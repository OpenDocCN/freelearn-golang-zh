- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Working with REST APIs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与REST API一起工作
- en: The subject of this chapter is the development of RESTful servers and clients
    with the Go programming language, which is one of the many areas where Go excels.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主题是使用Go编程语言开发RESTful服务器和客户端，Go在许多领域都表现出色。
- en: REST is an acronym for *REpresentational State Transfer* and is primarily an
    architecture for designing web services that offers a standardized efficient way
    for clients to access data and use the provided server functionality.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: REST是*表示状态转移*的缩写，主要是为设计网络服务提供了一种标准化的高效方式，使客户端能够访问数据并使用提供的服务器功能。
- en: RESTful services usually use the JSON format to exchange information, which
    is well supported by Go. REST is not tied to any operating system or system architecture
    and is not a protocol; however, to implement a RESTful service, we need to use
    a protocol such as HTTP or HTTPS as REST is an API convention built on the HTTP(S)
    protocol.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful服务通常使用JSON格式来交换信息，这得到了Go的良好支持。REST与任何操作系统或系统架构无关，也不是一种协议；然而，为了实现RESTful服务，我们需要使用HTTP或HTTPS等协议，因为REST是基于HTTP(S)协议的API约定。
- en: Although we are already familiar with most of the presented Go code, the ideas
    behind REST and the way Go code serves them are going to be new. The epicenter
    of the development of RESTful servers is the definition of the appropriate Go
    structures and the execution of the necessary marshaling and unmarshaling operations
    for supporting the exchange of JSON data between the clients and the server.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经熟悉了所展示的大多数Go代码，但REST背后的思想和Go代码实现它们的方式将会是新的。RESTful服务器开发的中心是定义适当的Go结构和执行必要的序列化和反序列化操作，以支持客户端和服务器之间JSON数据的交换。
- en: 'This truly important and practical chapter covers:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是一个非常重要且实用的章节，涵盖了：
- en: An introduction to REST
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST简介
- en: Developing RESTful servers and clients
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发RESTful服务器和客户端
- en: Creating a functional RESTful server
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建功能性的RESTful服务器
- en: Creating a RESTful client
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建RESTful客户端
- en: An introduction to REST
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST简介
- en: 'Most modern web applications work by exposing their APIs and allowing clients
    to use these APIs to interact and communicate with them. Although REST is not
    tied to HTTP, most web services use HTTP as their underlying protocol. Additionally,
    although REST can work with any data format, usually REST means **JSON over HTTP**
    because most of the time, data is exchanged in JSON format in RESTful services.
    There are also times when data is exchanged in plain text format, usually when
    the exchanged data is simple and there is no practical need for JSON records.
    Due to the way a RESTful service works, it should have an architecture that follows
    the subsequent principles:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代网络应用程序通过公开它们的API，并允许客户端使用这些API与它们进行交互和通信来工作。尽管REST与HTTP没有直接关联，但大多数网络服务使用HTTP作为其底层协议。此外，尽管REST可以与任何数据格式一起工作，但通常REST意味着**通过HTTP的JSON**，因为在大多数情况下，RESTful服务中的数据交换是以JSON格式进行的。也有时候数据是以纯文本格式交换的，通常当交换的数据很简单且没有实际需要JSON记录时。由于RESTful服务的工作方式，它应该有一个遵循以下原则的架构：
- en: Client-server design
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端-服务器设计
- en: Stateless implementation (each interaction does not depend on previous ones)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态实现（每次交互不依赖于之前的交互）
- en: Cacheable
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可缓存
- en: Uniform interface
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统一接口
- en: Layered system
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分层系统
- en: 'According to the HTTP protocol, we can perform the following operations on
    an HTTP server:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 根据HTTP协议，我们可以在HTTP服务器上执行以下操作：
- en: '`POST`: This is used for creating new resources.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：这用于创建新资源。'
- en: '`GET`: This is used for reading (getting) existing resources.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：这用于读取（获取）现有资源。'
- en: '`PUT`: This is used for updating existing resources. As a convention, a `PUT`
    request should contain the full and updated version of an existing resource.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：这用于更新现有资源。按照惯例，一个`PUT`请求应该包含现有资源的完整和更新版本。'
- en: '`DELETE`: This is used for deleting existing resources.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：这用于删除现有资源。'
- en: '`PATCH`: This is used for updating existing resources. A `PATCH` request only
    contains the modifications to an existing resource.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`：这用于更新现有资源。一个`PATCH`请求只包含对现有资源的修改。'
- en: 'The important thing here is that everything you do, especially when it is out
    of the ordinary, must be well documented. As a reference, keep in mind that the
    HTTP methods supported by Go are defined as constants in the `net/http` package:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是，你做的每一件事，尤其是当你做的是非同寻常的事情时，都必须有很好的文档记录。作为一个参考，请记住，Go支持的HTTP方法被定义为`net/http`包中的常量：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There also exist conventions regarding the returning HTTP status code of each
    client request. The most popular HTTP status codes as well as their meanings are
    the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个客户端请求返回的 HTTP 状态码也存在一些约定。以下是最流行的 HTTP 状态码及其含义：
- en: '`200` means that everything went well and the specified action was executed
    successfully.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`200` 表示一切顺利，指定的操作已成功执行。'
- en: '`201` means that the wanted resource was created.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`201` 表示所需的资源已创建。'
- en: '`202` means that the request was accepted and is currently being processed.
    This is usually used when an action takes too much time to complete.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`202` 表示请求已被接受，目前正在处理中。这通常用于动作需要太长时间才能完成的情况。'
- en: '`301` means that the requested resource has been moved permanently—the new
    URI should be part of the response. This is rarely used in RESTful services because
    API versioning is used instead.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`301` 表示请求的资源已永久移动——新的 URI 应该包含在响应中。这在 RESTful 服务中很少使用，因为 API 版本控制被用来代替。'
- en: '`400` means that there was a bad request and that you should change your initial
    request before sending it again.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`400` 表示请求有误，你应该在再次发送之前更改你的初始请求。'
- en: '`401` means that the client tried to access a protected request without authorization.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`401` 表示客户端尝试未经授权访问受保护的请求。'
- en: '`403` means that the client does not have the required permissions for accessing
    a resource even though the client is properly authorized. In UNIX terminology,
    `403` means that the current user does not have the required privileges to perform
    an action.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`403` 表示客户端即使已经正确授权，也没有访问资源的必要权限。在 UNIX 术语中，`403` 表示当前用户没有执行该操作的必要权限。'
- en: '`404` means that the resource was not found.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`404` 表示未找到资源。'
- en: '`405` means that the client used a method that is not allowed by the type of
    resource.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`405` 表示客户端使用了资源类型不允许的方法。'
- en: '`500` means internal server error—it probably indicates a server failure.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`500` 表示内部服务器错误——这通常表明服务器出现故障。'
- en: If you want to learn more about the HTTP protocol, you should visit RFC 7231
    at [https://datatracker.ietf.org/doc/html/rfc7231](https://datatracker.ietf.org/doc/html/rfc7231).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于 HTTP 协议的信息，你应该访问 RFC 7231，网址为 [https://datatracker.ietf.org/doc/html/rfc7231](https://datatracker.ietf.org/doc/html/rfc7231)。
- en: Now, let me tell you a personal story. A couple of years ago, I was developing
    a small RESTful client for a project I was working on. The client connected to
    a given server in order to get a list of usernames. For each username, I had to
    get a list of login and logout times by hitting another endpoint.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我给你讲一个个人故事。几年前，我正在为一个我正在工作的项目开发一个小型的 RESTful 客户端。客户端连接到指定的服务器以获取用户名列表。对于每个用户名，我必须通过访问另一个端点来获取登录和登出时间。
- en: What I can tell you from my personal experience is that most of the Go code
    was not about interacting with the RESTful server but about taking care of the
    data, transforming it to the desired format, and storing it in a database—the
    two most tricky tasks that I needed to perform were getting a date and time in
    UNIX epoch format and truncating the information about the minutes and seconds
    from that epoch time, as well as inserting a new record into a database table
    after making sure that a record with the same data was not already stored in that
    database. So, expect that most of the code you are going to write is going to
    be about confronting the logic of the service, which is true not only for RESTful
    services but for all services in general.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从我的个人经验中，我可以告诉你，大部分的 Go 代码并不是关于与 RESTful 服务器交互，而是关于处理数据，将其转换为所需的格式，并将其存储在数据库中——我需要执行的两大棘手任务是获取
    UNIX 纪元格式的日期和时间，以及从该纪元时间中截断关于分钟和秒的信息，以及确保具有相同数据的记录尚未存储在该数据库中后，将新记录插入数据库表。因此，预期你将要编写的代码的大部分将关于面对服务的逻辑，这不仅适用于
    RESTful 服务，也适用于所有服务。
- en: The first section of this chapter contains general yet essential information
    about programming RESTful servers and clients.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一部分包含有关编程 RESTful 服务器和客户端的通用但基本的信息。
- en: Developing RESTful servers and clients
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发 RESTful 服务器和客户端
- en: 'This section is going to develop a RESTful server and a client for that server
    using the functionality of the Go standard library to understand how things really
    work behind the scenes. The functionality of the server is described in the following
    list of endpoints:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将使用 Go 标准库的功能开发一个 RESTful 服务器及其客户端，以了解幕后实际是如何工作的。服务器功能在以下端点列表中描述：
- en: '`/add`: This endpoint is for adding new entries to the server.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/add`：此端点是用于向服务器添加新条目。'
- en: '`/delete`: This endpoint is used for deleting an existing entry.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/delete`：此端点用于删除现有条目。'
- en: '`/get`: This endpoint is for getting information about an entry that already
    exists.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/get`：此端点是用于获取已存在条目的信息。'
- en: '`/time`: This endpoint returns the current date and time and is mainly used
    for testing the operation of the RESTful server.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/time`：此端点返回当前日期和时间，主要用于测试RESTful服务器的操作。'
- en: '`/`: This endpoint is used for serving any request that is not a match to any
    other endpoint.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`：此端点用于处理不匹配任何其他端点的任何请求。'
- en: 'An alternative and more professional way of defining the endpoints would have
    been the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 定义端点的另一种替代和更专业的方法如下：
- en: '`/users/` with the `GET` method: Get a list of all users.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/users/` 使用`GET`方法：获取所有用户的列表。'
- en: '`/users/:id` with the `GET` method: Get information about the user with the
    given ID value.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/users/:id` 使用`GET`方法：获取具有给定ID值的用户信息。'
- en: '`/users/:id` with the `DELETE` method: Delete the user with the given ID.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/users/:id` 使用`DELETE`方法：删除具有给定ID的用户。'
- en: '`/users/` with the `POST` method: Create a new user.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/users/` 使用`POST`方法：创建新用户。'
- en: '`/users/:id` with either the `PATCH` or the `PUT` method: Update the user with
    the given ID value.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/users/:id` 使用`PATCH`或`PUT`方法：更新具有给定ID值的用户。'
- en: The implementation of the alternative way is left as an exercise for the reader—it
    should not be that difficult to implement it given that the Go code for the handlers
    is going to be the same and you must only redefine the part where we specify the
    handling of the endpoints.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 替代方法的实现留给读者作为练习——鉴于处理器的Go代码将相同，并且你只需重新定义我们指定端点处理的部分，这应该不难实现。
- en: The next subsection presents the implementation of the RESTful server.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将介绍RESTful服务器的实现。
- en: A RESTful server
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个RESTful服务器
- en: The purpose of the presented implementation is to understand how things work
    behind the scenes because the principles behind REST services remain the same.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 提出的实现目的是为了理解幕后的事情是如何运作的，因为REST服务的原则保持不变。
- en: The logic behind each handler function is simple. Each function reads user input
    and decides whether the given input and HTTP method are the desired ones before
    processing any data.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每个处理器函数背后的逻辑很简单。每个函数读取用户输入，并在处理任何数据之前决定给定的输入和HTTP方法是否是所需的。
- en: 'The principles of each client interaction are also simple: The server should
    send appropriate error messages and HTTP codes back to the client so that everyone
    knows what really happened. Lastly, everything should be documented to communicate
    in a common language.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每个客户交互的原则也很简单：服务器应向客户端发送适当的错误消息和HTTP状态码，以便每个人都知道真正发生了什么。最后，所有内容都应被记录下来，以便用一种共同的语言进行沟通。
- en: 'The code of the server, which is saved as `rServer.go`, is the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器代码，保存为`rServer.go`，如下所示：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is a structure that holds user data, so the use of JSON tags is mandatory
    as the JSON data format is different from the one we use in Go.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个存储用户数据的结构，因此必须使用JSON标签，因为JSON数据格式与我们使用的Go语言中的不同。
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `user` global variable holds the user data of the current interaction—this
    is the input for the `/add`, `/get`, and `/delete` endpoints and their simplistic
    implementations. As this global variable is shared by the entire program, our
    code is not concurrently safe, which is fine for a RESTful server used as a proof
    of concept.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`user`全局变量持有当前交互的用户数据——这是`/add`、`/get`和`/delete`端点及其简单实现的输入。由于此全局变量在整个程序中共享，我们的代码不是并发安全的，这对于用作概念证明的RESTful服务器来说是完全可以接受的。'
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A RESTful server is just an HTTP server, so we need to define the TCP port number
    the server listens to.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful服务器只是一个HTTP服务器，因此我们需要定义服务器监听的TCP端口号。
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code defines a global variable named `DATA` that holds the data
    of the service.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了一个名为`DATA`的全局变量，它包含服务的数据。
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is the default handler of the service. On a production server, the default
    handler might print instructions about the operation of the server as well as
    the list of available endpoints.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是服务的默认处理器。在生产服务器上，默认处理器可能会打印有关服务器操作以及可用端点的说明。
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`timeHandler()` is another simple handler that returns the current date and
    time—such modest handlers are usually used for testing the health of the server
    and are usually removed in the production version. A very popular endpoint with
    a similar purpose is `/health`, which is usually present in modern REST APIs with
    the purpose of providing a health status for the server, even in production.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeHandler()` 是另一个简单的处理器，它返回当前的日期和时间——这样的简单处理器通常用于测试服务器的健康状态，并且在生产版本中通常会被移除。一个具有类似目的的非常流行的端点是
    `/health`，它通常存在于现代 REST API 中，其目的是在即使在生产环境中也提供服务器的健康状态。'
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is the first time that you are seeing the `http.Error()` function. The
    `http.Error()` function sends a reply to the client request that includes the
    specified error message, which should be in plain text, as well as the desired
    HTTP code. You still need to write the data you want to send back to the client
    using an `fmt.Fprintf()` statement. However, `http.Error()` needs to be called
    last as we should not perform any more writes to `w` after using `http.Error()`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您第一次看到 `http.Error()` 函数。`http.Error()` 函数向客户端请求发送回复，包括指定的错误消息，该消息应为纯文本，以及所需的
    HTTP 状态码。您仍然需要使用 `fmt.Fprintf()` 语句编写要发送回客户端的数据。然而，`http.Error()` 需要最后调用，因为我们不应该在调用
    `http.Error()` 之后对 `w` 执行任何更多的写入操作。
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We try to read all data from the client at once using `io.ReadAll()` and we
    make sure that we read the data without any errors by checking the value of the
    `d` variable returned by `io.ReadAll(r.Body)`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试一次性从客户端读取所有数据，使用 `io.ReadAll()`，并通过检查 `io.ReadAll(r.Body)` 返回的 `d` 变量的值来确保我们读取数据时没有错误。
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After reading the data from the client, we put it into the `user` global variable
    – although using global variables is not considered a good practice, I personally
    prefer to use global variables for important settings or data that needs to be
    shared among a Go source file when dealing with relatively small Go source code
    files. Where you want to store the data and what to do with it is decided by the
    server. There is no rule on how to interpret the data. Therefore, **the client
    should communicate with the server according to the wishes of the server**.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在从客户端读取数据后，我们将其放入 `user` 全局变量——尽管使用全局变量不被视为最佳实践，但我个人更喜欢在处理相对较小的 Go 源代码文件时使用全局变量来存储重要的设置或需要共享的数据。数据存储的位置以及如何处理数据由服务器决定。没有关于如何解释数据的规则。因此，**客户端应按照服务器的意愿与服务器通信**。
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the given `Username` field is not empty, add the new structure to the `DATA`
    map. Data persistence is not implemented for this sample server—each time you
    restart the RESTful server, the `DATA` map is initialized from scratch.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定的 `Username` 字段不为空，则将新的结构添加到 `DATA` 映射中。对于这个示例服务器，没有实现数据持久化——每次重新启动 RESTful
    服务器时，`DATA` 映射都会从头开始初始化。
- en: If the value of the `username` field is empty, then we cannot add it to the
    `DATA` map and the operation fails with an `http.StatusBadRequest` code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `username` 字段的值为空，则我们无法将其添加到 `DATA` 映射中，并且操作会以 `http.StatusBadRequest` 状态码失败。
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For the `/get` endpoint, we need to use `http.MethodGet`, so we have to make
    sure that this condition is met (`if r.Method != http.MethodGet`).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `/get` 端点，我们需要使用 `http.MethodGet`，因此我们必须确保满足这个条件（`if r.Method != http.MethodGet`）。
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After that, we still need to make sure that we can read the data from the client
    request without any issues.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们仍然需要确保我们可以无问题地从客户端请求中读取数据。
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Then, we use the client data and put it into a `User` structure (the `user`
    global variable). Once again, I have to mention that using a global variable for
    storing the data is a personal preference that works well for smaller source code
    files but should be avoided for larger programs.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用客户端数据并将其放入 `User` 结构（`user` 全局变量）。再次提醒，使用全局变量来存储数据是个人偏好，对于较小的源代码文件来说效果很好，但对于较大的程序应该避免使用。
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If the desired user record is found, we send it back to the client using the
    data stored in the `d` variable—remember that `d` was initialized in the `io.ReadAll(r.Body)`
    call and already contains a JSON record that is marshaled.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到了所需的用户记录，我们使用存储在 `d` 变量中的数据将其发送回客户端——记住，`d` 在 `io.ReadAll(r.Body)` 调用中初始化，并且已经包含了一个序列化的
    JSON 记录。
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Otherwise, we inform the client that the desired record was not found and return
    `http.StatusNotFound`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们通知客户所需的记录未找到，并返回 `http.StatusNotFound`。
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `DELETE` HTTP method looks like a rational choice when deleting a resource,
    hence the `r.Method != http.MethodDelete` check.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当删除资源时，`DELETE` HTTP方法看起来是一个合理的选择，因此有`r.Method != http.MethodDelete`的检查。
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Again, we read the client input and store it in the `d` variable.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们读取客户端输入并将其存储在`d`变量中。
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It is considered a good practice to keep additional logging information when
    deleting resources.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除资源时保留额外的日志信息被认为是一种良好的做法。
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For the delete process, we make sure that both the given username and password
    values are the same as the ones that exist in the `DATA` map before deleting the
    relevant entry.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于删除过程，我们在删除相关条目之前确保提供的用户名和密码值与`DATA`映射中存在的值相同。
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The previous code presents a technique for defining the TCP port number of a
    web server while having a default value at hand. So, if there are no command line
    arguments, the default value will be used. Otherwise, the value given as a command
    line argument is used.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码展示了一种在拥有默认值的同时定义Web服务器TCP端口号的技术。因此，如果没有命令行参数，将使用默认值。否则，将使用作为命令行参数给出的值。
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding code block includes the details and the options for the web server.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块包含了Web服务器的详细信息及选项。
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The previous code defines the endpoints of the web server—nothing special here
    as a RESTful server implements an HTTP server behind the scenes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码定义了Web服务器的端点——在这里没有特别之处，因为RESTful服务器在幕后实现了一个HTTP服务器。
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The last step is about running the web server with the predefined options, which
    is common practice. After that, we test the RESTful server using the `curl(1)`
    utility, which is very handy when we do not have a client and we want to test
    the operation of a RESTful server—the good thing is that `curl(1)` can send and
    receive JSON data.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是使用预定义的选项运行Web服务器，这是常见的做法。之后，我们使用`curl(1)`实用程序测试RESTful服务器，这在没有客户端且想要测试RESTful服务器操作时非常方便——好处是`curl(1)`可以发送和接收JSON数据。
- en: 'When working with a RESTful server, we need to add `-H ''Content-Type: application/json''`
    to `curl(1)` to specify that we are going to work using the JSON format. The `-d`
    option is used for passing data to a server and is equivalent to the `--data`
    option, whereas the `-v` option generates more verbose output if we need more
    details to understand what is going on.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '当与RESTful服务器一起工作时，我们需要在`curl(1)`中添加`-H ''Content-Type: application/json''`来指定我们将使用JSON格式进行操作。`-d`选项用于向服务器传递数据，相当于`--data`选项，而`-v`选项在需要更多详细信息来理解正在发生的事情时会产生更详细的输出。'
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first interaction with the RESTful server is to make sure that the server
    works as expected. The next interaction is for adding a new user to the server—the
    details of the user are in the `{"user": "mtsouk", "password" : "admin"}` JSON
    record:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '与RESTful服务器第一次交互是为了确保服务器按预期工作。接下来的交互是为服务器添加新用户——用户的详细信息在`{"user": "mtsouk",
    "password" : "admin"}` JSON记录中：'
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The previous output shows that `curl(1)` has successfully connected to the server
    (`localhost`) using the desired TCP port (`1234`).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出显示`curl(1)`已成功连接到服务器（`localhost`），并使用所需的TCP端口（`1234`）。
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The previous output shows that `curl(1)` is going to send data using the `POST`
    method and the length of the data is 40 bytes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出显示`curl(1)`将使用`POST`方法发送数据，数据长度为40字节。
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The previous output tells us that the data was sent and that the body of the
    server response is `0` bytes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出告诉我们数据已发送，并且服务器响应的主体为`0`字节。
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The last part of the output tells us that after sending the data to the server,
    the connection was closed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后部分告诉我们，在向服务器发送数据后，连接被关闭。
- en: 'If we try to add the same user, the RESTful server is not going to complain:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试添加相同的用户，RESTful服务器不会抱怨：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Although this behavior might not be perfect, it is good if it is documented.
    This is not allowed on a production server, but it is acceptable when experimenting.
    So, we are diverting from a standard practice here and you should not do that
    in production.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种行为可能并不完美，但如果进行了文档记录，那么它是好的。在生产服务器上这是不允许的，但在实验时是可以接受的。因此，我们在这里偏离了标准做法，你不应该在生产环境中这样做。
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'With the preceding command, we add another user as specified by `{"user": "mihalis",
    "password" : "admin"}`.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '使用上述命令，我们添加了另一个用户，其详细信息由`{"user": "mihalis", "password" : "admin"}`指定。'
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The previous output shows an erroneous interaction where `-H` is not followed
    by a value. Although the request is sent to the server, it is rejected because
    `/add` does not use the default HTTP method.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示了一个错误的交互，其中 `-H` 后面没有跟值。尽管请求已发送到服务器，但由于 `/add` 不使用默认的 HTTP 方法，它被拒绝。
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This time, the curl command is correct, but the HTTP method used is not set
    correctly. Therefore, the request is not served.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，curl 命令是正确的，但使用的 HTTP 方法设置不正确。因此，请求没有被服务。
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The previous two interactions use `/get` to get information about an existing
    user. However, only the second user is found.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个交互使用 `/get` 来获取现有用户的信息。然而，只找到了第二个用户。
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The last interaction successfully deletes the user specified by `{"user": "mtsouk",
    "password" : "admin"}`.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '最后一次交互成功删除了由 `{"user": "mtsouk", "password" : "admin"}` 指定的用户。'
- en: 'The output generated by the server process for all previous interactions would
    look like the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器进程为所有之前的交互生成的输出将如下所示：
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: So far, we have a working RESTful server that has been tested with the help
    of the `curl(1)` utility. The next section is about developing a command line
    client for the RESTful server.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有一个可以工作的 RESTful 服务器，它已经通过 `curl(1)` 工具进行了测试。下一节是关于为 RESTful 服务器开发命令行客户端。
- en: A RESTful client
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个 RESTful 客户端
- en: 'This subsection illustrates the development of a client for the RESTful server
    developed previously. However, in this case, the client acts as a testing program
    that tries the capabilities of the RESTful server—later in this chapter, you are
    going to learn how to write proper clients using the cobra library. So, the code
    of the client, which can be found in `rClient.go`, is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节说明了之前开发的 RESTful 服务器的客户端开发。然而，在这种情况下，客户端充当测试程序，尝试 RESTful 服务器的功能——在本章的后面，你将学习如何使用
    cobra 库编写正确的客户端。因此，可以在 `rClient.go` 中找到客户端的代码，如下所示：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This same structure is found in the server implementation and is used for data
    exchange.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这种相同的结构在服务器实现中也可以找到，并用于数据交换。
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we predefine three `User` variables that are going to be used during testing.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们预先定义了三个将要用于测试的 `User` 变量。
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The previous constants define the endpoints that are going to be used.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的常量定义了将要使用的端点。
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We prepare a request that is going to access `/delete` using the `DELETE` HTTP
    method.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备了一个请求，将使用 `DELETE` HTTP 方法访问 `/delete`。
- en: '[PRE40]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is the correct way to specify that we want to use JSON data when interacting
    with the server.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是指定在与服务器交互时使用 JSON 数据的正确方式。
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Then, we send the request and wait for the server response using the `Do()`
    method with a 15-second timeout.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `Do()` 方法并设置 15 秒的超时时间来发送请求并等待服务器响应。
- en: '[PRE42]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The reason for putting that `fmt.Print()` here is that we want to get informed
    about the server response even if there is an error in the interaction.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里放置 `fmt.Print()` 的原因是，即使交互中存在错误，我们也想了解服务器的响应。
- en: '[PRE43]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `resp.StatusCode` value specifies the response HTTP code from `/delete`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`resp.StatusCode` 的值指定了 `/delete` 的响应 HTTP 状态码。'
- en: '[PRE44]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The previous code is going to access `/get` using the `GET` HTTP method.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将使用 `GET` HTTP 方法访问 `/get`。
- en: '[PRE45]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We specify that we are going to interact with the server using the JSON format
    using `Header.Set()`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `Header.Set()` 指定我们将使用 JSON 格式与服务器交互。
- en: '[PRE46]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The previous statements define a timeout period for the HTTP client in case
    the server is too busy responding.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语句为 HTTP 客户端定义了一个超时时间，以防服务器响应过于繁忙。
- en: '[PRE47]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The previous code sends the client request to the server using `c.Do(req)` and
    saves the server response in `resp` and the `error` value in `err`. If the value
    of `resp` is `nil`, then the server response is empty, which is an error condition.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用 `c.Do(req)` 将客户端请求发送到服务器，并将服务器响应保存到 `resp` 中，将错误值保存到 `err` 中。如果 `resp`
    的值为 `nil`，则表示服务器响应为空，这是一个错误条件。
- en: '[PRE48]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The value of `resp.StatusCode`, which is specified and transferred by the RESTful
    server, determines whether the interaction was successful in an HTTP sense (logically)
    or not.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`resp.StatusCode` 的值，由 RESTful 服务器指定和传递，决定了交互在 HTTP 意义上（逻辑上）是否成功。'
- en: '[PRE49]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We are going to access `/add` using the `POST` HTTP method. We can use `http.MethodPost`
    instead of `POST`. As stated earlier in this chapter, there exist relevant global
    variables in http for the remaining HTTP methods (`http.MethodGet`, `http.MethodDelete`,
    `http.MethodPut`, etc.) and it is recommended that we use them for portability.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `POST` HTTP 方法访问 `/add`。我们可以使用 `http.MethodPost` 而不是 `POST`。如本章前面所述，http
    中存在用于剩余 HTTP 方法的相关全局变量（`http.MethodGet`、`http.MethodDelete`、`http.MethodPut` 等），并且建议我们使用它们以提高可移植性。
- en: '[PRE50]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As before, we specify that we are going to interact with the server using the
    JSON format.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们指定我们将使用 JSON 格式与服务器交互。
- en: '[PRE51]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Once again, we define a timeout period for the client in case the server is
    too busy replying.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们为客户端定义了一个超时时间，以防服务器响应过于繁忙。
- en: '[PRE52]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `addEndpoint()` function is for testing the `/add` endpoint using the `POST`
    method.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`addEndpoint()` 函数用于使用 `POST` 方法测试 `/add` 端点。'
- en: '[PRE53]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We are going to access the `/time` endpoint using the `POST` HTTP method.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `POST` HTTP 方法访问 `/time` 端点。
- en: '[PRE54]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As before, we define a timeout period for the client in case the server is too
    busy responding.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们为客户端定义了一个超时时间，以防服务器响应过于繁忙。
- en: '[PRE55]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `timeEndpoint()` function is for testing the `/time` endpoint—note that
    this endpoint does not require any data from the client, so the client request
    is empty. The server is going to return a string with the current time and date
    of the server.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeEndpoint()` 函数用于测试 `/time` 端点——请注意，此端点不需要从客户端获取任何数据，因此客户端请求为空。服务器将返回一个包含服务器当前时间和日期的字符串。'
- en: '[PRE56]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We are going to access `/` using the `POST` HTTP method.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `POST` HTTP 方法访问 `/`。
- en: '[PRE57]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: It is considered a good practice to have a timeout period on the client side
    in case there are delays in the server response.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器响应延迟的情况下，在客户端设置超时时间被认为是一种良好的实践。
- en: '[PRE58]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `slashEndpoint()` function is for testing the default endpoint in the server—note
    that this endpoint does not require any data from the client.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`slashEndpoint()` 函数用于测试服务器中的默认端点——请注意，此端点不需要从客户端获取任何数据。'
- en: 'The next step is the implementation of the `main()` function, which uses all
    previous functions to visit the RESTful server endpoints:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实现 `main()` 函数，它使用所有前面的函数来访问 RESTful 服务器端点：
- en: '[PRE59]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `server` variable holds the server address and the port number that are
    going to be used.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`server` 变量包含将要使用的服务器地址和端口号。'
- en: '[PRE60]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: All the previous code is used for testing the `/add` endpoint using various
    types of data.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前一部分代码都是用于使用各种类型的数据测试 `/add` 端点。
- en: '[PRE61]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: All the previous code is used for testing the `/get` endpoint using various
    types of input. We only test for the return code because the HTTP code specifies
    the success or failure of the operation.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前一部分代码都是用于使用各种类型的输入测试 `/get` 端点。我们只测试返回代码，因为 HTTP 状态码指定了操作的成功或失败。
- en: '[PRE62]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: All the previous code is used for testing the `/delete` endpoint using various
    types of input. Once again, we print the HTTP code of the interaction because
    the value of the HTTP code specifies the success or failure of the client request.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前一部分代码都是用于使用各种类型的输入测试 `/delete` 端点。再次，我们打印交互的 HTTP 状态码，因为 HTTP 状态码的值指定了客户端请求的成功或失败。
- en: '[PRE63]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The previous code tests the `/time` endpoint—it prints the HTTP code as well
    as the rest of the server response.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码测试了 `/time` 端点——它打印了 HTTP 状态码以及服务器响应的其余部分。
- en: '[PRE64]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The last part of the program tries to connect to an endpoint that does not exist
    to verify the correct operation of the default handler function.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最后部分尝试连接到一个不存在的端点，以验证默认处理函数的正确操作。
- en: 'Running `rClient.go` and interacting with `rServer.go` produces the next kind
    of output:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `rClient.go` 并与 `rServer.go` 交互会产生以下类型的输出：
- en: '[PRE65]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The previous part is related to the testing of the `/add` endpoint. The first
    two users were successfully added, whereas the third user (`var u3 = User{"",
    "pass"}`) was not added because it does not contain all the required information.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 前一部分与 `/add` 端点的测试相关。前两个用户成功添加，而第三个用户（`var u3 = User{"", "pass"}`）没有添加，因为它不包含所有必需的信息。
- en: '[PRE66]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The previous part is related to the testing of the `/get` endpoint. The data
    of the first two users with the usernames `admin` and `tsoukalos` was successfully
    returned, whereas the user stored in the `u3` variable was not found.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 前一部分与 `/get` 端点的测试相关。用户名为 `admin` 和 `tsoukalos` 的前两个用户的数据成功返回，而存储在 `u3` 变量中的用户未找到。
- en: '[PRE67]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The previous output is related to the testing of the `/delete` endpoint. The
    `admin` and `tsoukalos` users were deleted. However, trying to delete `admin`
    for the second time failed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出与`/delete`端点的测试相关。`admin`和`tsoukalos`用户已被删除。然而，尝试第二次删除`admin`失败了。
- en: '[PRE68]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Similarly, the previous part is related to the testing of the `/time` endpoint.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，前一部分与`/time`端点的测试相关。
- en: '[PRE69]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The last part of the output is related to the operation of the default handler.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后一部分与默认处理器的操作相关。
- en: It is important to realize that `rClient.go` can successfully interact with
    every RESTful server that supports the same endpoints without knowing the implementation
    details of the RESTful server.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到`rClient.go`可以成功与支持相同端点的每个RESTful服务器进行交互，而无需了解RESTful服务器的实现细节。
- en: So far, both the RESTful server and the client can interact with each other.
    However, neither of them performs a real job. The next section shows how to develop
    a real-world RESTful server using `gorilla/mux` and a database backend for storing
    data.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，RESTful服务器和客户端可以相互交互。然而，它们都没有执行真正的任务。下一节将展示如何使用`gorilla/mux`和数据库后端来存储数据开发一个真实的RESTful服务器。
- en: Creating a functional RESTful server
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建功能性的RESTful服务器
- en: This section illustrates how to develop a RESTful server in Go given a REST
    API. The biggest difference between the presented RESTful service and the statistics
    application created in *Chapter 9*, *Building Web Services*, is that the RESTful
    service uses JSON messages for interacting with its clients, whereas the statistics
    application interacts and works using plain text messages.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 本节说明了在给定REST API的情况下如何使用Go开发RESTful服务器。所提供的RESTful服务与第9章中创建的统计应用程序之间最大的区别是，RESTful服务使用JSON消息与其客户端进行交互，而统计应用程序通过纯文本消息进行交互和工作。
- en: If you are thinking of using `net/http` for the implementation of the RESTful
    server, please do not do so without first thinking about the requirements of your
    server! This implementation uses the `gorilla/mux` package, which is a much better
    choice because it supports subrouters – more about that in the *Using gorilla/mux*
    subsection. However, `net/http` is still powerful and can be useful for many REST
    requirements.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算使用`net/http`来实现RESTful服务器，请在考虑你的服务器需求之前不要这样做！此实现使用`gorilla/mux`包，这是一个更好的选择，因为它支持子路由——更多关于这一点在*使用gorilla/mux*子节中。然而，`net/http`仍然非常强大，并且对于许多REST需求可能很有用。
- en: The purpose of the RESTful server is to implement a login/authentication system.
    The purpose of the login system is to keep track of the users who are logged in,
    as well as their permissions. The system comes with a default administrator user
    named `admin`—the default password is also `admin` and you should change it. The
    application stores its data in an SQLite3 database, which means that if you restart
    it, the list of existing users is read from that database and is not lost.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful服务器的目的是实现一个登录/认证系统。登录系统的目的是跟踪已登录的用户以及他们的权限。该系统附带一个名为`admin`的默认管理员用户——默认密码也是`admin`，你应该更改它。应用程序将其数据存储在SQLite3数据库中，这意味着如果你重新启动它，现有用户列表将从该数据库读取，而不会丢失。
- en: The REST API
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST API
- en: The API of an application helps you implement the functionality that you have
    in mind. However, this is a job for the client, not the server. The job of the
    server is to facilitate the job of its clients as much as possible by supporting
    a simple yet fully working functionality through a properly defined and implemented
    REST API. Make sure that you understand that before trying to develop and use
    a RESTful server.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的API有助于你实现你心中的功能。然而，这是一项客户端的工作，而不是服务器的工作。服务器的工作是通过通过适当定义和实现的REST API支持简单但完全工作的功能，尽可能多地促进其客户端的工作。在尝试开发和使用RESTful服务器之前，请确保你理解这一点。
- en: We are going to define the endpoints that are going to be used, the HTTP codes
    that are going to be returned, as well as the allowed method or methods. Creating
    a RESTful server based on a REST API for production is a serious job that should
    not be taken lightly. Creating a prototype to test and validate your ideas and
    designs is going to save you lots of time in the long run. Always begin with a
    prototype.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义将要使用的端点、将要返回的HTTP代码以及允许的方法或方法。基于REST API创建用于生产的RESTful服务器是一项严肃的工作，不应轻率对待。创建原型来测试和验证你的想法和设计将使你在长期内节省大量时间。始终从原型开始。
- en: 'The supported endpoints as well as the supported HTTP methods and the parameters
    are as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的端点以及支持的HTTP方法和参数如下：
- en: '`/`: This is used for catching and serving everything that is not a match.
    This endpoint works with all HTTP methods.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`: 这用于捕获和提供所有不匹配的内容。此端点与所有HTTP方法兼容。'
- en: '`/getall`: This is used for getting the full contents of the database. Using
    this requires a user with administrative privileges. This endpoint might return
    multiple JSON records and works with the `GET` HTTP method.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/getall`: 这用于获取数据库的全部内容。使用此功能需要具有管理权限的用户。此端点可能返回多个JSON记录，并支持`GET` HTTP方法。'
- en: '`/getid/username`: This is used for getting the ID of a user identified by
    their username, which is passed to the endpoint. This command should be issued
    by a user with administrative privileges and supports the `GET` HTTP method.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/getid/username`: 这用于获取通过用户名识别的用户ID，该ID被传递到端点。此命令应由具有管理权限的用户发出，并支持`GET` HTTP方法。'
- en: '`/username/ID`: This is used for deleting or getting information about the
    user with an ID equal to `ID`, depending on the HTTP method used. Therefore, the
    actual action that is going to be performed depends on the HTTP method used. The
    `DELETE` method deletes the user, whereas the `GET` method returns the user information.
    This endpoint should be issued by a user with administrative privileges.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/username/ID`: 这用于根据所使用的HTTP方法删除或获取ID等于`ID`的用户的信息。因此，将要执行的实际操作取决于所使用的HTTP方法。`DELETE`方法删除用户，而`GET`方法返回用户信息。此端点应由具有管理权限的用户发出。'
- en: '`/logged`: This is used for getting a list of all logged-in users. This endpoint
    might return multiple JSON records and requires the use of the `GET` HTTP method.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/logged`: 这用于获取所有已登录用户的列表。此端点可能返回多个JSON记录，并需要使用`GET` HTTP方法。'
- en: '`/update`: This is used for updating the username, password, or admin status
    of a user—the ID of the user in the database remains the same. This endpoint works
    with the `PUT` HTTP method only and the search for the user is based on the username.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/update`: 这用于更新用户的用户名、密码或管理员状态——数据库中用户的ID保持不变。此端点仅支持`PUT` HTTP方法，并且对用户的搜索基于用户名。'
- en: '`/login`: This is used for logging a user into the system, given a username
    and a password. This endpoint works with the `POST` HTTP method.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/login`: 这用于根据用户名和密码将用户登录到系统中。此端点支持`POST` HTTP方法。'
- en: '`/logout`: This is used for logging out a user, given a username and a password.
    This endpoint works with the `POST` HTTP method.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/logout`: 这用于根据用户名和密码注销用户。此端点支持`POST` HTTP方法。'
- en: '`/add`: This is used for adding a new user to the database. This endpoint works
    with the `POST` HTTP method and is issued by a user with administrative privileges.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/add`: 这用于将新用户添加到数据库中。此端点支持`POST` HTTP方法，并由具有管理权限的用户发出。'
- en: '`/time`: This is an endpoint used mainly for testing purposes. It is the only
    endpoint that does not work with JSON data, does not require a valid account,
    and works with all HTTP methods.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/time`: 这是一个主要用于测试目的的端点。它是唯一一个不与JSON数据兼容、不需要有效账户且与所有HTTP方法兼容的端点。'
- en: Now, let us discuss the capabilities and the functionality of the `gorilla/mux`
    package.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论`gorilla/mux`包的功能和功能。
- en: Using gorilla/mux
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用gorilla/mux
- en: The `gorilla/mux` package ([https://github.com/gorilla/mux](https://github.com/gorilla/mux))
    is a popular and powerful alternative to the default Go router that allows you
    to match incoming requests to their respective handler. Although there exist many
    differences between the default Go router (`http.ServeMux`) and `mux.Router` (the
    `gorilla/mux` router), the main difference is that `mux.Router` supports multiple
    conditions when matching a route with a handler function. This means that you
    can write less code to handle some options such as the HTTP method used.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`gorilla/mux`包([https://github.com/gorilla/mux](https://github.com/gorilla/mux))是默认Go路由器的流行且强大的替代品，允许您将传入请求与相应的处理程序匹配。尽管默认Go路由器(`http.ServeMux`)和`mux.Router`（`gorilla/mux`路由器）之间存在许多差异，但主要区别在于`mux.Router`在匹配路由与处理函数时支持多个条件。这意味着您可以用更少的代码处理一些选项，例如使用的HTTP方法。'
- en: 'Let us begin by presenting some matching examples—this functionality is not
    supported by the default Go router:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先通过一些匹配示例开始——默认Go路由器不支持此功能：
- en: '`r.HandleFunc("/url", UrlHandlerFunction)`: The previous command calls the
    `UrlHandlerFunction` function each time `/url` is visited.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r.HandleFunc("/url", UrlHandlerFunction)`: 前一个命令会在每次访问 `/url` 时调用 `UrlHandlerFunction`
    函数。'
- en: '`r.HandleFunc("/url", UrlHandlerFunction).Methods(http.MethodPut)`: This example
    shows how you can tell Gorilla to match a specific HTTP method (`PUT` in this
    case, which is defined by the use of `http.MethodPut`), which saves you from having
    to write code to do that manually.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r.HandleFunc("/url", UrlHandlerFunction).Methods(http.MethodPut)`: 这个例子展示了如何告诉
    Gorilla 匹配特定的 HTTP 方法（在这个例子中是 `PUT`，它通过使用 `http.MethodPut` 定义），这可以节省你手动编写代码来执行此操作。'
- en: '`mux.NotFoundHandler = http.HandlerFunc(handlers.DefaultHandler)`: With Gorilla,
    the right way to match anything that is not a match by any other path is by using
    `mux.NotFoundHandler`.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mux.NotFoundHandler = http.HandlerFunc(handlers.DefaultHandler)`: 使用 Gorilla，匹配任何其他路径都不匹配的内容的正确方法是通过使用
    `mux.NotFoundHandler`。'
- en: '`mux.MethodNotAllowedHandler = notAllowed`: If a method is not allowed for
    an existing route, it is handled with the help of `MethodNotAllowedHandler`. This
    is specific to `gorilla/mux`.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mux.MethodNotAllowedHandler = notAllowed`: 如果一个方法对于现有路由不被允许，它将通过 `MethodNotAllowedHandler`
    来处理。这是 `gorilla/mux` 的特定功能。'
- en: '`s.HandleFunc("/users/{id:[0-9]+}"), HandlerFunction)`: This last example shows
    that you can define a variable in a path using a name (`id`) and a pattern – Gorilla
    does the matching for you! If there is not a regular expression, then the match
    is going to be anything from the beginning slash to the next slash in the path.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s.HandleFunc("/users/{id:[0-9]+}"), HandlerFunction)`: 这个最后的例子表明，你可以使用名称（`id`）和模式在路径中定义一个变量——Gorilla
    会为你进行匹配！如果没有正则表达式，那么匹配将从路径中的第一个斜杠开始到下一个斜杠之间的任何内容。'
- en: Now, let us talk about another capability of `gorilla/mux`, which is subrouters.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来谈谈 `gorilla/mux` 的另一个功能，即子路由器。
- en: The use of subrouters
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子路由器的使用
- en: The server implementation uses subrouters. A *subrouter* is a nested route that
    will only be examined for potential matches if the parent route matches the parameters
    of the subrouter. The good thing is that the parent route can contain conditions
    that are common among all paths that are defined under a subrouter, which includes
    hosts, path prefixes, and, as it happens in our case, HTTP request methods. As
    a result, our subrouters are divided based on the common request method of the
    endpoints that follow. Not only does this optimize the request matchings, but
    it also makes the structure of the code easier to understand.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器实现使用了子路由器。一个 *子路由器* 是一个嵌套路由，只有当父路由与子路由器的参数匹配时，才会检查它是否有潜在的匹配。好处是父路由可以包含所有在子路由器下定义的路径的共同条件，包括主机、路径前缀，以及在我们的案例中，HTTP
    请求方法。因此，我们的子路由器是根据后续端点的公共请求方法来划分的。这不仅优化了请求匹配，还使得代码结构更容易理解。
- en: 'As an example, the subrouter for the `DELETE` HTTP method is as simple as the
    following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，用于 `DELETE` HTTP 方法的子路由器就像以下这样简单：
- en: '[PRE70]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The first statement is for defining the common characteristics of the subrouter,
    which in this case is the `http.MethodDelete` HTTP method, whereas the remaining
    statement, which in this case is the `deleteMux.HandleFunc(...)` one, is for defining
    the supported paths.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条语句用于定义子路由器的公共特性，在这个例子中是 `http.MethodDelete` HTTP 方法，而剩下的语句，在这个例子中是 `deleteMux.HandleFunc(...)`，用于定义支持的路径。
- en: Yes, `gorilla/mux` might be more difficult to use than the default Go router,
    but by now you should understand the benefits of the `gorilla/mux` package for
    working with HTTP services.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，`gorilla/mux` 可能比默认的 Go 路由器更难使用，但到目前为止，你应该已经理解了 `gorilla/mux` 包在处理 HTTP 服务时的好处。
- en: The next subsection briefly presents the Gin framework, which is an alternative
    to the `gorilla/mux` package.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节简要介绍了 Gin 框架，它是对 `gorilla/mux` 包的替代方案。
- en: The Gin HTTP framework
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gin HTTP 框架
- en: Gin is an open source web framework written in Go that can help you write powerful
    HTTP services. The Gin GitHub repository can be found at `https://github.com/gin-gonic/gin`.
    Gin uses `httprouter` as its HTTP router because `httprouter` is optimized for
    high performance and small memory usage. `httprouter` is an HTTP router, just
    like the default `mux` from the `net/http` package or the more advanced `gorilla/mux`.
    You can learn more about it at [https://github.com/julienschmidt/httprouter](https://github.com/julienschmidt/httprouter)
    and at [https://pkg.go.dev/github.com/julienschmidt/httprouter](https://pkg.go.dev/github.com/julienschmidt/httprouter).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Gin是一个用Go编写的开源Web框架，可以帮助你编写强大的HTTP服务。Gin的GitHub仓库可以在`https://github.com/gin-gonic/gin`找到。Gin使用`httprouter`作为其HTTP路由器，因为`httprouter`针对高性能和低内存使用进行了优化。`httprouter`是一个HTTP路由器，就像`net/http`包的默认`mux`或更高级的`gorilla/mux`。你可以在[https://github.com/julienschmidt/httprouter](https://github.com/julienschmidt/httprouter)和[https://pkg.go.dev/github.com/julienschmidt/httprouter](https://pkg.go.dev/github.com/julienschmidt/httprouter)了解更多关于它的信息。
- en: Gin versus Gorilla
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gin与Gorilla的比较
- en: The biggest difference between Gin and `gorilla/mux` is that `gorilla/mux` is
    just an HTTP router and nothing more, whereas Gin can do what `gorilla/mux` can
    plus JSON marshaling and unmarshaling, validation, customized response writing,
    and so on. Put simply, Gin can do many more things than `gorilla/mux`. In practice,
    you can consider Gin as being a higher-level framework than `gorilla/mux` with
    more capabilities.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Gin与`gorilla/mux`之间最大的区别在于`gorilla/mux`仅仅是一个HTTP路由器，没有其他功能，而Gin可以做到`gorilla/mux`所能做到的，包括JSON序列化和反序列化、验证、自定义响应写入等。简单来说，Gin能做的事情比`gorilla/mux`多得多。在实践中，你可以将Gin视为一个比`gorilla/mux`更高级的框架，具有更多功能。
- en: So, the question here is which one should you choose. It is not bad to try both
    starting with `gorilla/mux`. If `gorilla/mux` cannot do your job, then you definitely
    need to use Gin. Put simply, if performance is critical, if you want middleware
    support, or if want minimalistic and fast routing, then use Gin.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里的问题是你应该选择哪一个。从`gorilla/mux`开始尝试并不坏。如果`gorilla/mux`不能完成你的工作，那么你肯定需要使用Gin。简单来说，如果性能至关重要，如果你需要中间件支持，或者如果你想要最小化和快速的路由，那么请使用Gin。
- en: Working with the database
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与数据库交互
- en: In this subsection, we will show you how we work with the SQLite database that
    supports the functionality of the RESTful server. The relevant file is `./server/restdb.go`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将向您展示我们如何与支持RESTful服务器功能的SQLite数据库进行交互。相关文件是`./server/restdb.go`。
- en: The RESTful server itself knows nothing about the SQLite database. All related
    functionality is kept in the `restdb.go` file, which means that if you change
    the database, the handler functions do not have to know about it.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful服务器本身对SQLite数据库一无所知。所有相关功能都保存在`restdb.go`文件中，这意味着如果你更改数据库，处理函数不需要知道这一点。
- en: 'The database name, the database table, and the `admin` user are created using
    the next `create_db.sql` SQL file:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库名称、数据库表和`admin`用户是通过下一个`create_db.sql` SQL文件创建的：
- en: '[PRE71]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'You can use `create_db.sql` as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`create_db.sql`如下：
- en: '[PRE72]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We can verify that the `users` table is created and contains the desired entry
    as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证`users`表已创建并包含所需的条目，如下所示：
- en: '[PRE73]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We are going to present the most important database-related functions, beginning
    with `OpenConnection()`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍最重要的数据库相关函数，从`OpenConnection()`开始：
- en: '[PRE74]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: As we need to interact with SQLite3 all the time, we created a helper function
    that returns an `*sql.DB` variable, which is an open connection to SQLite3\. `Filename`
    is a global variable that specifies the SQLite3 database file that is going to
    be used.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要始终与SQLite3进行交互，我们创建了一个辅助函数，该函数返回一个`*sql.DB`变量，这是一个打开的SQLite3连接。`Filename`是一个全局变量，指定了将要使用的SQLite3数据库文件。
- en: 'Next, we present the `DeleteUser()` function:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们介绍`DeleteUser()`函数：
- en: '[PRE75]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The preceding code is how we use `OpenConnection()` to get a database connection
    to work with.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码展示了我们如何使用`OpenConnection()`来获取数据库连接并进行操作。
- en: '[PRE76]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Here, we use the `FindUserID()` helper function to make sure that the user with
    the given user ID exists in the database. If the user does not exist, the function
    stops and returns `false`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`FindUserID()`辅助函数来确保具有给定用户ID的用户存在于数据库中。如果用户不存在，函数将停止并返回`false`。
- en: '[PRE77]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This is the actual SQL statement for deleting the user. We use `Prepare()` to
    construct the required SQL statement that we execute using `Exec()`. The `$1`
    in `Prepare()` denotes a parameter that is going to be given in `Exec()`. If we
    wanted to have more parameters, we should have named them `$2`, `$3`, and so on.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这是删除用户的实际 SQL 语句。我们使用 `Prepare()` 来构建所需的 SQL 语句，然后使用 `Exec()` 执行。`Prepare()`
    中的 `$1` 表示将在 `Exec()` 中给出的参数。如果我们想有更多参数，我们应该将它们命名为 `$2`、`$3` 等。
- en: '[PRE78]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This is where the implementation of the `DeleteUser()` function ends. The execution
    of the `stmt.Exec(ID)` statement is what deletes a user from the database.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `DeleteUser()` 函数的实现结束的地方。执行 `stmt.Exec(ID)` 语句会从数据库中删除用户。
- en: 'The `ListAllUsers()` function, which is presented next, returns a slice of
    `User` elements, which holds all users found in the RESTful server:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个展示的 `ListAllUsers()` 函数返回一个 `User` 元素切片，它包含在 RESTful 服务器中找到的所有用户：
- en: '[PRE79]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: As the `SELECT` query requires no parameters, we use `Query()` to run it instead
    of `Prepare()` and `Exec()`. Keep in mind that this is a query that most likely
    returns multiple records.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `SELECT` 查询不需要参数，我们使用 `Query()` 来运行它，而不是 `Prepare()` 和 `Exec()`。请注意，这很可能是一个返回多条记录的查询。
- en: '[PRE80]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This is how we read the values from a single record returned by the SQL query.
    First, we define multiple variables for each one of the returned values and then
    we pass their pointers to `Scan()`. The `rows.Next()` method keeps returning records
    as long as there are new results in the database.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们从 SQL 查询返回的单个记录中读取值的方式。首先，我们为每个返回值定义多个变量，然后将它们的指针传递给 `Scan()`。只要数据库中有新的结果，`rows.Next()`
    方法就会继续返回记录。
- en: '[PRE81]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: So, as mentioned before, a slice of `User` structures is returned from `ListAllUsers()`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如之前提到的，`ListAllUsers()` 从 `User` 结构体切片中返回。
- en: 'Lastly, we are going to present the implementation of `IsUserValid()`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将展示 `IsUserValid()` 的实现：
- en: '[PRE82]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This is a common pattern: we call `OpenConnection()` and wait to get a connection
    to use before continuing.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常见的模式：我们调用 `OpenConnection()` 并等待获取一个连接来使用，然后再继续。
- en: '[PRE83]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Here, we pass our parameter to `Query()` without using `Prepare()` and `Exec()`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们直接将参数传递给 `Query()`，而没有使用 `Prepare()` 和 `Exec()`。
- en: '[PRE84]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Next, we create the required parameters to keep the return values of the SQL
    query.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建所需的参数以保留 SQL 查询的返回值。
- en: '[PRE85]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Once again, the `for` loop keeps running for as long as `rows.Next()` returns
    new records.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`for` 循环会一直运行，直到 `rows.Next()` 返回新的记录。
- en: '[PRE86]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'This is an important point: not only should the given user exist, but the given
    password should be the same as the one stored in the database for the given user
    to be valid.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的观点：不仅给定的用户必须存在，而且给定的密码必须与数据库中存储的给定用户的密码相同，才能使用户有效。
- en: '[PRE87]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: You can view the rest of the `restdb.go` source code on your own. Most functions
    are like the ones presented here. The code of `restdb.go` is going to be used
    in the implementation of the RESTful server that is presented next.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自己查看 `restdb.go` 的其余源代码。大多数函数与这里展示的类似。`restdb.go` 的代码将被用于实现接下来展示的 RESTful
    服务器。
- en: Implementing the RESTful server
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 RESTful 服务器
- en: We are now ready to begin explaining the implementation of the RESTful server.
    The server code is split into three files that belong to the `main` package. So,
    apart from `restdb.go`, we have `main.go` and `handlers.go`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备开始解释 RESTful 服务器的实现。服务器代码分为三个属于 `main` 包的文件。因此，除了 `restdb.go` 之外，我们还有
    `main.go` 和 `handlers.go`。
- en: The main reason for doing so is to not have to work with huge source code files
    and to separate the functionality of the server logically.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的主要原因是不必处理巨大的源代码文件，并且从逻辑上分离服务器的功能。
- en: 'The most important part of `main.go`, which belongs to the `main()` function,
    is the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.go` 中最重要的部分属于 `main()` 函数，如下所示：'
- en: '[PRE88]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: So, we define the default handler function. Although this is not necessary,
    it is a good practice to have such a handler.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义了默认的处理函数。尽管这不是必需的，但拥有这样一个处理函数是一种良好的实践。
- en: '[PRE89]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The `MethodNotAllowedHandler` handler is executed when you try to visit an endpoint
    using an unsupported HTTP method. The actual implementation of the handler is
    found in `handlers.go`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试使用不支持的 HTTP 方法访问端点时，会执行 `MethodNotAllowedHandler` 处理器。该处理器的实际实现位于 `handlers.go`
    文件中。
- en: '[PRE90]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `/time` endpoint is supported by all HTTP methods, so it does not belong
    to any subrouter.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`/time` 端点支持所有 HTTP 方法，因此它不属于任何子路由器。'
- en: '[PRE91]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: First, we define a subrouter for the `GET` HTTP method along with the supported
    endpoints. Remember that `gorilla/mux` is responsible for making sure that only
    `GET` requests are going to be served by the `getMux` subrouter.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个用于 `GET` HTTP 方法的子路由器，以及支持的端点。记住，`gorilla/mux` 负责确保只有 `GET` 请求将通过
    `getMux` 子路由器提供服务。
- en: '[PRE92]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: After that, we define a subrouter for `PUT` requests.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们定义了一个用于 `PUT` 请求的子路由器。
- en: '[PRE93]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Then, we define the subrouter for `POST` requests.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义了用于 `POST` 请求的子路由器。
- en: '[PRE94]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The last subrouter is for `DELETE` HTTP methods. The code in `gorilla/mux` is
    responsible for choosing the correct subrouter based on the details of the client
    request.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个子路由器用于 `DELETE` HTTP 方法。`gorilla/mux` 中的代码负责根据客户端请求的详细信息选择正确的子路由器。
- en: '[PRE95]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The HTTP server is executed as a goroutine because the program supports signal
    handling—refer to *Chapter 8*, *Go Concurrency*, for more details.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 服务器作为 goroutine 执行，因为程序支持信号处理——有关更多详细信息，请参阅 *第 8 章*，*Go 并发*。
- en: '[PRE96]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Last, we add signal handling for gracefully terminating the HTTP server. The
    `sig := <-sigs` statement prevents the `main()` function from exiting unless an
    `os.Interrupt` signal is received.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了信号处理，以便优雅地终止 HTTP 服务器。`sig := <-sigs` 语句防止 `main()` 函数在没有接收到 `os.Interrupt`
    信号的情况下退出。
- en: 'The `handlers.go` file contains the implementations for the handler functions
    and is also part of the `main` package—its most important parts are the following:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`handlers.go` 文件包含了处理函数的实现，也是 `main` 包的一部分——其最重要的部分如下：'
- en: '[PRE97]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This handler is for the `/add` endpoint. The server reads the client input using
    `io.ReadAll()` and makes sure that the `io.ReadAll()` call was successful.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 此处理程序用于 `/add` 端点。服务器使用 `io.ReadAll()` 读取客户端输入，并确保 `io.ReadAll()` 调用成功。
- en: '[PRE98]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Then, the code makes sure that the body of the client request is not empty.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码确保客户端请求的正文不为空。
- en: '[PRE99]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: As the `/add` endpoint requires two `User` structures, the previous code uses
    `json.Unmarshal()` to put them into a `[]User` variable—this means that the client
    should send these two JSON records using an array.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `/add` 端点需要两个 `User` 结构体，之前的代码使用 `json.Unmarshal()` 将它们放入 `[]User` 变量中——这意味着客户端应该使用数组发送这两个
    JSON 记录。
- en: '[PRE100]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: If the user issuing the command does not have administrative privileges, then
    the request fails. `IsUserAdmin()` is implemented in `restdb.go` as it has to
    do with the data stored in the database.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行命令的用户没有管理权限，则请求失败。`IsUserAdmin()` 在 `restdb.go` 中实现，因为它与数据库中存储的数据有关。
- en: '[PRE101]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Otherwise, `InsertUser()` inserts the desired user into the database.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，`InsertUser()` 将所需用户插入到数据库中。
- en: Last, we present the handler for the `/getall` endpoint.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们展示了 `/getall` 端点的处理程序。
- en: '[PRE102]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Once again, we read the data from the client using `io.ReadAll(r.Body)` and
    we make sure that the process is error-free by examining the `err` variable.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们使用 `io.ReadAll(r.Body)` 从客户端读取数据，并通过检查 `err` 变量确保整个过程没有错误。
- en: '[PRE103]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Here, we put the client data into a `User` variable. The `/getall` endpoint
    requires a single `User` record as input.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将客户端数据放入 `User` 变量中。`/getall` 端点需要一个单独的 `User` 记录作为输入。
- en: '[PRE104]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Only admin users can visit `/getall` and get the list of all users, hence the
    use of `IsUserAdmin()`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 只有管理员用户可以访问 `/getall` 并获取所有用户的列表，因此使用了 `IsUserAdmin()`。
- en: '[PRE105]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The last part of the code is about getting the desired data from the database
    and sending it to the client using the `SliceToJSON(ListAllUsers(), rw)` call.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后部分是关于从数据库获取所需数据，并使用 `SliceToJSON(ListAllUsers(), rw)` 调用将其发送到客户端。
- en: Feel free to put each handler into a separate Go file. The general idea is that
    if you have many handler functions, using a separate file for each handler function
    is a good practice. Among other things, it allows multiple developers to work
    on multiple handler functions without bothering each other.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 随意将每个处理程序放入单独的 Go 文件中。一般思路是，如果你有很多处理函数，为每个处理函数使用单独的文件是一种良好的实践。除此之外，它还允许多个开发者同时在不打扰彼此的情况下工作多个处理函数。
- en: Before developing a proper command line client, it would be a good idea to test
    the RESTful server using `curl(1)`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发合适的命令行客户端之前，使用 `curl(1)` 测试 RESTful 服务器是一个好主意。
- en: Testing the RESTful server
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 RESTful 服务器
- en: 'This subsection shows how to test the RESTful server using the `curl(1)` utility.
    You should test the RESTful server as much and as extensively as possible to find
    bugs or unwanted behavior. As we use three files for the server implementation,
    we need to run it as `go run main.go restdb.go handlers.go`. We begin by testing
    the `/time` handler, which works with all HTTP methods:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节展示了如何使用`curl(1)`实用程序测试RESTful服务器。您应该尽可能多地测试RESTful服务器，以查找错误或不受欢迎的行为。由于我们使用三个文件来实现服务器，我们需要以`go
    run main.go restdb.go handlers.go`的方式运行它。我们首先测试`/time`处理器，它适用于所有HTTP方法：
- en: '[PRE106]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Next, we test the default handler:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们测试默认处理器：
- en: '[PRE107]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Last, we see what happens if we use an unsupported HTTP method with a supported
    endpoint—in this case, the `/getall` endpoint that works with `GET` only:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看看如果我们使用不支持HTTP方法与支持端点会发生什么——在这种情况下，仅支持`GET`的`/getall`端点：
- en: '[PRE108]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Although the `/getall` endpoint requires a valid user to operate, the fact that
    we are using an HTTP method that is not supported by that endpoint takes precedence
    and the call fails for the right reasons.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`/getall`端点需要有效的用户才能操作，但我们使用的不受该端点支持的HTTP方法具有优先权，因此调用失败，这是正确的失败原因。
- en: It is important to look at the output of the RESTful server and the log entries
    that it generates during testing. Not all information can be sent back to a client,
    but the server process is allowed to print anything we want. This can be very
    helpful for debugging a server process such as our RESTful server.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试过程中，重要的是要查看RESTful服务器的输出以及它生成的日志条目。并非所有信息都可以发送回客户端，但服务器进程允许打印任何我们想要的内容。这可以非常有助于调试像我们的RESTful服务器这样的服务器进程。
- en: The next subsection tests all of the handlers that support the `GET` HTTP method.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 下一小节测试所有支持`GET` HTTP方法的处理器。
- en: Testing GET handlers
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试GET处理器
- en: 'First, we test the `/getall` endpoint—your output might vary depending on the
    contents of the SQLite database:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们测试`/getall`端点——您的输出可能取决于SQLite数据库的内容：
- en: '[PRE109]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The previous output is a list of all existing users found in the database in
    JSON format. You can always process the generated output with the `jq(1)` utility
    for a better-looking output.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出是数据库中找到的所有现有用户的列表，以JSON格式呈现。您始终可以使用`jq(1)`实用程序处理生成的输出，以获得更美观的输出。
- en: 'Then, we test the `/logged` endpoint:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们测试`/logged`端点：
- en: '[PRE110]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'After that, we test the `/username/{id}` endpoint:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们测试`/username/{id}`端点：
- en: '[PRE111]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Last, we test the `/getid/{username}` endpoint:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们测试`/getid/{username}`端点：
- en: '[PRE112]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: So, user `mihalis` has a user ID of `3`.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，用户`mihalis`的用户ID为`3`。
- en: So far, we can get a list of existing users and a list of logged-in users and
    get information about specific users—all of these endpoints use the `GET` method.
    The next subsection tests all of the handlers that support the `POST` method.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以获取现有用户列表和已登录用户列表，并获取特定用户的信息——所有这些端点都使用`GET`方法。下一小节将测试所有支持`POST`方法的处理器。
- en: Testing POST handlers
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试POST处理器
- en: 'First, we test the `/add` endpoint by adding the `packt` user, which does not
    have admin privileges:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过添加没有管理员权限的`packt`用户来测试`/add`端点：
- en: '[PRE113]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The previous call passes an array of two JSON records to the server. The second
    record comes with the details of the `packt` user. The command is issued by the
    `admin` user as specified by the data in the first JSON record.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的调用向服务器传递了一个包含两个JSON记录的数组。第二个记录包含了`packt`用户的详细信息。该命令由`admin`用户发出，该用户由第一个JSON记录中的数据指定。
- en: If we try to add the same username more than once, the process is going to fail—this
    is revealed with the use of `-v` in the `curl(1)` command. The relevant error
    message is going to be `HTTP/1.1 400 Bad Request`.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试多次添加相同的用户名，过程将会失败——这可以通过在`curl(1)`命令中使用`-v`来揭示。相关的错误信息将是`HTTP/1.1 400
    Bad Request`。
- en: 'Additionally, if we try to add a new user using the credentials of a user that
    is not an administrator, the server is going to generate the `Command issued by
    non-admin user: packt` message.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们尝试使用非管理员用户的凭据添加新用户，服务器将生成`由非管理员用户发出的命令：packt`消息。
- en: 'Next, we test the `/login` endpoint:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们测试`/login`端点：
- en: '[PRE114]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The previous command is used for logging in the `packt` user.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令用于登录`packt`用户。
- en: 'Last, we test the `/logout` endpoint:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们测试`/logout`端点：
- en: '[PRE115]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The previous command is used for logging out the `packt` user. You can use the
    `/logged` endpoint to verify the results of the previous two interactions.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令用于注销`packt`用户。您可以使用`/logged`端点来验证前两个交互的结果。
- en: Let us now test the only endpoint that supports the `PUT` HTTP method.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试唯一支持`PUT` HTTP方法的端点。
- en: Testing the PUT handler
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试PUT处理器
- en: 'First, we test the `/update` endpoint as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们按照以下方式测试`/update`端点：
- en: '[PRE116]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The previous command changes the password of the `admin` user from `admin` to
    `justChanged`.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 上一条命令将`admin`用户的密码从`admin`更改为`justChanged`。
- en: 'Then, we try to change a user password using the credentials of a non-admin
    user (`packt`):'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们尝试使用非管理员用户（`packt`）的凭据更改用户密码：
- en: '[PRE117]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The generated log message is `Command issued by non-admin user: packt`.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '生成的日志消息是`Command issued by non-admin user: packt`。'
- en: 'We might consider the fact that a non-admin user cannot even change their password
    as a flaw—it might be, but this is the way the RESTful server is implemented.
    The idea is that non-admin users should not issue dangerous commands directly.
    Additionally, this flaw can be easily fixed as follows: Generally speaking, regular
    users are not going to interact in this way with the server and are going to be
    offered a web interface for doing so. After that, an admin user can send the user
    request to the server. Therefore, this can be implemented in a different way that
    is more secure and does not give unnecessary privileges to regular users.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会考虑这样一个事实，即非管理员用户甚至无法更改自己的密码，这是一个缺陷——可能如此，但这是RESTful服务器实现的方式。其理念是非管理员用户不应直接发出危险命令。此外，这个缺陷可以很容易地修复，如下所示：一般来说，普通用户不会以这种方式与服务器交互，而是会提供一个用于此目的的Web界面。之后，管理员用户可以将用户请求发送到服务器。因此，这可以以不同的方式实现，更加安全，并且不会给普通用户不必要的权限。
- en: Lastly, we are going to test the `DELETE` HTTP method.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将测试`DELETE` HTTP方法。
- en: Testing the DELETE handler
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试DELETE处理器
- en: 'For the `DELETE` HTTP method, we need to test the `/username/{id}` endpoint.
    As this endpoint does not return any output, using `-v` in `curl(1)` is going
    to reveal the returned HTTP status code:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`DELETE` HTTP方法，我们需要测试`/username/{id}`端点。由于此端点不返回任何输出，使用`curl(1)`中的`-v`选项将揭示返回的HTTP状态码：
- en: '[PRE118]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The `HTTP/1.1 200 OK` status code verifies that the user was deleted successfully.
    If we try to delete the same user again, the request is going to fail, and the
    returned message is going to be `HTTP/1.1 404 Not Found`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTTP/1.1 200 OK`状态码验证用户已被成功删除。如果我们尝试再次删除同一用户，请求将失败，并返回消息`HTTP/1.1 404 Not
    Found`。'
- en: So far, we know that the RESTful server works as expected. However, `curl(1)`
    is far from perfect for working with the RESTful server on a daily basis. The
    next section shows how to develop a command line client for the RESTful server.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道RESTful服务器按预期工作。然而，`curl(1)`在日常使用RESTful服务器时远非完美。下一节将展示如何为RESTful服务器开发命令行客户端。
- en: Creating a RESTful client
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建RESTful客户端
- en: Creating a RESTful client is much easier than programming a server mainly because
    you do not have to work with the database on the client side. The only thing that
    the client needs to do is send the right amount and kind of data to the server
    and receive back and interpret the server response. The full RESTful client implementation
    can be found in `./ch11/client` of the book GitHub repository.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 创建RESTful客户端比编写服务器程序更容易，主要是因为你不需要在客户端与数据库交互。客户端需要做的唯一事情是向服务器发送正确数量和类型的数据，并接收并解释服务器的响应。完整的RESTful客户端实现可以在GitHub仓库的书籍`./ch11/client`中找到。
- en: 'The supported first-level cobra commands are going to be the following:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的第一级cobra命令如下：
- en: '`list`: This command accesses the `/getall` endpoint and returns the list of
    all available users.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list`: 此命令访问`/getall`端点并返回所有可用用户的列表。'
- en: '`time`: This command is for visiting the `/time` endpoint.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time`: 此命令用于访问`/time`端点。'
- en: '`update`: This command is for updating user records—the user ID cannot change.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update`: 此命令用于更新用户记录——用户ID不能更改。'
- en: '`logged`: This command lists all logged-in users.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logged`: 此命令列出所有已登录用户。'
- en: '`delete`: This command deletes an existing user.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete`: 此命令删除现有用户。'
- en: '`login`: This command is for logging in a user.'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`login`: 此命令用于登录用户。'
- en: '`logout`: This command is for logging out a user.'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logout`: 此命令用于注销用户。'
- en: '`add`: This command is for adding a new user to the system.'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add`: 此命令用于将新用户添加到系统中。'
- en: '`getid`: This command returns the ID of a user, identified by their username.'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getid`: 此命令返回由用户名标识的用户ID。'
- en: '`search`: This command displays information about a given user, identified
    by their ID.'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search`: 此命令显示有关给定用户（通过其ID识别）的信息。'
- en: A client like the one we are about to present is much better than working with
    `curl(1)` because it can process the received information but, most importantly,
    it can interpret the HTTP return codes and preprocess data before sending it to
    the server. The price you pay is the extra time needed for developing and debugging
    the RESTful client.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将展示的客户端比使用 `curl(1)` 工具工作要好得多，因为它可以处理接收到的信息，更重要的是，它可以解释HTTP返回码并在发送到服务器之前预处理数据。你付出的代价是开发调试RESTful客户端所需额外的时间。
- en: 'There exist two command line flags for passing the username and the password
    of the user issuing the command: `username` and `password`. As you are going to
    see in their implementations, they have the `-u` and `-p` shortcuts, respectively.
    Additionally, as the JSON record that holds user information has a small number
    of fields, all the fields are going to be given using the `data` flag or the `-d`
    shortcut—this is implemented in `./cmd/root.go`. Each command is going to read
    the desired flags only and the desired fields of the input JSON record—this is
    implemented in the source code file of each command. Lastly, the utility is going
    to return JSON records, when this makes sense, or a text message related to the
    endpoint that was visited. Now, let us continue with the structure of the client
    and the implementation of the commands.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 存在两个命令行标志用于传递执行命令的用户名和密码：`username` 和 `password`。正如你将在它们的实现中看到的那样，它们分别有 `-u`
    和 `-p` 快捷键。此外，由于包含用户信息的JSON记录字段数量较少，所有字段都将使用 `data` 标志或 `-d` 快捷键提供——这是在 `./cmd/root.go`
    中实现的。每个命令将只读取所需的标志和输入JSON记录的所需字段——这是在每个命令的源代码文件中实现的。最后，当这有意义时，工具将返回JSON记录，或者与访问的端点相关的文本消息。现在，让我们继续客户端的结构和命令的实现。
- en: Creating the structure of the command line client
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建命令行客户端的结构
- en: 'This subsection uses the cobra utility to create the structure for the command
    line utility. But first, we are going to create a proper cobra project with Go
    modules:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节使用 cobra 工具来创建命令行工具的结构。但首先，我们将使用 Go 模块创建一个合适的 cobra 项目：
- en: '[PRE119]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'You do not need to execute the last command, but it makes sure that everything
    is fine so far. After that, we are ready to define the commands that the utility
    is going to support by running the following cobra commands:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要执行最后一个命令，但它确保到目前为止一切正常。之后，我们准备通过运行以下 cobra 命令来定义工具将支持的命令：
- en: '[PRE120]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Now that we have the desired structure, we can begin implementing the commands
    and maybe remove some of the comments inserted by cobra, which is the subject
    of the next subsection.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所需的结构，我们可以开始实现命令，也许可以移除由 cobra 插入的一些注释，这是下一个小节的主题。
- en: Implementing the RESTful client commands
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现RESTful客户端命令
- en: 'As there is no point in displaying the entire code, we are going to present
    the most characteristic code found in some of the commands, starting with `root.go`,
    which is where the next global variables are defined:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 由于展示整个代码没有意义，我们将展示一些命令中最具代表性的代码，从 `root.go` 开始，这是定义下一个全局变量的地方：
- en: '[PRE121]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: These global variables hold the values of the command line options of the utility
    and are accessible from anywhere in the utility code.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这些全局变量持有工具的命令行选项值，并且可以在工具代码的任何地方访问。
- en: '[PRE122]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: We define the `User` structure for sending and receiving data.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了 `User` 结构，用于发送和接收数据。
- en: '[PRE123]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: We present the implementation of the `init()` function that holds the definitions
    of the command line options. The values of the command line flags are automatically
    stored in the variables that are passed as the first argument to `rootCmd.PersistentFlags().StringVarP()`.
    So, the `username` flag, which has the `-u` alias, stores its value in the `username`
    global variable.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了 `init()` 函数的实现，该函数包含了命令行选项的定义。命令行标志的值会自动存储在作为 `rootCmd.PersistentFlags().StringVarP()`
    第一个参数传递的变量中。因此，具有 `-u` 别名的 `username` 标志将它的值存储在 `username` 全局变量中。
- en: 'The next part is the implementation of the `list` command as found in `list.go`:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分是实现 `list` 命令，如 `list.go` 中所示：
- en: '[PRE124]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'This part is about the help messages that are displayed for the command. Although
    they are optional, it is good to have an accurate description of the command.
    We continue with the actual implementation:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分是关于显示在命令中的帮助信息。尽管它们是可选的，但有一个准确的命令描述是很好的。我们继续实际的实现：
- en: '[PRE125]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: First, we construct a `User` variable named `user` that holds the username and
    the password of the user issuing the command—the `user` variable is going to be
    passed to the server.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们构造一个名为`user`的`User`变量，该变量包含发出命令的用户的用户名和密码——`user`变量将被传递到服务器。
- en: '[PRE126]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: We need to encode the `user` variable before transferring it to the RESTful
    server, which is the purpose of the `ToJSON()` method. The implementation of the
    `ToJSON()` method is found in `root.go`.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`user`变量传输到RESTful服务器之前，我们需要对其进行编码，这就是`ToJSON()`方法的目的。`ToJSON()`方法的实现可以在`root.go`中找到。
- en: '[PRE127]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Here, we create the request using the `SERVER` and `PORT` global variables followed
    by the endpoint, using the desired HTTP method (`http.MethodGet`), and declare
    that we are going to send JSON data using the `Header.Set()` statement.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用全局变量`SERVER`和`PORT`以及端点创建请求，使用所需的HTTP方法（`http.MethodGet`），并声明我们将使用`Header.Set()`语句发送JSON数据。
- en: '[PRE128]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: After that, we send our data to the server using `Do()` and get the server response.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用`Do()`将我们的数据发送到服务器，并获取服务器的响应。
- en: '[PRE129]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: If the status code of the response is not `http.StatusOK`, then the request
    has failed.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 如果响应的状态码不是`http.StatusOK`，则请求失败。
- en: '[PRE130]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: If the status code is `http.StatusOK`, then we prepare to read a slice of `User`
    variables. As these variables hold JSON records, we need to decode them using
    `SliceFromJSON()`, which is defined in `root.go`.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态码是`http.StatusOK`，那么我们准备读取一个`User`变量的切片。由于这些变量持有JSON记录，我们需要使用定义在`root.go`中的`SliceFromJSON()`对其进行解码。
- en: Last is the code of the `add` command, as found in `add.go`. The difference
    between `add` and `list` is that the `add` command needs to send two JSON records
    to the RESTful server; the first one holds the data of the user issuing the command,
    and the second holds the data for the user that is about to be added to the system.
    The `username` and `password` flags hold the data for the `Username` and `Password`
    fields of the first record, whereas the `data` command line flag holds the data
    for the second record.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是`add`命令的代码，如`add.go`中所示。`add`和`list`之间的区别在于`add`命令需要向RESTful服务器发送两个JSON记录；第一个记录包含发出命令的用户的数据，第二个记录包含即将被添加到系统中的用户的数据。`username`和`password`标志持有第一个记录的`Username`和`Password`字段的数据，而`data`命令行标志持有第二个记录的数据。
- en: '[PRE131]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: As before, we get the information about the user issuing the command and put
    it into a structure.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们获取发出命令的用户信息并将其放入一个结构体中。
- en: '[PRE132]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: As the `data` command line flag holds a `string` value, we need to convert that
    string value to a `User` structure—this is the purpose of the `json.Unmarshal()`
    call.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`data`命令行标志持有`string`值，我们需要将那个字符串值转换为`User`结构——这就是`json.Unmarshal()`调用的目的。
- en: '[PRE133]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Then, we create a slice of `User` variables that are going to be sent to the
    server. The order you put the structures in that slice is important: first, the
    user issuing the command, and then the data of the user that is going to be created.
    This was decided by the RESTful server.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个将要发送到服务器的`User`变量切片。你在这个切片中放置结构的顺序很重要：首先是发出命令的用户，然后是即将创建的用户的数据。这是由RESTful服务器决定的。
- en: '[PRE134]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Then, we encode that slice before sending it to the RESTful server through the
    HTTP request.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在发送到RESTful服务器通过HTTP请求之前对那个切片进行编码。
- en: '[PRE135]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: We prepare the request and send it to the server. The server is responsible
    for decoding the provided data and acting accordingly, in this case, by adding
    a new user to the system. The client just needs to visit the correct endpoint
    using the appropriate HTTP method (`http.MethodPost`) and check the returned HTTP
    status code.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备请求并将其发送到服务器。服务器负责解码提供的数据并相应地执行，在这种情况下，通过向系统中添加新用户。客户端只需使用适当的HTTP方法（`http.MethodPost`）访问正确的端点，并检查返回的HTTP状态码。
- en: '[PRE136]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The `add` command does not return any data back to the client—what interests
    us is the HTTP status code because this is what determines the success or failure
    of the command.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`命令不会向客户端返回任何数据——我们感兴趣的是HTTP状态码，因为这决定了命令的成功或失败。'
- en: The rest of the commands have a similar implementation, which is not presented
    here. Feel free to look at the Go source code files in the `cmd` directory.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的命令有类似的实现，这里没有展示。请随意查看`cmd`目录中的Go源代码文件。
- en: Using the RESTful client
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用RESTful客户端
- en: We are now going to use the command line utility to interact with the RESTful
    server. This type of utility can be used for administering a RESTful server, creating
    automated tasks, and carrying out CI/CD jobs. For reasons of simplicity, the client
    and the server reside on the same machine, and we mostly work with the default
    user (`admin`)—this makes the presented commands shorter. Additionally, we execute
    `go build -o rest-cli` to create a binary executable and avoid using `go` `run`
    `main.go` all the time.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用命令行工具与 RESTful 服务器交互。这种类型的工具可以用于管理 RESTful 服务器、创建自动化任务以及执行 CI/CD 任务。为了简化，客户端和服务器位于同一台机器上，我们主要使用默认用户（`admin`）——这使得展示的命令更短。此外，我们执行
    `go build -o rest-cli` 来创建一个二进制可执行文件，以避免始终使用 `go run main.go`。
- en: 'First, we get the time from the server:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从服务器获取时间：
- en: '[PRE137]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Next, we list all users. As the output depends on the contents of the database,
    we print a small part of the output. Note that the `list` command needs to be
    issued by a user with admin privileges:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们列出所有用户。由于输出取决于数据库的内容，我们只打印输出的一部分。请注意，`list` 命令需要由具有管理员权限的用户执行：
- en: '[PRE138]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Keep in mind that you should use the active password of the `admin` user for
    the previous command to be executed correctly. In my case, the active password
    was also `admin` but this depends on your current status of the database.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你应该使用 `admin` 用户的激活密码来确保之前的命令正确执行。在我的情况下，激活密码也是 `admin`，但这取决于你当前数据库的状态。
- en: 'Next, we test the `logged` command when issued with an invalid password:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们测试使用无效密码发出的 `logged` 命令：
- en: '[PRE139]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: As expected, the command fails—this output is used for debugging purposes. After
    making sure that the command works as expected, you might want to print a more
    appropriate error message.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，命令失败了——这个输出用于调试目的。在确保命令按预期工作后，你可能想打印一个更合适的错误信息。
- en: 'After that, we test the `add` command:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们测试 `add` 命令：
- en: '[PRE140]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Trying to add the same user again is going to fail:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 再次尝试添加相同的用户将会失败：
- en: '[PRE141]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Next, we are going to delete `newUser`—but first, we need to find the user
    ID of `newUser`:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将删除 `newUser`——但首先，我们需要找到 `newUser` 的用户 ID：
- en: '[PRE142]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Feel free to continue testing the RESTful client and let me know if you find
    any bugs!
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 随意继续测试 RESTful 客户端，并告诉我你是否发现了任何错误！
- en: Working with multiple REST API versions
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与多个 REST API 版本一起工作
- en: 'A REST API can change and evolve over time. There exist various approaches
    on how to implement REST API versioning, including the following:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: REST API 可以随时间改变和演变。关于如何实现 REST API 版本化的方法有很多，包括以下几种：
- en: Using a custom HTTP header (`version-used`) to define the version used
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义 HTTP 头（`version-used`）来定义使用的版本
- en: Using a different subdomain for each version (`v1.servername` and `v2.servername`)
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个版本使用不同的子域名（`v1.servername` 和 `v2.servername`）
- en: Using a combination of `Accept` and `Content-Type` headers—this method is based
    on content negotiation
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Accept` 和 `Content-Type` 头的组合——这种方法基于内容协商
- en: Using a different path for each version (`/v1` and `/v2` if the RESTful server
    supports two REST API versions)
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个版本使用不同的路径（如果 RESTful 服务器支持两个 REST API 版本，则为 `/v1` 和 `/v2`）
- en: Using a query parameter to reference the desired version (`..../endpoint?version=v1`
    or `..../endpoint?v=1`)
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用查询参数来引用所需的版本（`..../endpoint?version=v1` 或 `..../endpoint?v=1`）
- en: There is no correct answer for how to implement REST API versioning. Use what
    seems more natural to you and your users. What is important is to be consistent
    and use the same approach everywhere. Personally, I prefer to use `/v1/...` for
    supporting the endpoints of version 1, and `/v2/...` for supporting the endpoints
    of version 2, and so on.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何实现 REST API 版本化，没有正确答案。使用对你和你的用户来说更自然的方法。重要的是要保持一致并在所有地方使用相同的方法。我个人更喜欢使用
    `/v1/...` 来支持版本 1 的端点，以及 `/v2/...` 来支持版本 2 的端点，依此类推。
- en: The development of our RESTful servers and clients has come to an end here.
    With the knowledge presented in this chapter, you can create powerful RESTful
    services!
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 RESTful 服务器和客户端的开发到此结束。通过本章所提供的内容，你可以创建强大的 RESTful 服务！
- en: Summary
  id: totrans-467
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Go is widely used for developing RESTful clients and servers and this chapter
    illustrated how to program professional RESTful clients and servers in Go. Although
    you can develop a RESTful server using the Standard Go library, this can be a
    really tedious task. External packages such as `gorilla/mux`, which was used in
    this chapter, and Gin can save you time by providing advanced features that would
    otherwise require lots of code when implemented with the functionality offered
    by the standard Go library.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: Go被广泛用于开发RESTful客户端和服务器，本章展示了如何在Go中编写专业的RESTful客户端和服务器。虽然你可以使用标准Go库开发RESTful服务器，但这可能是一项非常繁琐的任务。本章使用的`gorilla/mux`等外部包和Gin可以通过提供高级功能来节省你的时间，这些功能如果使用标准Go库实现，则需要大量的代码。
- en: Remember that defining a proper REST API and implementing a server and clients
    for it is a process that takes time and requires small adjustments and modifications.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，定义一个合适的REST API并实现相应的服务器和客户端是一个耗时且需要小幅度调整和修改的过程。
- en: Behind an efficient and productive RESTful service are properly defined JSON
    records and HTTP endpoints that support the desired operations. Given these two
    items, the Go code should offer support for the exchange of the JSON records between
    the server and the clients.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 一个高效且富有成效的RESTful服务背后是正确定义的JSON记录和HTTP端点，它们支持所需的操作。考虑到这两项内容，Go代码应该提供服务器和客户端之间交换JSON记录的支持。
- en: The next chapter is about code testing, profiling, cross-compilation, and creating
    example functions. Among other things, we are going to write code for testing
    the HTTP handlers developed in this chapter.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍代码测试、性能分析、交叉编译和创建示例函数。我们将编写测试本章开发的HTTP处理器的代码。
- en: Exercises
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Try to make `rServer.go` use Gin instead of `net/http`. Does `rClient.go` still
    work with the updated `rServer.go`? Why? Is that a good thing?
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试让`rServer.go`使用Gin而不是`net/http`。更新后的`rServer.go`是否仍然与`rClient.go`兼容？为什么？这是好事吗？
- en: Change the `server/restdb.go` file to support PostgreSQL instead of SQLite.
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`server/restdb.go`文件修改为支持PostgreSQL而不是SQLite。
- en: Change the `server/restdb.go` file to support MySQL instead of SQLite.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`server/restdb.go`文件修改为支持MySQL而不是SQLite。
- en: Put the handler functions from `server/handlers.go` into separate files.
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`server/handlers.go`中的处理函数放入单独的文件中。
- en: Additional resources
  id: totrans-477
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: You can find more about `gorilla/mux` at [https://github.com/gorilla/mux](https://github.com/gorilla/mux)
    and [https://www.gorillatoolkit.org/pkg/mux](https://www.gorillatoolkit.org/pkg/mux)
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/gorilla/mux](https://github.com/gorilla/mux)和[https://www.gorillatoolkit.org/pkg/mux](https://www.gorillatoolkit.org/pkg/mux)了解更多关于`gorilla/mux`的信息。
- en: 'The `go-querystring` library is for encoding Go structures into URL query parameters:
    [https://github.com/google/go-querystring](https://github.com/google/go-querystring)'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go-querystring`库用于将Go结构编码成URL查询参数：[https://github.com/google/go-querystring](https://github.com/google/go-querystring)。'
- en: 'Tutorial: Developing a RESTful API with Go and Gin: [https://go.dev/doc/tutorial/web-service-gin](https://go.dev/doc/tutorial/web-service-gin)'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 教程：使用Go和Gin开发RESTful API：[https://go.dev/doc/tutorial/web-service-gin](https://go.dev/doc/tutorial/web-service-gin)。
- en: If you want to validate JSON input, have a look at the Go `validator` package
    at [https://github.com/go-playground/validator](https://github.com/go-playground/validator)
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想验证JSON输入，可以查看Go的`validator`包，链接为[https://github.com/go-playground/validator](https://github.com/go-playground/validator)。
- en: 'You might find the `jq(1)` command line utility pretty handy when working with
    JSON records: [https://stedolan.github.io/jq/](https://stedolan.github.io/jq/)
    and [https://jqplay.org/](https://jqplay.org/)'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当处理JSON记录时，你可能觉得`jq(1)`命令行工具非常实用：[https://stedolan.github.io/jq/](https://stedolan.github.io/jq/)和[https://jqplay.org/](https://jqplay.org/)。
- en: Leave a review!
  id: totrans-483
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 留下评论！
- en: Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below to get a free eBook of your choice.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 喜欢这本书吗？通过留下亚马逊评论来帮助像你这样的读者。扫描下面的二维码以获取你选择的免费电子书。
- en: '![](img/Review_QR_Code.png)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/Review_QR_Code.png)'
