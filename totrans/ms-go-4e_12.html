<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer185">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">12</span></h1>
<h1 class="chapterTitle" id="_idParaDest-334"><span class="koboSpan" id="kobo.2.1">Code Testing and Profiling</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">Programming is both an art and a science, and as such, it needs tools that help the developer generate better software and understand why some aspects of their code do not work as expected. </span><span class="koboSpan" id="kobo.3.2">This chapter primarily addresses code testing and code profiling with the Go programming language. </span><span class="koboSpan" id="kobo.3.3">The provided code profiling tools are about improving the performance of Go programs by finding and understanding bottlenecks and discovering bugs.</span></p>
<p class="normal"><em class="italic"><span class="koboSpan" id="kobo.4.1">Code optimization</span></em><span class="koboSpan" id="kobo.5.1"> is the </span><a id="_idIndexMarker1001"/><span class="koboSpan" id="kobo.6.1">process where one or more developers try to make certain parts of a program run faster, be more efficient, or use fewer resources. </span><span class="koboSpan" id="kobo.6.2">Put simply, code optimization is about eliminating the bottlenecks of a program where and when it matters. </span><span class="koboSpan" id="kobo.6.3">The discussion about code optimization is going to continue in </span><em class="chapterRef"><span class="koboSpan" id="kobo.7.1">Chapter 14</span></em><span class="koboSpan" id="kobo.8.1">, </span><em class="italic"><span class="koboSpan" id="kobo.9.1">Efficiency and Performance</span></em><span class="koboSpan" id="kobo.10.1">, where we talk about benchmarking code.</span></p>
<p class="normal"><em class="italic"><span class="koboSpan" id="kobo.11.1">Code testing</span></em><span class="koboSpan" id="kobo.12.1"> is </span><a id="_idIndexMarker1002"/><span class="koboSpan" id="kobo.13.1">about making sure that your code does what you want it to do. </span><span class="koboSpan" id="kobo.13.2">In this chapter, we are experiencing the Go way of code testing. </span><span class="koboSpan" id="kobo.13.3">The best time to write test code is during development, as this can help to reveal bugs in the code as early as possible. </span><em class="italic"><span class="koboSpan" id="kobo.14.1">Code profiling</span></em><span class="koboSpan" id="kobo.15.1"> relates</span><a id="_idIndexMarker1003"/><span class="koboSpan" id="kobo.16.1"> to measuring certain aspects of a program to get a detailed understanding of the way the code works. </span><span class="koboSpan" id="kobo.16.2">The results of code profiling may help you to decide which parts of your code need to change.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.17.1">Keep in mind that when writing code, we should focus on its correctness as well as other desirable properties, such as readability, simplicity, and maintainability, not its performance. </span><span class="koboSpan" id="kobo.17.2">Once we are sure that the code is correct, then we might need to focus on its performance. </span><span class="koboSpan" id="kobo.17.3">A good trick for performance is to execute the code on machines that are a bit slower than the ones that are going to be used in production.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.18.1">This chapter covers:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.19.1">Optimizing code</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.20.1">Rewriting the </span><code class="inlineCode"><span class="koboSpan" id="kobo.21.1">main()</span></code><span class="koboSpan" id="kobo.22.1"> function for better testing</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.23.1">Profiling code</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.24.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.25.1">go tool trace</span></code><span class="koboSpan" id="kobo.26.1"> utility</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.27.1">Tracing a web server</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.28.1">Testing Go code</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.29.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.30.1">govulncheck</span></code><span class="koboSpan" id="kobo.31.1"> tool</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.32.1">Cross-compilation</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.33.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.34.1">go:generate</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.35.1">Creating example functions</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-335"><span class="koboSpan" id="kobo.36.1">Optimizing code</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.37.1">Code optimization</span><a id="_idIndexMarker1004"/><span class="koboSpan" id="kobo.38.1"> is both an art and a science. </span><span class="koboSpan" id="kobo.38.2">This means that there is no deterministic way to help you optimize your code and that you should use your brain and try many things, algorithms and techniques, if you want to make your code faster. </span><span class="koboSpan" id="kobo.38.3">However, the general principle regarding code optimization is </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.39.1">first make it correct, then make it fast</span></strong><span class="koboSpan" id="kobo.40.1">. </span><span class="koboSpan" id="kobo.40.2">Always remember what Donald Knuth said about optimization:</span></p>
<blockquote class="packt_quote">
<p class="quote"><span class="koboSpan" id="kobo.41.1">”The real problem is that programmers have spent far too much time worrying about efficiency in the wrong places and at the wrong times; premature optimization is the root of all evil (or at least most of it) in programming.”</span></p>
</blockquote>
<p class="normal"><span class="koboSpan" id="kobo.42.1">Also, remember what the late Joe Armstrong, one of the developers of Erlang, said about optimization:</span></p>
<blockquote class="packt_quote">
<p class="quote"><span class="koboSpan" id="kobo.43.1">”Make it work, then make it beautiful, then if you really, really have to, make it fast. </span><span class="koboSpan" id="kobo.43.2">90 percent of the time, if you make it beautiful, it will already be fast. </span><span class="koboSpan" id="kobo.43.3">So really, just make it beautiful!”</span></p>
</blockquote>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.44.1">Code testing</span><a id="_idIndexMarker1005"/><span class="koboSpan" id="kobo.45.1"> helps you make your program work correctly and code profiling</span><a id="_idIndexMarker1006"/><span class="koboSpan" id="kobo.46.1"> reveals bottlenecks.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.47.1">If you are really into code optimization, you might want to read </span><em class="italic"><span class="koboSpan" id="kobo.48.1">Compilers: Principles, Techniques, and Tools,</span></em><span class="koboSpan" id="kobo.49.1"> by Alfred V. </span><span class="koboSpan" id="kobo.49.2">Aho, Monica S. </span><span class="koboSpan" id="kobo.49.3">Lam, Ravi Sethi, and Jeffrey D. </span><span class="koboSpan" id="kobo.49.4">Ullman (Pearson Education Limited, 2014), which focuses on compiler construction. </span><span class="koboSpan" id="kobo.49.5">Additionally, all volumes in the </span><em class="italic"><span class="koboSpan" id="kobo.50.1">The Art of Computer Programming</span></em><span class="koboSpan" id="kobo.51.1"> series by Donald Knuth (Addison-Wesley Professional, 1998) are great resources for all aspects of programming if you have the time to read them.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.52.1">The next section shows a technique for rewriting </span><code class="inlineCode"><span class="koboSpan" id="kobo.53.1">main()</span></code><span class="koboSpan" id="kobo.54.1"> to make testing easier.</span></p>
<h1 class="heading-1" id="_idParaDest-336"><span class="koboSpan" id="kobo.55.1">Rewriting the main() function for better testing</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.56.1">There </span><a id="_idIndexMarker1007"/><span class="koboSpan" id="kobo.57.1">exists a clever way that you can rewrite each </span><code class="inlineCode"><span class="koboSpan" id="kobo.58.1">main()</span></code><span class="koboSpan" id="kobo.59.1"> function in order to make testing (and benchmarking) a lot easier. </span><span class="koboSpan" id="kobo.59.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.60.1">main()</span></code><span class="koboSpan" id="kobo.61.1"> function has a restriction, which is that you cannot call it from test code—this technique presents a solution to that problem using the code found in </span><code class="inlineCode"><span class="koboSpan" id="kobo.62.1">main.go</span></code><span class="koboSpan" id="kobo.63.1">. </span><span class="koboSpan" id="kobo.63.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.64.1">import</span></code><span class="koboSpan" id="kobo.65.1"> block is omitted to save space.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.66.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.67.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.68.1">()</span></span><span class="koboSpan" id="kobo.69.1"> {
    </span><span class="code-highlight"><strong class="hljs-slc"><span class="koboSpan" id="kobo.70.1">err := run(os.Args, os.Stdout)</span></strong></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.71.1">if</span></span><span class="koboSpan" id="kobo.72.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.73.1">nil</span></span><span class="koboSpan" id="kobo.74.1"> {
        fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.75.1">"%s\n"</span></span><span class="koboSpan" id="kobo.76.1">, err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.77.1">return</span></span><span class="koboSpan" id="kobo.78.1">
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.79.1">As we cannot have an executable program without a </span><code class="inlineCode"><span class="koboSpan" id="kobo.80.1">main()</span></code><span class="koboSpan" id="kobo.81.1"> function, we have to create a minimalistic one. </span><span class="koboSpan" id="kobo.81.2">What </span><code class="inlineCode"><span class="koboSpan" id="kobo.82.1">main()</span></code><span class="koboSpan" id="kobo.83.1"> does is call </span><code class="inlineCode"><span class="koboSpan" id="kobo.84.1">run()</span></code><span class="koboSpan" id="kobo.85.1">, which is our own customized version of </span><code class="inlineCode"><span class="koboSpan" id="kobo.86.1">main()</span></code><span class="koboSpan" id="kobo.87.1">, send the desired </span><code class="inlineCode"><span class="koboSpan" id="kobo.88.1">os.Args</span></code><span class="koboSpan" id="kobo.89.1"> to it, and collect the return value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.90.1">run()</span></code><span class="koboSpan" id="kobo.91.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.92.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.93.1">run</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.94.1">(args []</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.95.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.96.1">, stdout io.Writer)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.97.1">error</span></span><span class="koboSpan" id="kobo.98.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.99.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.100.1">len</span></span><span class="koboSpan" id="kobo.101.1">(args) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.102.1">1</span></span><span class="koboSpan" id="kobo.103.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.104.1">return</span></span><span class="koboSpan" id="kobo.105.1"> errors.New(</span><span class="hljs-string"><span class="koboSpan" id="kobo.106.1">"No input!"</span></span><span class="koboSpan" id="kobo.107.1">)
    }
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.108.1">// Continue with the implementation of run()</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.109.1">// as you would have with main()</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.110.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.111.1">nil</span></span><span class="koboSpan" id="kobo.112.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.113.1">As</span><a id="_idIndexMarker1008"/><span class="koboSpan" id="kobo.114.1"> discussed before, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.115.1">run()</span></code><span class="koboSpan" id="kobo.116.1"> function, or any other function that is called by </span><code class="inlineCode"><span class="koboSpan" id="kobo.117.1">main()</span></code><span class="koboSpan" id="kobo.118.1"> in the same way, provides a new top-level, root-type function like </span><code class="inlineCode"><span class="koboSpan" id="kobo.119.1">main()</span></code><span class="koboSpan" id="kobo.120.1"> with the additional benefit of being able to be called by test functions. </span><span class="koboSpan" id="kobo.120.2">Put simply, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.121.1">run()</span></code><span class="koboSpan" id="kobo.122.1"> function contains the code that would have been located in </span><code class="inlineCode"><span class="koboSpan" id="kobo.123.1">main()</span></code><span class="koboSpan" id="kobo.124.1">—the only difference is that </span><code class="inlineCode"><span class="koboSpan" id="kobo.125.1">run()</span></code><span class="koboSpan" id="kobo.126.1"> returns an </span><code class="inlineCode"><span class="koboSpan" id="kobo.127.1">error</span></code><span class="koboSpan" id="kobo.128.1"> variable, which is not possible with </span><code class="inlineCode"><span class="koboSpan" id="kobo.129.1">main()</span></code><span class="koboSpan" id="kobo.130.1">, which can only return exit codes to the operating system when used with </span><code class="inlineCode"><span class="koboSpan" id="kobo.131.1">os.Exit()</span></code><span class="koboSpan" id="kobo.132.1">. </span><span class="koboSpan" id="kobo.132.2">You might say that this creates a slightly bigger stack because of the extra function call but the benefits are far more important than the added memory usage. </span><span class="koboSpan" id="kobo.132.3">Although, technically, both parameters of </span><code class="inlineCode"><span class="koboSpan" id="kobo.133.1">run()</span></code><span class="koboSpan" id="kobo.134.1"> can be removed as they are globally available by default, passing these two parameters explicitly allows the programmer to pass other values during testing.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.135.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.136.1">main.go</span></code><span class="koboSpan" id="kobo.137.1"> produces the next output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.138.1">$ </span></span><span class="koboSpan" id="kobo.139.1">go run main.go 
No input!
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.140.1">$ </span></span><span class="koboSpan" id="kobo.141.1">go run main.go some input
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.142.1">There is nothing special in the way </span><code class="inlineCode"><span class="koboSpan" id="kobo.143.1">main.go</span></code><span class="koboSpan" id="kobo.144.1"> operates. </span><span class="koboSpan" id="kobo.144.2">The good thing is that you can call </span><code class="inlineCode"><span class="koboSpan" id="kobo.145.1">run()</span></code><span class="koboSpan" id="kobo.146.1"> from anywhere you want, including the code you write for testing, and pass the desired parameters to </span><code class="inlineCode"><span class="koboSpan" id="kobo.147.1">run()</span></code><span class="koboSpan" id="kobo.148.1">! </span><span class="koboSpan" id="kobo.148.2">It is good to have that technique in mind because it might save you when you want to write tests for a program with certain command line arguments or other input.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.149.1">The next section is about profiling Go code.</span></p>
<h1 class="heading-1" id="_idParaDest-337"><span class="koboSpan" id="kobo.150.1">Profiling code</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.151.1">Profiling</span><a id="_idIndexMarker1009"/><span class="koboSpan" id="kobo.152.1"> is a </span><a id="_idIndexMarker1010"/><span class="koboSpan" id="kobo.153.1">process of dynamic program analysis that measures various values related to program execution to give you a better understanding of the program behavior. </span><span class="koboSpan" id="kobo.153.2">In this section, we are going to learn how to profile Go code to understand it better, which can be used to improve its performance. </span><span class="koboSpan" id="kobo.153.3">Sometimes, code profiling can even reveal bugs in the code, such as endless loops or functions that never return. </span><span class="koboSpan" id="kobo.153.4">However, profiling would be better for memory leak bugs and things of that nature.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.154.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.155.1">runtime/pprof</span></code><span class="koboSpan" id="kobo.156.1"> standard Go package is used for profiling all kinds of applications apart from HTTP servers. </span><span class="koboSpan" id="kobo.156.2">The high-level </span><code class="inlineCode"><span class="koboSpan" id="kobo.157.1">net/http/pprof</span></code><span class="koboSpan" id="kobo.158.1"> package should be used when you want to profile a web application. </span><span class="koboSpan" id="kobo.158.2">What </span><code class="inlineCode"><span class="koboSpan" id="kobo.159.1">net/http/pprof</span></code><span class="koboSpan" id="kobo.160.1"> does is provide HTTP endpoints for profiling data, which means that it can also be used for any long-running application. </span><span class="koboSpan" id="kobo.160.2">You can see the help page of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.161.1">pprof</span></code><span class="koboSpan" id="kobo.162.1"> tool by executing </span><code class="inlineCode"><span class="koboSpan" id="kobo.163.1">go tool pprof -help</span></code><span class="koboSpan" id="kobo.164.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.165.1">This next subsection is going to illustrate how to profile a command line application, and the following subsection shows the profiling of an HTTP server.</span></p>
<h2 class="heading-2" id="_idParaDest-338"><span class="koboSpan" id="kobo.166.1">Profiling a command line application</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.167.1">The code of the </span><a id="_idIndexMarker1011"/><span class="koboSpan" id="kobo.168.1">application is saved as </span><code class="inlineCode"><span class="koboSpan" id="kobo.169.1">profileCla.go</span></code><span class="koboSpan" id="kobo.170.1"> and collects CPU and memory profiling data. </span><span class="koboSpan" id="kobo.170.2">What is interesting is the implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.171.1">main()</span></code><span class="koboSpan" id="kobo.172.1"> because this is where the collection of the profiling data takes place:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.173.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.174.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.175.1">()</span></span><span class="koboSpan" id="kobo.176.1"> {
    fmt.Println(os.TempDir())
    cpuFilename := path.Join(os.TempDir(), </span><span class="hljs-string"><span class="koboSpan" id="kobo.177.1">"cpuProfileCla.out"</span></span><span class="koboSpan" id="kobo.178.1">)
    cpuFile, err := os.Create(cpuFilename)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.179.1">if</span></span><span class="koboSpan" id="kobo.180.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.181.1">nil</span></span><span class="koboSpan" id="kobo.182.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.183.1">return</span></span><span class="koboSpan" id="kobo.184.1">
    }
    pprof.StartCPUProfile(cpuFile)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.185.1">defer</span></span><span class="koboSpan" id="kobo.186.1"> pprof.StopCPUProfile()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.187.1">The previous code is about collecting CPU profiling data. </span><code class="inlineCode"><span class="koboSpan" id="kobo.188.1">pprof.StartCPUProfile()</span></code><span class="koboSpan" id="kobo.189.1"> starts collecting data, which is stopped with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.190.1">pprof.StopCPUProfile()</span></code><span class="koboSpan" id="kobo.191.1"> call. </span><span class="koboSpan" id="kobo.191.2">All data is saved into a file named </span><code class="inlineCode"><span class="koboSpan" id="kobo.192.1">cpuProfileCla.out</span></code><span class="koboSpan" id="kobo.193.1"> under the </span><code class="inlineCode"><span class="koboSpan" id="kobo.194.1">os.TempDir()</span></code><span class="koboSpan" id="kobo.195.1"> directory—the value returned by </span><code class="inlineCode"><span class="koboSpan" id="kobo.196.1">os.TempDir()</span></code><span class="koboSpan" id="kobo.197.1"> depends on the OS used and makes the code portable. </span><span class="koboSpan" id="kobo.197.2">The use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.198.1">defer</span></code><span class="koboSpan" id="kobo.199.1"> means that </span><code class="inlineCode"><span class="koboSpan" id="kobo.200.1">pprof.StopCPUProfile()</span></code><span class="koboSpan" id="kobo.201.1"> is going to get called just before </span><code class="inlineCode"><span class="koboSpan" id="kobo.202.1">main()</span></code><span class="koboSpan" id="kobo.203.1"> exits—if you want to stop data collection at another point, you should put the </span><code class="inlineCode"><span class="koboSpan" id="kobo.204.1">pprof.StopCPUProfile()</span></code><span class="koboSpan" id="kobo.205.1"> call at the desired place.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.206.1">    total := </span><span class="hljs-number"><span class="koboSpan" id="kobo.207.1">0</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.208.1">for</span></span><span class="koboSpan" id="kobo.209.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.210.1">2</span></span><span class="koboSpan" id="kobo.211.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.212.1">100000</span></span><span class="koboSpan" id="kobo.213.1">; i++ {
        n := N1(i)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.214.1">if</span></span><span class="koboSpan" id="kobo.215.1"> n {
            total = total + </span><span class="hljs-number"><span class="koboSpan" id="kobo.216.1">1</span></span><span class="koboSpan" id="kobo.217.1">
        }
    }
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.218.1">"Total primes:"</span></span><span class="koboSpan" id="kobo.219.1">, total)
    total = </span><span class="hljs-number"><span class="koboSpan" id="kobo.220.1">0</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.221.1">for</span></span><span class="koboSpan" id="kobo.222.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.223.1">2</span></span><span class="koboSpan" id="kobo.224.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.225.1">100000</span></span><span class="koboSpan" id="kobo.226.1">; i++ {
        n := N2(i)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.227.1">if</span></span><span class="koboSpan" id="kobo.228.1"> n {
            total = total + </span><span class="hljs-number"><span class="koboSpan" id="kobo.229.1">1</span></span><span class="koboSpan" id="kobo.230.1">
        }
    }
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.231.1">"Total primes:"</span></span><span class="koboSpan" id="kobo.232.1">, total)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.233.1">for</span></span><span class="koboSpan" id="kobo.234.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.235.1">1</span></span><span class="koboSpan" id="kobo.236.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.237.1">90</span></span><span class="koboSpan" id="kobo.238.1">; i++ {
        n := fibo1(i)
        fmt.Print(n, </span><span class="hljs-string"><span class="koboSpan" id="kobo.239.1">" "</span></span><span class="koboSpan" id="kobo.240.1">)
    }
    fmt.Println()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.241.1">for</span></span><span class="koboSpan" id="kobo.242.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.243.1">1</span></span><span class="koboSpan" id="kobo.244.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.245.1">90</span></span><span class="koboSpan" id="kobo.246.1">; i++ {
        n := fibo2(i)
        fmt.Print(n, </span><span class="hljs-string"><span class="koboSpan" id="kobo.247.1">" "</span></span><span class="koboSpan" id="kobo.248.1">)
    }
    fmt.Println()
    runtime.GC()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.249.1">All the previous</span><a id="_idIndexMarker1012"/><span class="koboSpan" id="kobo.250.1"> code performs lots of CPU-intensive calculations for the CPU profiler to have data to collect—this is where your actual code usually goes.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"><span class="koboSpan" id="kobo.251.1">// Memory profiling!</span></span><span class="koboSpan" id="kobo.252.1">
    memoryFilename := path.Join(os.TempDir(), </span><span class="hljs-string"><span class="koboSpan" id="kobo.253.1">"memoryProfileCla.out"</span></span><span class="koboSpan" id="kobo.254.1">)
    memory, err := os.Create(memoryFilename)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.255.1">if</span></span><span class="koboSpan" id="kobo.256.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.257.1">nil</span></span><span class="koboSpan" id="kobo.258.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.259.1">return</span></span><span class="koboSpan" id="kobo.260.1">
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.261.1">defer</span></span><span class="koboSpan" id="kobo.262.1"> memory.Close()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.263.1">After the CPU-intensive code, we are going to put code that uses lots of memory. </span><span class="koboSpan" id="kobo.263.2">For that, we create a second file named </span><code class="inlineCode"><span class="koboSpan" id="kobo.264.1">memoryFilename</span></code><span class="koboSpan" id="kobo.265.1"> for collecting memory-related profiling data.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.266.1">for</span></span><span class="koboSpan" id="kobo.267.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.268.1">0</span></span><span class="koboSpan" id="kobo.269.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.270.1">10</span></span><span class="koboSpan" id="kobo.271.1">; i++ {
        s := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.272.1">make</span></span><span class="koboSpan" id="kobo.273.1">([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.274.1">byte</span></span><span class="koboSpan" id="kobo.275.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.276.1">50000000</span></span><span class="koboSpan" id="kobo.277.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.278.1">if</span></span><span class="koboSpan" id="kobo.279.1"> s == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.280.1">nil</span></span><span class="koboSpan" id="kobo.281.1"> {
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.282.1">"Operation failed!"</span></span><span class="koboSpan" id="kobo.283.1">)
        }
        time.Sleep(</span><span class="hljs-number"><span class="koboSpan" id="kobo.284.1">50</span></span><span class="koboSpan" id="kobo.285.1"> * time.Millisecond)
    }
    err = pprof.WriteHeapProfile(memory)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.286.1">if</span></span><span class="koboSpan" id="kobo.287.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.288.1">nil</span></span><span class="koboSpan" id="kobo.289.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.290.1">return</span></span><span class="koboSpan" id="kobo.291.1">
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.292.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.293.1">pprof.WriteHeapProfile()</span></code><span class="koboSpan" id="kobo.294.1"> function writes the memory data into the specified file. </span><span class="koboSpan" id="kobo.294.2">Once again, we allocate lots of memory for the memory profiler to have data to collect.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.295.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.296.1">profileCla.go</span></code><span class="koboSpan" id="kobo.297.1"> using </span><code class="inlineCode"><span class="koboSpan" id="kobo.298.1">go run</span></code><span class="koboSpan" id="kobo.299.1"> is going to create two files in the folder returned by </span><code class="inlineCode"><span class="koboSpan" id="kobo.300.1">os.TempDir()</span></code><span class="koboSpan" id="kobo.301.1">—usually, we move them into a different folder. </span><span class="koboSpan" id="kobo.301.2">Feel free to change the code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.302.1">profileCla.go</span></code><span class="koboSpan" id="kobo.303.1"> and put the profiling files in a different place.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.304.1">In my case, running on a macOS Sonoma machine, the temporary directory is going to be </span><code class="inlineCode"><span class="koboSpan" id="kobo.305.1">/var/folders/sk/ltk8cnw50lzdtr2hxcj5sv2m0000gn/T/</span></code><span class="koboSpan" id="kobo.306.1">. </span><span class="koboSpan" id="kobo.306.2">So, I am going to move the </span><code class="inlineCode"><span class="koboSpan" id="kobo.307.1">cpuProfileCla.out</span></code><span class="koboSpan" id="kobo.308.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.309.1">memoryProfileCla.out</span></code><span class="koboSpan" id="kobo.310.1"> files from there into the </span><code class="inlineCode"><span class="koboSpan" id="kobo.311.1">ch12</span></code><span class="koboSpan" id="kobo.312.1"> directory—you are not going to be able to find them because the </span><code class="inlineCode"><span class="koboSpan" id="kobo.313.1">.gitignore</span></code><span class="koboSpan" id="kobo.314.1"> file of the GitHub repository of the book ignores both of them.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.315.1">So, what do we</span><a id="_idIndexMarker1013"/><span class="koboSpan" id="kobo.316.1"> do next? </span><span class="koboSpan" id="kobo.316.2">We should use </span><code class="inlineCode"><span class="koboSpan" id="kobo.317.1">go tool pprof</span></code><span class="koboSpan" id="kobo.318.1"> to process these two files:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.319.1">$ </span></span><span class="koboSpan" id="kobo.320.1">go tool pprof cpuProfileCla.out
Type: cpu
Time: Dec 13, 2023 at 6:35pm (EET)
Duration: 14.85s, Total samples = 650ms ( 4.38%)
Entering interactive mode (type "help" for commands, "o" for options)
(pprof) top
Showing nodes accounting for 630ms, 96.92% of 650ms total
Showing top 10 nodes out of 47
      flat  flat%   sum%        cum   cum%
     300ms 46.15% 46.15%    330ms 50.77%  main.N2 (inline)
     120ms 18.46% 64.62%    120ms 18.46%  main.N1 (inline)
      40ms  6.15% 70.77%     40ms  6.15%  runtime.kevent
      40ms  6.15% 76.92%     40ms  6.15%  runtime.pthread_cond_signal
      40ms  6.15% 83.08%     40ms  6.15%  runtime.pthread_cond_wait
      30ms  4.62% 87.69%     30ms  4.62%  runtime.asyncPreempt
      30ms  4.62% 92.31%     30ms  4.62%  runtime.madvise
      10ms  1.54% 93.85%     10ms  1.54%  internal/poll.(*pollDesc).prepare
      10ms  1.54% 95.38%    480ms 73.85%  main.main
      10ms  1.54% 96.92%     10ms  1.54%  runtime.memclrNoHeapPointers
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.321.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.322.1">top</span></code><span class="koboSpan" id="kobo.323.1"> command returns a summary of the top 10 entries.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.324.1">(pprof) top10 -cum
Showing nodes accounting for 440ms, 67.69% of 650ms total
Showing top 10 nodes out of 47
      flat  flat%   sum%        cum   cum%
      10ms  1.54%  1.54%      480ms 73.85%  main.main
         0     0%  1.54%      480ms 73.85%  runtime.main
     300ms 46.15% 47.69%      330ms 50.77%  main.N2 (inline)
     120ms 18.46% 66.15%      120ms 18.46%  main.N1 (inline)
         0     0% 66.15%      120ms 18.46%  runtime.mcall
      10ms  1.54% 67.69%      120ms 18.46%  runtime.schedule
         0     0% 67.69%      110ms 16.92%  runtime.park_m
         0     0% 67.69%       80ms 12.31%  runtime.findRunnable
         0     0% 67.69%       50ms  7.69%  runtime.notewakeup
         0     0% 67.69%       50ms  7.69%  runtime.semawakeup
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.325.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.326.1">top10 –cum</span></code><span class="koboSpan" id="kobo.327.1"> command returns the cumulative time for each function.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.328.1">(pprof) list main.N1
Total: 650ms
ROUTINE ======================== main.N1 in /Users/mtsouk/go/src/github.com/mactsouk/mGo4th/ch12/profileCla.go
     120ms      120ms (flat, cum) 18.46% of Total
         .          </span><span class="koboSpan" id="kobo.328.2">.     </span><span class="koboSpan" id="kobo.328.3">36:func N1(n int) bool {
         .          </span><span class="koboSpan" id="kobo.328.4">.     </span><span class="koboSpan" id="kobo.328.5">37:    k := math.Floor(float64(n/2 + 1))
         .          </span><span class="koboSpan" id="kobo.328.6">.     </span><span class="koboSpan" id="kobo.328.7">38:    for i := 2; i &lt; int(k); i++ {
     120ms      120ms     39:        if (n % i) == 0 {
         .          </span><span class="koboSpan" id="kobo.328.8">.     </span><span class="koboSpan" id="kobo.328.9">40:            return false
         .          </span><span class="koboSpan" id="kobo.328.10">.     </span><span class="koboSpan" id="kobo.328.11">41:        }
         .          </span><span class="koboSpan" id="kobo.328.12">.     </span><span class="koboSpan" id="kobo.328.13">42:    }
         .          </span><span class="koboSpan" id="kobo.328.14">.     </span><span class="koboSpan" id="kobo.328.15">43:    return true
         .          </span><span class="koboSpan" id="kobo.328.16">.     </span><span class="koboSpan" id="kobo.328.17">44:}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.329.1">Last, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.330.1">list</span></code><span class="koboSpan" id="kobo.331.1"> command</span><a id="_idIndexMarker1014"/><span class="koboSpan" id="kobo.332.1"> shows information about a given function. </span><span class="koboSpan" id="kobo.332.2">The previous output shows that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.333.1">if (n % i) == 0</span></code><span class="koboSpan" id="kobo.334.1"> statement is responsible for all the time it takes </span><code class="inlineCode"><span class="koboSpan" id="kobo.335.1">N1()</span></code><span class="koboSpan" id="kobo.336.1"> to run!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.337.1">Try the profile commands on your own in your own code to see their full output. </span><span class="koboSpan" id="kobo.337.2">Visit </span><a href="https://go.dev/blog/pprof"><span class="url"><span class="koboSpan" id="kobo.338.1">https://go.dev/blog/pprof</span></span></a><span class="koboSpan" id="kobo.339.1"> from the Go blog to learn more about profiling.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.340.1">You can also create PDF output of the profiling data from the shell of the Go profiler using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.341.1">pdf</span></code><span class="koboSpan" id="kobo.342.1"> command. </span><span class="koboSpan" id="kobo.342.2">Personally, most of the time, I begin with this command because it gives me a rich and clear overview of the collected data.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.343.1">Now, let us discuss how to profile an HTTP server, which is the subject of the next subsection.</span></p>
<h2 class="heading-2" id="_idParaDest-339"><span class="koboSpan" id="kobo.344.1">Profiling an HTTP server</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.345.1">As</span><a id="_idIndexMarker1015"/><span class="koboSpan" id="kobo.346.1"> discussed, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.347.1">net/http/pprof</span></code><span class="koboSpan" id="kobo.348.1"> package should be used when you want to collect profiling data for a Go application that runs an HTTP server or any other long-running program where you want to periodically collect profiling data. </span><span class="koboSpan" id="kobo.348.2">To that end, importing </span><code class="inlineCode"><span class="koboSpan" id="kobo.349.1">net/http/pprof</span></code><span class="koboSpan" id="kobo.350.1"> installs various handlers under the </span><code class="inlineCode"><span class="koboSpan" id="kobo.351.1">/debug/pprof/</span></code><span class="koboSpan" id="kobo.352.1"> path. </span><span class="koboSpan" id="kobo.352.2">You are going to see more on this in a short while. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.353.1">The technique is illustrated in </span><code class="inlineCode"><span class="koboSpan" id="kobo.354.1">profileHTTP.go</span></code><span class="koboSpan" id="kobo.355.1">, which comes with the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.356.1">package</span></span><span class="koboSpan" id="kobo.357.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.358.1">import</span></span><span class="koboSpan" id="kobo.359.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.360.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.361.1">"net/http"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.362.1">"net/http/pprof"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.363.1">"os"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.364.1">"time"</span></span><span class="koboSpan" id="kobo.365.1">
)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.366.1">As discussed earlier, you should import the </span><code class="inlineCode"><span class="koboSpan" id="kobo.367.1">net/http/pprof</span></code><span class="koboSpan" id="kobo.368.1"> package. </span><span class="koboSpan" id="kobo.368.2">However, although </span><code class="inlineCode"><span class="koboSpan" id="kobo.369.1">net/http/pprof</span></code><span class="koboSpan" id="kobo.370.1"> is imported, it is not used directly. </span><span class="koboSpan" id="kobo.370.2">The import is for the side effects of registering the HTTP handlers, as explained in </span><a href="https://pkg.go.dev/net/http/pprof"><span class="url"><span class="koboSpan" id="kobo.371.1">https://pkg.go.dev/net/http/pprof</span></span></a><span class="koboSpan" id="kobo.372.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.373.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.374.1">myHandler</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.375.1">(w http.ResponseWriter, r *http.Request)</span></span><span class="koboSpan" id="kobo.376.1"> {
    fmt.Fprintf(w, </span><span class="hljs-string"><span class="koboSpan" id="kobo.377.1">"Serving: %s\n"</span></span><span class="koboSpan" id="kobo.378.1">, r.URL.Path)
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.379.1">"Served: %s\n"</span></span><span class="koboSpan" id="kobo.380.1">, r.Host)
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.381.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.382.1">timeHandler</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.383.1">(w http.ResponseWriter, r *http.Request)</span></span><span class="koboSpan" id="kobo.384.1"> {
    t := time.Now().Format(time.RFC1123)
    Body := </span><span class="hljs-string"><span class="koboSpan" id="kobo.385.1">"The current time is:"</span></span><span class="koboSpan" id="kobo.386.1">
    fmt.Fprintf(w, </span><span class="hljs-string"><span class="koboSpan" id="kobo.387.1">"%s %s"</span></span><span class="koboSpan" id="kobo.388.1">, Body, t)
    fmt.Fprintf(w, </span><span class="hljs-string"><span class="koboSpan" id="kobo.389.1">"Serving: %s\n"</span></span><span class="koboSpan" id="kobo.390.1">, r.URL.Path)
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.391.1">"Served time for: %s\n"</span></span><span class="koboSpan" id="kobo.392.1">, r.Host)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.393.1">The</span><a id="_idIndexMarker1016"/><span class="koboSpan" id="kobo.394.1"> previous two functions implement two handlers that are going to be used in our naïve HTTP server. </span><code class="inlineCode"><span class="koboSpan" id="kobo.395.1">myHandler()</span></code><span class="koboSpan" id="kobo.396.1"> is the default handler function, whereas </span><code class="inlineCode"><span class="koboSpan" id="kobo.397.1">timeHandler()</span></code><span class="koboSpan" id="kobo.398.1"> returns the current time and date on the server.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.399.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.400.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.401.1">()</span></span><span class="koboSpan" id="kobo.402.1"> {
    PORT := </span><span class="hljs-string"><span class="koboSpan" id="kobo.403.1">":8001"</span></span><span class="koboSpan" id="kobo.404.1">
    arguments := os.Args
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.405.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.406.1">len</span></span><span class="koboSpan" id="kobo.407.1">(arguments) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.408.1">1</span></span><span class="koboSpan" id="kobo.409.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.410.1">"Using default port number: "</span></span><span class="koboSpan" id="kobo.411.1">, PORT)
    } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.412.1">else</span></span><span class="koboSpan" id="kobo.413.1"> {
        PORT = </span><span class="hljs-string"><span class="koboSpan" id="kobo.414.1">":"</span></span><span class="koboSpan" id="kobo.415.1"> + arguments[</span><span class="hljs-number"><span class="koboSpan" id="kobo.416.1">1</span></span><span class="koboSpan" id="kobo.417.1">]
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.418.1">"Using port number: "</span></span><span class="koboSpan" id="kobo.419.1">, PORT)
    }
    r := http.NewServeMux()
    r.HandleFunc(</span><span class="hljs-string"><span class="koboSpan" id="kobo.420.1">"/time"</span></span><span class="koboSpan" id="kobo.421.1">, timeHandler)
    r.HandleFunc(</span><span class="hljs-string"><span class="koboSpan" id="kobo.422.1">"/"</span></span><span class="koboSpan" id="kobo.423.1">, myHandler)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.424.1">Up to this point, there is nothing special as we just register the handler functions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.425.1">All of the previous statements install the handlers for the HTTP profiler—you can access them using the hostname and port number of the web server. </span><span class="koboSpan" id="kobo.425.2">You do not have to use all handlers.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.426.1">    err := http.ListenAndServe(PORT, r)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.427.1">if</span></span><span class="koboSpan" id="kobo.428.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.429.1">nil</span></span><span class="koboSpan" id="kobo.430.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.431.1">return</span></span><span class="koboSpan" id="kobo.432.1">
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.433.1">Last, you start the HTTP server as usual.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.434.1">What is next? </span><span class="koboSpan" id="kobo.434.2">First, you run the HTTP server (</span><code class="inlineCode"><span class="koboSpan" id="kobo.435.1">go run profileHTTP.go</span></code><span class="koboSpan" id="kobo.436.1">). </span><span class="koboSpan" id="kobo.436.2">After that, you run the next command </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.437.1">in a different terminal window</span></strong><span class="koboSpan" id="kobo.438.1"> to collect profiling data while interacting with the HTTP server:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.439.1">$ </span></span><span class="koboSpan" id="kobo.440.1">go tool pprof http://localhost:8001/debug/pprof/profile
Fetching profile over HTTP from http://localhost:8001/debug/pprof/profile
Saved profile in /Users/mtsouk/pprof/pprof.samples.cpu.001.pb.gz
Type: cpu
Time: Dec 13, 2023 at 6:44pm (EET)
Duration: 30.02s, Total samples = 30ms (  0.1%)
Entering interactive mode (type "help" for commands, "o" for options)
(pprof) %
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.441.1">The previous output shows the initial screen of the HTTP profiler—the available commands are the same as when profiling a command line application.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.442.1">You can</span><a id="_idIndexMarker1017"/><span class="koboSpan" id="kobo.443.1"> either exit the shell and analyze your data later using </span><code class="inlineCode"><span class="koboSpan" id="kobo.444.1">go tool pprof</span></code><span class="koboSpan" id="kobo.445.1"> or continue giving profiler commands. </span><span class="koboSpan" id="kobo.445.2">This is the general idea behind profiling HTTP servers in Go.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.446.1">The next subsection discusses the web interface of the Go profiler.</span></p>
<h2 class="heading-2" id="_idParaDest-340"><span class="koboSpan" id="kobo.447.1">The web interface of the Go profiler</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.448.1">The good news is that, starting </span><a id="_idIndexMarker1018"/><span class="koboSpan" id="kobo.449.1">with Go version 1.10, </span><code class="inlineCode"><span class="koboSpan" id="kobo.450.1">go tool pprof</span></code><span class="koboSpan" id="kobo.451.1"> comes with a web interface that you can start as </span><code class="inlineCode"><span class="koboSpan" id="kobo.452.1">go tool pprof -http=[host]:[port] aProfile.out</span></code><span class="koboSpan" id="kobo.453.1">—do not forget to set your desired values to </span><code class="inlineCode"><span class="koboSpan" id="kobo.454.1">-http</span></code><span class="koboSpan" id="kobo.455.1">.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.456.1">I have executed the previous command as </span><code class="inlineCode"><span class="koboSpan" id="kobo.457.1">go tool pprof -http=127.0.0.1:1234 cpuProfileCla.out</span></code><span class="koboSpan" id="kobo.458.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.459.1">A part of the web interface of the profiler is seen in the next figure, which shows how the program execution time was spent—it is now the job of the developer to find out whether there is something wrong with the performance or not.</span></p>
<figure class="mediaobject"> <span class="koboSpan" id="kobo.460.1"><img alt="A screenshot of a computer  Description automatically generated" src="../Images/B21003_12_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.461.1">Figure 12.1: The web interface of the Go profiler</span></p>
<p class="normal"><span class="koboSpan" id="kobo.462.1">Feel free to</span><a id="_idIndexMarker1019"/><span class="koboSpan" id="kobo.463.1"> browse the web interface and see the various options and menus that are offered. </span><span class="koboSpan" id="kobo.463.2">Unfortunately, talking more about profiling is beyond the scope of this chapter. </span><span class="koboSpan" id="kobo.463.3">As always, if you are really interested in code profiling, experiment with it as much as possible.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.464.1">The next section is about code tracing, which gives you information about the operation of the Go internals.</span></p>
<h2 class="heading-2" id="_idParaDest-341"><span class="koboSpan" id="kobo.465.1">The go tool trace utility</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.466.1">Code tracing</span><a id="_idIndexMarker1020"/><span class="koboSpan" id="kobo.467.1"> is a process that </span><a id="_idIndexMarker1021"/><span class="koboSpan" id="kobo.468.1">allows you to learn information such as the operation of the garbage collector, the lifetime of goroutines, the activity of each logical processor, and the number of operating system threads used. </span><span class="koboSpan" id="kobo.468.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.469.1">go tool trace</span></code><span class="koboSpan" id="kobo.470.1"> utility is a tool for viewing the data stored in trace files, which can be generated in any one of the following three ways:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.471.1">With the </span><code class="inlineCode"><span class="koboSpan" id="kobo.472.1">runtime/trace</span></code><span class="koboSpan" id="kobo.473.1"> package</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.474.1">With the </span><code class="inlineCode"><span class="koboSpan" id="kobo.475.1">net/http/pprof</span></code><span class="koboSpan" id="kobo.476.1"> package</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.477.1">With the </span><code class="inlineCode"><span class="koboSpan" id="kobo.478.1">go test -trace</span></code><span class="koboSpan" id="kobo.479.1"> command</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.480.1">This section illustrates the use of the first technique using the code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.481.1">traceCLA.go</span></code><span class="koboSpan" id="kobo.482.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.483.1">package</span></span><span class="koboSpan" id="kobo.484.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.485.1">import</span></span><span class="koboSpan" id="kobo.486.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.487.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.488.1">"os"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.489.1">"path"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.490.1">"runtime/trace"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.491.1">"time"</span></span><span class="koboSpan" id="kobo.492.1">
)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.493.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.494.1">runtime/trace</span></code><span class="koboSpan" id="kobo.495.1"> package is required for collecting all kinds of tracing data—there is no point in selecting specific tracing data as all tracing data is interconnected.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.496.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.497.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.498.1">()</span></span><span class="koboSpan" id="kobo.499.1"> {
    filename := path.Join(os.TempDir(), </span><span class="hljs-string"><span class="koboSpan" id="kobo.500.1">"traceCLA.out"</span></span><span class="koboSpan" id="kobo.501.1">)
    f, err := os.Create(filename)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.502.1">if</span></span><span class="koboSpan" id="kobo.503.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.504.1">nil</span></span><span class="koboSpan" id="kobo.505.1"> {
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.506.1">panic</span></span><span class="koboSpan" id="kobo.507.1">(err)
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.508.1">defer</span></span><span class="koboSpan" id="kobo.509.1"> f.Close()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.510.1">As we did for profiling, we need to create a file to store tracing data. </span><span class="koboSpan" id="kobo.510.2">In this case, the file is called </span><code class="inlineCode"><span class="koboSpan" id="kobo.511.1">traceCLA.out</span></code><span class="koboSpan" id="kobo.512.1"> and is stored inside the temporary directory of your operating system.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.513.1">    err = trace.Start(f)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.514.1">if</span></span><span class="koboSpan" id="kobo.515.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.516.1">nil</span></span><span class="koboSpan" id="kobo.517.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.518.1">return</span></span><span class="koboSpan" id="kobo.519.1">
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.520.1">defer</span></span><span class="koboSpan" id="kobo.521.1"> trace.Stop()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.522.1">This part is all about acquiring data for </span><code class="inlineCode"><span class="koboSpan" id="kobo.523.1">go tool trace</span></code><span class="koboSpan" id="kobo.524.1">, and it has nothing to do with the purpose of the program. </span><span class="koboSpan" id="kobo.524.2">We start the tracing process using </span><code class="inlineCode"><span class="koboSpan" id="kobo.525.1">trace.Start()</span></code><span class="koboSpan" id="kobo.526.1">. </span><span class="koboSpan" id="kobo.526.2">When we are done, we call the </span><code class="inlineCode"><span class="koboSpan" id="kobo.527.1">trace.Stop()</span></code><span class="koboSpan" id="kobo.528.1"> function. </span><span class="koboSpan" id="kobo.528.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.529.1">defer</span></code><span class="koboSpan" id="kobo.530.1"> call means that we want to terminate tracing when the </span><code class="inlineCode"><span class="koboSpan" id="kobo.531.1">main()</span></code><span class="koboSpan" id="kobo.532.1"> function returns.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.533.1">for</span></span><span class="koboSpan" id="kobo.534.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.535.1">0</span></span><span class="koboSpan" id="kobo.536.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.537.1">3</span></span><span class="koboSpan" id="kobo.538.1">; i++ {
        s := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.539.1">make</span></span><span class="koboSpan" id="kobo.540.1">([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.541.1">byte</span></span><span class="koboSpan" id="kobo.542.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.543.1">50000000</span></span><span class="koboSpan" id="kobo.544.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.545.1">if</span></span><span class="koboSpan" id="kobo.546.1"> s == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.547.1">nil</span></span><span class="koboSpan" id="kobo.548.1"> {
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.549.1">"Operation failed!"</span></span><span class="koboSpan" id="kobo.550.1">)
        }
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.551.1">for</span></span><span class="koboSpan" id="kobo.552.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.553.1">0</span></span><span class="koboSpan" id="kobo.554.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.555.1">5</span></span><span class="koboSpan" id="kobo.556.1">; i++ {
        s := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.557.1">make</span></span><span class="koboSpan" id="kobo.558.1">([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.559.1">byte</span></span><span class="koboSpan" id="kobo.560.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.561.1">100000000</span></span><span class="koboSpan" id="kobo.562.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.563.1">if</span></span><span class="koboSpan" id="kobo.564.1"> s == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.565.1">nil</span></span><span class="koboSpan" id="kobo.566.1"> {
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.567.1">"Operation failed!"</span></span><span class="koboSpan" id="kobo.568.1">)
        }
        time.Sleep(time.Millisecond)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.569.1">All the previous </span><a id="_idIndexMarker1022"/><span class="koboSpan" id="kobo.570.1">code is about allocating memory to trigger the operation of the garbage collector and generate more tracing data—you can learn more about the Go garbage collector in </span><em class="chapterRef"><span class="koboSpan" id="kobo.571.1">Appendix A</span></em><span class="koboSpan" id="kobo.572.1">, </span><em class="italic"><span class="koboSpan" id="kobo.573.1">Go Garbage Collector</span></em><span class="koboSpan" id="kobo.574.1">. </span><span class="koboSpan" id="kobo.574.2">The program is executed as usual. </span><span class="koboSpan" id="kobo.574.3">However, when it finishes, it populates </span><code class="inlineCode"><span class="koboSpan" id="kobo.575.1">traceCLA.out</span></code><span class="koboSpan" id="kobo.576.1"> with tracing data. </span><span class="koboSpan" id="kobo.576.2">After that, we should process the tracing data as follows:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.577.1">$ </span></span><span class="koboSpan" id="kobo.578.1">go tool trace /path/ToTemporary/Directory/traceCLA.out
2023/12/14 18:12:06 Parsing trace...
</span><span class="koboSpan" id="kobo.578.2">2023/12/14 18:12:06 Splitting trace...
</span><span class="koboSpan" id="kobo.578.3">2023/12/14 18:12:06 Opening browser. </span><span class="koboSpan" id="kobo.578.4">Trace viewer is listening on http://127.0.0.1:52829
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.579.1">The last command automatically starts a web server (</span><code class="inlineCode"><span class="koboSpan" id="kobo.580.1">http://127.0.0.1:52829</span></code><span class="koboSpan" id="kobo.581.1">) and opens the web interface of the trace tool on your default web browser—you can run it on your own computer to play with the web interface of the trace tool.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.582.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.583.1">View trace</span></code><span class="koboSpan" id="kobo.584.1"> link shows information about the goroutines of your program and the operation of the garbage collector—if your code uses multiple goroutines, this is the best place to understand their behavior.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.585.1">Keep in mind that although </span><code class="inlineCode"><span class="koboSpan" id="kobo.586.1">go tool trace</span></code><span class="koboSpan" id="kobo.587.1"> is very handy and powerful, it cannot solve every kind of performance problem. </span><span class="koboSpan" id="kobo.587.2">There are times when </span><code class="inlineCode"><span class="koboSpan" id="kobo.588.1">go tool pprof</span></code><span class="koboSpan" id="kobo.589.1"> is more appropriate, especially when we want to reveal where our code spends most of its time.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.590.1">As with profiling, collecting tracing data for an HTTP server is a slightly different process, which is explained in the next subsection.</span></p>
<h2 class="heading-2" id="_idParaDest-342"><span class="koboSpan" id="kobo.591.1">Tracing a web server from a client</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.592.1">This </span><a id="_idIndexMarker1023"/><span class="koboSpan" id="kobo.593.1">section shows how to trace a web server application</span><a id="_idIndexMarker1024"/><span class="koboSpan" id="kobo.594.1"> using </span><code class="inlineCode"><span class="koboSpan" id="kobo.595.1">net/http/httptrace</span></code><span class="koboSpan" id="kobo.596.1">. </span><span class="koboSpan" id="kobo.596.2">The package allows you to trace the phases of an HTTP request from a client. </span><span class="koboSpan" id="kobo.596.3">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.597.1">traceHTTP.go</span></code><span class="koboSpan" id="kobo.598.1"> that interacts with web servers is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.599.1">package</span></span><span class="koboSpan" id="kobo.600.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.601.1">import</span></span><span class="koboSpan" id="kobo.602.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.603.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.604.1">"net/http"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.605.1">"net/http/httptrace"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.606.1">"os"</span></span><span class="koboSpan" id="kobo.607.1">
)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.608.1">As expected, we need to import </span><code class="inlineCode"><span class="koboSpan" id="kobo.609.1">net/http/httptrace</span></code><span class="koboSpan" id="kobo.610.1"> before being able to enable HTTP tracing.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.611.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.612.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.613.1">()</span></span><span class="koboSpan" id="kobo.614.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.615.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.616.1">len</span></span><span class="koboSpan" id="kobo.617.1">(os.Args) != </span><span class="hljs-number"><span class="koboSpan" id="kobo.618.1">2</span></span><span class="koboSpan" id="kobo.619.1"> {
        fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.620.1">"Usage: URL\n"</span></span><span class="koboSpan" id="kobo.621.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.622.1">return</span></span><span class="koboSpan" id="kobo.623.1">
    }
    URL := os.Args[</span><span class="hljs-number"><span class="koboSpan" id="kobo.624.1">1</span></span><span class="koboSpan" id="kobo.625.1">]
    client := http.Client{}
    req, _ := http.NewRequest(</span><span class="hljs-string"><span class="koboSpan" id="kobo.626.1">"GET"</span></span><span class="koboSpan" id="kobo.627.1">, URL, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.628.1">nil</span></span><span class="koboSpan" id="kobo.629.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.630.1">Up to this point, we have prepared the client request to the web server as usual.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.631.1">    trace := &amp;httptrace.ClientTrace{
        GotFirstResponseByte: </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.632.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.633.1">()</span></span><span class="koboSpan" id="kobo.634.1"> {
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.635.1">"First response byte!"</span></span><span class="koboSpan" id="kobo.636.1">)
        },
        GotConn: </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.637.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.638.1">(connInfo httptrace.GotConnInfo)</span></span><span class="koboSpan" id="kobo.639.1"> {
            fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.640.1">"Got Conn: %+v\n"</span></span><span class="koboSpan" id="kobo.641.1">, connInfo)
        },
        DNSDone: </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.642.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.643.1">(dnsInfo httptrace.DNSDoneInfo)</span></span><span class="koboSpan" id="kobo.644.1"> {
            fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.645.1">"DNS Info: %+v\n"</span></span><span class="koboSpan" id="kobo.646.1">, dnsInfo)
        },
        ConnectStart: </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.647.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.648.1">(network, addr </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.649.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.650.1">)</span></span><span class="koboSpan" id="kobo.651.1"> {
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.652.1">"Dial start"</span></span><span class="koboSpan" id="kobo.653.1">)
        },
        ConnectDone: </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.654.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.655.1">(network, addr </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.656.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.657.1">, err </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.658.1">error</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.659.1">)</span></span><span class="koboSpan" id="kobo.660.1"> {
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.661.1">"Dial done"</span></span><span class="koboSpan" id="kobo.662.1">)
        },
        WroteHeaders: </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.663.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.664.1">()</span></span><span class="koboSpan" id="kobo.665.1"> {
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.666.1">"Wrote headers"</span></span><span class="koboSpan" id="kobo.667.1">)
        },
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.668.1">The </span><a id="_idIndexMarker1025"/><span class="koboSpan" id="kobo.669.1">preceding code is all about tracing HTTP requests. </span><span class="koboSpan" id="kobo.669.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.670.1">httptrace.ClientTrace</span></code><span class="koboSpan" id="kobo.671.1"> structure defines the events that interest us, which</span><a id="_idIndexMarker1026"/><span class="koboSpan" id="kobo.672.1"> are </span><code class="inlineCode"><span class="koboSpan" id="kobo.673.1">GotFirstResponseByte</span></code><span class="koboSpan" id="kobo.674.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.675.1">GotConn</span></code><span class="koboSpan" id="kobo.676.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.677.1">DNSDone</span></code><span class="koboSpan" id="kobo.678.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.679.1">ConnectStart</span></code><span class="koboSpan" id="kobo.680.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.681.1">ConnectDone</span></code><span class="koboSpan" id="kobo.682.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.683.1">WroteHeaders</span></code><span class="koboSpan" id="kobo.684.1">. </span><span class="koboSpan" id="kobo.684.2">When such an event occurs, the relevant code is executed. </span><span class="koboSpan" id="kobo.684.3">You can find more information about the supported events and their purpose in the documentation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.685.1">net/http/httptrace</span></code><span class="koboSpan" id="kobo.686.1"> package.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.687.1">    req = req.WithContext(httptrace.WithClientTrace(req.Context(), trace))
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.688.1">"Requesting data from server!"</span></span><span class="koboSpan" id="kobo.689.1">)
    _, err := http.DefaultTransport.RoundTrip(req)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.690.1">if</span></span><span class="koboSpan" id="kobo.691.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.692.1">nil</span></span><span class="koboSpan" id="kobo.693.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.694.1">return</span></span><span class="koboSpan" id="kobo.695.1">
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.696.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.697.1">httptrace.WithClientTrace()</span></code><span class="koboSpan" id="kobo.698.1"> function returns a new context value based on the given parent context, while </span><code class="inlineCode"><span class="koboSpan" id="kobo.699.1">http.DefaultTransport.RoundTrip()</span></code><span class="koboSpan" id="kobo.700.1"> wraps the request with the context value in order to keep track of the request.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.701.1">Keep in mind that Go HTTP tracing has been designed to trace the events of a single </span><code class="inlineCode"><span class="koboSpan" id="kobo.702.1">http.Transport.RoundTrip</span></code><span class="koboSpan" id="kobo.703.1">.</span></p>
</div>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.704.1">    _, err = client.Do(req)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.705.1">if</span></span><span class="koboSpan" id="kobo.706.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.707.1">nil</span></span><span class="koboSpan" id="kobo.708.1"> {
        fmt.Println(err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.709.1">return</span></span><span class="koboSpan" id="kobo.710.1">
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.711.1">The last part sends the client request to the server for the tracing to begin.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.712.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.713.1">traceHTTP.go</span></code><span class="koboSpan" id="kobo.714.1"> generates the next output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.715.1">$ </span></span><span class="koboSpan" id="kobo.716.1">go run traceHTTP.go https://go.dev
Requesting data from server!
</span><span class="koboSpan" id="kobo.716.2">DNS Info: {Addrs:[{IP:2001:4860:4802:32::15 Zone:} {IP:2001:4860:4802:34::15 Zone:} {IP:2001:4860:4802:36::15 Zone:} {IP:2001:4860:4802:38::15 Zone:} {IP:216.239.32.21 Zone:} {IP:216.239.34.21 Zone:} {IP:216.239.36.21 Zone:} {IP:216.239.38.21 Zone:}] Err:&lt;nil&gt; Coalesced:false}
Dial start
Dial done
Got Conn: {Conn:0x1400018e000 Reused:false WasIdle:false IdleTime:0s}
Wrote headers
First response byte!
</span><span class="koboSpan" id="kobo.716.3">Got Conn: {Conn:0x1400018e000 Reused:true WasIdle:false IdleTime:0s}
Wrote headers
First response byte!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.717.1">The </span><a id="_idIndexMarker1027"/><span class="koboSpan" id="kobo.718.1">previous output helps you understand the progress of</span><a id="_idIndexMarker1028"/><span class="koboSpan" id="kobo.719.1"> the connection in more detail and is handy when troubleshooting. </span><span class="koboSpan" id="kobo.719.2">Unfortunately, talking more about tracing is beyond the scope of this book. </span><span class="koboSpan" id="kobo.719.3">The next subsection shows how to visit all the routes of a web server to make sure that they are properly defined.</span></p>
<h2 class="heading-2" id="_idParaDest-343"><span class="koboSpan" id="kobo.720.1">Visiting all routes of a web server</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.721.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.722.1">gorilla/mux</span></code><span class="koboSpan" id="kobo.723.1"> package</span><a id="_idIndexMarker1029"/><span class="koboSpan" id="kobo.724.1"> offers a </span><code class="inlineCode"><span class="koboSpan" id="kobo.725.1">Walk()</span></code><span class="koboSpan" id="kobo.726.1"> function that can be used to visit all the</span><a id="_idIndexMarker1030"/><span class="koboSpan" id="kobo.727.1"> registered routes of a router—this can be very handy when you want to make sure that every route is registered and is working.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.728.1">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.729.1">walkAll.go</span></code><span class="koboSpan" id="kobo.730.1">, which contains lots of empty handler functions because its purpose is not to test handling functions but to visit them, is as follows (nothing prohibits you from using the same technique on a fully implemented web server):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.731.1">package</span></span><span class="koboSpan" id="kobo.732.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.733.1">import</span></span><span class="koboSpan" id="kobo.734.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.735.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.736.1">"net/http"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.737.1">"strings"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.738.1">"github.com/gorilla/mux"</span></span><span class="koboSpan" id="kobo.739.1">
)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.740.1">As we are using an external package, the running of </span><code class="inlineCode"><span class="koboSpan" id="kobo.741.1">walkAll.go</span></code><span class="koboSpan" id="kobo.742.1"> should take place somewhere under </span><code class="inlineCode"><span class="koboSpan" id="kobo.743.1">~/go/src</span></code><span class="koboSpan" id="kobo.744.1">—in our case, under </span><code class="inlineCode"><span class="koboSpan" id="kobo.745.1">./ch12/walkAll</span></code><span class="koboSpan" id="kobo.746.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.747.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.748.1">handler</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.749.1">(w http.ResponseWriter, r *http.Request)</span></span><span class="koboSpan" id="kobo.750.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.751.1">return</span></span><span class="koboSpan" id="kobo.752.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.753.1">This empty handler function is shared by all endpoints for reasons of simplicity.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.754.1">func</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.755.1">(h notAllowedHandler)</span></span><span class="koboSpan" id="kobo.756.1"> ServeHTTP(rw http.ResponseWriter, r *http.Request) {
    handler(rw, r)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.757.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.758.1">notAllowedHandler</span></code><span class="koboSpan" id="kobo.759.1"> handler </span><a id="_idIndexMarker1031"/><span class="koboSpan" id="kobo.760.1">also</span><a id="_idIndexMarker1032"/><span class="koboSpan" id="kobo.761.1"> calls the </span><code class="inlineCode"><span class="koboSpan" id="kobo.762.1">handler()</span></code><span class="koboSpan" id="kobo.763.1"> function.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.764.1">type</span></span><span class="koboSpan" id="kobo.765.1"> notAllowedHandler </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.766.1">struct</span></span><span class="koboSpan" id="kobo.767.1">{}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.768.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.769.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.770.1">()</span></span><span class="koboSpan" id="kobo.771.1"> {
    r := mux.NewRouter()
    r.NotFoundHandler = http.HandlerFunc(handler)
    notAllowed := notAllowedHandler{}
    r.MethodNotAllowedHandler = notAllowed
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.772.1">// Register GET</span></span><span class="koboSpan" id="kobo.773.1">
    getMux := r.Methods(http.MethodGet).Subrouter()
    getMux.HandleFunc(</span><span class="hljs-string"><span class="koboSpan" id="kobo.774.1">"/time"</span></span><span class="koboSpan" id="kobo.775.1">, handler)
    getMux.HandleFunc(</span><span class="hljs-string"><span class="koboSpan" id="kobo.776.1">"/getall"</span></span><span class="koboSpan" id="kobo.777.1">, handler)
    getMux.HandleFunc(</span><span class="hljs-string"><span class="koboSpan" id="kobo.778.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.779.1">/getid"</span></span><span class="koboSpan" id="kobo.780.1">, handler)
    getMux.HandleFunc(</span><span class="hljs-string"><span class="koboSpan" id="kobo.781.1">"/logged"</span></span><span class="koboSpan" id="kobo.782.1">, handler)
    getMux.HandleFunc(</span><span class="hljs-string"><span class="koboSpan" id="kobo.783.1">"/username/{id:[0-9]+}"</span></span><span class="koboSpan" id="kobo.784.1">, handler)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.785.1">// Register PUT</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.786.1">// Update User</span></span><span class="koboSpan" id="kobo.787.1">
    putMux := r.Methods(http.MethodPut).Subrouter()
    putMux.HandleFunc(</span><span class="hljs-string"><span class="koboSpan" id="kobo.788.1">"/update"</span></span><span class="koboSpan" id="kobo.789.1">, handler)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.790.1">// Register POST</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.791.1">// Add User + Login + Logout</span></span><span class="koboSpan" id="kobo.792.1">
    postMux := r.Methods(http.MethodPost).Subrouter()
    postMux.HandleFunc(</span><span class="hljs-string"><span class="koboSpan" id="kobo.793.1">"/add"</span></span><span class="koboSpan" id="kobo.794.1">, handler)
    postMux.HandleFunc(</span><span class="hljs-string"><span class="koboSpan" id="kobo.795.1">"/login"</span></span><span class="koboSpan" id="kobo.796.1">, handler)
    postMux.HandleFunc(</span><span class="hljs-string"><span class="koboSpan" id="kobo.797.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.798.1">/logout"</span></span><span class="koboSpan" id="kobo.799.1">, handler)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.800.1">// Register DELETE</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.801.1">// Delete User</span></span><span class="koboSpan" id="kobo.802.1">
    deleteMux := r.Methods(http.MethodDelete).Subrouter()
    deleteMux.HandleFunc(</span><span class="hljs-string"><span class="koboSpan" id="kobo.803.1">"/username/{id:[0-9]+}"</span></span><span class="koboSpan" id="kobo.804.1">, handler)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.805.1">The previous part is about defining the routes and the HTTP methods that we want to support.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.806.1">    err := r.Walk(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.807.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.808.1">(route *mux.Route, router *mux.Router, ancestors []*mux.Route)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.809.1">error</span></span><span class="koboSpan" id="kobo.810.1"> {
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.811.1">The </span><a id="_idIndexMarker1033"/><span class="koboSpan" id="kobo.812.1">previous statements </span><a id="_idIndexMarker1034"/><span class="koboSpan" id="kobo.813.1">illustrate how we call the </span><code class="inlineCode"><span class="koboSpan" id="kobo.814.1">Walk()</span></code><span class="koboSpan" id="kobo.815.1"> method.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.816.1">        pathTemplate, err := route.GetPathTemplate()
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.817.1">if</span></span><span class="koboSpan" id="kobo.818.1"> err == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.819.1">nil</span></span><span class="koboSpan" id="kobo.820.1"> {
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.821.1">"ROUTE:"</span></span><span class="koboSpan" id="kobo.822.1">, pathTemplate)
        }
        pathRegexp, err := route.GetPathRegexp()
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.823.1">if</span></span><span class="koboSpan" id="kobo.824.1"> err == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.825.1">nil</span></span><span class="koboSpan" id="kobo.826.1"> {
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.827.1">"Path regexp:"</span></span><span class="koboSpan" id="kobo.828.1">, pathRegexp)
        }
        qT, err := route.GetQueriesTemplates()
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.829.1">if</span></span><span class="koboSpan" id="kobo.830.1"> err == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.831.1">nil</span></span><span class="koboSpan" id="kobo.832.1"> {
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.833.1">"Queries templates:"</span></span><span class="koboSpan" id="kobo.834.1">, strings.Join(qT, </span><span class="hljs-string"><span class="koboSpan" id="kobo.835.1">","</span></span><span class="koboSpan" id="kobo.836.1">))
        }
        qRegexps, err := route.GetQueriesRegexp()
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.837.1">if</span></span><span class="koboSpan" id="kobo.838.1"> err == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.839.1">nil</span></span><span class="koboSpan" id="kobo.840.1"> {
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.841.1">"Queries regexps:"</span></span><span class="koboSpan" id="kobo.842.1">, strings.Join(qRegexps, </span><span class="hljs-string"><span class="koboSpan" id="kobo.843.1">","</span></span><span class="koboSpan" id="kobo.844.1">))
        }
        methods, err := route.GetMethods()
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.845.1">if</span></span><span class="koboSpan" id="kobo.846.1"> err == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.847.1">nil</span></span><span class="koboSpan" id="kobo.848.1"> {
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.849.1">"Methods:"</span></span><span class="koboSpan" id="kobo.850.1">, strings.Join(methods, </span><span class="hljs-string"><span class="koboSpan" id="kobo.851.1">","</span></span><span class="koboSpan" id="kobo.852.1">))
        }
        fmt.Println()
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.853.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.854.1">nil</span></span><span class="koboSpan" id="kobo.855.1">
    })
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.856.1">For each visited route, the program collects the desired information. </span><span class="koboSpan" id="kobo.856.2">Feel free to remove some of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.857.1">fmt.Println()</span></code><span class="koboSpan" id="kobo.858.1"> calls if it does not help your purpose.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.859.1">if</span></span><span class="koboSpan" id="kobo.860.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.861.1">nil</span></span><span class="koboSpan" id="kobo.862.1"> {
        fmt.Println(err)
    }
    http.Handle(</span><span class="hljs-string"><span class="koboSpan" id="kobo.863.1">"/"</span></span><span class="koboSpan" id="kobo.864.1">, r)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.865.1">So, the general idea behind </span><code class="inlineCode"><span class="koboSpan" id="kobo.866.1">walkAll.go</span></code><span class="koboSpan" id="kobo.867.1"> is that you assign an empty handler to each route that you have in your server and then you call </span><code class="inlineCode"><span class="koboSpan" id="kobo.868.1">mux.Walk()</span></code><span class="koboSpan" id="kobo.869.1"> to visit all routes. </span><span class="koboSpan" id="kobo.869.2">Enabling Go modules and running </span><code class="inlineCode"><span class="koboSpan" id="kobo.870.1">walkAll.go</span></code><span class="koboSpan" id="kobo.871.1"> generates the next output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.872.1">$ </span></span><span class="koboSpan" id="kobo.873.1">go mod init
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.874.1">$ </span></span><span class="koboSpan" id="kobo.875.1">go mod tidy
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.876.1">$ </span></span><span class="koboSpan" id="kobo.877.1">go run walkAll.go
Queries templates: 
Queries regexps: 
Methods: GET
ROUTE: /time
Path regexp: ^/time$
Queries templates: 
Queries regexps: 
Methods: GET
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.878.1">The output</span><a id="_idIndexMarker1035"/><span class="koboSpan" id="kobo.879.1"> shows the HTTP methods that each route supports as </span><a id="_idIndexMarker1036"/><span class="koboSpan" id="kobo.880.1">well as the format of the path. </span><span class="koboSpan" id="kobo.880.2">So, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.881.1">/time</span></code><span class="koboSpan" id="kobo.882.1"> endpoint works with </span><code class="inlineCode"><span class="koboSpan" id="kobo.883.1">GET</span></code><span class="koboSpan" id="kobo.884.1"> and its path is </span><code class="inlineCode"><span class="koboSpan" id="kobo.885.1">/time</span></code><span class="koboSpan" id="kobo.886.1"> because the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.887.1">Path</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.888.1">regexp</span></code><span class="koboSpan" id="kobo.889.1"> means that </span><code class="inlineCode"><span class="koboSpan" id="kobo.890.1">/time</span></code><span class="koboSpan" id="kobo.891.1"> is between the beginning (</span><code class="inlineCode"><span class="koboSpan" id="kobo.892.1">^</span></code><span class="koboSpan" id="kobo.893.1">) and the end of the path (</span><code class="inlineCode"><span class="koboSpan" id="kobo.894.1">$</span></code><span class="koboSpan" id="kobo.895.1">).</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.896.1">ROUTE: /getall
Path regexp: ^/getall$
Queries templates: 
Queries regexps: 
Methods: GET
ROUTE: /getid
Path regexp: ^/getid$
Queries templates: 
Queries regexps: 
Methods: GET
ROUTE: /logged
Path regexp: ^/logged$
Queries templates: 
Queries regexps: 
Methods: GET
ROUTE: /username/{id:[0-9]+}
Path regexp: ^/username/(?P&lt;v0&gt;[0-9]+)$
Queries templates: 
Queries regexps: 
Methods: GET
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.897.1">In the </span><a id="_idIndexMarker1037"/><span class="koboSpan" id="kobo.898.1">case of </span><code class="inlineCode"><span class="koboSpan" id="kobo.899.1">/username</span></code><span class="koboSpan" id="kobo.900.1">, the output includes the regular </span><a id="_idIndexMarker1038"/><span class="koboSpan" id="kobo.901.1">expressions associated with the endpoint that is used for selecting the value of the id variable.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.902.1">Queries templates: 
Queries regexps: 
Methods: PUT
ROUTE: /update
Path regexp: ^/update$
Queries templates: 
Queries regexps: 
Methods: PUT
Queries templates: 
Queries regexps: 
Methods: POST
ROUTE: /add
Path regexp: ^/add$
Queries templates: 
Queries regexps: 
Methods: POST
ROUTE: /login
Path regexp: ^/login$
Queries templates: 
Queries regexps: 
Methods: POST
ROUTE: /logout
Path regexp: ^/logout$
Queries templates: 
Queries regexps: 
Methods: POST
Queries templates: 
Queries regexps: 
Methods: DELETE
ROUTE: /username/{id:[0-9]+}
Path regexp: ^/username/(?P&lt;v0&gt;[0-9]+)$
Queries templates: 
Queries regexps: 
Methods: DELETE
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.903.1">Although </span><a id="_idIndexMarker1039"/><span class="koboSpan" id="kobo.904.1">visiting the routes of a web server is a kind of</span><a id="_idIndexMarker1040"/><span class="koboSpan" id="kobo.905.1"> testing, it is not the official Go way of testing. </span><span class="koboSpan" id="kobo.905.2">The main thing to look for in such output is the absence of an endpoint, the use of the wrong HTTP method, or the absence of a parameter from an endpoint.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.906.1">The next section discusses the testing of Go code.</span></p>
<h1 class="heading-1" id="_idParaDest-344"><span class="koboSpan" id="kobo.907.1">Testing Go code</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.908.1">The subject of this </span><a id="_idIndexMarker1041"/><span class="koboSpan" id="kobo.909.1">section is the testing of Go code by </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.910.1">writing test functions</span></strong><span class="koboSpan" id="kobo.911.1">. </span><span class="koboSpan" id="kobo.911.2">Software testing is a very large subject and cannot be covered in a single section of a chapter in a book. </span><span class="koboSpan" id="kobo.911.3">So, this section tries to present as much practical information as possible.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.912.1">Go allows you to write tests for your Go code to detect bugs. </span><span class="koboSpan" id="kobo.912.2">However, software testing can only show the presence of one or more bugs, not the absence of bugs. </span><span class="koboSpan" id="kobo.912.3">This means that you can never be 100% sure that your code contains no bugs!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.913.1">Strictly speaking, this section is about automated testing, which involves writing extra code to verify whether the real code—that is, the production code—works as expected or not. </span><span class="koboSpan" id="kobo.913.2">Thus, the result of a test function is either </span><code class="inlineCode"><span class="koboSpan" id="kobo.914.1">PASS</span></code><span class="koboSpan" id="kobo.915.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.916.1">FAIL</span></code><span class="koboSpan" id="kobo.917.1">. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.918.1">You will see how this works shortly. </span><span class="koboSpan" id="kobo.918.2">Although the Go approach to testing might look simple at first, especially if you compare it with the testing practices of other programming languages, it is very efficient and effective because it does not require too much of the developer’s time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.919.1">Go follows certain conventions regarding testing (and benchmarking). </span><span class="koboSpan" id="kobo.919.2">The most important convention is that the name of a test function must begin with </span><code class="inlineCode"><span class="koboSpan" id="kobo.920.1">Test</span></code><span class="koboSpan" id="kobo.921.1">. </span><span class="koboSpan" id="kobo.921.2">After the </span><code class="inlineCode"><span class="koboSpan" id="kobo.922.1">Test</span></code><span class="koboSpan" id="kobo.923.1"> word, we must put an underscore or an uppercase letter. </span><span class="koboSpan" id="kobo.923.2">Therefore, both </span><code class="inlineCode"><span class="koboSpan" id="kobo.924.1">TestFunctionName()</span></code><span class="koboSpan" id="kobo.925.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.926.1">Test_functionName()</span></code><span class="koboSpan" id="kobo.927.1"> are valid test functions, whereas </span><code class="inlineCode"><span class="koboSpan" id="kobo.928.1">Testfunctionname()</span></code><span class="koboSpan" id="kobo.929.1"> is not. </span><span class="koboSpan" id="kobo.929.2">If you prefer idiomatic Go, then use </span><code class="inlineCode"><span class="koboSpan" id="kobo.930.1">TestFunctionName()</span></code><span class="koboSpan" id="kobo.931.1">. </span><span class="koboSpan" id="kobo.931.2">All such functions are put in files that end with </span><code class="inlineCode"><span class="koboSpan" id="kobo.932.1">_test.go</span></code><span class="koboSpan" id="kobo.933.1">. </span><span class="koboSpan" id="kobo.933.2">All test functions must have a </span><code class="inlineCode"><span class="koboSpan" id="kobo.934.1">t *testing.T</span></code><span class="koboSpan" id="kobo.935.1"> parameter and return no values. </span><span class="koboSpan" id="kobo.935.2">Lastly, packages that contain testing code should include the </span><code class="inlineCode"><span class="koboSpan" id="kobo.936.1">testing</span></code><span class="koboSpan" id="kobo.937.1"> package.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.938.1">Once the testing code is correct, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.939.1">go test</span></code><span class="koboSpan" id="kobo.940.1"> subcommand does all the dirty work for you, which includes scanning all </span><code class="inlineCode"><span class="koboSpan" id="kobo.941.1">*_test.go</span></code><span class="koboSpan" id="kobo.942.1"> files for special functions, generating a proper temporary </span><code class="inlineCode"><span class="koboSpan" id="kobo.943.1">main</span></code><span class="koboSpan" id="kobo.944.1"> package, calling these special functions, getting the results, and generating the final output.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.945.1">Now, let us present testing by revisiting the </span><code class="inlineCode"><span class="koboSpan" id="kobo.946.1">matchInt()</span></code><span class="koboSpan" id="kobo.947.1"> function from </span><em class="chapterRef"><span class="koboSpan" id="kobo.948.1">Chapter 3</span></em><span class="koboSpan" id="kobo.949.1">, </span><em class="italic"><span class="koboSpan" id="kobo.950.1">Composite Data Types</span></em><span class="koboSpan" id="kobo.951.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-345"><span class="koboSpan" id="kobo.952.1">Writing tests for ./ch03/intRE.go</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.953.1">In this subsection, we write</span><a id="_idIndexMarker1042"/><span class="koboSpan" id="kobo.954.1"> tests for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.955.1">matchInt()</span></code><span class="koboSpan" id="kobo.956.1"> function, which was implemented in </span><code class="inlineCode"><span class="koboSpan" id="kobo.957.1">intRE.go</span></code><span class="koboSpan" id="kobo.958.1"> back in </span><em class="chapterRef"><span class="koboSpan" id="kobo.959.1">Chapter 3</span></em><span class="koboSpan" id="kobo.960.1">, </span><em class="italic"><span class="koboSpan" id="kobo.961.1">Composite Data Types</span></em><span class="koboSpan" id="kobo.962.1">. </span><span class="koboSpan" id="kobo.962.2">First, we create a new file named </span><code class="inlineCode"><span class="koboSpan" id="kobo.963.1">intRE_test.go</span></code><span class="koboSpan" id="kobo.964.1">, which is going to contain all tests. </span><span class="koboSpan" id="kobo.964.2">Then, we rename the package from </span><code class="inlineCode"><span class="koboSpan" id="kobo.965.1">main</span></code><span class="koboSpan" id="kobo.966.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.967.1">testRE</span></code><span class="koboSpan" id="kobo.968.1"> and remove the </span><code class="inlineCode"><span class="koboSpan" id="kobo.969.1">main()</span></code><span class="koboSpan" id="kobo.970.1"> function—this is an optional step. </span><span class="koboSpan" id="kobo.970.2">After that, we must decide what we are going to test and how. </span><span class="koboSpan" id="kobo.970.3">The main steps in testing include writing tests for expected input, unexpected input, empty input, and edge cases. </span><span class="koboSpan" id="kobo.970.4">All these are going to be seen in the code. </span><span class="koboSpan" id="kobo.970.5">Additionally, we are going to generate random integers, convert them into strings, and use them as input for </span><code class="inlineCode"><span class="koboSpan" id="kobo.971.1">matchInt()</span></code><span class="koboSpan" id="kobo.972.1">. </span><span class="koboSpan" id="kobo.972.2">Generally speaking, a good way to test functions that work with numeric values is by using random numbers, or random values in general, as input and see how your code behaves and handles these values.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.973.1">The relevant code, which includes the original version of </span><code class="inlineCode"><span class="koboSpan" id="kobo.974.1">intRE.go</span></code><span class="koboSpan" id="kobo.975.1">, can be found inside </span><code class="inlineCode"><span class="koboSpan" id="kobo.976.1">~/go/src/github.com/mactsouk/mGo4th/ch12/intRE</span></code><span class="koboSpan" id="kobo.977.1"> and is composed of two test functions. </span><span class="koboSpan" id="kobo.977.2">The two test functions of </span><code class="inlineCode"><span class="koboSpan" id="kobo.978.1">intRE_test.go</span></code><span class="koboSpan" id="kobo.979.1"> are the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.980.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.981.1">TestMatchInt</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.982.1">(t *testing.T)</span></span><span class="koboSpan" id="kobo.983.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.984.1">if</span></span><span class="koboSpan" id="kobo.985.1"> matchInt(</span><span class="hljs-string"><span class="koboSpan" id="kobo.986.1">""</span></span><span class="koboSpan" id="kobo.987.1">) {
        t.Error(</span><span class="hljs-string"><span class="koboSpan" id="kobo.988.1">`matchInt("") != false`</span></span><span class="koboSpan" id="kobo.989.1">)
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.990.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.991.1">matchInt("")</span></code><span class="koboSpan" id="kobo.992.1"> call should return </span><code class="inlineCode"><span class="koboSpan" id="kobo.993.1">false</span></code><span class="koboSpan" id="kobo.994.1">, so if it returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.995.1">true</span></code><span class="koboSpan" id="kobo.996.1">, it means that the function does not work as expected.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.997.1">if</span></span><span class="koboSpan" id="kobo.998.1"> matchInt(</span><span class="hljs-string"><span class="koboSpan" id="kobo.999.1">"00"</span></span><span class="koboSpan" id="kobo.1000.1">) == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1001.1">false</span></span><span class="koboSpan" id="kobo.1002.1"> {
        t.Error(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1003.1">`matchInt("00") != true`</span></span><span class="koboSpan" id="kobo.1004.1">)
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1005.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1006.1">matchInt("00")</span></code><span class="koboSpan" id="kobo.1007.1"> call should return </span><code class="inlineCode"><span class="koboSpan" id="kobo.1008.1">true</span></code><span class="koboSpan" id="kobo.1009.1"> because </span><code class="inlineCode"><span class="koboSpan" id="kobo.1010.1">00</span></code><span class="koboSpan" id="kobo.1011.1"> is a valid integer, so if it returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.1012.1">false</span></code><span class="koboSpan" id="kobo.1013.1">, it means that the function does not work as expected.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1014.1">if</span></span><span class="koboSpan" id="kobo.1015.1"> matchInt(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1016.1">"-00"</span></span><span class="koboSpan" id="kobo.1017.1">) == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1018.1">false</span></span><span class="koboSpan" id="kobo.1019.1"> {
        t.Error(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1020.1">`matchInt("-00") != true`</span></span><span class="koboSpan" id="kobo.1021.1">)
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1022.1">if</span></span><span class="koboSpan" id="kobo.1023.1"> matchInt(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1024.1">"+00"</span></span><span class="koboSpan" id="kobo.1025.1">) == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1026.1">false</span></span><span class="koboSpan" id="kobo.1027.1"> {
        t.Error(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1028.1">`matchInt("+00") != true`</span></span><span class="koboSpan" id="kobo.1029.1">)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1030.1">This first</span><a id="_idIndexMarker1043"/><span class="koboSpan" id="kobo.1031.1"> test function uses static input to test the correctness of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1032.1">matchInt()</span></code><span class="koboSpan" id="kobo.1033.1">. </span><span class="koboSpan" id="kobo.1033.2">As discussed earlier, a testing function requires a single </span><code class="inlineCode"><span class="koboSpan" id="kobo.1034.1">*testing.T</span></code><span class="koboSpan" id="kobo.1035.1"> parameter and returns no values.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1036.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1037.1">TestWithRandom</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1038.1">(t *testing.T)</span></span><span class="koboSpan" id="kobo.1039.1"> {
    n := strconv.Itoa(random(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1040.1">-100000</span></span><span class="koboSpan" id="kobo.1041.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1042.1">19999</span></span><span class="koboSpan" id="kobo.1043.1">))
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1044.1">if</span></span><span class="koboSpan" id="kobo.1045.1"> matchInt(n) == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1046.1">false</span></span><span class="koboSpan" id="kobo.1047.1"> {
        t.Error(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1048.1">"n = "</span></span><span class="koboSpan" id="kobo.1049.1">, n)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1050.1">The second test function uses a random but valid input to test </span><code class="inlineCode"><span class="koboSpan" id="kobo.1051.1">matchInt()</span></code><span class="koboSpan" id="kobo.1052.1">—that random input is generated by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1053.1">random()</span></code><span class="koboSpan" id="kobo.1054.1"> function, which is also implemented in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1055.1">intRE_test.go</span></code><span class="koboSpan" id="kobo.1056.1">. </span><span class="koboSpan" id="kobo.1056.2">Therefore, the given input should always pass the test. </span><span class="koboSpan" id="kobo.1056.3">Running the two test functions with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1057.1">go test</span></code><span class="koboSpan" id="kobo.1058.1"> creates the next output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1059.1">$ </span></span><span class="koboSpan" id="kobo.1060.1">go </span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.1061.1">test</span></span><span class="koboSpan" id="kobo.1062.1"> -v *.go
=== RUN   TestMatchInt
--- PASS: TestMatchInt (0.00s)
=== RUN   TestWithRandom
--- PASS: TestWithRandom (0.00s)
PASS
ok    command-line-arguments    0.580s
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1063.1">So, all tests</span><a id="_idIndexMarker1044"/><span class="koboSpan" id="kobo.1064.1"> passed, which means that everything is fine with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1065.1">matchInt()</span></code><span class="koboSpan" id="kobo.1066.1">—in general, the simpler the operation of a function is, the easier it is to test it. </span><span class="koboSpan" id="kobo.1066.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1067.1">-v</span></code><span class="koboSpan" id="kobo.1068.1"> parameter creates verbose output and can be omitted.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1069.1">The next subsection shows how to test UNIX signals.</span></p>
<h2 class="heading-2" id="_idParaDest-346"><span class="koboSpan" id="kobo.1070.1">Testing UNIX signals</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1071.1">There exists a technique for</span><a id="_idIndexMarker1045"/><span class="koboSpan" id="kobo.1072.1"> testing UNIX signals. </span><span class="koboSpan" id="kobo.1072.2">Why do system signals need special treatment? </span><span class="koboSpan" id="kobo.1072.3">The main reason is that it is difficult to send a UNIX signal to a running UNIX process, which means that it is also difficult to manually test a process that handles UNIX signals. </span><span class="koboSpan" id="kobo.1072.4">The other tricky reason is that there is a possibility that you exit your running tests by accident when you receive a signal that is defined to do so.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1073.1">The relevant </span><a id="_idIndexMarker1046"/><span class="koboSpan" id="kobo.1074.1">code can be found inside </span><code class="inlineCode"><span class="koboSpan" id="kobo.1075.1">ch12/testSignals</span></code><span class="koboSpan" id="kobo.1076.1">, which contains two files named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1077.1">signalsTest.go</span></code><span class="koboSpan" id="kobo.1078.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1079.1">signalsTest_test.go</span></code><span class="koboSpan" id="kobo.1080.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1081.1">The structure of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1082.1">signalsTest.go</span></code><span class="koboSpan" id="kobo.1083.1"> is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1084.1">package</span></span><span class="koboSpan" id="kobo.1085.1"> mySignals
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1086.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1087.1">HandleSignal</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1088.1">(sig os.Signal)</span></span><span class="koboSpan" id="kobo.1089.1"> {
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1090.1">"handleSignal() Caught:"</span></span><span class="koboSpan" id="kobo.1091.1">, sig)
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1092.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1093.1">Listener</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1094.1">()</span></span><span class="koboSpan" id="kobo.1095.1"> {
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1096.1">// Function implementation</span></span><span class="koboSpan" id="kobo.1097.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1098.1">So, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1099.1">signalsTest.go</span></code><span class="koboSpan" id="kobo.1100.1"> does not include a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1101.1">main()</span></code><span class="koboSpan" id="kobo.1102.1"> function as it does not implement the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1103.1">main</span></code><span class="koboSpan" id="kobo.1104.1"> package. </span><span class="koboSpan" id="kobo.1104.2">This happens because such an implementation makes testing easier. </span><span class="koboSpan" id="kobo.1104.3">After you make sure that your code works as expected, you can either include it in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1105.1">main</span></code><span class="koboSpan" id="kobo.1106.1"> package or convert the existing file into the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1107.1">main</span></code><span class="koboSpan" id="kobo.1108.1"> package. </span><span class="koboSpan" id="kobo.1108.2">In that case, you just need to change the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1109.1">package</span></code><span class="koboSpan" id="kobo.1110.1"> statement and rename the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1111.1">Listener()</span></code><span class="koboSpan" id="kobo.1112.1"> function to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1113.1">main()</span></code><span class="koboSpan" id="kobo.1114.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1115.1">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1116.1">signalsTest_test.go</span></code><span class="koboSpan" id="kobo.1117.1"> is presented in two parts. </span><span class="koboSpan" id="kobo.1117.2">The first part contains the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1118.1">package</span></span><span class="koboSpan" id="kobo.1119.1"> mySignals
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1120.1">import</span></span><span class="koboSpan" id="kobo.1121.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1122.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1123.1">"syscall"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1124.1">"testing"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1125.1">"time"</span></span><span class="koboSpan" id="kobo.1126.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1127.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1128.1">TestAll</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1129.1">(t *testing.T)</span></span><span class="koboSpan" id="kobo.1130.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1131.1">go</span></span><span class="koboSpan" id="kobo.1132.1"> Listener()
    time.Sleep(time.Second)
    test_SIGUSR1()
    time.Sleep(time.Second)
    test_SIGUSR2()
    time.Sleep(time.Second)
    test_SIGHUP()
    time.Sleep(time.Second)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1133.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1134.1">TestAll()</span></code><span class="koboSpan" id="kobo.1135.1"> function </span><a id="_idIndexMarker1047"/><span class="koboSpan" id="kobo.1136.1">is the only testing function found in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1137.1">signalsTest_test.go</span></code><span class="koboSpan" id="kobo.1138.1">, which means that it is the only one that is going to get executed by </span><code class="inlineCode"><span class="koboSpan" id="kobo.1139.1">go test</span></code><span class="koboSpan" id="kobo.1140.1">. </span><span class="koboSpan" id="kobo.1140.2">Therefore, it would be responsible for calling the other functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.1141.1">signalsTest_test.go</span></code><span class="koboSpan" id="kobo.1142.1"> as well as the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1143.1">Listener()</span></code><span class="koboSpan" id="kobo.1144.1"> function from </span><code class="inlineCode"><span class="koboSpan" id="kobo.1145.1">signalsTest.go</span></code><span class="koboSpan" id="kobo.1146.1">, which is responsible for the handling of the UNIX signals. </span><span class="koboSpan" id="kobo.1146.2">If you forget to call the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1147.1">Listener()</span></code><span class="koboSpan" id="kobo.1148.1"> function, all tests will fail. </span><span class="koboSpan" id="kobo.1148.2">Additionally, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1149.1">Listener()</span></code><span class="koboSpan" id="kobo.1150.1"> needs to be called as a goroutine because, otherwise, all tests will stall as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1151.1">Listener()</span></code><span class="koboSpan" id="kobo.1152.1"> never returns.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1153.1">Bear in mind that if the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1154.1">Listener()</span></code><span class="koboSpan" id="kobo.1155.1"> goroutine stops handling signals for some reason and the program continues to run, the test will still return </span><code class="inlineCode"><span class="koboSpan" id="kobo.1156.1">PASS</span></code><span class="koboSpan" id="kobo.1157.1"> when it actually failed to handle the signal. </span><span class="koboSpan" id="kobo.1157.2">One possible way for this to happen is if the anonymous function in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1158.1">Listener()</span></code><span class="koboSpan" id="kobo.1159.1"> returns prematurely. </span><span class="koboSpan" id="kobo.1159.2">However, normally, this should never happen.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1160.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1161.1">time.Sleep()</span></code><span class="koboSpan" id="kobo.1162.1"> calls give enough time to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1163.1">test_SIGUSR1()</span></code><span class="koboSpan" id="kobo.1164.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1165.1">test_SIGUSR2()</span></code><span class="koboSpan" id="kobo.1166.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1167.1">test_SIGHUP()</span></code><span class="koboSpan" id="kobo.1168.1"> functions to send the UNIX signal and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1169.1">Listener()</span></code><span class="koboSpan" id="kobo.1170.1"> function to handle them sequentially. </span><span class="koboSpan" id="kobo.1170.2">The purpose of the last </span><code class="inlineCode"><span class="koboSpan" id="kobo.1171.1">time.Sleep()</span></code><span class="koboSpan" id="kobo.1172.1"> call is to give </span><code class="inlineCode"><span class="koboSpan" id="kobo.1173.1">Listener()</span></code><span class="koboSpan" id="kobo.1174.1"> time to process the last signal before all tests end.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1175.1">The second part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1176.1">signalsTest_test.go</span></code><span class="koboSpan" id="kobo.1177.1"> comes with the next code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1178.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1179.1">test_SIGUSR1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1180.1">()</span></span><span class="koboSpan" id="kobo.1181.1"> {
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1182.1">"Sending syscall.SIGUSR1"</span></span><span class="koboSpan" id="kobo.1183.1">)
    syscall.Kill(syscall.Getpid(), syscall.SIGUSR1)
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1184.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1185.1">test_SIGUSR2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1186.1">()</span></span><span class="koboSpan" id="kobo.1187.1"> {
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1188.1">"Sending syscall.SIGUSR2"</span></span><span class="koboSpan" id="kobo.1189.1">)
    syscall.Kill(syscall.Getpid(), syscall.SIGUSR2)
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1190.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1191.1">test_SIGHUP</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1192.1">()</span></span><span class="koboSpan" id="kobo.1193.1"> {
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1194.1">"Sending syscall.SIGHUP"</span></span><span class="koboSpan" id="kobo.1195.1">)
    syscall.Kill(syscall.Getpid(), syscall.SIGHUP)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1196.1">Each one of </span><a id="_idIndexMarker1048"/><span class="koboSpan" id="kobo.1197.1">the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1198.1">test_SIGUSR1()</span></code><span class="koboSpan" id="kobo.1199.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1200.1">test_SIGUSR2()</span></code><span class="koboSpan" id="kobo.1201.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1202.1">test_SIGHUP()</span></code><span class="koboSpan" id="kobo.1203.1"> functions sends a different signal to the running UNIX process—the process ID of the running UNIX process is discovered using a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1204.1">syscall.Getpid()</span></code><span class="koboSpan" id="kobo.1205.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1206.1">Running the tests produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1207.1">$ </span></span><span class="koboSpan" id="kobo.1208.1">go </span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.1209.1">test</span></span><span class="koboSpan" id="kobo.1210.1"> -v *.go
=== RUN   TestAll
Process ID: 22100
Sending syscall.SIGUSR1
handleSignal() Caught: user defined signal 1
Execution time: 1.001762208s
Sending syscall.SIGUSR2
handleSignal() Caught: user defined signal 2
Sending syscall.SIGHUP
Caught: hangup
--- PASS: TestAll (4.00s)
PASS
ok    command-line-arguments    4.411s
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1211.1">All tests finish successfully, which means that all signals are handled successfully without the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1212.1">Listener()</span></code><span class="koboSpan" id="kobo.1213.1"> function exiting prematurely.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1214.1">If you run the previous test multiple times, you might get a last line that looks like the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1215.1">ok    command-line-arguments    (cached)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1216.1">The word </span><code class="inlineCode"><span class="koboSpan" id="kobo.1217.1">cached</span></code><span class="koboSpan" id="kobo.1218.1"> in </span><a id="_idIndexMarker1049"/><span class="koboSpan" id="kobo.1219.1">the output tells us that Go used existing testing results to make running the tests faster and did not execute the testing functions, which is not always the desired behavior. </span><span class="koboSpan" id="kobo.1219.2">The next subsection shows how to clear or disable the cache when testing.</span></p>
<h2 class="heading-2" id="_idParaDest-347"><span class="koboSpan" id="kobo.1220.1">Disabling test caching</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1221.1">Testing and caching are </span><a id="_idIndexMarker1050"/><span class="koboSpan" id="kobo.1222.1">not always a good combination, mainly because you get the same results all the time. </span><span class="koboSpan" id="kobo.1222.2">However, it has its benefits if the test inputs and the test subject do not change—this makes it a completely valid condition in several situations. </span><span class="koboSpan" id="kobo.1222.3">There exist two ways to avoid getting results using test caching. </span><span class="koboSpan" id="kobo.1222.4">The first one requires running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1223.1">go clean -testcache</span></code><span class="koboSpan" id="kobo.1224.1">, which cleans the entire testing cache, whereas the second one requires running your tests using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1225.1">-count=1</span></code><span class="koboSpan" id="kobo.1226.1">, which prevents Go from saving any testing cache for the given testing execution.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1227.1">The next subsection discusses the use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1228.1">TempDir()</span></code><span class="koboSpan" id="kobo.1229.1"> method, which is handy when you want to create a temporary place for data during testing or benchmarking.</span></p>
<h2 class="heading-2" id="_idParaDest-348"><span class="koboSpan" id="kobo.1230.1">The testing.TempDir() function</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1231.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1232.1">testing.TempDir()</span></code><span class="koboSpan" id="kobo.1233.1"> method </span><a id="_idIndexMarker1051"/><span class="koboSpan" id="kobo.1234.1">works with both testing and benchmarking. </span><span class="koboSpan" id="kobo.1234.2">Its purpose is to create a temporary directory that will be used during testing (or benchmarking). </span><span class="koboSpan" id="kobo.1234.3">Each call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1235.1">testing.TempDir()</span></code><span class="koboSpan" id="kobo.1236.1"> returns a unique directory. </span><span class="koboSpan" id="kobo.1236.2">Go </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.1237.1">automatically removes</span></strong><span class="koboSpan" id="kobo.1238.1"> that temporary directory when the test and its subtests or the benchmarks are about to finish with the help of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1239.1">CleanUp()</span></code><span class="koboSpan" id="kobo.1240.1"> method—this is arranged by Go and you do not need to use and implement </span><code class="inlineCode"><span class="koboSpan" id="kobo.1241.1">CleanUp()</span></code><span class="koboSpan" id="kobo.1242.1"> on your own.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1243.1">You should not confuse </span><code class="inlineCode"><span class="koboSpan" id="kobo.1244.1">testing.TempDir()</span></code><span class="koboSpan" id="kobo.1245.1"> with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1246.1">os.TempDir()</span></code><span class="koboSpan" id="kobo.1247.1">. </span><span class="koboSpan" id="kobo.1247.2">We already saw the use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1248.1">os.TempDir()</span></code><span class="koboSpan" id="kobo.1249.1"> method in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1250.1">profileCla.go</span></code><span class="koboSpan" id="kobo.1251.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1252.1">traceCLA.go</span></code><span class="koboSpan" id="kobo.1253.1"> at the beginning of this chapter. </span><code class="inlineCode"><span class="koboSpan" id="kobo.1254.1">os.TempDir()</span></code><span class="koboSpan" id="kobo.1255.1"> returns the default directory to use for temporary files, whereas </span><code class="inlineCode"><span class="koboSpan" id="kobo.1256.1">testing.TempDir()</span></code><span class="koboSpan" id="kobo.1257.1"> returns a temporary directory for the current test to use.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1258.1">The exact place where the temporary directory is going to be created depends on the operating system used. </span><span class="koboSpan" id="kobo.1258.2">On macOS, it is under </span><code class="inlineCode"><span class="koboSpan" id="kobo.1259.1">/var/folders</span></code><span class="koboSpan" id="kobo.1260.1">, whereas on Linux, it is under </span><code class="inlineCode"><span class="koboSpan" id="kobo.1261.1">/tmp</span></code><span class="koboSpan" id="kobo.1262.1">. </span><span class="koboSpan" id="kobo.1262.2">We are going to illustrate </span><code class="inlineCode"><span class="koboSpan" id="kobo.1263.1">testing.TempDir()</span></code><span class="koboSpan" id="kobo.1264.1"> in the next subsection, where we also talk about </span><code class="inlineCode"><span class="koboSpan" id="kobo.1265.1">Cleanup()</span></code><span class="koboSpan" id="kobo.1266.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-349"><span class="koboSpan" id="kobo.1267.1">The Cleanup() function</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1268.1">Although we present the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1269.1">Cleanup()</span></code><span class="koboSpan" id="kobo.1270.1"> method</span><a id="_idIndexMarker1052"/><span class="koboSpan" id="kobo.1271.1"> in a testing scenario, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1272.1">Cleanup()</span></code><span class="koboSpan" id="kobo.1273.1"> works for both testing and benchmarking. </span><span class="koboSpan" id="kobo.1273.2">Its name reveals its purpose, which is to clean up some things that we have created when testing or benchmarking a package. </span><span class="koboSpan" id="kobo.1273.3">However, it is we who need to tell </span><code class="inlineCode"><span class="koboSpan" id="kobo.1274.1">Cleanup()</span></code><span class="koboSpan" id="kobo.1275.1"> what to do—the parameter of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1276.1">Cleanup()</span></code><span class="koboSpan" id="kobo.1277.1"> is a function that does the cleaning up. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.1278.1">That function is usually implemented inline as an anonymous function, but you can also create it elsewhere and call it by its name.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1279.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1280.1">cleanup.go</span></code><span class="koboSpan" id="kobo.1281.1"> file contains a dummy function named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1282.1">Foo()</span></code><span class="koboSpan" id="kobo.1283.1">—as it contains no real code, there is no point in presenting it. </span><span class="koboSpan" id="kobo.1283.2">On the other hand, all important code can be found in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1284.1">cleanup_test.go</span></code><span class="koboSpan" id="kobo.1285.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1286.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1287.1">myCleanUp</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1288.1">()</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1289.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1290.1">()</span></span><span class="koboSpan" id="kobo.1291.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1292.1">return</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1293.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1294.1">()</span></span><span class="koboSpan" id="kobo.1295.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1296.1">"Cleaning up!"</span></span><span class="koboSpan" id="kobo.1297.1">)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1298.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1299.1">myCleanUp()</span></code><span class="koboSpan" id="kobo.1300.1"> function is going to be used as a parameter to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1301.1">CleanUp()</span></code><span class="koboSpan" id="kobo.1302.1"> and should have that specific signature. </span><span class="koboSpan" id="kobo.1302.2">Apart from the signature, you can put any kind of code in the implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1303.1">myCleanUp()</span></code><span class="koboSpan" id="kobo.1304.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1305.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1306.1">TestFoo</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1307.1">(t *testing.T)</span></span><span class="koboSpan" id="kobo.1308.1"> {
    t1 := path.Join(os.TempDir(), </span><span class="hljs-string"><span class="koboSpan" id="kobo.1309.1">"test01"</span></span><span class="koboSpan" id="kobo.1310.1">)
    t2 := path.Join(os.TempDir(), </span><span class="hljs-string"><span class="koboSpan" id="kobo.1311.1">"test02"</span></span><span class="koboSpan" id="kobo.1312.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1313.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1314.1">t1</span></code><span class="koboSpan" id="kobo.1315.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1316.1">t2</span></code><span class="koboSpan" id="kobo.1317.1"> variables hold the paths of two directories that we are going to create.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1318.1">    err := os.Mkdir(t1, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1319.1">0755</span></span><span class="koboSpan" id="kobo.1320.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1321.1">if</span></span><span class="koboSpan" id="kobo.1322.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1323.1">nil</span></span><span class="koboSpan" id="kobo.1324.1"> {
        t.Error(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1325.1">"os.Mkdir() failed:"</span></span><span class="koboSpan" id="kobo.1326.1">, err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1327.1">return</span></span><span class="koboSpan" id="kobo.1328.1">
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1329.1">The previous code creates a directory using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1330.1">os.Mkdir()</span></code><span class="koboSpan" id="kobo.1331.1">—we manually specify its path. </span><span class="koboSpan" id="kobo.1331.2">Therefore, it is our duty to delete</span><a id="_idIndexMarker1053"/><span class="koboSpan" id="kobo.1332.1"> that directory when it is no longer needed.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1333.1">defer</span></span><span class="koboSpan" id="kobo.1334.1"> t.Cleanup(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1335.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1336.1">()</span></span><span class="koboSpan" id="kobo.1337.1"> {
        err = os.Remove(t1)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1338.1">if</span></span><span class="koboSpan" id="kobo.1339.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1340.1">nil</span></span><span class="koboSpan" id="kobo.1341.1"> {
            t.Error(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1342.1">"os.Mkdir() failed:"</span></span><span class="koboSpan" id="kobo.1343.1">, err)
        }
    })
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1344.1">After </span><code class="inlineCode"><span class="koboSpan" id="kobo.1345.1">TestFoo()</span></code><span class="koboSpan" id="kobo.1346.1"> finishes, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1347.1">t1</span></code><span class="koboSpan" id="kobo.1348.1"> is deleted by the code of the anonymous function that is passed as a parameter to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1349.1">t.CleanUp()</span></code><span class="koboSpan" id="kobo.1350.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1351.1">    err = os.Mkdir(t2, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1352.1">0755</span></span><span class="koboSpan" id="kobo.1353.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1354.1">if</span></span><span class="koboSpan" id="kobo.1355.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1356.1">nil</span></span><span class="koboSpan" id="kobo.1357.1"> {
        t.Error(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1358.1">"os.Mkdir() failed:"</span></span><span class="koboSpan" id="kobo.1359.1">, err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1360.1">return</span></span><span class="koboSpan" id="kobo.1361.1">
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1362.1">We create another directory with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1363.1">os.Mkdir()</span></code><span class="koboSpan" id="kobo.1364.1">—however, in this case, we are not deleting that directory. </span><span class="koboSpan" id="kobo.1364.2">Therefore, after </span><code class="inlineCode"><span class="koboSpan" id="kobo.1365.1">TestFoo()</span></code><span class="koboSpan" id="kobo.1366.1"> finishes, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1367.1">t2</span></code><span class="koboSpan" id="kobo.1368.1"> is not going to be deleted.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1369.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1370.1">TestBar</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1371.1">(t *testing.T)</span></span><span class="koboSpan" id="kobo.1372.1"> {
    t1 := t.TempDir()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1373.1">Because of the use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1374.1">testing.TempDir()</span></code><span class="koboSpan" id="kobo.1375.1"> method, the value (directory path) of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1376.1">t1</span></code><span class="koboSpan" id="kobo.1377.1"> is assigned by the operating system. </span><span class="koboSpan" id="kobo.1377.2">Additionally, that directory path is </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.1378.1">automatically deleted</span></strong><span class="koboSpan" id="kobo.1379.1"> when the test function is about to finish.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1380.1">    fmt.Println(t1)
    t.Cleanup(myCleanUp())
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1381.1">Here we use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1382.1">myCleanUp()</span></code><span class="koboSpan" id="kobo.1383.1"> as the</span><a id="_idIndexMarker1054"/><span class="koboSpan" id="kobo.1384.1"> parameter to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1385.1">Cleanup()</span></code><span class="koboSpan" id="kobo.1386.1">. </span><span class="koboSpan" id="kobo.1386.2">This is handy when you want to perform the same cleanup multiple times. </span><span class="koboSpan" id="kobo.1386.3">Running the tests creates the next output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1387.1">$ </span></span><span class="koboSpan" id="kobo.1388.1">go </span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.1389.1">test</span></span><span class="koboSpan" id="kobo.1390.1"> -v *.go
=== RUN   TestFoo
--- PASS: TestFoo (0.00s)
=== RUN   TestBar
/var/folders/sk/ltk8cnw50lzdtr2hxcj5sv2m0000gn/T/TestBar1090994662/001
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1391.1">This is the temporary directory that was created with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1392.1">TempDir()</span></code><span class="koboSpan" id="kobo.1393.1"> on a macOS machine.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1394.1">Cleaning up!
</span><span class="koboSpan" id="kobo.1394.2">--- PASS: TestBar (0.00s)
PASS
ok    command-line-arguments        0.493s
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1395.1">Checking whether the directories created by </span><code class="inlineCode"><span class="koboSpan" id="kobo.1396.1">TempDir()</span></code><span class="koboSpan" id="kobo.1397.1"> are there shows that they have been successfully deleted. </span><span class="koboSpan" id="kobo.1397.2">On the other hand, the directory stored in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1398.1">t2</span></code><span class="koboSpan" id="kobo.1399.1"> variable of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1400.1">TestFoo()</span></code><span class="koboSpan" id="kobo.1401.1"> has not been deleted. </span><span class="koboSpan" id="kobo.1401.2">Running the same tests again (remember to disable caching) is going to fail because the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1402.1">test02</span></code><span class="koboSpan" id="kobo.1403.1"> file already exists and cannot be created:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1404.1">$ </span></span><span class="koboSpan" id="kobo.1405.1">go </span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.1406.1">test</span></span><span class="koboSpan" id="kobo.1407.1"> -v *.go -count=1
=== RUN   TestFoo
    cleanup_test.go:34: os.Mkdir() failed: mkdir /var/folders/sk/ltk8cnw50lzdtr2hxcj5sv2m0000gn/T/test02: file exists
--- FAIL: TestFoo (0.00s)
=== RUN   TestBar
/var/folders/sk/ltk8cnw50lzdtr2hxcj5sv2m0000gn/T/TestBar1703429008/001
Cleaning up!
</span><span class="koboSpan" id="kobo.1407.2">--- PASS: TestBar (0.00s)
FAIL
FAIL    command-line-arguments    0.310s
FAIL
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1408.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1409.1">/var/folders/sk/ltk8cnw50lzdtr2hxcj5sv2m0000gn/T/test02: file exists</span></code><span class="koboSpan" id="kobo.1410.1"> error message reveals the root of the problem. </span><span class="koboSpan" id="kobo.1410.2">So, </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.1411.1">clean up your tests properly</span></strong><span class="koboSpan" id="kobo.1412.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1413.1">The next subsection discusses the use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1414.1">testing/quick</span></code><span class="koboSpan" id="kobo.1415.1"> package.</span></p>
<h2 class="heading-2" id="_idParaDest-350"><span class="koboSpan" id="kobo.1416.1">The testing/quick package</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1417.1">There are times when you need to</span><a id="_idIndexMarker1055"/><span class="koboSpan" id="kobo.1418.1"> create testing data without human intervention. </span><span class="koboSpan" id="kobo.1418.2">The Go standard library offers the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1419.1">testing/quick</span></code><span class="koboSpan" id="kobo.1420.1"> package, which can be used for </span><em class="italic"><span class="koboSpan" id="kobo.1421.1">black-box testing</span></em><span class="koboSpan" id="kobo.1422.1"> (a software testing method that checks the functionality of an application or function without any prior knowledge of its internal working) and is somewhat related to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1423.1">QuickCheck</span></code><span class="koboSpan" id="kobo.1424.1"> package found in the Haskell programming language—both packages implement utility functions to help you with black-box testing. </span><span class="koboSpan" id="kobo.1424.2">With the help of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1425.1">testing/quick</span></code><span class="koboSpan" id="kobo.1426.1">, Go generates random values of built-in types that you can use for testing, which saves you from having to generate all these values manually.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1427.1">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1428.1">quickT.go</span></code><span class="koboSpan" id="kobo.1429.1"> is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1430.1">package</span></span><span class="koboSpan" id="kobo.1431.1"> quickt
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1432.1">type</span></span><span class="koboSpan" id="kobo.1433.1"> Point2D </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1434.1">struct</span></span><span class="koboSpan" id="kobo.1435.1"> {
    X, Y </span><span class="hljs-type"><span class="koboSpan" id="kobo.1436.1">int</span></span><span class="koboSpan" id="kobo.1437.1">
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1438.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1439.1">Add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1440.1">(x1, x2 Point2D)</span></span><span class="koboSpan" id="kobo.1441.1"> Point2D {
    temp := Point2D{}
    temp.X = x1.X + x2.X
    temp.Y = x1.Y + x2.Y
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1442.1">return</span></span><span class="koboSpan" id="kobo.1443.1"> temp
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1444.1">The previous code implements a single function that adds two </span><code class="inlineCode"><span class="koboSpan" id="kobo.1445.1">Point2D</span></code><span class="koboSpan" id="kobo.1446.1"> variables—this is the function that we are going to test.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1447.1">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1448.1">quickT_test.go</span></code><span class="koboSpan" id="kobo.1449.1"> is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1450.1">package</span></span><span class="koboSpan" id="kobo.1451.1"> quickt
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1452.1">import</span></span><span class="koboSpan" id="kobo.1453.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1454.1">"testing"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1455.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1456.1">testing/quick"</span></span><span class="koboSpan" id="kobo.1457.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1458.1">var</span></span><span class="koboSpan" id="kobo.1459.1"> N = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1460.1">1000000</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1461.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1462.1">TestWithItself</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1463.1">(t *testing.T)</span></span><span class="koboSpan" id="kobo.1464.1"> {
    condition := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1465.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1466.1">(a, b Point2D)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1467.1">bool</span></span><span class="koboSpan" id="kobo.1468.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1469.1">return</span></span><span class="koboSpan" id="kobo.1470.1"> Add(a, b) == Add(b, a)
    }
    err := quick.Check(condition, &amp;quick.Config{MaxCount: N})
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1471.1">if</span></span><span class="koboSpan" id="kobo.1472.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1473.1">nil</span></span><span class="koboSpan" id="kobo.1474.1"> {
        t.Errorf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1475.1">"Error: %v"</span></span><span class="koboSpan" id="kobo.1476.1">, err)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1477.1">The call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1478.1">quick.Check()</span></code><span class="koboSpan" id="kobo.1479.1"> automatically </span><a id="_idIndexMarker1056"/><span class="koboSpan" id="kobo.1480.1">generates random numbers based on the signature of its first argument, which is a function defined earlier. </span><span class="koboSpan" id="kobo.1480.2">There is no need to create these random numbers on your own, which makes the code easy to read and write. </span><span class="koboSpan" id="kobo.1480.3">The actual tests happen in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1481.1">condition</span></code><span class="koboSpan" id="kobo.1482.1"> function. </span><span class="koboSpan" id="kobo.1482.2">Put simply, we start by defining a property function that represents a condition that we want to hold true for a range of inputs. </span><span class="koboSpan" id="kobo.1482.3">This function takes the input values and returns a Boolean value indicating whether the property holds for those values or not.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1483.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1484.1">TestThree</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1485.1">(t *testing.T)</span></span><span class="koboSpan" id="kobo.1486.1"> {
    condition := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1487.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1488.1">(a, b, c Point2D)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1489.1">bool</span></span><span class="koboSpan" id="kobo.1490.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1491.1">return</span></span><span class="koboSpan" id="kobo.1492.1"> Add(Add(a, b), c) == Add(a, b)
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1493.1">This implementation is wrong on purpose. </span><span class="koboSpan" id="kobo.1493.2">To correct the implementation, we should replace </span><code class="inlineCode"><span class="koboSpan" id="kobo.1494.1">Add(Add(a, b), c) == Add(a, b)</span></code><span class="koboSpan" id="kobo.1495.1"> with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1496.1">Add(Add(a, b), c) == Add(c, Add(a, b))</span></code><span class="koboSpan" id="kobo.1497.1">. </span><span class="koboSpan" id="kobo.1497.2">We did that to see the output that is generated when a test fails.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1498.1">    err := quick.Check(condition, &amp;quick.Config{MaxCount: N})
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1499.1">if</span></span><span class="koboSpan" id="kobo.1500.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1501.1">nil</span></span><span class="koboSpan" id="kobo.1502.1"> {
        t.Errorf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1503.1">"Error: %v"</span></span><span class="koboSpan" id="kobo.1504.1">, err)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1505.1">Running the created tests generates the next output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1506.1">$ </span></span><span class="koboSpan" id="kobo.1507.1">go </span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.1508.1">test</span></span><span class="koboSpan" id="kobo.1509.1"> -v *.go
=== RUN   TestWithItself
--- PASS: TestWithItself (0.86s)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1510.1">As expected, the first test was successful.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1511.1">=== RUN   TestThree
    quickT_test.go:28: Error: #1: failed on input quickT.Point2D{X:-8079189616506550499, Y:-6176385978113309642}, quickT.Point2D{X:9017849222923794558, Y:-7161977443830767080}, quickT.Point2D{X:-714979330681957566, Y:-4578147860393889265}
--- FAIL: TestThree (0.00s)
FAIL
FAIL    command-line-arguments  0.618s
FAIL
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1512.1">However, as </span><a id="_idIndexMarker1057"/><span class="koboSpan" id="kobo.1513.1">expected, the second test generated an error. </span><span class="koboSpan" id="kobo.1513.2">The good thing is that the input that caused the error is presented onscreen so that you can see the input that caused your function to fail.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1514.1">The next subsection tells us how to time out tests that take too long to finish.</span></p>
<h2 class="heading-2" id="_idParaDest-351"><span class="koboSpan" id="kobo.1515.1">Timing out tests</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1516.1">If the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1517.1">go test</span></code><span class="koboSpan" id="kobo.1518.1"> tool takes too long </span><a id="_idIndexMarker1058"/><span class="koboSpan" id="kobo.1519.1">to finish or, for some reason, never ends, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1520.1">-timeout</span></code><span class="koboSpan" id="kobo.1521.1"> parameter can help you.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1522.1">To illustrate that, we are using the code from the previous subsection as well as the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1523.1">-timeout</span></code><span class="koboSpan" id="kobo.1524.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1525.1">-count</span></code><span class="koboSpan" id="kobo.1526.1"> command line flags. </span><span class="koboSpan" id="kobo.1526.2">While the former specifies the maximum allowed time duration for the tests, the latter specifies the number of times the tests are going to be executed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1527.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1528.1">go test -v *.go -timeout 1s</span></code><span class="koboSpan" id="kobo.1529.1"> tells </span><code class="inlineCode"><span class="koboSpan" id="kobo.1530.1">go test</span></code><span class="koboSpan" id="kobo.1531.1"> that all tests should take at most one second to finish—on my machine, the tests did take less than a second to finish. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.1532.1">However, running the following generates a different output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1533.1">$ </span></span><span class="koboSpan" id="kobo.1534.1">go </span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.1535.1">test</span></span><span class="koboSpan" id="kobo.1536.1"> -v *.go -</span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.1537.1">timeout</span></span><span class="koboSpan" id="kobo.1538.1"> 1s -count 2
=== RUN   TestWithItself
--- PASS: TestWithItself (0.87s)
=== RUN   TestThree
    quickT_test.go:28: Error: #1: failed on input quickT.Point2D{X:-312047170140227400, Y:-5441930920566042029}, quickT.Point2D{X:7855449254220087092, Y:7437813460700902767}, quickT.Point2D{X:4838605758154930957, Y:-7621852714243790655}
--- FAIL: TestThree (0.00s)
=== RUN   TestWithItself
panic: test timed out after 1s
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1539.1">The actual output is longer than the presented one—the rest of the output has to do with goroutines being terminated before they have finished. </span><span class="koboSpan" id="kobo.1539.2">The key thing here is that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1540.1">go test</span></code><span class="koboSpan" id="kobo.1541.1"> command </span><a id="_idIndexMarker1059"/><span class="koboSpan" id="kobo.1542.1">timed out the process due to the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1543.1">-timeout 1s</span></code><span class="koboSpan" id="kobo.1544.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1545.1">So far, we have seen the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1546.1">Errorf()</span></code><span class="koboSpan" id="kobo.1547.1"> when a test fails. </span><span class="koboSpan" id="kobo.1547.2">The next subsection discusses the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1548.1">testing.T.Fatalf()</span></code><span class="koboSpan" id="kobo.1549.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1550.1">testing.T.Fatal()</span></code><span class="koboSpan" id="kobo.1551.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-352"><span class="koboSpan" id="kobo.1552.1">Testing using testing.T.Fatal() and testing.T.Fatalf()</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1553.1">This subsection discusses the</span><a id="_idIndexMarker1060"/><span class="koboSpan" id="kobo.1554.1"> use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1555.1">testing.T.Fatalf()</span></code><span class="koboSpan" id="kobo.1556.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1557.1">testing.T.Fatal()</span></code><span class="koboSpan" id="kobo.1558.1">. </span><span class="koboSpan" id="kobo.1558.2">The core</span><a id="_idIndexMarker1061"/><span class="koboSpan" id="kobo.1559.1"> idea behind the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1560.1">T.Fatal()</span></code><span class="koboSpan" id="kobo.1561.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1562.1">T.Fatalf()</span></code><span class="koboSpan" id="kobo.1563.1"> instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1564.1">T.Error()</span></code><span class="koboSpan" id="kobo.1565.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1566.1">T.Errorf()</span></code><span class="koboSpan" id="kobo.1567.1"> is that you should use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1568.1">T.Fatal()</span></code><span class="koboSpan" id="kobo.1569.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1570.1">T.Fatalf()</span></code><span class="koboSpan" id="kobo.1571.1"> when it makes sense to stop testing the code that comes because the previous failure is going to cause more failures. </span><span class="koboSpan" id="kobo.1571.2">On the other hand, you should use the appropriate </span><code class="inlineCode"><span class="koboSpan" id="kobo.1572.1">T.Error()</span></code><span class="koboSpan" id="kobo.1573.1"> variant when a condition failure is not going to cause more failures due to various dependencies.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1574.1">Two real-world cases for using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1575.1">t.Fatalf()</span></code><span class="koboSpan" id="kobo.1576.1"> are when a database connection required for testing fails or when a network connection required for testing cannot be established.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1577.1">The relevant code can be found in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1578.1">code.go</span></code><span class="koboSpan" id="kobo.1579.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1580.1">code_test.go</span></code><span class="koboSpan" id="kobo.1581.1">, which are both located inside </span><code class="inlineCode"><span class="koboSpan" id="kobo.1582.1">ch12/testFatal</span></code><span class="koboSpan" id="kobo.1583.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1584.1">The contents of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1585.1">code.go</span></code><span class="koboSpan" id="kobo.1586.1"> are the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1587.1">package</span></span><span class="koboSpan" id="kobo.1588.1"> server
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1589.1">var</span></span><span class="koboSpan" id="kobo.1590.1"> DATA = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1591.1">map</span></span><span class="koboSpan" id="kobo.1592.1">[</span><span class="hljs-type"><span class="koboSpan" id="kobo.1593.1">string</span></span><span class="koboSpan" id="kobo.1594.1">]</span><span class="hljs-type"><span class="koboSpan" id="kobo.1595.1">string</span></span><span class="koboSpan" id="kobo.1596.1">{}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1597.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1598.1">init</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1599.1">()</span></span><span class="koboSpan" id="kobo.1600.1"> {
    DATA[</span><span class="hljs-string"><span class="koboSpan" id="kobo.1601.1">"server"</span></span><span class="koboSpan" id="kobo.1602.1">] = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1603.1">"127.0.0.1"</span></span><span class="koboSpan" id="kobo.1604.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1605.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1606.1">server</span></code><span class="koboSpan" id="kobo.1607.1"> package initializes the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1608.1">DATA</span></code><span class="koboSpan" id="kobo.1609.1"> map using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1610.1">init()</span></code><span class="koboSpan" id="kobo.1611.1"> function by defining the value for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1612.1">"server"</span></code><span class="koboSpan" id="kobo.1613.1"> key.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1614.1">The contents of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1615.1">code_test.go</span></code><span class="koboSpan" id="kobo.1616.1"> are the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1617.1">package</span></span><span class="koboSpan" id="kobo.1618.1"> server
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1619.1">import</span></span><span class="koboSpan" id="kobo.1620.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1621.1">"testing"</span></span><span class="koboSpan" id="kobo.1622.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1623.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1624.1">TestMap</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1625.1">(t *testing.T)</span></span><span class="koboSpan" id="kobo.1626.1"> {
    key := </span><span class="hljs-string"><span class="koboSpan" id="kobo.1627.1">"server"</span></span><span class="koboSpan" id="kobo.1628.1">
    server, ok := DATA[key]
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1629.1">if</span></span><span class="koboSpan" id="kobo.1630.1"> !ok {
        t.Fatalf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1631.1">"Key %s not found!"</span></span><span class="koboSpan" id="kobo.1632.1">, key)
    }
    key = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1633.1">"port"</span></span><span class="koboSpan" id="kobo.1634.1">
    port, ok := DATA[key]
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1635.1">if</span></span><span class="koboSpan" id="kobo.1636.1"> !ok {
        t.Fatalf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1637.1">"Key %s not found!"</span></span><span class="koboSpan" id="kobo.1638.1">, key)
    }
    t.Log(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1639.1">"Connecting to"</span></span><span class="koboSpan" id="kobo.1640.1">, server, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1641.1">"@port"</span></span><span class="koboSpan" id="kobo.1642.1">, port)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1643.1">In this case, there is </span><a id="_idIndexMarker1062"/><span class="koboSpan" id="kobo.1644.1">no point in executing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1645.1">t.Log()</span></code><span class="koboSpan" id="kobo.1646.1"> call as the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1647.1">"port"</span></code><span class="koboSpan" id="kobo.1648.1"> key is not</span><a id="_idIndexMarker1063"/><span class="koboSpan" id="kobo.1649.1"> defined in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1650.1">DATA</span></code><span class="koboSpan" id="kobo.1651.1"> map. </span><span class="koboSpan" id="kobo.1651.2">In this case, we use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1652.1">t.Fatalf()</span></code><span class="koboSpan" id="kobo.1653.1">, which terminates the testing process.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1654.1">Running the tests generates the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1655.1">$ </span></span><span class="koboSpan" id="kobo.1656.1">go </span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.1657.1">test</span></span><span class="koboSpan" id="kobo.1658.1"> -v *.go
=== RUN   TestMap
    code_test.go:17: Key port not found!
</span><span class="koboSpan" id="kobo.1658.2">--- FAIL: TestMap (0.00s)
FAIL
FAIL    command-line-arguments    0.412s
FAIL
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1659.1">So, as expected, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1660.1">t.Log()</span></code><span class="koboSpan" id="kobo.1661.1"> is never executed and the test fails.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1662.1">The next subsection talks about table-driven testing.</span></p>
<h2 class="heading-2" id="_idParaDest-353"><span class="koboSpan" id="kobo.1663.1">Table-driven tests</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1664.1">Table-driven tests are</span><a id="_idIndexMarker1064"/><span class="koboSpan" id="kobo.1665.1"> tests that have many input scenarios. </span><span class="koboSpan" id="kobo.1665.2">The main advantage of table-driven testing is that a developer can cover lots of testing cases by reusing existing code, which saves time and energy. </span><span class="koboSpan" id="kobo.1665.3">In order to have the parameters of the various tests in the same place, we usually use a slice of structures and iterate over its elements to run the tests.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1666.1">All relevant code of the example can be found in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1667.1">ch12/table</span></code><span class="koboSpan" id="kobo.1668.1"> directory, which contains two files. </span><span class="koboSpan" id="kobo.1668.2">The first file is called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1669.1">table.go</span></code><span class="koboSpan" id="kobo.1670.1">, whereas the source code file that is used for testing is called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1671.1">table_test.go</span></code><span class="koboSpan" id="kobo.1672.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1673.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1674.1">table.go</span></code><span class="koboSpan" id="kobo.1675.1"> file contains the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1676.1">package</span></span><span class="koboSpan" id="kobo.1677.1"> division
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1678.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1679.1">intDiv</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1680.1">(a, b </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1681.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1682.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1683.1">int</span></span><span class="koboSpan" id="kobo.1684.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1685.1">return</span></span><span class="koboSpan" id="kobo.1686.1"> a / b
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1687.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1688.1">floatDiv</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1689.1">(a, b </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1690.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1691.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1692.1">float64</span></span><span class="koboSpan" id="kobo.1693.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1694.1">return</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1695.1">float64</span></span><span class="koboSpan" id="kobo.1696.1">(a) / </span><span class="hljs-type"><span class="koboSpan" id="kobo.1697.1">float64</span></span><span class="koboSpan" id="kobo.1698.1">(b)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1699.1">The Go package that we are going to test contains two functions that implement integer division (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1700.1">intDiv()</span></code><span class="koboSpan" id="kobo.1701.1">) and floating-point division between two integers (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1702.1">floatDiv()</span></code><span class="koboSpan" id="kobo.1703.1">), respectively. </span><span class="koboSpan" id="kobo.1703.2">As you might recall from your mathematics classes, integer division between two integers gives different results from regular division. </span><span class="koboSpan" id="kobo.1703.3">As an example, dividing 2 by 4 gives 0 as a result in integer division and 0.5 in regular division. </span><span class="koboSpan" id="kobo.1703.4">This means that integer division ignores the remainder and produces integer results only, hence the function signature of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1704.1">intDiv()</span></code><span class="koboSpan" id="kobo.1705.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1706.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1707.1">table_test.go</span></code><span class="koboSpan" id="kobo.1708.1"> file is going to be presented in two parts. </span><span class="koboSpan" id="kobo.1708.2">The first part comes with the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1709.1">package</span></span><span class="koboSpan" id="kobo.1710.1"> division
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1711.1">import</span></span><span class="koboSpan" id="kobo.1712.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1713.1">"testing"</span></span><span class="koboSpan" id="kobo.1714.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1715.1">type</span></span><span class="koboSpan" id="kobo.1716.1"> myTest </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1717.1">struct</span></span><span class="koboSpan" id="kobo.1718.1"> {
    a        </span><span class="hljs-type"><span class="koboSpan" id="kobo.1719.1">int</span></span><span class="koboSpan" id="kobo.1720.1">
    b        </span><span class="hljs-type"><span class="koboSpan" id="kobo.1721.1">int</span></span><span class="koboSpan" id="kobo.1722.1">
    resInt   </span><span class="hljs-type"><span class="koboSpan" id="kobo.1723.1">int</span></span><span class="koboSpan" id="kobo.1724.1">
    resFloat </span><span class="hljs-type"><span class="koboSpan" id="kobo.1725.1">float64</span></span><span class="koboSpan" id="kobo.1726.1">
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1727.1">var</span></span><span class="koboSpan" id="kobo.1728.1"> tests = []myTest{
    {a: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1729.1">1</span></span><span class="koboSpan" id="kobo.1730.1">, b: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1731.1">2</span></span><span class="koboSpan" id="kobo.1732.1">, resInt: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1733.1">0</span></span><span class="koboSpan" id="kobo.1734.1">, resFloat: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1735.1">0.5</span></span><span class="koboSpan" id="kobo.1736.1">},
    {a: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1737.1">5</span></span><span class="koboSpan" id="kobo.1738.1">, b: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1739.1">10</span></span><span class="koboSpan" id="kobo.1740.1">, resInt: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1741.1">0</span></span><span class="koboSpan" id="kobo.1742.1">, resFloat: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1743.1">0.5</span></span><span class="koboSpan" id="kobo.1744.1">},
    {a: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1745.1">2</span></span><span class="koboSpan" id="kobo.1746.1">, b: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1747.1">2</span></span><span class="koboSpan" id="kobo.1748.1">, resInt: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1749.1">1</span></span><span class="koboSpan" id="kobo.1750.1">, resFloat: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1751.1">1.0</span></span><span class="koboSpan" id="kobo.1752.1">},
    {a: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1753.1">4</span></span><span class="koboSpan" id="kobo.1754.1">, b: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1755.1">2</span></span><span class="koboSpan" id="kobo.1756.1">, resInt: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1757.1">2</span></span><span class="koboSpan" id="kobo.1758.1">, resFloat: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1759.1">2.0</span></span><span class="koboSpan" id="kobo.1760.1">},
    {a: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1761.1">5</span></span><span class="koboSpan" id="kobo.1762.1">, b: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1763.1">2</span></span><span class="koboSpan" id="kobo.1764.1">, resInt: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1765.1">2</span></span><span class="koboSpan" id="kobo.1766.1">, resFloat: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1767.1">2.5</span></span><span class="koboSpan" id="kobo.1768.1">},
    {a: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1769.1">5</span></span><span class="koboSpan" id="kobo.1770.1">, b: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1771.1">4</span></span><span class="koboSpan" id="kobo.1772.1">, resInt: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1773.1">1</span></span><span class="koboSpan" id="kobo.1774.1">, resFloat: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1775.1">1.2</span></span><span class="koboSpan" id="kobo.1776.1">},
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1777.1">The number of</span><a id="_idIndexMarker1065"/><span class="koboSpan" id="kobo.1778.1"> entries in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1779.1">tests</span></code><span class="koboSpan" id="kobo.1780.1"> structure, which can have any name you want, signifies the number of tests that we are going to perform. </span><span class="koboSpan" id="kobo.1780.2">The last entry has an intentional error in it as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1781.1">5</span></code><span class="koboSpan" id="kobo.1782.1"> divided by </span><code class="inlineCode"><span class="koboSpan" id="kobo.1783.1">4</span></code><span class="koboSpan" id="kobo.1784.1"> equals </span><code class="inlineCode"><span class="koboSpan" id="kobo.1785.1">1.25</span></code><span class="koboSpan" id="kobo.1786.1"> instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1787.1">1.2</span></code><span class="koboSpan" id="kobo.1788.1">, which means that the respective test is going to fail.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1789.1">The biggest advantage of table-driven testing is that adding a new test is just as simple as adding an entry to the structure that holds the existing tests. </span><span class="koboSpan" id="kobo.1789.2">In a different case, you would need to add an additional test function.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1790.1">The second part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1791.1">table_test.go</span></code><span class="koboSpan" id="kobo.1792.1"> is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1793.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1794.1">TestAll</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1795.1">(t *testing.T)</span></span><span class="koboSpan" id="kobo.1796.1"> {
    t.Parallel()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1797.1">for</span></span><span class="koboSpan" id="kobo.1798.1"> _, test := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1799.1">range</span></span><span class="koboSpan" id="kobo.1800.1"> tests {
        intResult := intDiv(test.a, test.b)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1801.1">if</span></span><span class="koboSpan" id="kobo.1802.1"> intResult != test.resInt {
            t.Errorf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1803.1">"Expected %d, got %d"</span></span><span class="koboSpan" id="kobo.1804.1">, test.resInt, intResult)
        }
        floatResult := floatDiv(test.a, test.b)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1805.1">if</span></span><span class="koboSpan" id="kobo.1806.1"> floatResult != test.resFloat {
            t.Errorf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1807.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1808.1">Expected %f, got %f"</span></span><span class="koboSpan" id="kobo.1809.1">, test.resFloat, floatResult)
        }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1810.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1811.1">Test_all()</span></code><span class="koboSpan" id="kobo.1812.1"> testing function iterates over the contents of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1813.1">tests</span></code><span class="koboSpan" id="kobo.1814.1"> structure and runs the tests. </span><span class="koboSpan" id="kobo.1814.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1815.1">t.Parallel()</span></code><span class="koboSpan" id="kobo.1816.1"> statement allows the tests to run in parallel, which makes the process faster. </span><span class="koboSpan" id="kobo.1816.2">Execute </span><code class="inlineCode"><span class="koboSpan" id="kobo.1817.1">go doc testing.T.Parallel</span></code><span class="koboSpan" id="kobo.1818.1"> in the shell for more information about its usage. </span><span class="koboSpan" id="kobo.1818.2">However, in this case, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1819.1">t.Parallel()</span></code><span class="koboSpan" id="kobo.1820.1"> has no effect since no other tests are marked as parallel.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1821.1">In general, float comparison like the one presented here is, generally, unreliable. </span><span class="koboSpan" id="kobo.1821.2">For the purposes of the book, it is fine, but you should not rely on float comparison in your test functions. </span><span class="koboSpan" id="kobo.1821.3">More about that can be found at </span><a href="https://medium.com/p/9872fe6de17f"><span class="url"><span class="koboSpan" id="kobo.1822.1">https://medium.com/p/9872fe6de17f</span></span></a><span class="koboSpan" id="kobo.1823.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1824.1">Running the tests produces</span><a id="_idIndexMarker1066"/><span class="koboSpan" id="kobo.1825.1"> the following results:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1826.1">$ </span></span><span class="koboSpan" id="kobo.1827.1">go </span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.1828.1">test</span></span><span class="koboSpan" id="kobo.1829.1"> -v *.go
=== RUN   TestAll
    table_test.go:33: Expected 1.200000, got 1.250000
--- FAIL: TestAll (0.00s)
FAIL
FAIL    command-line-arguments    0.332s
FAIL
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1830.1">All tests were successful apart from the last one. </span><span class="koboSpan" id="kobo.1830.2">The next subsection shows how to find information about the code coverage of your software.</span></p>
<h2 class="heading-2" id="_idParaDest-354"><span class="koboSpan" id="kobo.1831.1">Testing code coverage</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1832.1">In this section, we are going to</span><a id="_idIndexMarker1067"/><span class="koboSpan" id="kobo.1833.1"> learn how to find information about the code coverage of our programs to discover blocks of code or single code statements that are not being executed by testing functions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1834.1">Among other things, seeing the code coverage of programs can reveal logical issues and bugs in the code, so do not underestimate its usefulness. </span><span class="koboSpan" id="kobo.1834.2">However, the code coverage test complements unit testing without replacing it. </span><span class="koboSpan" id="kobo.1834.3">The only thing to remember is that you should make sure that the testing functions try to cover all cases and, therefore, try to run all available code. </span><span class="koboSpan" id="kobo.1834.4">If the testing functions do not try to cover all cases, then the issue might be with them, not the code that is being tested.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1835.1">All relevant files can be </span><a id="_idIndexMarker1068"/><span class="koboSpan" id="kobo.1836.1">found in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1837.1">ch12/coverage</span></code><span class="koboSpan" id="kobo.1838.1">. </span><span class="koboSpan" id="kobo.1838.2">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1839.1">coverage.go</span></code><span class="koboSpan" id="kobo.1840.1">, which has some intentional issues in order to show how unreachable code is identified, is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1841.1">package</span></span><span class="koboSpan" id="kobo.1842.1"> coverage
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1843.1">import</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1844.1">"fmt"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1845.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1846.1">f1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1847.1">()</span></span><span class="koboSpan" id="kobo.1848.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1849.1">if</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.1850.1">true</span></span><span class="koboSpan" id="kobo.1851.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1852.1">"Hello!"</span></span><span class="koboSpan" id="kobo.1853.1">)
    } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1854.1">else</span></span><span class="koboSpan" id="kobo.1855.1"> {
        fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1856.1">"Hi!"</span></span><span class="koboSpan" id="kobo.1857.1">)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1858.1">The issue with this function is that the first branch of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1859.1">if</span></code><span class="koboSpan" id="kobo.1860.1"> is always true and, therefore, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1861.1">else</span></code><span class="koboSpan" id="kobo.1862.1"> branch is never going to get executed.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1863.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1864.1">f2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1865.1">(n </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1866.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1867.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1868.1">int</span></span><span class="koboSpan" id="kobo.1869.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1870.1">if</span></span><span class="koboSpan" id="kobo.1871.1"> n &gt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.1872.1">0</span></span><span class="koboSpan" id="kobo.1873.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1874.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1875.1">0</span></span><span class="koboSpan" id="kobo.1876.1">
    } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1877.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1878.1">if</span></span><span class="koboSpan" id="kobo.1879.1"> n == </span><span class="hljs-number"><span class="koboSpan" id="kobo.1880.1">1</span></span><span class="koboSpan" id="kobo.1881.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1882.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1883.1">1</span></span><span class="koboSpan" id="kobo.1884.1">
    } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1885.1">else</span></span><span class="koboSpan" id="kobo.1886.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1887.1">return</span></span><span class="koboSpan" id="kobo.1888.1"> f2(n</span><span class="hljs-number"><span class="koboSpan" id="kobo.1889.1">-1</span></span><span class="koboSpan" id="kobo.1890.1">) + f2(n</span><span class="hljs-number"><span class="koboSpan" id="kobo.1891.1">-2</span></span><span class="koboSpan" id="kobo.1892.1">)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1893.1">There exist two issues with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1894.1">f2()</span></code><span class="koboSpan" id="kobo.1895.1">. </span><span class="koboSpan" id="kobo.1895.2">The first one is that it does not work well with negative integers and the second one is that all positive integers are handled by the first </span><code class="inlineCode"><span class="koboSpan" id="kobo.1896.1">if</span></code><span class="koboSpan" id="kobo.1897.1"> branch. </span><span class="koboSpan" id="kobo.1897.2">Code coverage can only help you with the second issue. </span><span class="koboSpan" id="kobo.1897.3">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1898.1">coverage_test.go</span></code><span class="koboSpan" id="kobo.1899.1"> is the following—these are regular test functions that try to run all available code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1900.1">package</span></span><span class="koboSpan" id="kobo.1901.1"> coverage
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1902.1">import</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1903.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1904.1">testing"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1905.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1906.1">Test_f1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1907.1">(t *testing.T)</span></span><span class="koboSpan" id="kobo.1908.1"> {
    f1()
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1909.1">This test function naively tests the operation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1910.1">f1()</span></code><span class="koboSpan" id="kobo.1911.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1912.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1913.1">Test_f2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1914.1">(t *testing.T)</span></span><span class="koboSpan" id="kobo.1915.1"> {
    _ = f2(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1916.1">123</span></span><span class="koboSpan" id="kobo.1917.1">)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1918.1">The second test function checks the operation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1919.1">f2()</span></code><span class="koboSpan" id="kobo.1920.1"> by running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1921.1">f2(123)</span></code><span class="koboSpan" id="kobo.1922.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1923.1">First, we should run </span><code class="inlineCode"><span class="koboSpan" id="kobo.1924.1">go test</span></code><span class="koboSpan" id="kobo.1925.1"> as follows—the code coverage task is done by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1926.1">s</span></code><span class="koboSpan" id="kobo.1927.1"> flag:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1928.1">$ </span></span><span class="koboSpan" id="kobo.1929.1">go </span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.1930.1">test</span></span><span class="koboSpan" id="kobo.1931.1"> -cover *.go
ok    command-line-arguments    0.420s    coverage: 50.0% of statements
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1932.1">The previous output shows that we have </span><code class="inlineCode"><span class="koboSpan" id="kobo.1933.1">50%</span></code><span class="koboSpan" id="kobo.1934.1"> code coverage, which is not a good thing! </span><span class="koboSpan" id="kobo.1934.2">However, we are not done yet as we can generate a test coverage report. </span><span class="koboSpan" id="kobo.1934.3">The next command generates the code coverage report:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1935.1">$ </span></span><span class="koboSpan" id="kobo.1936.1">go </span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.1937.1">test</span></span><span class="koboSpan" id="kobo.1938.1"> -coverprofile=coverage.out *.go
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1939.1">The contents </span><a id="_idIndexMarker1069"/><span class="koboSpan" id="kobo.1940.1">of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1941.1">coverage.out</span></code><span class="koboSpan" id="kobo.1942.1"> are as follows—yours might vary a little depending on your username and the folder used:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1943.1">$ </span></span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.1944.1">cat</span></span><span class="koboSpan" id="kobo.1945.1"> coverage.out
mode: set
~/go/src/github.com/mGo4th/ch12/coverage/coverage.go:5.11,6.10 1 1
~/go/src/github.com/mactsouk/mGo4th/ch12/coverage/coverage.go:6.10,8.3 1 1
~/go/src/github.com/mactsouk/mGo4th/ch12/coverage/coverage.go:8.8,10.3 1 0
~/go/src/github.com/mactsouk/mGo4th/ch12/coverage/coverage.go:13.20,14.12 1 1
~/go/src/github.com/mactsouk/mGo4th/ch12/coverage/coverage.go:14.12,16.3 1 1
~/go/src/github.com/mactsouk/mGo4th/ch12/coverage/coverage.go:16.8,16.19 1 0
~/go/src/github.com/mactsouk/mGo4th/ch12/coverage/coverage.go:16.19,18.3 1 0
~/go/src/github.com/mactsouk/mGo4th/ch12/coverage/coverage.go:18.8,20.3 1 0
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1946.1">The format and the fields in each line of the coverage file are </span><code class="inlineCode"><span class="koboSpan" id="kobo.1947.1">name.go:line.column,line.column numberOfStatements count</span></code><span class="koboSpan" id="kobo.1948.1">. </span><span class="koboSpan" id="kobo.1948.2">The last field is a flag that tells you whether the statements specified by </span><code class="inlineCode"><span class="koboSpan" id="kobo.1949.1">line.column,line.column</span></code><span class="koboSpan" id="kobo.1950.1"> are covered or not. </span><span class="koboSpan" id="kobo.1950.2">So, when you see </span><code class="inlineCode"><span class="koboSpan" id="kobo.1951.1">0</span></code><span class="koboSpan" id="kobo.1952.1"> in the last field, it means that the code is not covered.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1953.1">Lastly, the HTML output </span><a id="_idIndexMarker1070"/><span class="koboSpan" id="kobo.1954.1">can be seen in your favorite web browser by running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1955.1">go tool cover -html=coverage.out</span></code><span class="koboSpan" id="kobo.1956.1">. </span><span class="koboSpan" id="kobo.1956.2">If you used a different filename than </span><code class="inlineCode"><span class="koboSpan" id="kobo.1957.1">coverage.out</span></code><span class="koboSpan" id="kobo.1958.1">, modify the command accordingly. </span><span class="koboSpan" id="kobo.1958.2">The next figure shows the generated output—if you are reading the printed version of the book, you might not be able to see the colors. </span><span class="koboSpan" id="kobo.1958.3">Red lines denote code that is not being executed, whereas green lines show code that was executed by the tests.</span></p>
<figure class="mediaobject"> <span class="koboSpan" id="kobo.1959.1"><img alt="A screenshot of a computer  Description automatically generated" src="../Images/B21003_12_02.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1960.1">Figure 12.2: Code coverage report</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1961.1">Some of the code is marked as not tracked (gray in color) because this is code that cannot be processed by the code coverage tool. </span><span class="koboSpan" id="kobo.1961.2">The generated output clearly shows the code issues with both </span><code class="inlineCode"><span class="koboSpan" id="kobo.1962.1">f1()</span></code><span class="koboSpan" id="kobo.1963.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1964.1">f2()</span></code><span class="koboSpan" id="kobo.1965.1">. </span><span class="koboSpan" id="kobo.1965.2">You just have to correct them now!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1966.1">The next subsection discusses unreachable code and how to discover it.</span></p>
<h2 class="heading-2" id="_idParaDest-355"><span class="koboSpan" id="kobo.1967.1">Finding unreachable Go code</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1968.1">Sometimes, a wrongly</span><a id="_idIndexMarker1071"/><span class="koboSpan" id="kobo.1969.1"> implemented </span><code class="inlineCode"><span class="koboSpan" id="kobo.1970.1">if</span></code><span class="koboSpan" id="kobo.1971.1"> or a misplaced </span><code class="inlineCode"><span class="koboSpan" id="kobo.1972.1">return</span></code><span class="koboSpan" id="kobo.1973.1"> statement can create blocks of code that are unreachable, that is, blocks of code that are not going to be executed at all. </span><span class="koboSpan" id="kobo.1973.2">As this is a logical kind of error, which means that it is not going to get caught by the compiler, we need to find a way of discovering it.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1974.1">Fortunately, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1975.1">go vet</span></code><span class="koboSpan" id="kobo.1976.1"> tool, which examines Go source code and reports suspicious constructs, can help with that—the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1977.1">go vet</span></code><span class="koboSpan" id="kobo.1978.1"> is illustrated with the help of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1979.1">cannotReach.go</span></code><span class="koboSpan" id="kobo.1980.1"> source code file, which contains the next two functions:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1981.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1982.1">S2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1983.1">()</span></span><span class="koboSpan" id="kobo.1984.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1985.1">return</span></span><span class="koboSpan" id="kobo.1986.1">
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1987.1">"Hello!"</span></span><span class="koboSpan" id="kobo.1988.1">)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1989.1">There is a logical error here because </span><code class="inlineCode"><span class="koboSpan" id="kobo.1990.1">S2()</span></code><span class="koboSpan" id="kobo.1991.1"> returns before printing the desired message.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1992.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1993.1">S1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1994.1">()</span></span><span class="koboSpan" id="kobo.1995.1"> {
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1996.1">"In S1()"</span></span><span class="koboSpan" id="kobo.1997.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1998.1">return</span></span><span class="koboSpan" id="kobo.1999.1">
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2000.1">"Leaving S1()"</span></span><span class="koboSpan" id="kobo.2001.1">)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2002.1">Similarly, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2003.1">S1()</span></code><span class="koboSpan" id="kobo.2004.1"> returns without giving the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2005.1">fmt.Println("Leaving S1()")</span></code><span class="koboSpan" id="kobo.2006.1"> statement a chance to be executed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2007.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2008.1">go vet</span></code><span class="koboSpan" id="kobo.2009.1"> on </span><code class="inlineCode"><span class="koboSpan" id="kobo.2010.1">cannotReach.go</span></code><span class="koboSpan" id="kobo.2011.1"> creates the next output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2012.1">$ </span></span><span class="koboSpan" id="kobo.2013.1">go vet cannotReach.go
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2014.1"># </span></span><span class="koboSpan" id="kobo.2015.1">command-line-arguments
./cannotReach.go:9:2: unreachable code
./cannotReach.go:16:2: unreachable code
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2016.1">The first message points to </span><a id="_idIndexMarker1072"/><span class="koboSpan" id="kobo.2017.1">the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2018.1">fmt.Println()</span></code><span class="koboSpan" id="kobo.2019.1"> statement of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2020.1">S2()</span></code><span class="koboSpan" id="kobo.2021.1"> and the second one to the second </span><code class="inlineCode"><span class="koboSpan" id="kobo.2022.1">fmt.Println()</span></code><span class="koboSpan" id="kobo.2023.1"> statement of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2024.1">S1()</span></code><span class="koboSpan" id="kobo.2025.1">. </span><span class="koboSpan" id="kobo.2025.2">In this case, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2026.1">go vet</span></code><span class="koboSpan" id="kobo.2027.1"> did a great job. </span><span class="koboSpan" id="kobo.2027.2">However, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2028.1">go vet</span></code><span class="koboSpan" id="kobo.2029.1"> is not particularly sophisticated and cannot catch every possible type of logical error. </span><span class="koboSpan" id="kobo.2029.2">If you need a more advanced tool, have a look</span><a id="_idIndexMarker1073"/><span class="koboSpan" id="kobo.2030.1"> at </span><code class="inlineCode"><span class="koboSpan" id="kobo.2031.1">staticcheck</span></code><span class="koboSpan" id="kobo.2032.1"> (</span><a href="https://staticcheck.io/"><span class="url"><span class="koboSpan" id="kobo.2033.1">https://staticcheck.io/</span></span></a><span class="koboSpan" id="kobo.2034.1">), which can also be integrated with Microsoft Visual </span><a id="_idIndexMarker1074"/><span class="koboSpan" id="kobo.2035.1">Studio Code (</span><a href="https://code.visualstudio.com/"><span class="url"><span class="koboSpan" id="kobo.2036.1">https://code.visualstudio.com/</span></span></a><span class="koboSpan" id="kobo.2037.1">), Neovim (!), and </span><a id="_idIndexMarker1075"/><span class="koboSpan" id="kobo.2038.1">Zed (</span><a href="https://zed.dev/"><span class="url"><span class="koboSpan" id="kobo.2039.1">https://zed.dev/</span></span></a><span class="koboSpan" id="kobo.2040.1">)—the next figure shows that Zed underlines the unreachable code. </span><span class="koboSpan" id="kobo.2040.2">Visual Studio Code works in a similar way.</span></p>
<figure class="mediaobject"> <span class="koboSpan" id="kobo.2041.1"><img alt="A screen shot of a computer program  Description automatically generated" src="../Images/B21003_12_03.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.2042.1">Figure 12.3: Viewing unreachable code in Zed</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2043.1">As a rule of </span><a id="_idIndexMarker1076"/><span class="koboSpan" id="kobo.2044.1">thumb, it does not hurt to include </span><code class="inlineCode"><span class="koboSpan" id="kobo.2045.1">go vet</span></code><span class="koboSpan" id="kobo.2046.1"> in your workflow. </span><span class="koboSpan" id="kobo.2046.2">You can find more information about the capabilities of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2047.1">go vet</span></code><span class="koboSpan" id="kobo.2048.1"> by running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2049.1">go doc cmd/vet</span></code><span class="koboSpan" id="kobo.2050.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2051.1">The next subsection illustrates how to test an HTTP server with a database backend.</span></p>
<h2 class="heading-2" id="_idParaDest-356"><span class="koboSpan" id="kobo.2052.1">Testing an HTTP server with a database backend</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2053.1">An HTTP server is </span><a id="_idIndexMarker1077"/><span class="koboSpan" id="kobo.2054.1">a different kind of animal because it should already run for tests to get executed. </span><span class="koboSpan" id="kobo.2054.2">Thankfully, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2055.1">net/http/httptest</span></code><span class="koboSpan" id="kobo.2056.1"> package can help—you do not need to run the HTTP server on your own as the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2057.1">net/http/httptest</span></code><span class="koboSpan" id="kobo.2058.1"> package does the work for </span><a id="_idIndexMarker1078"/><span class="koboSpan" id="kobo.2059.1">you, but you need to have the </span><a id="_idIndexMarker1079"/><span class="koboSpan" id="kobo.2060.1">database server up and running. </span><span class="koboSpan" id="kobo.2060.2">We are going to test the REST API server we developed in </span><em class="chapterRef"><span class="koboSpan" id="kobo.2061.1">Chapter 11</span></em><span class="koboSpan" id="kobo.2062.1">, </span><em class="italic"><span class="koboSpan" id="kobo.2063.1">Working with REST APIs</span></em><span class="koboSpan" id="kobo.2064.1">. </span><span class="koboSpan" id="kobo.2064.2">All relevant files are located inside </span><code class="inlineCode"><span class="koboSpan" id="kobo.2065.1">ch12/testHTTP</span></code><span class="koboSpan" id="kobo.2066.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2067.1">The</span><a id="_idIndexMarker1080"/><span class="koboSpan" id="kobo.2068.1"> code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2069.1">server_test.go</span></code><span class="koboSpan" id="kobo.2070.1">, which holds the test </span><a id="_idIndexMarker1081"/><span class="koboSpan" id="kobo.2071.1">functions for the HTTP service, is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2072.1">package</span></span><span class="koboSpan" id="kobo.2073.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2074.1">import</span></span><span class="koboSpan" id="kobo.2075.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.2076.1">"bytes"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2077.1">"net/http"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2078.1">"net/http/httptest"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2079.1">"strconv"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2080.1">"strings"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2081.1">"testing"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2082.1">"time"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2083.1">"github.com/gorilla/mux"</span></span><span class="koboSpan" id="kobo.2084.1">
)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2085.1">The only reason for including </span><code class="inlineCode"><span class="koboSpan" id="kobo.2086.1">github.com/gorilla/mux</span></code><span class="koboSpan" id="kobo.2087.1"> is the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2088.1">mux.SetURLVars()</span></code><span class="koboSpan" id="kobo.2089.1"> later on.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2090.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2091.1">TestTimeHandler</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2092.1">(t *testing.T)</span></span><span class="koboSpan" id="kobo.2093.1"> {
    req, err := http.NewRequest(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2094.1">"GET"</span></span><span class="koboSpan" id="kobo.2095.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2096.1">"/time"</span></span><span class="koboSpan" id="kobo.2097.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2098.1">nil</span></span><span class="koboSpan" id="kobo.2099.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2100.1">if</span></span><span class="koboSpan" id="kobo.2101.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2102.1">nil</span></span><span class="koboSpan" id="kobo.2103.1"> {
        t.Fatal(err)
    }
    rr := httptest.NewRecorder()
    handler := http.HandlerFunc(TimeHandler)
    handler.ServeHTTP(rr, req)
    status := rr.Code
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2104.1">if</span></span><span class="koboSpan" id="kobo.2105.1"> status != http.StatusOK {
        t.Errorf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2106.1">"handler returned wrong status code: got %v want %v"</span></span><span class="koboSpan" id="kobo.2107.1">,
            status, http.StatusOK)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2108.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2109.1">http.NewRequest()</span></code><span class="koboSpan" id="kobo.2110.1"> function is used to define the HTTP request method and the endpoint and to send data to the endpoint when needed. </span><span class="koboSpan" id="kobo.2110.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2111.1">http.HandlerFunc(TimeHandler)</span></code><span class="koboSpan" id="kobo.2112.1"> call specifies the handler function that is being tested.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2113.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2114.1">TestMethodNotAllowed</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2115.1">(t *testing.T)</span></span><span class="koboSpan" id="kobo.2116.1"> {
    req, err := http.NewRequest(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2117.1">"DELETE"</span></span><span class="koboSpan" id="kobo.2118.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2119.1">"/time"</span></span><span class="koboSpan" id="kobo.2120.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2121.1">nil</span></span><span class="koboSpan" id="kobo.2122.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2123.1">if</span></span><span class="koboSpan" id="kobo.2124.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2125.1">nil</span></span><span class="koboSpan" id="kobo.2126.1"> {
        t.Fatal(err)
    }
    rr := httptest.NewRecorder()
    handler := http.HandlerFunc(MethodNotAllowedHandler)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2127.1">We are testing </span><code class="inlineCode"><span class="koboSpan" id="kobo.2128.1">MethodNotAllowedHandler</span></code><span class="koboSpan" id="kobo.2129.1"> in this test function.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2130.1">    handler.ServeHTTP(rr, req)
    status := rr.Code
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2131.1">if</span></span><span class="koboSpan" id="kobo.2132.1"> status != http.StatusNotFound {
        t.Errorf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2133.1">"handler returned wrong status code: got %v want %v"</span></span><span class="koboSpan" id="kobo.2134.1">,
            status, http.StatusOK)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2135.1">We know that this interaction is going to fail as we are testing </span><code class="inlineCode"><span class="koboSpan" id="kobo.2136.1">MethodNotAllowedHandler</span></code><span class="koboSpan" id="kobo.2137.1">. </span><span class="koboSpan" id="kobo.2137.2">Therefore, we expect to get an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2138.1">http.StatusNotFound</span></code><span class="koboSpan" id="kobo.2139.1"> response code back—if we get a different code, the test function is going to fail.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2140.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2141.1">TestLogin</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2142.1">(t *testing.T)</span></span><span class="koboSpan" id="kobo.2143.1"> {
    UserPass := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.2144.1">byte</span></span><span class="koboSpan" id="kobo.2145.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2146.1">`{"Username": "admin", "Password": "admin"}`</span></span><span class="koboSpan" id="kobo.2147.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2148.1">Here we store the desired fields of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2149.1">User</span></code><span class="koboSpan" id="kobo.2150.1"> structure in a byte slice. </span><span class="koboSpan" id="kobo.2150.2">For the tests to work, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2151.1">admin</span></code><span class="koboSpan" id="kobo.2152.1"> user should have </span><code class="inlineCode"><span class="koboSpan" id="kobo.2153.1">admin</span></code><span class="koboSpan" id="kobo.2154.1"> as the password because this is what is used in the code—modify </span><code class="inlineCode"><span class="koboSpan" id="kobo.2155.1">server_test.go</span></code><span class="koboSpan" id="kobo.2156.1"> in order to have the correct password for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2157.1">admin</span></code><span class="koboSpan" id="kobo.2158.1"> user, or any other user with admin privileges, of your installation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2159.1">In </span><a id="_idIndexMarker1082"/><span class="koboSpan" id="kobo.2160.1">general, and mainly for critical applications or </span><a id="_idIndexMarker1083"/><span class="koboSpan" id="kobo.2161.1">projects that involve more than a single developer, this is not a good practice. </span><span class="koboSpan" id="kobo.2161.2">Ideally, everything needed for the tests should be contained within the tests. </span><span class="koboSpan" id="kobo.2161.3">One possible solution is to provide a separate database or a separate machine used just for testing purposes.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2162.1">    req, err := http.NewRequest(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2163.1">"POST"</span></span><span class="koboSpan" id="kobo.2164.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2165.1">"/login"</span></span><span class="koboSpan" id="kobo.2166.1">, bytes.NewBuffer(UserPass))
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2167.1">if</span></span><span class="koboSpan" id="kobo.2168.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2169.1">nil</span></span><span class="koboSpan" id="kobo.2170.1"> {
        t.Fatal(err)
    }
    req.Header.Set(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2171.1">"Content-Type"</span></span><span class="koboSpan" id="kobo.2172.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2173.1">"application/json"</span></span><span class="koboSpan" id="kobo.2174.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2175.1">The previous lines of code construct the desired request, which is about logging in to the service.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2176.1">    rr := httptest.NewRecorder()
    handler := http.HandlerFunc(LoginHandler)
    handler.ServeHTTP(rr, req)
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2177.1">NewRecorder()</span></code><span class="koboSpan" id="kobo.2178.1"> returns an initialized </span><code class="inlineCode"><span class="koboSpan" id="kobo.2179.1">ResponseRecorder</span></code><span class="koboSpan" id="kobo.2180.1"> that is used in </span><code class="inlineCode"><span class="koboSpan" id="kobo.2181.1">ServeHTTP()</span></code><span class="koboSpan" id="kobo.2182.1">—</span><code class="inlineCode"><span class="koboSpan" id="kobo.2183.1">ServeHTTP()</span></code><span class="koboSpan" id="kobo.2184.1"> is the method that performs the request. </span><span class="koboSpan" id="kobo.2184.2">The response is saved in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2185.1">rr</span></code><span class="koboSpan" id="kobo.2186.1"> variable.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2187.1">There</span><a id="_idIndexMarker1084"/><span class="koboSpan" id="kobo.2188.1"> is also a test function for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2189.1">/logout</span></code><span class="koboSpan" id="kobo.2190.1"> endpoint, which</span><a id="_idIndexMarker1085"/><span class="koboSpan" id="kobo.2191.1"> is not presented here as it is almost identical to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2192.1">TestLogin()</span></code><span class="koboSpan" id="kobo.2193.1">. </span><span class="koboSpan" id="kobo.2193.2">In this case, running the tests in a random order might create issues with testing because </span><code class="inlineCode"><span class="koboSpan" id="kobo.2194.1">TestLogin()</span></code><span class="koboSpan" id="kobo.2195.1"> should always get executed before </span><code class="inlineCode"><span class="koboSpan" id="kobo.2196.1">TestLogout()</span></code><span class="koboSpan" id="kobo.2197.1">.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2198.1">    status := rr.Code
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2199.1">if</span></span><span class="koboSpan" id="kobo.2200.1"> status != http.StatusOK {
        t.Errorf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2201.1">"handler returned wrong status code: got %v want %v"</span></span><span class="koboSpan" id="kobo.2202.1">,
            status, http.StatusOK)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2203.1">return</span></span><span class="koboSpan" id="kobo.2204.1">
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2205.1">If the status code is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2206.1">http.StatusOK</span></code><span class="koboSpan" id="kobo.2207.1">, it means that the interaction worked as expected.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2208.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2209.1">TestAdd</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2210.1">(t *testing.T)</span></span><span class="koboSpan" id="kobo.2211.1"> {
    now := </span><span class="hljs-type"><span class="koboSpan" id="kobo.2212.1">int</span></span><span class="koboSpan" id="kobo.2213.1">(time.Now().Unix())
    username := </span><span class="hljs-string"><span class="koboSpan" id="kobo.2214.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2215.1">test_"</span></span><span class="koboSpan" id="kobo.2216.1"> + strconv.Itoa(now)
    users := </span><span class="hljs-string"><span class="koboSpan" id="kobo.2217.1">`[{"Username": "admin", "Password": "admin"}, {"Username":"`</span></span><span class="koboSpan" id="kobo.2218.1"> + username + </span><span class="hljs-string"><span class="koboSpan" id="kobo.2219.1">`", "Password": "myPass"}]`</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2220.1">For the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2221.1">Add()</span></code><span class="koboSpan" id="kobo.2222.1"> handler, we need to pass an array of JSON records, which is constructed here. </span><span class="koboSpan" id="kobo.2222.2">As we do not want to create the same username every time, we append the current timestamp to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2223.1">_test</span></code><span class="koboSpan" id="kobo.2224.1"> string.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2225.1">    UserPass := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.2226.1">byte</span></span><span class="koboSpan" id="kobo.2227.1">(users)
    req, err := http.NewRequest(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2228.1">"POST"</span></span><span class="koboSpan" id="kobo.2229.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2230.1">"/add"</span></span><span class="koboSpan" id="kobo.2231.1">, bytes.NewBuffer(UserPass))
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2232.1">if</span></span><span class="koboSpan" id="kobo.2233.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2234.1">nil</span></span><span class="koboSpan" id="kobo.2235.1"> {
        t.Fatal(err)
    }
    req.Header.Set(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2236.1">"Content-Type"</span></span><span class="koboSpan" id="kobo.2237.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2238.1">"application/json"</span></span><span class="koboSpan" id="kobo.2239.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2240.1">This is where we construct the slice of JSON records (</span><code class="inlineCode"><span class="koboSpan" id="kobo.2241.1">UserPass</span></code><span class="koboSpan" id="kobo.2242.1">) and create the request.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2243.1">    rr := httptest.NewRecorder()
    handler := http.HandlerFunc(AddHandler)
    handler.ServeHTTP(rr, req)
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2244.1">// Check the HTTP status code is what we expect.</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2245.1">if</span></span><span class="koboSpan" id="kobo.2246.1"> status := rr.Code; status != http.StatusOK {
        t.Errorf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2247.1">"handler returned wrong status code: got %v want %v"</span></span><span class="koboSpan" id="kobo.2248.1">,
            status, http.StatusOK)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2249.1">return</span></span><span class="koboSpan" id="kobo.2250.1">
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2251.1">If the server response is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2252.1">http.StatusOK</span></code><span class="koboSpan" id="kobo.2253.1">, then the request is successful and the test passes.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2254.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2255.1">TestGetUserDataHandler</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2256.1">(t *testing.T)</span></span><span class="koboSpan" id="kobo.2257.1"> {
    UserPass := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.2258.1">byte</span></span><span class="koboSpan" id="kobo.2259.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2260.1">`{"Username": "admin", "Password": "admin"}`</span></span><span class="koboSpan" id="kobo.2261.1">)
    req, err := http.NewRequest(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2262.1">"GET"</span></span><span class="koboSpan" id="kobo.2263.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2264.1">"/username/1"</span></span><span class="koboSpan" id="kobo.2265.1">, bytes.NewBuffer(UserPass))
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2266.1">Although we</span><a id="_idIndexMarker1086"/><span class="koboSpan" id="kobo.2267.1"> use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2268.1">/username/1</span></code><span class="koboSpan" id="kobo.2269.1"> in the request, this does not </span><a id="_idIndexMarker1087"/><span class="koboSpan" id="kobo.2270.1">add any value to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2271.1">Vars</span></code><span class="koboSpan" id="kobo.2272.1"> map. </span><span class="koboSpan" id="kobo.2272.2">Therefore, we need to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2273.1">SetURLVars()</span></code><span class="koboSpan" id="kobo.2274.1"> function to change the values in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2275.1">Vars</span></code><span class="koboSpan" id="kobo.2276.1"> map—this is illustrated next:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2277.1">if</span></span><span class="koboSpan" id="kobo.2278.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2279.1">nil</span></span><span class="koboSpan" id="kobo.2280.1"> {
        t.Fatal(err)
    }
    req.Header.Set(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2281.1">"Content-Type"</span></span><span class="koboSpan" id="kobo.2282.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2283.1">"application/json"</span></span><span class="koboSpan" id="kobo.2284.1">)
    vars := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2285.1">map</span></span><span class="koboSpan" id="kobo.2286.1">[</span><span class="hljs-type"><span class="koboSpan" id="kobo.2287.1">string</span></span><span class="koboSpan" id="kobo.2288.1">]</span><span class="hljs-type"><span class="koboSpan" id="kobo.2289.1">string</span></span><span class="koboSpan" id="kobo.2290.1">{
        </span><span class="hljs-string"><span class="koboSpan" id="kobo.2291.1">"id"</span></span><span class="koboSpan" id="kobo.2292.1">: </span><span class="hljs-string"><span class="koboSpan" id="kobo.2293.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2294.1">1"</span></span><span class="koboSpan" id="kobo.2295.1">,
    }
    req = mux.SetURLVars(req, vars)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2296.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2297.1">gorilla/mux</span></code><span class="koboSpan" id="kobo.2298.1"> package provides the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2299.1">SetURLVars()</span></code><span class="koboSpan" id="kobo.2300.1"> function for testing purposes—this function allows you to add elements to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2301.1">Vars</span></code><span class="koboSpan" id="kobo.2302.1"> map. </span><span class="koboSpan" id="kobo.2302.2">In this case, we need to set the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2303.1">id</span></code><span class="koboSpan" id="kobo.2304.1"> key to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2305.1">1</span></code><span class="koboSpan" id="kobo.2306.1">. </span><span class="koboSpan" id="kobo.2306.2">You can add as many key/value pairs as you want.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2307.1">    rr := httptest.NewRecorder()
    handler := http.HandlerFunc(GetUserDataHandler)
    handler.ServeHTTP(rr, req)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2308.1">if</span></span><span class="koboSpan" id="kobo.2309.1"> status := rr.Code; status != http.StatusOK {
        t.Errorf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2310.1">"handler returned wrong status code: got %v want %v"</span></span><span class="koboSpan" id="kobo.2311.1">,
            status, http.StatusOK)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2312.1">return</span></span><span class="koboSpan" id="kobo.2313.1">
    }
expected := </span><span class="hljs-string"><span class="koboSpan" id="kobo.2314.1">`</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2315.1">{"id":1,"username":"admin","password":"admin",</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2316.1">"lastlogin":1702577035,"admin":1,"active":0}`</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2317.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2318.1">expected</span></code><span class="koboSpan" id="kobo.2319.1"> variable holds the record we expect to get back from our request.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2320.1">Using the same value for </span><code class="inlineCode"><span class="koboSpan" id="kobo.2321.1">lastlogin</span></code><span class="koboSpan" id="kobo.2322.1"> does not make any sense. </span><span class="koboSpan" id="kobo.2322.2">Therefore, we might be dealing with a bug here. </span><span class="koboSpan" id="kobo.2322.3">Additionally, if we cannot guess the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2323.1">lastlogin</span></code><span class="koboSpan" id="kobo.2324.1"> in the server response, we might need to replace it with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2325.1">0</span></code><span class="koboSpan" id="kobo.2326.1"> in both </span><code class="inlineCode"><span class="koboSpan" id="kobo.2327.1">expected</span></code><span class="koboSpan" id="kobo.2328.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2329.1">serverResponse</span></code><span class="koboSpan" id="kobo.2330.1">. </span><span class="koboSpan" id="kobo.2330.2">An alternative would have been to marshal the result into a structure and only compare what is relevant for the test.</span></p>
</div>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2331.1">        serverResponse = strings.TrimSpace(serverResponse)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2332.1">The previous statement removes any spaces from the HTTP server response.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2333.1">if</span></span><span class="koboSpan" id="kobo.2334.1"> serverResponse != expected {
        t.Errorf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2335.1">"handler returned unexpected body: got %v but wanted %v"</span></span><span class="koboSpan" id="kobo.2336.1">, serverResponse, expected)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2337.1">The last </span><a id="_idIndexMarker1088"/><span class="koboSpan" id="kobo.2338.1">part of the code contains the standard</span><a id="_idIndexMarker1089"/><span class="koboSpan" id="kobo.2339.1"> Go way of checking whether we have received the expected answer or not.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2340.1">Creating tests for HTTP services is easy once you understand the presented examples. </span><span class="koboSpan" id="kobo.2340.2">This mainly happens because most of the code is repeated among test functions.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2341.1">Running the tests generates the next output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2342.1">$ </span></span><span class="koboSpan" id="kobo.2343.1">go </span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.2344.1">test</span></span><span class="koboSpan" id="kobo.2345.1"> -v server_test.go main.go handlers.go restdb.go 
=== RUN   TestTimeHandler
2023/12/14 22:12:30 TimeHandler Serving: /time from
--- PASS: TestTimeHandler (0.00s)
=== RUN   TestMethodNotAllowed
2023/12/14 22:12:30 Serving: /time from  with method DELETE
--- PASS: TestMethodNotAllowed (0.00s)
=== RUN   TestLogin
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2346.1">This is the output from visiting the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2347.1">/time</span></code><span class="koboSpan" id="kobo.2348.1"> endpoint with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2349.1">DELETE</span></code><span class="koboSpan" id="kobo.2350.1"> HTTP method. </span><span class="koboSpan" id="kobo.2350.2">Its result is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2351.1">PASS</span></code><span class="koboSpan" id="kobo.2352.1"> because we were expecting this request to fail as it uses the wrong HTTP method.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2353.1">2023/12/14 22:12:30 LoginHandler Serving: /login from
2023/12/14 22:12:30 Input user: {0 admin admin 0 0 0}
2023/12/14 22:12:30 Found user: {1 admin admin 1702577035 1 0}
2023/12/14 22:12:30 Logging in: {1 admin admin 1702577035 1 0}
2023/12/14 22:12:30 Updating user: {1 admin admin 1702577825 1 1}
2023/12/14 22:12:30 Affected: 1
2023/12/14 22:12:30 User updated: {1 admin admin 1702577728 1 1}
--- PASS: TestLogin (0.00s)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2354.1">This is the output from </span><code class="inlineCode"><span class="koboSpan" id="kobo.2355.1">TestLogin()</span></code><span class="koboSpan" id="kobo.2356.1"> that tests the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2357.1">/login</span></code><span class="koboSpan" id="kobo.2358.1"> endpoint. </span><span class="koboSpan" id="kobo.2358.2">All lines beginning with the date and time are generated by the REST API server and show the progress of the request.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2359.1">=== RUN   TestLogout
2023/12/14 22:12:30 LogoutHandler Serving: /logout from
2023/12/14 22:12:30 Found user: {1 admin admin 1702577035 1 1}
2023/12/14 22:12:30 Logging out: admin
2023/12/14 22:12:30 Updating user: {1 admin admin 1702577035 1 0}
2023/12/14 22:12:30 Affected: 1
2023/12/14 22:12:30 User updated: {1 admin admin 1702577035 1 0}
--- PASS: TestLogout (0.00s)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2360.1">This is the output from </span><code class="inlineCode"><span class="koboSpan" id="kobo.2361.1">TestLogout()</span></code><span class="koboSpan" id="kobo.2362.1"> that tests the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2363.1">/logout</span></code><span class="koboSpan" id="kobo.2364.1"> endpoint, which also has the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2365.1">PASS</span></code><span class="koboSpan" id="kobo.2366.1"> result.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2367.1">=== RUN   TestAdd
2023/12/14 22:12:30 AddHandler Serving: /add from
2023/12/14 22:12:30 [{0 admin admin 0 0 0} {0 test_1702577728 myPass 0 0 0}]
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2368.1">This is the</span><a id="_idIndexMarker1090"/><span class="koboSpan" id="kobo.2369.1"> output from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2370.1">TestAdd()</span></code><span class="koboSpan" id="kobo.2371.1"> test</span><a id="_idIndexMarker1091"/><span class="koboSpan" id="kobo.2372.1"> function. </span><span class="koboSpan" id="kobo.2372.2">The name of the new user that is created is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2373.1">test_1702577728</span></code><span class="koboSpan" id="kobo.2374.1"> and it should be different each time the test is executed.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2375.1">--- PASS: TestAdd (0.00s)
=== RUN   TestGetUserDataHandler
2023/12/14 22:12:30 GetUserDataHandler Serving: /username/1 from
2023/12/14 22:12:30 Found user: {1 admin admin 1702577035 1 0}
--- PASS: TestGetUserDataHandler (0.00s)
PASS
ok    command-line-arguments    0.329s
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2376.1">Lastly, this is the output from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2377.1">TestGetUserDataHandler()</span></code><span class="koboSpan" id="kobo.2378.1"> test function that was also executed without any issues.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2379.1">The next section presents the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2380.1">govulncheck</span></code><span class="koboSpan" id="kobo.2381.1"> tool, which is used to find vulnerabilities in project dependencies.</span></p>
<h1 class="heading-1" id="_idParaDest-357"><span class="koboSpan" id="kobo.2382.1">The govulncheck tool</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2383.1">The purpose of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2384.1">govulncheck</span></code><span class="koboSpan" id="kobo.2385.1"> tool </span><a id="_idIndexMarker1092"/><span class="koboSpan" id="kobo.2386.1">is to find vulnerabilities in project dependencies. </span><span class="koboSpan" id="kobo.2386.2">This means that it is there to make your Go binaries and Go modules more secure.</span></p>
<h2 class="heading-2" id="_idParaDest-358"><span class="koboSpan" id="kobo.2387.1">Installing the tool</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2388.1">You can </span><a id="_idIndexMarker1093"/><span class="koboSpan" id="kobo.2389.1">install </span><code class="inlineCode"><span class="koboSpan" id="kobo.2390.1">govulncheck</span></code><span class="koboSpan" id="kobo.2391.1"> by running the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2392.1">$ </span></span><span class="koboSpan" id="kobo.2393.1">go install golang.org/x/vuln/cmd/govulncheck@latest
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2394.1">$ </span></span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.2395.1">cd</span></span><span class="koboSpan" id="kobo.2396.1"> ~/go/bin
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2397.1">$ </span></span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.2398.1">ls</span></span><span class="koboSpan" id="kobo.2399.1"> -lh govulncheck
-rwxr-xr-x@ 1 mtsouk  staff    11M Dec  9 19:41 govulncheck
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2400.1">As expected, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2401.1">govulncheck</span></code><span class="koboSpan" id="kobo.2402.1"> binary is going to be installed in </span><code class="inlineCode"><span class="koboSpan" id="kobo.2403.1">~/go/bin</span></code><span class="koboSpan" id="kobo.2404.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2405.1">The relevant Go code can be found inside </span><code class="inlineCode"><span class="koboSpan" id="kobo.2406.1">ch12/vulcheck</span></code><span class="koboSpan" id="kobo.2407.1">—the source code file is called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2408.1">vul.go</span></code><span class="koboSpan" id="kobo.2409.1"> and contains the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2410.1">package</span></span><span class="koboSpan" id="kobo.2411.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2412.1">import</span></span><span class="koboSpan" id="kobo.2413.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.2414.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2415.1">"golang.org/x/text/language"</span></span><span class="koboSpan" id="kobo.2416.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2417.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2418.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2419.1">()</span></span><span class="koboSpan" id="kobo.2420.1"> {
    greece := language.Make(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2421.1">"el"</span></span><span class="koboSpan" id="kobo.2422.1">)
    en := language.Make(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2423.1">"en"</span></span><span class="koboSpan" id="kobo.2424.1">)
    fmt.Println(greece.Region())
    fmt.Println(en.Region())
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2425.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2426.1">vul.go</span></code><span class="koboSpan" id="kobo.2427.1"> requires executing the following commands first:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2428.1">$ </span></span><span class="koboSpan" id="kobo.2429.1">go mod init
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2430.1">$ </span></span><span class="koboSpan" id="kobo.2431.1">go mod tidy
go: finding module for package golang.org/x/text/language
go: downloading golang.org/x/text v0.14.0
go: found golang.org/x/text/language in golang.org/x/text v0.14.0
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2432.1">Based </span><a id="_idIndexMarker1094"/><span class="koboSpan" id="kobo.2433.1">on the previous output of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2434.1">go mod tidy</span></code><span class="koboSpan" id="kobo.2435.1">, the contents of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2436.1">go.mod</span></code><span class="koboSpan" id="kobo.2437.1"> are the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2438.1">$ </span></span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.2439.1">cat</span></span><span class="koboSpan" id="kobo.2440.1"> go.mod
module github.com/mactsouk/mGo4th/ch12/vulcheck
go 1.21.5
require golang.org/x/text v0.14.0
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2441.1">So, we are using version </span><code class="inlineCode"><span class="koboSpan" id="kobo.2442.1">v0.14.0</span></code><span class="koboSpan" id="kobo.2443.1"> of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2444.1">golang.org/x/text</span></code><span class="koboSpan" id="kobo.2445.1"> package.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2446.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2447.1">govulncheck</span></code><span class="koboSpan" id="kobo.2448.1"> against </span><code class="inlineCode"><span class="koboSpan" id="kobo.2449.1">vul.go</span></code><span class="koboSpan" id="kobo.2450.1"> produces the following results:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2451.1">$ </span></span><span class="koboSpan" id="kobo.2452.1">~/go/bin/govulncheck ./...
</span><span class="koboSpan" id="kobo.2452.2">Scanning your code and 47 packages across 1 dependent module for known vulnerabilities...
</span><span class="koboSpan" id="kobo.2452.3">No vulnerabilities found.
</span><span class="koboSpan" id="kobo.2452.4">Share feedback at https://go.dev/s/govulncheck-feedback
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2453.1">Now, let us change the contents of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2454.1">go.mod</span></code><span class="koboSpan" id="kobo.2455.1"> to include a package version with known vulnerabilities </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.2456.1">on purpose</span></strong><span class="koboSpan" id="kobo.2457.1">. </span><span class="koboSpan" id="kobo.2457.2">This requires executing the following commands:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2458.1">$ </span></span><span class="koboSpan" id="kobo.2459.1">go get golang.org/x/text@v0.3.5
go: downloading golang.org/x/text v0.3.5
go: downgraded golang.org/x/text v0.14.0 =&gt; v0.3.5
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2460.1">The purpose of the previous command is to download an older version of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2461.1">golang.org/x/text</span></code><span class="koboSpan" id="kobo.2462.1"> package with known vulnerabilities.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2463.1">The contents of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2464.1">go.mod</span></code><span class="koboSpan" id="kobo.2465.1"> are now the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2466.1">module github.com/mactsouk/mGo4th/ch12/vulcheck
go 1.21.5
require golang.org/x/text v0.3.5
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2467.1">So, we are now using version </span><code class="inlineCode"><span class="koboSpan" id="kobo.2468.1">v0.3.5</span></code><span class="koboSpan" id="kobo.2469.1"> of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2470.1">golang.org/x/text</span></code><span class="koboSpan" id="kobo.2471.1"> package.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2472.1">This time, running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2473.1">govulncheck</span></code><span class="koboSpan" id="kobo.2474.1"> against </span><code class="inlineCode"><span class="koboSpan" id="kobo.2475.1">vul.go</span></code><span class="koboSpan" id="kobo.2476.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2477.1">$ </span></span><span class="koboSpan" id="kobo.2478.1">~/go/bin/govulncheck ./...
</span><span class="koboSpan" id="kobo.2478.2">Scanning your code and 47 packages across 1 dependent module for known vulnerabilities...
</span><span class="koboSpan" id="kobo.2478.3">=== Informational ===
Found 2 vulnerabilities in packages that you import, but there are no call
stacks leading to the use of these vulnerabilities. </span><span class="koboSpan" id="kobo.2478.4">You may not need to
take any action. </span><span class="koboSpan" id="kobo.2478.5">See https://pkg.go.dev/golang.org/x/vuln/cmd/govulncheck
for details.
</span><span class="koboSpan" id="kobo.2478.6">Vulnerability #1: GO-2022-1059
    Denial of service via crafted Accept-Language header in
    golang.org/x/text/language
  More info: https://pkg.go.dev/vuln/GO-2022-1059
  Module: golang.org/x/text
    Found in: golang.org/x/text@v0.3.5
    Fixed in: golang.org/x/text@v0.3.8
Vulnerability #2: GO-2021-0113
    Out-of-bounds read in golang.org/x/text/language
  More info: https://pkg.go.dev/vuln/GO-2021-0113
  Module: golang.org/x/text
    Found in: golang.org/x/text@v0.3.5
    Fixed in: golang.org/x/text@v0.3.7
No vulnerabilities found.
</span><span class="koboSpan" id="kobo.2478.7">Share feedback at https://go.dev/s/govulncheck-feedback
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2479.1">This</span><a id="_idIndexMarker1095"/><span class="koboSpan" id="kobo.2480.1"> time, </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.2481.1">we found vulnerabilities in the modules that we are using</span></strong><span class="koboSpan" id="kobo.2482.1">. </span><span class="koboSpan" id="kobo.2482.2">The solution to that is to upgrade to the latest version of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2483.1">golang.org/x/text</span></code><span class="koboSpan" id="kobo.2484.1"> package by running the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2485.1">$ </span></span><span class="koboSpan" id="kobo.2486.1">go get golang.org/x/text@latest
go: upgraded golang.org/x/text v0.3.5 =&gt; v0.14.0
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2487.1">If you want to get the output in JSON format, you can run </span><code class="inlineCode"><span class="koboSpan" id="kobo.2488.1">govulncheck</span></code><span class="koboSpan" id="kobo.2489.1"> with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2490.1">-json</span></code><span class="koboSpan" id="kobo.2491.1"> flag, which is illustrated in the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2492.1">$ </span></span><span class="koboSpan" id="kobo.2493.1">~/go/bin/govulncheck -json ./...
</span><span class="koboSpan" id="kobo.2493.2">{
  "config": {
    "protocol_version": "v1.0.0",
    "scanner_name": "govulncheck",
    "scanner_version": "v1.0.1",
    "db": "https://vuln.go.dev",
    "db_last_modified": "2023-12-11T21:16:41Z",
    "go_version": "go1.21.5",
    "scan_level": "symbol"
  }
}
{
  "progress": {
    "message": "Scanning your code and 47 packages across 1 dependent module for known vulnerabilities..."
  </span><span class="koboSpan" id="kobo.2493.3">}
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2494.1">You</span><a id="_idIndexMarker1096"/><span class="koboSpan" id="kobo.2495.1"> should definitely make a habit of using </span><code class="inlineCode"><span class="koboSpan" id="kobo.2496.1">govulncheck</span></code><span class="koboSpan" id="kobo.2497.1"> in your projects.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2498.1">The next section discusses a handy Go feature, cross-compilation, because after testing your code, you usually want to distribute it!</span></p>
<h1 class="heading-1" id="_idParaDest-359"><span class="koboSpan" id="kobo.2499.1">Cross-compilation</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2500.1">Cross-compilation is </span><a id="_idIndexMarker1097"/><span class="koboSpan" id="kobo.2501.1">the process of generating a binary executable file for a different architecture than the one that we are working on without having access to other machines. </span><span class="koboSpan" id="kobo.2501.2">The main benefit that we receive from cross-compilation is that we do not need a second or third machine to create and distribute executable files for different architectures. </span><span class="koboSpan" id="kobo.2501.3">This means that we basically need just a single machine for our development. </span><span class="koboSpan" id="kobo.2501.4">Fortunately, Go has built-in support for cross-compilation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2502.1">To cross-compile a</span><a id="_idIndexMarker1098"/><span class="koboSpan" id="kobo.2503.1"> Go source file, we need to set the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2504.1">GOOS</span></code><span class="koboSpan" id="kobo.2505.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2506.1">GOARCH</span></code><span class="koboSpan" id="kobo.2507.1"> environment variables to the target operating system and architecture, respectively, which is not as difficult as it sounds.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2508.1">You can find a list of available values for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2509.1">GOOS</span></code><span class="koboSpan" id="kobo.2510.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2511.1">GOARCH</span></code><span class="koboSpan" id="kobo.2512.1"> environment variables at </span><a href="https://go.dev/doc/install/source"><span class="url"><span class="koboSpan" id="kobo.2513.1">https://go.dev/doc/install/source</span></span></a><span class="koboSpan" id="kobo.2514.1">. </span><span class="koboSpan" id="kobo.2514.2">Keep in mind, however, that not all </span><code class="inlineCode"><span class="koboSpan" id="kobo.2515.1">GOOS</span></code><span class="koboSpan" id="kobo.2516.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2517.1">GOARCH</span></code><span class="koboSpan" id="kobo.2518.1"> combinations are valid. </span><span class="koboSpan" id="kobo.2518.2">You can find a list of all valid combinations using </span><code class="inlineCode"><span class="koboSpan" id="kobo.2519.1">go tool dist list</span></code><span class="koboSpan" id="kobo.2520.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2521.1">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2522.1">crossCompile.go</span></code><span class="koboSpan" id="kobo.2523.1"> is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2524.1">package</span></span><span class="koboSpan" id="kobo.2525.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2526.1">import</span></span><span class="koboSpan" id="kobo.2527.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.2528.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2529.1">fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.2530.1">"runtime"</span></span><span class="koboSpan" id="kobo.2531.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2532.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2533.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2534.1">()</span></span><span class="koboSpan" id="kobo.2535.1"> {
    fmt.Print(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2536.1">"You are using "</span></span><span class="koboSpan" id="kobo.2537.1">, runtime.GOOS, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2538.1">" "</span></span><span class="koboSpan" id="kobo.2539.1">)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2540.1">"on a(n)"</span></span><span class="koboSpan" id="kobo.2541.1">, runtime.GOARCH, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2542.1">"machine"</span></span><span class="koboSpan" id="kobo.2543.1">)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2544.1">"with Go version"</span></span><span class="koboSpan" id="kobo.2545.1">, runtime.Version())
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2546.1">Running it on a macOS machine with Go version 1.21.5 generates the next output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2547.1">$ </span></span><span class="koboSpan" id="kobo.2548.1">go run crossCompile.go
You are using darwin on a(n) arm64 machine
with Go version go1.21.5
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2549.1">Compiling </span><code class="inlineCode"><span class="koboSpan" id="kobo.2550.1">crossCompile.go</span></code><span class="koboSpan" id="kobo.2551.1"> for the Linux OS that runs on a machine with an amd64 processor is as simple as running the next command on a macOS machine:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2552.1">$ </span></span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.2553.1">env</span></span><span class="koboSpan" id="kobo.2554.1"> GOOS=linux GOARCH=amd64 go build crossCompile.go
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2555.1">$ </span></span><span class="koboSpan" id="kobo.2556.1">file crossCompile
crossCompile: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, Go BuildID=28hWIc2cet8-kmHxC-W6/Y7DEXRrm3CrFgqVvflBA/KWqCcnUNgUozkElJHidj/Geqp0vSmfLgkLrZ_-7cX, with debug_info, not stripped
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2557.1">Transferring that file to an Arch Linux machine and running it generates the next output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2558.1">$ </span></span><span class="koboSpan" id="kobo.2559.1">./crossCompile 
You are using linux on a(n) amd64 machine
with Go version go1.21.5
</span></code></pre>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2560.1">One thing to notice here is that the cross-compiled binary file of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2561.1">crossCompile.go</span></code><span class="koboSpan" id="kobo.2562.1"> prints the Go version of the machine used for compiling it—this makes perfect sense as the target machine might not even have Go installed on it!</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2563.1">Cross-compilation</span><a id="_idIndexMarker1099"/><span class="koboSpan" id="kobo.2564.1"> is a great Go feature that can come in handy when you want to generate multiple versions of your executables through a CI/CD system and distribute them.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2565.1">The next subsection discusses </span><code class="inlineCode"><span class="koboSpan" id="kobo.2566.1">go:generate</span></code><span class="koboSpan" id="kobo.2567.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-360"><span class="koboSpan" id="kobo.2568.1">Using go:generate</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2569.1">Although </span><code class="inlineCode"><span class="koboSpan" id="kobo.2570.1">go:generate</span></code><span class="koboSpan" id="kobo.2571.1"> is not </span><a id="_idIndexMarker1100"/><span class="koboSpan" id="kobo.2572.1">directly connected to testing or profiling, it is a handy and advanced Go feature, and I believe that this chapter is the perfect place for discussing it as it can also help you with testing. </span><span class="koboSpan" id="kobo.2572.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2573.1">go:generate</span></code><span class="koboSpan" id="kobo.2574.1"> directive is associated with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2575.1">go generate</span></code><span class="koboSpan" id="kobo.2576.1"> command, which was added in Go 1.4 in order to help with automation, and allows you to run commands described by directives within existing files.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2577.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2578.1">go generate</span></code><span class="koboSpan" id="kobo.2579.1"> command supports the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2580.1">-v</span></code><span class="koboSpan" id="kobo.2581.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2582.1">-n</span></code><span class="koboSpan" id="kobo.2583.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2584.1">-x</span></code><span class="koboSpan" id="kobo.2585.1"> flags. </span><span class="koboSpan" id="kobo.2585.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2586.1">-v</span></code><span class="koboSpan" id="kobo.2587.1"> flag prints the names of packages and files as they are processed, whereas the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2588.1">-n</span></code><span class="koboSpan" id="kobo.2589.1"> flag prints the commands that would be executed. </span><span class="koboSpan" id="kobo.2589.2">Lastly, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2590.1">-x</span></code><span class="koboSpan" id="kobo.2591.1"> flag prints commands as they are executed—this is great for debugging </span><code class="inlineCode"><span class="koboSpan" id="kobo.2592.1">go:generate</span></code><span class="koboSpan" id="kobo.2593.1"> commands.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2594.1">The main reasons that you might need to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2595.1">go:generate</span></code><span class="koboSpan" id="kobo.2596.1"> are the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2597.1">You want to download dynamic data from the internet or some other source prior to the execution of the Go code.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2598.1">You want to execute some code prior to running the Go code.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2599.1">You want to generate a version number or other unique data before code execution.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2600.1">You want to make sure that you have sample data to work with. </span><span class="koboSpan" id="kobo.2600.2">For example, you can put data into a database using </span><code class="inlineCode"><span class="koboSpan" id="kobo.2601.1">go:generate</span></code><span class="koboSpan" id="kobo.2602.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2603.1">As using </span><code class="inlineCode"><span class="koboSpan" id="kobo.2604.1">go:generate</span></code><span class="koboSpan" id="kobo.2605.1"> is not considered a good practice because it hides things from the developer and creates additional dependencies, I try to avoid it when I can, and I usually can. </span><span class="koboSpan" id="kobo.2605.2">On the other hand, if you really need it, you will know it!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2606.1">The use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2607.1">go:generate</span></code><span class="koboSpan" id="kobo.2608.1"> is illustrated in </span><code class="inlineCode"><span class="koboSpan" id="kobo.2609.1">goGenerate.go</span></code><span class="koboSpan" id="kobo.2610.1">, which is found in </span><code class="inlineCode"><span class="koboSpan" id="kobo.2611.1">./ch12/generate</span></code><span class="koboSpan" id="kobo.2612.1"> and has the following content:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2613.1">package</span></span><span class="koboSpan" id="kobo.2614.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2615.1">import</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2616.1">"fmt"</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.2617.1">//go:generate ./echo.sh</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2618.1">This executes the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2619.1">echo.sh</span></code><span class="koboSpan" id="kobo.2620.1"> script, which should be available in the current directory.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.2621.1">//go:generate echo GOFILE: $GOFILE</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.2622.1">//go:generate echo GOARCH: $GOARCH</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.2623.1">//go:generate echo GOOS: $GOOS</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.2624.1">//go:generate echo GOLINE: $GOLINE</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.2625.1">//go:generate echo GOPACKAGE: $GOPACKAGE</span></span>
</code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2626.1">$GOFILE</span></code><span class="koboSpan" id="kobo.2627.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2628.1">$GOARCH</span></code><span class="koboSpan" id="kobo.2629.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2630.1">$GOOS</span></code><span class="koboSpan" id="kobo.2631.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2632.1">$GOLINE</span></code><span class="koboSpan" id="kobo.2633.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2634.1">$GOPACKAGE</span></code><span class="koboSpan" id="kobo.2635.1"> are special variables and are translated at the time of execution.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.2636.1">//go:generate echo DOLLAR: $DOLLAR</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.2637.1">//go:generate echo Hello!</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.2638.1">//go:generate ls -l</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.2639.1">//go:generate ./hello.py</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2640.1">This executes the hello.py Python script, which should be available in the current directory.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2641.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2642.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2643.1">()</span></span><span class="koboSpan" id="kobo.2644.1"> {
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2645.1">"Hello there!"</span></span><span class="koboSpan" id="kobo.2646.1">)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2647.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2648.1">go generate</span></code><span class="koboSpan" id="kobo.2649.1"> command</span><a id="_idIndexMarker1101"/><span class="koboSpan" id="kobo.2650.1"> is not going to run the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2651.1">fmt.Println()</span></code><span class="koboSpan" id="kobo.2652.1"> statement or any other statements found in a Go source file. </span><span class="koboSpan" id="kobo.2652.2">Lastly, keep in mind that </span><code class="inlineCode"><span class="koboSpan" id="kobo.2653.1">go generate</span></code><span class="koboSpan" id="kobo.2654.1"> is not executed automatically and must be run explicitly.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2655.1">Working with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2656.1">goGenerate.go</span></code><span class="koboSpan" id="kobo.2657.1"> from within </span><code class="inlineCode"><span class="koboSpan" id="kobo.2658.1">./ch12/generate</span></code><span class="koboSpan" id="kobo.2659.1"> generates the next output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2660.1">$ </span></span><span class="koboSpan" id="kobo.2661.1">go mod init
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2662.1">$ </span></span><span class="koboSpan" id="kobo.2663.1">go mod tidy
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2664.1">$ </span></span><span class="koboSpan" id="kobo.2665.1">go generate
Hello world!
</span><span class="koboSpan" id="kobo.2665.2">GOFILE: goGenerate.go
GOARCH: arm64
GOOS: darwin
GOLINE: 10
GOPACKAGE: main
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2666.1">This is the output of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2667.1">$GOFILE</span></code><span class="koboSpan" id="kobo.2668.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2669.1">$GOARCH</span></code><span class="koboSpan" id="kobo.2670.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2671.1">$GOOS</span></code><span class="koboSpan" id="kobo.2672.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2673.1">$GOLINE</span></code><span class="koboSpan" id="kobo.2674.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2675.1">$GOPACKAGE</span></code><span class="koboSpan" id="kobo.2676.1"> variables, which shows the values of these variables defined at runtime.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2677.1">DOLLAR: $
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2678.1">There is also a special variable named </span><code class="inlineCode"><span class="koboSpan" id="kobo.2679.1">$DOLLAR</span></code><span class="koboSpan" id="kobo.2680.1"> for printing a dollar character in the output because </span><code class="inlineCode"><span class="koboSpan" id="kobo.2681.1">$</span></code><span class="koboSpan" id="kobo.2682.1"> has a special meaning in the OS environment.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2683.1">Hello!
</span><span class="koboSpan" id="kobo.2683.2">total 32
-rwxr-xr-x@ 1 mtsouk  staff   32 Nov 10 22:22 echo.sh
-rw-r--r--  1 mtsouk  staff   59 Dec 14 20:25 go.mod
-rw-r--r--@ 1 mtsouk  staff  383 Nov 10 22:22 goGenerate.go
-rwxr-xr-x@ 1 mtsouk  staff   52 Nov 10 22:22 hello.py
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2684.1">This is the output of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2685.1">ls -l</span></code><span class="koboSpan" id="kobo.2686.1"> command, which shows the files found in the current directory at the time of the code execution. </span><span class="koboSpan" id="kobo.2686.2">This can be used to test whether some necessary files are present at the time of execution or not.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2687.1">Hello from Python!
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2688.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.2689.1">go generate</span></code><span class="koboSpan" id="kobo.2690.1"> with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2691.1">-n</span></code><span class="koboSpan" id="kobo.2692.1"> shows the commands that are going to be executed:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2693.1">$ </span></span><span class="koboSpan" id="kobo.2694.1">go generate -n
./echo.sh
echo GOFILE: goGenerate.go
echo GOARCH: arm64
echo GOOS: darwin
echo GOLINE: 10
echo GOPACKAGE: main
echo DOLLAR: $
echo Hello!
</span><span class="koboSpan" id="kobo.2694.2">ls -l
./hello.py
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2695.1">So, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2696.1">go:generate</span></code><span class="koboSpan" id="kobo.2697.1"> can help </span><a id="_idIndexMarker1102"/><span class="koboSpan" id="kobo.2698.1">you work with the OS </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.2699.1">before program execution</span></strong><span class="koboSpan" id="kobo.2700.1">. </span><span class="koboSpan" id="kobo.2700.2">However, as it hides things from the developer, its usage should be limited.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2701.1">The last section of this chapter talks about example functions.</span></p>
<h1 class="heading-1" id="_idParaDest-361"><span class="koboSpan" id="kobo.2702.1">Creating example functions</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2703.1">Part of the documentation process is</span><a id="_idIndexMarker1103"/><span class="koboSpan" id="kobo.2704.1"> generating example code that showcases the use of some or all the functions and data types of a package. </span><span class="koboSpan" id="kobo.2704.2">Example functions have many benefits, including the fact that they are executable tests that are executed by </span><code class="inlineCode"><span class="koboSpan" id="kobo.2705.1">go test</span></code><span class="koboSpan" id="kobo.2706.1">. </span><span class="koboSpan" id="kobo.2706.2">Therefore, if an example function contains an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2707.1">// Output:</span></code><span class="koboSpan" id="kobo.2708.1"> line, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2709.1">go test</span></code><span class="koboSpan" id="kobo.2710.1"> tool checks whether the calculated output matches the values found after the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2711.1">// Output:</span></code><span class="koboSpan" id="kobo.2712.1"> line. </span><span class="koboSpan" id="kobo.2712.2">Although we should include example functions in Go files that end with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2713.1">_test.go</span></code><span class="koboSpan" id="kobo.2714.1">, we do not need to import the testing Go package for example functions. </span><span class="koboSpan" id="kobo.2714.2">Moreover, the name of each example function must begin with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2715.1">Example</span></code><span class="koboSpan" id="kobo.2716.1">. </span><span class="koboSpan" id="kobo.2716.2">Lastly, example functions take no input parameters and return no results.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2717.1">We are going to illustrate example functions using the code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2718.1">exampleFunctions.go</span></code><span class="koboSpan" id="kobo.2719.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2720.1">exampleFunctions_test.go</span></code><span class="koboSpan" id="kobo.2721.1">. </span><span class="koboSpan" id="kobo.2721.2">The content of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2722.1">exampleFunctions.go</span></code><span class="koboSpan" id="kobo.2723.1"> is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2724.1">package</span></span><span class="koboSpan" id="kobo.2725.1"> exampleFunctions
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2726.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2727.1">LengthRange</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2728.1">(s </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2729.1">string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2730.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2731.1">int</span></span><span class="koboSpan" id="kobo.2732.1"> {
    i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.2733.1">0</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2734.1">for</span></span><span class="koboSpan" id="kobo.2735.1"> _, _ = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2736.1">range</span></span><span class="koboSpan" id="kobo.2737.1"> s {
        i = i + </span><span class="hljs-number"><span class="koboSpan" id="kobo.2738.1">1</span></span><span class="koboSpan" id="kobo.2739.1">
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2740.1">return</span></span><span class="koboSpan" id="kobo.2741.1"> i
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2742.1">The previous </span><a id="_idIndexMarker1104"/><span class="koboSpan" id="kobo.2743.1">code presents a regular package that contains a single function named </span><code class="inlineCode"><span class="koboSpan" id="kobo.2744.1">LengthRange()</span></code><span class="koboSpan" id="kobo.2745.1">. </span><span class="koboSpan" id="kobo.2745.2">The contents of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2746.1">exampleFunctions_test.go</span></code><span class="koboSpan" id="kobo.2747.1">, which includes the example functions, are the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2748.1">package</span></span><span class="koboSpan" id="kobo.2749.1"> exampleFunctions
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2750.1">import</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2751.1">"fmt"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2752.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2753.1">ExampleLengthRange</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2754.1">()</span></span><span class="koboSpan" id="kobo.2755.1"> {
    fmt.Println(LengthRange(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2756.1">"Mihalis"</span></span><span class="koboSpan" id="kobo.2757.1">))
    fmt.Println(LengthRange(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2758.1">"Mastering Go, 4th edition!"</span></span><span class="koboSpan" id="kobo.2759.1">))
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2760.1">// Output:</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.2761.1">// 7</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.2762.1">// 7</span></span><span class="koboSpan" id="kobo.2763.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2764.1">What the comment lines say is that the expected output is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2765.1">7</span></code><span class="koboSpan" id="kobo.2766.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2767.1">7</span></code><span class="koboSpan" id="kobo.2768.1">, which is obviously wrong. </span><span class="koboSpan" id="kobo.2768.2">This is going to be seen after we run </span><code class="inlineCode"><span class="koboSpan" id="kobo.2769.1">go test</span></code><span class="koboSpan" id="kobo.2770.1">:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2771.1">$ </span></span><span class="koboSpan" id="kobo.2772.1">go </span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.2773.1">test</span></span><span class="koboSpan" id="kobo.2774.1"> -v exampleFunctions*
=== RUN   ExampleLengthRange
--- FAIL: ExampleLengthRange (0.00s)
got:
7
26
want:
7
7
FAIL
FAIL    command-line-arguments  0.410s
FAIL
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2775.1">As expected, there is an error in the generated output—the second generated value is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2776.1">26</span></code><span class="koboSpan" id="kobo.2777.1"> instead of the expected </span><code class="inlineCode"><span class="koboSpan" id="kobo.2778.1">7</span></code><span class="koboSpan" id="kobo.2779.1">. </span><span class="koboSpan" id="kobo.2779.2">If we make the necessary corrections, the output is going to look as follows:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.2780.1">$ </span></span><span class="koboSpan" id="kobo.2781.1">go </span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.2782.1">test</span></span><span class="koboSpan" id="kobo.2783.1"> -v exampleFunctions*
=== RUN   ExampleLengthRange
--- PASS: ExampleLengthRange (0.00s)
PASS
ok      command-line-arguments  0.572s
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2784.1">Example</span><a id="_idIndexMarker1105"/><span class="koboSpan" id="kobo.2785.1"> functions can be a great tool both for learning the capabilities of a package and for testing the correctness of functions, so I suggest that you include both test code and example functions in your Go packages. </span><span class="koboSpan" id="kobo.2785.2">As a bonus, your test functions appear in the documentation of the package, if you decide to generate package documentation.</span></p>
<h1 class="heading-1" id="_idParaDest-362"><span class="koboSpan" id="kobo.2786.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2787.1">This chapter discussed </span><code class="inlineCode"><span class="koboSpan" id="kobo.2788.1">go:generate</span></code><span class="koboSpan" id="kobo.2789.1">, code profiling and tracing, and testing Go code. </span><span class="koboSpan" id="kobo.2789.2">You might find the Go way of testing boring, but this happens because Go is boring and predictable in general and that is a good thing! </span><span class="koboSpan" id="kobo.2789.3">Remember that writing bug-free code is important, whereas writing the fastest code possible is not always that important.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2790.1">Most of the time, you need to be able to write fast-enough code. </span><span class="koboSpan" id="kobo.2790.2">So, spend more time writing tests than benchmarks, unless your code runs really slowly. </span><span class="koboSpan" id="kobo.2790.3">You have also learned how to find unreachable code and how to cross-compile Go code.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2791.1">Although the discussions of the Go profiler and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2792.1">go tool trace</span></code><span class="koboSpan" id="kobo.2793.1"> are far from complete, you should understand that with topics such as profiling and code tracing, nothing can replace experimenting and trying new techniques on your own!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2794.1">The next chapter is about fuzz testing, which is a modern way of testing Go code in addition to the testing techniques presented in this chapter. </span><span class="koboSpan" id="kobo.2794.2">We will also look at observability in Go.</span></p>
<h1 class="heading-1" id="_idParaDest-363"><span class="koboSpan" id="kobo.2795.1">Exercises</span></h1>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2796.1">Create test functions for a package that calculates numbers in the Fibonacci sequence. </span><span class="koboSpan" id="kobo.2796.2">Do not forget to implement the package.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2797.1">The code in </span><code class="inlineCode"><span class="koboSpan" id="kobo.2798.1">testHTTP/server_test.go</span></code><span class="koboSpan" id="kobo.2799.1"> uses the same value for </span><code class="inlineCode"><span class="koboSpan" id="kobo.2800.1">lastlogin</span></code><span class="koboSpan" id="kobo.2801.1"> in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2802.1">expected</span></code><span class="koboSpan" id="kobo.2803.1"> variable. </span><span class="koboSpan" id="kobo.2803.2">This is clearly a bug in </span><code class="inlineCode"><span class="koboSpan" id="kobo.2804.1">restdb.go</span></code><span class="koboSpan" id="kobo.2805.1"> as the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2806.1">lastlogin</span></code><span class="koboSpan" id="kobo.2807.1"> should be updated. </span><span class="koboSpan" id="kobo.2807.2">After correcting the bug, modify </span><code class="inlineCode"><span class="koboSpan" id="kobo.2808.1">testHTTP/server_test.go</span></code><span class="koboSpan" id="kobo.2809.1"> to take into account the different values of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2810.1">lastlogin</span></code><span class="koboSpan" id="kobo.2811.1"> field.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2812.1">Try to find the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2813.1">os.TempDir()</span></code><span class="koboSpan" id="kobo.2814.1"> in various operating systems.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2815.1">Type </span><code class="inlineCode"><span class="koboSpan" id="kobo.2816.1">go doc os/signal.NotifyContext</span></code><span class="koboSpan" id="kobo.2817.1"> to see that you can handle signals in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2818.1">context.Context</span></code><span class="koboSpan" id="kobo.2819.1"> environment. </span><span class="koboSpan" id="kobo.2819.2">Try to create an example that uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.2820.1">signal.NotifyContext</span></code><span class="koboSpan" id="kobo.2821.1">.</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-364"><span class="koboSpan" id="kobo.2822.1">Additional resources</span></h1>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2823.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2824.1">generate</span></code><span class="koboSpan" id="kobo.2825.1"> package: </span><a href="https://pkg.go.dev/cmd/go/internal/generate"><span class="url"><span class="koboSpan" id="kobo.2826.1">https://pkg.go.dev/cmd/go/internal/generate</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2827.1">Generating code: </span><a href="https://go.dev/blog/generate"><span class="url"><span class="koboSpan" id="kobo.2828.1">https://go.dev/blog/generate</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2829.1">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2830.1">testing</span></code><span class="koboSpan" id="kobo.2831.1">: </span><a href="https://go.dev/src/testing/testing.go"><span class="url"><span class="koboSpan" id="kobo.2832.1">https://go.dev/src/testing/testing.go</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2833.1">About </span><code class="inlineCode"><span class="koboSpan" id="kobo.2834.1">net/http/httptrace</span></code><span class="koboSpan" id="kobo.2835.1">: </span><a href="https://pkg.go.dev/net/http/httptrace"><span class="url"><span class="koboSpan" id="kobo.2836.1">https://pkg.go.dev/net/http/httptrace</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2837.1">Profile-guided optimization in Go 1.21: </span><a href="https://go.dev/blog/pgo"><span class="url"><span class="koboSpan" id="kobo.2838.1">https://go.dev/blog/pgo</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2839.1">Govulncheck v1.0.0 is released: </span><a href="https://go.dev/blog/govulncheck"><span class="url"><span class="koboSpan" id="kobo.2840.1">https://go.dev/blog/govulncheck</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2841.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2842.1">govulncheck</span></code><span class="koboSpan" id="kobo.2843.1"> tool: </span><a href="https://pkg.go.dev/golang.org/x/vuln/cmd/govulncheck"><span class="url"><span class="koboSpan" id="kobo.2844.1">https://pkg.go.dev/golang.org/x/vuln/cmd/govulncheck</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2845.1">A </span><code class="inlineCode"><span class="koboSpan" id="kobo.2846.1">govulncheck</span></code><span class="koboSpan" id="kobo.2847.1"> tutorial: </span><a href="https://go.dev/doc/tutorial/govulncheck"><span class="url"><span class="koboSpan" id="kobo.2848.1">https://go.dev/doc/tutorial/govulncheck</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2849.1">Build more secure apps with Go and Google: </span><a href="https://www.youtube.com/watch?v=HSt6FhsPT8c"><span class="url"><span class="koboSpan" id="kobo.2850.1">https://www.youtube.com/watch?v=HSt6FhsPT8c</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2851.1">Introducing HTTP Tracing by Jaana Dogan: </span><a href="https://go.dev/blog/http-tracing"><span class="url"><span class="koboSpan" id="kobo.2852.1">https://go.dev/blog/http-tracing</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2853.1">GopherCon 2019: Dave Cheney—Two Go Programs, Three Different Profiling Techniques: </span><a href="https://youtu.be/nok0aYiGiYA "><span class="url"><span class="koboSpan" id="kobo.2854.1">https://youtu.be/nok0aYiGiYA</span></span></a></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.2855.1">Join our community on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2856.1">Join our community’s Discord space for discussions with the authors and other readers:</span></p>
<p class="normal"><a href="https://discord.gg/FzuQbc8zd6 "><span class="url"><span class="koboSpan" id="kobo.2857.1">https://discord.gg/FzuQbc8zd6</span></span></a></p>
<p class="normal"><a href="https://discord.gg/FzuQbc8zd6 "><span class="url"><span class="koboSpan" id="kobo.2858.1"><img alt="" role="presentation" src="../Images/QR_Code2286825896190168453.png"/></span></span></a></p>
</div>
</body></html>