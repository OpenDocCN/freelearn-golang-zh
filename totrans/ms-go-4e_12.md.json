["```go\nfunc main() {\n    **err := run(os.Args, os.Stdout)**\nif err != nil {\n        fmt.Printf(\"%s\\n\", err)\n        return\n    }\n} \n```", "```go\nfunc run(args []string, stdout io.Writer) error {\n    if len(args) == 1 {\n        return errors.New(\"No input!\")\n    }\n    // Continue with the implementation of run()\n// as you would have with main()\nreturn nil\n} \n```", "```go\n$ go run main.go \nNo input!\n$ go run main.go some input \n```", "```go\nfunc main() {\n    fmt.Println(os.TempDir())\n    cpuFilename := path.Join(os.TempDir(), \"cpuProfileCla.out\")\n    cpuFile, err := os.Create(cpuFilename)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    pprof.StartCPUProfile(cpuFile)\n    defer pprof.StopCPUProfile() \n```", "```go\n total := 0\nfor i := 2; i < 100000; i++ {\n        n := N1(i)\n        if n {\n            total = total + 1\n        }\n    }\n    fmt.Println(\"Total primes:\", total)\n    total = 0\nfor i := 2; i < 100000; i++ {\n        n := N2(i)\n        if n {\n            total = total + 1\n        }\n    }\n    fmt.Println(\"Total primes:\", total)\n    for i := 1; i < 90; i++ {\n        n := fibo1(i)\n        fmt.Print(n, \" \")\n    }\n    fmt.Println()\n    for i := 1; i < 90; i++ {\n        n := fibo2(i)\n        fmt.Print(n, \" \")\n    }\n    fmt.Println()\n    runtime.GC() \n```", "```go\n // Memory profiling!\n    memoryFilename := path.Join(os.TempDir(), \"memoryProfileCla.out\")\n    memory, err := os.Create(memoryFilename)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    defer memory.Close() \n```", "```go\n for i := 0; i < 10; i++ {\n        s := make([]byte, 50000000)\n        if s == nil {\n            fmt.Println(\"Operation failed!\")\n        }\n        time.Sleep(50 * time.Millisecond)\n    }\n    err = pprof.WriteHeapProfile(memory)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n} \n```", "```go\n$ go tool pprof cpuProfileCla.out\nType: cpu\nTime: Dec 13, 2023 at 6:35pm (EET)\nDuration: 14.85s, Total samples = 650ms ( 4.38%)\nEntering interactive mode (type \"help\" for commands, \"o\" for options)\n(pprof) top\nShowing nodes accounting for 630ms, 96.92% of 650ms total\nShowing top 10 nodes out of 47\n      flat  flat%   sum%        cum   cum%\n     300ms 46.15% 46.15%    330ms 50.77%  main.N2 (inline)\n     120ms 18.46% 64.62%    120ms 18.46%  main.N1 (inline)\n      40ms  6.15% 70.77%     40ms  6.15%  runtime.kevent\n      40ms  6.15% 76.92%     40ms  6.15%  runtime.pthread_cond_signal\n      40ms  6.15% 83.08%     40ms  6.15%  runtime.pthread_cond_wait\n      30ms  4.62% 87.69%     30ms  4.62%  runtime.asyncPreempt\n      30ms  4.62% 92.31%     30ms  4.62%  runtime.madvise\n      10ms  1.54% 93.85%     10ms  1.54%  internal/poll.(*pollDesc).prepare\n      10ms  1.54% 95.38%    480ms 73.85%  main.main\n      10ms  1.54% 96.92%     10ms  1.54%  runtime.memclrNoHeapPointers \n```", "```go\n(pprof) top10 -cum\nShowing nodes accounting for 440ms, 67.69% of 650ms total\nShowing top 10 nodes out of 47\n      flat  flat%   sum%        cum   cum%\n      10ms  1.54%  1.54%      480ms 73.85%  main.main\n         0     0%  1.54%      480ms 73.85%  runtime.main\n     300ms 46.15% 47.69%      330ms 50.77%  main.N2 (inline)\n     120ms 18.46% 66.15%      120ms 18.46%  main.N1 (inline)\n         0     0% 66.15%      120ms 18.46%  runtime.mcall\n      10ms  1.54% 67.69%      120ms 18.46%  runtime.schedule\n         0     0% 67.69%      110ms 16.92%  runtime.park_m\n         0     0% 67.69%       80ms 12.31%  runtime.findRunnable\n         0     0% 67.69%       50ms  7.69%  runtime.notewakeup\n         0     0% 67.69%       50ms  7.69%  runtime.semawakeup \n```", "```go\n(pprof) list main.N1\nTotal: 650ms\nROUTINE ======================== main.N1 in /Users/mtsouk/go/src/github.com/mactsouk/mGo4th/ch12/profileCla.go\n     120ms      120ms (flat, cum) 18.46% of Total\n         .          .     36:func N1(n int) bool {\n         .          .     37:    k := math.Floor(float64(n/2 + 1))\n         .          .     38:    for i := 2; i < int(k); i++ {\n     120ms      120ms     39:        if (n % i) == 0 {\n         .          .     40:            return false\n         .          .     41:        }\n         .          .     42:    }\n         .          .     43:    return true\n         .          .     44:} \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"net/http\"\n\"net/http/pprof\"\n\"os\"\n\"time\"\n) \n```", "```go\nfunc myHandler(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintf(w, \"Serving: %s\\n\", r.URL.Path)\n    fmt.Printf(\"Served: %s\\n\", r.Host)\n}\nfunc timeHandler(w http.ResponseWriter, r *http.Request) {\n    t := time.Now().Format(time.RFC1123)\n    Body := \"The current time is:\"\n    fmt.Fprintf(w, \"%s %s\", Body, t)\n    fmt.Fprintf(w, \"Serving: %s\\n\", r.URL.Path)\n    fmt.Printf(\"Served time for: %s\\n\", r.Host)\n} \n```", "```go\nfunc main() {\n    PORT := \":8001\"\n    arguments := os.Args\n    if len(arguments) == 1 {\n        fmt.Println(\"Using default port number: \", PORT)\n    } else {\n        PORT = \":\" + arguments[1]\n        fmt.Println(\"Using port number: \", PORT)\n    }\n    r := http.NewServeMux()\n    r.HandleFunc(\"/time\", timeHandler)\n    r.HandleFunc(\"/\", myHandler) \n```", "```go\n err := http.ListenAndServe(PORT, r)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n} \n```", "```go\n$ go tool pprof http://localhost:8001/debug/pprof/profile\nFetching profile over HTTP from http://localhost:8001/debug/pprof/profile\nSaved profile in /Users/mtsouk/pprof/pprof.samples.cpu.001.pb.gz\nType: cpu\nTime: Dec 13, 2023 at 6:44pm (EET)\nDuration: 30.02s, Total samples = 30ms (  0.1%)\nEntering interactive mode (type \"help\" for commands, \"o\" for options)\n(pprof) % \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"os\"\n\"path\"\n\"runtime/trace\"\n\"time\"\n) \n```", "```go\nfunc main() {\n    filename := path.Join(os.TempDir(), \"traceCLA.out\")\n    f, err := os.Create(filename)\n    if err != nil {\n        panic(err)\n    }\n    defer f.Close() \n```", "```go\n err = trace.Start(f)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    defer trace.Stop() \n```", "```go\n for i := 0; i < 3; i++ {\n        s := make([]byte, 50000000)\n        if s == nil {\n            fmt.Println(\"Operation failed!\")\n        }\n    }\n    for i := 0; i < 5; i++ {\n        s := make([]byte, 100000000)\n        if s == nil {\n            fmt.Println(\"Operation failed!\")\n        }\n        time.Sleep(time.Millisecond)\n    }\n} \n```", "```go\n$ go tool trace /path/ToTemporary/Directory/traceCLA.out\n2023/12/14 18:12:06 Parsing trace...\n2023/12/14 18:12:06 Splitting trace...\n2023/12/14 18:12:06 Opening browser. Trace viewer is listening on http://127.0.0.1:52829 \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"net/http\"\n\"net/http/httptrace\"\n\"os\"\n) \n```", "```go\nfunc main() {\n    if len(os.Args) != 2 {\n        fmt.Printf(\"Usage: URL\\n\")\n        return\n    }\n    URL := os.Args[1]\n    client := http.Client{}\n    req, _ := http.NewRequest(\"GET\", URL, nil) \n```", "```go\n trace := &httptrace.ClientTrace{\n        GotFirstResponseByte: func() {\n            fmt.Println(\"First response byte!\")\n        },\n        GotConn: func(connInfo httptrace.GotConnInfo) {\n            fmt.Printf(\"Got Conn: %+v\\n\", connInfo)\n        },\n        DNSDone: func(dnsInfo httptrace.DNSDoneInfo) {\n            fmt.Printf(\"DNS Info: %+v\\n\", dnsInfo)\n        },\n        ConnectStart: func(network, addr string) {\n            fmt.Println(\"Dial start\")\n        },\n        ConnectDone: func(network, addr string, err error) {\n            fmt.Println(\"Dial done\")\n        },\n        WroteHeaders: func() {\n            fmt.Println(\"Wrote headers\")\n        },\n    } \n```", "```go\n req = req.WithContext(httptrace.WithClientTrace(req.Context(), trace))\n    fmt.Println(\"Requesting data from server!\")\n    _, err := http.DefaultTransport.RoundTrip(req)\n    if err != nil {\n        fmt.Println(err)\n        return\n    } \n```", "```go\n _, err = client.Do(req)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n} \n```", "```go\n$ go run traceHTTP.go https://go.dev\nRequesting data from server!\nDNS Info: {Addrs:[{IP:2001:4860:4802:32::15 Zone:} {IP:2001:4860:4802:34::15 Zone:} {IP:2001:4860:4802:36::15 Zone:} {IP:2001:4860:4802:38::15 Zone:} {IP:216.239.32.21 Zone:} {IP:216.239.34.21 Zone:} {IP:216.239.36.21 Zone:} {IP:216.239.38.21 Zone:}] Err:<nil> Coalesced:false}\nDial start\nDial done\nGot Conn: {Conn:0x1400018e000 Reused:false WasIdle:false IdleTime:0s}\nWrote headers\nFirst response byte!\nGot Conn: {Conn:0x1400018e000 Reused:true WasIdle:false IdleTime:0s}\nWrote headers\nFirst response byte! \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"net/http\"\n\"strings\"\n\"github.com/gorilla/mux\"\n) \n```", "```go\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    return\n} \n```", "```go\nfunc (h notAllowedHandler) ServeHTTP(rw http.ResponseWriter, r *http.Request) {\n    handler(rw, r)\n} \n```", "```go\ntype notAllowedHandler struct{}\nfunc main() {\n    r := mux.NewRouter()\n    r.NotFoundHandler = http.HandlerFunc(handler)\n    notAllowed := notAllowedHandler{}\n    r.MethodNotAllowedHandler = notAllowed\n    // Register GET\n    getMux := r.Methods(http.MethodGet).Subrouter()\n    getMux.HandleFunc(\"/time\", handler)\n    getMux.HandleFunc(\"/getall\", handler)\n    getMux.HandleFunc(\"/getid\", handler)\n    getMux.HandleFunc(\"/logged\", handler)\n    getMux.HandleFunc(\"/username/{id:[0-9]+}\", handler)\n    // Register PUT\n// Update User\n    putMux := r.Methods(http.MethodPut).Subrouter()\n    putMux.HandleFunc(\"/update\", handler)\n    // Register POST\n// Add User + Login + Logout\n    postMux := r.Methods(http.MethodPost).Subrouter()\n    postMux.HandleFunc(\"/add\", handler)\n    postMux.HandleFunc(\"/login\", handler)\n    postMux.HandleFunc(\"/logout\", handler)\n    // Register DELETE\n// Delete User\n    deleteMux := r.Methods(http.MethodDelete).Subrouter()\n    deleteMux.HandleFunc(\"/username/{id:[0-9]+}\", handler) \n```", "```go\n err := r.Walk(func(route *mux.Route, router *mux.Router, ancestors []*mux.Route) error { \n```", "```go\n pathTemplate, err := route.GetPathTemplate()\n        if err == nil {\n            fmt.Println(\"ROUTE:\", pathTemplate)\n        }\n        pathRegexp, err := route.GetPathRegexp()\n        if err == nil {\n            fmt.Println(\"Path regexp:\", pathRegexp)\n        }\n        qT, err := route.GetQueriesTemplates()\n        if err == nil {\n            fmt.Println(\"Queries templates:\", strings.Join(qT, \",\"))\n        }\n        qRegexps, err := route.GetQueriesRegexp()\n        if err == nil {\n            fmt.Println(\"Queries regexps:\", strings.Join(qRegexps, \",\"))\n        }\n        methods, err := route.GetMethods()\n        if err == nil {\n            fmt.Println(\"Methods:\", strings.Join(methods, \",\"))\n        }\n        fmt.Println()\n        return nil\n    }) \n```", "```go\n if err != nil {\n        fmt.Println(err)\n    }\n    http.Handle(\"/\", r)\n} \n```", "```go\n$ go mod init\n$ go mod tidy\n$ go run walkAll.go\nQueries templates: \nQueries regexps: \nMethods: GET\nROUTE: /time\nPath regexp: ^/time$\nQueries templates: \nQueries regexps: \nMethods: GET \n```", "```go\nROUTE: /getall\nPath regexp: ^/getall$\nQueries templates: \nQueries regexps: \nMethods: GET\nROUTE: /getid\nPath regexp: ^/getid$\nQueries templates: \nQueries regexps: \nMethods: GET\nROUTE: /logged\nPath regexp: ^/logged$\nQueries templates: \nQueries regexps: \nMethods: GET\nROUTE: /username/{id:[0-9]+}\nPath regexp: ^/username/(?P<v0>[0-9]+)$\nQueries templates: \nQueries regexps: \nMethods: GET \n```", "```go\nQueries templates: \nQueries regexps: \nMethods: PUT\nROUTE: /update\nPath regexp: ^/update$\nQueries templates: \nQueries regexps: \nMethods: PUT\nQueries templates: \nQueries regexps: \nMethods: POST\nROUTE: /add\nPath regexp: ^/add$\nQueries templates: \nQueries regexps: \nMethods: POST\nROUTE: /login\nPath regexp: ^/login$\nQueries templates: \nQueries regexps: \nMethods: POST\nROUTE: /logout\nPath regexp: ^/logout$\nQueries templates: \nQueries regexps: \nMethods: POST\nQueries templates: \nQueries regexps: \nMethods: DELETE\nROUTE: /username/{id:[0-9]+}\nPath regexp: ^/username/(?P<v0>[0-9]+)$\nQueries templates: \nQueries regexps: \nMethods: DELETE \n```", "```go\nfunc TestMatchInt(t *testing.T) {\n    if matchInt(\"\") {\n        t.Error(`matchInt(\"\") != false`)\n    } \n```", "```go\n if matchInt(\"00\") == false {\n        t.Error(`matchInt(\"00\") != true`)\n    } \n```", "```go\n if matchInt(\"-00\") == false {\n        t.Error(`matchInt(\"-00\") != true`)\n    }\n    if matchInt(\"+00\") == false {\n        t.Error(`matchInt(\"+00\") != true`)\n    }\n} \n```", "```go\nfunc TestWithRandom(t *testing.T) {\n    n := strconv.Itoa(random(-100000, 19999))\n    if matchInt(n) == false {\n        t.Error(\"n = \", n)\n    }\n} \n```", "```go\n$ go test -v *.go\n=== RUN   TestMatchInt\n--- PASS: TestMatchInt (0.00s)\n=== RUN   TestWithRandom\n--- PASS: TestWithRandom (0.00s)\nPASS\nok    command-line-arguments    0.580s \n```", "```go\npackage mySignals\nfunc HandleSignal(sig os.Signal) {\n    fmt.Println(\"handleSignal() Caught:\", sig)\n}\nfunc Listener() {\n    // Function implementation\n} \n```", "```go\npackage mySignals\nimport (\n    \"fmt\"\n\"syscall\"\n\"testing\"\n\"time\"\n)\nfunc TestAll(t *testing.T) {\n    go Listener()\n    time.Sleep(time.Second)\n    test_SIGUSR1()\n    time.Sleep(time.Second)\n    test_SIGUSR2()\n    time.Sleep(time.Second)\n    test_SIGHUP()\n    time.Sleep(time.Second)\n} \n```", "```go\nfunc test_SIGUSR1() {\n    fmt.Println(\"Sending syscall.SIGUSR1\")\n    syscall.Kill(syscall.Getpid(), syscall.SIGUSR1)\n}\nfunc test_SIGUSR2() {\n    fmt.Println(\"Sending syscall.SIGUSR2\")\n    syscall.Kill(syscall.Getpid(), syscall.SIGUSR2)\n}\nfunc test_SIGHUP() {\n    fmt.Println(\"Sending syscall.SIGHUP\")\n    syscall.Kill(syscall.Getpid(), syscall.SIGHUP)\n} \n```", "```go\n$ go test -v *.go\n=== RUN   TestAll\nProcess ID: 22100\nSending syscall.SIGUSR1\nhandleSignal() Caught: user defined signal 1\nExecution time: 1.001762208s\nSending syscall.SIGUSR2\nhandleSignal() Caught: user defined signal 2\nSending syscall.SIGHUP\nCaught: hangup\n--- PASS: TestAll (4.00s)\nPASS\nok    command-line-arguments    4.411s \n```", "```go\nok    command-line-arguments    (cached) \n```", "```go\nfunc myCleanUp() func() {\n    return func() {\n        fmt.Println(\"Cleaning up!\")\n    }\n} \n```", "```go\nfunc TestFoo(t *testing.T) {\n    t1 := path.Join(os.TempDir(), \"test01\")\n    t2 := path.Join(os.TempDir(), \"test02\") \n```", "```go\n err := os.Mkdir(t1, 0755)\n    if err != nil {\n        t.Error(\"os.Mkdir() failed:\", err)\n        return\n    } \n```", "```go\n defer t.Cleanup(func() {\n        err = os.Remove(t1)\n        if err != nil {\n            t.Error(\"os.Mkdir() failed:\", err)\n        }\n    }) \n```", "```go\n err = os.Mkdir(t2, 0755)\n    if err != nil {\n        t.Error(\"os.Mkdir() failed:\", err)\n        return\n    }\n} \n```", "```go\nfunc TestBar(t *testing.T) {\n    t1 := t.TempDir() \n```", "```go\n fmt.Println(t1)\n    t.Cleanup(myCleanUp())\n} \n```", "```go\n$ go test -v *.go\n=== RUN   TestFoo\n--- PASS: TestFoo (0.00s)\n=== RUN   TestBar\n/var/folders/sk/ltk8cnw50lzdtr2hxcj5sv2m0000gn/T/TestBar1090994662/001 \n```", "```go\nCleaning up!\n--- PASS: TestBar (0.00s)\nPASS\nok    command-line-arguments        0.493s \n```", "```go\n$ go test -v *.go -count=1\n=== RUN   TestFoo\n    cleanup_test.go:34: os.Mkdir() failed: mkdir /var/folders/sk/ltk8cnw50lzdtr2hxcj5sv2m0000gn/T/test02: file exists\n--- FAIL: TestFoo (0.00s)\n=== RUN   TestBar\n/var/folders/sk/ltk8cnw50lzdtr2hxcj5sv2m0000gn/T/TestBar1703429008/001\nCleaning up!\n--- PASS: TestBar (0.00s)\nFAIL\nFAIL    command-line-arguments    0.310s\nFAIL \n```", "```go\npackage quickt\ntype Point2D struct {\n    X, Y int\n}\nfunc Add(x1, x2 Point2D) Point2D {\n    temp := Point2D{}\n    temp.X = x1.X + x2.X\n    temp.Y = x1.Y + x2.Y\n    return temp\n} \n```", "```go\npackage quickt\nimport (\n    \"testing\"\n\"testing/quick\"\n)\nvar N = 1000000\nfunc TestWithItself(t *testing.T) {\n    condition := func(a, b Point2D) bool {\n        return Add(a, b) == Add(b, a)\n    }\n    err := quick.Check(condition, &quick.Config{MaxCount: N})\n    if err != nil {\n        t.Errorf(\"Error: %v\", err)\n    }\n} \n```", "```go\nfunc TestThree(t *testing.T) {\n    condition := func(a, b, c Point2D) bool {\n        return Add(Add(a, b), c) == Add(a, b)\n    } \n```", "```go\n err := quick.Check(condition, &quick.Config{MaxCount: N})\n    if err != nil {\n        t.Errorf(\"Error: %v\", err)\n    }\n} \n```", "```go\n$ go test -v *.go\n=== RUN   TestWithItself\n--- PASS: TestWithItself (0.86s) \n```", "```go\n=== RUN   TestThree\n    quickT_test.go:28: Error: #1: failed on input quickT.Point2D{X:-8079189616506550499, Y:-6176385978113309642}, quickT.Point2D{X:9017849222923794558, Y:-7161977443830767080}, quickT.Point2D{X:-714979330681957566, Y:-4578147860393889265}\n--- FAIL: TestThree (0.00s)\nFAIL\nFAIL    command-line-arguments  0.618s\nFAIL \n```", "```go\n$ go test -v *.go -timeout 1s -count 2\n=== RUN   TestWithItself\n--- PASS: TestWithItself (0.87s)\n=== RUN   TestThree\n    quickT_test.go:28: Error: #1: failed on input quickT.Point2D{X:-312047170140227400, Y:-5441930920566042029}, quickT.Point2D{X:7855449254220087092, Y:7437813460700902767}, quickT.Point2D{X:4838605758154930957, Y:-7621852714243790655}\n--- FAIL: TestThree (0.00s)\n=== RUN   TestWithItself\npanic: test timed out after 1s \n```", "```go\npackage server\nvar DATA = map[string]string{}\nfunc init() {\n    DATA[\"server\"] = \"127.0.0.1\"\n} \n```", "```go\npackage server\nimport (\n    \"testing\"\n)\nfunc TestMap(t *testing.T) {\n    key := \"server\"\n    server, ok := DATA[key]\n    if !ok {\n        t.Fatalf(\"Key %s not found!\", key)\n    }\n    key = \"port\"\n    port, ok := DATA[key]\n    if !ok {\n        t.Fatalf(\"Key %s not found!\", key)\n    }\n    t.Log(\"Connecting to\", server, \"@port\", port)\n} \n```", "```go\n$ go test -v *.go\n=== RUN   TestMap\n    code_test.go:17: Key port not found!\n--- FAIL: TestMap (0.00s)\nFAIL\nFAIL    command-line-arguments    0.412s\nFAIL \n```", "```go\npackage division\nfunc intDiv(a, b int) int {\n    return a / b\n}\nfunc floatDiv(a, b int) float64 {\n    return float64(a) / float64(b)\n} \n```", "```go\npackage division\nimport (\n    \"testing\"\n)\ntype myTest struct {\n    a        int\n    b        int\n    resInt   int\n    resFloat float64\n}\nvar tests = []myTest{\n    {a: 1, b: 2, resInt: 0, resFloat: 0.5},\n    {a: 5, b: 10, resInt: 0, resFloat: 0.5},\n    {a: 2, b: 2, resInt: 1, resFloat: 1.0},\n    {a: 4, b: 2, resInt: 2, resFloat: 2.0},\n    {a: 5, b: 2, resInt: 2, resFloat: 2.5},\n    {a: 5, b: 4, resInt: 1, resFloat: 1.2},\n} \n```", "```go\nfunc TestAll(t *testing.T) {\n    t.Parallel()\n    for _, test := range tests {\n        intResult := intDiv(test.a, test.b)\n        if intResult != test.resInt {\n            t.Errorf(\"Expected %d, got %d\", test.resInt, intResult)\n        }\n        floatResult := floatDiv(test.a, test.b)\n        if floatResult != test.resFloat {\n            t.Errorf(\"Expected %f, got %f\", test.resFloat, floatResult)\n        }\n    }\n} \n```", "```go\n$ go test -v *.go\n=== RUN   TestAll\n    table_test.go:33: Expected 1.200000, got 1.250000\n--- FAIL: TestAll (0.00s)\nFAIL\nFAIL    command-line-arguments    0.332s\nFAIL \n```", "```go\npackage coverage\nimport \"fmt\"\nfunc f1() {\n    if true {\n        fmt.Println(\"Hello!\")\n    } else {\n        fmt.Println(\"Hi!\")\n    }\n} \n```", "```go\nfunc f2(n int) int {\n    if n >= 0 {\n        return 0\n    } else if n == 1 {\n        return 1\n    } else {\n        return f2(n-1) + f2(n-2)\n    }\n} \n```", "```go\npackage coverage\nimport \"testing\"\nfunc Test_f1(t *testing.T) {\n    f1()\n} \n```", "```go\nfunc Test_f2(t *testing.T) {\n    _ = f2(123)\n} \n```", "```go\n$ go test -cover *.go\nok    command-line-arguments    0.420s    coverage: 50.0% of statements \n```", "```go\n$ go test -coverprofile=coverage.out *.go \n```", "```go\n$ cat coverage.out\nmode: set\n~/go/src/github.com/mGo4th/ch12/coverage/coverage.go:5.11,6.10 1 1\n~/go/src/github.com/mactsouk/mGo4th/ch12/coverage/coverage.go:6.10,8.3 1 1\n~/go/src/github.com/mactsouk/mGo4th/ch12/coverage/coverage.go:8.8,10.3 1 0\n~/go/src/github.com/mactsouk/mGo4th/ch12/coverage/coverage.go:13.20,14.12 1 1\n~/go/src/github.com/mactsouk/mGo4th/ch12/coverage/coverage.go:14.12,16.3 1 1\n~/go/src/github.com/mactsouk/mGo4th/ch12/coverage/coverage.go:16.8,16.19 1 0\n~/go/src/github.com/mactsouk/mGo4th/ch12/coverage/coverage.go:16.19,18.3 1 0\n~/go/src/github.com/mactsouk/mGo4th/ch12/coverage/coverage.go:18.8,20.3 1 0 \n```", "```go\nfunc S2() {\n    return\n    fmt.Println(\"Hello!\")\n} \n```", "```go\nfunc S1() {\n    fmt.Println(\"In S1()\")\n    return\n    fmt.Println(\"Leaving S1()\")\n} \n```", "```go\n$ go vet cannotReach.go\n# command-line-arguments\n./cannotReach.go:9:2: unreachable code\n./cannotReach.go:16:2: unreachable code \n```", "```go\npackage main\nimport (\n    \"bytes\"\n\"net/http\"\n\"net/http/httptest\"\n\"strconv\"\n\"strings\"\n\"testing\"\n\"time\"\n\"github.com/gorilla/mux\"\n) \n```", "```go\nfunc TestTimeHandler(t *testing.T) {\n    req, err := http.NewRequest(\"GET\", \"/time\", nil)\n    if err != nil {\n        t.Fatal(err)\n    }\n    rr := httptest.NewRecorder()\n    handler := http.HandlerFunc(TimeHandler)\n    handler.ServeHTTP(rr, req)\n    status := rr.Code\n    if status != http.StatusOK {\n        t.Errorf(\"handler returned wrong status code: got %v want %v\",\n            status, http.StatusOK)\n    }\n} \n```", "```go\nfunc TestMethodNotAllowed(t *testing.T) {\n    req, err := http.NewRequest(\"DELETE\", \"/time\", nil)\n    if err != nil {\n        t.Fatal(err)\n    }\n    rr := httptest.NewRecorder()\n    handler := http.HandlerFunc(MethodNotAllowedHandler) \n```", "```go\n handler.ServeHTTP(rr, req)\n    status := rr.Code\n    if status != http.StatusNotFound {\n        t.Errorf(\"handler returned wrong status code: got %v want %v\",\n            status, http.StatusOK)\n    }\n} \n```", "```go\nfunc TestLogin(t *testing.T) {\n    UserPass := []byte(`{\"Username\": \"admin\", \"Password\": \"admin\"}`) \n```", "```go\n req, err := http.NewRequest(\"POST\", \"/login\", bytes.NewBuffer(UserPass))\n    if err != nil {\n        t.Fatal(err)\n    }\n    req.Header.Set(\"Content-Type\", \"application/json\") \n```", "```go\n rr := httptest.NewRecorder()\n    handler := http.HandlerFunc(LoginHandler)\n    handler.ServeHTTP(rr, req) \n```", "```go\n status := rr.Code\n    if status != http.StatusOK {\n        t.Errorf(\"handler returned wrong status code: got %v want %v\",\n            status, http.StatusOK)\n        return\n    }\n} \n```", "```go\nfunc TestAdd(t *testing.T) {\n    now := int(time.Now().Unix())\n    username := \"test_\" + strconv.Itoa(now)\n    users := `[{\"Username\": \"admin\", \"Password\": \"admin\"}, {\"Username\":\"` + username + `\", \"Password\": \"myPass\"}]` \n```", "```go\n UserPass := []byte(users)\n    req, err := http.NewRequest(\"POST\", \"/add\", bytes.NewBuffer(UserPass))\n    if err != nil {\n        t.Fatal(err)\n    }\n    req.Header.Set(\"Content-Type\", \"application/json\") \n```", "```go\n rr := httptest.NewRecorder()\n    handler := http.HandlerFunc(AddHandler)\n    handler.ServeHTTP(rr, req)\n    // Check the HTTP status code is what we expect.\nif status := rr.Code; status != http.StatusOK {\n        t.Errorf(\"handler returned wrong status code: got %v want %v\",\n            status, http.StatusOK)\n        return\n    }\n} \n```", "```go\nfunc TestGetUserDataHandler(t *testing.T) {\n    UserPass := []byte(`{\"Username\": \"admin\", \"Password\": \"admin\"}`)\n    req, err := http.NewRequest(\"GET\", \"/username/1\", bytes.NewBuffer(UserPass)) \n```", "```go\n if err != nil {\n        t.Fatal(err)\n    }\n    req.Header.Set(\"Content-Type\", \"application/json\")\n    vars := map[string]string{\n        \"id\": \"1\",\n    }\n    req = mux.SetURLVars(req, vars) \n```", "```go\n rr := httptest.NewRecorder()\n    handler := http.HandlerFunc(GetUserDataHandler)\n    handler.ServeHTTP(rr, req)\n    if status := rr.Code; status != http.StatusOK {\n        t.Errorf(\"handler returned wrong status code: got %v want %v\",\n            status, http.StatusOK)\n        return\n    }\nexpected := `{\"id\":1,\"username\":\"admin\",\"password\":\"admin\",\n\"lastlogin\":1702577035,\"admin\":1,\"active\":0}` \n```", "```go\n serverResponse = strings.TrimSpace(serverResponse) \n```", "```go\n if serverResponse != expected {\n        t.Errorf(\"handler returned unexpected body: got %v but wanted %v\", serverResponse, expected)\n    }\n} \n```", "```go\n$ go test -v server_test.go main.go handlers.go restdb.go \n=== RUN   TestTimeHandler\n2023/12/14 22:12:30 TimeHandler Serving: /time from\n--- PASS: TestTimeHandler (0.00s)\n=== RUN   TestMethodNotAllowed\n2023/12/14 22:12:30 Serving: /time from  with method DELETE\n--- PASS: TestMethodNotAllowed (0.00s)\n=== RUN   TestLogin \n```", "```go\n2023/12/14 22:12:30 LoginHandler Serving: /login from\n2023/12/14 22:12:30 Input user: {0 admin admin 0 0 0}\n2023/12/14 22:12:30 Found user: {1 admin admin 1702577035 1 0}\n2023/12/14 22:12:30 Logging in: {1 admin admin 1702577035 1 0}\n2023/12/14 22:12:30 Updating user: {1 admin admin 1702577825 1 1}\n2023/12/14 22:12:30 Affected: 1\n2023/12/14 22:12:30 User updated: {1 admin admin 1702577728 1 1}\n--- PASS: TestLogin (0.00s) \n```", "```go\n=== RUN   TestLogout\n2023/12/14 22:12:30 LogoutHandler Serving: /logout from\n2023/12/14 22:12:30 Found user: {1 admin admin 1702577035 1 1}\n2023/12/14 22:12:30 Logging out: admin\n2023/12/14 22:12:30 Updating user: {1 admin admin 1702577035 1 0}\n2023/12/14 22:12:30 Affected: 1\n2023/12/14 22:12:30 User updated: {1 admin admin 1702577035 1 0}\n--- PASS: TestLogout (0.00s) \n```", "```go\n=== RUN   TestAdd\n2023/12/14 22:12:30 AddHandler Serving: /add from\n2023/12/14 22:12:30 [{0 admin admin 0 0 0} {0 test_1702577728 myPass 0 0 0}] \n```", "```go\n--- PASS: TestAdd (0.00s)\n=== RUN   TestGetUserDataHandler\n2023/12/14 22:12:30 GetUserDataHandler Serving: /username/1 from\n2023/12/14 22:12:30 Found user: {1 admin admin 1702577035 1 0}\n--- PASS: TestGetUserDataHandler (0.00s)\nPASS\nok    command-line-arguments    0.329s \n```", "```go\n$ go install golang.org/x/vuln/cmd/govulncheck@latest\n$ cd ~/go/bin\n$ ls -lh govulncheck\n-rwxr-xr-x@ 1 mtsouk  staff    11M Dec  9 19:41 govulncheck \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"golang.org/x/text/language\"\n)\nfunc main() {\n    greece := language.Make(\"el\")\n    en := language.Make(\"en\")\n    fmt.Println(greece.Region())\n    fmt.Println(en.Region())\n} \n```", "```go\n$ go mod init\n$ go mod tidy\ngo: finding module for package golang.org/x/text/language\ngo: downloading golang.org/x/text v0.14.0\ngo: found golang.org/x/text/language in golang.org/x/text v0.14.0 \n```", "```go\n$ cat go.mod\nmodule github.com/mactsouk/mGo4th/ch12/vulcheck\ngo 1.21.5\nrequire golang.org/x/text v0.14.0 \n```", "```go\n$ ~/go/bin/govulncheck ./...\nScanning your code and 47 packages across 1 dependent module for known vulnerabilities...\nNo vulnerabilities found.\nShare feedback at https://go.dev/s/govulncheck-feedback \n```", "```go\n$ go get golang.org/x/text@v0.3.5\ngo: downloading golang.org/x/text v0.3.5\ngo: downgraded golang.org/x/text v0.14.0 => v0.3.5 \n```", "```go\nmodule github.com/mactsouk/mGo4th/ch12/vulcheck\ngo 1.21.5\nrequire golang.org/x/text v0.3.5 \n```", "```go\n$ ~/go/bin/govulncheck ./...\nScanning your code and 47 packages across 1 dependent module for known vulnerabilities...\n=== Informational ===\nFound 2 vulnerabilities in packages that you import, but there are no call\nstacks leading to the use of these vulnerabilities. You may not need to\ntake any action. See https://pkg.go.dev/golang.org/x/vuln/cmd/govulncheck\nfor details.\nVulnerability #1: GO-2022-1059\n    Denial of service via crafted Accept-Language header in\n    golang.org/x/text/language\n  More info: https://pkg.go.dev/vuln/GO-2022-1059\n  Module: golang.org/x/text\n    Found in: golang.org/x/text@v0.3.5\n    Fixed in: golang.org/x/text@v0.3.8\nVulnerability #2: GO-2021-0113\n    Out-of-bounds read in golang.org/x/text/language\n  More info: https://pkg.go.dev/vuln/GO-2021-0113\n  Module: golang.org/x/text\n    Found in: golang.org/x/text@v0.3.5\n    Fixed in: golang.org/x/text@v0.3.7\nNo vulnerabilities found.\nShare feedback at https://go.dev/s/govulncheck-feedback \n```", "```go\n$ go get golang.org/x/text@latest\ngo: upgraded golang.org/x/text v0.3.5 => v0.14.0 \n```", "```go\n$ ~/go/bin/govulncheck -json ./...\n{\n  \"config\": {\n    \"protocol_version\": \"v1.0.0\",\n    \"scanner_name\": \"govulncheck\",\n    \"scanner_version\": \"v1.0.1\",\n    \"db\": \"https://vuln.go.dev\",\n    \"db_last_modified\": \"2023-12-11T21:16:41Z\",\n    \"go_version\": \"go1.21.5\",\n    \"scan_level\": \"symbol\"\n  }\n}\n{\n  \"progress\": {\n    \"message\": \"Scanning your code and 47 packages across 1 dependent module for known vulnerabilities...\"\n  }\n} \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"runtime\"\n)\nfunc main() {\n    fmt.Print(\"You are using \", runtime.GOOS, \" \")\n    fmt.Println(\"on a(n)\", runtime.GOARCH, \"machine\")\n    fmt.Println(\"with Go version\", runtime.Version())\n} \n```", "```go\n$ go run crossCompile.go\nYou are using darwin on a(n) arm64 machine\nwith Go version go1.21.5 \n```", "```go\n$ env GOOS=linux GOARCH=amd64 go build crossCompile.go\n$ file crossCompile\ncrossCompile: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, Go BuildID=28hWIc2cet8-kmHxC-W6/Y7DEXRrm3CrFgqVvflBA/KWqCcnUNgUozkElJHidj/Geqp0vSmfLgkLrZ_-7cX, with debug_info, not stripped \n```", "```go\n$ ./crossCompile \nYou are using linux on a(n) amd64 machine\nwith Go version go1.21.5 \n```", "```go\npackage main\nimport \"fmt\"\n//go:generate ./echo.sh \n```", "```go\n//go:generate echo GOFILE: $GOFILE\n//go:generate echo GOARCH: $GOARCH\n//go:generate echo GOOS: $GOOS\n//go:generate echo GOLINE: $GOLINE\n//go:generate echo GOPACKAGE: $GOPACKAGE \n```", "```go\n//go:generate echo DOLLAR: $DOLLAR\n//go:generate echo Hello!\n//go:generate ls -l\n//go:generate ./hello.py \n```", "```go\nfunc main() {\n    fmt.Println(\"Hello there!\")\n} \n```", "```go\n$ go mod init\n$ go mod tidy\n$ go generate\nHello world!\nGOFILE: goGenerate.go\nGOARCH: arm64\nGOOS: darwin\nGOLINE: 10\nGOPACKAGE: main \n```", "```go\nDOLLAR: $ \n```", "```go\nHello!\ntotal 32\n-rwxr-xr-x@ 1 mtsouk  staff   32 Nov 10 22:22 echo.sh\n-rw-r--r--  1 mtsouk  staff   59 Dec 14 20:25 go.mod\n-rw-r--r--@ 1 mtsouk  staff  383 Nov 10 22:22 goGenerate.go\n-rwxr-xr-x@ 1 mtsouk  staff   52 Nov 10 22:22 hello.py \n```", "```go\nHello from Python! \n```", "```go\n$ go generate -n\n./echo.sh\necho GOFILE: goGenerate.go\necho GOARCH: arm64\necho GOOS: darwin\necho GOLINE: 10\necho GOPACKAGE: main\necho DOLLAR: $\necho Hello!\nls -l\n./hello.py \n```", "```go\npackage exampleFunctions\nfunc LengthRange(s string) int {\n    i := 0\nfor _, _ = range s {\n        i = i + 1\n    }\n    return i\n} \n```", "```go\npackage exampleFunctions\nimport \"fmt\"\nfunc ExampleLengthRange() {\n    fmt.Println(LengthRange(\"Mihalis\"))\n    fmt.Println(LengthRange(\"Mastering Go, 4th edition!\"))\n    // Output:\n// 7\n// 7\n} \n```", "```go\n$ go test -v exampleFunctions*\n=== RUN   ExampleLengthRange\n--- FAIL: ExampleLengthRange (0.00s)\ngot:\n7\n26\nwant:\n7\n7\nFAIL\nFAIL    command-line-arguments  0.410s\nFAIL \n```", "```go\n$ go test -v exampleFunctions*\n=== RUN   ExampleLengthRange\n--- PASS: ExampleLengthRange (0.00s)\nPASS\nok      command-line-arguments  0.572s \n```"]