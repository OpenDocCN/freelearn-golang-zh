- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Code Testing and Profiling
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码测试和分析
- en: Programming is both an art and a science, and as such, it needs tools that help
    the developer generate better software and understand why some aspects of their
    code do not work as expected. This chapter primarily addresses code testing and
    code profiling with the Go programming language. The provided code profiling tools
    are about improving the performance of Go programs by finding and understanding
    bottlenecks and discovering bugs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 编程既是艺术也是科学，因此它需要帮助开发者生成更好的软件并理解为什么他们的代码的一些方面没有按预期工作的工具。本章主要讨论使用 Go 编程语言进行代码测试和代码分析。提供的代码分析工具旨在通过找到并理解瓶颈以及发现错误来提高
    Go 程序的性能。
- en: '*Code optimization* is the process where one or more developers try to make
    certain parts of a program run faster, be more efficient, or use fewer resources.
    Put simply, code optimization is about eliminating the bottlenecks of a program
    where and when it matters. The discussion about code optimization is going to
    continue in *Chapter 14*, *Efficiency and Performance*, where we talk about benchmarking
    code.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码优化* 是一个过程，其中一个或多个开发者试图使程序中的一些部分运行得更快、更高效或使用更少的资源。简单来说，代码优化就是消除程序在需要时和需要的地方的瓶颈。关于代码优化的讨论将在
    *第14章*，*效率和性能* 中继续，我们将讨论代码基准测试。'
- en: '*Code testing* is about making sure that your code does what you want it to
    do. In this chapter, we are experiencing the Go way of code testing. The best
    time to write test code is during development, as this can help to reveal bugs
    in the code as early as possible. *Code profiling* relates to measuring certain
    aspects of a program to get a detailed understanding of the way the code works.
    The results of code profiling may help you to decide which parts of your code
    need to change.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码测试* 是确保你的代码做你想让它做的事情。在本章中，我们体验了 Go 的代码测试方式。编写测试代码的最佳时机是在开发过程中，因为这可以帮助尽早揭示代码中的错误。*代码分析*
    与测量程序的一些方面以获得代码工作方式的详细理解相关。代码分析的结果可以帮助你决定哪些代码部分需要更改。'
- en: Keep in mind that when writing code, we should focus on its correctness as well
    as other desirable properties, such as readability, simplicity, and maintainability,
    not its performance. Once we are sure that the code is correct, then we might
    need to focus on its performance. A good trick for performance is to execute the
    code on machines that are a bit slower than the ones that are going to be used
    in production.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在编写代码时，我们应该关注其正确性以及其他期望的特性，如可读性、简单性和可维护性，而不是其性能。一旦我们确信代码是正确的，那么我们可能需要关注其性能。一个提高性能的好技巧是在比生产环境中将要使用的机器慢一点的机器上执行代码。
- en: 'This chapter covers:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖：
- en: Optimizing code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化代码
- en: Rewriting the `main()` function for better testing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为更好的测试重写 `main()` 函数
- en: Profiling code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码分析
- en: The `go tool trace` utility
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go tool trace` 工具'
- en: Tracing a web server
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪网络服务器
- en: Testing Go code
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 Go 代码
- en: The `govulncheck` tool
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`govulncheck` 工具'
- en: Cross-compilation
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交叉编译
- en: Using `go:generate`
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `go:generate`
- en: Creating example functions
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建示例函数
- en: Optimizing code
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化代码
- en: 'Code optimization is both an art and a science. This means that there is no
    deterministic way to help you optimize your code and that you should use your
    brain and try many things, algorithms and techniques, if you want to make your
    code faster. However, the general principle regarding code optimization is **first
    make it correct, then make it fast**. Always remember what Donald Knuth said about
    optimization:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 代码优化既是艺术也是科学。这意味着没有确定性的方法可以帮助你优化代码，而且如果你想使代码更快，你应该用你的大脑尝试很多事情，算法和技术。然而，关于代码优化的普遍原则是
    **首先确保它正确，然后让它变得快速**。始终记住 Donald Knuth 关于优化的说法：
- en: ”The real problem is that programmers have spent far too much time worrying
    about efficiency in the wrong places and at the wrong times; premature optimization
    is the root of all evil (or at least most of it) in programming.”
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “真正的问题是程序员在错误的地方和错误的时间花费了太多的时间担心效率；过早的优化是编程中所有邪恶（至少是大部分）的根源。”
- en: 'Also, remember what the late Joe Armstrong, one of the developers of Erlang,
    said about optimization:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，记住已故的 Joe Armstrong（Erlang 的一位开发者）关于优化的说法：
- en: ”Make it work, then make it beautiful, then if you really, really have to, make
    it fast. 90 percent of the time, if you make it beautiful, it will already be
    fast. So really, just make it beautiful!”
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “先让它工作，然后让它变得美观，然后如果你真的、真的必须，再让它变得快速。90% 的时间，如果你让它变得美观，它已经足够快了。所以，实际上，只需让它变得美观！”
- en: Code testing helps you make your program work correctly and code profiling reveals
    bottlenecks.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 代码测试帮助你确保程序正确运行，代码剖析揭示了瓶颈。
- en: 'If you are really into code optimization, you might want to read *Compilers:
    Principles, Techniques, and Tools,* by Alfred V. Aho, Monica S. Lam, Ravi Sethi,
    and Jeffrey D. Ullman (Pearson Education Limited, 2014), which focuses on compiler
    construction. Additionally, all volumes in the *The Art of Computer Programming*
    series by Donald Knuth (Addison-Wesley Professional, 1998) are great resources
    for all aspects of programming if you have the time to read them.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你真的很喜欢代码优化，你可能想阅读 Alfred V. Aho、Monica S. Lam、Ravi Sethi 和 Jeffrey D. Ullman
    所著的 *Compilers: Principles, Techniques, and Tools*（Pearson Education Limited，2014），这本书专注于编译器构造。此外，如果你有时间阅读，Donald
    Knuth 的 *The Art of Computer Programming* 系列的所有卷都是编程各个方面的极好资源。'
- en: The next section shows a technique for rewriting `main()` to make testing easier.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将展示一种重新编写 `main()` 以便更容易进行测试的技术。
- en: Rewriting the main() function for better testing
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新编写 main() 函数以更好地进行测试
- en: There exists a clever way that you can rewrite each `main()` function in order
    to make testing (and benchmarking) a lot easier. The `main()` function has a restriction,
    which is that you cannot call it from test code—this technique presents a solution
    to that problem using the code found in `main.go`. The `import` block is omitted
    to save space.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种巧妙的方法可以重新编写每个 `main()` 函数，以便使测试（和基准测试）变得容易得多。`main()` 函数有一个限制，即你不能从测试代码中调用它——这个技术通过
    `main.go` 中的代码提供了一个解决方案。为了节省空间，省略了 `import` 块。
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As we cannot have an executable program without a `main()` function, we have
    to create a minimalistic one. What `main()` does is call `run()`, which is our
    own customized version of `main()`, send the desired `os.Args` to it, and collect
    the return value of `run()`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有 `main()` 函数就无法有一个可执行程序，我们必须创建一个最小化的 `main()`。`main()` 做的事情是调用 `run()`，这是我们自己的定制版本的
    `main()`，向它发送所需的 `os.Args`，并收集 `run()` 的返回值：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As discussed before, the `run()` function, or any other function that is called
    by `main()` in the same way, provides a new top-level, root-type function like
    `main()` with the additional benefit of being able to be called by test functions.
    Put simply, the `run()` function contains the code that would have been located
    in `main()`—the only difference is that `run()` returns an `error` variable, which
    is not possible with `main()`, which can only return exit codes to the operating
    system when used with `os.Exit()`. You might say that this creates a slightly
    bigger stack because of the extra function call but the benefits are far more
    important than the added memory usage. Although, technically, both parameters
    of `run()` can be removed as they are globally available by default, passing these
    two parameters explicitly allows the programmer to pass other values during testing.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`run()` 函数，或者以相同方式由 `main()` 调用的任何其他函数，提供了一个新的顶级、根类型函数，类似于 `main()`，并且具有额外的优势，即可以被测试函数调用。简单来说，`run()`
    函数包含了原本位于 `main()` 中的代码——唯一的区别是 `run()` 返回一个 `error` 变量，而 `main()` 在使用 `os.Exit()`
    时只能返回退出码到操作系统。你可能会说，这因为额外的函数调用而稍微增加了栈的大小，但好处远比增加的内存使用更重要。尽管技术上，`run()` 的两个参数都可以被移除，因为它们默认情况下是全局可用的，但显式传递这两个参数允许程序员在测试期间传递其他值。
- en: 'Running `main.go` produces the next output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `main.go` 产生以下输出：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There is nothing special in the way `main.go` operates. The good thing is that
    you can call `run()` from anywhere you want, including the code you write for
    testing, and pass the desired parameters to `run()`! It is good to have that technique
    in mind because it might save you when you want to write tests for a program with
    certain command line arguments or other input.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.go` 的操作方式并没有什么特别之处。好事是你可以从任何你想的地方调用 `run()`，包括你为测试编写的代码，并将所需的参数传递给 `run()`！记住这个技巧是好的，因为它可能会在你想要为具有特定命令行参数或其他输入的程序编写测试时救你一命。'
- en: The next section is about profiling Go code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将介绍 Go 代码的剖析。
- en: Profiling code
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 剖析代码
- en: Profiling is a process of dynamic program analysis that measures various values
    related to program execution to give you a better understanding of the program
    behavior. In this section, we are going to learn how to profile Go code to understand
    it better, which can be used to improve its performance. Sometimes, code profiling
    can even reveal bugs in the code, such as endless loops or functions that never
    return. However, profiling would be better for memory leak bugs and things of
    that nature.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 分析是一个动态程序分析的过程，它测量与程序执行相关的各种值，以帮助你更好地理解程序的行为。在本节中，我们将学习如何分析 Go 代码以更好地理解它，这可以用来提高其性能。有时，代码分析甚至可以揭示代码中的错误，例如无限循环或永不返回的函数。然而，对于内存泄漏错误和类似的问题，分析会更好。
- en: The `runtime/pprof` standard Go package is used for profiling all kinds of applications
    apart from HTTP servers. The high-level `net/http/pprof` package should be used
    when you want to profile a web application. What `net/http/pprof` does is provide
    HTTP endpoints for profiling data, which means that it can also be used for any
    long-running application. You can see the help page of the `pprof` tool by executing
    `go tool pprof -help`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`runtime/pprof` 是一个标准的 Go 包，用于分析除 HTTP 服务器之外的各种应用程序。当你想要分析一个 Web 应用程序时，应该使用高级的
    `net/http/pprof` 包。`net/http/pprof` 所做的是提供用于分析数据的 HTTP 端点，这意味着它也可以用于任何长时间运行的应用程序。你可以通过执行
    `go tool pprof -help` 来查看 `pprof` 工具的帮助页面。'
- en: This next subsection is going to illustrate how to profile a command line application,
    and the following subsection shows the profiling of an HTTP server.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将说明如何分析一个命令行应用程序，接下来的子节将展示 HTTP 服务器的分析。
- en: Profiling a command line application
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析命令行应用程序
- en: 'The code of the application is saved as `profileCla.go` and collects CPU and
    memory profiling data. What is interesting is the implementation of `main()` because
    this is where the collection of the profiling data takes place:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的代码保存为 `profileCla.go` 并收集 CPU 和内存分析数据。有趣的是 `main()` 的实现，因为这是分析数据收集发生的地方：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The previous code is about collecting CPU profiling data. `pprof.StartCPUProfile()`
    starts collecting data, which is stopped with the `pprof.StopCPUProfile()` call.
    All data is saved into a file named `cpuProfileCla.out` under the `os.TempDir()`
    directory—the value returned by `os.TempDir()` depends on the OS used and makes
    the code portable. The use of `defer` means that `pprof.StopCPUProfile()` is going
    to get called just before `main()` exits—if you want to stop data collection at
    another point, you should put the `pprof.StopCPUProfile()` call at the desired
    place.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码是关于收集 CPU 分析数据的。`pprof.StartCPUProfile()` 开始收集数据，通过 `pprof.StopCPUProfile()`
    调用来停止。所有数据都保存在 `os.TempDir()` 目录下的一个名为 `cpuProfileCla.out` 的文件中——`os.TempDir()`
    返回的值取决于所使用的操作系统，这使得代码具有可移植性。使用 `defer` 的意思是 `pprof.StopCPUProfile()` 将在 `main()`
    函数退出之前被调用——如果你想在另一个点停止数据收集，你应该将 `pprof.StopCPUProfile()` 调用放在期望的位置。
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All the previous code performs lots of CPU-intensive calculations for the CPU
    profiler to have data to collect—this is where your actual code usually goes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前序代码都进行了大量的 CPU 密集型计算，以便 CPU 分析器有数据可以收集——这通常是你的实际代码所在的位置。
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After the CPU-intensive code, we are going to put code that uses lots of memory.
    For that, we create a second file named `memoryFilename` for collecting memory-related
    profiling data.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CPU 密集型代码之后，我们将放置使用大量内存的代码。为此，我们创建了一个名为 `memoryFilename` 的第二个文件，用于收集与内存相关的分析数据。
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `pprof.WriteHeapProfile()` function writes the memory data into the specified
    file. Once again, we allocate lots of memory for the memory profiler to have data
    to collect.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`pprof.WriteHeapProfile()` 函数将内存数据写入指定的文件。再一次，我们分配了大量的内存，以便内存分析器有数据可以收集。'
- en: Running `profileCla.go` using `go run` is going to create two files in the folder
    returned by `os.TempDir()`—usually, we move them into a different folder. Feel
    free to change the code of `profileCla.go` and put the profiling files in a different
    place.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `go run` 运行 `profileCla.go` 将在 `os.TempDir()` 返回的文件夹中创建两个文件——通常，我们会将它们移动到另一个文件夹中。你可以随意修改
    `profileCla.go` 的代码，并将分析文件放在不同的位置。
- en: In my case, running on a macOS Sonoma machine, the temporary directory is going
    to be `/var/folders/sk/ltk8cnw50lzdtr2hxcj5sv2m0000gn/T/`. So, I am going to move
    the `cpuProfileCla.out` and `memoryProfileCla.out` files from there into the `ch12`
    directory—you are not going to be able to find them because the `.gitignore` file
    of the GitHub repository of the book ignores both of them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，在 macOS Sonoma 机器上运行，临时目录将是 `/var/folders/sk/ltk8cnw50lzdtr2hxcj5sv2m0000gn/T/`。因此，我将把
    `cpuProfileCla.out` 和 `memoryProfileCla.out` 文件从那里移动到 `ch12` 目录中——你将找不到它们，因为书籍的
    GitHub 仓库的 `.gitignore` 文件忽略了这两个文件。
- en: 'So, what do we do next? We should use `go tool pprof` to process these two
    files:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们接下来做什么？我们应该使用 `go tool pprof` 来处理这两个文件：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `top` command returns a summary of the top 10 entries.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`top` 命令返回前 10 个条目的摘要。'
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `top10 –cum` command returns the cumulative time for each function.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`top10 –cum` 命令返回每个函数的累积时间。'
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Last, the `list` command shows information about a given function. The previous
    output shows that the `if (n % i) == 0` statement is responsible for all the time
    it takes `N1()` to run!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`list` 命令显示有关给定函数的信息。之前的输出显示 `if (n % i) == 0` 语句是 `N1()` 运行所需所有时间的责任！
- en: Try the profile commands on your own in your own code to see their full output.
    Visit [https://go.dev/blog/pprof](https://go.dev/blog/pprof) from the Go blog
    to learn more about profiling.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在你自己的代码中尝试这些分析命令，以查看它们的完整输出。访问 [https://go.dev/blog/pprof](https://go.dev/blog/pprof)
    以了解有关分析更多的信息。
- en: You can also create PDF output of the profiling data from the shell of the Go
    profiler using the `pdf` command. Personally, most of the time, I begin with this
    command because it gives me a rich and clear overview of the collected data.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 Go 分析器的 shell 通过 `pdf` 命令创建分析数据的 PDF 输出。我个人大多数时候都是从这个命令开始的，因为它给了我一个丰富且清晰的收集数据的概览。
- en: Now, let us discuss how to profile an HTTP server, which is the subject of the
    next subsection.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论如何分析 HTTP 服务器，这是下一小节的主题。
- en: Profiling an HTTP server
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析 HTTP 服务器
- en: As discussed, the `net/http/pprof` package should be used when you want to collect
    profiling data for a Go application that runs an HTTP server or any other long-running
    program where you want to periodically collect profiling data. To that end, importing
    `net/http/pprof` installs various handlers under the `/debug/pprof/` path. You
    are going to see more on this in a short while.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当你要为运行 HTTP 服务器或任何其他需要定期收集分析数据的长时间运行程序收集 Go 应用程序的分析数据时，应该使用 `net/http/pprof`
    包。为此，导入 `net/http/pprof` 在 `/debug/pprof/` 路径下安装了各种处理程序。你很快就会看到更多关于这个的内容。
- en: 'The technique is illustrated in `profileHTTP.go`, which comes with the following
    code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术在 `profileHTTP.go` 中得到了展示，其中包含以下代码：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As discussed earlier, you should import the `net/http/pprof` package. However,
    although `net/http/pprof` is imported, it is not used directly. The import is
    for the side effects of registering the HTTP handlers, as explained in [https://pkg.go.dev/net/http/pprof](https://pkg.go.dev/net/http/pprof).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你应该导入 `net/http/pprof` 包。然而，尽管导入了 `net/http/pprof`，但它并没有直接使用。导入是为了注册 HTTP
    处理程序的副作用，如 [https://pkg.go.dev/net/http/pprof](https://pkg.go.dev/net/http/pprof)
    中所述。
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The previous two functions implement two handlers that are going to be used
    in our naïve HTTP server. `myHandler()` is the default handler function, whereas
    `timeHandler()` returns the current time and date on the server.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个函数实现了将要在我们简单的 HTTP 服务器中使用的两个处理程序。`myHandler()` 是默认的处理程序函数，而 `timeHandler()`
    返回服务器上的当前时间和日期。
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Up to this point, there is nothing special as we just register the handler functions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，并没有什么特别之处，因为我们只是注册了处理程序函数。
- en: All of the previous statements install the handlers for the HTTP profiler—you
    can access them using the hostname and port number of the web server. You do not
    have to use all handlers.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的先前声明都为 HTTP 分析器安装了处理程序——你可以使用 Web 服务器的主机名和端口号来访问它们。你不必使用所有处理程序。
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Last, you start the HTTP server as usual.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你像往常一样启动 HTTP 服务器。
- en: 'What is next? First, you run the HTTP server (`go run profileHTTP.go`). After
    that, you run the next command **in a different terminal window** to collect profiling
    data while interacting with the HTTP server:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是什么？首先，你运行 HTTP 服务器（`go run profileHTTP.go`）。然后，你在不同的终端窗口中运行下一个命令来收集与 HTTP
    服务器交互时的分析数据：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The previous output shows the initial screen of the HTTP profiler—the available
    commands are the same as when profiling a command line application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出显示了 HTTP 分析器的初始屏幕——可用的命令与分析命令行应用程序时相同。
- en: You can either exit the shell and analyze your data later using `go tool pprof`
    or continue giving profiler commands. This is the general idea behind profiling
    HTTP servers in Go.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择退出shell，稍后使用`go tool pprof`分析数据，或者继续输入分析器命令。这是在Go中分析HTTP服务器的一般思路。
- en: The next subsection discusses the web interface of the Go profiler.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节讨论了Go分析器的Web界面。
- en: The web interface of the Go profiler
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go分析器的Web界面
- en: The good news is that, starting with Go version 1.10, `go tool pprof` comes
    with a web interface that you can start as `go tool pprof -http=[host]:[port]
    aProfile.out`—do not forget to set your desired values to `-http`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，从Go版本1.10开始，`go tool pprof`自带了一个Web界面，您可以通过`go tool pprof -http=[host]:[port]
    aProfile.out`启动它——不要忘记将您希望设置的值设置为`-http`。
- en: I have executed the previous command as `go tool pprof -http=127.0.0.1:1234
    cpuProfileCla.out`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经执行了之前的命令`go tool pprof -http=127.0.0.1:1234 cpuProfileCla.out`。
- en: A part of the web interface of the profiler is seen in the next figure, which
    shows how the program execution time was spent—it is now the job of the developer
    to find out whether there is something wrong with the performance or not.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图中可以看到分析器Web界面的一部分，它显示了程序执行时间的分配情况——现在开发者需要找出性能是否存在问题。
- en: '![A screenshot of a computer  Description automatically generated](img/B21003_12_01.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图 自动生成描述](img/B21003_12_01.png)'
- en: 'Figure 12.1: The web interface of the Go profiler'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：Go分析器的Web界面
- en: Feel free to browse the web interface and see the various options and menus
    that are offered. Unfortunately, talking more about profiling is beyond the scope
    of this chapter. As always, if you are really interested in code profiling, experiment
    with it as much as possible.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 随意浏览Web界面，查看提供的各种选项和菜单。不幸的是，关于分析器的更多讨论超出了本章的范围。像往常一样，如果您真的对代码分析感兴趣，尽可能多地实验。
- en: The next section is about code tracing, which gives you information about the
    operation of the Go internals.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个章节是关于代码跟踪的，它提供了关于Go内部操作的信息。
- en: The go tool trace utility
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go工具跟踪实用程序
- en: 'Code tracing is a process that allows you to learn information such as the
    operation of the garbage collector, the lifetime of goroutines, the activity of
    each logical processor, and the number of operating system threads used. The `go
    tool trace` utility is a tool for viewing the data stored in trace files, which
    can be generated in any one of the following three ways:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 代码跟踪是一个允许您了解垃圾收集器操作、goroutine的生命周期、每个逻辑处理器的活动以及操作系统线程使用数量的过程。`go tool trace`实用程序是一个用于查看存储在跟踪文件中的数据的工具，这些数据可以通过以下三种方式中的任何一种生成：
- en: With the `runtime/trace` package
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`runtime/trace`包
- en: With the `net/http/pprof` package
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`net/http/pprof`包
- en: With the `go test -trace` command
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`go test -trace`命令
- en: 'This section illustrates the use of the first technique using the code of `traceCLA.go`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 本节通过`traceCLA.go`的代码示例说明了第一种技术的使用：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `runtime/trace` package is required for collecting all kinds of tracing
    data—there is no point in selecting specific tracing data as all tracing data
    is interconnected.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 需要使用`runtime/trace`包来收集所有种类的跟踪数据——没有选择特定跟踪数据的必要，因为所有跟踪数据都是相互关联的。
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we did for profiling, we need to create a file to store tracing data. In
    this case, the file is called `traceCLA.out` and is stored inside the temporary
    directory of your operating system.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在分析时做的那样，我们需要创建一个文件来存储跟踪数据。在这种情况下，文件名为`traceCLA.out`，并存储在您的操作系统的临时目录中。
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This part is all about acquiring data for `go tool trace`, and it has nothing
    to do with the purpose of the program. We start the tracing process using `trace.Start()`.
    When we are done, we call the `trace.Stop()` function. The `defer` call means
    that we want to terminate tracing when the `main()` function returns.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分完全是关于为`go tool trace`获取数据，它与程序的目的无关。我们使用`trace.Start()`启动跟踪过程。完成之后，我们调用`trace.Stop()`函数。`defer`调用意味着我们希望在`main()`函数返回时终止跟踪。
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'All the previous code is about allocating memory to trigger the operation of
    the garbage collector and generate more tracing data—you can learn more about
    the Go garbage collector in *Appendix A*, *Go Garbage Collector*. The program
    is executed as usual. However, when it finishes, it populates `traceCLA.out` with
    tracing data. After that, we should process the tracing data as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前一段代码都是关于分配内存以触发垃圾回收器的操作并生成更多跟踪数据的——你可以在附录A中了解更多关于Go垃圾回收器的信息，即*Go垃圾回收器*。程序会像往常一样执行。然而，当它完成后，它会将跟踪数据填充到`traceCLA.out`中。之后，我们应该按照以下方式处理跟踪数据：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The last command automatically starts a web server (`http://127.0.0.1:52829`)
    and opens the web interface of the trace tool on your default web browser—you
    can run it on your own computer to play with the web interface of the trace tool.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条命令会自动启动一个Web服务器（`http://127.0.0.1:52829`）并在你的默认Web浏览器上打开跟踪工具的Web界面——你可以在自己的电脑上运行它来玩转跟踪工具的Web界面。
- en: The `View trace` link shows information about the goroutines of your program
    and the operation of the garbage collector—if your code uses multiple goroutines,
    this is the best place to understand their behavior.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: “查看跟踪”链接显示了关于你的程序goroutines和垃圾回收器操作的信息——如果你的代码使用了多个goroutines，这是理解它们行为最好的地方。
- en: Keep in mind that although `go tool trace` is very handy and powerful, it cannot
    solve every kind of performance problem. There are times when `go tool pprof`
    is more appropriate, especially when we want to reveal where our code spends most
    of its time.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，尽管`go tool trace`非常方便且强大，但它不能解决所有类型的性能问题。有时`go tool pprof`更为合适，特别是当我们想要揭示代码大部分时间花在哪里时。
- en: As with profiling, collecting tracing data for an HTTP server is a slightly
    different process, which is explained in the next subsection.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与分析类似，收集HTTP服务器的跟踪数据是一个稍微不同的过程，这将在下一小节中解释。
- en: Tracing a web server from a client
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从客户端追踪Web服务器
- en: 'This section shows how to trace a web server application using `net/http/httptrace`.
    The package allows you to trace the phases of an HTTP request from a client. The
    code of `traceHTTP.go` that interacts with web servers is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了如何使用`net/http/httptrace`来追踪Web服务器应用程序。该包允许你追踪客户端HTTP请求的各个阶段。与Web服务器交互的`traceHTTP.go`代码如下：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As expected, we need to import `net/http/httptrace` before being able to enable
    HTTP tracing.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们需要在启用HTTP跟踪之前导入`net/http/httptrace`。
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Up to this point, we have prepared the client request to the web server as usual.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经像往常一样准备好了发送到Web服务器的客户端请求。
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding code is all about tracing HTTP requests. The `httptrace.ClientTrace`
    structure defines the events that interest us, which are `GotFirstResponseByte`,
    `GotConn`, `DNSDone`, `ConnectStart`, `ConnectDone`, and `WroteHeaders`. When
    such an event occurs, the relevant code is executed. You can find more information
    about the supported events and their purpose in the documentation of the `net/http/httptrace`
    package.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码都是关于追踪HTTP请求的。`httptrace.ClientTrace`结构体定义了我们感兴趣的事件，包括`GotFirstResponseByte`、`GotConn`、`DNSDone`、`ConnectStart`、`ConnectDone`和`WroteHeaders`。当这些事件发生时，相关的代码会被执行。你可以在`net/http/httptrace`包的文档中找到更多关于支持的事件及其目的的信息。
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `httptrace.WithClientTrace()` function returns a new context value based
    on the given parent context, while `http.DefaultTransport.RoundTrip()` wraps the
    request with the context value in order to keep track of the request.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`httptrace.WithClientTrace()`函数基于给定的父上下文返回一个新的上下文值，而`http.DefaultTransport.RoundTrip()`则将请求包装在这个上下文值中，以便跟踪请求。'
- en: Keep in mind that Go HTTP tracing has been designed to trace the events of a
    single `http.Transport.RoundTrip`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Go HTTP跟踪已经被设计来追踪单个`http.Transport.RoundTrip`的事件。
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The last part sends the client request to the server for the tracing to begin.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分将客户端请求发送到服务器以开始跟踪。
- en: 'Running `traceHTTP.go` generates the next output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`traceHTTP.go`会生成以下输出：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The previous output helps you understand the progress of the connection in more
    detail and is handy when troubleshooting. Unfortunately, talking more about tracing
    is beyond the scope of this book. The next subsection shows how to visit all the
    routes of a web server to make sure that they are properly defined.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出可以帮助你更详细地了解连接的进度，在故障排除时很有用。不幸的是，关于跟踪的更多讨论超出了本书的范围。下一小节将展示如何访问Web服务器的所有路由以确保它们被正确定义。
- en: Visiting all routes of a web server
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问Web服务器的所有路由
- en: The `gorilla/mux` package offers a `Walk()` function that can be used to visit
    all the registered routes of a router—this can be very handy when you want to
    make sure that every route is registered and is working.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`gorilla/mux` 包提供了一个 `Walk()` 函数，可以用来访问路由器注册的所有路由——当你想要确保每个路由都已注册且正常工作时，这会非常有用。'
- en: 'The code of `walkAll.go`, which contains lots of empty handler functions because
    its purpose is not to test handling functions but to visit them, is as follows
    (nothing prohibits you from using the same technique on a fully implemented web
    server):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`walkAll.go` 的代码，其中包含许多空处理函数，因为它的目的是不测试处理函数，而是访问它们，如下所示（没有任何东西禁止你在完全实现的Web服务器上使用相同的技巧）：'
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As we are using an external package, the running of `walkAll.go` should take
    place somewhere under `~/go/src`—in our case, under `./ch12/walkAll`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用外部包，`walkAll.go` 的运行应该在 `~/go/src` 下的某个位置进行——在我们的例子中，在 `./ch12/walkAll`
    下。
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This empty handler function is shared by all endpoints for reasons of simplicity.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个空处理函数出于简单起见被所有端点共享。
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `notAllowedHandler` handler also calls the `handler()` function.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`notAllowedHandler` 处理器也会调用 `handler()` 函数。'
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The previous part is about defining the routes and the HTTP methods that we
    want to support.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前一部分是关于定义我们想要支持的路线和HTTP方法。
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The previous statements illustrate how we call the `Walk()` method.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的陈述说明了我们如何调用 `Walk()` 方法。
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: For each visited route, the program collects the desired information. Feel free
    to remove some of the `fmt.Println()` calls if it does not help your purpose.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个访问的路由，程序会收集所需的信息。如果你觉得某些 `fmt.Println()` 调用没有帮助，请随意移除它们。
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'So, the general idea behind `walkAll.go` is that you assign an empty handler
    to each route that you have in your server and then you call `mux.Walk()` to visit
    all routes. Enabling Go modules and running `walkAll.go` generates the next output:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`walkAll.go` 背后的基本思想是，你为服务器中的每个路由分配一个空处理函数，然后调用 `mux.Walk()` 来访问所有路由。启用Go模块并运行
    `walkAll.go` 生成以下输出：
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The output shows the HTTP methods that each route supports as well as the format
    of the path. So, the `/time` endpoint works with `GET` and its path is `/time`
    because the value of `Path` `regexp` means that `/time` is between the beginning
    (`^`) and the end of the path (`$`).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了每个路由支持的HTTP方法以及路径的格式。因此，`/time` 端点使用 `GET` 方法，其路径是 `/time`，因为 `Path` 正则表达式的值意味着
    `/time` 在路径的开始 (`^`) 和结束 (`$`) 之间。
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the case of `/username`, the output includes the regular expressions associated
    with the endpoint that is used for selecting the value of the id variable.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `/username` 的情况下，输出包括与用于选择 id 变量值的端点相关的正则表达式。
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Although visiting the routes of a web server is a kind of testing, it is not
    the official Go way of testing. The main thing to look for in such output is the
    absence of an endpoint, the use of the wrong HTTP method, or the absence of a
    parameter from an endpoint.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然访问Web服务器的路由是一种测试方式，但它并不是官方的Go测试方式。在输出中，我们主要关注的是端点的缺失、使用错误的HTTP方法或端点参数的缺失。
- en: The next section discusses the testing of Go code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将讨论 Go 代码的测试。
- en: Testing Go code
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 Go 代码
- en: The subject of this section is the testing of Go code by **writing test functions**.
    Software testing is a very large subject and cannot be covered in a single section
    of a chapter in a book. So, this section tries to present as much practical information
    as possible.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的主题是通过编写测试函数来测试 Go 代码。软件测试是一个非常大的主题，无法在本书章节的单个部分中涵盖。因此，本节试图尽可能多地提供实用信息。
- en: Go allows you to write tests for your Go code to detect bugs. However, software
    testing can only show the presence of one or more bugs, not the absence of bugs.
    This means that you can never be 100% sure that your code contains no bugs!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Go 允许你为你的 Go 代码编写测试以检测错误。然而，软件测试只能显示一个或多个错误的存在，而不能证明没有错误。这意味着你永远不能100%确信你的代码中没有错误！
- en: Strictly speaking, this section is about automated testing, which involves writing
    extra code to verify whether the real code—that is, the production code—works
    as expected or not. Thus, the result of a test function is either `PASS` or `FAIL`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，本节是关于自动化测试，这涉及到编写额外的代码来验证实际代码——即生产代码——是否按预期工作。因此，测试函数的结果要么是 `PASS`，要么是
    `FAIL`。
- en: You will see how this works shortly. Although the Go approach to testing might
    look simple at first, especially if you compare it with the testing practices
    of other programming languages, it is very efficient and effective because it
    does not require too much of the developer’s time.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你很快就会看到它是如何工作的。虽然 Go 的测试方法一开始可能看起来很简单，特别是如果你将其与其他编程语言的测试实践进行比较，但它非常高效和有效，因为它不需要开发者太多的时间。
- en: Go follows certain conventions regarding testing (and benchmarking). The most
    important convention is that the name of a test function must begin with `Test`.
    After the `Test` word, we must put an underscore or an uppercase letter. Therefore,
    both `TestFunctionName()` and `Test_functionName()` are valid test functions,
    whereas `Testfunctionname()` is not. If you prefer idiomatic Go, then use `TestFunctionName()`.
    All such functions are put in files that end with `_test.go`. All test functions
    must have a `t *testing.T` parameter and return no values. Lastly, packages that
    contain testing code should include the `testing` package.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Go 在测试（以及基准测试）方面遵循某些约定。最重要的约定是测试函数的名称必须以 `Test` 开头。在 `Test` 词语之后，我们必须放置一个下划线或大写字母。因此，`TestFunctionName()`
    和 `Test_functionName()` 都是有效的测试函数，而 `Testfunctionname()` 则不是。如果你更喜欢 Go 的惯用法，那么请使用
    `TestFunctionName()`。所有这样的函数都放在以 `_test.go` 结尾的文件中。所有测试函数都必须有一个 `t *testing.T`
    参数，并且不返回任何值。最后，包含测试代码的包应包含 `testing` 包。
- en: Once the testing code is correct, the `go test` subcommand does all the dirty
    work for you, which includes scanning all `*_test.go` files for special functions,
    generating a proper temporary `main` package, calling these special functions,
    getting the results, and generating the final output.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦测试代码正确，`go test` 子命令会为你完成所有脏活，包括扫描所有 `*_test.go` 文件中的特殊函数，生成适当的临时 `main` 包，调用这些特殊函数，获取结果，并生成最终输出。
- en: Now, let us present testing by revisiting the `matchInt()` function from *Chapter
    3*, *Composite Data Types*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过回顾 *第 3 章*，*复合数据类型* 中的 `matchInt()` 函数来介绍测试。
- en: Writing tests for ./ch03/intRE.go
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 ./ch03/intRE.go 编写测试
- en: In this subsection, we write tests for the `matchInt()` function, which was
    implemented in `intRE.go` back in *Chapter 3*, *Composite Data Types*. First,
    we create a new file named `intRE_test.go`, which is going to contain all tests.
    Then, we rename the package from `main` to `testRE` and remove the `main()` function—this
    is an optional step. After that, we must decide what we are going to test and
    how. The main steps in testing include writing tests for expected input, unexpected
    input, empty input, and edge cases. All these are going to be seen in the code.
    Additionally, we are going to generate random integers, convert them into strings,
    and use them as input for `matchInt()`. Generally speaking, a good way to test
    functions that work with numeric values is by using random numbers, or random
    values in general, as input and see how your code behaves and handles these values.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们为在 *第 3 章*，*复合数据类型* 中实现的 `matchInt()` 函数编写测试。首先，我们创建一个名为 `intRE_test.go`
    的新文件，它将包含所有测试。然后，我们将包名从 `main` 改为 `testRE` 并删除 `main()` 函数——这是一个可选步骤。之后，我们必须决定我们要测试什么以及如何测试。测试的主要步骤包括编写预期输入、意外输入、空输入和边缘情况的测试。所有这些都会在代码中看到。此外，我们还将生成随机整数，将它们转换为字符串，并将它们用作
    `matchInt()` 的输入。一般来说，测试处理数值的函数的好方法是使用随机数或随机值作为输入，并观察你的代码如何表现和处理这些值。
- en: 'The relevant code, which includes the original version of `intRE.go`, can be
    found inside `~/go/src/github.com/mactsouk/mGo4th/ch12/intRE` and is composed
    of two test functions. The two test functions of `intRE_test.go` are the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 相关代码，包括 `intRE.go` 的原始版本，可以在 `~/go/src/github.com/mactsouk/mGo4th/ch12/intRE`
    内找到，并包含两个测试函数。`intRE_test.go` 的两个测试函数如下：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `matchInt("")` call should return `false`, so if it returns `true`, it means
    that the function does not work as expected.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`matchInt("")` 调用应该返回 `false`，所以如果它返回 `true`，则意味着该函数没有按预期工作。'
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `matchInt("00")` call should return `true` because `00` is a valid integer,
    so if it returns `false`, it means that the function does not work as expected.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`matchInt("00")` 调用应该返回 `true`，因为 `00` 是一个有效的整数，所以如果它返回 `false`，则意味着该函数没有按预期工作。'
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This first test function uses static input to test the correctness of `matchInt()`.
    As discussed earlier, a testing function requires a single `*testing.T` parameter
    and returns no values.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个测试函数使用静态输入来测试 `matchInt()` 函数的正确性。如前所述，一个测试函数需要一个 `*testing.T` 参数，并且不返回任何值。
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The second test function uses a random but valid input to test `matchInt()`—that
    random input is generated by the `random()` function, which is also implemented
    in `intRE_test.go`. Therefore, the given input should always pass the test. Running
    the two test functions with `go test` creates the next output:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试函数使用随机但有效的输入来测试`matchInt()`——这个随机输入是由`random()`函数生成的，该函数也实现于`intRE_test.go`中。因此，给定的输入应该总是通过测试。使用`go
    test`运行这两个测试函数会创建以下输出：
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: So, all tests passed, which means that everything is fine with `matchInt()`—in
    general, the simpler the operation of a function is, the easier it is to test
    it. The `-v` parameter creates verbose output and can be omitted.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，所有测试都通过了，这意味着`matchInt()`一切正常——一般来说，函数的操作越简单，测试它就越容易。`-v`参数创建详细输出，可以省略。
- en: The next subsection shows how to test UNIX signals.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将展示如何测试UNIX信号。
- en: Testing UNIX signals
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试UNIX信号
- en: There exists a technique for testing UNIX signals. Why do system signals need
    special treatment? The main reason is that it is difficult to send a UNIX signal
    to a running UNIX process, which means that it is also difficult to manually test
    a process that handles UNIX signals. The other tricky reason is that there is
    a possibility that you exit your running tests by accident when you receive a
    signal that is defined to do so.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一种测试UNIX信号的技术。为什么系统信号需要特殊处理？主要原因在于向正在运行的UNIX进程发送UNIX信号很困难，这意味着手动测试处理UNIX信号的进程也很困难。另一个棘手的原因是，当你收到定义为这样做的信号时，你可能会意外退出正在运行的测试。
- en: The relevant code can be found inside `ch12/testSignals`, which contains two
    files named `signalsTest.go` and `signalsTest_test.go`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 相关代码位于`ch12/testSignals`中，其中包含两个名为`signalsTest.go`和`signalsTest_test.go`的文件。
- en: 'The structure of `signalsTest.go` is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`signalsTest.go`的结构如下：'
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: So, `signalsTest.go` does not include a `main()` function as it does not implement
    the `main` package. This happens because such an implementation makes testing
    easier. After you make sure that your code works as expected, you can either include
    it in the `main` package or convert the existing file into the `main` package.
    In that case, you just need to change the `package` statement and rename the `Listener()`
    function to `main()`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`signalsTest.go`不包含`main()`函数，因为它不实现`main`包。这种情况发生是因为这样的实现使得测试更加容易。在你确保代码按预期工作后，你可以将其包含在`main`包中，或者将现有文件转换为`main`包。在这种情况下，你只需要更改`package`语句，并将`Listener()`函数重命名为`main()`。
- en: 'The code of `signalsTest_test.go` is presented in two parts. The first part
    contains the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`signalsTest_test.go`的代码分为两部分。第一部分包含以下代码：'
- en: '[PRE42]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `TestAll()` function is the only testing function found in `signalsTest_test.go`,
    which means that it is the only one that is going to get executed by `go test`.
    Therefore, it would be responsible for calling the other functions `signalsTest_test.go`
    as well as the `Listener()` function from `signalsTest.go`, which is responsible
    for the handling of the UNIX signals. If you forget to call the `Listener()` function,
    all tests will fail. Additionally, `Listener()` needs to be called as a goroutine
    because, otherwise, all tests will stall as `Listener()` never returns.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestAll()`函数是`signalsTest_test.go`中发现的唯一测试函数，这意味着它是`go test`将要执行的唯一函数。因此，它将负责调用`signalsTest_test.go`中的其他函数以及`signalsTest.go`中的`Listener()`函数，后者负责处理UNIX信号。如果你忘记调用`Listener()`函数，所有测试都将失败。此外，`Listener()`需要作为一个goroutine来调用，否则，所有测试都将停滞，因为`Listener()`永远不会返回。'
- en: Bear in mind that if the `Listener()` goroutine stops handling signals for some
    reason and the program continues to run, the test will still return `PASS` when
    it actually failed to handle the signal. One possible way for this to happen is
    if the anonymous function in `Listener()` returns prematurely. However, normally,
    this should never happen.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果由于某种原因`Listener()`协程停止处理信号，而程序继续运行，测试仍然会在实际上未能处理信号的情况下返回`PASS`。这种情况可能发生的一种方式是`Listener()`中的匿名函数提前返回。然而，通常情况下，这种情况不应该发生。
- en: The `time.Sleep()` calls give enough time to the `test_SIGUSR1()`, `test_SIGUSR2()`,
    and `test_SIGHUP()` functions to send the UNIX signal and the `Listener()` function
    to handle them sequentially. The purpose of the last `time.Sleep()` call is to
    give `Listener()` time to process the last signal before all tests end.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`time.Sleep()`调用为`test_SIGUSR1()`、`test_SIGUSR2()`和`test_SIGHUP()`函数发送UNIX信号以及`Listener()`函数按顺序处理信号提供了足够的时间。最后一个`time.Sleep()`调用的目的是在所有测试结束之前给`Listener()`处理最后一个信号的时间。'
- en: 'The second part of `signalsTest_test.go` comes with the next code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`signalsTest_test.go`的第二部分包含以下代码：'
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Each one of the `test_SIGUSR1()`, `test_SIGUSR2()`, and `test_SIGHUP()` functions
    sends a different signal to the running UNIX process—the process ID of the running
    UNIX process is discovered using a call to `syscall.Getpid()`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_SIGUSR1()`、`test_SIGUSR2()`和`test_SIGHUP()`中的每一个函数都会向运行的UNIX进程发送不同的信号——使用`syscall.Getpid()`调用发现运行中的UNIX进程的进程ID。'
- en: 'Running the tests produces the following output:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试会产生以下输出：
- en: '[PRE44]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: All tests finish successfully, which means that all signals are handled successfully
    without the `Listener()` function exiting prematurely.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试都成功完成，这意味着所有信号都成功处理，没有`Listener()`函数提前退出。
- en: 'If you run the previous test multiple times, you might get a last line that
    looks like the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你多次运行前面的测试，你可能会得到一个看起来像以下内容的最后一行：
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The word `cached` in the output tells us that Go used existing testing results
    to make running the tests faster and did not execute the testing functions, which
    is not always the desired behavior. The next subsection shows how to clear or
    disable the cache when testing.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中的单词`cached`告诉我们，Go使用了现有的测试结果来加快测试运行速度，而没有执行测试函数，这并不总是我们期望的行为。下一小节将展示如何在测试时清除或禁用缓存。
- en: Disabling test caching
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 禁用测试缓存
- en: Testing and caching are not always a good combination, mainly because you get
    the same results all the time. However, it has its benefits if the test inputs
    and the test subject do not change—this makes it a completely valid condition
    in several situations. There exist two ways to avoid getting results using test
    caching. The first one requires running `go clean -testcache`, which cleans the
    entire testing cache, whereas the second one requires running your tests using
    `-count=1`, which prevents Go from saving any testing cache for the given testing
    execution.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 测试和缓存并不总是好的组合，主要是因为你总是得到相同的结果。然而，如果测试输入和测试主题没有变化，这有其好处——这使得它在几种情况下完全有效。存在两种避免使用测试缓存得到结果的方法。第一种需要运行`go
    clean -testcache`，这将清除整个测试缓存，而第二种需要使用`-count=1`运行你的测试，这会阻止Go为给定的测试执行保存任何测试缓存。
- en: The next subsection discusses the use of the `TempDir()` method, which is handy
    when you want to create a temporary place for data during testing or benchmarking.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 下一小节将讨论`TempDir()`方法的使用，这在测试或基准测试期间需要创建一个临时数据存储位置时非常有用。
- en: The testing.TempDir() function
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试的`TempDir()`函数
- en: The `testing.TempDir()` method works with both testing and benchmarking. Its
    purpose is to create a temporary directory that will be used during testing (or
    benchmarking). Each call to `testing.TempDir()` returns a unique directory. Go
    **automatically removes** that temporary directory when the test and its subtests
    or the benchmarks are about to finish with the help of the `CleanUp()` method—this
    is arranged by Go and you do not need to use and implement `CleanUp()` on your
    own.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`testing.TempDir()`方法与测试和基准测试都兼容。它的目的是在测试（或基准测试）期间创建一个临时目录。每次调用`testing.TempDir()`都会返回一个唯一的目录。Go会**自动删除**该临时目录，当测试及其子测试或基准测试即将结束时，通过`CleanUp()`方法完成——这是Go安排的，你不需要自己使用和实现`CleanUp()`。'
- en: You should not confuse `testing.TempDir()` with `os.TempDir()`. We already saw
    the use of the `os.TempDir()` method in `profileCla.go` and `traceCLA.go` at the
    beginning of this chapter. `os.TempDir()` returns the default directory to use
    for temporary files, whereas `testing.TempDir()` returns a temporary directory
    for the current test to use.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该混淆`testing.TempDir()`和`os.TempDir()`。我们已经在本章开头看到了`os.TempDir()`方法在`profileCla.go`和`traceCLA.go`中的使用。`os.TempDir()`返回用于临时文件的默认目录，而`testing.TempDir()`返回当前测试使用的临时目录。
- en: The exact place where the temporary directory is going to be created depends
    on the operating system used. On macOS, it is under `/var/folders`, whereas on
    Linux, it is under `/tmp`. We are going to illustrate `testing.TempDir()` in the
    next subsection, where we also talk about `Cleanup()`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 临时目录将要创建的确切位置取决于所使用的操作系统。在 macOS 上，它位于 `/var/folders` 下，而在 Linux 上，它位于 `/tmp`
    下。我们将在下一个子节中说明 `testing.TempDir()`，同时也会讨论 `Cleanup()`。
- en: The Cleanup() function
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Cleanup()` 函数'
- en: Although we present the `Cleanup()` method in a testing scenario, `Cleanup()`
    works for both testing and benchmarking. Its name reveals its purpose, which is
    to clean up some things that we have created when testing or benchmarking a package.
    However, it is we who need to tell `Cleanup()` what to do—the parameter of `Cleanup()`
    is a function that does the cleaning up.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在测试场景中展示了 `Cleanup()` 方法，但 `Cleanup()` 适用于测试和基准测试。其名称揭示了其目的，即在测试或基准测试包时清理我们创建的一些东西。然而，我们需要告诉
    `Cleanup()` 要做什么——`Cleanup()` 的参数是一个执行清理的函数。
- en: That function is usually implemented inline as an anonymous function, but you
    can also create it elsewhere and call it by its name.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数通常作为匿名函数内联实现，但你也可以在其他地方创建它并通过其名称调用它。
- en: The `cleanup.go` file contains a dummy function named `Foo()`—as it contains
    no real code, there is no point in presenting it. On the other hand, all important
    code can be found in `cleanup_test.go`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`cleanup.go` 文件包含一个名为 `Foo()` 的虚拟函数——因为它不包含任何实际代码，所以没有必要展示它。另一方面，所有重要的代码都可以在
    `cleanup_test.go` 中找到。'
- en: '[PRE46]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `myCleanUp()` function is going to be used as a parameter to `CleanUp()`
    and should have that specific signature. Apart from the signature, you can put
    any kind of code in the implementation of `myCleanUp()`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`myCleanUp()` 函数将被用作 `CleanUp()` 的参数，并应具有该特定签名。除了签名之外，你可以在 `myCleanUp()` 的实现中放置任何类型的代码。'
- en: '[PRE47]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `t1` and `t2` variables hold the paths of two directories that we are going
    to create.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `t1` 和 `t2` 存储了我们将要创建的两个目录的路径。
- en: '[PRE48]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The previous code creates a directory using `os.Mkdir()`—we manually specify
    its path. Therefore, it is our duty to delete that directory when it is no longer
    needed.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用 `os.Mkdir()` 创建了一个目录——我们手动指定了其路径。因此，当它不再需要时，删除该目录是我们的责任。
- en: '[PRE49]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: After `TestFoo()` finishes, `t1` is deleted by the code of the anonymous function
    that is passed as a parameter to `t.CleanUp()`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TestFoo()` 执行完毕后，`t1` 被传递给 `t.CleanUp()` 参数的匿名函数所删除。
- en: '[PRE50]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We create another directory with `os.Mkdir()`—however, in this case, we are
    not deleting that directory. Therefore, after `TestFoo()` finishes, `t2` is not
    going to be deleted.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `os.Mkdir()` 创建另一个目录——然而，在这种情况下，我们不会删除该目录。因此，在 `TestFoo()` 执行完毕后，`t2` 不会被删除。
- en: '[PRE51]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Because of the use of the `testing.TempDir()` method, the value (directory path)
    of `t1` is assigned by the operating system. Additionally, that directory path
    is **automatically deleted** when the test function is about to finish.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用了 `testing.TempDir()` 方法，`t1` 的值（目录路径）由操作系统分配。此外，当测试函数即将结束时，该目录路径将被**自动删除**。
- en: '[PRE52]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here we use `myCleanUp()` as the parameter to `Cleanup()`. This is handy when
    you want to perform the same cleanup multiple times. Running the tests creates
    the next output:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `myCleanUp()` 作为 `Cleanup()` 的参数。当你想要多次执行相同的清理时，这很方便。运行测试会创建以下输出：
- en: '[PRE53]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This is the temporary directory that was created with `TempDir()` on a macOS
    machine.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 macOS 机器上的 `TempDir()` 创建的临时目录。
- en: '[PRE54]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Checking whether the directories created by `TempDir()` are there shows that
    they have been successfully deleted. On the other hand, the directory stored in
    the `t2` variable of `TestFoo()` has not been deleted. Running the same tests
    again (remember to disable caching) is going to fail because the `test02` file
    already exists and cannot be created:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 检查由 `TempDir()` 创建的目录是否存在表明它们已被成功删除。另一方面，存储在 `TestFoo()` 的 `t2` 变量中的目录尚未被删除。再次运行相同的测试（请记住禁用缓存）将会失败，因为
    `test02` 文件已经存在且无法创建：
- en: '[PRE55]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `/var/folders/sk/ltk8cnw50lzdtr2hxcj5sv2m0000gn/T/test02: file exists`
    error message reveals the root of the problem. So, **clean up your tests properly**.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '错误信息 `/var/folders/sk/ltk8cnw50lzdtr2hxcj5sv2m0000gn/T/test02: 文件存在` 揭示了问题的根源。因此，**请正确清理您的测试**。'
- en: The next subsection discusses the use of the `testing/quick` package.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节讨论了 `testing/quick` 包的使用。
- en: The testing/quick package
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试/快速包
- en: There are times when you need to create testing data without human intervention.
    The Go standard library offers the `testing/quick` package, which can be used
    for *black-box testing* (a software testing method that checks the functionality
    of an application or function without any prior knowledge of its internal working)
    and is somewhat related to the `QuickCheck` package found in the Haskell programming
    language—both packages implement utility functions to help you with black-box
    testing. With the help of `testing/quick`, Go generates random values of built-in
    types that you can use for testing, which saves you from having to generate all
    these values manually.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要在没有人为干预的情况下创建测试数据。Go 标准库提供了 `testing/quick` 包，它可以用于 *黑盒测试*（一种软件测试方法，在没有任何关于其内部工作先验知识的情况下检查应用程序或函数的功能），并且与
    Haskell 编程语言中找到的 `QuickCheck` 包有些相关——这两个包都实现了帮助您进行黑盒测试的实用函数。借助 `testing/quick`，Go
    生成用于测试的内置类型的随机值，这样您就无需手动生成所有这些值。
- en: 'The code of `quickT.go` is the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`quickT.go` 的代码如下：'
- en: '[PRE56]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The previous code implements a single function that adds two `Point2D` variables—this
    is the function that we are going to test.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码实现了一个单一的功能，该功能将两个 `Point2D` 变量相加——这是我们将要测试的功能。
- en: 'The code of `quickT_test.go` is as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`quickT_test.go` 的代码如下：'
- en: '[PRE57]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The call to `quick.Check()` automatically generates random numbers based on
    the signature of its first argument, which is a function defined earlier. There
    is no need to create these random numbers on your own, which makes the code easy
    to read and write. The actual tests happen in the `condition` function. Put simply,
    we start by defining a property function that represents a condition that we want
    to hold true for a range of inputs. This function takes the input values and returns
    a Boolean value indicating whether the property holds for those values or not.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `quick.Check()` 的调用会自动根据其第一个参数的签名生成随机数，该参数是一个之前定义的函数。您无需自己创建这些随机数，这使得代码易于阅读和编写。实际的测试发生在
    `condition` 函数中。简单来说，我们首先定义一个属性函数，它代表我们想要在一系列输入中保持为真的条件。这个函数接受输入值，并返回一个布尔值，表示该属性对于这些值是否成立。
- en: '[PRE58]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This implementation is wrong on purpose. To correct the implementation, we should
    replace `Add(Add(a, b), c) == Add(a, b)` with `Add(Add(a, b), c) == Add(c, Add(a,
    b))`. We did that to see the output that is generated when a test fails.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现故意是错误的。为了纠正实现，我们应该将 `Add(Add(a, b), c) == Add(a, b)` 替换为 `Add(Add(a, b),
    c) == Add(c, Add(a, b))`。我们这样做是为了看到当测试失败时生成的输出。
- en: '[PRE59]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Running the created tests generates the next output:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 运行创建的测试生成以下输出：
- en: '[PRE60]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As expected, the first test was successful.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，第一个测试是成功的。
- en: '[PRE61]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: However, as expected, the second test generated an error. The good thing is
    that the input that caused the error is presented onscreen so that you can see
    the input that caused your function to fail.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如预期的那样，第二个测试生成了一个错误。好事是，导致错误的输入显示在屏幕上，这样你就可以看到导致你的函数失败的输入。
- en: The next subsection tells us how to time out tests that take too long to finish.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 下一小节将告诉我们如何超时那些执行时间太长的测试。
- en: Timing out tests
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试超时
- en: If the `go test` tool takes too long to finish or, for some reason, never ends,
    the `-timeout` parameter can help you.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `go test` 工具完成得太慢，或者由于某种原因永远不结束，`-timeout` 参数可以帮助您。
- en: To illustrate that, we are using the code from the previous subsection as well
    as the `-timeout` and `-count` command line flags. While the former specifies
    the maximum allowed time duration for the tests, the latter specifies the number
    of times the tests are going to be executed.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们使用了前一小节中的代码以及 `-timeout` 和 `-count` 命令行标志。前者指定了测试允许的最大时间长度，后者指定了测试将要执行的数量。
- en: Running `go test -v *.go -timeout 1s` tells `go test` that all tests should
    take at most one second to finish—on my machine, the tests did take less than
    a second to finish.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `go test -v *.go -timeout 1s` 告诉 `go test` 所有测试最多需要一秒钟完成——在我的机器上，测试确实少于一秒就完成了。
- en: 'However, running the following generates a different output:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，运行以下代码会生成不同的输出：
- en: '[PRE62]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The actual output is longer than the presented one—the rest of the output has
    to do with goroutines being terminated before they have finished. The key thing
    here is that the `go test` command timed out the process due to the use of `-timeout
    1s`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 实际输出比展示的要长——其余的输出与goroutines在完成前被终止有关。这里的关键点是，`go test` 命令由于使用了 `-timeout 1s`
    而超时了进程。
- en: So far, we have seen the use of `Errorf()` when a test fails. The next subsection
    discusses the use of `testing.T.Fatalf()` and `testing.T.Fatal()`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了在测试失败时使用 `Errorf()` 的例子。下一个子节将讨论 `testing.T.Fatalf()` 和 `testing.T.Fatal()`
    的使用。
- en: Testing using testing.T.Fatal() and testing.T.Fatalf()
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 testing.T.Fatal() 和 testing.T.Fatalf() 进行测试
- en: This subsection discusses the use of `testing.T.Fatalf()` and `testing.T.Fatal()`.
    The core idea behind the use of `T.Fatal()` and `T.Fatalf()` instead of `T.Error()`
    and `T.Errorf()` is that you should use `T.Fatal()` or `T.Fatalf()` when it makes
    sense to stop testing the code that comes because the previous failure is going
    to cause more failures. On the other hand, you should use the appropriate `T.Error()`
    variant when a condition failure is not going to cause more failures due to various
    dependencies.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了 `testing.T.Fatalf()` 和 `testing.T.Fatal()` 的使用。使用 `T.Fatal()` 和 `T.Fatalf()`
    而不是 `T.Error()` 和 `T.Errorf()` 的核心思想是，当停止测试代码有意义时（因为之前的失败将导致更多失败），应使用 `T.Fatal()`
    或 `T.Fatalf()`。另一方面，当条件失败不会因为各种依赖而导致更多失败时，应使用适当的 `T.Error()` 变体。
- en: Two real-world cases for using `t.Fatalf()` are when a database connection required
    for testing fails or when a network connection required for testing cannot be
    established.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `t.Fatalf()` 的两个实际案例是：当测试所需的数据库连接失败时，或者当测试所需的网络连接无法建立时。
- en: The relevant code can be found in `code.go` and `code_test.go`, which are both
    located inside `ch12/testFatal`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 相关代码可以在 `code.go` 和 `code_test.go` 中找到，这两个文件都位于 `ch12/testFatal` 内。
- en: 'The contents of `code.go` are the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`code.go` 的内容如下：'
- en: '[PRE63]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `server` package initializes the `DATA` map using the `init()` function
    by defining the value for the `"server"` key.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`server` 包使用 `init()` 函数初始化 `DATA` 映射，通过为 `"server"` 键定义值。'
- en: 'The contents of `code_test.go` are the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`code_test.go` 的内容如下：'
- en: '[PRE64]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In this case, there is no point in executing the `t.Log()` call as the `"port"`
    key is not defined in the `DATA` map. In this case, we use `t.Fatalf()`, which
    terminates the testing process.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，执行 `t.Log()` 调用是没有意义的，因为 `"port"` 键在 `DATA` 映射中未定义。在这种情况下，我们使用 `t.Fatalf()`，它终止测试过程。
- en: 'Running the tests generates the following output:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试生成以下输出：
- en: '[PRE65]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: So, as expected, `t.Log()` is never executed and the test fails.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如预期的那样，`t.Log()` 从未执行，测试失败。
- en: The next subsection talks about table-driven testing.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将讨论基于表的测试。
- en: Table-driven tests
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于表的测试
- en: Table-driven tests are tests that have many input scenarios. The main advantage
    of table-driven testing is that a developer can cover lots of testing cases by
    reusing existing code, which saves time and energy. In order to have the parameters
    of the various tests in the same place, we usually use a slice of structures and
    iterate over its elements to run the tests.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 基于表的测试是具有许多输入场景的测试。基于表的测试的主要优点是，开发者可以通过重用现有代码来覆盖大量的测试用例，从而节省时间和精力。为了将各种测试的参数放在同一个地方，我们通常使用结构体切片并遍历其元素来运行测试。
- en: All relevant code of the example can be found in the `ch12/table` directory,
    which contains two files. The first file is called `table.go`, whereas the source
    code file that is used for testing is called `table_test.go`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中所有相关代码都可以在 `ch12/table` 目录中找到，该目录包含两个文件。第一个文件名为 `table.go`，而用于测试的源代码文件名为
    `table_test.go`。
- en: 'The `table.go` file contains the following code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`table.go` 文件包含以下代码：'
- en: '[PRE66]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The Go package that we are going to test contains two functions that implement
    integer division (`intDiv()`) and floating-point division between two integers
    (`floatDiv()`), respectively. As you might recall from your mathematics classes,
    integer division between two integers gives different results from regular division.
    As an example, dividing 2 by 4 gives 0 as a result in integer division and 0.5
    in regular division. This means that integer division ignores the remainder and
    produces integer results only, hence the function signature of `intDiv()`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要测试的 Go 包包含两个函数，分别实现整数除法 (`intDiv()`) 和两个整数之间的浮点除法 (`floatDiv()`)。如您从数学课程中回忆起来，两个整数之间的整数除法与常规除法的结果不同。例如，将
    2 除以 4 在整数除法中结果为 0，而在常规除法中为 0.5。这意味着整数除法忽略余数，只产生整数结果，因此 `intDiv()` 函数的函数签名。
- en: 'The `table_test.go` file is going to be presented in two parts. The first part
    comes with the following code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`table_test.go` 文件将分两部分介绍。第一部分包含以下代码：'
- en: '[PRE67]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The number of entries in the `tests` structure, which can have any name you
    want, signifies the number of tests that we are going to perform. The last entry
    has an intentional error in it as `5` divided by `4` equals `1.25` instead of
    `1.2`, which means that the respective test is going to fail.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`tests` 结构中的条目数量，可以取任何你想要的名称，表示我们将要执行测试的数量。最后一个条目中有一个故意的错误，即 `5` 除以 `4` 等于
    `1.25` 而不是 `1.2`，这意味着相应的测试将会失败。'
- en: The biggest advantage of table-driven testing is that adding a new test is just
    as simple as adding an entry to the structure that holds the existing tests. In
    a different case, you would need to add an additional test function.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 表格驱动测试的最大优点是添加新的测试与向包含现有测试的结构添加条目一样简单。在另一种情况下，您需要添加一个额外的测试函数。
- en: 'The second part of `table_test.go` is the following:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`table_test.go` 的第二部分如下：'
- en: '[PRE68]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `Test_all()` testing function iterates over the contents of the `tests`
    structure and runs the tests. The `t.Parallel()` statement allows the tests to
    run in parallel, which makes the process faster. Execute `go doc testing.T.Parallel`
    in the shell for more information about its usage. However, in this case, `t.Parallel()`
    has no effect since no other tests are marked as parallel.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`Test_all()` 测试函数遍历 `tests` 结构的内容并运行测试。`t.Parallel()` 语句允许测试并行运行，这使过程更快。在 shell
    中执行 `go doc testing.T.Parallel` 以获取更多关于其使用的信息。然而，在这种情况下，`t.Parallel()` 没有作用，因为没有其他测试被标记为并行。'
- en: In general, float comparison like the one presented here is, generally, unreliable.
    For the purposes of the book, it is fine, but you should not rely on float comparison
    in your test functions. More about that can be found at [https://medium.com/p/9872fe6de17f](https://medium.com/p/9872fe6de17f).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，像这里展示的浮点数比较通常是不可靠的。对于本书的目的来说，这是可以接受的，但你不应该在测试函数中依赖浮点数比较。更多关于这个话题的信息可以在 [https://medium.com/p/9872fe6de17f](https://medium.com/p/9872fe6de17f)
    找到。
- en: 'Running the tests produces the following results:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试产生以下结果：
- en: '[PRE69]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: All tests were successful apart from the last one. The next subsection shows
    how to find information about the code coverage of your software.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试都成功了，除了最后一个。下一个小节将展示如何查找关于您软件代码覆盖率的详细信息。
- en: Testing code coverage
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试代码覆盖率
- en: In this section, we are going to learn how to find information about the code
    coverage of our programs to discover blocks of code or single code statements
    that are not being executed by testing functions.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何查找有关我们程序代码覆盖率的信息，以发现测试函数未执行的代码块或单个代码语句。
- en: Among other things, seeing the code coverage of programs can reveal logical
    issues and bugs in the code, so do not underestimate its usefulness. However,
    the code coverage test complements unit testing without replacing it. The only
    thing to remember is that you should make sure that the testing functions try
    to cover all cases and, therefore, try to run all available code. If the testing
    functions do not try to cover all cases, then the issue might be with them, not
    the code that is being tested.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他方面，查看程序的代码覆盖率可以揭示代码中的逻辑问题和错误，所以不要低估它的有用性。然而，代码覆盖率测试补充了单元测试，而没有取代它。唯一要记住的是，你应该确保测试函数尝试覆盖所有情况，因此尝试运行所有可用的代码。如果测试函数没有尝试覆盖所有情况，那么问题可能出在它们身上，而不是正在被测试的代码。
- en: 'All relevant files can be found in `ch12/coverage`. The code of `coverage.go`,
    which has some intentional issues in order to show how unreachable code is identified,
    is as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 所有相关文件都可以在 `ch12/coverage` 中找到。`coverage.go` 的代码如下，其中包含一些故意的问题，以展示如何识别不可达的代码：
- en: '[PRE70]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The issue with this function is that the first branch of `if` is always true
    and, therefore, the `else` branch is never going to get executed.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的问题在于 `if` 的第一个分支总是为真，因此 `else` 分支永远不会被执行。
- en: '[PRE71]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'There exist two issues with `f2()`. The first one is that it does not work
    well with negative integers and the second one is that all positive integers are
    handled by the first `if` branch. Code coverage can only help you with the second
    issue. The code of `coverage_test.go` is the following—these are regular test
    functions that try to run all available code:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`f2()` 存在两个问题。第一个问题是它不适用于负整数，第二个问题是所有正整数都由第一个 `if` 分支处理。代码覆盖率只能帮助您解决第二个问题。`coverage_test.go`
    的代码如下——这些是常规测试函数，试图运行所有可用的代码：'
- en: '[PRE72]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This test function naively tests the operation of `f1()`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试函数天真地测试了 `f1()` 的操作。
- en: '[PRE73]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The second test function checks the operation of `f2()` by running `f2(123)`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试函数通过运行 `f2(123)` 来检查 `f2()` 的操作。
- en: 'First, we should run `go test` as follows—the code coverage task is done by
    the `s` flag:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该按照以下方式运行 `go test`——代码覆盖率任务由 `s` 标志完成：
- en: '[PRE74]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The previous output shows that we have `50%` code coverage, which is not a
    good thing! However, we are not done yet as we can generate a test coverage report.
    The next command generates the code coverage report:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出显示我们有 `50%` 的代码覆盖率，这并不是一个好现象！然而，我们还没有完成，因为我们还可以生成一个测试覆盖率报告。下一个命令生成代码覆盖率报告：
- en: '[PRE75]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The contents of `coverage.out` are as follows—yours might vary a little depending
    on your username and the folder used:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`coverage.out` 的内容如下——你的可能因用户名和使用的文件夹而略有不同：'
- en: '[PRE76]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The format and the fields in each line of the coverage file are `name.go:line.column,line.column
    numberOfStatements count`. The last field is a flag that tells you whether the
    statements specified by `line.column,line.column` are covered or not. So, when
    you see `0` in the last field, it means that the code is not covered.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率文件的格式和每行的字段是 `name.go:line.column,line.column numberOfStatements count`。最后一个字段是一个标志，告诉你指定的
    `line.column,line.column` 语句是否被覆盖。所以，当你看到最后一个字段中的 `0` 时，这意味着代码没有被覆盖。
- en: Lastly, the HTML output can be seen in your favorite web browser by running
    `go tool cover -html=coverage.out`. If you used a different filename than `coverage.out`,
    modify the command accordingly. The next figure shows the generated output—if
    you are reading the printed version of the book, you might not be able to see
    the colors. Red lines denote code that is not being executed, whereas green lines
    show code that was executed by the tests.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过运行 `go tool cover -html=coverage.out`，你可以在你喜欢的网页浏览器中看到HTML输出。如果你使用了不同于
    `coverage.out` 的文件名，请相应地修改命令。下一张图显示了生成的输出——如果你正在阅读本书的打印版，你可能看不到颜色。红色线条表示未执行的代码，而绿色线条表示由测试执行的代码。
- en: '![A screenshot of a computer  Description automatically generated](img/B21003_12_02.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成](img/B21003_12_02.png)'
- en: 'Figure 12.2: Code coverage report'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：代码覆盖率报告
- en: Some of the code is marked as not tracked (gray in color) because this is code
    that cannot be processed by the code coverage tool. The generated output clearly
    shows the code issues with both `f1()` and `f2()`. You just have to correct them
    now!
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 一些代码被标记为未跟踪（灰色），因为这是代码覆盖率工具无法处理的代码。生成的输出清楚地显示了 `f1()` 和 `f2()` 的代码问题。你现在只需纠正它们即可！
- en: The next subsection discusses unreachable code and how to discover it.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节讨论了无法到达的代码以及如何发现它。
- en: Finding unreachable Go code
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找无法到达的Go代码
- en: Sometimes, a wrongly implemented `if` or a misplaced `return` statement can
    create blocks of code that are unreachable, that is, blocks of code that are not
    going to be executed at all. As this is a logical kind of error, which means that
    it is not going to get caught by the compiler, we need to find a way of discovering
    it.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个错误实现的 `if` 语句或一个放置不当的 `return` 语句可以创建一些无法到达的代码块，也就是说，这些代码块根本不会被执行。由于这是一个逻辑错误，这意味着它不会被编译器捕获，我们需要找到一种方法来发现它。
- en: 'Fortunately, the `go vet` tool, which examines Go source code and reports suspicious
    constructs, can help with that—the use of `go vet` is illustrated with the help
    of the `cannotReach.go` source code file, which contains the next two functions:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`go vet` 工具，它检查Go源代码并报告可疑结构，可以帮助我们完成这项工作——`go vet` 的使用通过 `cannotReach.go`
    源代码文件来展示，该文件包含以下两个函数：
- en: '[PRE77]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: There is a logical error here because `S2()` returns before printing the desired
    message.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这里存在一个逻辑错误，因为 `S2()` 在打印期望的消息之前就返回了。
- en: '[PRE78]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Similarly, `S1()` returns without giving the `fmt.Println("Leaving S1()")` statement
    a chance to be executed.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`S1()` 返回，没有给 `fmt.Println("Leaving S1()")` 语句执行的机会。
- en: 'Running `go vet` on `cannotReach.go` creates the next output:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `cannotReach.go` 上运行 `go vet` 生成以下输出：
- en: '[PRE79]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The first message points to the `fmt.Println()` statement of `S2()` and the
    second one to the second `fmt.Println()` statement of `S1()`. In this case, `go
    vet` did a great job. However, `go vet` is not particularly sophisticated and
    cannot catch every possible type of logical error. If you need a more advanced
    tool, have a look at `staticcheck` ([https://staticcheck.io/](https://staticcheck.io/)),
    which can also be integrated with Microsoft Visual Studio Code ([https://code.visualstudio.com/](https://code.visualstudio.com/)),
    Neovim (!), and Zed ([https://zed.dev/](https://zed.dev/))—the next figure shows
    that Zed underlines the unreachable code. Visual Studio Code works in a similar
    way.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条信息指向 `S2()` 的 `fmt.Println()` 语句，第二条信息指向 `S1()` 的第二个 `fmt.Println()` 语句。在这种情况下，`go
    vet` 做得很好。然而，`go vet` 并非特别复杂，无法捕捉到所有可能的逻辑错误。如果您需要更高级的工具，可以看看 `staticcheck` ([https://staticcheck.io/](https://staticcheck.io/))，它也可以与
    Microsoft Visual Studio Code ([https://code.visualstudio.com/](https://code.visualstudio.com/))、Neovim
    (!) 和 Zed ([https://zed.dev/](https://zed.dev/)) 集成——下一图显示了 Zed 下划线了不可达的代码。Visual
    Studio Code 以类似的方式工作。
- en: '![A screen shot of a computer program  Description automatically generated](img/B21003_12_03.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序屏幕截图  自动生成的描述](img/B21003_12_03.png)'
- en: 'Figure 12.3: Viewing unreachable code in Zed'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3：在 Zed 中查看不可达的代码
- en: As a rule of thumb, it does not hurt to include `go vet` in your workflow. You
    can find more information about the capabilities of `go vet` by running `go doc
    cmd/vet`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条经验法则，在您的流程中包含 `go vet` 并无害处。您可以通过运行 `go doc cmd/vet` 来找到有关 `go vet` 功能的更多信息。
- en: The next subsection illustrates how to test an HTTP server with a database backend.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节说明了如何测试具有数据库后端的 HTTP 服务器。
- en: Testing an HTTP server with a database backend
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试具有数据库后端的 HTTP 服务器
- en: An HTTP server is a different kind of animal because it should already run for
    tests to get executed. Thankfully, the `net/http/httptest` package can help—you
    do not need to run the HTTP server on your own as the `net/http/httptest` package
    does the work for you, but you need to have the database server up and running.
    We are going to test the REST API server we developed in *Chapter 11*, *Working
    with REST APIs*. All relevant files are located inside `ch12/testHTTP`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 服务器是一种不同的动物，因为它应该已经运行，以便测试能够执行。幸运的是，`net/http/httptest` 包可以帮助您——您不需要自己运行
    HTTP 服务器，因为 `net/http/httptest` 包会为您完成这项工作，但您需要确保数据库服务器正在运行。我们将测试我们在 *第 11 章*
    中开发的 REST API 服务器，*与 REST API 一起工作*。所有相关文件都位于 `ch12/testHTTP` 内。
- en: 'The code of `server_test.go`, which holds the test functions for the HTTP service,
    is the following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 存储测试 HTTP 服务测试函数的 `server_test.go` 代码如下：
- en: '[PRE80]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The only reason for including `github.com/gorilla/mux` is the use of `mux.SetURLVars()`
    later on.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 `github.com/gorilla/mux` 的唯一原因是在之后使用 `mux.SetURLVars()`。
- en: '[PRE81]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The `http.NewRequest()` function is used to define the HTTP request method and
    the endpoint and to send data to the endpoint when needed. The `http.HandlerFunc(TimeHandler)`
    call specifies the handler function that is being tested.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.NewRequest()` 函数用于定义 HTTP 请求方法、端点，并在需要时向端点发送数据。`http.HandlerFunc(TimeHandler)`
    调用指定了正在测试的处理函数。'
- en: '[PRE82]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: We are testing `MethodNotAllowedHandler` in this test function.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个测试函数中测试 `MethodNotAllowedHandler`。
- en: '[PRE83]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We know that this interaction is going to fail as we are testing `MethodNotAllowedHandler`.
    Therefore, we expect to get an `http.StatusNotFound` response code back—if we
    get a different code, the test function is going to fail.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道这次交互将会失败，因为我们正在测试 `MethodNotAllowedHandler`。因此，我们期望得到一个 `http.StatusNotFound`
    的响应代码——如果我们得到不同的代码，测试函数将会失败。
- en: '[PRE84]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Here we store the desired fields of a `User` structure in a byte slice. For
    the tests to work, the `admin` user should have `admin` as the password because
    this is what is used in the code—modify `server_test.go` in order to have the
    correct password for the `admin` user, or any other user with admin privileges,
    of your installation.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `User` 结构体所需的字段存储在字节切片中。为了测试能够正常工作，`admin` 用户应该将 `admin` 作为密码，因为这是代码中使用的——修改
    `server_test.go` 以确保 `admin` 用户的密码正确，或者任何其他具有管理员权限的用户，以适应您的安装。
- en: In general, and mainly for critical applications or projects that involve more
    than a single developer, this is not a good practice. Ideally, everything needed
    for the tests should be contained within the tests. One possible solution is to
    provide a separate database or a separate machine used just for testing purposes.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，尤其是在涉及多个开发者的关键应用程序或项目中，这不是一个好的做法。理想情况下，测试所需的一切都应该包含在测试中。一个可能的解决方案是提供一个单独的数据库或一台仅用于测试目的的单独机器。
- en: '[PRE85]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The previous lines of code construct the desired request, which is about logging
    in to the service.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码行构建了所需的请求，这是关于登录到服务的请求。
- en: '[PRE86]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '`NewRecorder()` returns an initialized `ResponseRecorder` that is used in `ServeHTTP()`—`ServeHTTP()`
    is the method that performs the request. The response is saved in the `rr` variable.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewRecorder()` 返回一个初始化的 `ResponseRecorder`，它在 `ServeHTTP()` 中使用——`ServeHTTP()`
    是执行请求的方法。响应被保存在 `rr` 变量中。'
- en: There is also a test function for the `/logout` endpoint, which is not presented
    here as it is almost identical to `TestLogin()`. In this case, running the tests
    in a random order might create issues with testing because `TestLogin()` should
    always get executed before `TestLogout()`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个用于 `/logout` 端点的测试函数，这里没有展示，因为它几乎与 `TestLogin()` 相同。在这种情况下，以随机顺序运行测试可能会在测试中引起问题，因为
    `TestLogin()` 应始终在 `TestLogout()` 之前执行。
- en: '[PRE87]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: If the status code is `http.StatusOK`, it means that the interaction worked
    as expected.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态码是 `http.StatusOK`，这意味着交互按预期工作。
- en: '[PRE88]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: For the `Add()` handler, we need to pass an array of JSON records, which is
    constructed here. As we do not want to create the same username every time, we
    append the current timestamp to the `_test` string.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Add()` 处理器，我们需要传递一个 JSON 记录数组，这里进行了构建。因为我们不希望每次都创建相同的用户名，所以我们将在 `_test`
    字符串中附加当前的时间戳。
- en: '[PRE89]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: This is where we construct the slice of JSON records (`UserPass`) and create
    the request.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们构建 JSON 记录切片 (`UserPass`) 并创建请求的地方。
- en: '[PRE90]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: If the server response is `http.StatusOK`, then the request is successful and
    the test passes.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器响应是 `http.StatusOK`，则请求成功且测试通过。
- en: '[PRE91]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Although we use `/username/1` in the request, this does not add any value to
    the `Vars` map. Therefore, we need to use the `SetURLVars()` function to change
    the values in the `Vars` map—this is illustrated next:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在请求中使用了 `/username/1`，但这不会给 `Vars` 映射添加任何价值。因此，我们需要使用 `SetURLVars()` 函数来更改
    `Vars` 映射中的值——这将在下面说明：
- en: '[PRE92]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The `gorilla/mux` package provides the `SetURLVars()` function for testing purposes—this
    function allows you to add elements to the `Vars` map. In this case, we need to
    set the value of the `id` key to `1`. You can add as many key/value pairs as you
    want.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`gorilla/mux` 包提供了 `SetURLVars()` 函数用于测试目的——这个函数允许你向 `Vars` 映射中添加元素。在这种情况下，我们需要将
    `id` 键的值设置为 `1`。你可以添加任意多的键/值对。'
- en: '[PRE93]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The `expected` variable holds the record we expect to get back from our request.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`expected` 变量包含我们期望从请求中获取的记录。'
- en: Using the same value for `lastlogin` does not make any sense. Therefore, we
    might be dealing with a bug here. Additionally, if we cannot guess the value of
    `lastlogin` in the server response, we might need to replace it with `0` in both
    `expected` and `serverResponse`. An alternative would have been to marshal the
    result into a structure and only compare what is relevant for the test.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的 `lastlogin` 值没有任何意义。因此，我们可能在这里遇到了一个错误。此外，如果我们无法猜测服务器响应中 `lastlogin` 的值，我们可能需要在
    `expected` 和 `serverResponse` 中将其替换为 `0`。另一种选择是将结果序列化为结构体，并仅比较测试相关的部分。
- en: '[PRE94]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The previous statement removes any spaces from the HTTP server response.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的声明从 HTTP 服务器响应中移除了所有空格。
- en: '[PRE95]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The last part of the code contains the standard Go way of checking whether we
    have received the expected answer or not.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后部分包含了标准 Go 检查我们是否收到了预期答案的方法。
- en: Creating tests for HTTP services is easy once you understand the presented examples.
    This mainly happens because most of the code is repeated among test functions.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你理解了所提供的示例，为 HTTP 服务创建测试就变得简单了。这主要是因为大多数代码在测试函数之间是重复的。
- en: 'Running the tests generates the next output:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试生成了以下输出：
- en: '[PRE96]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: This is the output from visiting the `/time` endpoint with the `DELETE` HTTP
    method. Its result is `PASS` because we were expecting this request to fail as
    it uses the wrong HTTP method.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 `DELETE` HTTP 方法访问 `/time` 端点时的输出。其结果是 `PASS`，因为我们预计这个请求会失败，因为它使用了错误的 HTTP
    方法。
- en: '[PRE97]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This is the output from `TestLogin()` that tests the `/login` endpoint. All
    lines beginning with the date and time are generated by the REST API server and
    show the progress of the request.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从 `TestLogin()` 测试 `/login` 端点得到的输出。所有以日期和时间开头的行为 REST API 服务器生成，显示了请求的进度。
- en: '[PRE98]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: This is the output from `TestLogout()` that tests the `/logout` endpoint, which
    also has the `PASS` result.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `TestLogout()` 测试 `/logout` 端点并得到 `PASS` 结果的输出。
- en: '[PRE99]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: This is the output from the `TestAdd()` test function. The name of the new user
    that is created is `test_1702577728` and it should be different each time the
    test is executed.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `TestAdd()` 测试函数的输出。新创建的用户名为 `test_1702577728`，并且每次执行测试时都应该不同。
- en: '[PRE100]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Lastly, this is the output from the `TestGetUserDataHandler()` test function
    that was also executed without any issues.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是 `TestGetUserDataHandler()` 测试函数的输出，该函数也执行无误。
- en: The next section presents the `govulncheck` tool, which is used to find vulnerabilities
    in project dependencies.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节介绍了 `govulncheck` 工具，该工具用于查找项目依赖项中的漏洞。
- en: The govulncheck tool
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`govulncheck` 工具'
- en: The purpose of the `govulncheck` tool is to find vulnerabilities in project
    dependencies. This means that it is there to make your Go binaries and Go modules
    more secure.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`govulncheck` 工具的目的是在项目依赖项中查找漏洞。这意味着它存在是为了使你的 Go 二进制文件和 Go 模块更加安全。'
- en: Installing the tool
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装工具
- en: 'You can install `govulncheck` by running the following command:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令来安装 `govulncheck`：
- en: '[PRE101]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: As expected, the `govulncheck` binary is going to be installed in `~/go/bin`.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`govulncheck` 二进制文件将被安装到 `~/go/bin`。
- en: 'The relevant Go code can be found inside `ch12/vulcheck`—the source code file
    is called `vul.go` and contains the following code:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的 Go 代码可以在 `ch12/vulcheck` 内找到——源代码文件名为 `vul.go`，包含以下代码：
- en: '[PRE102]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Running `vul.go` requires executing the following commands first:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `vul.go` 需要先执行以下命令：
- en: '[PRE103]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Based on the previous output of `go mod tidy`, the contents of `go.mod` are
    the following:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 `go mod tidy` 的前一个输出，`go.mod` 的内容如下：
- en: '[PRE104]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: So, we are using version `v0.14.0` of the `golang.org/x/text` package.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们正在使用 `golang.org/x/text` 包的 `v0.14.0` 版本。
- en: 'Running `govulncheck` against `vul.go` produces the following results:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `vul.go` 运行 `govulncheck` 产生以下结果：
- en: '[PRE105]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Now, let us change the contents of `go.mod` to include a package version with
    known vulnerabilities **on purpose**. This requires executing the following commands:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们故意将 `go.mod` 的内容更改以包含具有已知漏洞的包版本。这需要执行以下命令：
- en: '[PRE106]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The purpose of the previous command is to download an older version of the `golang.org/x/text`
    package with known vulnerabilities.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的目的是下载具有已知漏洞的较旧版本的 `golang.org/x/text` 包。
- en: 'The contents of `go.mod` are now the following:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`go.mod` 的内容现在是以下内容：'
- en: '[PRE107]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: So, we are now using version `v0.3.5` of the `golang.org/x/text` package.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在正在使用 `golang.org/x/text` 包的 `v0.3.5` 版本。
- en: 'This time, running `govulncheck` against `vul.go` produces the following output:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，对 `vul.go` 运行 `govulncheck` 产生以下输出：
- en: '[PRE108]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'This time, **we found vulnerabilities in the modules that we are using**. The
    solution to that is to upgrade to the latest version of the `golang.org/x/text`
    package by running the following command:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，**我们在我们使用的模块中发现了漏洞**。解决方法是运行以下命令升级到 `golang.org/x/text` 包的最新版本：
- en: '[PRE109]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'If you want to get the output in JSON format, you can run `govulncheck` with
    the `-json` flag, which is illustrated in the following output:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要以 JSON 格式获取输出，你可以使用 `-json` 标志运行 `govulncheck`，如下面的输出所示：
- en: '[PRE110]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: You should definitely make a habit of using `govulncheck` in your projects.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 你绝对应该养成在项目中使用 `govulncheck` 的习惯。
- en: The next section discusses a handy Go feature, cross-compilation, because after
    testing your code, you usually want to distribute it!
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节讨论了一个实用的 Go 功能，交叉编译，因为测试完你的代码后，你通常想要分发它！
- en: Cross-compilation
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交叉编译
- en: Cross-compilation is the process of generating a binary executable file for
    a different architecture than the one that we are working on without having access
    to other machines. The main benefit that we receive from cross-compilation is
    that we do not need a second or third machine to create and distribute executable
    files for different architectures. This means that we basically need just a single
    machine for our development. Fortunately, Go has built-in support for cross-compilation.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉编译是在没有访问其他机器的情况下，为不同于我们正在工作的架构生成二进制可执行文件的过程。我们从交叉编译中获得的主要好处是我们不需要第二台或第三台机器来创建和分发不同架构的可执行文件。这意味着我们基本上只需要一台机器进行开发。幸运的是，Go
    内置了对交叉编译的支持。
- en: To cross-compile a Go source file, we need to set the `GOOS` and `GOARCH` environment
    variables to the target operating system and architecture, respectively, which
    is not as difficult as it sounds.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 要交叉编译 Go 源文件，我们需要将 `GOOS` 和 `GOARCH` 环境变量分别设置为目标的操作系统和架构，这并不像听起来那么困难。
- en: You can find a list of available values for the `GOOS` and `GOARCH` environment
    variables at [https://go.dev/doc/install/source](https://go.dev/doc/install/source).
    Keep in mind, however, that not all `GOOS` and `GOARCH` combinations are valid.
    You can find a list of all valid combinations using `go tool dist list`.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://go.dev/doc/install/source](https://go.dev/doc/install/source)
    找到 `GOOS` 和 `GOARCH` 环境变量的可用值列表。然而，请注意，并非所有 `GOOS` 和 `GOARCH` 组合都是有效的。你可以使用 `go
    tool dist list` 命令找到所有有效组合的列表。
- en: 'The code of `crossCompile.go` is the following:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`crossCompile.go` 的代码如下：'
- en: '[PRE111]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Running it on a macOS machine with Go version 1.21.5 generates the next output:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 机器上运行（Go 版本 1.21.5）会生成以下输出：
- en: '[PRE112]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Compiling `crossCompile.go` for the Linux OS that runs on a machine with an
    amd64 processor is as simple as running the next command on a macOS machine:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 机器上运行以下命令，就可以简单地编译 `crossCompile.go` 以适用于运行在 amd64 处理器上的 Linux OS：
- en: '[PRE113]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Transferring that file to an Arch Linux machine and running it generates the
    next output:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 将该文件传输到一台 Arch Linux 机器并运行它，会生成以下输出：
- en: '[PRE114]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: One thing to notice here is that the cross-compiled binary file of `crossCompile.go`
    prints the Go version of the machine used for compiling it—this makes perfect
    sense as the target machine might not even have Go installed on it!
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是，`crossCompile.go` 的交叉编译二进制文件会打印出编译它的机器的 Go 版本——这完全合理，因为目标机器甚至可能没有安装
    Go！
- en: Cross-compilation is a great Go feature that can come in handy when you want
    to generate multiple versions of your executables through a CI/CD system and distribute
    them.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉编译是 Go 的一个很棒的功能，当你想要通过 CI/CD 系统生成多个可执行文件的版本并分发它们时，它非常有用。
- en: The next subsection discusses `go:generate`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将讨论 `go:generate`。
- en: Using go:generate
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 go:generate
- en: Although `go:generate` is not directly connected to testing or profiling, it
    is a handy and advanced Go feature, and I believe that this chapter is the perfect
    place for discussing it as it can also help you with testing. The `go:generate`
    directive is associated with the `go generate` command, which was added in Go
    1.4 in order to help with automation, and allows you to run commands described
    by directives within existing files.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `go:generate` 并不直接与测试或分析相关联，但它是一个方便且高级的 Go 功能，我相信这一章是讨论它的完美地方，因为它还可以帮助你进行测试。`go:generate`
    指令与 `go generate` 命令相关联，该命令在 Go 1.4 中添加，旨在帮助自动化，并允许你在现有文件中运行由指令描述的命令。
- en: The `go generate` command supports the `-v`, `-n`, and `-x` flags. The `-v`
    flag prints the names of packages and files as they are processed, whereas the
    `-n` flag prints the commands that would be executed. Lastly, the `-x` flag prints
    commands as they are executed—this is great for debugging `go:generate` commands.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '`go generate` 命令支持 `-v`、`-n` 和 `-x` 标志。`-v` 标志在处理过程中打印包和文件名，而 `-n` 标志打印将要执行的命令。最后，`-x`
    标志在执行时打印命令——这对于调试 `go:generate` 命令非常有用。'
- en: 'The main reasons that you might need to use `go:generate` are the following:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要使用 `go:generate` 的主要原因如下：
- en: You want to download dynamic data from the internet or some other source prior
    to the execution of the Go code.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想在执行 Go 代码之前从互联网或其他来源下载动态数据。
- en: You want to execute some code prior to running the Go code.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想在运行 Go 代码之前执行一些代码。
- en: You want to generate a version number or other unique data before code execution.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想在代码执行之前生成版本号或其他唯一数据。
- en: You want to make sure that you have sample data to work with. For example, you
    can put data into a database using `go:generate`.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想确保你有样本数据可以工作。例如，你可以使用 `go:generate` 将数据放入数据库中。
- en: As using `go:generate` is not considered a good practice because it hides things
    from the developer and creates additional dependencies, I try to avoid it when
    I can, and I usually can. On the other hand, if you really need it, you will know
    it!
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用 `go:generate` 被认为不是一种好的做法，因为它会隐藏信息给开发者并创建额外的依赖，所以我尽量在可能的情况下避免使用它，而且通常可以做到。另一方面，如果你真的需要它，你会知道的！
- en: 'The use of `go:generate` is illustrated in `goGenerate.go`, which is found
    in `./ch12/generate` and has the following content:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`go:generate` 的使用在 `goGenerate.go` 中得到了说明，该文件位于 `./ch12/generate`，内容如下：'
- en: '[PRE115]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: This executes the `echo.sh` script, which should be available in the current
    directory.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行 `echo.sh` 脚本，该脚本应位于当前目录中。
- en: '[PRE116]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '`$GOFILE`, `$GOARCH`, `$GOOS`, `$GOLINE`, and `$GOPACKAGE` are special variables
    and are translated at the time of execution.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`$GOFILE`、`$GOARCH`、`$GOOS`、`$GOLINE` 和 `$GOPACKAGE` 是特殊变量，它们在执行时会被翻译。'
- en: '[PRE117]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: This executes the hello.py Python script, which should be available in the current
    directory.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行hello.py Python脚本，该脚本应位于当前目录中。
- en: '[PRE118]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The `go generate` command is not going to run the `fmt.Println()` statement
    or any other statements found in a Go source file. Lastly, keep in mind that `go
    generate` is not executed automatically and must be run explicitly.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`go generate`命令不会运行Go源文件中找到的`fmt.Println()`语句或其他任何语句。最后，请记住，`go generate`不会自动执行，必须显式运行。'
- en: 'Working with `goGenerate.go` from within `./ch12/generate` generates the next
    output:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在`./ch12/generate`目录内使用`goGenerate.go`生成下一个输出：
- en: '[PRE119]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: This is the output of the `$GOFILE`, `$GOARCH`, `$GOOS`, `$GOLINE`, and `$GOPACKAGE`
    variables, which shows the values of these variables defined at runtime.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`$GOFILE`、`$GOARCH`、`$GOOS`、`$GOLINE`和`$GOPACKAGE`变量的输出，它显示了这些变量在运行时的值。
- en: '[PRE120]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: There is also a special variable named `$DOLLAR` for printing a dollar character
    in the output because `$` has a special meaning in the OS environment.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个名为`$DOLLAR`的特殊变量，用于在输出中打印美元字符，因为在操作系统环境中`$`有特殊含义。
- en: '[PRE121]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: This is the output of the `ls -l` command, which shows the files found in the
    current directory at the time of the code execution. This can be used to test
    whether some necessary files are present at the time of execution or not.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`ls -l`命令的输出，它显示了代码执行时的当前目录中的文件。这可以用来测试在执行时是否有一些必要的文件存在。
- en: '[PRE122]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Running `go generate` with `-n` shows the commands that are going to be executed:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-n`选项运行`go generate`会显示将要执行的命令：
- en: '[PRE123]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: So, `go:generate` can help you work with the OS **before program execution**.
    However, as it hides things from the developer, its usage should be limited.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`go:generate`可以在程序执行前与操作系统交互。然而，由于它隐藏了某些内容，其使用应该受到限制。
- en: The last section of this chapter talks about example functions.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后部分讨论示例函数。
- en: Creating example functions
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建示例函数
- en: Part of the documentation process is generating example code that showcases
    the use of some or all the functions and data types of a package. Example functions
    have many benefits, including the fact that they are executable tests that are
    executed by `go test`. Therefore, if an example function contains an `// Output:`
    line, the `go test` tool checks whether the calculated output matches the values
    found after the `// Output:` line. Although we should include example functions
    in Go files that end with `_test.go`, we do not need to import the testing Go
    package for example functions. Moreover, the name of each example function must
    begin with `Example`. Lastly, example functions take no input parameters and return
    no results.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 文档过程的一部分是生成示例代码，展示了一个包中某些或所有函数和数据类型的使用。示例函数有许多好处，包括它们是可执行的测试，由`go test`执行。因此，如果一个示例函数包含`//
    Output:`行，`go test`工具将检查计算出的输出是否与`// Output:`行之后找到的值匹配。尽管我们应该将示例函数包含在以`_test.go`结尾的Go文件中，但我们不需要为示例函数导入测试Go包。此外，每个示例函数的名称必须以`Example`开头。最后，示例函数不接收任何输入参数，也不返回任何结果。
- en: 'We are going to illustrate example functions using the code of `exampleFunctions.go`
    and `exampleFunctions_test.go`. The content of `exampleFunctions.go` is as follows:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`exampleFunctions.go`和`exampleFunctions_test.go`的代码来展示示例函数。`exampleFunctions.go`的内容如下：
- en: '[PRE124]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The previous code presents a regular package that contains a single function
    named `LengthRange()`. The contents of `exampleFunctions_test.go`, which includes
    the example functions, are the following:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码展示了一个包含一个名为`LengthRange()`的单个函数的常规包。`exampleFunctions_test.go`的内容，包括示例函数，如下所示：
- en: '[PRE125]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'What the comment lines say is that the expected output is `7` and `7`, which
    is obviously wrong. This is going to be seen after we run `go test`:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 注释行说明预期的输出是`7`和`7`，这显然是错误的。这将在我们运行`go test`后看到：
- en: '[PRE126]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'As expected, there is an error in the generated output—the second generated
    value is `26` instead of the expected `7`. If we make the necessary corrections,
    the output is going to look as follows:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，生成的输出中存在一个错误——第二个生成的值是`26`，而不是预期的`7`。如果我们进行必要的修正，输出将如下所示：
- en: '[PRE127]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Example functions can be a great tool both for learning the capabilities of
    a package and for testing the correctness of functions, so I suggest that you
    include both test code and example functions in your Go packages. As a bonus,
    your test functions appear in the documentation of the package, if you decide
    to generate package documentation.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 示例函数可以是学习包功能以及测试函数正确性的一个很好的工具，所以我建议你在你的 Go 包中包含测试代码和示例函数。作为额外的好处，如果你的测试函数出现在包的文档中，那么你可以选择生成包文档。
- en: Summary
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter discussed `go:generate`, code profiling and tracing, and testing
    Go code. You might find the Go way of testing boring, but this happens because
    Go is boring and predictable in general and that is a good thing! Remember that
    writing bug-free code is important, whereas writing the fastest code possible
    is not always that important.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了 `go:generate`、代码分析和跟踪以及测试 Go 代码。你可能觉得 Go 的测试方式很无聊，但这正是因为 Go 在总体上既无聊又可预测，而这是一件好事！记住，编写无错误的代码很重要，而编写尽可能快的代码并不总是那么重要。
- en: Most of the time, you need to be able to write fast-enough code. So, spend more
    time writing tests than benchmarks, unless your code runs really slowly. You have
    also learned how to find unreachable code and how to cross-compile Go code.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，你需要能够编写足够快的代码。所以，花更多的时间写测试而不是基准测试，除非你的代码运行得真的很慢。你也已经学会了如何找到不可达的代码以及如何交叉编译
    Go 代码。
- en: Although the discussions of the Go profiler and `go tool trace` are far from
    complete, you should understand that with topics such as profiling and code tracing,
    nothing can replace experimenting and trying new techniques on your own!
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管关于 Go 分析器和 `go tool trace` 的讨论远未完成，但你应该明白，在诸如分析、代码跟踪等主题上，没有什么能取代亲自实验和尝试新技术的经验！
- en: The next chapter is about fuzz testing, which is a modern way of testing Go
    code in addition to the testing techniques presented in this chapter. We will
    also look at observability in Go.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍模糊测试，这是本章中介绍测试技术之外的另一种现代测试 Go 代码的方法。我们还将探讨 Go 中的可观察性。
- en: Exercises
  id: totrans-454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Create test functions for a package that calculates numbers in the Fibonacci
    sequence. Do not forget to implement the package.
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为计算斐波那契数列的包创建测试函数。不要忘记实现该包。
- en: The code in `testHTTP/server_test.go` uses the same value for `lastlogin` in
    the `expected` variable. This is clearly a bug in `restdb.go` as the value of
    `lastlogin` should be updated. After correcting the bug, modify `testHTTP/server_test.go`
    to take into account the different values of the `lastlogin` field.
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testHTTP/server_test.go` 中的代码在 `expected` 变量中使用相同的 `lastlogin` 值。这显然是 `restdb.go`
    中的一个错误，因为 `lastlogin` 的值应该被更新。在修复错误后，修改 `testHTTP/server_test.go` 以考虑 `lastlogin`
    字段的不同值。'
- en: Try to find the value of `os.TempDir()` in various operating systems.
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试在各个操作系统下找到 `os.TempDir()` 的值。
- en: Type `go doc os/signal.NotifyContext` to see that you can handle signals in
    a `context.Context` environment. Try to create an example that uses `signal.NotifyContext`.
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入 `go doc os/signal.NotifyContext` 以查看你可以在 `context.Context` 环境中处理信号。尝试创建一个使用
    `signal.NotifyContext` 的示例。
- en: Additional resources
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'The `generate` package: [https://pkg.go.dev/cmd/go/internal/generate](https://pkg.go.dev/cmd/go/internal/generate)'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generate` 包：[https://pkg.go.dev/cmd/go/internal/generate](https://pkg.go.dev/cmd/go/internal/generate)'
- en: 'Generating code: [https://go.dev/blog/generate](https://go.dev/blog/generate)'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成代码：[https://go.dev/blog/generate](https://go.dev/blog/generate)
- en: 'The code of `testing`: [https://go.dev/src/testing/testing.go](https://go.dev/src/testing/testing.go)'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testing` 的代码：[https://go.dev/src/testing/testing.go](https://go.dev/src/testing/testing.go)'
- en: 'About `net/http/httptrace`: [https://pkg.go.dev/net/http/httptrace](https://pkg.go.dev/net/http/httptrace)'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '关于 `net/http/httptrace`: [https://pkg.go.dev/net/http/httptrace](https://pkg.go.dev/net/http/httptrace)'
- en: 'Profile-guided optimization in Go 1.21: [https://go.dev/blog/pgo](https://go.dev/blog/pgo)'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 1.21 中的基于配置的优化：[https://go.dev/blog/pgo](https://go.dev/blog/pgo)
- en: 'Govulncheck v1.0.0 is released: [https://go.dev/blog/govulncheck](https://go.dev/blog/govulncheck)'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Govulncheck v1.0.0 已发布：[https://go.dev/blog/govulncheck](https://go.dev/blog/govulncheck)
- en: 'The `govulncheck` tool: [https://pkg.go.dev/golang.org/x/vuln/cmd/govulncheck](https://pkg.go.dev/golang.org/x/vuln/cmd/govulncheck)'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`govulncheck` 工具：[https://pkg.go.dev/golang.org/x/vuln/cmd/govulncheck](https://pkg.go.dev/golang.org/x/vuln/cmd/govulncheck)'
- en: 'A `govulncheck` tutorial: [https://go.dev/doc/tutorial/govulncheck](https://go.dev/doc/tutorial/govulncheck)'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`govulncheck` 教程：[https://go.dev/doc/tutorial/govulncheck](https://go.dev/doc/tutorial/govulncheck)'
- en: 'Build more secure apps with Go and Google: [https://www.youtube.com/watch?v=HSt6FhsPT8c](https://www.youtube.com/watch?v=HSt6FhsPT8c)'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Go 和 Google 构建更安全的应用程序：[https://www.youtube.com/watch?v=HSt6FhsPT8c](https://www.youtube.com/watch?v=HSt6FhsPT8c)
- en: 'Introducing HTTP Tracing by Jaana Dogan: [https://go.dev/blog/http-tracing](https://go.dev/blog/http-tracing)'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 HTTP 追踪，作者 Jaana Dogan：[https://go.dev/blog/http-tracing](https://go.dev/blog/http-tracing)
- en: 'GopherCon 2019: Dave Cheney—Two Go Programs, Three Different Profiling Techniques:
    [https://youtu.be/nok0aYiGiYA](https://youtu.be/nok0aYiGiYA )'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GopherCon 2019：Dave Cheney—两个 Go 程序，三种不同的性能分析技术：[https://youtu.be/nok0aYiGiYA](https://youtu.be/nok0aYiGiYA)
- en: Join our community on Discord
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://discord.gg/FzuQbc8zd6](https://discord.gg/FzuQbc8zd6 )'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/FzuQbc8zd6](https://discord.gg/FzuQbc8zd6)'
- en: '[![](img/QR_Code2286825896190168453.png)](https://discord.gg/FzuQbc8zd6 )'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](img/QR_Code2286825896190168453.png)](https://discord.gg/FzuQbc8zd6)'
