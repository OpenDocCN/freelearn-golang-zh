["```go\npackage main\nimport (\n    \"fmt\"\n)\nfunc AddInt(x, y int) int {\n    for i := 0; i < x; i++ {\n        y = y + 1\n    }\n    return y\n}\nfunc main() {\n    fmt.Println(AddInt(5, 4))\n} \n```", "```go\npackage main\nimport (\n    \"testing\"\n)\nfunc TestAddInt(t *testing.T) {\n    testCases := []struct {\n        x, y, want int\n    }{\n        {1, 2, 3},\n        {1, 0, 1},\n        {100, 10, 110},\n    }\n    for _, tc := range testCases {\n        result := AddInt(tc.x, tc.y)\n        if result != tc.want {\n            t.Errorf(\"X: %d, Y: %d, want %d\", tc.x, tc.y, tc.want)\n        }\n    }\n} \n```", "```go\nfunc **FuzzAddInt**(f *testing.F) {\n    testCases := []struct {\n        x, y int\n    }{\n        {0, 1},\n        {0, 100},\n    }\n    for _, tc := range testCases {\n        f.Add(tc.x, tc.y)\n    } \n```", "```go\n f.Fuzz(func(t *testing.T, x, y int) {\n        result := AddInt(x, y)\n        if result != x+y {\n            t.Errorf(\"X: %d, Y: %d, Result %d, want %d\", x, y, result, x+y)\n        }\n    })\n} \n```", "```go\n$ go test *.go\nok    command-line-arguments    0.427s \n```", "```go\n$ go test -fuzz=FuzzAddInt *.go\nfuzz: elapsed: 0s, gathering baseline coverage: 0/2 completed\nfuzz: elapsed: 0s, gathering baseline coverage: 2/2 completed, now fuzzing with 10 workers\nfuzz: elapsed: 0s, execs: 6 (410/sec), new interesting: 2 (total: 4)\n--- FAIL: FuzzAddInt (0.02s)\n    --- FAIL: FuzzAddInt (0.00s)\n        code_test.go:40: X: -63, Y: 32, Result 32, want -31\n    **Failing input written to testdata/fuzz/FuzzAddInt/b403d5353f8afe03**\n    To re-run:\n    go test -run=FuzzAddInt/b403d5353f8afe03\nFAIL\nexit status 1\nFAIL    command-line-arguments    0.222s \n```", "```go\n$ cat testdata/fuzz/FuzzAddInt/b403d5353f8afe03\ngo test fuzz v1\nint(-63)\nint(32) \n```", "```go\npackage main\n**// This version has bugs**\nimport (\n    \"fmt\"\n)\nfunc R1(s string) []byte {\n    sAr := []byte(sAr)\n    rev := make([]byte, len(s))\n    l := len(sAr)\n    for i := 0; i < l; i++ {\n        rev[i] = sAr[l-1-i]\n    }\n    return rev\n} \n```", "```go\nfunc R2(s string) string {\n    b := []byte(s)\n    for i, j := 0, len(b)-1; i < len(b)/2; i, j = i+1, j-1 {\n        b[i], b[j] = b[j], b[i]\n    }\n    return string(b)\n} \n```", "```go\nfunc main() {\n    str := \"1234567890\"\n    fmt.Println(string(R1(str)))\n    fmt.Println(R2(str))\n} \n```", "```go\n$ go run reverse.go\n0987654321\n0987654321 \n```", "```go\npackage main\nimport (\n    \"testing\"\n\"unicode/utf8\"\n)\nfunc TestR1(t *testing.T) {\n    testCases := []struct {\n        in, want string\n    }{\n        {\" \", \" \"},\n        {\"!12345@\", \"@54321!\"},\n        {\"Mastering Go\", \"oG gniretsaM\"},\n    }\n    for _, tc := range testCases {\n        rev := R1(tc.in)\n        if string(rev) != tc.want {\n            t.Errorf(\"Reverse: %q, want %q\", rev, tc.want)\n        }\n    }\n} \n```", "```go\nfunc TestR2(t *testing.T) {\n    testCases := []struct {\n        in, want string\n    }{\n        {\" \", \" \"},\n        {\"!12345@\", \"@54321!\"},\n        {\"Mastering Go\", \"oG gniretsaM\"},\n    }\n    for _, tc := range testCases {\n        rev := R2(tc.in)\n        if rev != tc.want {\n            t.Errorf(\"Reverse: %q, want %q\", rev, tc.want)\n        }\n    }\n} \n```", "```go\nfunc FuzzR1(f *testing.F) {\n    testCases := []string{\"Hello, world\", \" \", \"!12345\"}\n    for _, tc := range testCases {\n        f.Add(tc)\n    }\n    f.Fuzz(func(t *testing.T, orig string) {\n        rev := R1(orig)\n        doubleRev := R1(string(rev))\n        if orig != string(doubleRev) {\n            t.Errorf(\"Before: %q, after: %q\", orig, doubleRev)\n        }\n        if utf8.ValidString(orig) && !utf8.ValidString(string(rev)) {\n            t.Errorf(\"Reverse: invalid UTF-8 string %q\", rev)\n        }\n    })\n} \n```", "```go\nfunc FuzzR2(f *testing.F) {\n    testCases := []string{\"Hello, world\", \" \", \"!12345\"}\n    for _, tc := range testCases {\n        f.Add(tc)\n    }\n    f.Fuzz(func(t *testing.T, orig string) {\n        rev := R2(orig)\n        doubleRev := R2(rev)\n        if orig != doubleRev {\n            t.Errorf(\"Before: %q, after: %q\", orig, doubleRev)\n        }\n        if utf8.ValidString(orig) && !utf8.ValidString(rev) {\n            t.Errorf(\"Reverse: invalid UTF-8 string %q\", rev)\n        }\n    })\n} \n```", "```go\n$ go test *.go\nok    command-line-arguments    0.103s \n```", "```go\n$ go test -fuzz=FuzzR1 *.go\nfuzz: elapsed: 0s, gathering baseline coverage: 0/7 completed\nfuzz: elapsed: 0s, gathering baseline coverage: 7/7 completed, now fuzzing with 10 workers\nfuzz: minimizing 30-byte failing input file\nfuzz: elapsed: 0s, minimizing\n--- FAIL: FuzzR1 (0.03s)\n    --- FAIL: FuzzR1 (0.00s)\n        reverse_test.go:55: Reverse: invalid UTF-8 string \"\\x94\\xd4\"\n    Failing input written to testdata/fuzz/FuzzR1/a256ceb5e3bf582f\n    To re-run:\n    go test -run=FuzzR1/a256ceb5e3bf582f\nFAIL\nexit status 1\nFAIL    command-line-arguments    0.493s \n```", "```go\n$ cat testdata/fuzz/FuzzR1/a256ceb5e3bf582f\ngo test fuzz v1\nstring(\"Ô”\") \n```", "```go\n$ go test -fuzz=FuzzR2 *.go\n--- FAIL: FuzzR1 (0.00s)\n    --- FAIL: FuzzR1/a256ceb5e3bf582f (0.00s)\n        reverse_test.go:55: Reverse: invalid UTF-8 string \"\\x94\\xd4\"\nFAIL\nexit status 1\nFAIL    command-line-arguments    0.253s \n```", "```go\npackage main\nimport (\n    \"errors\"\n\"fmt\"\n\"unicode/utf8\"\n)\nfunc R1(s string) (string, error) {\n    if !utf8.ValidString(s) {\n        return s, errors.New(\"Invalid UTF-8\")\n    }\n    a := []byte(s)\n    for i, j := 0, len(s)-1; i < j; i++ {\n        a[i], a[j] = a[j], a[i]\n        j--\n    }\n    return string(a), nil\n}\nfunc R2(s string) (string, error) {\n    if !utf8.ValidString(s) {\n        return s, errors.New(\"Invalid UTF-8\")\n    }\n    r := []rune(s)\n    for i, j := 0, len(r)-1; i < len(r)/2; i, j = i+1, j-1 {\n        r[i], r[j] = r[j], r[i]\n    }\n    return string(r), nil\n} \n```", "```go\nfunc main() {\n    str := \"1234567890\"\n    R1ret, _ := R1(str)\n    fmt.Println(R1ret)\n    R2ret, _ := R2(str)\n    fmt.Println(R2ret)\n} \n```", "```go\n$ go run correct.go\n0987654321\n0987654321 \n```", "```go\npackage main\nimport (\n    \"testing\"\n\"unicode/utf8\"\n)\nfunc TestR1(t *testing.T) {\n    testCases := []struct {\n        in, want string\n    }{\n        {\" \", \" \"},\n        {\"!12345@\", \"@54321!\"},\n        {\"Mastering Go\", \"oG gniretsaM\"},\n    }\n    for _, tc := range testCases {\n        rev, err := R1(tc.in)\n        if err != nil {\n            return\n        }\n        if rev != tc.want {\n            t.Errorf(\"Reverse: %q, want %q\", rev, tc.want)\n        }\n    }\n}\nfunc TestR2(t *testing.T) {\n    testCases := []struct {\n        in, want string\n    }{\n        {\" \", \" \"},\n        {\"!12345@\", \"@54321!\"},\n        {\"Mastering Go\", \"oG gniretsaM\"},\n    }\n    for _, tc := range testCases {\n        rev, err := R2(tc.in)\n        if err != nil {\n            return\n        }\n        if rev != tc.want {\n            t.Errorf(\"Reverse: %q, want %q\", rev, tc.want)\n        }\n    }\n} \n```", "```go\nfunc FuzzR1(f *testing.F) {\n    testCases := []string{\"Hello, world\", \" \", \"!12345\"}\n    for _, tc := range testCases {\n        f.Add(tc)\n    }\n    f.Fuzz(func(t *testing.T, orig string) {\n        rev, err := R1(orig)\n        if err != nil {\n            return\n        }\n        doubleRev, err := R1(rev)\n        if err != nil {\n            return\n        }\n        if orig != doubleRev {\n            t.Errorf(\"Before: %q, after: %q\", orig, doubleRev)\n        }\n        if utf8.ValidString(orig) && !utf8.ValidString(string(rev)) {\n            t.Errorf(\"Reverse: invalid UTF-8 string %q\", rev)\n        }\n    })\n} \n```", "```go\nfunc FuzzR2(f *testing.F) {\n    testCases := []string{\"Hello, world\", \" \", \"!12345\"}\n    for _, tc := range testCases {\n        f.Add(tc)\n    }\n    f.Fuzz(func(t *testing.T, orig string) {\n        rev, err := R2(orig)\n        if err != nil {\n            return\n        }\n        doubleRev, err := R2(**string**(rev))\n        if err != nil {\n            return\n        }\n        if orig != doubleRev {\n            t.Errorf(\"Before: %q, after: %q\", orig, doubleRev)\n        }\n        if utf8.ValidString(orig) && !utf8.ValidString(rev) {\n            t.Errorf(\"Reverse: invalid UTF-8 string %q\", rev)\n        }\n    })\n} \n```", "```go\n$ go test *.go\nok    command-line-arguments    0.609s \n```", "```go\n$ go test -fuzz=FuzzR1 *.go -fuzztime 10s\nfuzz: elapsed: 0s, gathering baseline coverage: 0/15 completed\nfuzz: elapsed: 0s, gathering baseline coverage: 15/15 completed, now fuzzing with 10 workers\nfuzz: elapsed: 3s, execs: 1129701 (376437/sec), new interesting: 31 (total: 46)\nfuzz: elapsed: 6s, execs: 2527522 (466068/sec), new interesting: 34 (total: 49)\nfuzz: elapsed: 9s, execs: 3808349 (426919/sec), new interesting: 37 (total: 52)\nfuzz: elapsed: 11s, execs: 4208389 (199790/sec), new interesting: 37 (total: 52)\nPASS\nok    command-line-arguments    11.508s \n```", "```go\n$ go test -fuzz=FuzzR2 *.go -fuzztime 10s\nfuzz: elapsed: 0s, gathering baseline coverage: 0/3 completed\nfuzz: elapsed: 0s, gathering baseline coverage: 3/3 completed, now fuzzing with 10 workers\nfuzz: elapsed: 3s, execs: 1271973 (423844/sec), new interesting: 38 (total: 41)\nfuzz: elapsed: 6s, execs: 2638924 (455741/sec), new interesting: 39 (total: 42)\nfuzz: elapsed: 9s, execs: 4044955 (468745/sec), new interesting: 39 (total: 42)\nfuzz: elapsed: 10s, execs: 4495553 (413586/sec), new interesting: 39 (total: 42)\nPASS\nok    command-line-arguments    10.396s \n```", "```go\ntype Sample struct {\n    Name string\n    Value Value\n} \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"runtime/metrics\"\n\"sync\"\n\"time\"\n)\nfunc main() {\n    const nGo = \"/sched/goroutines:goroutines\" \n```", "```go\n getMetric := make([]metrics.Sample, 1)\n    getMetric[0].Name = nGo \n```", "```go\n var wg sync.WaitGroup\n    for i := 0; i < 3; i++ {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n            time.Sleep(4 * time.Second)\n        }() \n```", "```go\n // Get actual data\n        metrics.Read(getMetric)\n        if getMetric[0].Value.Kind() == metrics.KindBad {\n            fmt.Printf(\"metric %q no longer supported\\n\", nGo)\n        } \n```", "```go\n mVal := getMetric[0].Value.Uint64()\n        fmt.Printf(\"Number of goroutines: %d\\n\", mVal)\n    } \n```", "```go\n wg.Wait()\n    metrics.Read(getMetric)\n    mVal := getMetric[0].Value.Uint64()\n    fmt.Printf(\"Before exiting: %d\\n\", mVal)\n} \n```", "```go\n$ go run metrics.go\nNumber of goroutines: 2\nNumber of goroutines: 3\nNumber of goroutines: 4\nBefore exiting: 1 \n```", "```go\npackage main\nimport (\n    \"log/slog\"\n\"os\"\n\"time\"\n)\nfunc myFunction() {\n    j := 0\nfor i := 1; i < 100000000; i++ {\n        j = j % i\n    }\n} \n```", "```go\nfunc main() {\n    handler := slog.NewTextHandler(os.Stdout, nil)\n    logger := slog.New(handler)\n    logger.Debug(\"This is a DEBUG message\")\n    for i := 0; i < 5; i++ {\n        now := time.Now()\n        myFunction()\n        elapsed := time.Since(now)\n        logger.Info(\n            \"Observability\",\n            slog.Int64(\"time_taken\", int64(elapsed)),\n        )\n    }\n} \n```", "```go\n$ go run functionTime.go\ntime=2023-12-30T11:33:36.471+02:00 level=INFO msg=Observability time_taken=51243083\ntime=2023-12-30T11:33:36.505+02:00 level=INFO msg=Observability time_taken=34088708\ntime=2023-12-30T11:33:36.536+02:00 level=INFO msg=Observability time_taken=31203083\ntime=2023-12-30T11:33:36.568+02:00 level=INFO msg=Observability time_taken=31224625\ntime=2023-12-30T11:33:36.599+02:00 level=INFO msg=Observability time_taken=31206208 \n```", "```go\npackage main\nimport (\n    \"expvar\"\n\"fmt\"\n\"net/http\"\n)\nfunc main() {\n    intVar := expvar.NewInt(\"intVar\")\n    intVar.Set(1234)\n    expvar.Publish(\"customFunction\", expvar.Func(func() interface{} {\n        return \"Hi from Mastering Go!\"\n    })) \n```", "```go\n http.Handle(\"/debug/expvars\", expvar.Handler())\n    go func() {\n        fmt.Println(\"HTTP server listening on :8080\")\n        err := http.ListenAndServe(\":8080\", nil)\n        if err != nil {\n            fmt.Println(\"Error starting HTTP server:\", err)\n        }\n    }()\n    intVar.Add(10)\n    select {}\n} \n```", "```go\n$ curl -X GET http://localhost:8080/debug/expvars\n{\n\"cmdline\": [\"/var/folders/sk/ltk8cnw50lzdtr2hxcj5sv2m0000gn/T/go-build4228023601/b001/exe/expvarUse\"],\n\"customFunction\": \"Hi from Mastering Go!\",\n\"intVar\": 1244, \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"strings\"\n    . \"github.com/klauspost/cpuid/v2\"\n)\nfunc main() {\n    // Print basic CPU information:\n    fmt.Println(\"Name:\", CPU.BrandName)\n    fmt.Println(\"PhysicalCores:\", CPU.PhysicalCores)\n    fmt.Println(\"LogicalCores:\", CPU.LogicalCores)\n    fmt.Println(\"ThreadsPerCore:\", CPU.ThreadsPerCore)\n    fmt.Println(\"Family\", CPU.Family, \"Model:\", CPU.Model, \"Vendor ID:\", CPU.VendorID)\n    fmt.Println(\"Features:\", strings.Join(CPU.FeatureSet(), \",\"))\n    fmt.Println(\"Cacheline bytes:\", CPU.CacheLine)\n    fmt.Println(\"L1 Data Cache:\", CPU.Cache.L1D, \"bytes\")\n    fmt.Println(\"L1 Instruction Cache:\", CPU.Cache.L1I, \"bytes\")\n    fmt.Println(\"L2 Cache:\", CPU.Cache.L2, \"bytes\")\n    fmt.Println(\"L3 Cache:\", CPU.Cache.L3, \"bytes\")\n    fmt.Println(\"Frequency\", CPU.Hz, \"hz\")\n} \n```", "```go\nName: Apple M1 Max\nPhysicalCores: 10\nLogicalCores: 10\nThreadsPerCore: 1\nFamily 458787763 Model: 0 Vendor ID: VendorUnknown\nFeatures: AESARM,ASIMD,ASIMDDP,ASIMDHP,ASIMDRDM,ATOMICS,CRC32,DCPOP,FCMA,FP,FPHP,GPA,JSCVT,LRCPC,PMULL,SHA1,SHA2,SHA3,SHA512\nCacheline bytes: 128\nL1 Data Cache: 65536 bytes\nL1 Instruction Cache: 131072 bytes\nL2 Cache: 4194304 bytes\nL3 Cache: -1 bytes\nFrequency 0 hz \n```", "```go\nName: Intel(R) Core(TM) i7-10510U CPU @ 1.80GHz\nPhysicalCores: 4\nLogicalCores: 8\nThreadsPerCore: 2\nFamily 6 Model: 142 Vendor ID: Intel\nFeatures: ADX,AESNI,AVX,AVX2,BMI1,BMI2,CLMUL,CMOV,CMPXCHG8,CX16,ERMS,F16C,FLUSH_L1D,FMA3,FXSR,FXSROPT,HTT,IA32_ARCH_CAP,IBPB,LAHF,LZCNT,MD_CLEAR,MMX,MOVBE,MPX,NX,OSXSAVE,POPCNT,RDRAND,RDSEED,RDTSCP,SGX,SPEC_CTRL_SSBD,SSE,SSE2,SSE3,SSE4,SSE42,SSSE3,STIBP,SYSCALL,SYSEE,VMX,X87,XGETBV1,XSAVE,XSAVEC,XSAVEOPT,XSAVES\nCacheline bytes: 64\nL1 Data Cache: 32768 bytes\nL1 Instruction Cache: 32768 bytes\nL2 Cache: 262144 bytes\nL3 Cache: 8388608 bytes\nFrequency 2300000000 hz \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"net/http\"\n\"math/rand\"\n\"time\"\n\"github.com/prometheus/client_golang/prometheus\"\n\"github.com/prometheus/client_golang/prometheus/promhttp\"\n) \n```", "```go\nvar PORT = \":1234\"\nvar counter = prometheus.NewCounter(\n    prometheus.CounterOpts{\n        Namespace: \"mtsouk\",\n        Name:      \"my_counter\",\n        Help:      \"This is my counter\",\n    }) \n```", "```go\nvar gauge = prometheus.NewGauge(\n    prometheus.GaugeOpts{\n        Namespace: \"mtsouk\",\n        Name:      \"my_gauge\",\n        Help:      \"This is my gauge\",\n    }) \n```", "```go\nvar histogram = prometheus.NewHistogram(\n    prometheus.HistogramOpts{\n        Namespace: \"mtsouk\",\n        Name:      \"my_histogram\",\n        Help:      \"This is my histogram\",\n    }) \n```", "```go\nvar summary = prometheus.NewSummary(\n    prometheus.SummaryOpts{\n        Namespace: \"mtsouk\",\n        Name:      \"my_summary\",\n        Help:      \"This is my summary\",\n    }) \n```", "```go\nfunc main() {\n    prometheus.MustRegister(counter)\n    prometheus.MustRegister(gauge)\n    prometheus.MustRegister(histogram)\n    prometheus.MustRegister(summary) \n```", "```go\n go func() {\n        for {\n            counter.Add(rand.Float64() * 5)\n            gauge.Add(rand.Float64()*15 - 5)\n            histogram.Observe(rand.Float64() * 10)\n            summary.Observe(rand.Float64() * 10)\n            time.Sleep(2 * time.Second)\n        }\n    }() \n```", "```go\n http.Handle(\"/metrics\", promhttp.Handler())\n    fmt.Println(\"Listening to port\", PORT)\n    fmt.Println(http.ListenAndServe(PORT, nil))\n} \n```", "```go\n$ curl localhost:1234/metrics --silent | grep mtsouk\n# HELP mtsouk_my_counter This is my counter\n# TYPE mtsouk_my_counter counter\nmtsouk_my_counter 19.948239343027772 \n```", "```go\n# HELP mtsouk_my_gauge This is my gauge\n# TYPE mtsouk_my_gauge gauge\nmtsouk_my_gauge 29.335329668135287 \n```", "```go\n# HELP mtsouk_my_histogram This is my histogram\n# TYPE mtsouk_my_histogram histogram\nmtsouk_my_histogram_bucket{le=\"0.005\"} 0\nmtsouk_my_histogram_bucket{le=\"0.01\"} 0\nmtsouk_my_histogram_bucket{le=\"0.025\"} 0\n. . .\nmtsouk_my_histogram_bucket{le=\"5\"} 4\nmtsouk_my_histogram_bucket{le=\"10\"} 9\nmtsouk_my_histogram_bucket{le=\"+Inf\"} 9\nmtsouk_my_histogram_sum 44.52262035556937\nmtsouk_my_histogram_count 9 \n```", "```go\n# HELP mtsouk_my_summary This is my summary\n# TYPE mtsouk_my_summary summary\nmtsouk_my_summary_sum 19.407554729772105\nmtsouk_my_summary_count 9 \n```", "```go\nFROM golang:alpine AS builder\nRUN apk update && apk add --no-cache git \n```", "```go\nRUN mkdir $GOPATH/src/server\nADD ./samplePro.go $GOPATH/src/server \n```", "```go\nWORKDIR $GOPATH/src/server\nRUN go mod init\nRUN go mod tidy\nRUN go mod download\nRUN mkdir /pro\nRUN go build -o /pro/server samplePro.go \n```", "```go\nFROM alpine:latest\nRUN mkdir /pro\nCOPY --from=builder /pro/server /pro/server\nEXPOSE 1234\nWORKDIR /pro\nCMD [\"/pro/server\"] \n```", "```go\n$ docker build -f dFilev2 -t go-app122 . \n```", "```go\n$ docker buildx build -f dFilev2 -t go-app122 . \n```", "```go\n goapp:\nimage: go-app122\ncontainer_name: goapp-int\nrestart: always\nports:\n- 1234:1234\nnetworks:\n- monitoring \n```", "```go\npackage main\nimport (\n    \"log\"\n\"math/rand\"\n\"net/http\"\n\"runtime\"\n\"runtime/metrics\"\n\"time\"\n\"github.com/prometheus/client_golang/prometheus\"\n\"github.com/prometheus/client_golang/prometheus/promhttp\"\n) \n```", "```go\nvar PORT = \":1234\"\nvar nGoroutines = prometheus.NewGauge(\n    prometheus.GaugeOpts{\n        Namespace: \"packt\",\n        Name:      \"n_goroutines\",\n        Help:      \"Number of goroutines\"})\nvar nMemory = prometheus.NewGauge(\n    prometheus.GaugeOpts{\n        Namespace: \"packt\",\n        Name:      \"n_memory\",\n        Help:      \"Memory usage\"}) \n```", "```go\nfunc main() {\n    prometheus.MustRegister(nGoroutines)\n    prometheus.MustRegister(nMemory)\n    const nGo = \"/sched/goroutines:goroutines\"\nconst nMem = \"/memory/classes/heap/free:bytes\" \n```", "```go\n getMetric := make([]metrics.Sample, 2)\n    getMetric[0].Name = nGo\n    getMetric[1].Name = nMem\n    http.Handle(\"/metrics\", promhttp.Handler()) \n```", "```go\n go func() {\n        for {\n            for i := 1; i < 4; i++ {\n                go func() {\n                    _ = make([]int, 1000000)\n                    time.Sleep(time.Duration(rand.Intn(10)) * time.Second)\n                }()\n            } \n```", "```go\n runtime.GC()\n            metrics.Read(getMetric)\n            goVal := getMetric[0].Value.Uint64()\n            memVal := getMetric[1].Value.Uint64()\n            time.Sleep(time.Duration(rand.Intn(15)) * time.Second)\n            **nGoroutines.Set**(float64(goVal))\n            **nMemory.Set**(float64(memVal))\n        }\n    }() \n```", "```go\n log.Println(\"Listening to port\", PORT)\n    log.Println(http.ListenAndServe(PORT, nil))\n} \n```", "```go\n$ go mod init\n$ go mod tidy\n$ go mod download\n$ go run prometheus.go\n2024/01/01 19:18:11 Listening to port :1234 \n```", "```go\n$ curl localhost:1234/metrics --silent | grep packt\n# HELP packt_n_goroutines Number of goroutines\n# TYPE packt_n_goroutines gauge\npackt_n_goroutines 6\n# HELP packt_n_memory Memory usage\n# TYPE packt_n_memory gauge\npackt_n_memory 4.8799744e+07 \n```", "```go\nFROM golang:alpine AS builder \n```", "```go\nRUN apk update && apk add --no-cache git\nRUN mkdir $GOPATH/src/server\nADD ./prometheus.go $GOPATH/src/server\nWORKDIR $GOPATH/src/server\nRUN go mod init\nRUN go mod tidy\nRUN go mod download \n```", "```go\nRUN mkdir /pro\nRUN go build -o /pro/server prometheus.go\n**FROM** **alpine:latest**\nRUN mkdir /pro\nCOPY --from=builder /pro/server /pro/server\nEXPOSE 1234\nWORKDIR /pro\nCMD [\"/pro/server\"] \n```", "```go\n$ docker build -f Dockerfile -t goapp . \n```", "```go\n$ docker buildx build -f Dockerfile -t goapp . \n```", "```go\ngoapp             latest           6f63d9a27185   2 minutes ago   17.8MB \n```", "```go\n# prometheus.yml\nscrape_configs:\n- job_name: GoServer\nscrape_interval: 5s\nstatic_configs:\n- targets: ['goapp:1234'] \n```", "```go\nversion: \"3\"\nservices:\ngoapp:\nimage: goapp\ncontainer_name: goapp\nrestart: always\nports:\n- 1234:1234\nnetworks:\n- monitoring \n```", "```go\n prometheus:\nimage: prom/prometheus:latest\ncontainer_name: prometheus\nrestart: always\nuser: \"0\"\nvolumes:\n- ./prometheus/:/etc/prometheus/ \n```", "```go\n - ./prometheus_data/:/prometheus/\ncommand:\n- '--config.file=/etc/prometheus/prometheus.yml' \n```", "```go\n - '--storage.tsdb.path=/prometheus'\n- '--web.console.libraries=/etc/prometheus/console_libraries'\n- '--web.console.templates=/etc/prometheus/consoles'\n- '--storage.tsdb.retention.time=200h'\n- '--web.enable-lifecycle'\nports:\n- 9090:9090\nnetworks:\n- monitoring \n```", "```go\n grafana:\nimage: grafana/grafana\ncontainer_name: grafana\ndepends_on:\n- prometheus\nrestart: always\nuser: \"0\"\nports:\n- 3000:3000\nenvironment:\n- GF_SECURITY_ADMIN_PASSWORD=helloThere \n```", "```go\n - GF_USERS_ALLOW_SIGN_UP=false\n- GF_PANELS_DISABLE_SANITIZE_HTML=true\n- GF_SECURITY_ALLOW_EMBEDDING=true\nnetworks:\n- monitoring\nvolumes:\n- ./grafana_data/:/var/lib/grafana/\nvolumes:\ngrafana_data: {}\n    prometheus_data: {} \n```", "```go\nnetworks:\nmonitoring:\ndriver: bridge \n```"]