- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Fuzz Testing and Observability
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模糊测试与可观察性
- en: The subject of this chapter is twofold. First, we are going to talk about *fuzz
    testing*, which is a recent Go feature that improves the testing process, and
    second, we are going to talk about *observability*, which can help you understand
    what is going on when everything is working as expected but slower than desired.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主题有两个方面。首先，我们将讨论*模糊测试*，这是 Go 语言的一个新特性，它改进了测试过程；其次，我们将讨论*可观察性*，这可以帮助你理解当一切按预期进行但速度不如预期时，系统正在发生什么。
- en: With fuzz testing, we bring the unexpected to testing. The main benefit is that
    you get to test your code using random and unpredicted values and data, which
    might lead to detecting unknown vulnerabilities. This also leads to improved test
    coverage, better automation and efficiency in testing, better continuous testing,
    improved software quality, and cost-effective security testing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过模糊测试，我们将意外事件引入测试。主要好处是你可以使用随机和不可预测的值和数据来测试你的代码，这可能导致发现未知漏洞。这也导致了测试覆盖率的提高，测试自动化和效率的提升，更好的持续测试，软件质量的提高，以及成本效益高的安全测试。
- en: Observability refers to the ability to understand, measure, and analyze the
    internal state and behavior of a system based on its external outputs or observable
    signals. In the context of computer systems and software applications, observability
    is crucial for monitoring, troubleshooting, and maintaining the health and performance
    of the system. So, observability helps us find out more about the unseen sides
    of a program.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察性指的是根据系统的外部输出或可观察信号来理解、测量和分析系统内部状态和行为的能力。在计算机系统和软件应用的情况下，可观察性对于监控、故障排除和维护系统的健康和性能至关重要。因此，可观察性帮助我们了解程序未知的方面。
- en: The first rule of observability is **knowing what you are looking for**. This
    means that if you do not know what to look for, you might end up collecting the
    wrong data, overlook the useful metrics, and concentrate on the irrelevant ones!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察性的第一规则是**知道你在寻找什么**。这意味着如果你不知道要寻找什么，你可能会收集错误的数据，忽略有用的指标，而专注于无关紧要的指标！
- en: Additionally, reading metrics without storing and visualizing them is not effective.
    Therefore, this chapter also illustrates how to expose your metrics to Prometheus
    and how to visualize data stored in Prometheus using Grafana. Keep in mind that
    Prometheus is not the only software for storing time series data. One alternative
    to Prometheus is Elasticsearch. In that case, you might need to use Kibana instead
    of Grafana. What is important is that the key ideas remain the same.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，读取指标而不存储和可视化它们是无效的。因此，本章还说明了如何将你的指标暴露给 Prometheus，以及如何使用 Grafana 可视化存储在 Prometheus
    中的数据。请记住，Prometheus 并不是存储时间序列数据的唯一软件。Prometheus 的一个替代方案是 Elasticsearch。在这种情况下，你可能需要使用
    Kibana 而不是 Grafana。重要的是关键思想保持一致。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Fuzz testing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊测试
- en: Observability
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察性
- en: Exposing metrics to Prometheus
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将指标暴露给 Prometheus
- en: We begin this chapter with fuzz testing.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从本章的模糊测试开始。
- en: Fuzz testing
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模糊测试
- en: As software engineers, we worry , not when things go as expected, but when unexpected
    things happen. One way to deal with the unexpected is fuzzing. Fuzzing (or fuzz
    testing) is a testing technique that generates invalid, unexpected, or random
    data on **programs that require input**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件工程师，我们担心的是意外事件，而不是事情按预期进行时。处理意外事件的一种方法就是模糊测试。模糊测试（或模糊测试）是一种测试技术，它为**需要输入的程序**生成无效、意外或随机数据。
- en: Fuzz testing is good at discovering security and vulnerability issues with code—manual
    testing is not always ideal as those tests may not account for all potential untrusted
    inputs, specifically invalid inputs that may break a system. However, fuzz testing
    cannot replace unit testing. This means that fuzz testing is not a panacea and
    cannot replace all other testing techniques. So, fuzz testing is more suitable
    for **testing code that parses input**, which includes cases such as buffer overflow
    and SQL injection.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试擅长发现代码中的安全和漏洞问题——手动测试并不总是理想的，因为这些测试可能不会考虑到所有潜在的不受信任的输入，特别是可能破坏系统的无效输入。然而，模糊测试不能取代单元测试。这意味着模糊测试不是万能的，不能取代所有其他测试技术。因此，模糊测试更适合**测试解析输入的代码**，这包括缓冲区溢出和
    SQL 注入等案例。
- en: 'The main advantages of fuzzing include the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试的主要优势包括以下内容：
- en: You can make sure that the code can handle invalid or random input.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以确保代码能够处理无效或随机输入。
- en: Bugs that are discovered with fuzzing may be severe and might indicate security
    risks.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过模糊测试发现的错误可能很严重，并可能表明存在安全风险。
- en: Malicious attackers often use fuzzing to locate vulnerabilities, so it is good
    to be prepared.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恶意攻击者经常使用模糊测试来定位漏洞，因此做好准备是好的。
- en: With fuzzing comes the `testing.F` data type in the same way that we use `testing.T`
    for testing and `testing.B` for benchmarking—benchmarking Go code is covered in
    *Chapter 14*, *Efficiency and Performance*. Additionally, fuzz testing functions
    begin with `Fuzz` just like testing functions begin with `Test`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与模糊测试一样，我们使用 `testing.T` 进行测试和 `testing.B` 进行基准测试——基准测试 Go 代码在 *第 14 章*，*效率和性能*
    中有所介绍。此外，模糊测试函数以 `Fuzz` 开头，就像测试函数以 `Test` 开头一样。
- en: When a fuzz testing run fails, the data that generated the issue is saved on
    disk under the `testdata` directory, and after that, even regular tests are going
    to fail—because they are going to use that data automatically—until we correct
    the relevant issues or bugs. Feel free to delete that `testdata` directory if
    you need to rerun your regular tests.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当模糊测试运行失败时，导致问题的数据将被保存在 `testdata` 目录下，之后，即使是常规测试也将失败——因为它们将自动使用那些数据——直到我们纠正相关的问题或错误。如果您需要重新运行常规测试，请随意删除该
    `testdata` 目录。
- en: The next subsection presents a simple example of fuzz testing.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节提供了一个模糊测试的简单示例。
- en: A simple fuzz testing example
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的模糊测试示例
- en: In this subsection, we are going to create a simple example that uses fuzz testing
    in order to better understand it. The relevant code is found under `ch13/fuzz`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将创建一个简单的示例，使用模糊测试来更好地理解它。相关的代码可以在 `ch13/fuzz` 下找到。
- en: 'For the purposes of this simple example, we are going to see code that tests
    a simple Go function that is found in `code.go`. The contents of `code.go` are
    the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个简单的示例，我们将查看测试 `code.go` 中简单 Go 函数的代码。`code.go` 的内容如下：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There is an issue here: `AddInt()` is not implemented properly because the
    `for` loop is not going to work when the `x` parameter has a negative value.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个问题：`AddInt()` 没有正确实现，因为当 `x` 参数为负值时，`for` 循环将不会工作。
- en: 'The `code_test.go` file with the tests is going to be presented in two parts.
    The first part comes with the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 包含测试的 `code_test.go` 文件将分为两部分。第一部分包含以下代码：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This first part implements a testing function in the usual way. However, in
    this case, we are only testing `AddInt()` using positive integers (natural numbers),
    which means that it is going to work without any issues.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分以通常的方式实现了一个测试函数。然而，在这种情况下，我们只使用正整数（自然数）测试 `AddInt()`，这意味着它将没有任何问题地工作。
- en: 'The second part of `code_test.go` contains the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`code_test.go` 的第二部分包含以下代码：'
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This part implements a fuzz testing function named `FuzzAddInt()`, which can
    be verified by the use of the `testing.F` data type as well as its name beginning
    with `Fuzz`. The `testing.F` data type provides the `Add()` and `Fuzz()` methods,
    which are used for providing the (optional) starting input and for running the
    actual fuzz tests, respectively.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分实现了一个名为 `FuzzAddInt()` 的模糊测试函数，可以通过 `testing.F` 数据类型的使用以及其以 `Fuzz` 开头的名称来验证。`testing.F`
    数据类型提供了 `Add()` 和 `Fuzz()` 方法，分别用于提供（可选的）起始输入和运行实际的模糊测试。
- en: The *corpus* is a collection of inputs that guide the fuzz testing process and
    is composed of two parts. The first part is the *seed corpus*, and the second
    part is the *generated corpus*. The *seed corpus* can be provided by `Add()` function
    calls and/or data in the `testdata/fuzz` directory. The *generated corpus* is
    completely machine generated. It is not mandatory to have a seed corpus.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*语料库* 是指导模糊测试过程的输入集合，由两部分组成。第一部分是 *种子语料库*，第二部分是 *生成语料库*。*种子语料库* 可以通过 `Add()`
    函数调用和/或 `testdata/fuzz` 目录中的数据提供。*生成语料库* 完全由机器生成。不需要有种子语料库。'
- en: The `Add()` function adds data to the *seed corpus* and can be called as many
    times as you want—in this case, we call `Add()` two times.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Add()` 函数将数据添加到 *种子语料库*，并且可以根据需要多次调用——在这种情况下，我们调用了 `Add()` 两次。'
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After the (optional) `Add()` function, we need to call `Fuzz()`, which requires
    a `*testing.T` variable as well as a list of fuzzing arguments, which should be
    the same number and have the same data type as the ones used in `Add()`, which
    are usually the same as the number of arguments in the function that is being
    tested.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在（可选的）`Add()` 函数之后，我们需要调用 `Fuzz()`，这需要一个 `*testing.T` 变量以及一个模糊参数列表，这些参数应该与 `Add()`
    中使用的参数数量和数据类型相同，通常与被测试函数的参数数量相同。
- en: Put simply, we embed regular testing functions in fuzz testing functions—it
    is the input for those regular testing functions that are provided by the fuzz
    testing process based on the generated corpus.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们在模糊测试函数中嵌入常规测试函数——这些常规测试函数的输入是由模糊测试过程根据生成的语料库提供的。
- en: So, we tell `f.Fuzz()` that we need two additional `int` parameters apart from
    the compulsory `*testing.T`, which are named `x` and `y`. These two parameters
    are the input of the tests. Because of that, the `f.Add()` call should also have
    two parameters.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们告诉 `f.Fuzz()` 我们需要两个额外的 `int` 参数，除了强制性的 `*testing.T` 之外，这两个参数分别命名为 `x`
    和 `y`。这两个参数是测试的输入。因此，`f.Add()` 调用也应该有两个参数。
- en: 'Running the regular tests is as simple as executing the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 运行常规测试就像执行以下命令一样简单：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So, the testing function revealed no issues with `AddInt()`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，测试函数没有发现 `AddInt()` 存在问题。
- en: 'Running the fuzz test requires the use of the `-fuzz` command line parameter
    followed by the name of the fuzz function. So, we need to execute the following
    command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 运行模糊测试需要使用 `-fuzz` 命令行参数，后跟模糊函数的名称。因此，我们需要执行以下命令：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So, the fuzz test caught the error with `AddInt()`. Put simply, the fuzz testing
    process included negative integers in the testing and caught a logical error generated
    by the use of the `for` loop—we did not!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，模糊测试捕获了 `AddInt()` 的错误。简单来说，模糊测试过程包括负整数在测试中，并捕获了由 `for` 循环的使用产生的逻辑错误——我们没有！
- en: 'The contents of `testdata/fuzz/FuzzAddInt/b403d5353f8afe03` are the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`testdata/fuzz/FuzzAddInt/b403d5353f8afe03` 的内容如下：'
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Fixing `AddInt()` is left as an exercise for you—as a hint, consider using different
    code when the parameter used in the `for` loop is negative. In our case, the function
    parameter that causes the error condition is `x`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 修复 `AddInt()` 作为练习留给您——作为一个提示，考虑在 `for` 循环中使用的参数为负时使用不同的代码。在我们的例子中，导致错误条件的函数参数是
    `x`。
- en: The next subsection presents a more practical fuzz testing example.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将展示一个更实际的模糊测试示例。
- en: An advanced fuzz testing example
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级模糊测试示例
- en: 'In this subsection, we present a more advanced fuzz testing example. The relevant
    code is found under `ch13/reverse`. The code in `reverse.go` is the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个子节中，我们展示了一个更高级的模糊测试示例。相关代码位于 `ch13/reverse`。`reverse.go` 中的代码如下：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this first part, we implement a function named `R1()` that reverses a string.
    Internally, the function converts the input `string` value into a byte slice and
    returns a byte slice.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一部分中，我们实现了一个名为 `R1()` 的函数，该函数反转一个字符串。内部，该函数将输入的 `string` 值转换为字节切片并返回一个字节切片。
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this part, we implement a function named `R2()` that also reverses a string.
    Internally, the function works with a byte slice but returns a `string` value.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个部分中，我们实现了一个名为 `R2()` 的函数，该函数也反转一个字符串。内部，该函数使用字节切片，但返回一个 `string` 值。
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `main()` function calls both `R1()` and `R2()` in order to reverse the `"1234567890"`
    string—this is a naive way of testing the implemented functionality.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数调用 `R1()` 和 `R2()` 两个函数以反转 `"1234567890"` 字符串——这是一种测试实现功能的基本方法。'
- en: 'Running `reverse.go` generates the following output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `reverse.go` 生成以下输出：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So, at first, the code looks correct and produces the expected output. Now,
    let us write some tests for the two functions in `reverse.go`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最初，代码看起来是正确的，并产生了预期的输出。现在，让我们为 `reverse.go` 中的两个函数编写一些测试。
- en: 'The code in `reverse_test.go` is presented in three parts. The first part is
    the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`reverse_test.go` 中的代码分为三个部分。第一部分如下：'
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding is a test function for `R1()`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 前面是 `R1()` 的测试函数。
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding is a test function for `R2()`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 前面是 `R2()` 的测试函数。
- en: Both `TestR1()` and `TestR2()` are regular testing functions that use user-defined
    tests, which are stored in the `testCases` structure. The first field is the original
    string, whereas the second field is the reversed string.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestR1()` 和 `TestR2()` 都是常规测试函数，使用用户定义的测试，这些测试存储在 `testCases` 结构中。第一个字段是原始字符串，而第二个字段是反转后的字符串。'
- en: 'The second part contains the fuzz testing functions and is the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含模糊测试函数，如下所示：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is a fuzz testing function for testing `R1()`. We add three strings to
    the seed corpus, which are saved in the `testCases` slice.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于测试`R1()`的模糊测试函数。我们向种子语料库中添加了三个字符串，这些字符串保存在`testCases`切片中。
- en: 'The last part of `reverse_test.go` contains the code for testing `R2()`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`reverse_test.go`文件的最后一部分包含了测试`R2()`函数的代码：'
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is a fuzz testing function for testing `R2()`. As before, we add three
    strings to the seed corpus using the values stored in the `testCases` slice.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于测试`R2()`的模糊测试函数。和之前一样，我们使用保存在`testCases`切片中的值向种子语料库中添加了三个字符串。
- en: Both fuzz testing functions reverse the given string two times and compare it
    with `orig` itself to make sure that they are the same. This happens because,
    when you reverse a string twice, you should get the original string back.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 两个模糊测试函数都会将给定的字符串反转两次，并将其与`orig`本身进行比较，以确保它们相同。这是因为，当你将一个字符串反转两次时，你应该得到原始字符串。
- en: 'Running tests without fuzzing produces the following results:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 不进行模糊测试运行测试会产生以下结果：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So, it looks like everything is working as expected. But is this the case?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，看起来一切都在按预期工作。但这是否就是情况呢？
- en: 'Let us run tests with fuzzing. First, we are going to run `FuzzR1()` as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行带有模糊测试的测试。首先，我们将按照以下方式运行`FuzzR1()`：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So, in this case, the fuzz test found an issue with the code. The failing input
    is saved in `testdata/fuzz/FuzzR1/42f418307d5ef745`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，模糊测试发现了代码中的问题。失败的输入被保存在`testdata/fuzz/FuzzR1/42f418307d5ef745`。
- en: 'The contents of `testdata/fuzz/FuzzR1/a256ceb5e3bf582f` are the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`testdata/fuzz/FuzzR1/a256ceb5e3bf582f`的内容如下：'
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Put simply, the string stored in `testdata/fuzz/FuzzR1/a256ceb5e3bf582f` is
    not being reversed successfully.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，保存在`testdata/fuzz/FuzzR1/a256ceb5e3bf582f`中的字符串没有被成功反转。
- en: 'Next, we are going to run `FuzzR2()` with fuzzing:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将运行带有模糊测试的`FuzzR2()`：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As there exists a `testdata` directory from the failure of `FuzzR1()`, the second
    fuzz testing fails because of the data found in the `testdata` directory. In the
    subsection that follows, we are going to correct the bug.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`FuzzR1()`失败，存在一个`testdata`目录，因此第二次模糊测试由于在`testdata`目录中找到的数据而失败。在接下来的小节中，我们将修复这个错误。
- en: Correcting the bug
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复错误
- en: 'What we should do now is **correct the bug**. The improved version of `reverse.go`
    is called `correct.go` and is found in `ch13/reverse/correct`. Its code is as
    follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该做的是**修复错误**。`reverse.go`的改进版本被称为`correct.go`，位于`ch13/reverse/correct`目录下。其代码如下：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that in the implementation of `R2()`, we now work with **runes instead
    of bytes**. Additionally, both `R1()` and `R2()` verify that we are dealing with
    a valid UTF-8 string using the functionality of `utf8.ValidString()` prior to
    doing any processing. When the input is an invalid UTF-8 string, an `error` message
    is returned—we did not do that in `reverse.go`, which is what caused the bug.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`R2()`的实现中，我们现在使用**runes而不是bytes**。此外，`R1()`和`R2()`在开始任何处理之前，都使用`utf8.ValidString()`的功能来验证我们正在处理一个有效的UTF-8字符串。当输入是一个无效的UTF-8字符串时，会返回一个错误信息——我们在`reverse.go`中没有这样做，这就是导致错误的原因。
- en: 'The remaining code is about the implementation of `main()`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的代码是关于`main()`函数的实现：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As explained earlier, the main difference in this improved version is that the
    two functions also return an `error` variable to make sure that we are dealing
    with valid UTF-8 strings. However, this also means that the test functions as
    well as the fuzz testing functions should be modified in order to adjust to the
    change in the function signatures.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这个改进版本的主要区别是这两个函数也返回一个`error`变量，以确保我们正在处理有效的UTF-8字符串。然而，这也意味着测试函数以及模糊测试函数应该被修改，以适应函数签名的变化。
- en: 'Running `correct.go` produces the following output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`correct.go`会产生以下输出：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: So, it looks like the basic functionality is still implemented correctly.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，看起来基本功能仍然被正确实现。
- en: 'The improved test version is called `correct_test.go` and is also found in
    `ch13/reverse/correct`—it is going to be presented in two parts. The first part
    of `correct_test.go` contains the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 改进的测试版本被称为`correct_test.go`，也位于`ch13/reverse/correct`目录下——它将分两部分展示。`correct_test.go`的第一部分包含以下代码：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The logic of both `TestR1()` and `TestR2()` is the same as before: we use the
    values stored in a slice of structures (`testCases`) to verify the correctness
    of `R1()` and `R2()`. However, this time, we take into consideration the `error`
    value returned by `R1()` and `R2()`. If there is an error with `R1()` or `R2()`,
    both test functions return immediately, which makes the test successful.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestR1()` 和 `TestR2()` 的逻辑与之前相同：我们使用存储在结构体切片（`testCases`）中的值来验证 `R1()` 和 `R2()`
    的正确性。然而，这次我们考虑了 `R1()` 和 `R2()` 返回的 `error` 值。如果 `R1()` 或 `R2()` 出现错误，两个测试函数会立即返回，这使得测试成功。'
- en: 'The second part of `correct_test.go` is the implementation of the fuzz testing
    functions:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`correct_test.go` 的第二部分是模糊测试函数的实现：'
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`FuzzR1()` uses the `error` value returned by `R1()` to make sure that we are
    dealing with a valid string. If the string is not valid, then it returns. Additionally,
    it reverses the given string—which is stored in the automatically generated `orig`
    parameter—two times and compares it with `orig` itself to make sure that they
    are the same.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`FuzzR1()` 使用 `R1()` 返回的 `error` 值来确保我们正在处理一个有效的字符串。如果字符串无效，则返回。此外，它将给定的字符串（存储在自动生成的
    `orig` 参数中）反转两次，并与 `orig` 本身进行比较，以确保它们相同。'
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`FuzzR2()` also uses the `error` value returned by `R2()` to make sure that
    we are dealing with a valid string. If the string is not valid, then it also returns.
    The remaining implementation follows the logic of `FuzzR1()`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`FuzzR2()` 也使用 `R2()` 返回的 `error` 值来确保我们正在处理一个有效的字符串。如果字符串无效，它也会返回。剩余的实现遵循
    `FuzzR1()` 的逻辑。'
- en: 'Running the regular tests produces the following output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 运行常规测试会产生以下输出：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Performing the fuzzing test for `R1()` generates the following output:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `R1()` 进行模糊测试会生成以下输出：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The use of `-fuzztime 10s` makes sure that the tests are going to stop after
    they exceed the given time limit or when there is an error.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-fuzztime 10s` 确保测试在超过给定时间限制或出现错误后停止。
- en: 'Running the fuzzing test for `R2()` generates the following output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `R2()` 进行模糊测试会生成以下输出：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: So, everything works as expected and the bug was corrected!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一切如预期进行，并且错误已被纠正！
- en: The next section is about observability, which is a systematic way of collecting
    data related to the efficiency and the internals of a system.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节是关于可观察性的，这是一种系统地收集与系统效率和内部相关的数据的系统方法。
- en: Observability
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可观察性
- en: Observability is the measurement of the internal state of a system in relation
    to external operations. In practical terms, observability is about understanding
    how well the resources of a computer system are being utilized while a given software
    or application is being executed on a system.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察性是衡量系统内部状态与外部操作之间关系的度量。在实践中，可观察性是关于理解在给定软件或应用程序在系统上执行时，计算机系统的资源是如何被有效利用的。
- en: In Go terminology, and in relation to the content of this book, observability
    is about learning **how Go uses the available resources and how an application
    performs while the application is executed** in order to understand the efficiency
    of the Go application as well as the Go runtime itself. The purpose of this process
    is to improve the efficiency of a Go application and maybe modify the resources
    available to that particular Go application in order to improve its overall operation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 术语中，以及与本书内容相关的情况下，可观察性是关于学习 **Go 如何使用可用资源以及应用程序在执行过程中的表现**，以便理解 Go 应用程序的效率以及
    Go 运行时本身的效率。此过程的目的在于提高 Go 应用程序的效率，并可能修改特定 Go 应用程序可用的资源，以改善其整体运行。
- en: If it is still unclear, let me explain it in a more practical way. Let us say
    that a Go application runs slow. We need to discover why this happens. For that,
    we measure the appropriate internal Go metrics as well as application-specific
    metrics and try to make sense of them.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仍然不清楚，让我用更实际的方式解释一下。假设一个 Go 应用程序运行缓慢。我们需要找出这是为什么。为此，我们需要测量适当的内部 Go 指标以及应用程序特定的指标，并尝试理解它们。
- en: 'The key components of observability include:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察性的关键组件包括：
- en: '**Logs**: Recording events, activities, and messages generated by a system.
    Logs provide a historical record of what has happened and are useful for debugging
    and auditing.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志**：记录系统生成的事件、活动和消息。日志提供了发生事件的记录，对于调试和审计很有用。'
- en: '**Metrics**: Quantitative measurements that provide insight into the system’s
    performance and behavior. Metrics examples include response times, error rates,
    and resource utilization.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指标**：提供对系统性能和行为洞察的定量测量。指标示例包括响应时间、错误率和资源利用率。'
- en: '**Traces**: Sequences of events or transactions that allow you to trace the
    flow of a request through a system. Tracing helps in understanding the latency
    and dependencies between different components.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪**：一系列事件或事务，允许您跟踪请求通过系统中的各个组件的流程。跟踪有助于理解不同组件之间的延迟和依赖关系。'
- en: '**Monitoring**: Continuous tracking of metrics and logs to identify patterns,
    anomalies, and potential issues. Monitoring systems can generate alerts when predefined
    thresholds are exceeded. This is a complex task, especially when having to deal
    with a large number of metrics.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控**：持续跟踪指标和日志以识别模式、异常和潜在问题。当预定义的阈值超过时，监控系统可以生成警报。这是一个复杂任务，尤其是在需要处理大量指标时。'
- en: '**Alerting**: Notification mechanisms that inform administrators or operators
    about potential issues or irregularities in the system. Alerts help in responding
    quickly to problems and minimizing downtime.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**警报**：通知机制，告知管理员或操作员关于系统中潜在问题或不规则性的信息。警报有助于快速响应问题并最小化停机时间。'
- en: '**Distributed tracing**: Tracking and visualizing requests as they traverse
    through various components in a distributed system. This is particularly important
    in microservices architectures and is extremely challenging.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式跟踪**：跟踪和可视化请求在分布式系统中的各个组件之间传递的过程。这在微服务架构中尤为重要，并且极具挑战性。'
- en: This chapter is going to deal with metrics. Code profiling and tracing were
    covered in *Chapter 12*, *Code Testing and Profiling*. Additionally, logging was
    covered in *Chapter 1*, *A Quick Introduction to Go*, and *Chapter 7*, *Telling
    a UNIX System What to Do*. Dealing with the remaining components is beyond the
    scope of this book.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将处理指标。代码分析和跟踪在 *第12章*，*代码测试和分析* 中介绍。此外，日志在 *第1章*，*Go语言快速入门* 和 *第7章*，*告诉UNIX系统做什么*
    中介绍。处理剩余组件超出了本书的范围。
- en: We begin by explaining the use of the `runtime/metrics` package, which provides
    Go runtime-related metrics.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先解释 `runtime/metrics` 包的使用，该包提供与Go运行时相关的指标。
- en: The runtime/metrics package
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`runtime/metrics` 包'
- en: The `runtime/metrics` package makes metrics exported by the Go runtime available
    to the developer. Each metric name is specified by a path. As an example, the
    number of live goroutines is accessed as `/sched/goroutines:goroutines`. However,
    if you want to collect all available metrics, you should use `metrics.All()`—this
    saves you from having to write lots of code in order to collect each individual
    metric.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`runtime/metrics` 包使Go运行时导出的指标对开发者可用。每个指标名称由一个路径指定。例如，活着的goroutines的数量可以通过
    `/sched/goroutines:goroutines` 访问。然而，如果您想收集所有可用的指标，应使用 `metrics.All()`——这可以节省您编写大量代码以收集每个单独指标的时间。'
- en: 'Metrics are saved using the `metrics.Sample` data type. The definition of the
    `metrics.Sample` data structure is as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 指标使用 `metrics.Sample` 数据类型保存。`metrics.Sample` 数据结构的定义如下：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `Name` value must correspond to the name of one of the metric descriptions
    returned by `metrics.All()`. If you already know the metric description, there
    is no need to use `metrics.All()`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Name` 值必须与 `metrics.All()` 返回的指标描述之一的名字相匹配。如果您已经知道指标描述，则无需使用 `metrics.All()`。'
- en: 'The use of the `runtime/metrics` package is illustrated in `metrics.go`. The
    presented code gets the value of `/sched/goroutines:goroutines` and prints it
    on screen:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`runtime/metrics` 包的使用在 `metrics.go` 中展示。展示的代码获取 `/sched/goroutines:goroutines`
    的值并在屏幕上打印：'
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `nGo` variable holds the path of the metric we want to collect.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`nGo` 变量保存了我们想要收集的指标路径。'
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: After that, we create a slice of type `metrics.Sample` in order to keep the
    metric value. The initial size of the slice is `1` because we are only collecting
    values for a single metric. We set the `Name` value to `/sched/goroutines:goroutines`
    as stored in `nGo`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们创建一个类型为 `metrics.Sample` 的切片以保存指标值。切片的初始大小为 `1`，因为我们只为单个指标收集值。我们将 `Name`
    值设置为 `/sched/goroutines:goroutines`，正如在 `nGo` 中存储的那样。
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we manually create three goroutines so that the program has relevant data
    to collect.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们手动创建三个goroutines，以便程序有相关的数据可以收集。
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `metrics.Read()` function collects the desired metrics based on the data
    in the `getMetric` slice.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`metrics.Read()` 函数根据 `getMetric` 切片中的数据收集所需的指标。'
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After reading the desired metric, we convert it into a numeric value (unsigned
    `int64` here) in order to use it in our program.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取所需的度量后，我们将它转换为数值（这里是无符号 `int64`）以便在我们的程序中使用。
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The last lines of the code verify that, after all goroutines have finished,
    the value of the metric is going to be `1`, which is the goroutine used for running
    the `main()` function.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后几行验证了，在所有 goroutine 完成后，度量值的值将是 `1`，这是用于运行 `main()` 函数的 goroutine。
- en: 'Running `metrics.go` produces the next output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `metrics.go` 产生以下输出：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We have created three goroutines and we already have a goroutine for running
    the `main()` function. Therefore, the maximum number of goroutines is indeed four.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了三个 goroutine，并且已经有一个用于运行 `main()` 函数的 goroutine。因此，最大 goroutine 数量确实是四个。
- en: The following subsection presents a technique for measuring the execution time
    of a Go function, which is not something that is directly supported by Go.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节介绍了一种测量 Go 函数执行时间的技术，这不是 Go 直接支持的功能。
- en: Measuring the execution time of a function
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量函数的执行时间
- en: The `runtime/metrics` package provides a list of metrics that you can find on
    the help page of the package. However, there are times when we want to measure
    the time of a specific operation, which is a request not supported by the `runtime/metrics`
    package. In our example, we are going to do exactly that and store the information
    in a log entry.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`runtime/metrics` 包提供了一组度量，您可以在包的帮助页面上找到这些度量。然而，有时我们想要测量特定操作的时间，这是 `runtime/metrics`
    包不支持的操作。在我们的例子中，我们将做 exactly that 并将信息存储在日志条目中。'
- en: In this example, we are going to use the `log/slog` package of the standard
    library. You can use any logging package you want as long as it is simple and
    readable, but most importantly, as long as it is efficient and does not introduce
    extra load to the system.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用标准库中的 `log/slog` 包。只要它是简单且可读的，您可以使用任何日志包，但最重要的是，只要它是高效的并且不会给系统带来额外的负载。
- en: 'The code of `functionTime.go` is presented in two parts. The first part is
    the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`functionTime.go` 的代码分为两部分。第一部分如下：'
- en: '[PRE36]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is where we define the function that we want to measure—this can be any
    function or operation you want.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们定义想要测量的函数的地方——这可以是您想要的任何函数或操作。
- en: 'The second part of `functionTime.go` comes with the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`functionTime.go` 的第二部分包含以下代码：'
- en: '[PRE37]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The use of `time.Now()` and `time.Since()` calls that surround the execution
    of `myFunction()` is how we measure the execution time of `myFunction()`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `time.Now()` 和 `time.Since()` 调用包围 `myFunction()` 的执行，这是我们测量 `myFunction()`
    执行时间的方法。
- en: Remember that the `time.Duration` data type holds nanoseconds and is, in reality,
    an `int64` value, hence the use of `slog.Int64()` as well as the `int64(elapsed)`
    cast for converting the `time.Duration` value into an `int64` one.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`time.Duration` 数据类型包含纳秒，实际上是一个 `int64` 值，因此使用了 `slog.Int64()` 以及 `int64(elapsed)`
    强制类型转换来将 `time.Duration` 值转换为 `int64`。
- en: 'Running `functionTime.go` generates the following kind of output:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `functionTime.go` 生成以下类型的输出：
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Keep in mind that on a busy system, the `time_taken` values are not going to
    be so similar because of the OS scheduler as well as the Go scheduler operations.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在繁忙的系统上，由于操作系统调度程序以及 Go 调度程序的操作，`time_taken` 值不会那么相似。
- en: The next subsection is a handy introduction to the `expvar` package.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 下一小节是 `expvar` 包的便捷介绍。
- en: The expvar package
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`expvar` 包'
- en: The `expvar` package allows you to expose variables and functions to servers,
    which includes custom metrics. The `expvar` package exposes these variables via
    HTTP at `/debug/vars` in JSON format.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`expvar` 包允许您将变量和函数暴露给服务器，包括自定义度量。`expvar` 包通过 HTTP 在 `/debug/vars` 以 JSON
    格式暴露这些变量。'
- en: 'The code of `expvarUse.go` is presented in two parts. The first part is the
    following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`expvarUse.go` 的代码也分为两部分。第一部分如下：'
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The previous code does two things. First, it registers an integer variable named
    `intVar` to be exposed and, second, it registers a function named `customFunction`
    to be exposed using `expvar.NewInt()` and `expvar.Publish()`, respectively. The
    `Publish()` function takes two arguments in its signature, which are the name
    of the variable that the function is going to expose and the function that we
    want to expose. In this case, we use an anonymous function that is implemented
    inline.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码做了两件事。首先，它使用 `expvar.NewInt()` 注册一个名为 `intVar` 的整数变量以供公开，其次，它使用 `expvar.Publish()`
    注册一个名为 `customFunction` 的函数以供公开。`Publish()` 函数在其签名中接受两个参数，分别是函数将要公开的变量名称和我们想要公开的函数。在这种情况下，我们使用一个内联实现的匿名函数。
- en: 'The second part of `expvarUse.go` is the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`expvarUse.go` 的第二部分如下：'
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `http.Handle()` function allows us to install an additional handler in a
    non-standard location, which, in this case, is `/debug/expvars`. So, we use the
    `/debug/expvars` path to also access the registered variable and function, we
    start the HTTP server that listens on port number `8080`, we modify `intVar` using
    `intVar.Add()`, and we use `select {}` to prevent the program from terminating
    because it blocks the program.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.Handle()` 函数允许我们在非标准位置安装一个额外的处理程序，在这种情况下，是 `/debug/expvars`。因此，我们使用 `/debug/expvars`
    路径来访问注册的变量和函数，我们启动监听端口 `8080` 的 HTTP 服务器，我们使用 `intVar.Add()` 修改 `intVar`，并使用 `select
    {}` 来防止程序终止，因为它会阻塞程序。'
- en: In this case, we mimic the application logic, which we should replace with our
    own logic, by updating the value of `intVar` manually using `intVar.Add(10)`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们通过手动使用 `intVar.Add(10)` 更新 `intVar` 的值来模拟应用程序逻辑，我们应该用我们自己的逻辑来替换它。
- en: Running `expvarUse.go` is not going to produce any output but it is going to
    start the HTTP server. We can access the exposed variable and function by visiting
    `http://localhost:8080/debug/vars` or `http://localhost:8080/debug/expvars` in
    a web browser or by making an HTTP `GET` request using a tool such as `curl(1)`
    or `wget(1)`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `expvarUse.go` 不会产生任何输出，但它会启动 HTTP 服务器。我们可以通过访问网页浏览器中的 `http://localhost:8080/debug/vars`
    或 `http://localhost:8080/debug/expvars`，或者使用 `curl(1)` 或 `wget(1)` 等工具发送 HTTP
    `GET` 请求来访问公开的变量和函数。
- en: 'In our case, we are going to use `curl(1)` and we are going to get the following
    kind of output (some output is omitted for brevity):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将使用 `curl(1)` 并得到以下类型的输出（为了简洁起见，省略了一些输出）：
- en: '[PRE41]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The next subsection covers learning about the CPU of a machine and its characteristics.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子部分将介绍如何了解机器的 CPU 及其特性。
- en: Learning about CPU characteristics
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解 CPU 特性
- en: There are times when we need to learn about the details of the CPU at runtime
    and maybe expose them in order to collect the relevant metrics. For such times,
    the [https://github.com/klauspost/cpuid](https://github.com/klauspost/cpuid) package
    can really come in handy.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们需要了解 CPU 在运行时的详细信息，并可能将其公开以收集相关指标。在这种情况下，[https://github.com/klauspost/cpuid](https://github.com/klauspost/cpuid)
    包真的非常有用。
- en: We are going to put all relevant code inside `~/go/src/github.com/mactsouk/mGo4th/ch13/cpuid`
    because we are going to utilize an external package.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把所有相关代码放入 `~/go/src/github.com/mactsouk/mGo4th/ch13/cpuid` 目录中，因为我们将要利用一个外部包。
- en: 'The Go code of `cpuid.go` is the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`cpuid.go` 的 Go 代码如下：'
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The code is standard, and you should not need to make any changes to it.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是标准的，你不需要对其进行任何修改。
- en: 'Running `cpuid.go` on my macOS machine with a M1 Max CPU produces the following
    output:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的 macOS 机器上运行 `cpuid.go` 并带有 M1 Max CPU 产生以下输出：
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Running `cpuid.go` on a Linux machine with an Intel i7 processor produces the
    following output:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在带有 Intel i7 处理器的 Linux 机器上运行 `cpuid.go` 产生以下输出：
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: By comparing the outputs, we can see that `cpuid` works better on the Linux
    machine with the Intel CPU as it displays the frequency of the CPU, which is not
    the case for the MacBook Pro machine.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过比较输出，我们可以看到 `cpuid` 在带有 Intel CPU 的 Linux 机器上运行得更好，因为它显示了 CPU 的频率，而 MacBook
    Pro 机器则没有这种情况。
- en: The next section is about how to expose metrics to Prometheus and how to plot
    the metrics in Grafana.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将介绍如何将指标暴露给 Prometheus 以及如何在 Grafana 中绘制指标。
- en: Exposing metrics to Prometheus
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将指标暴露给 Prometheus
- en: Imagine that you have an application that writes files to disk and you want
    to get metrics for that application to better understand how the writing of multiple
    files influences the general performance—you need to gather performance data to
    understand the behavior of your application. A good way to store such metrics
    is by using Prometheus.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个将文件写入磁盘的应用程序，并且你想要获取该应用程序的度量以更好地理解多个文件写入如何影响整体性能——你需要收集性能数据以了解应用程序的行为。存储此类度量的一种好方法是使用Prometheus。
- en: 'The list of supported data types for metrics by Prometheus is the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus支持的度量数据类型列表如下：
- en: '**Counter**: This is a cumulative value that is used for representing increasing
    counters—the value of a counter can stay the same, go up, or be reset to zero,
    but it cannot decrease. Counters are usually used for representing cumulative
    values such as the number of requests served so far, the total number of errors,
    and so on.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Counter**：这是一个累积值，用于表示递增的计数器——计数器的值可以保持不变，上升，或重置为零，但不能减少。Counter通常用于表示累积值，例如迄今为止服务的请求数量、错误总数等。'
- en: '**Gauge**: This is a single numerical value that is allowed to increase or
    decrease. Gauges are usually used for representing values that can go up or down
    such as the number of requests and time durations.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gauge**：这是一个允许增加或减少的单个数值。Gauge通常用于表示可以上升或下降的值，例如请求数量和时间长度。'
- en: '**Histogram**: A histogram is used for sampling observations and creating counts
    and buckets. Histograms are usually used for counting request durations, response
    times, and so on.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Histogram**：Histogram用于采样观察结果并创建计数和桶。Histogram通常用于计数请求持续时间、响应时间等。'
- en: '**Summary**: A summary is like a histogram but can also calculate quantiles
    over sliding windows that work with times.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Summary**：Summary类似于直方图，但也可以在滑动窗口中计算时间相关的分位数。'
- en: Both histograms and summaries are useful for performing statistical calculations
    and properties. Usually, a counter or a gauge is all that you need for storing
    your system metrics.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图和Summary都可用于执行统计计算和属性。通常，一个计数器或Gauge就足够用于存储你的系统度量。
- en: The subsections that follow illustrate how to make any metric you collect available
    to Prometheus.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的子节将说明如何使你收集的任何度量对Prometheus可用。
- en: Exposing metrics
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暴露度量
- en: Collecting metrics is a totally different task from exposing them for Prometheus
    to collect them. This subsection shows how to make the metrics available to Prometheus
    for collection. For reasons of simplicity, the presented application is going
    to generate random values.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 收集度量与向Prometheus暴露它们以供收集是完全不同的任务。本小节将展示如何使度量对Prometheus的收集可用。为了简化起见，所展示的应用将生成随机值。
- en: 'The code of `samplePro.go` is as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`samplePro.go`的代码如下：'
- en: '[PRE45]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We need to use two external packages for communicating with Prometheus.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用两个外部包来与Prometheus通信。
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Bear in mind that I use global variables here to denote important settings and
    that is a personal preference and my way of easily finding those settings. The
    same applies for the use of all caps for naming the `PORT` variable.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我在这里使用全局变量来表示重要的设置，这是一个个人偏好，也是我轻松找到这些设置的方法。同样适用于使用大写字母来命名`PORT`变量。
- en: This is how we define a new `counter` variable and specify the desired options.
    The `Namespace` field is very important as it allows you to group metrics in sets.
    The name of the first metric is `my_counter`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们定义一个新的`counter`变量并指定所需选项。`Namespace`字段非常重要，因为它允许你将度量分组。第一个度量的名称是`my_counter`。
- en: '[PRE47]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is how we define a new `gauge` variable and specify the desired options—the
    name of the metric is `my_gauge`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们定义一个新的`gauge`变量并指定所需选项——度量名称为`my_gauge`。
- en: '[PRE48]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is how we define a new `histogram` variable and specify the desired options.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们定义一个新的`histogram`变量并指定所需选项。
- en: '[PRE49]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This is how we define a new `summary` variable and specify the desired options.
    However, as you are going to see, defining a metric variable is not enough. You
    also need to register it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们定义一个新的`summary`变量并指定所需选项的方法。然而，正如你将要看到的，定义一个度量变量是不够的。你还需要注册它。
- en: '[PRE50]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In these four `prometheus.MustRegister()` statements, you register the four
    metric variables. Now, when Prometheus connects to the server and the namespace,
    it is going to know about them.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这四个`prometheus.MustRegister()`语句中，你注册了四个度量变量。现在，当Prometheus连接到服务器和命名空间时，它将了解它们。
- en: '[PRE51]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This goroutine runs for as long as the web server runs with the help of the
    endless `for` loop. In this goroutine, the metrics are updated every 2 seconds
    due to the use of the `time.Sleep(2 * time.Second)` statement.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 goroutine 在 web 服务器运行期间通过 endless `for` 循环持续运行。在这个 goroutine 中，由于使用了 `time.Sleep(2
    * time.Second)` 语句，指标每 2 秒更新一次。
- en: '[PRE52]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As you already know, each URL is handled by a handler function that you usually
    implement on your own. However, in this case, we are using the `promhttp.Handler()`
    handler function that comes with the [github.com/prometheus/client_golang/prometheus/promhttp](https://github.com/prometheus/client_golang/prometheus/promhttp)
    package—this saves us from having to write our own code. However, we still need
    to register the `promhttp.Handler()` handler function using `http.Handle()` before
    we start the web server. Note that the metrics are found under the `/metrics`
    path—Prometheus knows how to find that.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，每个 URL 都由一个处理函数处理，你通常自己实现这个处理函数。然而，在这种情况下，我们使用的是 [github.com/prometheus/client_golang/prometheus/promhttp](https://github.com/prometheus/client_golang/prometheus/promhttp)
    包中提供的 `promhttp.Handler()` 处理函数——这使我们免于编写自己的代码。然而，在我们启动 web 服务器之前，我们仍然需要使用 `http.Handle()`
    注册 `promhttp.Handler()` 处理函数。注意，指标位于 `/metrics` 路径下——Prometheus 知道如何找到它。
- en: 'With `samplePro.go` running, getting the list of metrics that belong to the
    `mtsouk` namespace is as simple as running the next `curl(1)` command:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `samplePro.go` 运行时，获取属于 `mtsouk` 命名空间的指标列表就像运行下一个 `curl(1)` 命令一样简单：
- en: '[PRE53]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This is the output from a `counter` variable. If the `| grep mtsouk` part is
    omitted, then you are going to get the list of all available metrics.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从 `counter` 变量输出的内容。如果省略了 `| grep mtsouk` 部分，那么你将得到所有可用指标列表。
- en: '[PRE54]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This is the output from a `gauge` variable.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从 `gauge` 变量输出的内容。
- en: '[PRE55]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This is the output from a `histogram` variable. Histograms contain buckets,
    hence the large number of output lines.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从 `histogram` 变量输出的内容。直方图包含桶，因此有大量的输出行。
- en: '[PRE56]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The last lines of the output are for the `summary` data type.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行是针对 `summary` 数据类型的。
- en: So, the metrics are there and ready to be pulled by Prometheus—in practice,
    this means that every production Go application can export metrics that can be
    used for measuring its performance and discovering its bottlenecks. However, we
    are not done yet as we need to learn about building Docker images for Go applications.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，指标已经准备好了，可以由 Prometheus 拉取——在实践中，这意味着每个生产 Go 应用程序都可以导出用于衡量其性能和发现其瓶颈的指标。然而，我们还没有完成，因为我们还需要了解如何为
    Go 应用程序构建 Docker 镜像。
- en: Creating a Docker image for a Go server
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Go 服务器的 Docker 镜像
- en: This subsection shows how to create a Docker image for a Go application. The
    main benefit you get from this is that you can deploy it in a Docker environment
    without worrying about compiling it and having the required resources—everything
    is included in the Docker image.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节展示了如何为 Go 应用程序创建 Docker 镜像。你从中获得的主要好处是，你可以在 Docker 环境中部署它，而无需担心编译它和所需的资源——所有这些都包含在
    Docker 镜像中。
- en: 'Still, you might ask, “Why not use a normal Go binary instead of a Docker image?”
    The answer is simple: Docker images can be put in `docker-compose.yml` files and
    can be deployed using Kubernetes. The same is not true for Go binaries. Additionally,
    Docker images can provide consistent shared libraries when this is needed.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，你可能会问，“为什么不使用正常的 Go 二进制文件而不是 Docker 镜像？” 答案很简单：Docker 镜像可以放入 `docker-compose.yml`
    文件中，并可以使用 Kubernetes 进行部署。Go 二进制文件则不行。此外，当需要时，Docker 镜像可以提供一致的共享库。
- en: When creating a new Docker image, you usually start with a base Docker image
    that already includes Go and create the desired binary in there. The key point
    here is that `samplePro.go` uses an external package that should be downloaded
    in the Docker image before building the executable binary.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的 Docker 镜像时，你通常从一个已经包含 Go 的基础 Docker 镜像开始，并在其中创建所需的二进制文件。关键点是 `samplePro.go`
    使用了一个外部包，在构建可执行二进制文件之前，应该在 Docker 镜像中下载这个包。
- en: 'The process must start with `go mod init` and `go mod tidy`. The contents of
    the relevant Docker file, which is named `dFilev2`, are as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程必须从 `go mod init` 和 `go mod tidy` 开始。名为 `dFilev2` 的相关 Docker 文件的 内容如下：
- en: '[PRE57]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As `golang:alpine` uses the latest Go version, which does not come with `git`,
    we install `git` manually.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `golang:alpine` 使用的是最新的 Go 版本，该版本不包含 `git`，所以我们手动安装 `git`。
- en: '[PRE58]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If you want to use Go modules, you should put your code in `$GOPATH/src`, which
    is what we do here.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用 Go 模块，你应该将你的代码放在 `$GOPATH/src` 目录下，这是我们在这里所做的事情。
- en: '[PRE59]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We download the required dependencies using various `go mod` commands. The building
    of the binary file is the same as before.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用各种 `go mod` 命令下载所需的依赖。二进制文件的构建与之前相同。
- en: '[PRE60]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this second stage, we put the binary file into the desired location `(/pro`)
    and expose the desired port, which, in this case, is port number `1234`. The port
    number depends on the code in `samplePro.go`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第二阶段，我们将二进制文件放入所需的位置 `(/pro)` 并公开所需的端口，在这个例子中，是端口号 `1234`。端口号取决于 `samplePro.go`
    中的代码。
- en: The previous process is a **two-step process that makes the final Docker image
    smaller in size**, hence the use of the second `FROM` command with a Docker image
    that does not include the Go tools and is just used for running the generated
    Go binary.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的过程是一个**两步过程，使得最终的 Docker 镜像尺寸更小**，因此使用了第二个 `FROM` 命令，该命令使用不包含 Go 工具的 Docker
    镜像，仅用于运行生成的 Go 二进制文件。
- en: 'Building a Docker image using `dFilev2` is as simple as running the next command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dFilev2` 构建 Docker 镜像就像运行下一个命令一样简单：
- en: '[PRE61]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Although previous versions of Docker used the `docker build` command for building
    images, recent versions of Docker also support the use of `buildx` for the same
    task. You might need to install the `buildkit` and `docker-buildx` packages to
    enable the `buildx` command.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管之前的 Docker 版本使用 `docker build` 命令来构建镜像，但 Docker 的最新版本也支持使用 `buildx` 来执行相同的任务。您可能需要安装
    `buildkit` 和 `docker-buildx` 包来启用 `buildx` 命令。
- en: 'So, if you want to go the `docker buildx` way, you should execute the following
    command instead:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您想走 `docker buildx` 的路，您应该执行以下命令：
- en: '[PRE62]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The results from both `docker build` and `docker buildx` are exactly the same.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker build` 和 `docker buildx` 的结果完全相同。'
- en: 'Once the Docker image has been successfully created, there is no difference
    in the way you should use it in a `docker-compose.yml` file—a relevant entry in
    a `docker-compose.yml` file would look as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦成功创建了 Docker 镜像，您在 `docker-compose.yml` 文件中使用它的方式就没有区别——`docker-compose.yml`
    文件中的一个相关条目如下所示：
- en: '[PRE63]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The name of the Docker image is `go-app122`, whereas the internal name of the
    container would be `goapp-int`. So, if a different container from the `monitoring`
    network wants to access that container, it should use the `goapp-int` hostname.
    Last, the only open port is port number `1234`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像的名称是 `go-app122`，而容器的内部名称将是 `goapp-int`。因此，如果来自 `monitoring` 网络的不同容器想要访问该容器，它应该使用
    `goapp-int` 主机名。最后，唯一开放的端口是端口号 `1234`。
- en: The next subsection illustrates how you can expose the chosen metrics to Prometheus.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将说明如何将选定的指标公开给 Prometheus。
- en: Specifying the metrics to expose
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定要公开的指标
- en: This section illustrates how to expose the desired metrics from the `runtime/metrics`
    package to Prometheus. In our case, we use `/sched/goroutines:goroutines` and
    `/memory/classes/total:bytes`. You already know about the former, which is the
    total number of goroutines. The latter metric is the amount of memory mapped by
    the Go runtime into the current process as read-write.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 本节说明了如何将 `runtime/metrics` 包中的所需指标公开给 Prometheus。在我们的例子中，我们使用 `/sched/goroutines:goroutines`
    和 `/memory/classes/total:bytes`。您已经了解前者，它是 goroutines 的总数。后者指标是 Go 运行时映射到当前进程的内存量，作为可读写。
- en: As the presented code uses external packages, it should be put inside `~/go/src`
    and Go modules should be enabled using `go mod init`. In our case, the code can
    be found in `ch13/prom/`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 由于展示的代码使用了外部包，它应该放在 `~/go/src` 中，并使用 `go mod init` 启用 Go 模块。在我们的例子中，代码可以在 `ch13/prom/`
    中找到。
- en: 'The Go code of `prometheus.go` is as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`prometheus.go` 的 Go 代码如下：'
- en: '[PRE64]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The first external package is the Go client library for Prometheus and the second
    package is for using the default handler function (`promhttp.Handler()`).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个外部包是 Prometheus 的 Go 客户端库，第二个包是用于使用默认处理函数 (`promhttp.Handler()`)。
- en: '[PRE65]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Here, we define the two Prometheus metrics.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了两个 Prometheus 指标。
- en: '[PRE66]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This is where you register the variables for the metrics in Prometheus and define
    the metrics you want to read from the `runtime/metrics` package.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你在 Prometheus 中注册指标变量并定义你想要从 `runtime/metrics` 包中读取的指标的地方。
- en: '[PRE67]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This is where you register the handler function for the `/metrics` path. We
    use `promhttp.Handler()`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 `/metrics` 路径上注册处理函数的地方。我们使用 `promhttp.Handler()`。
- en: '[PRE68]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Note that such a program should definitely have at least two goroutines: one
    for running the HTTP server and another one for collecting the metrics. Usually,
    the HTTP server is on the goroutine that runs the `main()` function and the metric
    collection happens in a user-defined goroutine.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这样的程序肯定至少应该有两个goroutine：一个用于运行HTTP服务器，另一个用于收集指标。通常，HTTP服务器位于运行`main()`函数的goroutine上，而指标收集发生在用户定义的goroutine中。
- en: The outer `for` loop makes sure that the goroutine runs forever, whereas the
    inner `for` loop creates additional goroutines so that the value of the `/sched/goroutines:goroutines`
    metric changes all the time.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 外层`for`循环确保goroutine永远运行，而内层`for`循环创建额外的goroutine，以便`/sched/goroutines:goroutines`指标的值始终在变化。
- en: '[PRE69]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `runtime.GC()` function tells the Go garbage collector to run and is called
    for changing the `/memory/classes/heap/free:bytes` metric. The two `Set()` calls
    update the values of the metrics.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`runtime.GC()`函数告诉Go垃圾收集器运行，并用于更改`/memory/classes/heap/free:bytes`指标。两次`Set()`调用更新指标的值。'
- en: You can read more about the operation of the Go garbage collector in *Appendix
    A*, *Go Garbage Collector*.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在*附录A*，*Go垃圾收集器*中了解更多关于Go垃圾收集器操作的信息。
- en: '[PRE70]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The last statement runs the web server using the default Go router. Running
    `prometheus.go` from the `ch13/prom` directory requires executing the next commands:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条语句使用默认的Go路由器运行Web服务器。从`ch13/prom`目录运行`prometheus.go`需要执行以下命令：
- en: '[PRE71]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Although `prometheus.go` generates no output apart from the previous line, the
    next subsection illustrates how to read the desired metrics from it using `curl(1)`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`prometheus.go`除了上一行之外没有生成任何输出，但下一小节将说明如何使用`curl(1)`从其中读取所需的指标。
- en: Getting the metrics
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取指标
- en: You can get a list of the available metrics from `prometheus.go` using `curl(1)`
    in order to make sure that the application works as expected. I always test the
    operation of such an application with `curl(1)` or some other similar utility
    such as `wget(1)` before trying to get the metrics with Prometheus.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`curl(1)`从`prometheus.go`获取可用的指标列表，以确保应用程序按预期工作。在尝试使用Prometheus获取指标之前，我总是使用`curl(1)`或其他类似工具（如`wget(1)`）来测试此类应用程序的操作。
- en: '[PRE72]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The previous command assumes that `curl(1)` is executed on the same machine
    as the HTTP server and that the server listens to TCP port number `1234`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令假设`curl(1)`在运行HTTP服务器的同一台机器上执行，并且服务器监听TCP端口号`1234`。
- en: 'Next, we must enable Prometheus to pull the metrics—it is much easier to run
    Prometheus from a Docker image. The easiest way for a Prometheus Docker image
    to be able to see the Go application with the metrics is to execute both as Docker
    images. We are going to use the following Dockerfile (which is similar to `dFilev2`
    used previously) to convert `prometheus.go` into a Docker image:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须启用Prometheus以拉取指标——从Docker镜像运行Prometheus要容易得多。要使Prometheus Docker镜像能够看到带有指标的Go应用程序，最简单的方法是将两者都作为Docker镜像执行。我们将使用以下Dockerfile（与之前使用的`dFilev2`类似）将`prometheus.go`转换为Docker镜像：
- en: '[PRE73]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This is the name of the base Docker image that is used for building the binary.
    `golang:alpine` always contains the latest Go version as long as you update it
    regularly.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于构建二进制文件的基础Docker镜像的名称。`golang:alpine`只要您定期更新，就始终包含最新的Go版本。
- en: '[PRE74]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The previous commands download the required dependencies before trying to build
    the binary.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令在尝试构建二进制文件之前会下载所需的依赖项。
- en: '[PRE75]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Building the desired Docker image, which is going to be named `goapp`, is as
    simple as running the next command:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 构建所需的Docker镜像，该镜像将被命名为`goapp`，只需运行以下命令即可：
- en: '[PRE76]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'If you prefer to use `docker buildx`, you should execute the following command
    instead:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢使用`docker buildx`，则应执行以下命令：
- en: '[PRE77]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'As usual, the output of `docker images` verifies the successful creation of
    the `goapp` Docker image—in my case, the relevant entry looks as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，`docker images`的输出验证了`goapp` Docker镜像成功创建——在我的情况下，相关条目如下：
- en: '[PRE78]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Let us now discuss how to configure Prometheus to pull the desired metrics.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论如何配置Prometheus以拉取所需的指标。
- en: Putting the metrics in Prometheus
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将指标放入Prometheus
- en: 'To be able to pull the metrics, Prometheus needs a proper configuration file
    that specifies the source of the metrics. The configuration file that is going
    to be used is as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够拉取指标，Prometheus需要一个适当的配置文件，该文件指定了指标的来源。将要使用的配置文件如下：
- en: '[PRE79]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We tell Prometheus to connect to a host named `goapp` using port number `1234`.
    Prometheus pulls data every five seconds, according to the value of the `scrape_interval`
    field. You should put `prometheus.yml` in the `prometheus` directory, which should
    be under the same root directory as the `docker-compose.yml` file that is presented
    next.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉Prometheus使用端口号`1234`连接到名为`goapp`的主机。Prometheus根据`scrape_interval`字段的值每五秒拉取一次数据。您应该将`prometheus.yml`放在`prometheus`目录下，该目录应与下一个展示的`docker-compose.yml`文件位于同一根目录下。
- en: 'Prometheus, as well as Grafana and the Go application, are going to run as
    Docker containers using the next `docker-compose.yml` file:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus、Grafana以及Go应用程序都将使用下一个`docker-compose.yml`文件作为Docker容器运行：
- en: '[PRE80]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This is the part that deals with the Go application that collects the metrics.
    The Docker image name, as well as the internal hostname of the Docker container,
    is `goapp`. You should define the port number that is going to be open for connections.
    In this case, both the internal and external port numbers are `1234`. The internal
    one is mapped to the external one. Additionally, you should put all Docker images
    under the same network, which, in this case, is called `monitoring` and is defined
    in a while.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这是处理收集指标的应用程序的Go部分。Docker镜像名称以及Docker容器的内部主机名是`goapp`。您应该定义将要开放的连接端口号。在这种情况下，内部和外部端口号都是`1234`。内部端口号映射到外部端口号。此外，您应该将所有Docker镜像放在同一个网络下，在这个例子中，该网络被称为`monitoring`，并且将在稍后定义。
- en: '[PRE81]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This is how you pass your own copy of `prometheus.yml` to the Docker image to
    be used by Prometheus. So, `./prometheus/prometheus.yml` from the local machine
    can be accessed as `/etc/prometheus/prometheus.yml` from within the Docker image.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您如何将本地机器上的`prometheus.yml`副本传递给用于Prometheus的Docker镜像。因此，`./prometheus/prometheus.yml`可以从Docker镜像内部作为`/etc/prometheus/prometheus.yml`访问。
- en: '[PRE82]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This is where you tell Prometheus which configuration file to use.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您告诉Prometheus使用哪个配置文件的地方。
- en: '[PRE83]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This is where the definition of the Prometheus part of the scenario ends. The
    Docker image used is called `prom/prometheus:latest` and the internal name of
    it is `prometheus`. Prometheus listens to port number `9090`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是场景中Prometheus部分的定义结束的地方。使用的Docker镜像名为`prom/prometheus:latest`，其内部名称为`prometheus`。Prometheus监听端口号`9090`。
- en: 'Last, we present the Grafana part. Grafana listens to port number `3000`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们展示Grafana部分。Grafana监听端口号`3000`：
- en: '[PRE84]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This is the current password of the admin user (`helloThere`)—you need that
    for connecting to Grafana.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这是管理员用户（`helloThere`）的当前密码——您需要它来连接到Grafana。
- en: '[PRE85]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The preceding two lines in combination with the two `volumes` fields allow both
    Grafana and Prometheus to save their data locally so that data is not lost each
    time you restart the Docker images.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行与两个`volumes`字段结合使用，允许Grafana和Prometheus将数据本地保存，这样每次重启Docker镜像时数据都不会丢失。
- en: '[PRE86]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Internally, all three containers are known by the value of their `container_name`
    field. However, externally, you can connect to the open ports from your local
    machine as `http://localhost:port` or from another machine using `http://hostname:port`—the
    second way is not very secure and should be blocked by a firewall. Lastly, you
    need to run `docker-compose up` and you are done! The Go application begins exposing
    data and Prometheus begins collecting it.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，所有三个容器都以其`container_name`字段的值为名。然而，在外部，您可以从本地机器作为`http://localhost:port`或从另一台机器使用`http://hostname:port`连接到开放的端口——第二种方式不太安全，应该通过防火墙阻止。最后，您需要运行`docker-compose
    up`，这样您就完成了！Go应用程序开始公开数据，Prometheus开始收集它。
- en: 'The next figure shows the Prometheus UI (`http://hostname:9090`) displaying
    a simple plot of `packt_n_goroutines`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图显示了Prometheus UI（`http://hostname:9090`）显示`packt_n_goroutines`的简单图表：
- en: '![A screenshot of a graph  Description automatically generated](img/B21003_13_01.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![一个图表的截图  自动生成的描述](img/B21003_13_01.png)'
- en: 'Figure 13.1: The Prometheus UI when displaying packt_n_goroutines'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1：显示packt_n_goroutines的Prometheus UI
- en: This output, which shows the values of the metrics in a graphical way, is very
    handy for debugging purposes, but it is far from being truly professional as Prometheus
    is not a visualization tool. The next subsection shows how you can connect Prometheus
    with Grafana and use Grafana to create impressive plots.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出以图形方式显示指标值，对于调试非常有用，但它远非真正专业，因为Prometheus不是一个可视化工具。下一个小节将展示如何将Prometheus与Grafana连接，并使用Grafana创建令人印象深刻的图表。
- en: Visualizing Prometheus metrics in Grafana
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Grafana中可视化Prometheus指标
- en: There is no point in collecting metrics without doing something with them, and
    by something, I mean visualizing them. Prometheus and Grafana work very well together,
    so we are going to use Grafana for the visualization part. The single most important
    task that you should perform in Grafana is connecting it with your Prometheus
    instance. In Grafana terminology, you should create a Grafana data source that
    allows Grafana to get data from Prometheus.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不对收集的指标做任何处理，那么收集指标就没有意义了，这里的“处理”指的是可视化。Prometheus 和 Grafana 配合得非常好，因此我们将使用
    Grafana 进行可视化部分。在 Grafana 中，您应该执行的最重要任务是将它与您的 Prometheus 实例连接起来。在 Grafana 术语中，您应该创建一个
    Grafana 数据源，允许 Grafana 从 Prometheus 获取数据。
- en: 'The steps for creating a data source with our Prometheus installation are the
    following:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的 Prometheus 安装创建数据源的步骤如下：
- en: First, go to `http://localhost:3000` to connect to Grafana, because Grafana
    needs to learn about the data stored in Prometheus.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，前往 `http://localhost:3000` 以连接到 Grafana，因为 Grafana 需要了解存储在 Prometheus 中的数据。
- en: The username of the administrator is `admin`, whereas the password is defined
    in the value of the `GF_SECURITY_ADMIN_PASSWORD` parameter of the `docker-compose.yml`
    file.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管理员的用户名是 `admin`，而密码定义在 `docker-compose.yml` 文件的 `GF_SECURITY_ADMIN_PASSWORD`
    参数值中。
- en: Then, select **Add your first data source**. From the list of data sources,
    select **Prometheus**, which is usually at the top of the list.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择 **添加您的第一个数据源**。从数据源列表中选择 **Prometheus**，它通常位于列表顶部。
- en: Put `http://prometheus:9090` in the **URL** field and then press the **Save
    & Test** button. Due to the internal network that exists between the Docker images,
    the Grafana container knows the Prometheus container by the `prometheus` hostname—this
    is the value of the `container_name` field. As you already know, you can also
    connect to Prometheus from your local machine using `http://localhost:9090`.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **URL** 字段中输入 `http://prometheus:9090`，然后按下 **保存 & 测试** 按钮。由于 Docker 镜像之间存在内部网络，Grafana
    容器通过 `prometheus` 主机名知道 Prometheus 容器——这是 `container_name` 字段的值。正如您已经知道的，您也可以使用
    `http://localhost:9090` 从您的本地机器连接到 Prometheus。
- en: We are done! The name of the data source is `Prometheus`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了！数据源的名字是 `Prometheus`。
- en: After these steps, create a new dashboard from the initial Grafana screen and
    put a new visualization on it. Select **Prometheus** as the data source of the
    panel if it is not already selected. Then, go to the **Metrics** drop-down menu
    and select the desired metrics. Click **Save** and you are done. Create as many
    panels as you want.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些步骤之后，从初始的 Grafana 屏幕创建一个新的仪表板，并在上面放置一个新的可视化。如果面板的数据源尚未选择，请选择 **Prometheus**。然后，转到
    **指标** 下拉菜单并选择所需的指标。点击 **保存**，您就完成了。创建您想要的任何数量的面板。
- en: The next figure shows Grafana visualizing two metrics from Prometheus as exposed
    by `prometheus.go`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图显示了 Grafana 将 `prometheus.go` 暴露的两个指标进行可视化。
- en: '![A screenshot of a computer screen  Description automatically generated](img/B21003_13_02.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成描述](img/B21003_13_02.png)'
- en: 'Figure 13.2: Visualizing metrics in Grafana'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2：在 Grafana 中可视化指标
- en: Grafana has many more capabilities than the ones presented here—if you are working
    with system metrics and want to check the performance of your Go applications,
    Prometheus and Grafana are good and popular choices.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Grafana 拥有比这里展示的更多功能——如果您正在处理系统指标并想检查 Go 应用的性能，Prometheus 和 Grafana 是好且流行的选择。
- en: In this section, we learned how to send metrics to Prometheus from a Go application
    and how to visualize the metrics in Grafana. However, nothing is going to make
    sense if we do not know what metrics to collect, what a metric means, or how to
    collect metrics without sacrificing the overall performance of an application.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何从 Go 应用程序向 Prometheus 发送指标，以及如何在 Grafana 中可视化这些指标。然而，如果我们不知道要收集哪些指标，指标的含义是什么，或者如何在不牺牲应用程序整体性能的情况下收集指标，那么这一切都没有意义。
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was about a recent addition to Go testing, which is fuzz testing.
    Fuzz testing can help you find bugs in your code by generating test data on its
    own. While fuzz testing offers several benefits, it is important to note that
    it is not a silver bullet. This means that it should be used in conjunction with
    other testing techniques and security practices to ensure comprehensive coverage
    and robust security measures.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讲述了 Go 测试的一个新功能，即模糊测试。模糊测试可以通过自行生成测试数据来帮助您在代码中找到错误。虽然模糊测试提供了几个好处，但重要的是要注意它并不是万能的。这意味着它应该与其他测试技术和安全实践结合使用，以确保全面的覆盖和强大的安全措施。
- en: You might say that after making sure that your software has no bugs, you may
    need to make it faster. In such cases, you need to understand how your resources
    are being used—observability is about collecting performance-related information
    that helps you identify the behavior of your application.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会说，在确保你的软件没有错误之后，你可能需要让它运行得更快。在这种情况下，你需要了解你的资源是如何被使用的——可观测性是关于收集与性能相关的信息，这些信息有助于你识别应用程序的行为。
- en: Observability is crucial in modern, complex systems where traditional monitoring
    methods may fall short. It enables engineers and operators to gain insights into
    the inner workings of a system, diagnose problems, and improve the overall system
    reliability and performance. The concept is closely related to DevOps and **Site
    Reliability Engineering** (**SRE**) practices, emphasizing the importance of understanding,
    and managing systems in real-world, production environments.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 可观测性在现代复杂系统中至关重要，因为传统的监控方法可能无法满足需求。它使工程师和操作员能够深入了解系统的内部运作，诊断问题，并提高整体系统的可靠性和性能。这一概念与DevOps和**站点可靠性工程（SRE**）实践密切相关，强调在现实世界的生产环境中理解和管理系统的重要性。
- en: In the next chapter, which is about efficiency and performance, we are going
    to learn how to avoid memory leaks, how to benchmark Go code, and about Go memory
    management.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何避免内存泄漏，如何基准测试Go代码，以及Go的内存管理。
- en: Exercises
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Try to do the following exercises on your own:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下练习：
- en: Run `cpuid.go` on your own machine and see the capabilities and features of
    your hardware.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的机器上运行 `cpuid.go` 并查看你的硬件的功能和特性。
- en: Create a version of `cpuid.go` that writes the desired information in logs.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个将所需信息写入日志的 `cpuid.go` 版本。
- en: Fix the `AddInt()` function from `fuzz``/code.go`.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复 `fuzz/code.go` 中的 `AddInt()` 函数。
- en: Create a function for integer multiplication that uses a `for` loop in its implementation.
    Write testing functions and fuzz testing functions for it.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个使用 `for` 循环实现整数乘法的函数。为它编写测试函数和模糊测试函数。
- en: Additional resources
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'The `runtime/metrics` package: [https://pkg.go.dev/runtime/metrics](https://pkg.go.dev/runtime/metrics)'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runtime/metrics` 包: [https://pkg.go.dev/runtime/metrics](https://pkg.go.dev/runtime/metrics)'
- en: 'The `expvar` package: [https://pkg.go.dev/expvar](https://pkg.go.dev/expvar)'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expvar` 包: [https://pkg.go.dev/expvar](https://pkg.go.dev/expvar)'
- en: 'Prometheus: [https://prometheus.io/](https://prometheus.io/)'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Prometheus: [https://prometheus.io/](https://prometheus.io/)'
- en: 'Grafana: [https://grafana.com/](https://grafana.com/)'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Grafana: [https://grafana.com/](https://grafana.com/)'
- en: 'Kibana: [https://www.elastic.co/kibana/](https://www.elastic.co/kibana/)'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Kibana: [https://www.elastic.co/kibana/](https://www.elastic.co/kibana/)'
- en: 'Elasticsearch: [https://www.elastic.co/](https://www.elastic.co/ )'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Elasticsearch: [https://www.elastic.co/](https://www.elastic.co/)'
- en: Leave a review!
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 留下评论！
- en: Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below to get a free eBook of your choice.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 喜欢这本书吗？通过留下亚马逊评论来帮助像你这样的读者。扫描下面的二维码，获取你选择的免费电子书。
- en: '![](img/Review_QR_Code.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![评论二维码](img/Review_QR_Code.png)'
