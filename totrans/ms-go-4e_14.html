<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer203">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">14</span></h1>
<h1 class="chapterTitle" id="_idParaDest-385"><span class="koboSpan" id="kobo.2.1">Efficiency and Performance</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">Every story has a villain. </span><span class="koboSpan" id="kobo.3.2">For developers, that villain is usually time. </span><span class="koboSpan" id="kobo.3.3">They must write code in a given time frame and ideally, the code must run as fast as possible. </span><span class="koboSpan" id="kobo.3.4">Most of the errors and bugs are a result of fighting with time constraints, both realistic and imaginary ones! </span><span class="koboSpan" id="kobo.3.5">So, this chapter is here to help you fight with the second aspect of time: efficiency and performance. </span><span class="koboSpan" id="kobo.3.6">For the first aspect of time, you need a good manager with technical skills.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4.1">The first part of the chapter is about benchmarking Go code using benchmark functions that measure the performance of a function or an entire program. </span><span class="koboSpan" id="kobo.4.2">Thinking that the implementation of a function is faster than a different implementation is not enough. </span><span class="koboSpan" id="kobo.4.3">We need to be able to prove it.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5.1">After that, we talk about how Go manages memory and how careless Go code can introduce memory leaks. </span><span class="koboSpan" id="kobo.5.2">A memory leak in Go occurs when memory that is no longer needed is not properly released, causing the program’s memory usage to grow over time. </span><span class="koboSpan" id="kobo.5.3">Understanding the memory model is crucial for writing efficient, correct, and concurrent Go programs. </span><span class="koboSpan" id="kobo.5.4">In practice, when our code uses large amounts of memory, which is not usually the case, we need to take extra care with our code for better performance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6.1">Lastly, we show how to use eBPF with Go. </span><span class="koboSpan" id="kobo.6.2">eBPF, which stands for Extended Berkeley Packet Filter, is a technology that enables programmability in</span><a id="_idIndexMarker1196"/><span class="koboSpan" id="kobo.7.1"> the </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.8.1">Linux kernel</span></strong><span class="koboSpan" id="kobo.9.1">. </span><span class="koboSpan" id="kobo.9.2">It originated as an extension of the</span><a id="_idIndexMarker1197"/><span class="koboSpan" id="kobo.10.1"> traditional </span><strong class="keyWord"><span class="koboSpan" id="kobo.11.1">Berkeley Packet Filter</span></strong><span class="koboSpan" id="kobo.12.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.13.1">BPF</span></strong><span class="koboSpan" id="kobo.14.1">), which was designed for packet filtering within the kernel. </span><span class="koboSpan" id="kobo.14.2">eBPF, however, is a more general-purpose and flexible framework that allows the execution of user-supplied programs within the kernel space without requiring changes to the kernel itself.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.15.1">We will cover the following topics:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.16.1">Benchmarking code</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.17.1">Buffered versus unbuffered file I/O</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.18.1">Wrongly defined benchmark functions</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.19.1">Go memory management</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.20.1">Memory leaks</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.21.1">Working with eBPF</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.22.1">The section that follows is about benchmarking Go code, which helps you determine what is faster and what is slower in your code—this makes it a perfect place to begin your search for efficiency. </span></p>
<h1 class="heading-1" id="_idParaDest-386"><span class="koboSpan" id="kobo.23.1">Benchmarking code</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.24.1">Benchmarking measures </span><a id="_idIndexMarker1198"/><span class="koboSpan" id="kobo.25.1">the performance of a function or a program, allowing you to</span><a id="_idIndexMarker1199"/><span class="koboSpan" id="kobo.26.1"> compare different implementations and understand the performance impact of code changes. </span><span class="koboSpan" id="kobo.26.2">Using that information, you can easily reveal the part of the code that needs to be rewritten to improve its performance. </span><span class="koboSpan" id="kobo.26.3">It goes without saying that you should not benchmark Go code on a busy machine that is currently being used for other, more important, purposes unless you have a very good reason to do so! </span><span class="koboSpan" id="kobo.26.4">Otherwise, you might interfere with the benchmarking process and get inaccurate results, but most importantly, you might generate performance issues on the machine.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.27.1">Most of the time, the load of the operating system plays a key role in the performance of your code. </span><span class="koboSpan" id="kobo.27.2">Let me tell you a story here: a Java utility I developed for a project performs lots of computations and finishes in 6,242 seconds (roughly 1.7 hours) when running on its own. </span><span class="koboSpan" id="kobo.27.3">It took about a day for four instances of the same Java command line utility to run on the same Linux machine! </span><span class="koboSpan" id="kobo.27.4">If you think about it, running them one after the other would have been faster than running them at the same time!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.28.1">Go follows certain conventions regarding benchmarking (and testing). </span><span class="koboSpan" id="kobo.28.2">The most important convention is that the name of a benchmark function must begin with </span><code class="inlineCode"><span class="koboSpan" id="kobo.29.1">Benchmark</span></code><span class="koboSpan" id="kobo.30.1">. </span><span class="koboSpan" id="kobo.30.2">After the </span><code class="inlineCode"><span class="koboSpan" id="kobo.31.1">Benchmark</span></code><span class="koboSpan" id="kobo.32.1"> word, we can put an underscore or an uppercase letter. </span><span class="koboSpan" id="kobo.32.2">Therefore, both </span><code class="inlineCode"><span class="koboSpan" id="kobo.33.1">BenchmarkFunctionName()</span></code><span class="koboSpan" id="kobo.34.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.35.1">Benchmark_functionName()</span></code><span class="koboSpan" id="kobo.36.1"> are valid benchmark functions, whereas </span><code class="inlineCode"><span class="koboSpan" id="kobo.37.1">Benchmarkfunctionname()</span></code><span class="koboSpan" id="kobo.38.1"> is not. </span><span class="koboSpan" id="kobo.38.2">By convention such functions are put in files that end with </span><code class="inlineCode"><span class="koboSpan" id="kobo.39.1">_test.go</span></code><span class="koboSpan" id="kobo.40.1">. </span><span class="koboSpan" id="kobo.40.2">Once the benchmarking is correct, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.41.1">go test</span></code><span class="koboSpan" id="kobo.42.1"> subcommand does all the dirty work for you, which includes scanning all </span><code class="inlineCode"><span class="koboSpan" id="kobo.43.1">*_test.go</span></code><span class="koboSpan" id="kobo.44.1"> files for special functions, generating a proper temporary </span><code class="inlineCode"><span class="koboSpan" id="kobo.45.1">main</span></code><span class="koboSpan" id="kobo.46.1"> package, calling these special functions, getting the results, and generating the final output.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.47.1">Benchmark functions use </span><code class="inlineCode"><span class="koboSpan" id="kobo.48.1">testing.B</span></code><span class="koboSpan" id="kobo.49.1"> variables, whereas testing functions use </span><code class="inlineCode"><span class="koboSpan" id="kobo.50.1">testing.T</span></code><span class="koboSpan" id="kobo.51.1"> variables. </span><span class="koboSpan" id="kobo.51.2">It is easy to remember.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.52.1">Starting from Go 1.17, we can shuffle the execution order of both tests and benchmarks with the help of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.53.1">shuffle</span></code><span class="koboSpan" id="kobo.54.1"> parameter (</span><code class="inlineCode"><span class="koboSpan" id="kobo.55.1">go test -shuffle=on</span></code><span class="koboSpan" id="kobo.56.1">). </span><span class="koboSpan" id="kobo.56.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.57.1">shuffle</span></code><span class="koboSpan" id="kobo.58.1"> parameter accepts a value (which is the seed for the random number generator) and can be useful when you </span><a id="_idIndexMarker1200"/><span class="koboSpan" id="kobo.59.1">want to replay an execution order. </span><span class="koboSpan" id="kobo.59.2">Its default value is </span><a id="_idIndexMarker1201"/><span class="koboSpan" id="kobo.60.1">off. </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.61.1">The logic behind this capability is that, sometimes, the order in which tests and benchmarks are executed affects their results</span></strong><span class="koboSpan" id="kobo.62.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.63.1">The next subsection presents a simple benchmarking scenario where we try to optimize slice initializations.</span></p>
<h2 class="heading-2" id="_idParaDest-387"><span class="koboSpan" id="kobo.64.1">A simple benchmark scenario</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.65.1">We begin by presenting </span><a id="_idIndexMarker1202"/><span class="koboSpan" id="kobo.66.1">a scenario that tests the performance of two functions that do the same thing but with a different implementation. </span><span class="koboSpan" id="kobo.66.2">We want to be able to initialize slices with consecutive values that start from 0 and go up to a predefined value. </span><span class="koboSpan" id="kobo.66.3">So, given a slice named </span><code class="inlineCode"><span class="koboSpan" id="kobo.67.1">mySlice</span></code><span class="koboSpan" id="kobo.68.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.69.1">mySlice[0]</span></code><span class="koboSpan" id="kobo.70.1"> is going to have the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.71.1">0</span></code><span class="koboSpan" id="kobo.72.1">,</span><code class="inlineCode"><span class="koboSpan" id="kobo.73.1"> mySlice[1]</span></code><span class="koboSpan" id="kobo.74.1"> is going to have the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.75.1">1</span></code><span class="koboSpan" id="kobo.76.1">, and so on. </span><span class="koboSpan" id="kobo.76.2">The relevant code can be found inside </span><code class="inlineCode"><span class="koboSpan" id="kobo.77.1">ch14/slices</span></code><span class="koboSpan" id="kobo.78.1">, which contains two files named </span><code class="inlineCode"><span class="koboSpan" id="kobo.79.1">initialize.go</span></code><span class="koboSpan" id="kobo.80.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.81.1">initialize_test.go</span></code><span class="koboSpan" id="kobo.82.1">. </span><span class="koboSpan" id="kobo.82.2">The Go code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.83.1">initialize.go</span></code><span class="koboSpan" id="kobo.84.1"> is presented in two parts. </span><span class="koboSpan" id="kobo.84.2">The first part is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.85.1">package</span></span><span class="koboSpan" id="kobo.86.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.87.1">import</span></span><span class="koboSpan" id="kobo.88.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.89.1">"fmt"</span></span><span class="koboSpan" id="kobo.90.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.91.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.92.1">InitSliceNew</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.93.1">(n </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.94.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.95.1">)</span></span><span class="koboSpan" id="kobo.96.1"> []</span><span class="hljs-type"><span class="koboSpan" id="kobo.97.1">int</span></span><span class="koboSpan" id="kobo.98.1"> {
    s := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.99.1">make</span></span><span class="koboSpan" id="kobo.100.1">([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.101.1">int</span></span><span class="koboSpan" id="kobo.102.1">, n)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.103.1">for</span></span><span class="koboSpan" id="kobo.104.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.105.1">0</span></span><span class="koboSpan" id="kobo.106.1">; i &lt; n; i++ {
    	s[i] = i
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.107.1">return</span></span><span class="koboSpan" id="kobo.108.1"> s
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.109.1">In the previous code, we </span><a id="_idIndexMarker1203"/><span class="koboSpan" id="kobo.110.1">see the implementation of the desired functionality that uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.111.1">make()</span></code><span class="koboSpan" id="kobo.112.1"> to pre-allocate the desired memory space.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.113.1">The second part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.114.1">initialize.go</span></code><span class="koboSpan" id="kobo.115.1"> is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.116.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.117.1">InitSliceAppend</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.118.1">(n </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.119.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.120.1">)</span></span><span class="koboSpan" id="kobo.121.1"> []</span><span class="hljs-type"><span class="koboSpan" id="kobo.122.1">int</span></span><span class="koboSpan" id="kobo.123.1"> {
    s := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.124.1">make</span></span><span class="koboSpan" id="kobo.125.1">([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.126.1">int</span></span><span class="koboSpan" id="kobo.127.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.128.1">0</span></span><span class="koboSpan" id="kobo.129.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.130.1">for</span></span><span class="koboSpan" id="kobo.131.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.132.1">0</span></span><span class="koboSpan" id="kobo.133.1">; i &lt; n; i++ {
    	s = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.134.1">append</span></span><span class="koboSpan" id="kobo.135.1">(s, i)
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.136.1">return</span></span><span class="koboSpan" id="kobo.137.1"> s
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.138.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.139.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.140.1">()</span></span><span class="koboSpan" id="kobo.141.1"> {
    fmt.Println(InitSliceNew(</span><span class="hljs-number"><span class="koboSpan" id="kobo.142.1">10</span></span><span class="koboSpan" id="kobo.143.1">))
    fmt.Println(InitSliceAppend(</span><span class="hljs-number"><span class="koboSpan" id="kobo.144.1">10</span></span><span class="koboSpan" id="kobo.145.1">))
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.146.1">In </span><code class="inlineCode"><span class="koboSpan" id="kobo.147.1">InitSliceAppend()</span></code><span class="koboSpan" id="kobo.148.1">, we see a different implementation of the desired functionality that starts with an empty slice and uses multiple </span><code class="inlineCode"><span class="koboSpan" id="kobo.149.1">append()</span></code><span class="koboSpan" id="kobo.150.1"> calls to populate it. </span><span class="koboSpan" id="kobo.150.2">The purpose of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.151.1">main()</span></code><span class="koboSpan" id="kobo.152.1"> function is to naively test the functionality of </span><code class="inlineCode"><span class="koboSpan" id="kobo.153.1">InitSliceNew()</span></code><span class="koboSpan" id="kobo.154.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.155.1">InitSliceAppend()</span></code><span class="koboSpan" id="kobo.156.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.157.1">The implementation of the benchmarking functions is found in </span><code class="inlineCode"><span class="koboSpan" id="kobo.158.1">initialize_test.go</span></code><span class="koboSpan" id="kobo.159.1"> and is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.160.1">package</span></span><span class="koboSpan" id="kobo.161.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.162.1">import</span></span><span class="koboSpan" id="kobo.163.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.164.1">"testing"</span></span><span class="koboSpan" id="kobo.165.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.166.1">var</span></span><span class="koboSpan" id="kobo.167.1"> t []</span><span class="hljs-type"><span class="koboSpan" id="kobo.168.1">int</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.169.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.170.1">BenchmarkNew</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.171.1">(b *testing.B)</span></span><span class="koboSpan" id="kobo.172.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.173.1">for</span></span><span class="koboSpan" id="kobo.174.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.175.1">0</span></span><span class="koboSpan" id="kobo.176.1">; i &lt; b.N; i++ {
    	t = InitSliceNew(i)
    }
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.177.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.178.1">BenchmarkAppend</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.179.1">(b *testing.B)</span></span><span class="koboSpan" id="kobo.180.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.181.1">for</span></span><span class="koboSpan" id="kobo.182.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.183.1">0</span></span><span class="koboSpan" id="kobo.184.1">; i &lt; b.N; i++ {
    	t = InitSliceAppend(i)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.185.1">Here, we have two </span><a id="_idIndexMarker1204"/><span class="koboSpan" id="kobo.186.1">benchmarking functions that benchmark </span><code class="inlineCode"><span class="koboSpan" id="kobo.187.1">InitSliceNew()</span></code><span class="koboSpan" id="kobo.188.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.189.1">InitSliceAppend()</span></code><span class="koboSpan" id="kobo.190.1">. </span><span class="koboSpan" id="kobo.190.2">The global parameter </span><code class="inlineCode"><span class="koboSpan" id="kobo.191.1">t</span></code><span class="koboSpan" id="kobo.192.1"> is used to prevent Go from optimizing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.193.1">for</span></code><span class="koboSpan" id="kobo.194.1"> loops by preventing the return values of </span><code class="inlineCode"><span class="koboSpan" id="kobo.195.1">InitSliceNew()</span></code><span class="koboSpan" id="kobo.196.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.197.1">InitSliceAppend()</span></code><span class="koboSpan" id="kobo.198.1"> from being ignored.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.199.1">Keep in mind that the benchmarking process takes place inside the </span><code class="inlineCode"><span class="koboSpan" id="kobo.200.1">for</span></code><span class="koboSpan" id="kobo.201.1"> loop. </span><span class="koboSpan" id="kobo.201.2">This means that, when needed, we can declare new variables, open network connections, and so on, outside that </span><code class="inlineCode"><span class="koboSpan" id="kobo.202.1">for</span></code><span class="koboSpan" id="kobo.203.1"> loop.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.204.1">And now some important information regarding benchmarking: </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.205.1">each benchmark function is executed for at least one second by default</span></strong><span class="koboSpan" id="kobo.206.1">—this duration also includes the execution time of the functions that are called by a benchmark function. </span><span class="koboSpan" id="kobo.206.2">If the benchmark function returns in a time that is less than one second, the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.207.1">b.N</span></code><span class="koboSpan" id="kobo.208.1"> is increased, and the function runs again as many times in total as the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.209.1">b.N</span></code><span class="koboSpan" id="kobo.210.1">. </span><span class="koboSpan" id="kobo.210.2">The first time the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.211.1">b.N</span></code><span class="koboSpan" id="kobo.212.1"> is 1, then it becomes 2, then 5, then 10, then 20, then 50, and so on. </span><span class="koboSpan" id="kobo.212.2">This happens because the faster the function, the more times Go needs to run it to get accurate results.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.213.1">Benchmarking the code on a macOS M1 Max laptop produces the following kind of output—your output might vary:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.214.1">$ </span></span><span class="koboSpan" id="kobo.215.1">go </span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.216.1">test</span></span><span class="koboSpan" id="kobo.217.1"> -bench=. </span><span class="koboSpan" id="kobo.217.2">*.go
goos: darwin
goarch: arm64
BenchmarkNew-10             255704         79712 ns/op
BenchmarkAppend-10           86847        143459 ns/op
PASS
ok    command-line-arguments    33.539s
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.218.1">There are two important points here. </span><span class="koboSpan" id="kobo.218.2">First, the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.219.1">-bench</span></code><span class="koboSpan" id="kobo.220.1"> parameter specifies the benchmark functions that are going to be executed. </span><span class="koboSpan" id="kobo.220.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.221.1">.</span></code><span class="koboSpan" id="kobo.222.1"> value used is a regular expression that matches all valid benchmark functions. </span><span class="koboSpan" id="kobo.222.2">The second point is that if you omit the </span><code class="inlineCode"><span class="koboSpan" id="kobo.223.1">-bench</span></code><span class="koboSpan" id="kobo.224.1"> parameter, no benchmark function is going to be executed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.225.1">The generated output shows that </span><code class="inlineCode"><span class="koboSpan" id="kobo.226.1">InitSliceNew()</span></code><span class="koboSpan" id="kobo.227.1"> is faster than </span><code class="inlineCode"><span class="koboSpan" id="kobo.228.1">InitSliceAppend()</span></code><span class="koboSpan" id="kobo.229.1"> because </span><code class="inlineCode"><span class="koboSpan" id="kobo.230.1">InitSliceNew()</span></code><span class="koboSpan" id="kobo.231.1"> was executed </span><code class="inlineCode"><span class="koboSpan" id="kobo.232.1">255704</span></code><span class="koboSpan" id="kobo.233.1"> times, each time taking </span><code class="inlineCode"><span class="koboSpan" id="kobo.234.1">79712 ns</span></code><span class="koboSpan" id="kobo.235.1">, whereas </span><code class="inlineCode"><span class="koboSpan" id="kobo.236.1">InitSliceAppend()</span></code><span class="koboSpan" id="kobo.237.1"> was executed </span><code class="inlineCode"><span class="koboSpan" id="kobo.238.1">86847</span></code><span class="koboSpan" id="kobo.239.1"> times, each time taking </span><code class="inlineCode"><span class="koboSpan" id="kobo.240.1">143459 ns</span></code><span class="koboSpan" id="kobo.241.1">. </span><span class="koboSpan" id="kobo.241.2">This makes perfect sense as </span><code class="inlineCode"><span class="koboSpan" id="kobo.242.1">InitSliceAppend()</span></code><span class="koboSpan" id="kobo.243.1"> needs to allocate memory all the time—this means that both the length and the capacity of the slice change, whereas </span><code class="inlineCode"><span class="koboSpan" id="kobo.244.1">InitSliceNew()</span></code><span class="koboSpan" id="kobo.245.1"> allocates the prerequisite memory once and for all.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.246.1">Understanding how </span><code class="inlineCode"><span class="koboSpan" id="kobo.247.1">append()</span></code><span class="koboSpan" id="kobo.248.1"> works is going to help you make sense of the results. </span><span class="koboSpan" id="kobo.248.2">If the underlying array has sufficient capacity, then the length of the resulting slice is increased by the number of elements appended and its capacity remains the same. </span><span class="koboSpan" id="kobo.248.3">This means that there are no new memory allocations. </span><span class="koboSpan" id="kobo.248.4">However, if the underlying array does not have sufficient capacity, a new array is created, which means that a new memory space is allocated, with a larger capacity. </span><span class="koboSpan" id="kobo.248.5">After that, the slice is updated to reference the new array, and its</span><a id="_idIndexMarker1205"/><span class="koboSpan" id="kobo.249.1"> length and capacity are adjusted accordingly. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.250.1">The subsection that follows shows a benchmarking technique that allows us to reduce the number of allocations.</span></p>
<h2 class="heading-2" id="_idParaDest-388"><span class="koboSpan" id="kobo.251.1">Benchmarking the number of memory allocations</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.252.1">In this</span><a id="_idIndexMarker1206"/><span class="koboSpan" id="kobo.253.1"> second benchmarking scenario, we are going to deal with a performance issue that has to do with the number of memory allocations that take place during the operation of a function. </span><span class="koboSpan" id="kobo.253.2">We present two versions of the same program to illustrate the differences between the slow version and the improved ones. </span><span class="koboSpan" id="kobo.253.3">All the relevant code can be found in two directories inside </span><code class="inlineCode"><span class="koboSpan" id="kobo.254.1">ch14/alloc</span></code><span class="koboSpan" id="kobo.255.1"> named </span><code class="inlineCode"><span class="koboSpan" id="kobo.256.1">base</span></code><span class="koboSpan" id="kobo.257.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.258.1">improved</span></code><span class="koboSpan" id="kobo.259.1">.</span></p>
<h3 class="heading-3" id="_idParaDest-389"><span class="koboSpan" id="kobo.260.1">Initial version</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.261.1">The purpose of</span><a id="_idIndexMarker1207"/><span class="koboSpan" id="kobo.262.1"> the function that is being benchmarked is to write a message to a buffer. </span><span class="koboSpan" id="kobo.262.2">This version contains no optimizations. </span><span class="koboSpan" id="kobo.262.3">The code of this first version is found in </span><code class="inlineCode"><span class="koboSpan" id="kobo.263.1">ch14/alloc/base</span></code><span class="koboSpan" id="kobo.264.1">, which contains two Go source code files. </span><span class="koboSpan" id="kobo.264.2">The first one is named </span><code class="inlineCode"><span class="koboSpan" id="kobo.265.1">allocate.go</span></code><span class="koboSpan" id="kobo.266.1"> and comes with the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.267.1">package</span></span><span class="koboSpan" id="kobo.268.1"> allocate
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.269.1">import</span></span><span class="koboSpan" id="kobo.270.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.271.1">"bytes"</span></span><span class="koboSpan" id="kobo.272.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.273.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.274.1">writeMessage</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.275.1">(msg []</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.276.1">byte</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.277.1">)</span></span><span class="koboSpan" id="kobo.278.1"> {
    b := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.279.1">new</span></span><span class="koboSpan" id="kobo.280.1">(bytes.Buffer)
    b.Write(msg)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.281.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.282.1">writeMessage()</span></code><span class="koboSpan" id="kobo.283.1"> function just writes the given message in a new buffer (</span><code class="inlineCode"><span class="koboSpan" id="kobo.284.1">bytes.Buffer</span></code><span class="koboSpan" id="kobo.285.1">). </span><span class="koboSpan" id="kobo.285.2">As we are only concerned about its performance, we do not deal with error handling.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.286.1">The second</span><a id="_idIndexMarker1208"/><span class="koboSpan" id="kobo.287.1"> file, which is called </span><code class="inlineCode"><span class="koboSpan" id="kobo.288.1">allocate_test.go</span></code><span class="koboSpan" id="kobo.289.1">, contains benchmarks and comes with the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.290.1">package</span></span><span class="koboSpan" id="kobo.291.1"> allocate
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.292.1">import</span></span><span class="koboSpan" id="kobo.293.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.294.1">"testing"</span></span><span class="koboSpan" id="kobo.295.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.296.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.297.1">BenchmarkWrite</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.298.1">(b *testing.B)</span></span><span class="koboSpan" id="kobo.299.1"> {
    msg := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.300.1">byte</span></span><span class="koboSpan" id="kobo.301.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.302.1">"Mastering Go!"</span></span><span class="koboSpan" id="kobo.303.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.304.1">for</span></span><span class="koboSpan" id="kobo.305.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.306.1">0</span></span><span class="koboSpan" id="kobo.307.1">; i &lt; b.N; i++ {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.308.1">for</span></span><span class="koboSpan" id="kobo.309.1"> k := </span><span class="hljs-number"><span class="koboSpan" id="kobo.310.1">0</span></span><span class="koboSpan" id="kobo.311.1">; k &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.312.1">50</span></span><span class="koboSpan" id="kobo.313.1">; k++ {
            writeMessage(msg)
        }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.314.1">Benchmarking the code using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.315.1">-benchmem</span></code><span class="koboSpan" id="kobo.316.1"> command line flag, which also displays memory allocations, produces the following kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.317.1">$ </span></span><span class="koboSpan" id="kobo.318.1">go </span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.319.1">test</span></span><span class="koboSpan" id="kobo.320.1"> -bench=. </span><span class="koboSpan" id="kobo.320.2">-benchmem *.go
goos: darwin
goarch: arm64
BenchmarkWrite-10     1148637    1024 ns/op    3200 B/op    50 allocs/op
PASS
ok    command-line-arguments    2.256s
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.321.1">Each </span><a id="_idIndexMarker1209"/><span class="koboSpan" id="kobo.322.1">execution of the benchmarking function requires 50 memory allocations. </span><span class="koboSpan" id="kobo.322.2">This means that there is room for improvement regarding the number of memory allocations that are taking place. </span><span class="koboSpan" id="kobo.322.3">We are going to try to reduce them in the subsection that follows.</span></p>
<h3 class="heading-3" id="_idParaDest-390"><span class="koboSpan" id="kobo.323.1">Improving the number of memory allocations</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.324.1">In this subsection, we </span><a id="_idIndexMarker1210"/><span class="koboSpan" id="kobo.325.1">present three different functions that all implement the writing of a message to a buffer. </span><span class="koboSpan" id="kobo.325.2">However, this time, the buffer is given as a function parameter instead of being initialized internally.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.326.1">The code of the improved version is found in </span><code class="inlineCode"><span class="koboSpan" id="kobo.327.1">ch14/alloc/improved</span></code><span class="koboSpan" id="kobo.328.1"> and contains two Go source code files. </span><span class="koboSpan" id="kobo.328.2">The first one is named </span><code class="inlineCode"><span class="koboSpan" id="kobo.329.1">improve.go</span></code><span class="koboSpan" id="kobo.330.1"> and contains the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.331.1">package</span></span><span class="koboSpan" id="kobo.332.1"> allocate
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.333.1">import</span></span><span class="koboSpan" id="kobo.334.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.335.1">"bytes"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.336.1">"io"</span></span><span class="koboSpan" id="kobo.337.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.338.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.339.1">writeMessageBuffer</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.340.1">(msg []</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.341.1">byte</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.342.1">, b bytes.Buffer)</span></span><span class="koboSpan" id="kobo.343.1"> {
    b.Write(msg)
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.344.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.345.1">writeMessageBufferPointer</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.346.1">(msg []</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.347.1">byte</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.348.1">, b *bytes.Buffer)</span></span><span class="koboSpan" id="kobo.349.1"> {
    b.Write(msg)
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.350.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.351.1">writeMessageBufferWriter</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.352.1">(msg []</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.353.1">byte</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.354.1">, b io.Writer)</span></span><span class="koboSpan" id="kobo.355.1"> {
    b.Write(msg)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.356.1">What we have here are three functions that all implement the writing of a message to a buffer. </span><span class="koboSpan" id="kobo.356.2">However, </span><code class="inlineCode"><span class="koboSpan" id="kobo.357.1">writeMessageBuffer()</span></code><span class="koboSpan" id="kobo.358.1"> passes the buffer by value, whereas </span><code class="inlineCode"><span class="koboSpan" id="kobo.359.1">writeMessageBufferPointer()</span></code><span class="koboSpan" id="kobo.360.1"> passes a pointer to the buffer variable. </span><span class="koboSpan" id="kobo.360.2">Lastly, </span><code class="inlineCode"><span class="koboSpan" id="kobo.361.1">writeMessageBufferWriter()</span></code><span class="koboSpan" id="kobo.362.1"> uses an </span><code class="inlineCode"><span class="koboSpan" id="kobo.363.1">io.Writer</span></code><span class="koboSpan" id="kobo.364.1"> interface variable, which also supports </span><code class="inlineCode"><span class="koboSpan" id="kobo.365.1">bytes.Buffer</span></code><span class="koboSpan" id="kobo.366.1"> variables.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.367.1">The second file is named </span><code class="inlineCode"><span class="koboSpan" id="kobo.368.1">improve_test.go</span></code><span class="koboSpan" id="kobo.369.1"> and is going to be presented in three parts. </span><span class="koboSpan" id="kobo.369.2">The first part comes with the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.370.1">package</span></span><span class="koboSpan" id="kobo.371.1"> allocate
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.372.1">import</span></span><span class="koboSpan" id="kobo.373.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.374.1">"bytes"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.375.1">"testing"</span></span><span class="koboSpan" id="kobo.376.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.377.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.378.1">BenchmarkWBuf</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.379.1">(b *testing.B)</span></span><span class="koboSpan" id="kobo.380.1"> {
    msg := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.381.1">byte</span></span><span class="koboSpan" id="kobo.382.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.383.1">"Mastering Go!"</span></span><span class="koboSpan" id="kobo.384.1">)
    buffer := bytes.Buffer{}
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.385.1">for</span></span><span class="koboSpan" id="kobo.386.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.387.1">0</span></span><span class="koboSpan" id="kobo.388.1">; i &lt; b.N; i++ {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.389.1">for</span></span><span class="koboSpan" id="kobo.390.1"> k := </span><span class="hljs-number"><span class="koboSpan" id="kobo.391.1">0</span></span><span class="koboSpan" id="kobo.392.1">; k &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.393.1">50</span></span><span class="koboSpan" id="kobo.394.1">; k++ {
            writeMessageBuffer(msg, buffer)
        }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.395.1">This is the </span><a id="_idIndexMarker1211"/><span class="koboSpan" id="kobo.396.1">benchmarking function for </span><code class="inlineCode"><span class="koboSpan" id="kobo.397.1">writeMessageBuffer()</span></code><span class="koboSpan" id="kobo.398.1">. </span><span class="koboSpan" id="kobo.398.2">The buffer is allocated only once and is being used in all benchmarks by passing it to the relevant function.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.399.1">The second part is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.400.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.401.1">BenchmarkWBufPointerNoReset</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.402.1">(b *testing.B)</span></span><span class="koboSpan" id="kobo.403.1"> {
    msg := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.404.1">byte</span></span><span class="koboSpan" id="kobo.405.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.406.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.407.1">Mastering Go!"</span></span><span class="koboSpan" id="kobo.408.1">)
    buffer := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.409.1">new</span></span><span class="koboSpan" id="kobo.410.1">(bytes.Buffer)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.411.1">for</span></span><span class="koboSpan" id="kobo.412.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.413.1">0</span></span><span class="koboSpan" id="kobo.414.1">; i &lt; b.N; i++ {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.415.1">for</span></span><span class="koboSpan" id="kobo.416.1"> k := </span><span class="hljs-number"><span class="koboSpan" id="kobo.417.1">0</span></span><span class="koboSpan" id="kobo.418.1">; k &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.419.1">50</span></span><span class="koboSpan" id="kobo.420.1">; k++ {
            writeMessageBufferPointer(msg, buffer)
        }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.421.1">This is the benchmarking function for </span><code class="inlineCode"><span class="koboSpan" id="kobo.422.1">writeMessageBufferPointer()</span></code><span class="koboSpan" id="kobo.423.1">. </span><span class="koboSpan" id="kobo.423.2">Once again, the used buffer is allocated only once and is being shared by all benchmarks.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.424.1">The last part of </span><code class="inlineCode"><span class="koboSpan" id="kobo.425.1">improve_test.go</span></code><span class="koboSpan" id="kobo.426.1"> contains the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.427.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.428.1">BenchmarkWBufPointerReset</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.429.1">(b *testing.B)</span></span><span class="koboSpan" id="kobo.430.1"> {
    msg := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.431.1">byte</span></span><span class="koboSpan" id="kobo.432.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.433.1">"Mastering Go!"</span></span><span class="koboSpan" id="kobo.434.1">)
    buffer := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.435.1">new</span></span><span class="koboSpan" id="kobo.436.1">(bytes.Buffer)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.437.1">for</span></span><span class="koboSpan" id="kobo.438.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.439.1">0</span></span><span class="koboSpan" id="kobo.440.1">; i &lt; b.N; i++ {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.441.1">for</span></span><span class="koboSpan" id="kobo.442.1"> k := </span><span class="hljs-number"><span class="koboSpan" id="kobo.443.1">0</span></span><span class="koboSpan" id="kobo.444.1">; k &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.445.1">50</span></span><span class="koboSpan" id="kobo.446.1">; k++ {
            writeMessageBufferPointer(msg, buffer)
            buffer.Reset()
        }
    }
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.447.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.448.1">BenchmarkWBufWriterReset</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.449.1">(b *testing.B)</span></span><span class="koboSpan" id="kobo.450.1"> {
    msg := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.451.1">byte</span></span><span class="koboSpan" id="kobo.452.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.453.1">"Mastering Go!"</span></span><span class="koboSpan" id="kobo.454.1">)
    buffer := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.455.1">new</span></span><span class="koboSpan" id="kobo.456.1">(bytes.Buffer)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.457.1">for</span></span><span class="koboSpan" id="kobo.458.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.459.1">0</span></span><span class="koboSpan" id="kobo.460.1">; i &lt; b.N; i++ {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.461.1">for</span></span><span class="koboSpan" id="kobo.462.1"> k := </span><span class="hljs-number"><span class="koboSpan" id="kobo.463.1">0</span></span><span class="koboSpan" id="kobo.464.1">; k &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.465.1">50</span></span><span class="koboSpan" id="kobo.466.1">; k++ {
            writeMessageBufferWriter(msg, buffer)
            buffer.Reset()
        }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.467.1">Here, we see the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.468.1">buffer.Reset()</span></code><span class="koboSpan" id="kobo.469.1"> in the two benchmarking functions. </span><span class="koboSpan" id="kobo.469.2">The purpose of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.470.1">buffer.Reset()</span></code><span class="koboSpan" id="kobo.471.1"> function is to reset the buffer so it has no content. </span><span class="koboSpan" id="kobo.471.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.472.1">buffer.Reset()</span></code><span class="koboSpan" id="kobo.473.1"> function has the same results as </span><code class="inlineCode"><span class="koboSpan" id="kobo.474.1">buffer.Truncate(0)</span></code><span class="koboSpan" id="kobo.475.1">. </span><code class="inlineCode"><span class="koboSpan" id="kobo.476.1">Truncate(n)</span></code><span class="koboSpan" id="kobo.477.1"> discards all but the first </span><code class="inlineCode"><span class="koboSpan" id="kobo.478.1">n</span></code><span class="koboSpan" id="kobo.479.1"> unread bytes from the buffer. </span><span class="koboSpan" id="kobo.479.2">We use </span><code class="inlineCode"><span class="koboSpan" id="kobo.480.1">buffer.Reset()</span></code><span class="koboSpan" id="kobo.481.1"> thinking it might improve performance. </span><span class="koboSpan" id="kobo.481.2">However, this remains to be seen.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.482.1">Benchmarking the</span><a id="_idIndexMarker1212"/><span class="koboSpan" id="kobo.483.1"> improved version produces the following kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.484.1">$ </span></span><span class="koboSpan" id="kobo.485.1">go </span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.486.1">test</span></span><span class="koboSpan" id="kobo.487.1"> -bench=. </span><span class="koboSpan" id="kobo.487.2">-benchmem *.go
goos: darwin
goarch: arm64
BenchmarkWBuf-10            1128193   1056 ns/op   3200 B/op 50 allocs/op
BenchmarkWBufPointerNoReset-10 4050562   337.1 ns/op  2120 B/op 0 allocs/op
BenchmarkWBufPointerReset-10   7993546   150.7 ns/op   0 B/op      0 allocs/op
BenchmarkWBufWriterReset-10    7851434   151.8 ns/op   0 B/op   0 allocs/op
PASS
ok      command-line-arguments    7.667s
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.488.1">As presented by the results of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.489.1">BenchmarkWBuf()</span></code><span class="koboSpan" id="kobo.490.1"> benchmarking function, the use of a buffer as a parameter to the function does not automatically speed up the process, even if we share the same buffer during benchmarking. </span><span class="koboSpan" id="kobo.490.2">However, this is not the case with the remaining benchmarks. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.491.1">The use of a pointer to the buffer saves us from having to copy the buffer before passing it to the function—this explains the results of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.492.1">BenchmarkWBufPointerNoReset()</span></code><span class="koboSpan" id="kobo.493.1"> function where we have no additional memory allocations. </span><span class="koboSpan" id="kobo.493.2">However, we still need to use 2,120 bytes per operation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.494.1">The output with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.495.1">-benchmem</span></code><span class="koboSpan" id="kobo.496.1"> command line parameter includes two additional columns. </span><span class="koboSpan" id="kobo.496.2">The fourth column shows the amount of memory that was allocated on average in each execution of the benchmark function. </span><span class="koboSpan" id="kobo.496.3">The fifth column shows the number of allocations used to allocate the memory value of the fourth column.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.497.1">Lastly, it turns out that resetting the buffer using </span><code class="inlineCode"><span class="koboSpan" id="kobo.498.1">buffer.Reset()</span></code><span class="koboSpan" id="kobo.499.1"> after calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.500.1">writeMessageBufferPointer()</span></code><span class="koboSpan" id="kobo.501.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.502.1">writeMessageBufferWriter()</span></code><span class="koboSpan" id="kobo.503.1"> speeds up the process. </span><span class="koboSpan" id="kobo.503.2">A possible explanation for that is that an empty buffer is easier to work with. </span><span class="koboSpan" id="kobo.503.3">So, when </span><code class="inlineCode"><span class="koboSpan" id="kobo.504.1">buffer.Reset()</span></code><span class="koboSpan" id="kobo.505.1"> is used, we have both 0 memory allocations and 0 bytes per operation. </span><span class="koboSpan" id="kobo.505.2">As a result, </span><code class="inlineCode"><span class="koboSpan" id="kobo.506.1">BenchmarkWBufPointerReset()</span></code><span class="koboSpan" id="kobo.507.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.508.1">BenchmarkWBufWriterReset()</span></code><span class="koboSpan" id="kobo.509.1"> need 150.7 and 151.8 nanoseconds per operation, respectively, which is a huge speed up from the 1,056 and 337.1 nanoseconds per operation required by </span><code class="inlineCode"><span class="koboSpan" id="kobo.510.1">BenchmarkWBuf()</span></code><span class="koboSpan" id="kobo.511.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.512.1">BenchmarkWBufPointerNoReset()</span></code><span class="koboSpan" id="kobo.513.1">, respectively.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.514.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.515.1">buffer.Reset()</span></code><span class="koboSpan" id="kobo.516.1"> can</span><a id="_idIndexMarker1213"/><span class="koboSpan" id="kobo.517.1"> be more efficient for one or a combination of the following reasons:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.518.1">Reuse of allocated memory</span></strong><span class="koboSpan" id="kobo.519.1">: When you call </span><code class="inlineCode"><span class="koboSpan" id="kobo.520.1">buffer.Reset()</span></code><span class="koboSpan" id="kobo.521.1">, the underlying byte slice used by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.522.1">bytes.Buffer</span></code><span class="koboSpan" id="kobo.523.1"> is not deallocated. </span><span class="koboSpan" id="kobo.523.2">Instead, it is reused. </span><span class="koboSpan" id="kobo.523.3">The length of the buffer is set to zero, making the existing memory available for new data to be written.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.524.1">Reduced allocation overhead</span></strong><span class="koboSpan" id="kobo.525.1">: Creating a new buffer involves allocating a new underlying byte slice. </span><span class="koboSpan" id="kobo.525.2">This allocation comes with overhead, including managing the memory, updating the memory allocator’s data structures, and possibly invoking the garbage collector.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.526.1">Avoiding garbage collection</span></strong><span class="koboSpan" id="kobo.527.1">: Creating and discarding many small buffers can lead to increased pressure on the Garbage Collector, especially in scenarios with high-frequency buffer creation. </span><span class="koboSpan" id="kobo.527.2">By reusing the buffer with </span><code class="inlineCode"><span class="koboSpan" id="kobo.528.1">Reset()</span></code><span class="koboSpan" id="kobo.529.1">, you reduce the number of short-lived objects, potentially reducing the impact on garbage</span><a id="_idIndexMarker1214"/><span class="koboSpan" id="kobo.530.1"> collection.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.531.1">The subject of the next section is benchmarking buffered writing.</span></p>
<h1 class="heading-1" id="_idParaDest-391"><span class="koboSpan" id="kobo.532.1">Buffered versus unbuffered file I/O</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.533.1">In this</span><a id="_idIndexMarker1215"/><span class="koboSpan" id="kobo.534.1"> section, we are going to compare buffered and</span><a id="_idIndexMarker1216"/><span class="koboSpan" id="kobo.535.1"> unbuffered operations while reading and writing files.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.536.1">In this section, we are going to test whether the size of the buffer plays a key role in the performance of write operations. </span><span class="koboSpan" id="kobo.536.2">The relevant code can be found in </span><code class="inlineCode"><span class="koboSpan" id="kobo.537.1">ch14/io</span></code><span class="koboSpan" id="kobo.538.1">. </span><span class="koboSpan" id="kobo.538.2">Apart from the relevant files, the directory includes a </span><code class="inlineCode"><span class="koboSpan" id="kobo.539.1">testdata</span></code><span class="koboSpan" id="kobo.540.1"> directory, which was first seen in </span><em class="chapterRef"><span class="koboSpan" id="kobo.541.1">Chapter 13</span></em><span class="koboSpan" id="kobo.542.1">, </span><em class="italic"><span class="koboSpan" id="kobo.543.1">Fuzz Testing and Observability</span></em><span class="koboSpan" id="kobo.544.1">, and is used for storing data related to the testing process.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.545.1">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.546.1">table.go</span></code><span class="koboSpan" id="kobo.547.1"> is not presented here—feel free to look at it. </span><span class="koboSpan" id="kobo.547.2">The code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.548.1">table_test.go</span></code><span class="koboSpan" id="kobo.549.1"> is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.550.1">package</span></span><span class="koboSpan" id="kobo.551.1"> table
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.552.1">import</span></span><span class="koboSpan" id="kobo.553.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.554.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.555.1">"os"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.556.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.557.1">path"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.558.1">"strconv"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.559.1">"testing"</span></span><span class="koboSpan" id="kobo.560.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.561.1">var</span></span><span class="koboSpan" id="kobo.562.1"> ERR </span><span class="hljs-type"><span class="koboSpan" id="kobo.563.1">error</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.564.1">var</span></span><span class="koboSpan" id="kobo.565.1"> countChars </span><span class="hljs-type"><span class="koboSpan" id="kobo.566.1">int</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.567.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.568.1">benchmarkCreate</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.569.1">(b *testing.B, buffer, filesize </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.570.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.571.1">)</span></span><span class="koboSpan" id="kobo.572.1"> {
    filename := path.Join(os.TempDir(), strconv.Itoa(buffer))
    filename = filename + </span><span class="hljs-string"><span class="koboSpan" id="kobo.573.1">"-"</span></span><span class="koboSpan" id="kobo.574.1"> + strconv.Itoa(filesize)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.575.1">var</span></span><span class="koboSpan" id="kobo.576.1"> err </span><span class="hljs-type"><span class="koboSpan" id="kobo.577.1">error</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.578.1">for</span></span><span class="koboSpan" id="kobo.579.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.580.1">0</span></span><span class="koboSpan" id="kobo.581.1">; i &lt; b.N; i++ {
        err = Create(filename, buffer, filesize)
    }
    ERR = err
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.582.1">The reason for storing the return value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.583.1">Create()</span></code><span class="koboSpan" id="kobo.584.1"> in a variable named </span><code class="inlineCode"><span class="koboSpan" id="kobo.585.1">err</span></code><span class="koboSpan" id="kobo.586.1"> and using another global variable named </span><code class="inlineCode"><span class="koboSpan" id="kobo.587.1">ERR</span></code><span class="koboSpan" id="kobo.588.1"> afterward is tricky. </span><span class="koboSpan" id="kobo.588.2">We want to prevent the compiler from doing any optimizations that might exclude the function that we want to measure from being executed because its results are never used.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.589.1">    err = os.Remove(filename)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.590.1">if</span></span><span class="koboSpan" id="kobo.591.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.592.1">nil</span></span><span class="koboSpan" id="kobo.593.1"> {
        fmt.Println(err)
    }
    ERR = err
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.594.1">Neither the signature nor the name of </span><code class="inlineCode"><span class="koboSpan" id="kobo.595.1">benchmarkCreate()</span></code><span class="koboSpan" id="kobo.596.1"> makes it a benchmark function. </span><span class="koboSpan" id="kobo.596.2">This is a helper function that allows you to call </span><code class="inlineCode"><span class="koboSpan" id="kobo.597.1">Create()</span></code><span class="koboSpan" id="kobo.598.1">, which creates a new file on disk; its implementation can be found in </span><code class="inlineCode"><span class="koboSpan" id="kobo.599.1">table.go</span></code><span class="koboSpan" id="kobo.600.1">, with the proper parameters. </span><span class="koboSpan" id="kobo.600.2">Its implementation is valid, and it can be used by benchmark functions.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.601.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.602.1">BenchmarkBuffer4Create</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.603.1">(b *testing.B)</span></span><span class="koboSpan" id="kobo.604.1"> {
    benchmarkCreate(b, </span><span class="hljs-number"><span class="koboSpan" id="kobo.605.1">4</span></span><span class="koboSpan" id="kobo.606.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.607.1">1000000</span></span><span class="koboSpan" id="kobo.608.1">)
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.609.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.610.1">BenchmarkBuffer8Create</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.611.1">(b *testing.B)</span></span><span class="koboSpan" id="kobo.612.1"> {
    benchmarkCreate(b, </span><span class="hljs-number"><span class="koboSpan" id="kobo.613.1">8</span></span><span class="koboSpan" id="kobo.614.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.615.1">1000000</span></span><span class="koboSpan" id="kobo.616.1">)
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.617.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.618.1">BenchmarkBuffer16Create</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.619.1">(b *testing.B)</span></span><span class="koboSpan" id="kobo.620.1"> {
    benchmarkCreate(b, </span><span class="hljs-number"><span class="koboSpan" id="kobo.621.1">16</span></span><span class="koboSpan" id="kobo.622.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.623.1">1000000</span></span><span class="koboSpan" id="kobo.624.1">)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.625.1">These are three correctly defined benchmark functions that all call </span><code class="inlineCode"><span class="koboSpan" id="kobo.626.1">benchmarkCreate()</span></code><span class="koboSpan" id="kobo.627.1">. </span><span class="koboSpan" id="kobo.627.2">Benchmark functions require a single </span><code class="inlineCode"><span class="koboSpan" id="kobo.628.1">*testing.B</span></code><span class="koboSpan" id="kobo.629.1"> variable and return no values. </span><span class="koboSpan" id="kobo.629.2">In this case, the numbers at the end of the function name indicate the size of the buffer.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.630.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.631.1">BenchmarkRead</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.632.1">(b *testing.B)</span></span><span class="koboSpan" id="kobo.633.1"> {
    buffers := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.634.1">int</span></span><span class="koboSpan" id="kobo.635.1">{</span><span class="hljs-number"><span class="koboSpan" id="kobo.636.1">1</span></span><span class="koboSpan" id="kobo.637.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.638.1">16</span></span><span class="koboSpan" id="kobo.639.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.640.1">96</span></span><span class="koboSpan" id="kobo.641.1">}
    files := []</span><span class="hljs-type"><span class="koboSpan" id="kobo.642.1">string</span></span><span class="koboSpan" id="kobo.643.1">{</span><span class="hljs-string"><span class="koboSpan" id="kobo.644.1">"10.txt"</span></span><span class="koboSpan" id="kobo.645.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.646.1">"1000.txt"</span></span><span class="koboSpan" id="kobo.647.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.648.1">"5k.txt"</span></span><span class="koboSpan" id="kobo.649.1">}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.650.1">This is the</span><a id="_idIndexMarker1217"/><span class="koboSpan" id="kobo.651.1"> code that defines the array structures that </span><a id="_idIndexMarker1218"/><span class="koboSpan" id="kobo.652.1">are going to be used in the table tests. </span><span class="koboSpan" id="kobo.652.2">This saves us from having to implement (3x3=) 9 separate benchmark functions.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.653.1">for</span></span><span class="koboSpan" id="kobo.654.1"> _, filename := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.655.1">range</span></span><span class="koboSpan" id="kobo.656.1"> files {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.657.1">for</span></span><span class="koboSpan" id="kobo.658.1"> _, bufSize := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.659.1">range</span></span><span class="koboSpan" id="kobo.660.1"> buffers {
            name := fmt.Sprintf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.661.1">"%s-%d"</span></span><span class="koboSpan" id="kobo.662.1">, filename, bufSize)
            b.Run(name, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.663.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.664.1">(b *testing.B)</span></span><span class="koboSpan" id="kobo.665.1"> {
                </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.666.1">for</span></span><span class="koboSpan" id="kobo.667.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.668.1">0</span></span><span class="koboSpan" id="kobo.669.1">; i &lt; b.N; i++ {
                    t := CountChars(</span><span class="hljs-string"><span class="koboSpan" id="kobo.670.1">"./testdata/"</span></span><span class="koboSpan" id="kobo.671.1">+filename, bufSize)
                    countChars = t
                }
            })
        }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.672.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.673.1">b.Run()</span></code><span class="koboSpan" id="kobo.674.1"> method, which allows you to run one or more sub-benchmarks within a benchmark </span><a id="_idIndexMarker1219"/><span class="koboSpan" id="kobo.675.1">function, accepts two parameters. </span><span class="koboSpan" id="kobo.675.2">First, the </span><a id="_idIndexMarker1220"/><span class="koboSpan" id="kobo.676.1">name of the sub-benchmark, which is displayed on the screen, and second, the function that implements the sub-benchmark. </span><span class="koboSpan" id="kobo.676.2">This is an efficient way to run multiple benchmarks with the use of table tests and know their parameters. </span><span class="koboSpan" id="kobo.676.3">Just remember to define a proper name for each sub-benchmark because this is going to be displayed on the screen.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.677.1">Running the benchmarks generates the next output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.678.1">$ </span></span><span class="koboSpan" id="kobo.679.1">go </span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.680.1">test</span></span><span class="koboSpan" id="kobo.681.1"> -bench=. </span><span class="koboSpan" id="kobo.681.2">-benchmem *.go
goos: darwin
goarch: arm64
BenchmarkBuffer4Create-10     382740   2915 ns/op   384 B/op    5 allocs/op
BenchmarkBuffer8Create-10     444297   2400 ns/op   384 B/op    5 allocs/op
BenchmarkBuffer16Create-10    491230   2165 ns/op   384 B/op  5 allocs/op
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.682.1">The previous three lines are the results of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.683.1">BenchmarkBuffer4Create()</span></code><span class="koboSpan" id="kobo.684.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.685.1">BenchmarkBuffer8Create()</span></code><span class="koboSpan" id="kobo.686.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.687.1">BenchmarkBuffer16Create()</span></code><span class="koboSpan" id="kobo.688.1"> benchmark functions, respectively, and indicate their performance.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.689.1">BenchmarkRead/10.txt-1-10     146298    8180 ns/op   168 B/op   6 allocs/op
BenchmarkRead/10.txt-16-10    197534    6024 ns/op   200 B/op   6 allocs/op
BenchmarkRead/10.txt-96-10    197245    6148 ns/op   440 B/op   6 allocs/op
BenchmarkRead/1000.txt-1-10   4382        268204 ns/op  168 B/op   6 allocs/op
BenchmarkRead/1000.txt-16-10  32732    36684 ns/op   200 B/op   6 allocs/op
BenchmarkRead/1000.txt-96-10  105078   11337 ns/op   440 B/op      6 allocs/op
BenchmarkRead/5k.txt-1-10     912       1308924 ns/op  168 B/op	  6 allocs/op
BenchmarkRead/5k.txt-16-10    7413        159638 ns/op  200 B/op	  6 allocs/op
BenchmarkRead/5k.txt-96-10    36471    32841 ns/op   440 B/op      6 allocs/op
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.690.1">The previous results are from the table tests with the 9 sub-benchmarks.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.691.1">PASS
ok      command-line-arguments    24.518s
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.692.1">So, what does this output tell us? </span><span class="koboSpan" id="kobo.692.2">First, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.693.1">-10</span></code><span class="koboSpan" id="kobo.694.1"> at the end of each benchmark function signifies the number of goroutines used for its execution, which is essentially the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.695.1">GOMAXPROCS</span></code><span class="koboSpan" id="kobo.696.1"> environment variable. </span><span class="koboSpan" id="kobo.696.2">Similarly, you can see the values of </span><code class="inlineCode"><span class="koboSpan" id="kobo.697.1">GOOS</span></code><span class="koboSpan" id="kobo.698.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.699.1">GOARCH</span></code><span class="koboSpan" id="kobo.700.1">, which show the operating system and the architecture of the machine in the generated output. </span><span class="koboSpan" id="kobo.700.2">The second column in the output displays the number of times that the relevant function was executed. </span><span class="koboSpan" id="kobo.700.3">Faster functions are executed more times than slower functions. </span><span class="koboSpan" id="kobo.700.4">As an example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.701.1">BenchmarkBuffer4Create()</span></code><span class="koboSpan" id="kobo.702.1"> was executed </span><code class="inlineCode"><span class="koboSpan" id="kobo.703.1">382740</span></code><span class="koboSpan" id="kobo.704.1"> times, while </span><code class="inlineCode"><span class="koboSpan" id="kobo.705.1">BenchmarkBuffer16Create()</span></code><span class="koboSpan" id="kobo.706.1"> was executed </span><code class="inlineCode"><span class="koboSpan" id="kobo.707.1">491230</span></code><span class="koboSpan" id="kobo.708.1"> times because it is faster! </span><span class="koboSpan" id="kobo.708.2">The third column in the output shows the average time of each run and is measured in nanoseconds per benchmark function execution (</span><code class="inlineCode"><span class="koboSpan" id="kobo.709.1">ns/op</span></code><span class="koboSpan" id="kobo.710.1">). </span><span class="koboSpan" id="kobo.710.2">The higher the value of the third column, the slower the benchmark function is. </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.711.1">A large value in the third column is an indication that a function might need to be optimized</span></strong><span class="koboSpan" id="kobo.712.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.713.1">So far, we have learned how to create benchmark functions to test the performance of our own functions to better understand potential bottlenecks that might need to be optimized. </span><span class="koboSpan" id="kobo.713.2">You might ask, how often do we need to create benchmark functions? </span><span class="koboSpan" id="kobo.713.3">The answer is simple. </span><span class="koboSpan" id="kobo.713.4">When something runs slower than needed and/or when you want to choose between two or more implementations.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.714.1">The next subsection shows how to compare benchmark results.</span></p>
<h2 class="heading-2" id="_idParaDest-392"><span class="koboSpan" id="kobo.715.1">The benchstat utility</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.716.1">Now imagine that you have </span><a id="_idIndexMarker1221"/><span class="koboSpan" id="kobo.717.1">benchmarking data, and you want to compare it with the results that were produced in another computer or with a different configuration. </span><span class="koboSpan" id="kobo.717.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.718.1">benchstat</span></code><span class="koboSpan" id="kobo.719.1"> utility can help you here. </span><span class="koboSpan" id="kobo.719.2">The utility can be found in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.720.1">https://pkg.go.dev/golang.org/x/perf/cmd/benchstat</span></code><span class="koboSpan" id="kobo.721.1"> package and can be downloaded using </span><code class="inlineCode"><span class="koboSpan" id="kobo.722.1">go install golang.org/x/perf/cmd/benchstat@latest</span></code><span class="koboSpan" id="kobo.723.1">. </span><span class="koboSpan" id="kobo.723.2">Go puts all binary files in </span><code class="inlineCode"><span class="koboSpan" id="kobo.724.1">~/go/bin</span></code><span class="koboSpan" id="kobo.725.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.726.1">benchstat</span></code><span class="koboSpan" id="kobo.727.1"> is no exception to that rule.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.728.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.729.1">benchstat</span></code><span class="koboSpan" id="kobo.730.1"> utility replaces the </span><code class="inlineCode"><span class="koboSpan" id="kobo.731.1">benchcmp</span></code><span class="koboSpan" id="kobo.732.1"> utility, which can </span><a id="_idIndexMarker1222"/><span class="koboSpan" id="kobo.733.1">be found at </span><a href="https://pkg.go.dev/golang.org/x/tools/cmd/benchcmp"><span class="url"><span class="koboSpan" id="kobo.734.1">https://pkg.go.dev/golang.org/x/tools/cmd/benchcmp</span></span></a><span class="koboSpan" id="kobo.735.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.736.1">So, imagine that we </span><a id="_idIndexMarker1223"/><span class="koboSpan" id="kobo.737.1">have two benchmark results for </span><code class="inlineCode"><span class="koboSpan" id="kobo.738.1">table_test.go</span></code><span class="koboSpan" id="kobo.739.1"> saved in </span><code class="inlineCode"><span class="koboSpan" id="kobo.740.1">r1.txt</span></code><span class="koboSpan" id="kobo.741.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.742.1">r2.txt</span></code><span class="koboSpan" id="kobo.743.1">—you should remove all lines from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.744.1">go test</span></code><span class="koboSpan" id="kobo.745.1"> output that do not contain benchmarking results, which leaves all lines that begin with </span><code class="inlineCode"><span class="koboSpan" id="kobo.746.1">Benchmark</span></code><span class="koboSpan" id="kobo.747.1">. </span><span class="koboSpan" id="kobo.747.2">You can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.748.1">benchstat</span></code><span class="koboSpan" id="kobo.749.1"> as follows:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.750.1">$ </span></span><span class="koboSpan" id="kobo.751.1">~/go/bin/benchstat r1.txt r2.txt
                   │     r1.txt     │                 r2.txt            │
                   │     sec/op     │    sec/op     vs base             │
Buffer4Create-8      10472.0n ± ∞ ¹   830.8n ± ∞ ¹     ~ (p=0.667 n=1+2) ²
Buffer8Create-8       6884.0n ± ∞ ¹   798.9n ± ∞ ¹     ~ (p=0.667 n=1+2) ²
Buffer16Create-8      5010.0n ± ∞ ¹   770.5n ± ∞ ¹     ~ (p=0.667 n=1+2) ²
Read/10.txt-1-8       14.955µ ± ∞ ¹   3.987µ ± ∞ ¹     ~ (p=0.667 n=1+2) ²
Read/10.txt-16-8      12.172µ ± ∞ ¹   2.583µ ± ∞ ¹     ~ (p=0.667 n=1+2) ²
Read/10.txt-96-8      11.925µ ± ∞ ¹   2.612µ ± ∞ ¹     ~ (p=0.667 n=1+2) ²
Read/1000.txt-1-8      381.3µ ± ∞ ¹   175.8µ ± ∞ ¹     ~ (p=0.667 n=1+2) ²
Read/1000.txt-16-8     54.05µ ± ∞ ¹   22.68µ ± ∞ ¹     ~ (p=0.667 n=1+2) ²
Read/1000.txt-96-8    19.115µ ± ∞ ¹   6.225µ ± ∞ ¹     ~ (p=1.333 n=1+2) ²
Read/5k.txt-1-8       1812.5µ ± ∞ ¹   895.7µ ± ∞ ¹     ~ (p=0.667 n=1+2) ²
Read/5k.txt-16-8       221.8µ ± ∞ ¹   107.7µ ± ∞ ¹     ~ (p=0.667 n=1+2) ²
Read/5k.txt-96-8       51.53µ ± ∞ ¹   21.52µ ± ∞ ¹     ~ (p=0.667 n=1+2) ²
geomean                36.91µ         9.717µ        -73.68%
¹ need &gt;= 6 samples for confidence interval at level 0.95
² need &gt;= 4 samples to detect a difference at alpha level 0.05
</span></code></pre>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.752.1">You can save the results from benchmarks by simply redirecting the generated output into a file. </span><span class="koboSpan" id="kobo.752.2">For example, you can run </span><code class="inlineCode"><span class="koboSpan" id="kobo.753.1">go test -bench=. </span><span class="koboSpan" id="kobo.753.2">&gt; output.txt</span></code><span class="koboSpan" id="kobo.754.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.755.1">If the value of the last column is </span><code class="inlineCode"><span class="koboSpan" id="kobo.756.1">~</span></code><span class="koboSpan" id="kobo.757.1">, as it happens to be here, it means that there was no significant change in the results. </span><span class="koboSpan" id="kobo.757.2">The previous output shows no differences between the two results. </span><span class="koboSpan" id="kobo.757.3">Discussing more </span><a id="_idIndexMarker1224"/><span class="koboSpan" id="kobo.758.1">about </span><code class="inlineCode"><span class="koboSpan" id="kobo.759.1">benchstat</span></code><span class="koboSpan" id="kobo.760.1"> is beyond the scope of the book. </span><span class="koboSpan" id="kobo.760.2">Type </span><code class="inlineCode"><span class="koboSpan" id="kobo.761.1">benchstat -h</span></code><span class="koboSpan" id="kobo.762.1"> to learn more about the supported parameters.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.763.1">The next section touches on a sensitive subject, which is incorrectly defined benchmark functions.</span></p>
<h1 class="heading-1" id="_idParaDest-393"><span class="koboSpan" id="kobo.764.1">Wrongly defined benchmark functions</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.765.1">You should be very careful when</span><a id="_idIndexMarker1225"/><span class="koboSpan" id="kobo.766.1"> defining benchmark functions because you might define them incorrectly. </span><span class="koboSpan" id="kobo.766.2">Look at the Go code of the following benchmark function:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.767.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.768.1">BenchmarkFiboI</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.769.1">(b *testing.B)</span></span><span class="koboSpan" id="kobo.770.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.771.1">for</span></span><span class="koboSpan" id="kobo.772.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.773.1">0</span></span><span class="koboSpan" id="kobo.774.1">; i &lt; b.N; i++ {
        _ = fibo1(i)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.775.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.776.1">BenchmarkFibo()</span></code><span class="koboSpan" id="kobo.777.1"> function has a valid name and the correct signature. </span><span class="koboSpan" id="kobo.777.2">The bad news is that this benchmark function is logically wrong and is not going to produce any results. </span><span class="koboSpan" id="kobo.777.3">The reason for this is that as the </span><code class="inlineCode"><span class="koboSpan" id="kobo.778.1">b.N</span></code><span class="koboSpan" id="kobo.779.1"> value grows in the way described earlier, the runtime of the benchmark function also increases because of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.780.1">for</span></code><span class="koboSpan" id="kobo.781.1"> loop. </span><span class="koboSpan" id="kobo.781.2">This fact prevents </span><code class="inlineCode"><span class="koboSpan" id="kobo.782.1">BenchmarkFiboI()</span></code><span class="koboSpan" id="kobo.783.1"> from converging to a stable number, which prevents the function from completing and, therefore, returning any results. </span><span class="koboSpan" id="kobo.783.2">For analogous reasons, the next benchmark function is also wrongly implemented:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.784.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.785.1">BenchmarkfiboII</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.786.1">(b *testing.B)</span></span><span class="koboSpan" id="kobo.787.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.788.1">for</span></span><span class="koboSpan" id="kobo.789.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.790.1">0</span></span><span class="koboSpan" id="kobo.791.1">; i &lt; b.N; i++ {
        _ = fibo1(b.N)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.792.1">On the other hand, there is nothing wrong with the implementation of the following two benchmark functions:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.793.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.794.1">BenchmarkFiboIV</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.795.1">(b *testing.B)</span></span><span class="koboSpan" id="kobo.796.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.797.1">for</span></span><span class="koboSpan" id="kobo.798.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.799.1">0</span></span><span class="koboSpan" id="kobo.800.1">; i &lt; b.N; i++ {
        _ = fibo1(</span><span class="hljs-number"><span class="koboSpan" id="kobo.801.1">10</span></span><span class="koboSpan" id="kobo.802.1">)
    }
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.803.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.804.1">BenchmarkFiboIII</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.805.1">(b *testing.B)</span></span><span class="koboSpan" id="kobo.806.1"> {
    _ = fibo1(b.N)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.807.1">Correct </span><a id="_idIndexMarker1226"/><span class="koboSpan" id="kobo.808.1">benchmark functions are a tool for identifying bottlenecks in your code that you should put in your own projects, especially when working with file I/O or CPU-intensive operations—as I am writing this, I have been waiting three days for a Python program to finish its operation to test the performance of the brute-force method of a mathematical algorithm.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.809.1">Enough with benchmarking. </span><span class="koboSpan" id="kobo.809.2">The next section discusses the Go way of working with memory.</span></p>
<h1 class="heading-1" id="_idParaDest-394"><span class="koboSpan" id="kobo.810.1">Go memory management</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.811.1">The subject of this section is Go</span><a id="_idIndexMarker1227"/><span class="koboSpan" id="kobo.812.1"> memory management. </span><span class="koboSpan" id="kobo.812.2">We are going to begin by stating a fact that you should already be familiar with: Go sacrifices visibility and total control over memory management for the sake of simplicity and the use of</span><a id="_idIndexMarker1228"/><span class="koboSpan" id="kobo.813.1"> the </span><strong class="keyWord"><span class="koboSpan" id="kobo.814.1">Garbage Collector</span></strong><span class="koboSpan" id="kobo.815.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.816.1">GC</span></strong><span class="koboSpan" id="kobo.817.1">). </span><span class="koboSpan" id="kobo.817.2">Although the GC operation introduces an overhead to the speed of a program, it saves us from having to manually deal with memory, which is a huge advantage and saves us from lots of bugs.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.818.1">There exist two types of </span><a id="_idIndexMarker1229"/><span class="koboSpan" id="kobo.819.1">allocations that take place during program execution: </span><em class="italic"><span class="koboSpan" id="kobo.820.1">dynamic allocations</span></em><span class="koboSpan" id="kobo.821.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.822.1">automatic allocations</span></em><span class="koboSpan" id="kobo.823.1">. </span><span class="koboSpan" id="kobo.823.2">Automatic allocations are the allocations whose lifespan</span><a id="_idIndexMarker1230"/><span class="koboSpan" id="kobo.824.1"> can be inferred by the compiler before the program starts its execution. </span><span class="koboSpan" id="kobo.824.2">For example, all local variables, the return arguments of functions, and function arguments have a given lifespan, which means that they can be automatically allocated by the compiler. </span><span class="koboSpan" id="kobo.824.3">All other allocations are performed dynamically, which also includes data that must be available outside the scope of a function.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.825.1">We continue our discussion on Go memory management by talking about the heap and the stack because this is where most of the allocations take place.</span></p>
<h2 class="heading-2" id="_idParaDest-395"><span class="koboSpan" id="kobo.826.1">Heap and stack</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.827.1">The </span><em class="italic"><span class="koboSpan" id="kobo.828.1">heap</span></em><span class="koboSpan" id="kobo.829.1"> is the</span><a id="_idIndexMarker1231"/><span class="koboSpan" id="kobo.830.1"> place where programming languages store global variables—the heap is where garbage collection takes place. </span><span class="koboSpan" id="kobo.830.2">The </span><em class="italic"><span class="koboSpan" id="kobo.831.1">stack</span></em><span class="koboSpan" id="kobo.832.1"> is </span><a id="_idIndexMarker1232"/><span class="koboSpan" id="kobo.833.1">the place where programming languages store temporary variables used by functions—each function has its own stack. </span><span class="koboSpan" id="kobo.833.2">As goroutines are located in user space, the Go runtime is responsible for the rules that govern their operation. </span><span class="koboSpan" id="kobo.833.3">Additionally, </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.834.1">each goroutine has its own stack,</span></strong><span class="koboSpan" id="kobo.835.1"> whereas the heap is “shared” among goroutines.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.836.1">Dynamic allocations take place in the heap, whereas automatic allocations are stored in the stack. </span><span class="koboSpan" id="kobo.836.2">The Go compiler performs a process that is called </span><em class="italic"><span class="koboSpan" id="kobo.837.1">escape analysis</span></em><span class="koboSpan" id="kobo.838.1"> to find out whether a memory needs to be allocated at the heap or should stay within the stack.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.839.1">In C++, when you create new variables using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.840.1">new</span></code><span class="koboSpan" id="kobo.841.1"> operator, you know that these variables are going to the heap. </span><span class="koboSpan" id="kobo.841.2">This is not the case with Go and the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.842.1">new()</span></code><span class="koboSpan" id="kobo.843.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.844.1">make()</span></code><span class="koboSpan" id="kobo.845.1"> functions. </span><span class="koboSpan" id="kobo.845.2">In Go, the compiler decides where a new variable is going to be placed based on its size and the result of escape analysis. </span><span class="koboSpan" id="kobo.845.3">This is the reason that we can return pointers to local variables from Go functions. </span><span class="koboSpan" id="kobo.845.4">Although we have not seen </span><code class="inlineCode"><span class="koboSpan" id="kobo.846.1">new()</span></code><span class="koboSpan" id="kobo.847.1"> in this book frequently, keep in mind that </span><code class="inlineCode"><span class="koboSpan" id="kobo.848.1">new()</span></code><span class="koboSpan" id="kobo.849.1"> returns pointers to initialized memory.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.850.1">If you want to know where the variables of a program are allocated by Go, you can use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.851.1">-m</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.852.1">gc</span></code><span class="koboSpan" id="kobo.853.1"> flag with </span><code class="inlineCode"><span class="koboSpan" id="kobo.854.1">go run</span></code><span class="koboSpan" id="kobo.855.1">. </span><span class="koboSpan" id="kobo.855.2">This is illustrated in </span><code class="inlineCode"><span class="koboSpan" id="kobo.856.1">allocate.go</span></code><span class="koboSpan" id="kobo.857.1">—this is a regular program that needs no modifications in order to display the extra output as all details are handled by Go.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.858.1">package</span></span><span class="koboSpan" id="kobo.859.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.860.1">import</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.861.1">"fmt"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.862.1">const</span></span><span class="koboSpan" id="kobo.863.1"> VAT = </span><span class="hljs-number"><span class="koboSpan" id="kobo.864.1">24</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.865.1">type</span></span><span class="koboSpan" id="kobo.866.1"> Item </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.867.1">struct</span></span><span class="koboSpan" id="kobo.868.1"> {
    Description </span><span class="hljs-type"><span class="koboSpan" id="kobo.869.1">string</span></span><span class="koboSpan" id="kobo.870.1">
    Value       </span><span class="hljs-type"><span class="koboSpan" id="kobo.871.1">float64</span></span><span class="koboSpan" id="kobo.872.1">
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.873.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.874.1">Value</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.875.1">(price </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.876.1">float64</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.877.1">)</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.878.1">float64</span></span><span class="koboSpan" id="kobo.879.1"> {
    total := price + price*VAT/</span><span class="hljs-number"><span class="koboSpan" id="kobo.880.1">100</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.881.1">return</span></span><span class="koboSpan" id="kobo.882.1"> total
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.883.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.884.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.885.1">()</span></span><span class="koboSpan" id="kobo.886.1"> {
    t := Item{Description: </span><span class="hljs-string"><span class="koboSpan" id="kobo.887.1">"Keyboard"</span></span><span class="koboSpan" id="kobo.888.1">, Value: </span><span class="hljs-number"><span class="koboSpan" id="kobo.889.1">100</span></span><span class="koboSpan" id="kobo.890.1">}
    t.Value = Value(t.Value)
    fmt.Println(t)
    tP := &amp;Item{}
    *&amp;tP.Description = </span><span class="hljs-string"><span class="koboSpan" id="kobo.891.1">"Mouse"</span></span><span class="koboSpan" id="kobo.892.1">
    *&amp;tP.Value = </span><span class="hljs-number"><span class="koboSpan" id="kobo.893.1">100</span></span><span class="koboSpan" id="kobo.894.1">
    fmt.Println(tP)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.895.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.896.1">allocate.go</span></code><span class="koboSpan" id="kobo.897.1"> generates the next output—the output is a result of the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.898.1">-gcflags '-m'</span></code><span class="koboSpan" id="kobo.899.1">, which modifies</span><a id="_idIndexMarker1233"/><span class="koboSpan" id="kobo.900.1"> the generated executable. </span><span class="koboSpan" id="kobo.900.2">You should not create executable binaries that go to production with the</span><a id="_idIndexMarker1234"/><span class="koboSpan" id="kobo.901.1"> use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.902.1">-gcflags</span></code><span class="koboSpan" id="kobo.903.1"> flags.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.904.1">$ </span></span><span class="koboSpan" id="kobo.905.1">go run -gcflags </span><span class="hljs-con-string"><span class="koboSpan" id="kobo.906.1">'-m'</span></span><span class="koboSpan" id="kobo.907.1"> allocate.go
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.908.1"># </span></span><span class="koboSpan" id="kobo.909.1">command-line-arguments
./allocate.go:12:6: can inline Value
./allocate.go:19:17: inlining call to Value
./allocate.go:20:13: inlining call to fmt.Println
./allocate.go:25:13: inlining call to fmt.Println
./allocate.go:20:13: ... </span><span class="koboSpan" id="kobo.909.2">argument does not escape
./allocate.go:20:14: t escapes to heap
./allocate.go:22:8: &amp;Item{} escapes to heap
./allocate.go:25:13: ... </span><span class="koboSpan" id="kobo.909.3">argument does not escape
{Keyboard 124}
&amp;{Mouse 100}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.910.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.911.1">t escapes to heap</span></code><span class="koboSpan" id="kobo.912.1"> message means that </span><code class="inlineCode"><span class="koboSpan" id="kobo.913.1">t</span></code><span class="koboSpan" id="kobo.914.1"> escapes the function. </span><span class="koboSpan" id="kobo.914.2">Put simply, it means that </span><code class="inlineCode"><span class="koboSpan" id="kobo.915.1">t</span></code><span class="koboSpan" id="kobo.916.1"> is used outside of the function and does not have a local scope (because it is passed outside the function). </span><span class="koboSpan" id="kobo.916.2">However, this does not necessarily mean that the variable has moved to the heap. </span><span class="koboSpan" id="kobo.916.3">On other occasions, you can see the message </span><code class="inlineCode"><span class="koboSpan" id="kobo.917.1">moved to heap</span></code><span class="koboSpan" id="kobo.918.1">. </span><span class="koboSpan" id="kobo.918.2">This message shows that the compiler decided to move a variable to the heap because it might be used outside of the function. </span><span class="koboSpan" id="kobo.918.3">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.919.1">does not escape</span></code><span class="koboSpan" id="kobo.920.1"> message indicates that the relevant argument does not escape to the heap. </span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.921.1">Ideally, we should write our algorithms in order to use the stack instead of the heap, but this is impossible as stacks cannot allocate too-large objects and cannot store variables that live longer than a function. </span><span class="koboSpan" id="kobo.921.2">So, it is up to the Go compiler to decide.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.922.1">The last two lines of the output consist of</span><a id="_idIndexMarker1235"/><span class="koboSpan" id="kobo.923.1"> the output generated by the two </span><code class="inlineCode"><span class="koboSpan" id="kobo.924.1">fmt.Println()</span></code><span class="koboSpan" id="kobo.925.1"> statements.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.926.1">If you want to get a more detailed output, you </span><a id="_idIndexMarker1236"/><span class="koboSpan" id="kobo.927.1">can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.928.1">-m</span></code><span class="koboSpan" id="kobo.929.1"> twice:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.930.1">$ </span></span><span class="koboSpan" id="kobo.931.1">go run -gcflags </span><span class="hljs-con-string"><span class="koboSpan" id="kobo.932.1">'-m -m'</span></span><span class="koboSpan" id="kobo.933.1"> allocate.go
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.934.1"># </span></span><span class="koboSpan" id="kobo.935.1">command-line-arguments
./allocate.go:12:6: can inline Value with cost 13 as: func(float64) float64 { total := price + price * VAT / 100; return total }
./allocate.go:17:6: cannot inline main: function too complex: cost 199 exceeds budget 80
./allocate.go:19:17: inlining call to Value
./allocate.go:20:13: inlining call to fmt.Println
./allocate.go:25:13: inlining call to fmt.Println
./allocate.go:22:8: &amp;Item{} escapes to heap:
./allocate.go:22:8:   flow: tP = &amp;{storage for &amp;Item{}}:
./allocate.go:22:8:     from &amp;Item{} (spill) at ./allocate.go:22:8
./allocate.go:22:8:     from tP := &amp;Item{} (assign) at ./allocate.go:22:5
./allocate.go:22:8:   flow: {storage for ... </span><span class="koboSpan" id="kobo.935.2">argument} = tP:
./allocate.go:22:8:     from tP (interface-converted) at ./allocate.go:25:14
./allocate.go:22:8:     from ... </span><span class="koboSpan" id="kobo.935.3">argument (slice-literal-element) at ./allocate.go:25:13
./allocate.go:22:8:   flow: fmt.a = &amp;{storage for ... </span><span class="koboSpan" id="kobo.935.4">argument}:
./allocate.go:22:8:     from ... </span><span class="koboSpan" id="kobo.935.5">argument (spill) at ./allocate.go:25:13
./allocate.go:22:8:     from fmt.a := ... </span><span class="koboSpan" id="kobo.935.6">argument (assign-pair) at ./allocate.go:25:13
./allocate.go:22:8:   flow: {heap} = *fmt.a:
./allocate.go:22:8:     from fmt.Fprintln(os.Stdout, fmt.a...) (call parameter) at ./allocate.go:25:13
./allocate.go:20:14: t escapes to heap:
./allocate.go:20:14:   flow: {storage for ... </span><span class="koboSpan" id="kobo.935.7">argument} = &amp;{storage for t}:
./allocate.go:20:14:     from t (spill) at ./allocate.go:20:14
./allocate.go:20:14:     from ... </span><span class="koboSpan" id="kobo.935.8">argument (slice-literal-element) at ./allocate.go:20:13
./allocate.go:20:14:   flow: fmt.a = &amp;{storage for ... </span><span class="koboSpan" id="kobo.935.9">argument}:
./allocate.go:20:14:     from ... </span><span class="koboSpan" id="kobo.935.10">argument (spill) at ./allocate.go:20:13
./allocate.go:20:14:     from fmt.a := ... </span><span class="koboSpan" id="kobo.935.11">argument (assign-pair) at ./allocate.go:20:13
./allocate.go:20:14:   flow: {heap} = *fmt.a:
./allocate.go:20:14:     from fmt.Fprintln(os.Stdout, fmt.a...) (call parameter) at ./allocate.go:20:13
./allocate.go:20:13: ... </span><span class="koboSpan" id="kobo.935.12">argument does not escape
./allocate.go:20:14: t escapes to heap
./allocate.go:22:8: &amp;Item{} escapes to heap
./allocate.go:25:13: ... </span><span class="koboSpan" id="kobo.935.13">argument does not escape
{Keyboard 124}
&amp;{Mouse 100}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.936.1">Although more detailed, I find this output too crowded. </span><span class="koboSpan" id="kobo.936.2">Usually, using </span><code class="inlineCode"><span class="koboSpan" id="kobo.937.1">-m</span></code><span class="koboSpan" id="kobo.938.1"> just once reveals what is happening behind the scenes regarding the program heap and stack.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.939.1">What you should remember is that the heap is where the largest amounts of memory are usually stored. </span><span class="koboSpan" id="kobo.939.2">In practice, this means that </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.940.1">measuring the heap size is usually enough for understanding and counting the memory usage of a Go process</span></strong><span class="koboSpan" id="kobo.941.1">. </span><span class="koboSpan" id="kobo.941.2">As a result, the Go GC spends most of its time working with the heap, which means the heap is the first element to be analyzed when we want to optimize the memory usage of a program.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.942.1">The next subsection discusses the main elements of the Go memory model.</span></p>
<h2 class="heading-2" id="_idParaDest-396"><span class="koboSpan" id="kobo.943.1">The main elements of the Go memory model</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.944.1">In this section, we are going to discuss the main elements of the Go memory model in order to have a better understanding of what is happening behind the scenes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.945.1">The Go memory model</span><a id="_idIndexMarker1237"/><span class="koboSpan" id="kobo.946.1"> works with the following main elements:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.947.1">Program code</span></strong><span class="koboSpan" id="kobo.948.1">: Program code</span><a id="_idIndexMarker1238"/><span class="koboSpan" id="kobo.949.1"> is memory mapped by the OS when the</span><a id="_idIndexMarker1239"/><span class="koboSpan" id="kobo.950.1"> process is about to run, so Go has no control over that part. </span><span class="koboSpan" id="kobo.950.2">This kind of data is read-only. </span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.951.1">Global data</span></strong><span class="koboSpan" id="kobo.952.1">: Global data</span><a id="_idIndexMarker1240"/><span class="koboSpan" id="kobo.953.1"> is also memory mapped by the OS in read-only </span><a id="_idIndexMarker1241"/><span class="koboSpan" id="kobo.954.1">status.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.955.1">Uninitialized data</span></strong><span class="koboSpan" id="kobo.956.1">: Uninitialized data </span><a id="_idIndexMarker1242"/><span class="koboSpan" id="kobo.957.1">is stored in anonymous pages</span><a id="_idIndexMarker1243"/><span class="koboSpan" id="kobo.958.1"> by the OS. </span><span class="koboSpan" id="kobo.958.2">By uninitialized data, we mean data such as the global variables of a package. </span><span class="koboSpan" id="kobo.958.3">Although we might not know their values before the program starts, we know that we are going to need to allocate memory for them when the program starts its execution. </span><span class="koboSpan" id="kobo.958.4">This kind of memory space is allocated once and is</span><a id="_idIndexMarker1244"/><span class="koboSpan" id="kobo.959.1"> never </span><a id="_idIndexMarker1245"/><span class="koboSpan" id="kobo.960.1">freed. </span><span class="koboSpan" id="kobo.960.2">So, the GC has no control over it.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.961.1">Heap</span></strong><span class="koboSpan" id="kobo.962.1">: As</span><a id="_idIndexMarker1246"/><span class="koboSpan" id="kobo.963.1"> discussed earlier in this chapter, this is the heap</span><a id="_idIndexMarker1247"/><span class="koboSpan" id="kobo.964.1"> used for dynamic allocations.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.965.1">Stacks</span></strong><span class="koboSpan" id="kobo.966.1">: These are the stacks</span><a id="_idIndexMarker1248"/><span class="koboSpan" id="kobo.967.1"> used for </span><a id="_idIndexMarker1249"/><span class="koboSpan" id="kobo.968.1">automatic allocations.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.969.1">You do not need to know all the gory details of all these components of the Go memory model. </span><span class="koboSpan" id="kobo.969.2">What you need to remember is that problems arise when we either purposely or unintentionally put objects into the heap without letting the GC release them and, therefore, free their respective memory space. </span><span class="koboSpan" id="kobo.969.3">We are going to see cases related to memory leaks that have to do with slices and maps in a while.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.970.1">There also exists an internal Go component that performs memory allocations called the </span><em class="italic"><span class="koboSpan" id="kobo.971.1">Go allocator</span></em><span class="koboSpan" id="kobo.972.1">. </span><span class="koboSpan" id="kobo.972.2">It can dynamically allocate memory blocks in order for Go objects to work properly and it is optimized to prevent memory fragmentation and locking. </span><span class="koboSpan" id="kobo.972.3">The Go allocator is implemented and maintained by the Go team and, as such, its operation details can change.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.973.1">The next section discusses memory leaks, which have to do with not properly freeing memory space.</span></p>
<h1 class="heading-1" id="_idParaDest-397"><span class="koboSpan" id="kobo.974.1">Memory leaks</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.975.1">In the subsections that follow, we </span><a id="_idIndexMarker1250"/><span class="koboSpan" id="kobo.976.1">are going to talk about </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.977.1">memory leaks in slices and maps</span></strong><span class="koboSpan" id="kobo.978.1">. </span><span class="koboSpan" id="kobo.978.2">A </span><em class="italic"><span class="koboSpan" id="kobo.979.1">memory leak</span></em><span class="koboSpan" id="kobo.980.1"> happens when a memory space is allocated without being completely freed afterward.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.981.1">We are going to begin with memory leaks caused by wrongly used slices.</span></p>
<h2 class="heading-2" id="_idParaDest-398"><span class="koboSpan" id="kobo.982.1">Slices and memory leaks</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.983.1">In this subsection, we are </span><a id="_idIndexMarker1251"/><span class="koboSpan" id="kobo.984.1">going to showcase code that uses slices and produces </span><a id="_idIndexMarker1252"/><span class="koboSpan" id="kobo.985.1">memory leaks and then illustrate a way to avoid such memory leaks. </span><span class="koboSpan" id="kobo.985.2">One common scenario for memory leaks with slices involves holding a reference to a larger underlying array even after the slice is no longer needed. </span><span class="koboSpan" id="kobo.985.3">This</span><a id="_idIndexMarker1253"/><span class="koboSpan" id="kobo.986.1"> prevents the GC from reclaiming the memory</span><a id="_idIndexMarker1254"/><span class="koboSpan" id="kobo.987.1"> associated with the array.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.988.1">The code in </span><code class="inlineCode"><span class="koboSpan" id="kobo.989.1">slicesLeaks.go</span></code><span class="koboSpan" id="kobo.990.1"> is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.991.1">package</span></span><span class="koboSpan" id="kobo.992.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.993.1">import</span></span><span class="koboSpan" id="kobo.994.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.995.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.996.1">"time"</span></span><span class="koboSpan" id="kobo.997.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.998.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.999.1">createSlice</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1000.1">()</span></span><span class="koboSpan" id="kobo.1001.1"> []</span><span class="hljs-type"><span class="koboSpan" id="kobo.1002.1">int</span></span><span class="koboSpan" id="kobo.1003.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1004.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1005.1">make</span></span><span class="koboSpan" id="kobo.1006.1">([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.1007.1">int</span></span><span class="koboSpan" id="kobo.1008.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1009.1">1000000</span></span><span class="koboSpan" id="kobo.1010.1">)
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1011.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1012.1">getValue</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1013.1">(s []</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1014.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1015.1">)</span></span><span class="koboSpan" id="kobo.1016.1"> []</span><span class="hljs-type"><span class="koboSpan" id="kobo.1017.1">int</span></span><span class="koboSpan" id="kobo.1018.1"> {
    val := s[:</span><span class="hljs-number"><span class="koboSpan" id="kobo.1019.1">3</span></span><span class="koboSpan" id="kobo.1020.1">]
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1021.1">return</span></span><span class="koboSpan" id="kobo.1022.1"> val
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1023.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1024.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1025.1">()</span></span><span class="koboSpan" id="kobo.1026.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1027.1">for</span></span><span class="koboSpan" id="kobo.1028.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.1029.1">0</span></span><span class="koboSpan" id="kobo.1030.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.1031.1">15</span></span><span class="koboSpan" id="kobo.1032.1">; i++ {
        message := createSlice()
        val := getValue(message)
        fmt.Print(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1033.1">len</span></span><span class="koboSpan" id="kobo.1034.1">(val), </span><span class="hljs-string"><span class="koboSpan" id="kobo.1035.1">" "</span></span><span class="koboSpan" id="kobo.1036.1">)
        time.Sleep(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1037.1">10</span></span><span class="koboSpan" id="kobo.1038.1"> * time.Millisecond)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1039.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1040.1">createSlice()</span></code><span class="koboSpan" id="kobo.1041.1"> function creates a slice with a large underlying array, which means that it requires lots of memory. </span><span class="koboSpan" id="kobo.1041.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1042.1">getValue()</span></code><span class="koboSpan" id="kobo.1043.1"> function takes the first five elements of its input slice and returns those elements as a slice. </span><span class="koboSpan" id="kobo.1043.2">However, it does that while referencing the original input slice, which means that that input slice cannot be freed by the GC. </span><span class="koboSpan" id="kobo.1043.3">Yes, this is a problem!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1044.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1045.1">slicesLeaks.go</span></code><span class="koboSpan" id="kobo.1046.1"> with some extra command line arguments produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1047.1">$ </span></span><span class="koboSpan" id="kobo.1048.1">go run -gcflags </span><span class="hljs-con-string"><span class="koboSpan" id="kobo.1049.1">'-m -l'</span></span><span class="koboSpan" id="kobo.1050.1"> slicesLeaks.go
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1051.1"># </span></span><span class="koboSpan" id="kobo.1052.1">command-line-arguments
./slicesLeaks.go:9:13: make([]int, 1000000) escapes to heap
./slicesLeaks.go:12:15: leaking param: s to result ~r0 level=0
./slicesLeaks.go:21:12: ... </span><span class="koboSpan" id="kobo.1052.2">argument does not escape
./slicesLeaks.go:21:16: len(val) escapes to heap
./slicesLeaks.go:21:23: " " escapes to heap
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1053.1">The output indicates that there is a leaking parameter. </span><span class="koboSpan" id="kobo.1053.2">A </span><em class="italic"><span class="koboSpan" id="kobo.1054.1">leaking parameter</span></em><span class="koboSpan" id="kobo.1055.1"> means that this function somehow keeps its parameter alive after it returns—this is where the memory leak takes place. </span><span class="koboSpan" id="kobo.1055.2">However, this does not mean it is being moved to the stack, as most </span><em class="italic"><span class="koboSpan" id="kobo.1056.1">leaking parameters</span></em><span class="koboSpan" id="kobo.1057.1"> are allocated on the heap.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1058.1">An</span><a id="_idIndexMarker1255"/><span class="koboSpan" id="kobo.1059.1"> improved version of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1060.1">slicesLeaks.go</span></code><span class="koboSpan" id="kobo.1061.1"> can be found in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1062.1">slicesNoLeaks.go</span></code><span class="koboSpan" id="kobo.1063.1">. </span><span class="koboSpan" id="kobo.1063.2">The</span><a id="_idIndexMarker1256"/><span class="koboSpan" id="kobo.1064.1"> only difference is in the implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1065.1">getValue()</span></code><span class="koboSpan" id="kobo.1066.1"> function:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1067.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1068.1">getValue</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1069.1">(s []</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1070.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1071.1">)</span></span><span class="koboSpan" id="kobo.1072.1"> []</span><span class="hljs-type"><span class="koboSpan" id="kobo.1073.1">int</span></span><span class="koboSpan" id="kobo.1074.1"> {
    returnVal := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1075.1">make</span></span><span class="koboSpan" id="kobo.1076.1">([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.1077.1">int</span></span><span class="koboSpan" id="kobo.1078.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1079.1">3</span></span><span class="koboSpan" id="kobo.1080.1">)
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1081.1">copy</span></span><span class="koboSpan" id="kobo.1082.1">(returnVal, s)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1083.1">return</span></span><span class="koboSpan" id="kobo.1084.1"> returnVal
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1085.1">This time we create a copy of the slice part that we want to return, which means that the function no longer references the initial slice. </span><span class="koboSpan" id="kobo.1085.2">As a result, the GC is going to be allowed to free its memory.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1086.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1087.1">slicesNoLeaks.go</span></code><span class="koboSpan" id="kobo.1088.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1089.1">$ </span></span><span class="koboSpan" id="kobo.1090.1">go run -gcflags </span><span class="hljs-con-string"><span class="koboSpan" id="kobo.1091.1">'-m -l'</span></span><span class="koboSpan" id="kobo.1092.1"> slicesNoLeaks.go
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1093.1"># </span></span><span class="koboSpan" id="kobo.1094.1">command-line-arguments
./slicesNoLeaks.go:9:13: make([]int, 1000000) escapes to heap
./slicesNoLeaks.go:12:15: s does not escape
./slicesNoLeaks.go:13:19: make([]int, 3) escapes to heap
./slicesNoLeaks.go:22:12: ... </span><span class="koboSpan" id="kobo.1094.2">argument does not escape
./slicesNoLeaks.go:22:16: len(val) escapes to heap
./slicesNoLeaks.go:22:23: " " escapes to heap
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1095.1">So, we get no</span><a id="_idIndexMarker1257"/><span class="koboSpan" id="kobo.1096.1"> message about leaking parameters, which means that the issue</span><a id="_idIndexMarker1258"/><span class="koboSpan" id="kobo.1097.1"> has been resolved.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1098.1">Next, we are going to discuss memory leaks and maps.</span></p>
<h2 class="heading-2" id="_idParaDest-399"><span class="koboSpan" id="kobo.1099.1">Maps and memory leaks</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1100.1">This subsection is</span><a id="_idIndexMarker1259"/><span class="koboSpan" id="kobo.1101.1"> about memory leaks introduced by maps as illustrated in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1102.1">mapsLeaks.go</span></code><span class="koboSpan" id="kobo.1103.1">. </span><span class="koboSpan" id="kobo.1103.2">The </span><a id="_idIndexMarker1260"/><span class="koboSpan" id="kobo.1104.1">code in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1105.1">mapsLeaks.go</span></code><span class="koboSpan" id="kobo.1106.1"> is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1107.1">package</span></span><span class="koboSpan" id="kobo.1108.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1109.1">import</span></span><span class="koboSpan" id="kobo.1110.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1111.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1112.1">"runtime"</span></span><span class="koboSpan" id="kobo.1113.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1114.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1115.1">printAlloc</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1116.1">()</span></span><span class="koboSpan" id="kobo.1117.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1118.1">var</span></span><span class="koboSpan" id="kobo.1119.1"> m runtime.MemStats
    runtime.ReadMemStats(&amp;m)
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1120.1">"%d KB\n"</span></span><span class="koboSpan" id="kobo.1121.1">, m.Alloc/</span><span class="hljs-number"><span class="koboSpan" id="kobo.1122.1">1024</span></span><span class="koboSpan" id="kobo.1123.1">)
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1124.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1125.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1126.1">()</span></span><span class="koboSpan" id="kobo.1127.1"> {
    n := </span><span class="hljs-number"><span class="koboSpan" id="kobo.1128.1">2000000</span></span><span class="koboSpan" id="kobo.1129.1">
    m := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1130.1">make</span></span><span class="koboSpan" id="kobo.1131.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1132.1">map</span></span><span class="koboSpan" id="kobo.1133.1">[</span><span class="hljs-type"><span class="koboSpan" id="kobo.1134.1">int</span></span><span class="koboSpan" id="kobo.1135.1">][</span><span class="hljs-number"><span class="koboSpan" id="kobo.1136.1">128</span></span><span class="koboSpan" id="kobo.1137.1">]</span><span class="hljs-type"><span class="koboSpan" id="kobo.1138.1">byte</span></span><span class="koboSpan" id="kobo.1139.1">)
    printAlloc()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1140.1">for</span></span><span class="koboSpan" id="kobo.1141.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.1142.1">0</span></span><span class="koboSpan" id="kobo.1143.1">; i &lt; n; i++ {
    	m[i] = [</span><span class="hljs-number"><span class="koboSpan" id="kobo.1144.1">128</span></span><span class="koboSpan" id="kobo.1145.1">]</span><span class="hljs-type"><span class="koboSpan" id="kobo.1146.1">byte</span></span><span class="koboSpan" id="kobo.1147.1">{}
    }
    printAlloc()
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1148.1">for</span></span><span class="koboSpan" id="kobo.1149.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.1150.1">0</span></span><span class="koboSpan" id="kobo.1151.1">; i &lt; n; i++ {
    	</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1152.1">delete</span></span><span class="koboSpan" id="kobo.1153.1">(m, i)
    }
    runtime.GC()
    printAlloc()
    runtime.KeepAlive(m)
    m = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1154.1">nil</span></span><span class="koboSpan" id="kobo.1155.1">
    runtime.GC()
    printAlloc()
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1156.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1157.1">printAlloc()</span></code><span class="koboSpan" id="kobo.1158.1"> is a helper function for printing information about the memory, whereas the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1159.1">runtime.KeepAlive(m)</span></code><span class="koboSpan" id="kobo.1160.1"> statement keeps a reference to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1161.1">m</span></code><span class="koboSpan" id="kobo.1162.1"> so that the map is not garbage collected.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1163.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1164.1">mapsLeaks.go</span></code><span class="koboSpan" id="kobo.1165.1"> produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1166.1">$ </span></span><span class="koboSpan" id="kobo.1167.1">go run -gcflags </span><span class="hljs-con-string"><span class="koboSpan" id="kobo.1168.1">'-m -l'</span></span><span class="koboSpan" id="kobo.1169.1"> mapsLeaks.go
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1170.1"># </span></span><span class="koboSpan" id="kobo.1171.1">command-line-arguments
./mapsLeaks.go:11:12: ... </span><span class="koboSpan" id="kobo.1171.2">argument does not escape
./mapsLeaks.go:11:31: m.Alloc / 1024 escapes to heap
./mapsLeaks.go:16:11: make(map[int][128]byte) does not escape
111 KB
927931 KB
600767 KB
119 KB
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1172.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1173.1">make(map[int][128]byte)</span></code><span class="koboSpan" id="kobo.1174.1"> statement allocates 111 KB of memory only. </span><span class="koboSpan" id="kobo.1174.2">However, when we populate the map, it allocates 927,931 KB of memory. </span><span class="koboSpan" id="kobo.1174.3">After that, we delete all the elements of the map, and we somehow expect the used memory to shrink. </span><span class="koboSpan" id="kobo.1174.4">However, the empty map requires 600,767 KB of memory! </span><span class="koboSpan" id="kobo.1174.5">The reason for that is that by design the number of buckets in a map cannot shrink. </span><span class="koboSpan" id="kobo.1174.6">As a result, when we remove all maps elements, we do not reduce the number of existing buckets; we just zero the slots in the buckets.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1175.1">However, using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1176.1">m = nil</span></code><span class="koboSpan" id="kobo.1177.1"> allows the GC to free the memory that was previously occupied by </span><code class="inlineCode"><span class="koboSpan" id="kobo.1178.1">m</span></code><span class="koboSpan" id="kobo.1179.1"> and now </span><a id="_idIndexMarker1261"/><span class="koboSpan" id="kobo.1180.1">only 119 KB of memory are allocated. </span><span class="koboSpan" id="kobo.1180.2">As a result, giving </span><code class="inlineCode"><span class="koboSpan" id="kobo.1181.1">nil</span></code><span class="koboSpan" id="kobo.1182.1"> values</span><a id="_idIndexMarker1262"/><span class="koboSpan" id="kobo.1183.1"> to unused objects is a good practice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1184.1">Lastly, we are going to present a technique that can reduce memory allocations.</span></p>
<h2 class="heading-2" id="_idParaDest-400"><span class="koboSpan" id="kobo.1185.1">Memory pre-allocation</span></h2>
<p class="normal"><em class="italic"><span class="koboSpan" id="kobo.1186.1">Memory pre-allocation</span></em><span class="koboSpan" id="kobo.1187.1"> refers to the</span><a id="_idIndexMarker1263"/><span class="koboSpan" id="kobo.1188.1"> act of reserving memory space for data structures before they are needed. </span><span class="koboSpan" id="kobo.1188.2">Although pre-allocating memory is not a panacea, it can be beneficial in certain situations to avoid frequent memory allocations and deallocations, which can lead to improved performance and reduced memory fragmentation.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1189.1">It is essential to consider pre-allocation when you have a good estimate of the required capacity or size, you expect a significant number of insertions or appends, or when you want to reduce memory reallocations and improve performance. </span><span class="koboSpan" id="kobo.1189.2">However, pre-allocation makes more sense when dealing with large amounts of data.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1190.1">The implementation </span><a id="_idIndexMarker1264"/><span class="koboSpan" id="kobo.1191.1">of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1192.1">main()</span></code><span class="koboSpan" id="kobo.1193.1"> function of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1194.1">preallocate.go</span></code><span class="koboSpan" id="kobo.1195.1"> is presented in two parts. </span><span class="koboSpan" id="kobo.1195.2">The first part comes with the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1196.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1197.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1198.1">()</span></span><span class="koboSpan" id="kobo.1199.1"> {
    mySlice := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1200.1">make</span></span><span class="koboSpan" id="kobo.1201.1">([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.1202.1">int</span></span><span class="koboSpan" id="kobo.1203.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1204.1">0</span></span><span class="koboSpan" id="kobo.1205.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1206.1">100</span></span><span class="koboSpan" id="kobo.1207.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1208.1">for</span></span><span class="koboSpan" id="kobo.1209.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.1210.1">0</span></span><span class="koboSpan" id="kobo.1211.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.1212.1">100</span></span><span class="koboSpan" id="kobo.1213.1">; i++ {
    	mySlice = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1214.1">append</span></span><span class="koboSpan" id="kobo.1215.1">(mySlice, i)
    }
    fmt.Println(mySlice)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1216.1">In this example, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1217.1">make()</span></code><span class="koboSpan" id="kobo.1218.1"> function is used to create a slice with a length of 0 and a capacity of 100. </span><span class="koboSpan" id="kobo.1218.2">This pre-allocates memory for the slice, and as elements are appended, the slice can grow without the need for repeated reallocation, which slows down the process.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1219.1">The second part is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1220.1">    myMap := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1221.1">make</span></span><span class="koboSpan" id="kobo.1222.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1223.1">map</span></span><span class="koboSpan" id="kobo.1224.1">[</span><span class="hljs-type"><span class="koboSpan" id="kobo.1225.1">string</span></span><span class="koboSpan" id="kobo.1226.1">]</span><span class="hljs-type"><span class="koboSpan" id="kobo.1227.1">int</span></span><span class="koboSpan" id="kobo.1228.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1229.1">10</span></span><span class="koboSpan" id="kobo.1230.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1231.1">for</span></span><span class="koboSpan" id="kobo.1232.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.1233.1">0</span></span><span class="koboSpan" id="kobo.1234.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.1235.1">10</span></span><span class="koboSpan" id="kobo.1236.1">; i++ {
    	key := fmt.Sprintf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1237.1">"k%d"</span></span><span class="koboSpan" id="kobo.1238.1">, i)
    	myMap[key] = i
    }
    fmt.Println(myMap)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1239.1">As before, by providing an initial capacity, we reduce the chances of the map being resized</span><a id="_idIndexMarker1265"/><span class="koboSpan" id="kobo.1240.1"> frequently as elements are added, leading to more efficient memory usage.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1241.1">The next section discusses the use of eBPF from Go—as </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.1242.1">eBPF is available on Linux only</span></strong><span class="koboSpan" id="kobo.1243.1">, the presented code can be executed on Linux machines only.</span></p>
<h1 class="heading-1" id="_idParaDest-401"><span class="koboSpan" id="kobo.1244.1">Working with eBPF</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1245.1">BPF stands for Berkeley Packet Filter</span><a id="_idIndexMarker1266"/><span class="koboSpan" id="kobo.1246.1"> and eBPF for Extended BPF. </span><span class="koboSpan" id="kobo.1246.2">BPF was introduced back in 1992 to improve the performance of packet capture tools. </span><span class="koboSpan" id="kobo.1246.3">Back in 2013, Alexei Starovoitov did a major rewrite of BPF that was included in the Linux kernel in 2014 and replaced BPF. </span><span class="koboSpan" id="kobo.1246.4">With this rewrite, BPF, which is now called eBPF, became more versatile and can be used for a variety of tasks other than network packet capture.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1247.1">eBPF software</span><a id="_idIndexMarker1267"/><span class="koboSpan" id="kobo.1248.1"> can be programmed in BCC, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1249.1">bpftrace</span></code><span class="koboSpan" id="kobo.1250.1">, or using LLVM. </span><span class="koboSpan" id="kobo.1250.2">The LLVM compiler can compile BPF programs into BPF bytecode using a supported programming language such as C or the LLVM intermediate representation. </span><span class="koboSpan" id="kobo.1250.3">As both ways are difficult to program because of the use of low-level code, using BCC or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1251.1">bpftrace</span></code><span class="koboSpan" id="kobo.1252.1"> makes things simpler for the developer.</span></p>
<h2 class="heading-2" id="_idParaDest-402"><span class="koboSpan" id="kobo.1253.1">What is eBPF?</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1254.1">It is really difficult to </span><a id="_idIndexMarker1268"/><span class="koboSpan" id="kobo.1255.1">describe precisely what eBPF can do because it has so many capabilities. </span><span class="koboSpan" id="kobo.1255.2">It is much easier to describe how we can use eBPF. </span><span class="koboSpan" id="kobo.1255.3">eBPF can be used in three main areas: networking, security, and observability. </span><span class="koboSpan" id="kobo.1255.4">This section focuses on the observability capabilities (tracing) of eBPF.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1256.1">You can consider eBPF as a virtual machine located inside the Linux kernel that can execute eBPF commands, which is custom BPF code. </span><span class="koboSpan" id="kobo.1256.2">So, eBPF makes the Linux kernel programmable to help you solve real-world problems. </span><span class="koboSpan" id="kobo.1256.3">Keep in mind that eBPF (as well as all programming languages) does not solve problems on its own. </span><span class="koboSpan" id="kobo.1256.4">eBPF just gives you the tools to solve your problems! </span><span class="koboSpan" id="kobo.1256.5">eBPF programs are executed by the Linux kernel eBPF runtime.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1257.1">In more detail, the key features and aspects</span><a id="_idIndexMarker1269"/><span class="koboSpan" id="kobo.1258.1"> of eBPF include the following:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1259.1">Programmability</span></strong><span class="koboSpan" id="kobo.1260.1">: eBPF allows users to write and load small programs into the kernel, which can be attached to various hooks or entry points within the kernel code. </span><span class="koboSpan" id="kobo.1260.2">These programs run in a restricted virtual machine environment, ensuring safety and security.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1261.1">In-kernel execution</span></strong><span class="koboSpan" id="kobo.1262.1">: eBPF programs are executed within the kernel in a secure way, making it possible to perform efficient and low-overhead operations directly in kernel space.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1263.1">Dynamic attach points</span></strong><span class="koboSpan" id="kobo.1264.1">: eBPF programs can be attached to various hooks or attach points in the kernel, allowing developers to extend and customize kernel behavior dynamically. </span><span class="koboSpan" id="kobo.1264.2">Examples include networking, tracing, and security-related hooks.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1265.1">Observability and tracing</span></strong><span class="koboSpan" id="kobo.1266.1">: eBPF is widely used for observability and tracing purposes as it allows developers to instrument the kernel to gather insights into system behavior, performance, and interactions. </span><span class="koboSpan" id="kobo.1266.2">Tools like </span><code class="inlineCode"><span class="koboSpan" id="kobo.1267.1">bpftrace</span></code><span class="koboSpan" id="kobo.1268.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1269.1">perf</span></code><span class="koboSpan" id="kobo.1270.1"> use eBPF to provide advanced tracing capabilities.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1271.1">Networking</span></strong><span class="koboSpan" id="kobo.1272.1">: eBPF is extensively used in networking for tasks such as packet filtering, traffic monitoring, and load balancing. </span><span class="koboSpan" id="kobo.1272.2">It enables the creation of efficient and customizable networking solutions without requiring modifications to the kernel.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1273.1">Performance analysis</span></strong><span class="koboSpan" id="kobo.1274.1">: eBPF provides a powerful framework for performance analysis and profiling. </span><span class="koboSpan" id="kobo.1274.2">It allows developers and administrators to collect detailed information about system performance without significant </span><a id="_idIndexMarker1270"/><span class="koboSpan" id="kobo.1275.1">overhead.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1276.1">The main advantage of eBPF compared to traditional performance tools is that it is efficient, production-safe, and part of the Linux kernel. </span><span class="koboSpan" id="kobo.1276.2">In practice, this means that we can use eBPF without the need to add or load any other components to the Linux kernel.</span></p>
<h2 class="heading-2" id="_idParaDest-403"><span class="koboSpan" id="kobo.1277.1">About observability and eBPF</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1278.1">Most Linux</span><a id="_idIndexMarker1271"/><span class="koboSpan" id="kobo.1279.1"> applications are executed in user space, which is a layer without too </span><a id="_idIndexMarker1272"/><span class="koboSpan" id="kobo.1280.1">many privileges. </span><span class="koboSpan" id="kobo.1280.2">Although using user space is safer and more secure, it has restrictions and requires using system calls to ask the kernel for access to privileged resources. </span><span class="koboSpan" id="kobo.1280.3">Even the simplest commands use a large amount of system calls when executed. </span><span class="koboSpan" id="kobo.1280.4">In practice, this means that if we are able to observe the system calls of our applications, we can learn more information about the way they behave and operate.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1281.1">When things operate as expected and the performance of our applications is good, we usually do not care much about performance and the executed system calls. </span><span class="koboSpan" id="kobo.1281.2">But when things go wrong, we desperately need to understand more about the operation of our applications. </span><span class="koboSpan" id="kobo.1281.3">Putting special code in the Linux kernel or developing a module in order to understand the operation of our applications is a difficult task that might require a long period of time. </span><span class="koboSpan" id="kobo.1281.4">This is where observability and eBPF come into play. </span><span class="koboSpan" id="kobo.1281.5">eBPF, its language, and its tools allow us to dynamically see what happens behind the scenes without the need to change the entire Linux operating system.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1282.1">All you need to communicate with eBPF is a programming language that </span><a id="_idIndexMarker1273"/><span class="koboSpan" id="kobo.1283.1">supports </span><code class="inlineCode"><span class="koboSpan" id="kobo.1284.1">libbpf</span></code><span class="koboSpan" id="kobo.1285.1"> (</span><a href="https://github.com/libbpf/libbpf"><span class="url"><span class="koboSpan" id="kobo.1286.1">https://github.com/libbpf/libbpf</span></span></a><span class="koboSpan" id="kobo.1287.1">). </span><span class="koboSpan" id="kobo.1287.2">Apart from C, Go also offers support for</span><a id="_idIndexMarker1274"/><span class="koboSpan" id="kobo.1288.1"> the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1289.1">libbpf</span></code><span class="koboSpan" id="kobo.1290.1"> library (</span><a href="https://github.com/aquasecurity/libbpfgo"><span class="url"><span class="koboSpan" id="kobo.1291.1">https://github.com/aquasecurity/libbpfgo</span></span></a><span class="koboSpan" id="kobo.1292.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1293.1">The next subsection shows how to create an eBPF tool in Go.</span></p>
<h2 class="heading-2" id="_idParaDest-404"><span class="koboSpan" id="kobo.1294.1">Creating an eBPF tool in Go</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1295.1">As </span><code class="inlineCode"><span class="koboSpan" id="kobo.1296.1">gobpf</span></code><span class="koboSpan" id="kobo.1297.1"> is an </span><a id="_idIndexMarker1275"/><span class="koboSpan" id="kobo.1298.1">external Go package and the fact that, by default, all recent Go </span><a id="_idIndexMarker1276"/><span class="koboSpan" id="kobo.1299.1">versions use modules, all source code should be put somewhere under </span><code class="inlineCode"><span class="koboSpan" id="kobo.1300.1">~/go/src</span></code><span class="koboSpan" id="kobo.1301.1">. </span><span class="koboSpan" id="kobo.1301.2">The presented utility records the user ID of each user by tracing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1302.1">getuid(2)</span></code><span class="koboSpan" id="kobo.1303.1"> system call and keeps a count for each user ID.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1304.1">The code of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1305.1">uid.go</span></code><span class="koboSpan" id="kobo.1306.1"> utility is going to be presented in four parts. </span><span class="koboSpan" id="kobo.1306.2">The first part comes with the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1307.1">package</span></span><span class="koboSpan" id="kobo.1308.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1309.1">import</span></span><span class="koboSpan" id="kobo.1310.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.1311.1">"encoding/binary"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1312.1">"flag"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1313.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1314.1">"os"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1315.1">"os/signal"</span></span><span class="koboSpan" id="kobo.1316.1">
    bpf </span><span class="hljs-string"><span class="koboSpan" id="kobo.1317.1">"github.com/iovisor/gobpf/bcc"</span></span><span class="koboSpan" id="kobo.1318.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1319.1">import</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1320.1">"C"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1321.1">const</span></span><span class="koboSpan" id="kobo.1322.1"> source </span><span class="hljs-type"><span class="koboSpan" id="kobo.1323.1">string</span></span><span class="koboSpan" id="kobo.1324.1"> = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1325.1">`</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1326.1">#include &lt;uapi/linux/ptrace.h&gt;</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1327.1">BPF_HASH(counts);</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1328.1">int count(struct pt_regs *ctx) {</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1329.1">    if (!PT_REGS_PARM1(ctx))</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1330.1">        return 0;</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1331.1">    u64 *pointer;</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1332.1">    u64 times = 0;</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1333.1">    u64 uid;</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1334.1">    uid = bpf_get_current_uid_gid() &amp; 0xFFFFFFFF;</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1335.1">    pointer = counts.lookup(&amp;uid);</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1336.1">        if (pointer !=0)</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1337.1">            times = *pointer;</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1338.1">    times++;</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1339.1">        counts.update(&amp;uid, &amp;times);</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1340.1">    return 0;</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1341.1">}</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1342.1">`</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1343.1">If you are familiar with the C programming language, you should recognize that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1344.1">source</span></code><span class="koboSpan" id="kobo.1345.1"> variable </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.1346.1">holds C code</span></strong><span class="koboSpan" id="kobo.1347.1">—this is the code that communicates with the Linux kernel to get the desired information. </span><span class="koboSpan" id="kobo.1347.2">However, this code is called from a Go program.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1348.1">The second </span><a id="_idIndexMarker1277"/><span class="koboSpan" id="kobo.1349.1">part of</span><a id="_idIndexMarker1278"/><span class="koboSpan" id="kobo.1350.1"> the utility is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1351.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1352.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1353.1">()</span></span><span class="koboSpan" id="kobo.1354.1"> {
    pid := flag.Int(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1355.1">"pid"</span></span><span class="koboSpan" id="kobo.1356.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1357.1">-1</span></span><span class="koboSpan" id="kobo.1358.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1359.1">"attach to pid, default is all processes"</span></span><span class="koboSpan" id="kobo.1360.1">)
    flag.Parse()
    m := bpf.NewModule(source, []</span><span class="hljs-type"><span class="koboSpan" id="kobo.1361.1">string</span></span><span class="koboSpan" id="kobo.1362.1">{})
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1363.1">defer</span></span><span class="koboSpan" id="kobo.1364.1"> m.Close()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1365.1">In this second part, we define a command line argument named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1366.1">pid</span></code><span class="koboSpan" id="kobo.1367.1"> and initialize a new eBPF module named </span><code class="inlineCode"><span class="koboSpan" id="kobo.1368.1">m</span></code><span class="koboSpan" id="kobo.1369.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1370.1">The third part of the utility contains the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1371.1">    Uprobe, err := m.LoadUprobe(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1372.1">"count"</span></span><span class="koboSpan" id="kobo.1373.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1374.1">if</span></span><span class="koboSpan" id="kobo.1375.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1376.1">nil</span></span><span class="koboSpan" id="kobo.1377.1"> {
        fmt.Fprintf(os.Stderr, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1378.1">"Failed to load uprobe count: %s\n"</span></span><span class="koboSpan" id="kobo.1379.1">, err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1380.1">return</span></span><span class="koboSpan" id="kobo.1381.1">
    }
    err = m.AttachUprobe(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1382.1">"c"</span></span><span class="koboSpan" id="kobo.1383.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1384.1">"getuid"</span></span><span class="koboSpan" id="kobo.1385.1">, Uprobe, *pid)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1386.1">if</span></span><span class="koboSpan" id="kobo.1387.1"> err != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1388.1">nil</span></span><span class="koboSpan" id="kobo.1389.1"> {
        fmt.Fprintf(os.Stderr, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1390.1">"Failed to attach uprobe to getuid: %s\n"</span></span><span class="koboSpan" id="kobo.1391.1">, err)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1392.1">return</span></span><span class="koboSpan" id="kobo.1393.1">
    }
    table := bpf.NewTable(m.TableId(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1394.1">"counts"</span></span><span class="koboSpan" id="kobo.1395.1">), m)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1396.1">"Tracing getuid()... </span><span class="koboSpan" id="kobo.1396.2">Press Ctrl-C to end."</span></span><span class="koboSpan" id="kobo.1397.1">)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1398.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1399.1">m.LoadUprobe("count")</span></code><span class="koboSpan" id="kobo.1400.1"> statement loads the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1401.1">count()</span></code><span class="koboSpan" id="kobo.1402.1"> function. </span><span class="koboSpan" id="kobo.1402.2">The handling of the probe is initiated with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1403.1">m.AttachUprobe()</span></code><span class="koboSpan" id="kobo.1404.1"> call. </span><span class="koboSpan" id="kobo.1404.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1405.1">AttachUprobe()</span></code><span class="koboSpan" id="kobo.1406.1"> method says that we want to trace the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1407.1">getuid(2)</span></code><span class="koboSpan" id="kobo.1408.1"> system call using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1409.1">Uprobe</span></code><span class="koboSpan" id="kobo.1410.1">. </span><span class="koboSpan" id="kobo.1410.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1411.1">bpf.NewTable()</span></code><span class="koboSpan" id="kobo.1412.1"> statement is what gives us access to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1413.1">counts</span></code><span class="koboSpan" id="kobo.1414.1"> hash defined in the C code. </span><span class="koboSpan" id="kobo.1414.2">Remember that the eBPF program is written in C code that is held in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1415.1">string</span></code><span class="koboSpan" id="kobo.1416.1"> variable.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1417.1">The last part of the utility contains the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1418.1">    sig := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1419.1">make</span></span><span class="koboSpan" id="kobo.1420.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1421.1">chan</span></span><span class="koboSpan" id="kobo.1422.1"> os.Signal, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1423.1">1</span></span><span class="koboSpan" id="kobo.1424.1">)
    signal.Notify(sig, os.Interrupt)
    &lt;-sig
    fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1425.1">"%s\t%s\n"</span></span><span class="koboSpan" id="kobo.1426.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1427.1">"User ID"</span></span><span class="koboSpan" id="kobo.1428.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1429.1">"COUNT"</span></span><span class="koboSpan" id="kobo.1430.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1431.1">for</span></span><span class="koboSpan" id="kobo.1432.1"> it := table.Iter(); it.Next(); {
        k := binary.LittleEndian.Uint64(it.Key())
        v := binary.LittleEndian.Uint64(it.Leaf())
        fmt.Printf(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1433.1">"%d\t\t%d\n"</span></span><span class="koboSpan" id="kobo.1434.1">, k, v)
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1435.1">The previous </span><a id="_idIndexMarker1279"/><span class="koboSpan" id="kobo.1436.1">code uses</span><a id="_idIndexMarker1280"/><span class="koboSpan" id="kobo.1437.1"> channels and UNIX signal handling to block the program. </span><span class="koboSpan" id="kobo.1437.2">Once </span><em class="keystroke"><span class="koboSpan" id="kobo.1438.1">Ctrl</span></em><span class="koboSpan" id="kobo.1439.1"> + </span><em class="keystroke"><span class="koboSpan" id="kobo.1440.1">C</span></em><span class="koboSpan" id="kobo.1441.1"> is pressed, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1442.1">sig</span></code><span class="koboSpan" id="kobo.1443.1"> channel unblocks the program and prints the desired information with the help of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1444.1">table</span></code><span class="koboSpan" id="kobo.1445.1"> variable. </span><span class="koboSpan" id="kobo.1445.2">As the data in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1446.1">table</span></code><span class="koboSpan" id="kobo.1447.1"> variable is in the binary format, we need to decode it using two </span><code class="inlineCode"><span class="koboSpan" id="kobo.1448.1">binary.LittleEndian.Uint64()</span></code><span class="koboSpan" id="kobo.1449.1"> calls.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1450.1">In order to execute the program, you need a C compiler and the BPF libraries to be installed, which depends on your Linux variant. </span><span class="koboSpan" id="kobo.1450.2">Please refer to your Linux variant documentation for instructions on how to install eBPF. </span><span class="koboSpan" id="kobo.1450.3">If you have any issues running the program, ask in relevant forums.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1451.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.1452.1">uid.go</span></code><span class="koboSpan" id="kobo.1453.1"> creates the following kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1454.1">$ </span></span><span class="koboSpan" id="kobo.1455.1">go run uid.go
Tracing getuid()... </span><span class="koboSpan" id="kobo.1455.2">Press Ctrl-C to end.
</span><span class="koboSpan" id="kobo.1455.3">User ID    COUNT
979        4
0          3
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1456.1">You can use </span><a id="_idIndexMarker1281"/><span class="koboSpan" id="kobo.1457.1">the code </span><a id="_idIndexMarker1282"/><span class="koboSpan" id="kobo.1458.1">in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1459.1">uid.go</span></code><span class="koboSpan" id="kobo.1460.1"> as a template when writing your own eBPF utilities in Go.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1461.1">The section that follows discusses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1462.1">rand.Seed()</span></code><span class="koboSpan" id="kobo.1463.1"> function and why it is not necessary to use it, starting from Go version 1.20.</span></p>
<h1 class="heading-1" id="_idParaDest-405"><span class="koboSpan" id="kobo.1464.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1465.1">In this chapter of the book, we presented various advanced Go topics related to benchmarking, performance, and efficiency. </span><span class="koboSpan" id="kobo.1465.2">Remember that benchmark results can be influenced by various factors such as hardware, compiler optimizations, and workload. </span><span class="koboSpan" id="kobo.1465.3">It is important to </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.1466.1">interpret the results carefully and rationally</span></strong><span class="koboSpan" id="kobo.1467.1"> while considering the specific conditions under which the benchmarks are run.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1468.1">In this chapter, we learned that Go has automatic memory management, which means that the language runtime takes care of memory allocation and deallocation for you. </span><span class="koboSpan" id="kobo.1468.2">The primary components of Go’s memory management are garbage collection, automatic memory allocation, and a runtime scheduler.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1469.1">This chapter also presented a very powerful technology, eBPF. </span><span class="koboSpan" id="kobo.1469.2">If you are using Linux machines, then you should definitely learn more about eBPF and how to use it with Go. </span><span class="koboSpan" id="kobo.1469.3">The eBPF framework has gained popularity due to its versatility and the ability to address a wide range of use cases within the Linux kernel. </span><span class="koboSpan" id="kobo.1469.4">When working with eBPF, you should first think like a system administrator, not as a programmer. </span><span class="koboSpan" id="kobo.1469.5">Put simply, start by trying the existing eBPF tools instead of writing your own. </span><span class="koboSpan" id="kobo.1469.6">However, if you have an actual issue that cannot be solved by existing eBPF tools, then you might need to start acting like a developer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1470.1">The next chapter is about Go 1.21 and Go 1.22 and the changes they introduced.</span></p>
<h1 class="heading-1" id="_idParaDest-406"><span class="koboSpan" id="kobo.1471.1">Exercises</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1472.1">Try to do the following exercises:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1473.1">Create three different implementations of a function that copies binary files and benchmark them to find the faster one. </span><span class="koboSpan" id="kobo.1473.2">Can you explain why this function is faster?</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1474.1">Write a version of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1475.1">BenchmarkWBufWriterReset()</span></code><span class="koboSpan" id="kobo.1476.1"> that does not use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1477.1">buffer.Reset()</span></code><span class="koboSpan" id="kobo.1478.1"> and see how fast it performs.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1479.1">This is a really difficult task: Create a machine learning library in Go. </span><span class="koboSpan" id="kobo.1479.2">Keep in mind that, behind the scenes, ML uses statistics and matrix operations.</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-407"><span class="koboSpan" id="kobo.1480.1">Additional resources</span></h1>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1481.1">gobpf: </span><a href="https://github.com/iovisor/gobpf"><span class="url"><span class="koboSpan" id="kobo.1482.1">https://github.com/iovisor/gobpf</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1483.1">The smallest Go binary: </span><a href="https://totallygamerjet.hashnode.dev/the-smallest-go-binary-5kb "><span class="url"><span class="koboSpan" id="kobo.1484.1">https://totallygamerjet.hashnode.dev/the-smallest-go-binary-5kb</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1485.1">Working with Go execution traces (gotraceui): </span><a href="https://gotraceui.dev/"><span class="url"><span class="koboSpan" id="kobo.1486.1">https://gotraceui.dev/</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1487.1">How to troubleshoot memory leaks in Go with Grafana Pyroscope: </span><a href="https://grafana.com/blog/2023/04/19/how-to-troubleshoot-memory-leaks-in-go-with-grafana-pyroscope/"><span class="url"><span class="koboSpan" id="kobo.1488.1">https://grafana.com/blog/2023/04/19/how-to-troubleshoot-memory-leaks-in-go-with-grafana-pyroscope/</span></span></a></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1489.1">A few bytes here, a few there, pretty soon you’re talking real memory</span></em><span class="koboSpan" id="kobo.1490.1">: </span><a href="https://dave.cheney.net/2021/01/05/a-few-bytes-here-a-few-there-pretty-soon-youre-talking-real-memory"><span class="url"><span class="koboSpan" id="kobo.1491.1">https://dave.cheney.net/2021/01/05/a-few-bytes-here-a-few-there-pretty-soon-youre-talking-real-memory</span></span></a></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.1492.1">Join our community on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1493.1">Join our community’s Discord space for discussions with the authors and other readers:</span></p>
<p class="normal"><a href="https://discord.gg/FzuQbc8zd6 "><span class="url"><span class="koboSpan" id="kobo.1494.1">https://discord.gg/FzuQbc8zd6</span></span></a></p>
<p class="normal"><a href="https://discord.gg/FzuQbc8zd6 "><span class="url"><span class="koboSpan" id="kobo.1495.1"><img alt="" role="presentation" src="../Images/QR_Code2286825896190168453.png"/></span></span></a></p>
</div>
</body></html>