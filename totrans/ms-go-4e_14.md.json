["```go\npackage main\nimport (\n    \"fmt\"\n)\nfunc InitSliceNew(n int) []int {\n    s := make([]int, n)\n    for i := 0; i < n; i++ {\n    \ts[i] = i\n    }\n    return s\n} \n```", "```go\nfunc InitSliceAppend(n int) []int {\n    s := make([]int, 0)\n    for i := 0; i < n; i++ {\n    \ts = append(s, i)\n    }\n    return s\n}\nfunc main() {\n    fmt.Println(InitSliceNew(10))\n    fmt.Println(InitSliceAppend(10))\n} \n```", "```go\npackage main\nimport (\n    \"testing\"\n)\nvar t []int\nfunc BenchmarkNew(b *testing.B) {\n    for i := 0; i < b.N; i++ {\n    \tt = InitSliceNew(i)\n    }\n}\nfunc BenchmarkAppend(b *testing.B) {\n    for i := 0; i < b.N; i++ {\n    \tt = InitSliceAppend(i)\n    }\n} \n```", "```go\n$ go test -bench=. *.go\ngoos: darwin\ngoarch: arm64\nBenchmarkNew-10             255704         79712 ns/op\nBenchmarkAppend-10           86847        143459 ns/op\nPASS\nok    command-line-arguments    33.539s \n```", "```go\npackage allocate\nimport (\n    \"bytes\"\n)\nfunc writeMessage(msg []byte) {\n    b := new(bytes.Buffer)\n    b.Write(msg)\n} \n```", "```go\npackage allocate\nimport (\n    \"testing\"\n)\nfunc BenchmarkWrite(b *testing.B) {\n    msg := []byte(\"Mastering Go!\")\n    for i := 0; i < b.N; i++ {\n        for k := 0; k < 50; k++ {\n            writeMessage(msg)\n        }\n    }\n} \n```", "```go\n$ go test -bench=. -benchmem *.go\ngoos: darwin\ngoarch: arm64\nBenchmarkWrite-10     1148637    1024 ns/op    3200 B/op    50 allocs/op\nPASS\nok    command-line-arguments    2.256s \n```", "```go\npackage allocate\nimport (\n    \"bytes\"\n\"io\"\n)\nfunc writeMessageBuffer(msg []byte, b bytes.Buffer) {\n    b.Write(msg)\n}\nfunc writeMessageBufferPointer(msg []byte, b *bytes.Buffer) {\n    b.Write(msg)\n}\nfunc writeMessageBufferWriter(msg []byte, b io.Writer) {\n    b.Write(msg)\n} \n```", "```go\npackage allocate\nimport (\n    \"bytes\"\n\"testing\"\n)\nfunc BenchmarkWBuf(b *testing.B) {\n    msg := []byte(\"Mastering Go!\")\n    buffer := bytes.Buffer{}\n    for i := 0; i < b.N; i++ {\n        for k := 0; k < 50; k++ {\n            writeMessageBuffer(msg, buffer)\n        }\n    }\n} \n```", "```go\nfunc BenchmarkWBufPointerNoReset(b *testing.B) {\n    msg := []byte(\"Mastering Go!\")\n    buffer := new(bytes.Buffer)\n    for i := 0; i < b.N; i++ {\n        for k := 0; k < 50; k++ {\n            writeMessageBufferPointer(msg, buffer)\n        }\n    }\n} \n```", "```go\nfunc BenchmarkWBufPointerReset(b *testing.B) {\n    msg := []byte(\"Mastering Go!\")\n    buffer := new(bytes.Buffer)\n    for i := 0; i < b.N; i++ {\n        for k := 0; k < 50; k++ {\n            writeMessageBufferPointer(msg, buffer)\n            buffer.Reset()\n        }\n    }\n}\nfunc BenchmarkWBufWriterReset(b *testing.B) {\n    msg := []byte(\"Mastering Go!\")\n    buffer := new(bytes.Buffer)\n    for i := 0; i < b.N; i++ {\n        for k := 0; k < 50; k++ {\n            writeMessageBufferWriter(msg, buffer)\n            buffer.Reset()\n        }\n    }\n} \n```", "```go\n$ go test -bench=. -benchmem *.go\ngoos: darwin\ngoarch: arm64\nBenchmarkWBuf-10            1128193   1056 ns/op   3200 B/op 50 allocs/op\nBenchmarkWBufPointerNoReset-10 4050562   337.1 ns/op  2120 B/op 0 allocs/op\nBenchmarkWBufPointerReset-10   7993546   150.7 ns/op   0 B/op      0 allocs/op\nBenchmarkWBufWriterReset-10    7851434   151.8 ns/op   0 B/op   0 allocs/op\nPASS\nok      command-line-arguments    7.667s \n```", "```go\npackage table\nimport (\n    \"fmt\"\n\"os\"\n\"path\"\n\"strconv\"\n\"testing\"\n)\nvar ERR error\nvar countChars int\nfunc benchmarkCreate(b *testing.B, buffer, filesize int) {\n    filename := path.Join(os.TempDir(), strconv.Itoa(buffer))\n    filename = filename + \"-\" + strconv.Itoa(filesize)\n    var err error\nfor i := 0; i < b.N; i++ {\n        err = Create(filename, buffer, filesize)\n    }\n    ERR = err \n```", "```go\n err = os.Remove(filename)\n    if err != nil {\n        fmt.Println(err)\n    }\n    ERR = err\n} \n```", "```go\nfunc BenchmarkBuffer4Create(b *testing.B) {\n    benchmarkCreate(b, 4, 1000000)\n}\nfunc BenchmarkBuffer8Create(b *testing.B) {\n    benchmarkCreate(b, 8, 1000000)\n}\nfunc BenchmarkBuffer16Create(b *testing.B) {\n    benchmarkCreate(b, 16, 1000000)\n} \n```", "```go\nfunc BenchmarkRead(b *testing.B) {\n    buffers := []int{1, 16, 96}\n    files := []string{\"10.txt\", \"1000.txt\", \"5k.txt\"} \n```", "```go\n for _, filename := range files {\n        for _, bufSize := range buffers {\n            name := fmt.Sprintf(\"%s-%d\", filename, bufSize)\n            b.Run(name, func(b *testing.B) {\n                for i := 0; i < b.N; i++ {\n                    t := CountChars(\"./testdata/\"+filename, bufSize)\n                    countChars = t\n                }\n            })\n        }\n    }\n} \n```", "```go\n$ go test -bench=. -benchmem *.go\ngoos: darwin\ngoarch: arm64\nBenchmarkBuffer4Create-10     382740   2915 ns/op   384 B/op    5 allocs/op\nBenchmarkBuffer8Create-10     444297   2400 ns/op   384 B/op    5 allocs/op\nBenchmarkBuffer16Create-10    491230   2165 ns/op   384 B/op  5 allocs/op \n```", "```go\nBenchmarkRead/10.txt-1-10     146298    8180 ns/op   168 B/op   6 allocs/op\nBenchmarkRead/10.txt-16-10    197534    6024 ns/op   200 B/op   6 allocs/op\nBenchmarkRead/10.txt-96-10    197245    6148 ns/op   440 B/op   6 allocs/op\nBenchmarkRead/1000.txt-1-10   4382        268204 ns/op  168 B/op   6 allocs/op\nBenchmarkRead/1000.txt-16-10  32732    36684 ns/op   200 B/op   6 allocs/op\nBenchmarkRead/1000.txt-96-10  105078   11337 ns/op   440 B/op      6 allocs/op\nBenchmarkRead/5k.txt-1-10     912       1308924 ns/op  168 B/op\t  6 allocs/op\nBenchmarkRead/5k.txt-16-10    7413        159638 ns/op  200 B/op\t  6 allocs/op\nBenchmarkRead/5k.txt-96-10    36471    32841 ns/op   440 B/op      6 allocs/op \n```", "```go\nPASS\nok      command-line-arguments    24.518s \n```", "```go\n$ ~/go/bin/benchstat r1.txt r2.txt\n                   │     r1.txt     │                 r2.txt            │\n                   │     sec/op     │    sec/op     vs base             │\nBuffer4Create-8      10472.0n ± ∞ ¹   830.8n ± ∞ ¹     ~ (p=0.667 n=1+2) ²\nBuffer8Create-8       6884.0n ± ∞ ¹   798.9n ± ∞ ¹     ~ (p=0.667 n=1+2) ²\nBuffer16Create-8      5010.0n ± ∞ ¹   770.5n ± ∞ ¹     ~ (p=0.667 n=1+2) ²\nRead/10.txt-1-8       14.955µ ± ∞ ¹   3.987µ ± ∞ ¹     ~ (p=0.667 n=1+2) ²\nRead/10.txt-16-8      12.172µ ± ∞ ¹   2.583µ ± ∞ ¹     ~ (p=0.667 n=1+2) ²\nRead/10.txt-96-8      11.925µ ± ∞ ¹   2.612µ ± ∞ ¹     ~ (p=0.667 n=1+2) ²\nRead/1000.txt-1-8      381.3µ ± ∞ ¹   175.8µ ± ∞ ¹     ~ (p=0.667 n=1+2) ²\nRead/1000.txt-16-8     54.05µ ± ∞ ¹   22.68µ ± ∞ ¹     ~ (p=0.667 n=1+2) ²\nRead/1000.txt-96-8    19.115µ ± ∞ ¹   6.225µ ± ∞ ¹     ~ (p=1.333 n=1+2) ²\nRead/5k.txt-1-8       1812.5µ ± ∞ ¹   895.7µ ± ∞ ¹     ~ (p=0.667 n=1+2) ²\nRead/5k.txt-16-8       221.8µ ± ∞ ¹   107.7µ ± ∞ ¹     ~ (p=0.667 n=1+2) ²\nRead/5k.txt-96-8       51.53µ ± ∞ ¹   21.52µ ± ∞ ¹     ~ (p=0.667 n=1+2) ²\ngeomean                36.91µ         9.717µ        -73.68%\n¹ need >= 6 samples for confidence interval at level 0.95\n² need >= 4 samples to detect a difference at alpha level 0.05 \n```", "```go\nfunc BenchmarkFiboI(b *testing.B) {\n    for i := 0; i < b.N; i++ {\n        _ = fibo1(i)\n    }\n} \n```", "```go\nfunc BenchmarkfiboII(b *testing.B) {\n    for i := 0; i < b.N; i++ {\n        _ = fibo1(b.N)\n    }\n} \n```", "```go\nfunc BenchmarkFiboIV(b *testing.B) {\n    for i := 0; i < b.N; i++ {\n        _ = fibo1(10)\n    }\n}\nfunc BenchmarkFiboIII(b *testing.B) {\n    _ = fibo1(b.N)\n} \n```", "```go\npackage main\nimport \"fmt\"\nconst VAT = 24\ntype Item struct {\n    Description string\n    Value       float64\n}\nfunc Value(price float64) float64 {\n    total := price + price*VAT/100\nreturn total\n}\nfunc main() {\n    t := Item{Description: \"Keyboard\", Value: 100}\n    t.Value = Value(t.Value)\n    fmt.Println(t)\n    tP := &Item{}\n    *&tP.Description = \"Mouse\"\n    *&tP.Value = 100\n    fmt.Println(tP)\n} \n```", "```go\n$ go run -gcflags '-m' allocate.go\n# command-line-arguments\n./allocate.go:12:6: can inline Value\n./allocate.go:19:17: inlining call to Value\n./allocate.go:20:13: inlining call to fmt.Println\n./allocate.go:25:13: inlining call to fmt.Println\n./allocate.go:20:13: ... argument does not escape\n./allocate.go:20:14: t escapes to heap\n./allocate.go:22:8: &Item{} escapes to heap\n./allocate.go:25:13: ... argument does not escape\n{Keyboard 124}\n&{Mouse 100} \n```", "```go\n$ go run -gcflags '-m -m' allocate.go\n# command-line-arguments\n./allocate.go:12:6: can inline Value with cost 13 as: func(float64) float64 { total := price + price * VAT / 100; return total }\n./allocate.go:17:6: cannot inline main: function too complex: cost 199 exceeds budget 80\n./allocate.go:19:17: inlining call to Value\n./allocate.go:20:13: inlining call to fmt.Println\n./allocate.go:25:13: inlining call to fmt.Println\n./allocate.go:22:8: &Item{} escapes to heap:\n./allocate.go:22:8:   flow: tP = &{storage for &Item{}}:\n./allocate.go:22:8:     from &Item{} (spill) at ./allocate.go:22:8\n./allocate.go:22:8:     from tP := &Item{} (assign) at ./allocate.go:22:5\n./allocate.go:22:8:   flow: {storage for ... argument} = tP:\n./allocate.go:22:8:     from tP (interface-converted) at ./allocate.go:25:14\n./allocate.go:22:8:     from ... argument (slice-literal-element) at ./allocate.go:25:13\n./allocate.go:22:8:   flow: fmt.a = &{storage for ... argument}:\n./allocate.go:22:8:     from ... argument (spill) at ./allocate.go:25:13\n./allocate.go:22:8:     from fmt.a := ... argument (assign-pair) at ./allocate.go:25:13\n./allocate.go:22:8:   flow: {heap} = *fmt.a:\n./allocate.go:22:8:     from fmt.Fprintln(os.Stdout, fmt.a...) (call parameter) at ./allocate.go:25:13\n./allocate.go:20:14: t escapes to heap:\n./allocate.go:20:14:   flow: {storage for ... argument} = &{storage for t}:\n./allocate.go:20:14:     from t (spill) at ./allocate.go:20:14\n./allocate.go:20:14:     from ... argument (slice-literal-element) at ./allocate.go:20:13\n./allocate.go:20:14:   flow: fmt.a = &{storage for ... argument}:\n./allocate.go:20:14:     from ... argument (spill) at ./allocate.go:20:13\n./allocate.go:20:14:     from fmt.a := ... argument (assign-pair) at ./allocate.go:20:13\n./allocate.go:20:14:   flow: {heap} = *fmt.a:\n./allocate.go:20:14:     from fmt.Fprintln(os.Stdout, fmt.a...) (call parameter) at ./allocate.go:20:13\n./allocate.go:20:13: ... argument does not escape\n./allocate.go:20:14: t escapes to heap\n./allocate.go:22:8: &Item{} escapes to heap\n./allocate.go:25:13: ... argument does not escape\n{Keyboard 124}\n&{Mouse 100} \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"time\"\n)\nfunc createSlice() []int {\n    return make([]int, 1000000)\n}\nfunc getValue(s []int) []int {\n    val := s[:3]\n    return val\n}\nfunc main() {\n    for i := 0; i < 15; i++ {\n        message := createSlice()\n        val := getValue(message)\n        fmt.Print(len(val), \" \")\n        time.Sleep(10 * time.Millisecond)\n    }\n} \n```", "```go\n$ go run -gcflags '-m -l' slicesLeaks.go\n# command-line-arguments\n./slicesLeaks.go:9:13: make([]int, 1000000) escapes to heap\n./slicesLeaks.go:12:15: leaking param: s to result ~r0 level=0\n./slicesLeaks.go:21:12: ... argument does not escape\n./slicesLeaks.go:21:16: len(val) escapes to heap\n./slicesLeaks.go:21:23: \" \" escapes to heap\n3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 \n```", "```go\nfunc getValue(s []int) []int {\n    returnVal := make([]int, 3)\n    copy(returnVal, s)\n    return returnVal\n} \n```", "```go\n$ go run -gcflags '-m -l' slicesNoLeaks.go\n# command-line-arguments\n./slicesNoLeaks.go:9:13: make([]int, 1000000) escapes to heap\n./slicesNoLeaks.go:12:15: s does not escape\n./slicesNoLeaks.go:13:19: make([]int, 3) escapes to heap\n./slicesNoLeaks.go:22:12: ... argument does not escape\n./slicesNoLeaks.go:22:16: len(val) escapes to heap\n./slicesNoLeaks.go:22:23: \" \" escapes to heap\n3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 \n```", "```go\npackage main\nimport (\n    \"fmt\"\n\"runtime\"\n)\nfunc printAlloc() {\n    var m runtime.MemStats\n    runtime.ReadMemStats(&m)\n    fmt.Printf(\"%d KB\\n\", m.Alloc/1024)\n}\nfunc main() {\n    n := 2000000\n    m := make(map[int][128]byte)\n    printAlloc()\n    for i := 0; i < n; i++ {\n    \tm[i] = [128]byte{}\n    }\n    printAlloc()\n    for i := 0; i < n; i++ {\n    \tdelete(m, i)\n    }\n    runtime.GC()\n    printAlloc()\n    runtime.KeepAlive(m)\n    m = nil\n    runtime.GC()\n    printAlloc()\n} \n```", "```go\n$ go run -gcflags '-m -l' mapsLeaks.go\n# command-line-arguments\n./mapsLeaks.go:11:12: ... argument does not escape\n./mapsLeaks.go:11:31: m.Alloc / 1024 escapes to heap\n./mapsLeaks.go:16:11: make(map[int][128]byte) does not escape\n111 KB\n927931 KB\n600767 KB\n119 KB \n```", "```go\nfunc main() {\n    mySlice := make([]int, 0, 100)\n    for i := 0; i < 100; i++ {\n    \tmySlice = append(mySlice, i)\n    }\n    fmt.Println(mySlice) \n```", "```go\n myMap := make(map[string]int, 10)\n    for i := 0; i < 10; i++ {\n    \tkey := fmt.Sprintf(\"k%d\", i)\n    \tmyMap[key] = i\n    }\n    fmt.Println(myMap)\n} \n```", "```go\npackage main\nimport (\n    \"encoding/binary\"\n\"flag\"\n\"fmt\"\n\"os\"\n\"os/signal\"\n    bpf \"github.com/iovisor/gobpf/bcc\"\n)\nimport \"C\"\nconst source string = `\n#include <uapi/linux/ptrace.h>\nBPF_HASH(counts);\nint count(struct pt_regs *ctx) {\n    if (!PT_REGS_PARM1(ctx))\n        return 0;\n    u64 *pointer;\n    u64 times = 0;\n    u64 uid;\n    uid = bpf_get_current_uid_gid() & 0xFFFFFFFF;\n    pointer = counts.lookup(&uid);\n        if (pointer !=0)\n            times = *pointer;\n    times++;\n        counts.update(&uid, &times);\n    return 0;\n}\n` \n```", "```go\nfunc main() {\n    pid := flag.Int(\"pid\", -1, \"attach to pid, default is all processes\")\n    flag.Parse()\n    m := bpf.NewModule(source, []string{})\n    defer m.Close() \n```", "```go\n Uprobe, err := m.LoadUprobe(\"count\")\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"Failed to load uprobe count: %s\\n\", err)\n        return\n    }\n    err = m.AttachUprobe(\"c\", \"getuid\", Uprobe, *pid)\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"Failed to attach uprobe to getuid: %s\\n\", err)\n        return\n    }\n    table := bpf.NewTable(m.TableId(\"counts\"), m)\n    fmt.Println(\"Tracing getuid()... Press Ctrl-C to end.\") \n```", "```go\n sig := make(chan os.Signal, 1)\n    signal.Notify(sig, os.Interrupt)\n    <-sig\n    fmt.Printf(\"%s\\t%s\\n\", \"User ID\", \"COUNT\")\n    for it := table.Iter(); it.Next(); {\n        k := binary.LittleEndian.Uint64(it.Key())\n        v := binary.LittleEndian.Uint64(it.Leaf())\n        fmt.Printf(\"%d\\t\\t%d\\n\", k, v)\n    }\n} \n```", "```go\n$ go run uid.go\nTracing getuid()... Press Ctrl-C to end.\nUser ID    COUNT\n979        4\n0          3 \n```"]