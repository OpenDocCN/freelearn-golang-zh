- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Efficiency and Performance
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 效率和性能
- en: 'Every story has a villain. For developers, that villain is usually time. They
    must write code in a given time frame and ideally, the code must run as fast as
    possible. Most of the errors and bugs are a result of fighting with time constraints,
    both realistic and imaginary ones! So, this chapter is here to help you fight
    with the second aspect of time: efficiency and performance. For the first aspect
    of time, you need a good manager with technical skills.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每个故事都有一个反派。对于开发者来说，这个反派通常是时间。他们必须在给定的时间内编写代码，理想情况下，代码必须尽可能快地运行。大多数错误和缺陷都是与时间限制作斗争的结果，无论是现实的还是想象的！因此，本章旨在帮助你与时间的第二个方面作斗争：效率和性能。对于时间的第一个方面，你需要一个技术技能良好的好管理者。
- en: The first part of the chapter is about benchmarking Go code using benchmark
    functions that measure the performance of a function or an entire program. Thinking
    that the implementation of a function is faster than a different implementation
    is not enough. We need to be able to prove it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一部分是关于使用基准函数对 Go 代码进行基准测试，这些基准函数用于衡量函数或整个程序的性能。认为某个函数的实现比另一个实现更快是不够的。我们需要能够证明这一点。
- en: After that, we talk about how Go manages memory and how careless Go code can
    introduce memory leaks. A memory leak in Go occurs when memory that is no longer
    needed is not properly released, causing the program’s memory usage to grow over
    time. Understanding the memory model is crucial for writing efficient, correct,
    and concurrent Go programs. In practice, when our code uses large amounts of memory,
    which is not usually the case, we need to take extra care with our code for better
    performance.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将讨论 Go 如何管理内存，以及粗心的 Go 代码如何引入内存泄漏。在 Go 中，内存泄漏发生在不再需要的内存没有被正确释放时，导致程序内存使用量随时间增长。理解内存模型对于编写高效、正确和并发的
    Go 程序至关重要。在实践中，当我们的代码使用大量内存时（这通常不是情况），我们需要格外注意代码，以获得更好的性能。
- en: Lastly, we show how to use eBPF with Go. eBPF, which stands for Extended Berkeley
    Packet Filter, is a technology that enables programmability in the **Linux kernel**.
    It originated as an extension of the traditional **Berkeley Packet Filter** (**BPF**),
    which was designed for packet filtering within the kernel. eBPF, however, is a
    more general-purpose and flexible framework that allows the execution of user-supplied
    programs within the kernel space without requiring changes to the kernel itself.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将展示如何使用 Go 语言结合 eBPF。eBPF，即扩展伯克利包过滤器，是一种使 Linux 内核可编程的技术。它起源于对传统伯克利包过滤器（BPF）的扩展，BPF
    是为内核内部数据包过滤而设计的。然而，eBPF 是一个更通用和灵活的框架，允许在内核空间中执行用户提供的程序，而无需修改内核本身。
- en: 'We will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Benchmarking code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基准测试代码
- en: Buffered versus unbuffered file I/O
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲与非缓冲文件 I/O
- en: Wrongly defined benchmark functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误定义的基准函数
- en: Go memory management
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 内存管理
- en: Memory leaks
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存泄漏
- en: Working with eBPF
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 eBPF 一起工作
- en: The section that follows is about benchmarking Go code, which helps you determine
    what is faster and what is slower in your code—this makes it a perfect place to
    begin your search for efficiency.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分是关于基准测试 Go 代码，这有助于你确定你的代码中什么更快，什么更慢——这使得它成为开始搜索效率的完美起点。
- en: Benchmarking code
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试代码
- en: Benchmarking measures the performance of a function or a program, allowing you
    to compare different implementations and understand the performance impact of
    code changes. Using that information, you can easily reveal the part of the code
    that needs to be rewritten to improve its performance. It goes without saying
    that you should not benchmark Go code on a busy machine that is currently being
    used for other, more important, purposes unless you have a very good reason to
    do so! Otherwise, you might interfere with the benchmarking process and get inaccurate
    results, but most importantly, you might generate performance issues on the machine.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试衡量函数或程序的性能，允许你比较不同的实现，并了解代码更改对性能的影响。利用这些信息，你可以轻松地揭示需要重写以改进性能的代码部分。不言而喻，除非你有非常充分的理由，否则你不应该在正在用于其他更重要目的的繁忙机器上对
    Go 代码进行基准测试！否则，你可能会干扰基准测试过程，得到不准确的结果，更重要的是，你可能会在机器上产生性能问题。
- en: 'Most of the time, the load of the operating system plays a key role in the
    performance of your code. Let me tell you a story here: a Java utility I developed
    for a project performs lots of computations and finishes in 6,242 seconds (roughly
    1.7 hours) when running on its own. It took about a day for four instances of
    the same Java command line utility to run on the same Linux machine! If you think
    about it, running them one after the other would have been faster than running
    them at the same time!'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，操作系统的负载在代码性能中起着关键作用。让我在这里讲一个故事：我为一个项目开发的一个 Java 工具在独立运行时执行了大量的计算，耗时 6,242
    秒（大约 1.7 小时）。当四个相同的 Java 命令行工具实例在同一台 Linux 机器上运行时，大约需要一天时间！如果你这么想，一个接一个地运行它们会比同时运行它们快！
- en: Go follows certain conventions regarding benchmarking (and testing). The most
    important convention is that the name of a benchmark function must begin with
    `Benchmark`. After the `Benchmark` word, we can put an underscore or an uppercase
    letter. Therefore, both `BenchmarkFunctionName()` and `Benchmark_functionName()`
    are valid benchmark functions, whereas `Benchmarkfunctionname()` is not. By convention
    such functions are put in files that end with `_test.go`. Once the benchmarking
    is correct, the `go test` subcommand does all the dirty work for you, which includes
    scanning all `*_test.go` files for special functions, generating a proper temporary
    `main` package, calling these special functions, getting the results, and generating
    the final output.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Go 在基准测试（以及测试）方面遵循某些约定。最重要的约定是基准函数的名称必须以 `Benchmark` 开头。在 `Benchmark` 词语之后，我们可以放置一个下划线或大写字母。因此，`BenchmarkFunctionName()`
    和 `Benchmark_functionName()` 都是有效的基准函数，而 `Benchmarkfunctionname()` 则不是。按照惯例，这样的函数被放在以
    `_test.go` 结尾的文件中。一旦基准测试正确，`go test` 子命令就会为你完成所有脏活，包括扫描所有 `*_test.go` 文件中的特殊函数，生成适当的临时
    `main` 包，调用这些特殊函数，获取结果，并生成最终输出。
- en: Benchmark functions use `testing.B` variables, whereas testing functions use
    `testing.T` variables. It is easy to remember.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 基准函数使用 `testing.B` 变量，而测试函数使用 `testing.T` 变量。这很容易记住。
- en: Starting from Go 1.17, we can shuffle the execution order of both tests and
    benchmarks with the help of the `shuffle` parameter (`go test -shuffle=on`). The
    `shuffle` parameter accepts a value (which is the seed for the random number generator)
    and can be useful when you want to replay an execution order. Its default value
    is off. **The logic behind this capability is that, sometimes, the order in which
    tests and benchmarks are executed affects their results**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Go 1.17 开始，我们可以使用 `shuffle` 参数（`go test -shuffle=on`）帮助打乱测试和基准的执行顺序。`shuffle`
    参数接受一个值（这是随机数生成器的种子），当你想重新播放执行顺序时很有用。它的默认值是关闭。**这个功能背后的逻辑是，有时测试和基准的执行顺序会影响它们的结果**。
- en: The next subsection presents a simple benchmarking scenario where we try to
    optimize slice initializations.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节展示了一个简单的基准测试场景，我们尝试优化切片初始化。
- en: A simple benchmark scenario
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的基准测试场景
- en: 'We begin by presenting a scenario that tests the performance of two functions
    that do the same thing but with a different implementation. We want to be able
    to initialize slices with consecutive values that start from 0 and go up to a
    predefined value. So, given a slice named `mySlice`, `mySlice[0]` is going to
    have the value of `0`, `mySlice[1]` is going to have the value of `1`, and so
    on. The relevant code can be found inside `ch14/slices`, which contains two files
    named `initialize.go` and `initialize_test.go`. The Go code of `initialize.go`
    is presented in two parts. The first part is the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先展示一个测试两个函数性能的场景，这两个函数执行相同的事情，但实现方式不同。我们希望能够初始化具有连续值的切片，从 0 开始，到预定义的值。所以，给定一个名为
    `mySlice` 的切片，`mySlice[0]` 将具有 `0` 的值，`mySlice[1]` 将具有 `1` 的值，以此类推。相关代码可以在 `ch14/slices`
    中找到，其中包含两个名为 `initialize.go` 和 `initialize_test.go` 的文件。`initialize.go` 的 Go 代码分为两部分。第一部分如下：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the previous code, we see the implementation of the desired functionality
    that uses `make()` to pre-allocate the desired memory space.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们看到使用 `make()` 预分配所需内存空间的所需功能实现。
- en: 'The second part of `initialize.go` is the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`initialize.go` 的第二部分如下：'
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In `InitSliceAppend()`, we see a different implementation of the desired functionality
    that starts with an empty slice and uses multiple `append()` calls to populate
    it. The purpose of the `main()` function is to naively test the functionality
    of `InitSliceNew()` and `InitSliceAppend()`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `InitSliceAppend()` 中，我们看到一个不同的实现，它从一个空切片开始，并使用多个 `append()` 调用来填充它。`main()`
    函数的目的是天真地测试 `InitSliceNew()` 和 `InitSliceAppend()` 的功能。
- en: 'The implementation of the benchmarking functions is found in `initialize_test.go`
    and is the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试函数的实现位于 `initialize_test.go` 中，如下所示：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we have two benchmarking functions that benchmark `InitSliceNew()` and
    `InitSliceAppend()`. The global parameter `t` is used to prevent Go from optimizing
    the `for` loops by preventing the return values of `InitSliceNew()` and `InitSliceAppend()`
    from being ignored.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个基准测试函数，分别基准测试 `InitSliceNew()` 和 `InitSliceAppend()`。全局参数 `t` 用于防止
    Go 通过忽略 `InitSliceNew()` 和 `InitSliceAppend()` 的返回值来优化 `for` 循环。
- en: Keep in mind that the benchmarking process takes place inside the `for` loop.
    This means that, when needed, we can declare new variables, open network connections,
    and so on, outside that `for` loop.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，基准测试过程发生在 `for` 循环内部。这意味着，当需要时，我们可以在 `for` 循环外部声明新变量、打开网络连接等。
- en: 'And now some important information regarding benchmarking: **each benchmark
    function is executed for at least one second by default**—this duration also includes
    the execution time of the functions that are called by a benchmark function. If
    the benchmark function returns in a time that is less than one second, the value
    of `b.N` is increased, and the function runs again as many times in total as the
    value of `b.N`. The first time the value of `b.N` is 1, then it becomes 2, then
    5, then 10, then 20, then 50, and so on. This happens because the faster the function,
    the more times Go needs to run it to get accurate results.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有一些关于基准测试的重要信息：**默认情况下，每个基准函数至少执行一秒钟**——这个持续时间也包括由基准函数调用的函数的执行时间。如果基准函数在不到一秒的时间内返回，`b.N`
    的值会增加，并且该函数将再次以 `b.N` 的总次数运行。当 `b.N` 的值为 1 时，它变为 2，然后是 5，然后是 10，然后是 20，然后是 50，以此类推。这是因为函数越快，Go
    需要运行它的次数就越多，以获得准确的结果。
- en: 'Benchmarking the code on a macOS M1 Max laptop produces the following kind
    of output—your output might vary:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS M1 Max 笔记本上对代码进行基准测试会产生以下类型的输出——你的输出可能会有所不同：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There are two important points here. First, the value of the `-bench` parameter
    specifies the benchmark functions that are going to be executed. The `.` value
    used is a regular expression that matches all valid benchmark functions. The second
    point is that if you omit the `-bench` parameter, no benchmark function is going
    to be executed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个重要的点。首先，`-bench` 参数的值指定了将要执行的基准测试函数。使用的 `.` 值是一个正则表达式，它匹配所有有效的基准测试函数。第二个要点是，如果你省略了
    `-bench` 参数，则不会执行任何基准测试函数。
- en: The generated output shows that `InitSliceNew()` is faster than `InitSliceAppend()`
    because `InitSliceNew()` was executed `255704` times, each time taking `79712
    ns`, whereas `InitSliceAppend()` was executed `86847` times, each time taking
    `143459 ns`. This makes perfect sense as `InitSliceAppend()` needs to allocate
    memory all the time—this means that both the length and the capacity of the slice
    change, whereas `InitSliceNew()` allocates the prerequisite memory once and for
    all.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的输出显示 `InitSliceNew()` 比较快，因为 `InitSliceNew()` 执行了 `255704` 次，每次耗时 `79712
    ns`，而 `InitSliceAppend()` 执行了 `86847` 次，每次耗时 `143459 ns`。这完全合理，因为 `InitSliceAppend()`
    需要不断分配内存——这意味着切片的长度和容量都会改变，而 `InitSliceNew()` 只分配一次必要的内存。
- en: Understanding how `append()` works is going to help you make sense of the results.
    If the underlying array has sufficient capacity, then the length of the resulting
    slice is increased by the number of elements appended and its capacity remains
    the same. This means that there are no new memory allocations. However, if the
    underlying array does not have sufficient capacity, a new array is created, which
    means that a new memory space is allocated, with a larger capacity. After that,
    the slice is updated to reference the new array, and its length and capacity are
    adjusted accordingly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 理解`append()`函数的工作原理将有助于你理解结果。如果底层数组有足够的容量，那么结果切片的长度将增加附加元素的数量，但其容量保持不变。这意味着没有新的内存分配。然而，如果底层数组没有足够的容量，将创建一个新的数组，这意味着将分配新的内存空间，具有更大的容量。之后，切片被更新以引用新的数组，并相应地调整其长度和容量。
- en: The subsection that follows shows a benchmarking technique that allows us to
    reduce the number of allocations.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个小节展示了允许我们减少分配数量的基准测试技术。
- en: Benchmarking the number of memory allocations
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基准测试内存分配的数量
- en: In this second benchmarking scenario, we are going to deal with a performance
    issue that has to do with the number of memory allocations that take place during
    the operation of a function. We present two versions of the same program to illustrate
    the differences between the slow version and the improved ones. All the relevant
    code can be found in two directories inside `ch14/alloc` named `base` and `improved`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第二个基准测试场景中，我们将处理与函数操作期间发生的内存分配数量有关的一个性能问题。我们展示了同一程序的两种版本，以说明慢速版本和改进版本之间的差异。所有相关代码都可以在`ch14/alloc`目录下的两个目录中找到，分别命名为`base`和`improved`。
- en: Initial version
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始版本
- en: 'The purpose of the function that is being benchmarked is to write a message
    to a buffer. This version contains no optimizations. The code of this first version
    is found in `ch14/alloc/base`, which contains two Go source code files. The first
    one is named `allocate.go` and comes with the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 被基准测试的函数的目的是将消息写入缓冲区。这个版本没有进行优化。这个第一版本的代码位于`ch14/alloc/base`，其中包含两个Go源代码文件。第一个文件名为`allocate.go`，包含以下代码：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `writeMessage()` function just writes the given message in a new buffer
    (`bytes.Buffer`). As we are only concerned about its performance, we do not deal
    with error handling.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`writeMessage()`函数只是将给定的消息写入一个新的缓冲区（`bytes.Buffer`）。因为我们只关心其性能，所以我们不处理错误处理。'
- en: 'The second file, which is called `allocate_test.go`, contains benchmarks and
    comes with the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个文件，名为`allocate_test.go`，包含基准测试代码，包含以下代码：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Benchmarking the code using the `-benchmem` command line flag, which also displays
    memory allocations, produces the following kind of output:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有`-benchmem`命令行标志的基准测试代码，它还会显示内存分配，产生以下类型的输出：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Each execution of the benchmarking function requires 50 memory allocations.
    This means that there is room for improvement regarding the number of memory allocations
    that are taking place. We are going to try to reduce them in the subsection that
    follows.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每次执行基准测试函数都需要50次内存分配。这意味着在内存分配的数量上还有改进的空间。我们将在下一个小节中尝试减少它们。
- en: Improving the number of memory allocations
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提高内存分配的数量
- en: In this subsection, we present three different functions that all implement
    the writing of a message to a buffer. However, this time, the buffer is given
    as a function parameter instead of being initialized internally.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们介绍了三个不同的函数，它们都实现了将消息写入缓冲区的功能。然而，这次，缓冲区作为函数参数给出，而不是内部初始化。
- en: 'The code of the improved version is found in `ch14/alloc/improved` and contains
    two Go source code files. The first one is named `improve.go` and contains the
    following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 改进版本的代码位于`ch14/alloc/improved`，包含两个Go源代码文件。第一个文件名为`improve.go`，包含以下代码：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: What we have here are three functions that all implement the writing of a message
    to a buffer. However, `writeMessageBuffer()` passes the buffer by value, whereas
    `writeMessageBufferPointer()` passes a pointer to the buffer variable. Lastly,
    `writeMessageBufferWriter()` uses an `io.Writer` interface variable, which also
    supports `bytes.Buffer` variables.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有三个函数，它们都实现了将消息写入缓冲区的功能。然而，`writeMessageBuffer()`通过值传递缓冲区，而`writeMessageBufferPointer()`传递缓冲区变量的指针。最后，`writeMessageBufferWriter()`使用`io.Writer`接口变量，它也支持`bytes.Buffer`变量。
- en: 'The second file is named `improve_test.go` and is going to be presented in
    three parts. The first part comes with the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个文件命名为 `improve_test.go`，将分三部分进行展示。第一部分包含以下代码：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is the benchmarking function for `writeMessageBuffer()`. The buffer is
    allocated only once and is being used in all benchmarks by passing it to the relevant
    function.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `writeMessageBuffer()` 的基准测试函数。缓冲区只分配一次，并通过传递给相关函数在所有基准测试中使用。
- en: 'The second part is the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分如下：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is the benchmarking function for `writeMessageBufferPointer()`. Once again,
    the used buffer is allocated only once and is being shared by all benchmarks.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `writeMessageBufferPointer()` 的基准测试函数。再次强调，所使用的缓冲区只分配一次，并在所有基准测试中共享。
- en: 'The last part of `improve_test.go` contains the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`improve_test.go` 文件的最后一部分包含以下代码：'
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we see the use of `buffer.Reset()` in the two benchmarking functions.
    The purpose of the `buffer.Reset()` function is to reset the buffer so it has
    no content. The `buffer.Reset()` function has the same results as `buffer.Truncate(0)`.
    `Truncate(n)` discards all but the first `n` unread bytes from the buffer. We
    use `buffer.Reset()` thinking it might improve performance. However, this remains
    to be seen.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到在两个基准测试函数中使用了 `buffer.Reset()`。`buffer.Reset()` 函数的目的是将缓冲区重置为无内容状态。`buffer.Reset()`
    函数的结果与 `buffer.Truncate(0)` 相同。`Truncate(n)` 会丢弃缓冲区中除前 `n` 个未读字节之外的所有字节。我们使用 `buffer.Reset()`
    是因为它可能提高性能。然而，这一点还有待观察。
- en: 'Benchmarking the improved version produces the following kind of output:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对改进版本进行基准测试会产生以下类型的输出：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As presented by the results of the `BenchmarkWBuf()` benchmarking function,
    the use of a buffer as a parameter to the function does not automatically speed
    up the process, even if we share the same buffer during benchmarking. However,
    this is not the case with the remaining benchmarks.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如 `BenchmarkWBuf()` 基准测试函数的结果所示，将缓冲区作为函数的参数使用并不会自动加快过程，即使我们在基准测试期间共享相同的缓冲区。然而，其他基准测试的情况并非如此。
- en: The use of a pointer to the buffer saves us from having to copy the buffer before
    passing it to the function—this explains the results of the `BenchmarkWBufPointerNoReset()`
    function where we have no additional memory allocations. However, we still need
    to use 2,120 bytes per operation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用指向缓冲区的指针可以避免在传递给函数之前复制缓冲区——这解释了 `BenchmarkWBufPointerNoReset()` 函数的结果，在该函数中没有额外的内存分配。然而，我们仍然需要每个操作使用
    2,120 字节。
- en: The output with the `-benchmem` command line parameter includes two additional
    columns. The fourth column shows the amount of memory that was allocated on average
    in each execution of the benchmark function. The fifth column shows the number
    of allocations used to allocate the memory value of the fourth column.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-benchmem` 命令行参数的输出包括两列额外的信息。第四列显示了在基准测试函数的每次执行中平均分配的内存量。第五列显示了用于分配第四列内存值的分配次数。
- en: Lastly, it turns out that resetting the buffer using `buffer.Reset()` after
    calling `writeMessageBufferPointer()` and `writeMessageBufferWriter()` speeds
    up the process. A possible explanation for that is that an empty buffer is easier
    to work with. So, when `buffer.Reset()` is used, we have both 0 memory allocations
    and 0 bytes per operation. As a result, `BenchmarkWBufPointerReset()` and `BenchmarkWBufWriterReset()`
    need 150.7 and 151.8 nanoseconds per operation, respectively, which is a huge
    speed up from the 1,056 and 337.1 nanoseconds per operation required by `BenchmarkWBuf()`
    and `BenchmarkWBufPointerNoReset()`, respectively.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，发现在使用 `writeMessageBufferPointer()` 和 `writeMessageBufferWriter()` 调用 `buffer.Reset()`
    后重置缓冲区可以加快处理速度。一个可能的解释是空缓冲区更容易处理。因此，当使用 `buffer.Reset()` 时，我们既有 0 次内存分配，也有 0 字节的操作。结果，`BenchmarkWBufPointerReset()`
    和 `BenchmarkWBufWriterReset()` 分别需要每个操作 150.7 纳秒和 151.8 纳秒，这比 `BenchmarkWBuf()`
    和 `BenchmarkWBufPointerNoReset()` 分别需要的 1,056 纳秒和 337.1 纳秒快得多。
- en: 'Using `buffer.Reset()` can be more efficient for one or a combination of the
    following reasons:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `buffer.Reset()` 可能更高效，原因可能包括以下之一：
- en: '**Reuse of allocated memory**: When you call `buffer.Reset()`, the underlying
    byte slice used by the `bytes.Buffer` is not deallocated. Instead, it is reused.
    The length of the buffer is set to zero, making the existing memory available
    for new data to be written.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分配内存的重用**：当你调用 `buffer.Reset()` 时，`bytes.Buffer` 所使用的底层字节切片不会被释放。相反，它会被重用。缓冲区的长度被设置为零，使得现有的内存可用于写入新数据。'
- en: '**Reduced allocation overhead**: Creating a new buffer involves allocating
    a new underlying byte slice. This allocation comes with overhead, including managing
    the memory, updating the memory allocator’s data structures, and possibly invoking
    the garbage collector.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少分配开销**：创建一个新的缓冲区涉及到分配一个新的底层字节切片。这种分配伴随着开销，包括管理内存、更新内存分配器的数据结构，以及可能调用垃圾收集器。'
- en: '**Avoiding garbage collection**: Creating and discarding many small buffers
    can lead to increased pressure on the Garbage Collector, especially in scenarios
    with high-frequency buffer creation. By reusing the buffer with `Reset()`, you
    reduce the number of short-lived objects, potentially reducing the impact on garbage
    collection.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免垃圾收集**：创建和丢弃许多小缓冲区可能导致垃圾收集器压力增加，尤其是在高频缓冲区创建的场景中。通过使用`Reset()`重用缓冲区，你可以减少短期存在的对象数量，从而可能减少对垃圾收集器的影响。'
- en: The subject of the next section is benchmarking buffered writing.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节的主题是基准测试缓冲写入。
- en: Buffered versus unbuffered file I/O
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓冲与非缓冲文件I/O
- en: In this section, we are going to compare buffered and unbuffered operations
    while reading and writing files.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将比较读写文件时的缓冲和非缓冲操作。
- en: In this section, we are going to test whether the size of the buffer plays a
    key role in the performance of write operations. The relevant code can be found
    in `ch14/io`. Apart from the relevant files, the directory includes a `testdata`
    directory, which was first seen in *Chapter 13*, *Fuzz Testing and Observability*,
    and is used for storing data related to the testing process.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将测试缓冲区的大小是否在写操作的性能中扮演关键角色。相关的代码可以在`ch14/io`中找到。除了相关文件外，该目录还包括一个`testdata`目录，它首次出现在第13章，*模糊测试和可观察性*中，用于存储与测试过程相关的数据。
- en: 'The code of `table.go` is not presented here—feel free to look at it. The code
    of `table_test.go` is the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`table.go`的代码在此处未展示——请随意查看。`table_test.go`的代码如下：'
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The reason for storing the return value of `Create()` in a variable named `err`
    and using another global variable named `ERR` afterward is tricky. We want to
    prevent the compiler from doing any optimizations that might exclude the function
    that we want to measure from being executed because its results are never used.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Create()`的返回值存储在名为`err`的变量中，并在之后使用另一个名为`ERR`的全局变量，这个做法很巧妙。我们希望防止编译器执行任何可能排除我们想要测量的函数执行的优化，因为其结果从未被使用。
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Neither the signature nor the name of `benchmarkCreate()` makes it a benchmark
    function. This is a helper function that allows you to call `Create()`, which
    creates a new file on disk; its implementation can be found in `table.go`, with
    the proper parameters. Its implementation is valid, and it can be used by benchmark
    functions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`benchmarkCreate()`的签名或名称都没有使其成为一个基准函数。这是一个辅助函数，允许你调用`Create()`，该函数在磁盘上创建一个新文件；其实现可以在`table.go`中找到，带有适当的参数。其实现是有效的，并且可以被基准函数使用。'
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: These are three correctly defined benchmark functions that all call `benchmarkCreate()`.
    Benchmark functions require a single `*testing.B` variable and return no values.
    In this case, the numbers at the end of the function name indicate the size of
    the buffer.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是三个正确定义的基准函数，它们都调用了`benchmarkCreate()`。基准函数需要一个`*testing.B`变量，并且不返回任何值。在这种情况下，函数名末尾的数字表示缓冲区的大小。
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is the code that defines the array structures that are going to be used
    in the table tests. This saves us from having to implement (3x3=) 9 separate benchmark
    functions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是定义将要用于表格测试的数组结构的代码。这使我们免于实现（3x3=）9个单独的基准函数。
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `b.Run()` method, which allows you to run one or more sub-benchmarks within
    a benchmark function, accepts two parameters. First, the name of the sub-benchmark,
    which is displayed on the screen, and second, the function that implements the
    sub-benchmark. This is an efficient way to run multiple benchmarks with the use
    of table tests and know their parameters. Just remember to define a proper name
    for each sub-benchmark because this is going to be displayed on the screen.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`b.Run()`方法允许你在基准函数内运行一个或多个子基准测试，它接受两个参数。首先，子基准测试的名称，它将在屏幕上显示，其次，实现子基准测试的函数。这是使用表格测试运行多个基准测试并了解其参数的有效方式。只需记住为每个子基准测试定义一个合适的名称，因为这将显示在屏幕上。'
- en: 'Running the benchmarks generates the next output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 运行基准测试会生成以下输出：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The previous three lines are the results of the `BenchmarkBuffer4Create()`,
    `BenchmarkBuffer8Create()`, and `BenchmarkBuffer16Create()` benchmark functions,
    respectively, and indicate their performance.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 前三行分别是 `BenchmarkBuffer4Create()`、`BenchmarkBuffer8Create()` 和 `BenchmarkBuffer16Create()`
    基准测试函数的结果，并显示了它们的性能。
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The previous results are from the table tests with the 9 sub-benchmarks.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的结果来自表格测试的 9 个子基准测试。
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So, what does this output tell us? First, the `-10` at the end of each benchmark
    function signifies the number of goroutines used for its execution, which is essentially
    the value of the `GOMAXPROCS` environment variable. Similarly, you can see the
    values of `GOOS` and `GOARCH`, which show the operating system and the architecture
    of the machine in the generated output. The second column in the output displays
    the number of times that the relevant function was executed. Faster functions
    are executed more times than slower functions. As an example, `BenchmarkBuffer4Create()`
    was executed `382740` times, while `BenchmarkBuffer16Create()` was executed `491230`
    times because it is faster! The third column in the output shows the average time
    of each run and is measured in nanoseconds per benchmark function execution (`ns/op`).
    The higher the value of the third column, the slower the benchmark function is.
    **A large value in the third column is an indication that a function might need
    to be optimized**.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个输出告诉我们什么呢？首先，每个基准测试函数末尾的 `-10` 表示用于其执行的 goroutine 数量，这实际上是 `GOMAXPROCS`
    环境变量的值。同样，你还可以看到 `GOOS` 和 `GOARCH` 的值，它们显示了在生成的输出中机器的操作系统和架构。输出中的第二列显示了相关函数执行的次数。执行速度较快的函数比执行速度较慢的函数执行次数更多。例如，`BenchmarkBuffer4Create()`
    执行了 `382740` 次，而 `BenchmarkBuffer16Create()` 执行了 `491230` 次，因为它更快！输出中的第三列显示了每次运行的平均时间，并以每基准测试函数执行纳秒（`ns/op`）为单位进行衡量。第三列的值越高，基准测试函数就越慢。**第三列的值较大表明该函数可能需要优化**。
- en: So far, we have learned how to create benchmark functions to test the performance
    of our own functions to better understand potential bottlenecks that might need
    to be optimized. You might ask, how often do we need to create benchmark functions?
    The answer is simple. When something runs slower than needed and/or when you want
    to choose between two or more implementations.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何创建基准测试函数来测试我们自己的函数的性能，以便更好地理解可能需要优化的潜在瓶颈。你可能会问，我们需要多久创建一次基准测试函数？答案是简单的。当某些东西运行得比预期慢，或者当你想要在两种或多种实现之间进行选择时。
- en: The next subsection shows how to compare benchmark results.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将展示如何比较基准测试结果。
- en: The benchstat utility
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`benchstat` 工具'
- en: Now imagine that you have benchmarking data, and you want to compare it with
    the results that were produced in another computer or with a different configuration.
    The `benchstat` utility can help you here. The utility can be found in the `https://pkg.go.dev/golang.org/x/perf/cmd/benchstat`
    package and can be downloaded using `go install golang.org/x/perf/cmd/benchstat@latest`.
    Go puts all binary files in `~/go/bin`, and `benchstat` is no exception to that
    rule.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，你有一些基准测试数据，并且想要将其与另一台计算机或不同配置产生的结果进行比较。`benchstat` 工具在这里可以帮助你。该工具位于 `https://pkg.go.dev/golang.org/x/perf/cmd/benchstat`
    包中，可以使用 `go install golang.org/x/perf/cmd/benchstat@latest` 命令下载。Go 将所有二进制文件放在
    `~/go/bin` 目录下，`benchstat` 也不例外。
- en: The `benchstat` utility replaces the `benchcmp` utility, which can be found
    at [https://pkg.go.dev/golang.org/x/tools/cmd/benchcmp](https://pkg.go.dev/golang.org/x/tools/cmd/benchcmp).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`benchstat` 工具取代了 `benchcmp` 工具，后者可以在 [https://pkg.go.dev/golang.org/x/tools/cmd/benchcmp](https://pkg.go.dev/golang.org/x/tools/cmd/benchcmp)
    找到。'
- en: 'So, imagine that we have two benchmark results for `table_test.go` saved in
    `r1.txt` and `r2.txt`—you should remove all lines from the `go test` output that
    do not contain benchmarking results, which leaves all lines that begin with `Benchmark`.
    You can use `benchstat` as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，想象一下，我们有两个针对 `table_test.go` 的基准测试结果保存在 `r1.txt` 和 `r2.txt` 中——你应该删除 `go
    test` 输出中所有不包含基准测试结果的行，这样就会留下所有以 `Benchmark` 开头的行。你可以这样使用 `benchstat`：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can save the results from benchmarks by simply redirecting the generated
    output into a file. For example, you can run `go test -bench=. > output.txt`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将生成的输出重定向到文件来保存基准测试的结果。例如，你可以运行 `go test -bench=. > output.txt`。
- en: If the value of the last column is `~`, as it happens to be here, it means that
    there was no significant change in the results. The previous output shows no differences
    between the two results. Discussing more about `benchstat` is beyond the scope
    of the book. Type `benchstat -h` to learn more about the supported parameters.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最后一列的值是 `~`，就像这里发生的情况一样，这意味着结果没有发生显著变化。之前的输出显示两个结果之间没有差异。关于 `benchstat` 的更多讨论超出了本书的范围。输入
    `benchstat -h` 以了解支持的参数。
- en: The next section touches on a sensitive subject, which is incorrectly defined
    benchmark functions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分涉及到一个敏感的主题，即错误定义的基准函数。
- en: Wrongly defined benchmark functions
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误定义的基准函数
- en: 'You should be very careful when defining benchmark functions because you might
    define them incorrectly. Look at the Go code of the following benchmark function:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义基准函数时，你应该非常小心，因为你可能会错误地定义它们。看看以下基准函数的 Go 代码：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `BenchmarkFibo()` function has a valid name and the correct signature.
    The bad news is that this benchmark function is logically wrong and is not going
    to produce any results. The reason for this is that as the `b.N` value grows in
    the way described earlier, the runtime of the benchmark function also increases
    because of the `for` loop. This fact prevents `BenchmarkFiboI()` from converging
    to a stable number, which prevents the function from completing and, therefore,
    returning any results. For analogous reasons, the next benchmark function is also
    wrongly implemented:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`BenchmarkFibo()` 函数具有有效的名称和正确的签名。坏消息是，这个基准函数在逻辑上是错误的，并且不会产生任何结果。原因是，正如之前描述的那样，随着
    `b.N` 值的增长，基准函数的运行时间也会因为 `for` 循环而增加。这个事实阻止了 `BenchmarkFiboI()` 收敛到一个稳定的数字，从而阻止了函数完成，因此没有返回任何结果。出于类似的原因，下一个基准函数也是错误实现的：'
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'On the other hand, there is nothing wrong with the implementation of the following
    two benchmark functions:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，以下两个基准函数的实现并没有什么问题：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Correct benchmark functions are a tool for identifying bottlenecks in your code
    that you should put in your own projects, especially when working with file I/O
    or CPU-intensive operations—as I am writing this, I have been waiting three days
    for a Python program to finish its operation to test the performance of the brute-force
    method of a mathematical algorithm.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的基准函数是识别你代码中瓶颈的工具，你应该将其放入自己的项目中，尤其是在处理文件 I/O 或 CPU 密集型操作时——正如我写这篇文章时，我已经等待了三天，等待一个
    Python 程序完成其操作以测试一个数学算法的暴力方法的性能。
- en: Enough with benchmarking. The next section discusses the Go way of working with
    memory.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试就到这里。下一个部分将讨论 Go 处理内存的方式。
- en: Go memory management
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 内存管理
- en: 'The subject of this section is Go memory management. We are going to begin
    by stating a fact that you should already be familiar with: Go sacrifices visibility
    and total control over memory management for the sake of simplicity and the use
    of the **Garbage Collector** (**GC**). Although the GC operation introduces an
    overhead to the speed of a program, it saves us from having to manually deal with
    memory, which is a huge advantage and saves us from lots of bugs.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的主题是 Go 内存管理。我们将首先陈述一个你应该已经熟悉的事实：Go 为了简单性和使用 **垃圾回收器**（**GC**）而牺牲了内存管理的可见性和完全控制。尽管
    GC 操作会给程序的速度带来开销，但它使我们免于手动处理内存，这是一个巨大的优势，并使我们免于许多错误。
- en: 'There exist two types of allocations that take place during program execution:
    *dynamic allocations* and *automatic allocations*. Automatic allocations are the
    allocations whose lifespan can be inferred by the compiler before the program
    starts its execution. For example, all local variables, the return arguments of
    functions, and function arguments have a given lifespan, which means that they
    can be automatically allocated by the compiler. All other allocations are performed
    dynamically, which also includes data that must be available outside the scope
    of a function.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序执行过程中存在两种类型的内存分配：*动态分配*和*自动分配*。自动分配是指编译器在程序开始执行之前可以推断其生命周期的分配。例如，所有局部变量、函数的返回参数和函数参数都有确定的生存期，这意味着它们可以被编译器自动分配。所有其他分配都是动态进行的，这包括必须在函数作用域之外可用的数据。
- en: We continue our discussion on Go memory management by talking about the heap
    and the stack because this is where most of the allocations take place.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续讨论 Go 的内存管理，通过介绍堆和栈来展开，因为大多数的内存分配都发生在这里。
- en: Heap and stack
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆和栈
- en: The *heap* is the place where programming languages store global variables—the
    heap is where garbage collection takes place. The *stack* is the place where programming
    languages store temporary variables used by functions—each function has its own
    stack. As goroutines are located in user space, the Go runtime is responsible
    for the rules that govern their operation. Additionally, **each goroutine has
    its own stack,** whereas the heap is “shared” among goroutines.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*堆*是编程语言存储全局变量的地方——堆是垃圾回收发生的地方。*栈*是编程语言存储函数使用的临时变量的地方——每个函数都有自己的栈。由于goroutines位于用户空间，Go运行时负责管理它们的操作规则。此外，**每个goroutine都有自己的栈**，而堆是“共享”的。'
- en: Dynamic allocations take place in the heap, whereas automatic allocations are
    stored in the stack. The Go compiler performs a process that is called *escape
    analysis* to find out whether a memory needs to be allocated at the heap or should
    stay within the stack.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分配发生在堆上，而自动分配存储在栈上。Go编译器执行一个称为*逃逸分析*的过程，以确定是否需要在堆上分配内存或者应该保持在栈上。
- en: In C++, when you create new variables using the `new` operator, you know that
    these variables are going to the heap. This is not the case with Go and the use
    of `new()` and `make()` functions. In Go, the compiler decides where a new variable
    is going to be placed based on its size and the result of escape analysis. This
    is the reason that we can return pointers to local variables from Go functions.
    Although we have not seen `new()` in this book frequently, keep in mind that `new()`
    returns pointers to initialized memory.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，当你使用`new`运算符创建新变量时，你知道这些变量将进入堆。在Go和`new()`、`make()`函数的使用中并非如此。在Go中，编译器根据变量的大小和逃逸分析的结果来决定新变量将被放置的位置。这也是为什么我们可以从Go函数中返回局部变量的指针。尽管我们在这本书中没有频繁地看到`new()`，但请记住，`new()`返回指向初始化内存的指针。
- en: If you want to know where the variables of a program are allocated by Go, you
    can use the `-m` `gc` flag with `go run`. This is illustrated in `allocate.go`—this
    is a regular program that needs no modifications in order to display the extra
    output as all details are handled by Go.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道Go程序中的变量在哪里分配，你可以使用`go run`的`-m` `gc`标志。这在`allocate.go`中得到了说明——这是一个常规程序，无需修改即可显示额外的输出，因为所有细节都由Go处理。
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Running `allocate.go` generates the next output—the output is a result of the
    use of `-gcflags '-m'`, which modifies the generated executable. You should not
    create executable binaries that go to production with the use of `-gcflags` flags.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`allocate.go`生成下一个输出——这个输出是使用`-gcflags '-m'`的结果，它修改了生成的可执行文件。你不应该使用`-gcflags`标志创建用于生产的可执行二进制文件。
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `t escapes to heap` message means that `t` escapes the function. Put simply,
    it means that `t` is used outside of the function and does not have a local scope
    (because it is passed outside the function). However, this does not necessarily
    mean that the variable has moved to the heap. On other occasions, you can see
    the message `moved to heap`. This message shows that the compiler decided to move
    a variable to the heap because it might be used outside of the function. The `does
    not escape` message indicates that the relevant argument does not escape to the
    heap.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`t escapes to heap`这条消息的意思是`t`逃出了函数。简单来说，这意味着`t`在函数外部被使用，并且没有局部作用域（因为它被传递出了函数）。然而，这并不一定意味着变量已经移动到了堆上。在其他情况下，你可能会看到“moved
    to heap”的消息。这条消息表明编译器决定将一个变量移动到堆上，因为它可能在函数外部被使用。`does not escape`这条消息表示相关的参数没有逃逸到堆上。'
- en: Ideally, we should write our algorithms in order to use the stack instead of
    the heap, but this is impossible as stacks cannot allocate too-large objects and
    cannot store variables that live longer than a function. So, it is up to the Go
    compiler to decide.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们应该编写算法以使用栈而不是堆，但这是不可能的，因为栈不能分配太大的对象，也不能存储比函数生命周期更长的变量。所以，这取决于Go编译器来决定。
- en: The last two lines of the output consist of the output generated by the two
    `fmt.Println()` statements.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后两行是由两个`fmt.Println()`语句生成的输出。
- en: 'If you want to get a more detailed output, you can use `-m` twice:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想得到更详细的输出，可以使用`-m`两次：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Although more detailed, I find this output too crowded. Usually, using `-m`
    just once reveals what is happening behind the scenes regarding the program heap
    and stack.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然信息更详细，但我发现这个输出太拥挤了。通常，使用`-m`一次就能揭示程序堆和栈背后的情况。
- en: What you should remember is that the heap is where the largest amounts of memory
    are usually stored. In practice, this means that **measuring the heap size is
    usually enough for understanding and counting the memory usage of a Go process**.
    As a result, the Go GC spends most of its time working with the heap, which means
    the heap is the first element to be analyzed when we want to optimize the memory
    usage of a program.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该记住的是，堆通常是存储最大内存量的地方。在实践中，这意味着**测量堆大小通常足以理解和计算Go进程的内存使用情况**。因此，Go垃圾回收器的大部分时间都用于处理堆，这意味着当我们想要优化程序的内存使用时，堆是首先要分析的部分。
- en: The next subsection discusses the main elements of the Go memory model.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个小节将讨论Go内存模型的主要元素。
- en: The main elements of the Go memory model
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go内存模型的主要元素
- en: In this section, we are going to discuss the main elements of the Go memory
    model in order to have a better understanding of what is happening behind the
    scenes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论Go内存模型的主要元素，以便更好地理解幕后发生的事情。
- en: 'The Go memory model works with the following main elements:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Go内存模型与以下主要元素一起工作：
- en: '**Program code**: Program code is memory mapped by the OS when the process
    is about to run, so Go has no control over that part. This kind of data is read-only.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**程序代码**：当进程即将运行时，操作系统会将程序代码进行内存映射，因此Go无法控制这部分。这类数据是只读的。'
- en: '**Global data**: Global data is also memory mapped by the OS in read-only status.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局数据**：全局数据也被操作系统以只读状态进行内存映射。'
- en: '**Uninitialized data**: Uninitialized data is stored in anonymous pages by
    the OS. By uninitialized data, we mean data such as the global variables of a
    package. Although we might not know their values before the program starts, we
    know that we are going to need to allocate memory for them when the program starts
    its execution. This kind of memory space is allocated once and is never freed.
    So, the GC has no control over it.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未初始化的数据**：未初始化的数据由操作系统存储在匿名页面中。我们所说的未初始化数据，指的是包的全局变量等数据。尽管在程序开始之前我们可能不知道它们的值，但我们知道程序开始执行时我们需要为它们分配内存。这种内存空间一旦分配就不再释放。因此，垃圾回收器无法控制这部分内存。'
- en: '**Heap**: As discussed earlier in this chapter, this is the heap used for dynamic
    allocations.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆**：如本章前面所述，这是用于动态分配的堆。'
- en: '**Stacks**: These are the stacks used for automatic allocations.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**栈**：这些是用于自动分配的栈。'
- en: You do not need to know all the gory details of all these components of the
    Go memory model. What you need to remember is that problems arise when we either
    purposely or unintentionally put objects into the heap without letting the GC
    release them and, therefore, free their respective memory space. We are going
    to see cases related to memory leaks that have to do with slices and maps in a
    while.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要了解Go内存模型所有这些组件的详细信息。你需要记住的是，当我们有意或无意地将对象放入堆中而不让垃圾回收器释放它们，从而不释放它们各自的内存空间时，就会产生问题。我们将在稍后看到与切片和映射相关的内存泄漏案例。
- en: There also exists an internal Go component that performs memory allocations
    called the *Go allocator*. It can dynamically allocate memory blocks in order
    for Go objects to work properly and it is optimized to prevent memory fragmentation
    and locking. The Go allocator is implemented and maintained by the Go team and,
    as such, its operation details can change.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 还存在一个名为*Go分配器*的内部Go组件，用于执行内存分配。它可以为Go对象动态分配内存块，以使Go对象能够正常工作，并且它被优化以防止内存碎片化和锁定。Go分配器由Go团队实现和维护，因此其操作细节可能会发生变化。
- en: The next section discusses memory leaks, which have to do with not properly
    freeing memory space.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将讨论与未正确释放内存空间有关的内存泄漏。
- en: Memory leaks
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存泄漏
- en: In the subsections that follow, we are going to talk about **memory leaks in
    slices and maps**. A *memory leak* happens when a memory space is allocated without
    being completely freed afterward.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，我们将讨论**切片和映射中的内存泄漏**。当分配内存后没有完全释放时，就会发生内存泄漏。
- en: We are going to begin with memory leaks caused by wrongly used slices.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从由错误使用切片引起的内存泄漏开始。
- en: Slices and memory leaks
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片和内存泄漏
- en: In this subsection, we are going to showcase code that uses slices and produces
    memory leaks and then illustrate a way to avoid such memory leaks. One common
    scenario for memory leaks with slices involves holding a reference to a larger
    underlying array even after the slice is no longer needed. This prevents the GC
    from reclaiming the memory associated with the array.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将展示使用切片并产生内存泄漏的代码，然后说明避免此类内存泄漏的方法。切片内存泄漏的一个常见场景是在切片不再需要时仍然持有对较大底层数组的引用。这阻止GC回收与数组相关的内存。
- en: 'The code in `slicesLeaks.go` is the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`slicesLeaks.go`中的代码如下：'
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `createSlice()` function creates a slice with a large underlying array,
    which means that it requires lots of memory. The `getValue()` function takes the
    first five elements of its input slice and returns those elements as a slice.
    However, it does that while referencing the original input slice, which means
    that that input slice cannot be freed by the GC. Yes, this is a problem!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`createSlice()`函数创建了一个具有大型底层数组的切片，这意味着它需要大量的内存。`getValue()`函数取其输入切片的前五个元素，并将这些元素作为切片返回。然而，它这样做的同时还引用了原始输入切片，这意味着该输入切片不能被GC释放。是的，这是一个问题！'
- en: 'Running `slicesLeaks.go` with some extra command line arguments produces the
    following output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一些额外的命令行参数运行`slicesLeaks.go`会产生以下输出：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The output indicates that there is a leaking parameter. A *leaking parameter*
    means that this function somehow keeps its parameter alive after it returns—this
    is where the memory leak takes place. However, this does not mean it is being
    moved to the stack, as most *leaking parameters* are allocated on the heap.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表明存在泄漏参数。*泄漏参数*意味着这个函数在返回后以某种方式保持了其参数的存活状态——这就是内存泄漏发生的地方。然而，这并不意味着它被移动到栈上，因为大多数*泄漏参数*都是在堆上分配的。
- en: 'An improved version of `slicesLeaks.go` can be found in `slicesNoLeaks.go`.
    The only difference is in the implementation of the `getValue()` function:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`slicesNoLeaks.go`中`getValue()`函数的实现是`createSlice()`函数的一个改进版本：'
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This time we create a copy of the slice part that we want to return, which means
    that the function no longer references the initial slice. As a result, the GC
    is going to be allowed to free its memory.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们创建了要返回的切片部分的副本，这意味着函数不再引用初始切片。因此，GC将被允许释放其内存。
- en: 'Running `slicesNoLeaks.go` produces the following output:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`slicesNoLeaks.go`会产生以下输出：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: So, we get no message about leaking parameters, which means that the issue has
    been resolved.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们没有收到关于泄漏参数的消息，这意味着问题已经解决。
- en: Next, we are going to discuss memory leaks and maps.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论内存泄漏和映射。
- en: Maps and memory leaks
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射和内存泄漏
- en: 'This subsection is about memory leaks introduced by maps as illustrated in
    `mapsLeaks.go`. The code in `mapsLeaks.go` is the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节讨论由映射（maps）引入的内存泄漏，如`mapsLeaks.go`所示。`mapsLeaks.go`中的代码如下：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `printAlloc()` is a helper function for printing information about the memory,
    whereas the `runtime.KeepAlive(m)` statement keeps a reference to `m` so that
    the map is not garbage collected.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`printAlloc()`是一个用于打印内存信息的辅助函数，而`runtime.KeepAlive(m)`语句保持对`m`的引用，这样映射就不会被垃圾回收。'
- en: 'Running `mapsLeaks.go` produces the following output:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`mapsLeaks.go`会产生以下输出：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `make(map[int][128]byte)` statement allocates 111 KB of memory only. However,
    when we populate the map, it allocates 927,931 KB of memory. After that, we delete
    all the elements of the map, and we somehow expect the used memory to shrink.
    However, the empty map requires 600,767 KB of memory! The reason for that is that
    by design the number of buckets in a map cannot shrink. As a result, when we remove
    all maps elements, we do not reduce the number of existing buckets; we just zero
    the slots in the buckets.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`make(map[int][128]byte)`语句仅分配了111 KB的内存。然而，当我们填充映射时，它分配了927,931 KB的内存。之后，我们删除映射的所有元素，并期望使用的内存会缩小。然而，空映射需要600,767
    KB的内存！这是因为按设计，映射中的桶（buckets）数量不能缩小。因此，当我们删除所有映射元素时，我们并没有减少现有桶的数量；我们只是将桶中的槽位清零。'
- en: However, using `m = nil` allows the GC to free the memory that was previously
    occupied by `m` and now only 119 KB of memory are allocated. As a result, giving
    `nil` values to unused objects is a good practice.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用`m = nil`允许GC释放之前由`m`占用的内存，现在只分配了119 KB的内存。因此，将`nil`值赋予未使用的对象是一种良好的实践。
- en: Lastly, we are going to present a technique that can reduce memory allocations.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将介绍一种可以减少内存分配的技术。
- en: Memory pre-allocation
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存预分配
- en: '*Memory pre-allocation* refers to the act of reserving memory space for data
    structures before they are needed. Although pre-allocating memory is not a panacea,
    it can be beneficial in certain situations to avoid frequent memory allocations
    and deallocations, which can lead to improved performance and reduced memory fragmentation.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存预分配**是指在数据结构需要之前为其预留内存空间的行为。尽管预分配内存不是万能的，但在某些情况下，它可以避免频繁的内存分配和释放，从而提高性能并减少内存碎片。'
- en: It is essential to consider pre-allocation when you have a good estimate of
    the required capacity or size, you expect a significant number of insertions or
    appends, or when you want to reduce memory reallocations and improve performance.
    However, pre-allocation makes more sense when dealing with large amounts of data.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对所需的容量或大小有良好的估计，你预计会有大量的插入或追加操作，或者当你想要减少内存重新分配并提高性能时，考虑预分配是很重要的。然而，当处理大量数据时，预分配更有意义。
- en: 'The implementation of the `main()` function of `preallocate.go` is presented
    in two parts. The first part comes with the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`preallocate.go` 中 `main()` 函数的实现分为两部分。第一部分包含以下代码：'
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this example, the `make()` function is used to create a slice with a length
    of 0 and a capacity of 100\. This pre-allocates memory for the slice, and as elements
    are appended, the slice can grow without the need for repeated reallocation, which
    slows down the process.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，使用 `make()` 函数创建了一个长度为 0、容量为 100 的切片。这为切片预先分配了内存，当元素被追加时，切片可以增长而不需要重复重新分配，这可以加快处理速度。
- en: 'The second part is the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分如下：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As before, by providing an initial capacity, we reduce the chances of the map
    being resized frequently as elements are added, leading to more efficient memory
    usage.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，通过提供初始容量，我们减少了在元素添加时频繁调整映射大小的可能性，从而提高了内存使用效率。
- en: The next section discusses the use of eBPF from Go—as **eBPF is available on
    Linux only**, the presented code can be executed on Linux machines only.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将讨论从 Go 语言中使用 eBPF 的方法——因为**eBPF 仅在 Linux 系统上可用**，所以提供的代码只能在 Linux 机器上执行。
- en: Working with eBPF
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 eBPF
- en: BPF stands for Berkeley Packet Filter and eBPF for Extended BPF. BPF was introduced
    back in 1992 to improve the performance of packet capture tools. Back in 2013,
    Alexei Starovoitov did a major rewrite of BPF that was included in the Linux kernel
    in 2014 and replaced BPF. With this rewrite, BPF, which is now called eBPF, became
    more versatile and can be used for a variety of tasks other than network packet
    capture.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: BPF 代表伯克利包过滤器，而 eBPF 代表扩展 BPF。BPF 最初于 1992 年推出，旨在提高数据包捕获工具的性能。2013 年，Alexei
    Starovoitov 对 BPF 进行了重大重写，该重写于 2014 年被包含在 Linux 内核中，并取代了 BPF。通过这次重写，现在被称为 eBPF
    的 BPF 变得更加灵活，可以用于除网络数据包捕获之外的各种任务。
- en: eBPF software can be programmed in BCC, `bpftrace`, or using LLVM. The LLVM
    compiler can compile BPF programs into BPF bytecode using a supported programming
    language such as C or the LLVM intermediate representation. As both ways are difficult
    to program because of the use of low-level code, using BCC or `bpftrace` makes
    things simpler for the developer.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: eBPF 软件可以用 BCC、`bpftrace` 或使用 LLVM 编程。LLVM 编译器可以使用支持的编程语言（如 C 或 LLVM 中间表示）将
    BPF 程序编译成 BPF 字节码。由于两种方式都因为使用了低级代码而难以编程，因此使用 BCC 或 `bpftrace` 可以使开发人员的工作更加简单。
- en: What is eBPF?
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 eBPF？
- en: 'It is really difficult to describe precisely what eBPF can do because it has
    so many capabilities. It is much easier to describe how we can use eBPF. eBPF
    can be used in three main areas: networking, security, and observability. This
    section focuses on the observability capabilities (tracing) of eBPF.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 eBPF 具有众多功能，很难精确描述它能够做什么。相比之下，描述我们如何使用 eBPF 要容易得多。eBPF 可以用于三个主要领域：网络、安全和可观察性。本节重点介绍
    eBPF 的可观察性功能（跟踪）。
- en: You can consider eBPF as a virtual machine located inside the Linux kernel that
    can execute eBPF commands, which is custom BPF code. So, eBPF makes the Linux
    kernel programmable to help you solve real-world problems. Keep in mind that eBPF
    (as well as all programming languages) does not solve problems on its own. eBPF
    just gives you the tools to solve your problems! eBPF programs are executed by
    the Linux kernel eBPF runtime.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 eBPF 视为位于 Linux 内核内部的虚拟机，它可以执行 eBPF 命令，即定制的 BPF 代码。因此，eBPF 使得 Linux 内核可编程，帮助你解决实际问题。请注意，eBPF（以及所有编程语言）本身并不能解决问题。eBPF
    只提供了解决问题的工具！eBPF 程序由 Linux 内核的 eBPF 运行时执行。
- en: 'In more detail, the key features and aspects of eBPF include the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细地说，eBPF 的关键特性和方面包括以下内容：
- en: '**Programmability**: eBPF allows users to write and load small programs into
    the kernel, which can be attached to various hooks or entry points within the
    kernel code. These programs run in a restricted virtual machine environment, ensuring
    safety and security.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可编程性**：eBPF 允许用户将小型程序写入并加载到内核中，这些程序可以附加到内核代码中的各种钩子或入口点。这些程序在受限的虚拟机环境中运行，确保安全性和安全性。'
- en: '**In-kernel execution**: eBPF programs are executed within the kernel in a
    secure way, making it possible to perform efficient and low-overhead operations
    directly in kernel space.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内核内执行**：eBPF 程序以安全的方式在内核中执行，使得直接在内核空间执行高效且开销低的操作成为可能。'
- en: '**Dynamic attach points**: eBPF programs can be attached to various hooks or
    attach points in the kernel, allowing developers to extend and customize kernel
    behavior dynamically. Examples include networking, tracing, and security-related
    hooks.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态附加点**：eBPF 程序可以附加到内核中的各种钩子或附加点，允许开发者动态地扩展和自定义内核行为。例如，包括网络、跟踪和安全相关的钩子。'
- en: '**Observability and tracing**: eBPF is widely used for observability and tracing
    purposes as it allows developers to instrument the kernel to gather insights into
    system behavior, performance, and interactions. Tools like `bpftrace` and `perf`
    use eBPF to provide advanced tracing capabilities.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可观察性和跟踪**：eBPF 因其允许开发者对内核进行仪器化以收集有关系统行为、性能和交互的见解而被广泛用于可观察性和跟踪目的。像 `bpftrace`
    和 `perf` 这样的工具使用 eBPF 提供高级跟踪功能。'
- en: '**Networking**: eBPF is extensively used in networking for tasks such as packet
    filtering, traffic monitoring, and load balancing. It enables the creation of
    efficient and customizable networking solutions without requiring modifications
    to the kernel.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络**：eBPF 在网络中被广泛用于诸如数据包过滤、流量监控和负载均衡等任务。它使得创建高效且可定制的网络解决方案成为可能，而无需修改内核。'
- en: '**Performance analysis**: eBPF provides a powerful framework for performance
    analysis and profiling. It allows developers and administrators to collect detailed
    information about system performance without significant overhead.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能分析**：eBPF 提供了一个强大的性能分析和分析框架。它允许开发者和管理员收集有关系统性能的详细信息，而不会产生显著的开销。'
- en: The main advantage of eBPF compared to traditional performance tools is that
    it is efficient, production-safe, and part of the Linux kernel. In practice, this
    means that we can use eBPF without the need to add or load any other components
    to the Linux kernel.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统性能工具相比，eBPF 的主要优势在于其高效性、生产安全性以及它是 Linux 内核的一部分。在实践中，这意味着我们可以使用 eBPF 而无需向
    Linux 内核添加或加载任何其他组件。
- en: About observability and eBPF
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于可观察性和 eBPF
- en: Most Linux applications are executed in user space, which is a layer without
    too many privileges. Although using user space is safer and more secure, it has
    restrictions and requires using system calls to ask the kernel for access to privileged
    resources. Even the simplest commands use a large amount of system calls when
    executed. In practice, this means that if we are able to observe the system calls
    of our applications, we can learn more information about the way they behave and
    operate.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Linux 应用程序都在用户空间执行，这是一个没有太多特权的层。尽管使用用户空间更安全、更安全，但它有限制，需要使用系统调用来请求内核访问特权资源。即使是简单的命令在执行时也会使用大量的系统调用。在实践中，这意味着如果我们能够观察我们应用程序的系统调用，我们可以更多地了解它们的行为和操作方式。
- en: When things operate as expected and the performance of our applications is good,
    we usually do not care much about performance and the executed system calls. But
    when things go wrong, we desperately need to understand more about the operation
    of our applications. Putting special code in the Linux kernel or developing a
    module in order to understand the operation of our applications is a difficult
    task that might require a long period of time. This is where observability and
    eBPF come into play. eBPF, its language, and its tools allow us to dynamically
    see what happens behind the scenes without the need to change the entire Linux
    operating system.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当事情按预期运行且我们应用程序的性能良好时，我们通常不太关心性能和执行的系统调用。但当事情出错时，我们迫切需要了解更多关于我们应用程序的操作。在 Linux
    内核中放置特殊代码或开发模块以了解我们应用程序的操作是一项困难的任务，可能需要很长时间。这就是可观察性和 eBPF 发挥作用的地方。eBPF、其语言及其工具允许我们动态地看到幕后发生的事情，而无需更改整个
    Linux 操作系统。
- en: All you need to communicate with eBPF is a programming language that supports
    `libbpf` ([https://github.com/libbpf/libbpf](https://github.com/libbpf/libbpf)).
    Apart from C, Go also offers support for the `libbpf` library ([https://github.com/aquasecurity/libbpfgo](https://github.com/aquasecurity/libbpfgo)).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 与 eBPF 通信你所需要的一切是一个支持 `libbpf` 的编程语言（[https://github.com/libbpf/libbpf](https://github.com/libbpf/libbpf)）。除了
    C 语言之外，Go 还提供了对 `libbpf` 库的支持（[https://github.com/aquasecurity/libbpfgo](https://github.com/aquasecurity/libbpfgo)）。
- en: The next subsection shows how to create an eBPF tool in Go.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子部分将展示如何在 Go 中创建一个 eBPF 工具。
- en: Creating an eBPF tool in Go
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Go 中创建 eBPF 工具
- en: As `gobpf` is an external Go package and the fact that, by default, all recent
    Go versions use modules, all source code should be put somewhere under `~/go/src`.
    The presented utility records the user ID of each user by tracing the `getuid(2)`
    system call and keeps a count for each user ID.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `gobpf` 是一个外部 Go 包，并且默认情况下，所有最新的 Go 版本都使用模块，所有源代码都应该放在 `~/go/src` 下的某个位置。所提供的工具通过跟踪
    `getuid(2)` 系统调用来记录每个用户的用户 ID，并为每个用户 ID 记录计数。
- en: 'The code of the `uid.go` utility is going to be presented in four parts. The
    first part comes with the following code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`uid.go` 工具的代码将被分为四个部分进行展示。第一部分包含以下代码：'
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you are familiar with the C programming language, you should recognize that
    the `source` variable **holds C code**—this is the code that communicates with
    the Linux kernel to get the desired information. However, this code is called
    from a Go program.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 C 编程语言，你应该能认出 `source` 变量 **包含 C 代码**——这是与 Linux 内核通信以获取所需信息的代码。然而，这段代码是从
    Go 程序中调用的。
- en: 'The second part of the utility is the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 工具的第二部分如下：
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this second part, we define a command line argument named `pid` and initialize
    a new eBPF module named `m`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的第二部分，我们定义了一个名为 `pid` 的命令行参数，并初始化了一个名为 `m` 的新 eBPF 模块。
- en: 'The third part of the utility contains the following code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 工具的第三部分包含以下代码：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `m.LoadUprobe("count")` statement loads the `count()` function. The handling
    of the probe is initiated with the `m.AttachUprobe()` call. The `AttachUprobe()`
    method says that we want to trace the `getuid(2)` system call using `Uprobe`.
    The `bpf.NewTable()` statement is what gives us access to the `counts` hash defined
    in the C code. Remember that the eBPF program is written in C code that is held
    in a `string` variable.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`m.LoadUprobe("count")` 语句加载了 `count()` 函数。通过 `m.AttachUprobe()` 调用启动了对探针的处理。`AttachUprobe()`
    方法表示我们想要使用 `Uprobe` 跟踪 `getuid(2)` 系统调用。`bpf.NewTable()` 语句使我们能够访问在 C 代码中定义的 `counts`
    哈希表。记住，eBPF 程序是用 C 代码编写的，这些代码存储在一个 `string` 变量中。'
- en: 'The last part of the utility contains the following code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 工具的最后部分包含以下代码：
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The previous code uses channels and UNIX signal handling to block the program.
    Once *Ctrl* + *C* is pressed, the `sig` channel unblocks the program and prints
    the desired information with the help of the `table` variable. As the data in
    the `table` variable is in the binary format, we need to decode it using two `binary.LittleEndian.Uint64()`
    calls.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用了通道和 UNIX 信号处理来阻塞程序。一旦按下 *Ctrl* + *C*，`sig` 通道将解除对程序的阻塞，并借助 `table` 变量打印所需的信息。由于
    `table` 变量中的数据是二进制格式，我们需要使用两个 `binary.LittleEndian.Uint64()` 调用来解码它。
- en: In order to execute the program, you need a C compiler and the BPF libraries
    to be installed, which depends on your Linux variant. Please refer to your Linux
    variant documentation for instructions on how to install eBPF. If you have any
    issues running the program, ask in relevant forums.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行程序，你需要安装 C 编译器和 BPF 库，这取决于你的 Linux 变体。请参考你的 Linux 变体文档了解如何安装 eBPF 的说明。如果你在运行程序时遇到任何问题，请在相关论坛中提问。
- en: 'Running `uid.go` creates the following kind of output:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `uid.go` 将生成以下类型的输出：
- en: '[PRE39]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You can use the code in `uid.go` as a template when writing your own eBPF utilities
    in Go.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `uid.go` 中的代码用作模板，在编写自己的 Go eBPF 工具时使用。
- en: The section that follows discusses the `rand.Seed()` function and why it is
    not necessary to use it, starting from Go version 1.20.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将讨论 `rand.Seed()` 函数以及为什么从 Go 版本 1.20 开始不需要使用它。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter of the book, we presented various advanced Go topics related
    to benchmarking, performance, and efficiency. Remember that benchmark results
    can be influenced by various factors such as hardware, compiler optimizations,
    and workload. It is important to **interpret the results carefully and rationally**
    while considering the specific conditions under which the benchmarks are run.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一章中，我们介绍了与基准测试、性能和效率相关的各种高级Go语言主题。请记住，基准测试结果可能会受到各种因素的影响，例如硬件、编译器优化和工作负载。在考虑基准测试运行的具体条件时，**仔细和理性地解释结果**是很重要的。
- en: In this chapter, we learned that Go has automatic memory management, which means
    that the language runtime takes care of memory allocation and deallocation for
    you. The primary components of Go’s memory management are garbage collection,
    automatic memory allocation, and a runtime scheduler.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们了解到Go具有自动内存管理，这意味着语言运行时为您处理内存分配和释放。Go内存管理的主要组件是垃圾回收、自动内存分配和运行时调度器。
- en: This chapter also presented a very powerful technology, eBPF. If you are using
    Linux machines, then you should definitely learn more about eBPF and how to use
    it with Go. The eBPF framework has gained popularity due to its versatility and
    the ability to address a wide range of use cases within the Linux kernel. When
    working with eBPF, you should first think like a system administrator, not as
    a programmer. Put simply, start by trying the existing eBPF tools instead of writing
    your own. However, if you have an actual issue that cannot be solved by existing
    eBPF tools, then you might need to start acting like a developer.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还介绍了一种非常强大的技术，即eBPF。如果你在使用Linux机器，那么你绝对应该更多地了解eBPF以及如何使用Go来使用它。由于其多功能性和在Linux内核中解决广泛用例的能力，eBPF框架已经获得了流行。当与eBPF一起工作时，你应该首先像系统管理员那样思考，而不是像程序员那样。简单来说，先尝试现有的eBPF工具，而不是编写自己的。然而，如果你有一个现有eBPF工具无法解决的问题，那么你可能需要开始像开发者一样行事。
- en: The next chapter is about Go 1.21 and Go 1.22 and the changes they introduced.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍Go 1.21和Go 1.22以及它们引入的变化。
- en: Exercises
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Try to do the following exercises:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下练习：
- en: Create three different implementations of a function that copies binary files
    and benchmark them to find the faster one. Can you explain why this function is
    faster?
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建三种不同的函数实现，用于复制二进制文件，并对它们进行基准测试以找到最快的版本。你能解释为什么这个函数更快吗？
- en: Write a version of `BenchmarkWBufWriterReset()` that does not use `buffer.Reset()`
    and see how fast it performs.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个不使用`buffer.Reset()`的`BenchmarkWBufWriterReset()`版本，并看看它的性能如何。
- en: 'This is a really difficult task: Create a machine learning library in Go. Keep
    in mind that, behind the scenes, ML uses statistics and matrix operations.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个非常困难的任务：在Go中创建一个机器学习库。请记住，在幕后，机器学习使用统计和矩阵运算。
- en: Additional resources
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'gobpf: [https://github.com/iovisor/gobpf](https://github.com/iovisor/gobpf)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'gobpf: [https://github.com/iovisor/gobpf](https://github.com/iovisor/gobpf)'
- en: 'The smallest Go binary: [https://totallygamerjet.hashnode.dev/the-smallest-go-binary-5kb](https://totallygamerjet.hashnode.dev/the-smallest-go-binary-5kb
    )'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '最小的Go二进制文件: [https://totallygamerjet.hashnode.dev/the-smallest-go-binary-5kb](https://totallygamerjet.hashnode.dev/the-smallest-go-binary-5kb)'
- en: 'Working with Go execution traces (gotraceui): [https://gotraceui.dev/](https://gotraceui.dev/)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用Go执行跟踪（gotraceui）: [https://gotraceui.dev/](https://gotraceui.dev/)'
- en: 'How to troubleshoot memory leaks in Go with Grafana Pyroscope: [https://grafana.com/blog/2023/04/19/how-to-troubleshoot-memory-leaks-in-go-with-grafana-pyroscope/](https://grafana.com/blog/2023/04/19/how-to-troubleshoot-memory-leaks-in-go-with-grafana-pyroscope/)'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如何使用Grafana Pyroscope在Go中调试内存泄漏: [https://grafana.com/blog/2023/04/19/how-to-troubleshoot-memory-leaks-in-go-with-grafana-pyroscope/](https://grafana.com/blog/2023/04/19/how-to-troubleshoot-memory-leaks-in-go-with-grafana-pyroscope/)'
- en: '*A few bytes here, a few there, pretty soon you’re talking real memory*: [https://dave.cheney.net/2021/01/05/a-few-bytes-here-a-few-there-pretty-soon-youre-talking-real-memory](https://dave.cheney.net/2021/01/05/a-few-bytes-here-a-few-there-pretty-soon-youre-talking-real-memory)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*这里几字节，那里几字节，很快你就在谈论真正的内存了*：[https://dave.cheney.net/2021/01/05/a-few-bytes-here-a-few-there-pretty-soon-youre-talking-real-memory](https://dave.cheney.net/2021/01/05/a-few-bytes-here-a-few-there-pretty-soon-youre-talking-real-memory)'
- en: Join our community on Discord
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间，与作者和其他读者进行讨论：
- en: '[https://discord.gg/FzuQbc8zd6](https://discord.gg/FzuQbc8zd6 )'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[加入我们的Discord服务器](https://discord.gg/FzuQbc8zd6)'
- en: '[![](img/QR_Code2286825896190168453.png)](https://discord.gg/FzuQbc8zd6 )'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](img/QR_Code2286825896190168453.png)](https://discord.gg/FzuQbc8zd6 )'
