<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer215">
<h1 class="chapterTitle" id="_idParaDest-420"><span class="koboSpan" id="kobo.1.1">Appendix</span></h1>
<h1 class="chapterTitle" id="_idParaDest-421"><span class="koboSpan" id="kobo.2.1">The Go Garbage Collector</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">The subject of this appendix is the operation of the Go </span><strong class="keyWord"><span class="koboSpan" id="kobo.4.1">Garbage Collector</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.6.1">GC</span></strong><span class="koboSpan" id="kobo.7.1">). </span><span class="koboSpan" id="kobo.7.2">It is important to note that the details and performance characteristics of the GC may evolve with each new Go release.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.8.1">Developers generally do not need to interact directly with the GC, as </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.9.1">it operates automatically in the background in its own goroutine</span></strong><span class="koboSpan" id="kobo.10.1">. </span><span class="koboSpan" id="kobo.10.2">However, understanding its behavior can be beneficial for optimizing memory usage and avoiding common pitfalls related to memory management. </span><span class="koboSpan" id="kobo.10.3">For the most up-to-date and detailed information, it is recommended to refer to the official Go documentation and release notes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.11.1">First, let us discuss garbage collection in general. </span><span class="koboSpan" id="kobo.11.2">Following that, we will dig deeper into the nuances of the Go GC.</span></p>
<h1 class="heading-1" id="_idParaDest-422"><span class="koboSpan" id="kobo.12.1">Garbage collection</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.13.1">Garbage collection is the process of</span><a id="_idIndexMarker1297"/><span class="koboSpan" id="kobo.14.1"> freeing up memory space that is not being used. </span><span class="koboSpan" id="kobo.14.2">In other words, the GC sees which objects are out of scope and cannot be referenced anymore and frees the memory space they consume. </span><span class="koboSpan" id="kobo.14.3">This process happens in a concurrent way while a Go program is running and not before or after the execution of the program. </span><span class="koboSpan" id="kobo.14.4">The documentation of the Go GC implementation states the following:</span></p>
<blockquote class="packt_quote">
<p class="quote"><span class="koboSpan" id="kobo.15.1">”The GC runs concurrently with mutator threads, is type accurate (also known as precise), allows multiple GC threads to run in parallel. </span><span class="koboSpan" id="kobo.15.2">It is a concurrent mark and sweep that uses a write barrier. </span><span class="koboSpan" id="kobo.15.3">It is non-generational and non-compacting. </span><span class="koboSpan" id="kobo.15.4">Allocation is done using size segregated per P allocation areas to minimize fragmentation while eliminating locks in the common case.”</span></p>
</blockquote>
<h1 class="heading-1" id="_idParaDest-423"><span class="koboSpan" id="kobo.16.1">The key characteristics of the Go GC</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.17.1">The key characteristics of the Go </span><a id="_idIndexMarker1298"/><span class="koboSpan" id="kobo.18.1">garbage collector are the following:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.19.1">Concurrent and parallel</span></strong><span class="koboSpan" id="kobo.20.1">: The Go GC operates concurrently with the execution of Go programs. </span><span class="koboSpan" id="kobo.20.2">It runs concurrently with the application’s threads, meaning that the GC can perform its work without stopping the application that is being executed. </span><span class="koboSpan" id="kobo.20.3">Additionally, certain phases of the GC can be parallelized to take advantage of multiple CPU cores and modern CPUs.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.21.1">Generational collector</span></strong><span class="koboSpan" id="kobo.22.1">: The Go GC uses a generational garbage collection strategy, dividing objects into two generations: young and old. </span><span class="koboSpan" id="kobo.22.2">Most objects are allocated to the young generation, and most garbage collection work is focused there. </span><span class="koboSpan" id="kobo.22.3">The old generation contains longer-lived objects, which are less likely to get garbage collected.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.23.1">Tri-color mark and sweep algorithm</span></strong><span class="koboSpan" id="kobo.24.1">: The Go GC uses a tri-color mark-and-sweep algorithm. </span><span class="koboSpan" id="kobo.24.2">This algorithm uses three colors (white, gray, and black) to track the state of objects during the marking phase. </span><span class="koboSpan" id="kobo.24.3">White objects are not yet visited, gray objects are in the process of being visited, and black objects have been visited.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.25.1">Write barrier</span></strong><span class="koboSpan" id="kobo.26.1">: Go uses a write barrier to keep track of pointers that are updated in the heap in order to maintain consistency during garbage collection. </span><span class="koboSpan" id="kobo.26.2">The write barrier ensures that the GC is aware of changes to pointers, allowing it to trace object dependencies accurately.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.27.1">Garbage collection triggers</span></strong><span class="koboSpan" id="kobo.28.1">: The Go GC is triggered based on memory allocation and heap size. </span><span class="koboSpan" id="kobo.28.2">When the allocated memory reaches a certain threshold or the heap size grows beyond a specified limit, the GC is triggered to reclaim unused memory.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.29.1">Manual control</span></strong><span class="koboSpan" id="kobo.30.1">: While the GC is designed to be automatic and transparent to developers, there are ways to provide hints and control certain aspects of the garbage collection process. </span><span class="koboSpan" id="kobo.30.2">For example, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.31.1">runtime.GC()</span></code><span class="koboSpan" id="kobo.32.1"> function can be used to request an explicit garbage collection cycle.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.33.1">We are going to revisit most of the characteristics of the GC in a while.</span></p>
<h1 class="heading-1" id="_idParaDest-424"><span class="koboSpan" id="kobo.34.1">Learning more about the Go GC</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.35.1">The Go standard library offers functions that</span><a id="_idIndexMarker1299"/><span class="koboSpan" id="kobo.36.1"> allow you to study the operation of the GC and learn more about what the GC covertly does. </span><span class="koboSpan" id="kobo.36.2">These functions are illustrated in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.37.1">gColl.go</span></code><span class="koboSpan" id="kobo.38.1"> utility. </span><span class="koboSpan" id="kobo.38.2">The source code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.39.1">gColl.go</span></code><span class="koboSpan" id="kobo.40.1"> is presented here in chunks.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.41.1">package</span></span><span class="koboSpan" id="kobo.42.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.43.1">import</span></span><span class="koboSpan" id="kobo.44.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.45.1">"fmt"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.46.1">"runtime"</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.47.1">"time"</span></span><span class="koboSpan" id="kobo.48.1">
)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.49.1">We need the </span><code class="inlineCode"><span class="koboSpan" id="kobo.50.1">runtime</span></code><span class="koboSpan" id="kobo.51.1"> package because it allows us to get information about the Go runtime system, which among other things includes information about the operation of the GC. </span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.52.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.53.1">printStats</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.54.1">(mem runtime.MemStats)</span></span><span class="koboSpan" id="kobo.55.1"> {
    runtime.ReadMemStats(&amp;mem)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.56.1">"mem.Alloc:"</span></span><span class="koboSpan" id="kobo.57.1">, mem.Alloc)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.58.1">"mem.TotalAlloc:"</span></span><span class="koboSpan" id="kobo.59.1">, mem.TotalAlloc)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.60.1">"mem.HeapAlloc:"</span></span><span class="koboSpan" id="kobo.61.1">, mem.HeapAlloc)
    fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.62.1">"mem.NumGC:"</span></span><span class="koboSpan" id="kobo.63.1">, mem.NumGC, </span><span class="hljs-string"><span class="koboSpan" id="kobo.64.1">"\n"</span></span><span class="koboSpan" id="kobo.65.1">)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.66.1">The main purpose of </span><code class="inlineCode"><span class="koboSpan" id="kobo.67.1">printStats()</span></code><span class="koboSpan" id="kobo.68.1"> is to avoid writing the same Go code multiple times. </span><span class="koboSpan" id="kobo.68.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.69.1">runtime.ReadMemStats()</span></code><span class="koboSpan" id="kobo.70.1"> call gets the latest garbage collection statistics for you.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.71.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.72.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.73.1">()</span></span><span class="koboSpan" id="kobo.74.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.75.1">var</span></span><span class="koboSpan" id="kobo.76.1"> mem runtime.MemStats
    printStats(mem)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.77.1">for</span></span><span class="koboSpan" id="kobo.78.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.79.1">0</span></span><span class="koboSpan" id="kobo.80.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.81.1">10</span></span><span class="koboSpan" id="kobo.82.1">; i++ {
        s := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.83.1">make</span></span><span class="koboSpan" id="kobo.84.1">([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.85.1">byte</span></span><span class="koboSpan" id="kobo.86.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.87.1">50000000</span></span><span class="koboSpan" id="kobo.88.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.89.1">if</span></span><span class="koboSpan" id="kobo.90.1"> s == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.91.1">nil</span></span><span class="koboSpan" id="kobo.92.1"> {
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.93.1">"Operation failed!"</span></span><span class="koboSpan" id="kobo.94.1">)
        }
    }
    printStats(mem)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.95.1">In this part, we have a for loop that creates 10 byte slices with 50,000,000 bytes each. </span><span class="koboSpan" id="kobo.95.2">The reason for this is that by allocating large amounts of memory, we can trigger the GC.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.96.1">for</span></span><span class="koboSpan" id="kobo.97.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.98.1">0</span></span><span class="koboSpan" id="kobo.99.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.100.1">10</span></span><span class="koboSpan" id="kobo.101.1">; i++ {
        s := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.102.1">make</span></span><span class="koboSpan" id="kobo.103.1">([]</span><span class="hljs-type"><span class="koboSpan" id="kobo.104.1">byte</span></span><span class="koboSpan" id="kobo.105.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.106.1">100000000</span></span><span class="koboSpan" id="kobo.107.1">)
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.108.1">if</span></span><span class="koboSpan" id="kobo.109.1"> s == </span><span class="hljs-literal"><span class="koboSpan" id="kobo.110.1">nil</span></span><span class="koboSpan" id="kobo.111.1"> {
            fmt.Println(</span><span class="hljs-string"><span class="koboSpan" id="kobo.112.1">"Operation failed!"</span></span><span class="koboSpan" id="kobo.113.1">)
        }
        time.Sleep(</span><span class="hljs-number"><span class="koboSpan" id="kobo.114.1">5</span></span><span class="koboSpan" id="kobo.115.1"> * time.Second)
    }
    printStats(mem)
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.116.1">The last part of the program makes even bigger memory allocations—this time, each byte slice has 100,000,000 bytes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.117.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.118.1">gColl.go</span></code><span class="koboSpan" id="kobo.119.1"> on a macOS</span><a id="_idIndexMarker1300"/><span class="koboSpan" id="kobo.120.1"> Sonoma machine with 32 GB of RAM produces the following kind of output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.121.1">$ </span></span><span class="koboSpan" id="kobo.122.1">go run gColl.go
mem.Alloc: 114960
mem.TotalAlloc: 114960
mem.HeapAlloc: 114960
mem.NumGC: 0
mem.Alloc: 50123152
mem.TotalAlloc: 500163016
mem.HeapAlloc: 50123152
mem.NumGC: 9
mem.Alloc: 121472
mem.TotalAlloc: 1500246248
mem.HeapAlloc: 121472
mem.NumGC: 20
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.123.1">The value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.124.1">mem.Alloc</span></code><span class="koboSpan" id="kobo.125.1"> is the bytes of allocated heap objects—all the objects that the GC has not yet freed. </span><code class="inlineCode"><span class="koboSpan" id="kobo.126.1">mem.TotalAlloc</span></code><span class="koboSpan" id="kobo.127.1"> shows the cumulative bytes allocated for heap objects—this number does not decrease when objects are freed, which means that it keeps increasing. </span><span class="koboSpan" id="kobo.127.2">Therefore, it shows the total number of bytes allocated for heap objects during program execution. </span><code class="inlineCode"><span class="koboSpan" id="kobo.128.1">mem.HeapAlloc</span></code><span class="koboSpan" id="kobo.129.1"> is the same as </span><code class="inlineCode"><span class="koboSpan" id="kobo.130.1">mem.Alloc</span></code><span class="koboSpan" id="kobo.131.1">. </span><span class="koboSpan" id="kobo.131.2">Last, </span><code class="inlineCode"><span class="koboSpan" id="kobo.132.1">mem.NumGC</span></code> <strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.133.1">shows the total number of completed garbage collection cycles</span></strong><span class="koboSpan" id="kobo.134.1">. </span><span class="koboSpan" id="kobo.134.2">The bigger that value is, the more you have to consider how you allocate memory in your code and if there is a way to optimize that.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.135.1">If you want even more verbose output about the operation of the GC, you can combine </span><code class="inlineCode"><span class="koboSpan" id="kobo.136.1">go run</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.137.1">gColl.go</span></code><span class="koboSpan" id="kobo.138.1"> with </span><code class="inlineCode"><span class="koboSpan" id="kobo.139.1">GODEBUG=gctrace=1</span></code><span class="koboSpan" id="kobo.140.1">. </span><span class="koboSpan" id="kobo.140.2">Apart from the regular program output, you get some extra metrics—this is illustrated in the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.141.1">$ </span></span><span class="koboSpan" id="kobo.142.1">GODEBUG=gctrace=1 go run gColl.go
gc 1 @0.004s 2%: 0.008+0.34+0.042 ms clock, 0.081+0.063/0.51/0.18+0.42 ms cpu, 3-&gt;3-&gt;0 MB, 4 MB goal, 0 MB stacks, 0 MB globals, 10 P
gc 2 @0.009s 3%: 0.097+0.93+0.049 ms clock, 0.97+0.20/1.0/0.84+0.49 ms cpu, 3-&gt;3-&gt;1 MB, 4 MB goal, 0 MB stacks, 0 MB globals, 10 P
.
</span><span class="koboSpan" id="kobo.142.2">.
</span><span class="koboSpan" id="kobo.142.3">.
</span><span class="koboSpan" id="kobo.142.4">gc 18 @35.101s 0%: 0.13+0.15+0.009 ms clock, 1.3+0/0.22/0.007+0.095 ms cpu, 95-&gt;95-&gt;0 MB, 95 MB goal, 0 MB stacks, 0 MB globals, 10 P
gc 19 @40.107s 0%: 0.091+0.38+0.011 ms clock, 0.91+0/0.54/0+0.11 ms cpu, 95-&gt;95-&gt;0 MB, 95 MB goal, 0 MB stacks, 0 MB globals, 10 P
gc 20 @45.111s 0%: 0.095+0.26+0.009 ms clock, 0.95+0/0.38/0+0.092 ms cpu, 95-&gt;95-&gt;0 MB, 95 MB goal, 0 MB stacks, 0 MB globals, 10 P
mem.Alloc: 121200
mem.TotalAlloc: 1500245792
mem.HeapAlloc: 121200
mem.NumGC: 20
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.143.1">As before, we have the same number of </span><a id="_idIndexMarker1301"/><span class="koboSpan" id="kobo.144.1">completed garbage collection cycles (20). </span><span class="koboSpan" id="kobo.144.2">However, we get extra information about the heap size of each cycle. </span><span class="koboSpan" id="kobo.144.3">So, for garbage collection cycle 20 (</span><code class="inlineCode"><span class="koboSpan" id="kobo.145.1">gc 20</span></code><span class="koboSpan" id="kobo.146.1">), we get the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.147.1">gc 20 @45.111s 0%: 0.095+0.26+0.009 ms clock, 0.95+0/0.38/0+0.092 ms cpu, 95-&gt;95-&gt;0 MB, 95 MB goal, 0 MB stacks, 0 MB globals, 10 P
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.148.1">Now let us explain the </span><code class="inlineCode"><span class="koboSpan" id="kobo.149.1">95-&gt;95-&gt;0</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.150.1">MB</span></code><span class="koboSpan" id="kobo.151.1"> triplet in the previous line of output. </span><span class="koboSpan" id="kobo.151.2">The first value (</span><code class="inlineCode"><span class="koboSpan" id="kobo.152.1">95</span></code><span class="koboSpan" id="kobo.153.1">) is the heap size when the GC is about to run. </span><span class="koboSpan" id="kobo.153.2">The second value (</span><code class="inlineCode"><span class="koboSpan" id="kobo.154.1">95</span></code><span class="koboSpan" id="kobo.155.1">) is the heap size when the GC ends its operation. </span><span class="koboSpan" id="kobo.155.2">The last value is the size of the live heap (</span><code class="inlineCode"><span class="koboSpan" id="kobo.156.1">0</span></code><span class="koboSpan" id="kobo.157.1">).</span></p>
<h2 class="heading-2" id="_idParaDest-425"><span class="koboSpan" id="kobo.158.1">The tri-color algorithm</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.159.1">As mentioned earlier, the operation </span><a id="_idIndexMarker1302"/><span class="koboSpan" id="kobo.160.1">of the Go GC is based on the tri-color algorithm. </span><span class="koboSpan" id="kobo.160.2">Note that the tri-color algorithm is not unique to Go and can be used in other programming languages as well.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.161.1">Strictly speaking, the official name for the algorithm used in Go is the </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.162.1">tri-color mark-and-sweep algorithm</span></strong><span class="koboSpan" id="kobo.163.1">. </span><span class="koboSpan" id="kobo.163.2">It works concurrently with the program and uses a write barrier. </span><span class="koboSpan" id="kobo.163.3">This means that while a Go program runs, the Go scheduler is responsible for the scheduling of the application as well as the GC, which also runs as a goroutine. </span><span class="koboSpan" id="kobo.163.4">This is as if the Go scheduler must deal with a regular application with multiple goroutines!</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.164.1">The core idea behind this algorithm came from Edsger W. </span><span class="koboSpan" id="kobo.164.2">Dijkstra, Leslie Lamport, A. </span><span class="koboSpan" id="kobo.164.3">J. </span><span class="koboSpan" id="kobo.164.4">Martin, C. </span><span class="koboSpan" id="kobo.164.5">S. </span><span class="koboSpan" id="kobo.164.6">Scholten, and E. </span><span class="koboSpan" id="kobo.164.7">F. </span><span class="koboSpan" id="kobo.164.8">M. </span><span class="koboSpan" id="kobo.164.9">Steffens and was first illustrated in a paper named </span><em class="italic"><span class="koboSpan" id="kobo.165.1">On-the-Fly Garbage Collection: An Exercise in Cooperation</span></em><span class="koboSpan" id="kobo.166.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.167.1">The primary principle behind the tri-color mark-and-sweep algorithm is that it divides the objects of the heap into </span><a id="_idIndexMarker1303"/><span class="koboSpan" id="kobo.168.1">three different sets according to their color, which is assigned by the algorithm and can be black, gray, or white. </span><span class="koboSpan" id="kobo.168.2">The objects in the black set are guaranteed to have no pointers to any object in the white set. </span><span class="koboSpan" id="kobo.168.3">On the other hand, an object in the white set can point to an object in the black set because this has no effect on the operation of the GC. </span><span class="koboSpan" id="kobo.168.4">The objects in the gray set might have pointers to some objects in the white set. </span><span class="koboSpan" id="kobo.168.5">Finally, the objects in the white set are the candidates for garbage collection.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.169.1">So, when the garbage collection begins, all objects are white, and the GC visits all the root objects and colors them gray. </span><span class="koboSpan" id="kobo.169.2">The roots are the objects that can be directly accessed by the application, which includes global variables and other things on the stack. </span><span class="koboSpan" id="kobo.169.3">These objects mostly depend on the Go code of a particular program.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.170.1">After that, the GC picks a gray object, makes it black, and starts looking at whether that object has pointers to other objects in the white set or not. </span><span class="koboSpan" id="kobo.170.2">Therefore, when an object in the gray set is scanned for pointers to other objects, it is colored black. </span><span class="koboSpan" id="kobo.170.3">If that scan discovers that this particular object has one or more pointers to a white object, it puts that white object in the gray set. </span><span class="koboSpan" id="kobo.170.4">This process keeps going for as long as there exist objects in the gray set. </span><span class="koboSpan" id="kobo.170.5">After that, the objects in the white set are unreachable and their memory space can be reused. </span><span class="koboSpan" id="kobo.170.6">Therefore, at this point, the elements in the white set are said to be garbage collected. </span><span class="koboSpan" id="kobo.170.7">Please note that no object can go directly from the black set to the white set, which allows the algorithm to operate and be able to clear the objects in the white set. </span><span class="koboSpan" id="kobo.170.8">As mentioned before, no object in the black set can directly point to an object in the white set. </span><span class="koboSpan" id="kobo.170.9">Additionally, if an object in the gray set becomes unreachable at some point in a garbage collection cycle, it will not be collected in that garbage collection cycle but in the next one! </span><span class="koboSpan" id="kobo.170.10">Although this is not an optimal situation, it is not that bad.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.171.1">During this process, the running</span><a id="_idIndexMarker1304"/><span class="koboSpan" id="kobo.172.1"> application is called the mutator. </span><span class="koboSpan" id="kobo.172.2">The mutator runs a small function</span><a id="_idIndexMarker1305"/><span class="koboSpan" id="kobo.173.1"> named </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.174.1">write barrier</span></strong><span class="koboSpan" id="kobo.175.1">, which is executed each time a pointer in the heap is modified. </span><span class="koboSpan" id="kobo.175.2">If the pointer of an object in the heap is modified, this means that this object is now reachable—the write barrier colors it gray and puts it in the gray set. </span><span class="koboSpan" id="kobo.175.3">The mutator is responsible for the invariant that no element of the black set has a pointer to an element of the white set. </span><span class="koboSpan" id="kobo.175.4">This is accomplished with the help of the write barrier function. </span><span class="koboSpan" id="kobo.175.5">Failing to accomplish this invariant will ruin the garbage collection process and will most likely crash your program in a pretty bad and undesirable way!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.176.1">So, to summarize, there are</span><a id="_idIndexMarker1306"/><span class="koboSpan" id="kobo.177.1"> three different colors: black, white, and gray. </span><span class="koboSpan" id="kobo.177.2">When the algorithm begins, all objects are colored white. </span><span class="koboSpan" id="kobo.177.3">As the algorithm keeps going, white objects are moved into one of the other two sets. </span><span class="koboSpan" id="kobo.177.4">The objects that are left in the white set are the ones that are going to be cleared at some point. </span><span class="koboSpan" id="kobo.177.5">The next figure displays the three color sets with objects in them.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.178.1"><img alt="A group of circles with letters and numbers  Description automatically generated" src="../Images/B21003_appA_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.179.1">Figure A.1: The Go garbage collector represents the heap of a program as a graph</span></p>
<p class="normal"><span class="koboSpan" id="kobo.180.1">While object </span><strong class="keyWord"><span class="koboSpan" id="kobo.181.1">E</span></strong><span class="koboSpan" id="kobo.182.1">, which is in the white set, can access object </span><strong class="keyWord"><span class="koboSpan" id="kobo.183.1">F</span></strong><span class="koboSpan" id="kobo.184.1">, it cannot be accessed by any other object because no other object points to object </span><strong class="keyWord"><span class="koboSpan" id="kobo.185.1">E</span></strong><span class="koboSpan" id="kobo.186.1">, which makes it a perfect candidate for garbage collection! </span><span class="koboSpan" id="kobo.186.2">Additionally, objects </span><strong class="keyWord"><span class="koboSpan" id="kobo.187.1">A</span></strong><span class="koboSpan" id="kobo.188.1">, </span><strong class="keyWord"><span class="koboSpan" id="kobo.189.1">B</span></strong><span class="koboSpan" id="kobo.190.1">, and </span><strong class="keyWord"><span class="koboSpan" id="kobo.191.1">C</span></strong><span class="koboSpan" id="kobo.192.1"> are root objects and are always reachable; therefore, they cannot be garbage collected.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.193.1">Can you guess what happens next? </span><span class="koboSpan" id="kobo.193.2">Well, the algorithm will have to process the remaining elements of the gray set, which means that both objects </span><strong class="keyWord"><span class="koboSpan" id="kobo.194.1">A</span></strong><span class="koboSpan" id="kobo.195.1"> and </span><strong class="keyWord"><span class="koboSpan" id="kobo.196.1">F</span></strong><span class="koboSpan" id="kobo.197.1"> will go to the black set. </span><span class="koboSpan" id="kobo.197.2">Object </span><strong class="keyWord"><span class="koboSpan" id="kobo.198.1">A</span></strong><span class="koboSpan" id="kobo.199.1"> goes to the black set because it is a root element and </span><strong class="keyWord"><span class="koboSpan" id="kobo.200.1">F</span></strong><span class="koboSpan" id="kobo.201.1"> goes to the black set because it does not point to any other object while it is in the gray set.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.202.1">After object </span><strong class="keyWord"><span class="koboSpan" id="kobo.203.1">E</span></strong><span class="koboSpan" id="kobo.204.1"> is garbage</span><a id="_idIndexMarker1307"/><span class="koboSpan" id="kobo.205.1"> collected, object </span><strong class="keyWord"><span class="koboSpan" id="kobo.206.1">F</span></strong><span class="koboSpan" id="kobo.207.1"> will become unreachable and will be garbage collected in the next cycle of the GC because an unreachable object cannot magically become reachable in the next iteration of the garbage collection cycle.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.208.1">Go garbage collection can also be applied to variables such as channels. </span><span class="koboSpan" id="kobo.208.2">When the GC finds out that a channel is unreachable, which is when the channel variable cannot be accessed anymore, it will free its resources even if the channel has not been closed.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.209.1">Go allows you to manually initiate garbage collection cycles by putting a </span><code class="inlineCode"><span class="koboSpan" id="kobo.210.1">runtime.GC()</span></code><span class="koboSpan" id="kobo.211.1"> statement in your Go code. </span><span class="koboSpan" id="kobo.211.2">However, keep in mind that </span><code class="inlineCode"><span class="koboSpan" id="kobo.212.1">runtime.GC()</span></code><span class="koboSpan" id="kobo.213.1"> blocks the caller and it might block the entire program, especially if you are running a very busy Go program with many objects. </span><span class="koboSpan" id="kobo.213.2">This mainly happens because you cannot perform garbage collections while everything else is rapidly changing, as this will not give the GC the opportunity to clearly identify the members of the white, black, and gray sets. </span><span class="koboSpan" id="kobo.213.3">This garbage collection status </span><a id="_idIndexMarker1308"/><span class="koboSpan" id="kobo.214.1">is also called a garbage collection safe point.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.215.1">You can find the long and relatively advanced Go code of the GC at </span><a href="https://github.com/golang/go/blob/master/src/runtime/mgc.go"><span class="url"><span class="koboSpan" id="kobo.216.1">https://github.com/golang/go/blob/master/src/runtime/mgc.go</span></span></a><span class="koboSpan" id="kobo.217.1">, which you can study if you want to learn even more information about the garbage collection operation. </span><span class="koboSpan" id="kobo.217.2">You can even make changes to that code if you are brave enough!</span></p>
<h2 class="heading-2" id="_idParaDest-426"><span class="koboSpan" id="kobo.218.1">More about the operation of the Go GC</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.219.1">This section talks more about the Go</span><a id="_idIndexMarker1309"/><span class="koboSpan" id="kobo.220.1"> GC and presents additional information about its activities. </span><span class="koboSpan" id="kobo.220.2">The main concern of the Go GC is low latency, which basically means short pauses in its operation in order to have real-time operation. </span><span class="koboSpan" id="kobo.220.3">On the other hand, what a program does is create new objects and manipulate existing objects with pointers all the time. </span><span class="koboSpan" id="kobo.220.4">This process can end up creating objects that cannot be accessed anymore because there are no pointers pointing to these objects. </span><span class="koboSpan" id="kobo.220.5">These objects are then garbage and wait for the GC to clean them up and free their memory space. </span><span class="koboSpan" id="kobo.220.6">After that, the memory space that has been freed is ready to be used again.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.221.1">The mark-and-sweep algorithm is the simplest algorithm used. </span><span class="koboSpan" id="kobo.221.2">The algorithm stops the program execution (</span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.222.1">stop-the-world GC</span></strong><span class="koboSpan" id="kobo.223.1">) in order to visit</span><a id="_idIndexMarker1310"/><span class="koboSpan" id="kobo.224.1"> all the accessible objects of the heap of a program and marks them. </span><span class="koboSpan" id="kobo.224.2">After that, it sweeps the inaccessible objects. </span><span class="koboSpan" id="kobo.224.3">During the mark phase of the algorithm, each object is marked as white, gray, or black. </span><span class="koboSpan" id="kobo.224.4">The children of a gray object are colored gray, whereas the original gray object is then colored black. </span><span class="koboSpan" id="kobo.224.5">The sweep</span><a id="_idIndexMarker1311"/><span class="koboSpan" id="kobo.225.1"> phase begins when there are no more gray objects to examine. </span><span class="koboSpan" id="kobo.225.2">This technique works because there are no pointers from the black set to the white set, which is a fundamental invariant of the algorithm.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.226.1">Although the mark-and-sweep algorithm is simple, it suspends the execution of the program while it is running, which means that it adds latency to the actual process. </span><span class="koboSpan" id="kobo.226.2">Go tries to lower that latency by running the GC as a concurrent process and by using the tri-color algorithm described in the previous section. </span><span class="koboSpan" id="kobo.226.3">However, other processes can move pointers or create new objects while the GC runs concurrently. </span><span class="koboSpan" id="kobo.226.4">This fact can make things difficult for the GC.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.227.1">As a result, the basic principle that will allow the tri-color algorithm to operate concurrently while maintaining the fundamental invariant of the mark-and-sweep algorithm is that no object in the black set can point to an object in the white set.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.228.1">The solution to this problem is fixing all the cases that can cause a problem for the algorithm. </span><span class="koboSpan" id="kobo.228.2">Therefore, new objects must go to the gray set because, this way, the fundamental invariant of the mark-and-sweep algorithm cannot be altered. </span><span class="koboSpan" id="kobo.228.3">Additionally, when a pointer of the program is moved, you color the object that the pointer points to as gray. </span><span class="koboSpan" id="kobo.228.4">The gray set acts like a barrier between the white set and the black set. </span><span class="koboSpan" id="kobo.228.5">Finally, each time a pointer is moved, some Go code gets automatically executed, which is the write barrier mentioned earlier, which does some recoloring. </span><span class="koboSpan" id="kobo.228.6">The latency introduced by the execution of the write barrier code is the price we have to pay for being able to run the GC concurrently.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.229.1">Note that the Java programming language has many garbage collectors that are highly configurable with the help of multiple parameters. </span><span class="koboSpan" id="kobo.229.2">One of these Java garbage collectors is called G1 and it is recommended for low-latency applications. </span><span class="koboSpan" id="kobo.229.3">Although Go does not have multiple garbage collectors, it does have knobs that you can use to tune the garbage collector for your applications.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.230.1">The section that follows discusses maps and slices from a garbage collection perspective because sometimes the way we </span><a id="_idIndexMarker1312"/><span class="koboSpan" id="kobo.231.1">handle variables influences the operation of the GC.</span></p>
<h1 class="heading-1" id="_idParaDest-427"><span class="koboSpan" id="kobo.232.1">Maps, slices, and the Go GC</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.233.1">In this section, we discuss the operation of the Go GC in relation to maps and slices. </span><span class="koboSpan" id="kobo.233.2">The purpose of this section is to let you write code that makes the work of the GC easier.</span></p>
<h2 class="heading-2" id="_idParaDest-428"><span class="koboSpan" id="kobo.234.1">Using slices</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.235.1">The example in this section uses a slice to</span><a id="_idIndexMarker1313"/><span class="koboSpan" id="kobo.236.1"> store a large number of structures in order to show how slice allocation is related to the operation of the GC. </span><span class="koboSpan" id="kobo.236.2">Each structure stores two integer values. </span><span class="koboSpan" id="kobo.236.3">This is implemented in </span><code class="inlineCode"><span class="koboSpan" id="kobo.237.1">sliceGC.go</span></code><span class="koboSpan" id="kobo.238.1"> as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.239.1">package</span></span><span class="koboSpan" id="kobo.240.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.241.1">import</span></span><span class="koboSpan" id="kobo.242.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.243.1">"runtime"</span></span><span class="koboSpan" id="kobo.244.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.245.1">type</span></span><span class="koboSpan" id="kobo.246.1"> data </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.247.1">struct</span></span><span class="koboSpan" id="kobo.248.1"> {
    i, j </span><span class="hljs-type"><span class="koboSpan" id="kobo.249.1">int</span></span><span class="koboSpan" id="kobo.250.1">
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.251.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.252.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.253.1">()</span></span><span class="koboSpan" id="kobo.254.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.255.1">var</span></span><span class="koboSpan" id="kobo.256.1"> N = </span><span class="hljs-number"><span class="koboSpan" id="kobo.257.1">80000000</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.258.1">var</span></span><span class="koboSpan" id="kobo.259.1"> structure []data
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.260.1">for</span></span><span class="koboSpan" id="kobo.261.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.262.1">0</span></span><span class="koboSpan" id="kobo.263.1">; i &lt; N; i++ {
        value := </span><span class="hljs-type"><span class="koboSpan" id="kobo.264.1">int</span></span><span class="koboSpan" id="kobo.265.1">(i)
        structure = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.266.1">append</span></span><span class="koboSpan" id="kobo.267.1">(structure, data{value, value})
    }
    runtime.GC()
    _ = structure[</span><span class="hljs-number"><span class="koboSpan" id="kobo.268.1">0</span></span><span class="koboSpan" id="kobo.269.1">]
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.270.1">The last statement, (</span><code class="inlineCode"><span class="koboSpan" id="kobo.271.1">_ = structure[0]</span></code><span class="koboSpan" id="kobo.272.1">), is used to prevent the GC from garbage collecting the structure variable too early, as it is not referenced or used outside of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.273.1">for</span></code><span class="koboSpan" id="kobo.274.1"> loop. </span><span class="koboSpan" id="kobo.274.2">The same technique will be used in the three Go programs that follow. </span><span class="koboSpan" id="kobo.274.3">Apart from this important detail, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.275.1">for</span></code><span class="koboSpan" id="kobo.276.1"> loop is used for putting all values into structures that are stored in the structure slice</span><a id="_idIndexMarker1314"/><span class="koboSpan" id="kobo.277.1"> variable. </span><span class="koboSpan" id="kobo.277.2">An equivalent way of doing that is the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.278.1">runtime.KeepAlive()</span></code><span class="koboSpan" id="kobo.279.1">. </span><span class="koboSpan" id="kobo.279.2">The program generates no output—it just triggers the GC using a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.280.1">runtime.GC()</span></code><span class="koboSpan" id="kobo.281.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-429"><span class="koboSpan" id="kobo.282.1">Using maps with pointers</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.283.1">In this subsection, we use a map for </span><a id="_idIndexMarker1315"/><span class="koboSpan" id="kobo.284.1">storing pointers. </span><span class="koboSpan" id="kobo.284.2">This time, the map uses integer keys that reference the pointers. </span><span class="koboSpan" id="kobo.284.3">The name of the program is </span><code class="inlineCode"><span class="koboSpan" id="kobo.285.1">mapStar.go</span></code><span class="koboSpan" id="kobo.286.1"> and contains the following Go code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.287.1">package</span></span><span class="koboSpan" id="kobo.288.1"> main
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.289.1">import</span></span><span class="koboSpan" id="kobo.290.1"> (
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.291.1">"runtime"</span></span><span class="koboSpan" id="kobo.292.1">
)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.293.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.294.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.295.1">()</span></span><span class="koboSpan" id="kobo.296.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.297.1">var</span></span><span class="koboSpan" id="kobo.298.1"> N = </span><span class="hljs-number"><span class="koboSpan" id="kobo.299.1">80000000</span></span><span class="koboSpan" id="kobo.300.1">
    myMap := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.301.1">make</span></span><span class="koboSpan" id="kobo.302.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.303.1">map</span></span><span class="koboSpan" id="kobo.304.1">[</span><span class="hljs-type"><span class="koboSpan" id="kobo.305.1">int</span></span><span class="koboSpan" id="kobo.306.1">]*</span><span class="hljs-type"><span class="koboSpan" id="kobo.307.1">int</span></span><span class="koboSpan" id="kobo.308.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.309.1">for</span></span><span class="koboSpan" id="kobo.310.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.311.1">0</span></span><span class="koboSpan" id="kobo.312.1">; i &lt; N; i++ {
        value := </span><span class="hljs-type"><span class="koboSpan" id="kobo.313.1">int</span></span><span class="koboSpan" id="kobo.314.1">(i)
        myMap[value] = &amp;value
    }
    runtime.GC()
    _ = myMap[</span><span class="hljs-number"><span class="koboSpan" id="kobo.315.1">0</span></span><span class="koboSpan" id="kobo.316.1">]
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.317.1">The operation of the program is the same as in </span><code class="inlineCode"><span class="koboSpan" id="kobo.318.1">sliceGC.go</span></code><span class="koboSpan" id="kobo.319.1"> from the previous section. </span><span class="koboSpan" id="kobo.319.2">What differs is the use of a map (</span><code class="inlineCode"><span class="koboSpan" id="kobo.320.1">make(map[int]*int)</span></code><span class="koboSpan" id="kobo.321.1">) for storing the pointers to </span><code class="inlineCode"><span class="koboSpan" id="kobo.322.1">int</span></code><span class="koboSpan" id="kobo.323.1">. </span><span class="koboSpan" id="kobo.323.2">As before, the program produces no output.</span></p>
<h2 class="heading-2" id="_idParaDest-430"><span class="koboSpan" id="kobo.324.1">Using maps without pointers</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.325.1">In this subsection, we use a map that</span><a id="_idIndexMarker1316"/><span class="koboSpan" id="kobo.326.1"> stores integer values directly instead of pointers to integers. </span><span class="koboSpan" id="kobo.326.2">The important code of </span><code class="inlineCode"><span class="koboSpan" id="kobo.327.1">mapNoStar.go</span></code><span class="koboSpan" id="kobo.328.1"> is the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.329.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.330.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.331.1">()</span></span><span class="koboSpan" id="kobo.332.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.333.1">var</span></span><span class="koboSpan" id="kobo.334.1"> N = </span><span class="hljs-number"><span class="koboSpan" id="kobo.335.1">80000000</span></span><span class="koboSpan" id="kobo.336.1">
    myMap := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.337.1">make</span></span><span class="koboSpan" id="kobo.338.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.339.1">map</span></span><span class="koboSpan" id="kobo.340.1">[</span><span class="hljs-type"><span class="koboSpan" id="kobo.341.1">int</span></span><span class="koboSpan" id="kobo.342.1">]</span><span class="hljs-type"><span class="koboSpan" id="kobo.343.1">int</span></span><span class="koboSpan" id="kobo.344.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.345.1">for</span></span><span class="koboSpan" id="kobo.346.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.347.1">0</span></span><span class="koboSpan" id="kobo.348.1">; i &lt; N; i++ {
        value := </span><span class="hljs-type"><span class="koboSpan" id="kobo.349.1">int</span></span><span class="koboSpan" id="kobo.350.1">(i)
        myMap[value] = value
    }
    runtime.GC()
    _ = myMap[</span><span class="hljs-number"><span class="koboSpan" id="kobo.351.1">0</span></span><span class="koboSpan" id="kobo.352.1">]
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.353.1">Once again, the program </span><a id="_idIndexMarker1317"/><span class="koboSpan" id="kobo.354.1">produces no output.</span></p>
<h2 class="heading-2" id="_idParaDest-431"><span class="koboSpan" id="kobo.355.1">Splitting a map</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.356.1">In this last program, we use a different </span><a id="_idIndexMarker1318"/><span class="koboSpan" id="kobo.357.1">technique called sharding where we split one long map into a map of maps. </span><span class="koboSpan" id="kobo.357.2">The implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.358.1">main()</span></code><span class="koboSpan" id="kobo.359.1"> function of </span><code class="inlineCode"><span class="koboSpan" id="kobo.360.1">mapSplit.go</span></code><span class="koboSpan" id="kobo.361.1"> is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.362.1">func</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.363.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.364.1">()</span></span><span class="koboSpan" id="kobo.365.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.366.1">var</span></span><span class="koboSpan" id="kobo.367.1"> N = </span><span class="hljs-number"><span class="koboSpan" id="kobo.368.1">80000000</span></span><span class="koboSpan" id="kobo.369.1">
    split := </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.370.1">make</span></span><span class="koboSpan" id="kobo.371.1">([]</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.372.1">map</span></span><span class="koboSpan" id="kobo.373.1">[</span><span class="hljs-type"><span class="koboSpan" id="kobo.374.1">int</span></span><span class="koboSpan" id="kobo.375.1">]</span><span class="hljs-type"><span class="koboSpan" id="kobo.376.1">int</span></span><span class="koboSpan" id="kobo.377.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.378.1">2000</span></span><span class="koboSpan" id="kobo.379.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.380.1">for</span></span><span class="koboSpan" id="kobo.381.1"> i := </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.382.1">range</span></span><span class="koboSpan" id="kobo.383.1"> split {
        split[i] = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.384.1">make</span></span><span class="koboSpan" id="kobo.385.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.386.1">map</span></span><span class="koboSpan" id="kobo.387.1">[</span><span class="hljs-type"><span class="koboSpan" id="kobo.388.1">int</span></span><span class="koboSpan" id="kobo.389.1">]</span><span class="hljs-type"><span class="koboSpan" id="kobo.390.1">int</span></span><span class="koboSpan" id="kobo.391.1">)
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.392.1">for</span></span><span class="koboSpan" id="kobo.393.1"> i := </span><span class="hljs-number"><span class="koboSpan" id="kobo.394.1">0</span></span><span class="koboSpan" id="kobo.395.1">; i &lt; N; i++ {
        value := </span><span class="hljs-type"><span class="koboSpan" id="kobo.396.1">int</span></span><span class="koboSpan" id="kobo.397.1">(i)
        split[i%</span><span class="hljs-number"><span class="koboSpan" id="kobo.398.1">2000</span></span><span class="koboSpan" id="kobo.399.1">][value] = value
    }
    runtime.GC()
    _ = split[</span><span class="hljs-number"><span class="koboSpan" id="kobo.400.1">0</span></span><span class="koboSpan" id="kobo.401.1">][</span><span class="hljs-number"><span class="koboSpan" id="kobo.402.1">0</span></span><span class="koboSpan" id="kobo.403.1">]
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.404.1">The code uses two </span><code class="inlineCode"><span class="koboSpan" id="kobo.405.1">for</span></code><span class="koboSpan" id="kobo.406.1"> loops, one for creating the map of maps and the other one for storing the desired data values in the map of maps.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.407.1">As all four programs are using huge data structures, they are consuming large amounts of memory. </span><span class="koboSpan" id="kobo.407.2">Programs that consume lots of memory space trigger the Go GC more often. </span><span class="koboSpan" id="kobo.407.3">The next subsection presents an evaluation of the presented techniques.</span></p>
<h2 class="heading-2" id="_idParaDest-432"><span class="koboSpan" id="kobo.408.1">Comparing the performance of the presented techniques</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.409.1">In this subsection, we compare the performance of each one of these four implementations using the time </span><a id="_idIndexMarker1319"/><span class="koboSpan" id="kobo.410.1">command of </span><code class="inlineCode"><span class="koboSpan" id="kobo.411.1">zsh(1)</span></code><span class="koboSpan" id="kobo.412.1">, which is pretty similar to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.413.1">time(1)</span></code><span class="koboSpan" id="kobo.414.1"> UNIX command. </span><span class="koboSpan" id="kobo.414.2">The purpose of the comparison is to understand how the allocation technique and the data structure used affect the performance of a program.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.415.1">$ </span></span><span class="koboSpan" id="kobo.416.1">time go run sliceGC.go
go run sliceGC.go  0.61s user 0.52s system 92% cpu 1.222 total
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.417.1">$ </span></span><span class="koboSpan" id="kobo.418.1">time go run mapStar.go
go run mapStar.go  23.86s user 1.02s system 176% cpu 14.107 total
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.419.1">$ </span></span><span class="koboSpan" id="kobo.420.1">time go run mapNoStar.go
go run mapNoStar.go  10.01s user 0.53s system 98% cpu 10.701 total
</span><span class="hljs-con-meta"><span class="koboSpan" id="kobo.421.1">$ </span></span><span class="koboSpan" id="kobo.422.1">time go run mapSplit.go
go run mapSplit.go  11.22s user 0.44s system 100% cpu 11.641 total
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.423.1">It turns out that </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.424.1">all map versions are slower than the slice version</span></strong><span class="koboSpan" id="kobo.425.1">. </span><span class="koboSpan" id="kobo.425.2">Unfortunately for maps, the map version will always be slower than the slice version because of the execution of the hash function and the fact that the data is not contiguous. </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.426.1">In maps, data is stored in a bucket determined by the output of the hash function</span></strong><span class="koboSpan" id="kobo.427.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.428.1">Additionally, the first map program (</span><code class="inlineCode"><span class="koboSpan" id="kobo.429.1">mapStar.go</span></code><span class="koboSpan" id="kobo.430.1">) may trigger some GC slowdown because taking the address of </span><code class="inlineCode"><span class="koboSpan" id="kobo.431.1">&amp;value</span></code><span class="koboSpan" id="kobo.432.1"> will cause it to escape to the heap. </span><span class="koboSpan" id="kobo.432.2">Every other program is just using the stack for those locals. </span><strong class="bold-italic" style="font-style: italic;"><span class="koboSpan" id="kobo.433.1">When variables escape to the heap, they cause more garbage collection pressure</span></strong><span class="koboSpan" id="kobo.434.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.435.1">Accessing an element of a map or a slice has </span><code class="inlineCode"><span class="koboSpan" id="kobo.436.1">O(1)</span></code><span class="koboSpan" id="kobo.437.1"> runtime, which means that the access time does not depend on the number of elements found in the map or the slice. </span><span class="koboSpan" id="kobo.437.2">However, the way these structures work affects the overall speed.</span></p>
<h1 class="heading-1" id="_idParaDest-433"><span class="koboSpan" id="kobo.438.1">Additional resources</span></h1>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.439.1">Go FAQ: How do I know whether a variable is allocated on the heap or the stack? </span><a href="https://go.dev/doc/faq#stack_or_heap"><span class="url"><span class="koboSpan" id="kobo.440.1">https://go.dev/doc/faq#stack_or_heap</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.441.1">The list of available </span><code class="inlineCode"><span class="koboSpan" id="kobo.442.1">-gcflags</span></code><span class="koboSpan" id="kobo.443.1"> options: </span><a href="https://pkg.go.dev/cmd/compile.dev/doc/faq#stack_or_heap"><span class="url"><span class="koboSpan" id="kobo.444.1">https://pkg.go.dev/cmd/compile</span></span></a></li>
<li class="bulletList"><span class="koboSpan" id="kobo.445.1">If you want to learn more about garbage collection, you should visit </span><a href="http://gchandbook.org/"><span class="url"><span class="koboSpan" id="kobo.446.1">http://gchandbook.org/</span></span></a></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.447.1">Leave a review!</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.448.1">Enjoyed this book? </span><span class="koboSpan" id="kobo.448.2">Help readers like you by leaving an Amazon review. </span><span class="koboSpan" id="kobo.448.3">Scan the QR code below to get a free eBook of your choice.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.449.1"><img alt="" role="presentation" src="../Images/Review_QR_Code.png"/></span></p>
</div>
</body></html>