<html><head></head><body>
		<div id="_idContainer014">
			<h1 id="_idParaDest-28" class="chapter-number" lang="en-GB"><a id="_idTextAnchor027"/>2</h1>
			<h1 id="_idParaDest-29" lang="en-GB"><a id="_idTextAnchor028"/>Scaffolding a Go Microservice</h1>
			<p lang="en-GB">In this chapter, we will finally start scaffolding our microservice code. The goal of this chapter is to establish a solid foundation for writing Go microservices and setting the right structure for future changes. While Go makes it relatively easy to write small applications, there are multiple challenges that engineers may face along the way, including the following:</p>
			<ul>
				<li lang="en-GB">How to set the right project structure to make it easier to evolve and maintain the code base</li>
				<li lang="en-GB">How to write idiomatic Go code that is going to be consistent with the largest Go code bases</li>
				<li lang="en-GB">How to separate the components of a microservice and wire them together</li>
			</ul>
			<p lang="en-GB">In this chapter, we are going to address each of these challenges. First, you will be introduced to the key aspects of writing idiomatic and conventional Go code. You will learn important recommendations for writing and organizing your code base, as well as how to set up the proper code structure for your services. Then, we are going to introduce you to an example application, which will consist of three microservices that we are going to use throughout the book. In the following chapters, we will add additional features to these services, illustrating all the important areas of microservice development.</p>
			<p lang="en-GB">In this chapter, we will cover the following topics:</p>
			<ul>
				<li lang="en-GB">Go basics</li>
				<li lang="en-GB">Project structure</li>
				<li lang="en-GB">Scaffolding an example application</li>
			</ul>
			<h1 id="_idParaDest-30" lang="en-GB"><a id="_idTextAnchor029"/>Technical requirements</h1>
			<p lang="en-GB">To complete this chapter, you need to have Go 1.11 or above. If you don’t have Go installed, you can download it from the official website at <a href="https://go.dev/dl">go.dev/dl</a>.</p>
			<p lang="en-GB">You can find the code examples for this chapter on GitHub: <a href="https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter02">https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter02</a>.</p>
			<h1 id="_idParaDest-31" lang="en-GB"><a id="_idTextAnchor030"/>Go basics</h1>
			<p lang="en-GB">Go is a<a id="_idIndexMarker029"/> great language for writing microservices. It is relatively easy to learn and has a pretty smooth learning curve, making onboarding new engineers easier. While you may have already had some experience with Go, one of the purposes of this book is to provide enough information to all types of developers—from beginners to highly experienced professionals.</p>
			<p lang="en-GB">In this section, we are going to summarize important concepts of the language. If you already have experience with Go, you can still quickly scan through this part. It also includes some useful recommendations and best practices commonly missed even by experienced engineers.</p>
			<h2 id="_idParaDest-32" lang="en-GB"><a id="_idTextAnchor031"/>Core principles</h2>
			<p lang="en-GB">Before we proceed to <a id="_idIndexMarker030"/>look at the basics of Go, I’m going to share with you some fundamental principles that will help you make decisions when writing and organizing your code. These principles include the following:</p>
			<ul>
				<li lang="en-GB"><em class="italic" lang="">Always follow the official guidelines</em>. It is not uncommon for us engineers to have strong opinions about various styling and coding practices. However, in any developer community, consistency is more important than individual opinions. Make sure you get familiar with the most fundamental Go programming guidelines, written by the Go team:<ul><li lang="en-GB"><strong class="bold" lang="">Effective Go—an official set of guidelines for Go developers</strong>: <a href="https://go.dev/doc/effective_go">https://go.dev/doc/effective_go</a></li><li lang="en-GB"><strong class="bold" lang="">Go code review comments</strong>: Another useful source of information on Go development, covering various aspects, including code style, naming, and error handling: <a href="https://github.com/golang/go/wiki/CodeReviewComments">https://github.com/golang/go/wiki/CodeReviewComments</a></li></ul></li>
				<li lang="en-GB"><em class="italic" lang="">Follow the style used in the standard library</em>. The standard Go library, which comes with any Go installation, is the best source of code examples and comments. Get familiar with some of the packages from the library, such as <strong class="source-inline" lang="">context</strong> and <strong class="source-inline" lang="">net</strong>. Following the coding style used in these packages will help you to write consistent, readable, and maintainable code, regardless of who will be using it later.</li>
				<li lang="en-GB"><em class="italic" lang="">Do not try to apply the ideas from other languages to Go</em>. Instead, understand the philosophy of Go and see the implementation of the most elegant Go packages—you can check the <strong class="source-inline" lang="">net</strong> package for some good examples: <a href="https://pkg.go.dev/net">https://pkg.go.dev/net</a>.</li>
			</ul>
			<p lang="en-GB">Now, as we are aligned on the core principles, let’s move on to the key recommendations for writing conventional and idiomatic Go code.</p>
			<h2 id="_idParaDest-33" lang="en-GB"><a id="_idTextAnchor032"/>Writing idiomatic Go code</h2>
			<p lang="en-GB">This section <a id="_idIndexMarker031"/>summarizes<a id="_idIndexMarker032"/> the key topics described in the <em class="italic" lang="">Effective Go</em> document. Following the suggestions provided in this section will help you to keep your code consistent with the official guidelines.</p>
			<h3 lang="en-GB">Naming</h3>
			<p lang="en-GB">Naming is one <a id="_idIndexMarker033"/>of the most important aspects of Go development. Writing Go code in an idiomatic way requires an understanding of its core <a id="_idIndexMarker034"/>naming <a id="_idIndexMarker035"/>principles:</p>
			<ul>
				<li lang="en-GB">Exported names start with an uppercase character.</li>
				<li lang="en-GB">When a variable, struct, or interface is imported from another package, its name includes a package name or alias, for example, <strong class="source-inline" lang="">bytes.Buffer</strong>.</li>
				<li lang="en-GB">Since references include package names, you should not prefix your names with the package name. If the package name is <strong class="source-inline" lang="">xml</strong>, use the name <strong class="source-inline" lang="">Reader</strong>, not <strong class="source-inline" lang="">XMLReader</strong>—in the second case, the full name would be <strong class="source-inline" lang="">xml.XMLReader</strong>.</li>
				<li lang="en-GB">Packages are generally given lowercase, single-word names.</li>
				<li lang="en-GB">It is not idiomatic to start the names of getters with the <strong class="source-inline" lang="">Get</strong> prefix. If your function returns the user’s age, call the function <strong class="source-inline" lang="">Age()</strong>, not <strong class="source-inline" lang="">GetAge()</strong>. Using the <strong class="source-inline" lang="">Set</strong> prefix, however, is fine; you can safely call your function <strong class="source-inline" lang="">SetAge()</strong>.</li>
				<li lang="en-GB">Single-method interfaces are named using the method name plus an <strong class="source-inline" lang="">er</strong> suffix. For example, an interface with a <strong class="source-inline" lang="">Write</strong> function would be called <strong class="source-inline" lang="">Writer</strong>.</li>
				<li lang="en-GB"><a id="_idTextAnchor033"/>Initialisms and acronyms should have a consistent case. The correct versions would be <strong class="source-inline" lang="">URL</strong>, <strong class="source-inline" lang="">url</strong> and <strong class="source-inline" lang="">ID</strong>, include while <strong class="source-inline" lang="">Url</strong>, <strong class="source-inline" lang="">Id</strong> would be incorrect.</li>
				<li lang="en-GB">Variable names should be short rather than long. In general, follow this simple rule—the closer to declaration a name is used, the shorter it should be. For iterating over an array, use <em class="italic" lang="">i</em> for the index variable.</li>
			</ul>
			<p lang="en-GB">Additional naming <a id="_idIndexMarker036"/>recommendations include the following:</p>
			<ul>
				<li lang="en-GB">The package name should be short, concise, and evocative and should provide context for its contents, for example, <strong class="source-inline" lang="">json</strong>.</li>
				<li lang="en-GB">Keep the contents of a package consistent with the name. If you start noticing that a package includes extra logic that has no relationship to the package name, consider exporting it to a separate one or using a more descriptive name.</li>
				<li lang="en-GB">Use name abbreviations only if they are widely used (for example, <strong class="source-inline" lang="">fmt</strong> or <strong class="source-inline" lang="">cmd</strong>).</li>
				<li lang="en-GB">Avoid name collisions, when possible. For example, if you introduce a set of string functions, avoid calling it <strong class="source-inline" lang="">strings</strong> package because a package with the same name exists in the Go standard library and is already widely used.</li>
				<li lang="en-GB">Consider the client’s point of view when giving names to your code. Think about how the code is going to be used when giving a name to it, for example, the <strong class="source-inline" lang="">Writer</strong> interface for proving the write functionality.</li>
			</ul>
			<p lang="en-GB">In addition to these rules, remember to keep the naming consistent across your code base. It will help make it easier to read and write new code—good names will act as examples for other engineers as well.</p>
			<h3 lang="en-GB">Comments</h3>
			<p lang="en-GB">Comments are the <a id="_idIndexMarker037"/>next important aspect of Go development. Go <a id="_idIndexMarker038"/>comments can be used in two different ways:</p>
			<ul>
				<li lang="en-GB">Seeing the comments alongside the code</li>
				<li lang="en-GB">Viewing the package documentation generated by the <strong class="source-inline" lang="">godoc</strong> tool</li>
			</ul>
			<p lang="en-GB">General principles for Go <a id="_idIndexMarker039"/>comments include the following:</p>
			<ul>
				<li lang="en-GB">Every package should have a comment describing its contents.</li>
				<li lang="en-GB">Every exported name in Go should have a comment.</li>
				<li lang="en-GB">Comments should be complete sentences and end with a period.</li>
				<li lang="en-GB">The first sentence of the comment should start with the name being exported and provide a summary of it, as in the following example:<pre class="source-code" lang="en-GB">
// ErrNotFound is returned when the record is not found.</pre><pre class="source-code" lang="en-GB">
var ErrNotFound = errors.New("not found")</pre></li>
			</ul>
			<p lang="en-GB">The Go standard library provides many good examples of code comments, so I always suggest getting familiar with some examples from it.</p>
			<h3 lang="en-GB">Errors</h3>
			<p lang="en-GB">General recommendations<a id="_idIndexMarker040"/> for Go <a id="_idIndexMarker041"/>errors include the following:</p>
			<ul>
				<li lang="en-GB">Only use panics in truly exceptional cases.</li>
				<li lang="en-GB">Always handle each error; don’t discard errors by using <strong class="source-inline" lang="">_</strong> assignment.</li>
				<li lang="en-GB">Error strings should start with a lowercase character, unless they begin with names requiring capitalization, such as acronyms.</li>
				<li lang="en-GB">Error strings, unlike comments, should not end with punctuation marks, as in the following example:<pre class="source-code" lang="en-GB">
return errors.New("user not found")</pre><pre class="source-code" lang="en-GB">
var errUserNotFound = errors.New("user not found")</pre></li>
				<li lang="en-GB">When calling a function returning an error, always handle the error first.</li>
				<li lang="en-GB">Wrap errors if you want to add additional information to the clause. The conventional way of wrapping errors in Go is to use <strong class="source-inline" lang="">%w</strong> at the end of the formatted error:<pre class="source-code" lang="en-GB">
if err != nil {</pre><pre class="source-code" lang="en-GB">
    return fmt.Errorf("upload failed: %w", err)</pre><pre class="source-code" lang="en-GB">
}</pre></li>
				<li lang="en-GB">While checking<a id="_idIndexMarker042"/> for errors, using the <strong class="source-inline" lang="">==</strong> operator may result in improper handling of the wrapped errors. There are two solutions to this. For a comparison to a sentinel error, such as <strong class="source-inline" lang="">errors.New("some error")</strong>, use <strong class="source-inline" lang="">errors.Is</strong>:<pre class="source-code" lang="en-GB">
if errors.Is(err, ErrNotFound) {</pre><pre class="source-code" lang="en-GB">
    // err or some error it wraps is ErrNotFound.</pre><pre class="source-code" lang="en-GB">
}</pre></li>
			</ul>
			<p lang="en-GB">For error types, use <strong class="source-inline" lang="">errors.As</strong>:</p>
			<pre class="source-code" lang="en-GB">
var e *QueryError
if errors.As(err, &amp;e) {
    // err has *QueryError type.
}</pre>
			<p lang="en-GB">Additionally, keep errors descriptive yet compact. It should be always easy to understand what exactly went wrong by reading the error message.</p>
			<h2 id="_idParaDest-34" lang="en-GB"><a id="_idTextAnchor034"/>Interfaces</h2>
			<p lang="en-GB">Key principles of Go <a id="_idIndexMarker043"/><strong class="bold" lang="">interfaces</strong> include the following:</p>
			<ul>
				<li lang="en-GB">Do not define interfaces before they are used without a realistic example of usage.</li>
				<li lang="en-GB">Return concrete (using a pointer or struct) types instead of an interface in your functions.</li>
				<li lang="en-GB">Single-method interfaces should be called by the method name and include the <strong class="source-inline" lang="">er</strong> suffix, for example, the <strong class="source-inline" lang="">Writer</strong> interface with a <strong class="source-inline" lang="">Write</strong> function.</li>
			</ul>
			<p lang="en-GB">See some built-in interfaces, such as <strong class="source-inline" lang="">Writer</strong> and <strong class="source-inline" lang="">Reader</strong>, to get a good example of defining and using interfaces in Go.</p>
			<h2 id="_idParaDest-35" lang="en-GB"><a id="_idTextAnchor035"/>Tests</h2>
			<p lang="en-GB">We are going to cover testing in detail in <a href="B18865_08.xhtml#_idTextAnchor109"><em class="italic" lang="">Chapter 8</em></a> of this book. Let’s provide here some key suggestions for writing <a id="_idIndexMarker044"/>Go tests in an idiomatic way:</p>
			<ul>
				<li lang="en-GB">Tests should always provide information to the user on what exactly went wrong in case of a failure.</li>
				<li lang="en-GB">Consider writing table-driven tests whenever possible. See this example: <a href="https://github.com/golang/go/blob/master/src/fmt/errors_test.go">https://github.com/golang/go/blob/master/src/fmt/errors_test.go</a>.</li>
				<li lang="en-GB">Generally, we <a id="_idIndexMarker045"/>should only test public functions. Your private function should be indirectly tested through them.</li>
			</ul>
			<p lang="en-GB">Make sure you always write tests for your code. Not only does this help with finding bugs earlier but it also helps to see how your code can be used. I personally find the latter especially useful.</p>
			<h2 id="_idParaDest-36" lang="en-GB"><a id="_idTextAnchor036"/>Context</h2>
			<p lang="en-GB">One of the key <a id="_idIndexMarker046"/>differences between the Go language and other popular languages is explicit context propagation. <strong class="bold" lang="">Context propagation</strong> is a <a id="_idIndexMarker047"/>mechanism of propagating an additional call argument, called <strong class="bold" lang="">context</strong>, into function calls, passing additional metadata.</p>
			<p lang="en-GB">Go <a id="_idIndexMarker048"/>context has a type called <strong class="source-inline" lang="">context.Context</strong>. There are multiple ways of using it:</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Cancelation logic</strong>: You can pass a special instance of a context that can get <em class="italic" lang="">canceled</em>. In that case, all functions you were to call with it would be able to detect this. Such logic can be useful for handling application shutdown or stopping any processing.</li>
				<li lang="en-GB"><strong class="bold" lang="">Timeouts</strong>: You can set the timeouts for your execution by using the corresponding context functions.</li>
				<li lang="en-GB"><strong class="bold" lang="">Propagating extra metadata</strong>: You can propagate additional key-value metadata inside the context. This way, any downstream functions called would receive that metadata inside the context object. There are some useful applications of this approach, one of which is distributed tracing, which we are going to cover in the following chapters.</li>
			</ul>
			<p lang="en-GB">We will get back to context propagation in the following chapters. Now, we can define some important aspects of using context in Go:</p>
			<ul>
				<li lang="en-GB">Context is immutable but can be cloned with extra metadata.</li>
				<li lang="en-GB">Functions using context should accept it as their first argument.</li>
			</ul>
			<p lang="en-GB">Additionally, some context best practices are as follows:</p>
			<ul>
				<li lang="en-GB">Always pass context to functions performing I/O calls.</li>
				<li lang="en-GB">Limit the usage of context for passing any metadata. You should use metadata propagation for truly exceptional cases, such as distributed tracing, mentioned earlier.</li>
				<li lang="en-GB">Do not attach context to structures.</li>
			</ul>
			<p lang="en-GB">Now, as we have discussed the key recommendations for writing idiomatic Go code, we can move on to the next section, which is going to cover the project structure recommendations and standards for Go applications.</p>
			<h1 id="_idParaDest-37" lang="en-GB"><a id="_idTextAnchor037"/>Project structure</h1>
			<p lang="en-GB">The<a id="_idIndexMarker049"/> project structure is the foundation of and plays a major role in the readability and maintainability of your code. As we discussed in the previous sections, in Go projects, the structure may play a more important role than in other languages, because each exported name generally includes the name of its package. This requires you to have good and descriptive naming for your packages and directories, as well as the right hierarchy of your code.</p>
			<p lang="en-GB">While the official guidelines define some strong recommendations for naming and coding styles there aren’t that many rules constraining the Go project structure. Each project is unique by its nature, and developers are generally free to choose the way they organize the code. However, there are some common practices and specifics of Go package organization that we are going to cover in this section.</p>
			<h2 id="_idParaDest-38" lang="en-GB"><a id="_idTextAnchor038"/>Private packages</h2>
			<p lang="en-GB">In Go, all code <a id="_idIndexMarker050"/>stored inside a directory called <strong class="source-inline" lang="">internal</strong> can be imported and used only by packages stored within the same directory or one of the directories it includes. Putting code into an internal directory can ensure your code is not exported and used by external packages. This can be useful for the following different cases:</p>
			<ul>
				<li lang="en-GB">Hide the details of the implementation from the user if some of the types of functions need to be exported.</li>
				<li lang="en-GB">Ensure no external package relies on your types and functions, which you don’t want to expose widely.</li>
				<li lang="en-GB">Remove possible unnecessary dependencies between the packages.</li>
				<li lang="en-GB">Avoid extra refactoring and maintenance difficulties if your code is unexpectedly used by other developers/teams.</li>
			</ul>
			<p lang="en-GB">I have found it useful to use internal packages as a protection against unwanted dependencies. This plays a big role in large repositories and applications, where there is a high possibility of unexpected dependencies between the packages. Large code bases that don’t have a separation between private and public packages often suffer from an effect called <em class="italic" lang="">spaghettification</em>—when packages depend on each other in an uncontrolled and chaotic way.</p>
			<h2 id="_idParaDest-39" lang="en-GB"><a id="_idTextAnchor039"/>Public packages</h2>
			<p lang="en-GB">There is another type <a id="_idIndexMarker051"/>of directory name with a semantic meaning in Go—a directory called <strong class="source-inline" lang="">pkg</strong>. It implies that it is OK to use the code from this package externally.</p>
			<p lang="en-GB">The <strong class="source-inline" lang="">pkg</strong> directory isn’t recommended officially, but it is widely used. Ironically, the Go team used this in the library code and then got rid of this pattern, while the rest of the Go community adopted it so widely that it became a common practice.</p>
			<p lang="en-GB">It is up to you whether you use a <strong class="source-inline" lang="">pkg</strong> directory in your applications. But in tandem with the internal directory, it can help to organize your code so that what is private and what is public is clear, easing the code navigation for the developers.</p>
			<h2 id="_idParaDest-40" lang="en-GB"><a id="_idTextAnchor040"/>Executable packages</h2>
			<p lang="en-GB">The <strong class="source-inline" lang="">cmd</strong> package is commonly <a id="_idIndexMarker052"/>used in the Go community to store the code of one or multiple executable packages with a <strong class="source-inline" lang="">main</strong> function. This may include the code starting your application or any code for your executable tools. For a single-app directory, you can store your Go code directly in the <strong class="source-inline" lang="">cmd</strong> package:</p>
			<pre class="source-code" lang="en-GB">
cmd/
cmd/main.go</pre>
			<p lang="en-GB">For a multi-app directory, you can include subpackages in <strong class="source-inline" lang="">cmd</strong> packages:</p>
			<pre class="source-code" lang="en-GB">
cmd/
cmd/indexer/main.go
cmd/crawler/main.go</pre>
			<h2 id="_idParaDest-41" lang="en-GB"><a id="_idTextAnchor041"/>Other commonly used directories</h2>
			<p lang="en-GB">The following list includes <a id="_idIndexMarker053"/>some other commonly used directory or package names in the Go community:</p>
			<ul>
				<li lang="en-GB"><strong class="source-inline" lang="">api</strong>: JSON schema files and definitions in various protocols, including gRPC. We are going to cover these topics in <a href="B18865_04.xhtml#_idTextAnchor067"><em class="italic" lang="">Chapter 4</em></a>.</li>
				<li lang="en-GB"><strong class="source-inline" lang="">testdata</strong>: Files containing the data used in tests.</li>
				<li lang="en-GB"><strong class="source-inline" lang="">web</strong>: Web application components and assets.</li>
			</ul>
			<h2 id="_idParaDest-42" lang="en-GB"><a id="_idTextAnchor042"/>Common files</h2>
			<p lang="en-GB">Here is a list of common<a id="_idIndexMarker054"/> filenames, which will keep your packages consistent with the official library and lots of third-party libraries:</p>
			<ul>
				<li lang="en-GB"><strong class="source-inline" lang="">main.go</strong>: A file containing the <strong class="source-inline" lang="">main()</strong> function</li>
				<li lang="en-GB"><strong class="source-inline" lang="">doc.go</strong>: Package documentation (a separate file is not necessary for small packages)</li>
				<li lang="en-GB"><strong class="source-inline" lang="">*_test.go</strong>: Test files</li>
				<li lang="en-GB"><strong class="source-inline" lang="">README.md</strong>: A read-me file written in the Markdown language</li>
				<li lang="en-GB"><strong class="source-inline" lang="">LICENSE</strong>: A license file, if there is one</li>
				<li lang="en-GB"><strong class="source-inline" lang="">CONTRIBUTING.md</strong>/CONTRIBUTORS/AUTHORS: List of contributors and/or authors</li>
			</ul>
			<p lang="en-GB">Now, let’s cover the best practices for organizing the code base for Go applications.</p>
			<h2 id="_idParaDest-43" lang="en-GB"><a id="_idTextAnchor043"/>Best practices</h2>
			<p lang="en-GB">In this <a id="_idIndexMarker055"/>section, you can find a list of best practices for organizing the Go application project structure. It is going to help you to keep your code aligned with thousands of other Go packages and keep it conventional and idiomatic. The best practices of Go project organization include the following:</p>
			<ul>
				<li lang="en-GB">Separate private code using an internal directory.</li>
				<li lang="en-GB">Get familiar with the way popular open source Go projects, such as <a href="https://github.com/kubernetes/kubernetes">https://github.com/kubernetes/kubernetes</a>, are organized. This can provide you with great examples of how to structure your repository.</li>
				<li lang="en-GB">Split in a sufficiently granular way. Don’t split the packages too early but also avoid having a lot of logic in a single package. Generally, you will find that the easier it is to give a short and specific self-descriptive name to a package, the better your code composition is.</li>
				<li lang="en-GB">Avoid long package names.</li>
				<li lang="en-GB">Always be ready to change the structure if requirements are changed or if the structure no longer reflects the package name/original intent.</li>
			</ul>
			<p lang="en-GB">This sums up the part of the chapter describing the core principles and best practices of Go application development and code organization. Now, we are ready to get to the practical side of this chapter.</p>
			<h1 id="_idParaDest-44" lang="en-GB"><a id="_idTextAnchor044"/>Scaffolding an example application</h1>
			<p lang="en-GB">We have covered the <a id="_idIndexMarker056"/>general recommendations for writing and organizing Go applications and we are finally ready to start writing the code! In this section, we are going to introduce an application, consisting of multiple microservices that are going to be used throughout the book. In each chapter, we are going to add to or improve them, converting them from small examples into production-grade services that are ready to be used.</p>
			<p lang="en-GB">You will learn how to scaffold microservice code and split the code into separate logical parts, each having its own role. We are going to apply the project structure and Go knowledge you gained in this chapter to illustrate how to set the right structure for each service and write its code in a conventional and idiomatic way.</p>
			<h2 id="_idParaDest-45" lang="en-GB"><a id="_idTextAnchor045"/>Movie application</h2>
			<p lang="en-GB">Let’s imagine we are building <a id="_idIndexMarker057"/>an application<a id="_idIndexMarker058"/> for movie lovers. The application would provide the following features:</p>
			<ul>
				<li lang="en-GB">Get the movie metadata (such as title, year, description, and director) and the aggregated movie rating</li>
				<li lang="en-GB">Rate a movie</li>
			</ul>
			<p lang="en-GB">All the listed features seem to be <a id="_idIndexMarker059"/>closely related. However, let’s take a closer look at them.</p>
			<h3 lang="en-GB">Movie metadata</h3>
			<p lang="en-GB">Let’s assume we have the <a id="_idIndexMarker060"/>metadata for a collection of movies, which includes the following fields:</p>
			<ul>
				<li lang="en-GB">ID</li>
				<li lang="en-GB">Title</li>
				<li lang="en-GB">Year</li>
				<li lang="en-GB">Description</li>
				<li lang="en-GB">Director</li>
				<li lang="en-GB">List of actors</li>
			</ul>
			<p lang="en-GB">Such information about movies doesn’t generally change unless somebody wants to update the description, but for simplicity, we may assume that we are dealing with a static dataset. We would retrieve the records based on their IDs, so we could use any key-value or document database to store and access the metadata.</p>
			<h3 lang="en-GB">Ratings</h3>
			<p lang="en-GB">Let’s now review<a id="_idIndexMarker061"/> the functionality required for storing and retrieving movie ratings.</p>
			<p lang="en-GB">Generally, we would need to perform the following rating operations:</p>
			<ul>
				<li lang="en-GB">Store a movie rating</li>
				<li lang="en-GB">Get the aggregated movie rating</li>
			</ul>
			<p lang="en-GB">Later, we would also need to support rating deletion, but for now, we can just keep this logic in mind while designing the application.</p>
			<p lang="en-GB">The ratings data is quite different from the movie metadata—we can both append and delete the records. In addition to this, we need to return the aggregated rating, so we should either be able to return all stored ratings for an item and perform the aggregation on the go or have separate logic for performing and storing the aggregations. You will notice that the ways we access ratings and movie metadata are different. This hints that the ratings data can, and probably should, be stored separately from the movie metadata.</p>
			<p lang="en-GB">While designing the application, it is beneficial to think one step ahead and imagine how the application may evolve in the future. This does not mean that you should necessarily build the application trying to predict future use cases, because it can lead to unnecessary abstractions that may not be needed later if your plans change. However, thinking one step ahead may save you time later if you find more efficient ways of modeling and storing your data, which would help you to adapt to changing requirements.</p>
			<p lang="en-GB">Let’s see how the rating service can possibly evolve. At some point, we may want to extend the rating functionality to other types of movie-related records. A user may be able to do the following:</p>
			<ul>
				<li lang="en-GB">Rate the actor’s performance in some movies</li>
				<li lang="en-GB">Rate the movie soundtrack</li>
				<li lang="en-GB">Rate the movie’s costume design</li>
			</ul>
			<p lang="en-GB">When making <a id="_idIndexMarker062"/>decisions on supporting future use cases, you should ask yourself, how likely it is that I will need to implement that logic in the observable future (6 to 12 months)? You should generally avoid thinking much further ahead because the requirements and goals may change. However, if you are quite certain you have plans to support particular features, you should make sure your data model can support those features without major changes.</p>
			<p lang="en-GB">Let’s assume we definitely want to implement the additional ratings mentioned earlier. In this case, we want to make sure we can design our application in a way that would support the ratings for different types of objects.</p>
			<p lang="en-GB">Let’s define the API for such a rating component:</p>
			<ul>
				<li lang="en-GB">Store the rating record, including the following:<ul><li lang="en-GB">ID of the user who gave the rating</li><li lang="en-GB">Type of record</li><li lang="en-GB">ID of the record</li><li lang="en-GB">Rating value</li></ul></li>
				<li lang="en-GB">Get the aggregated rating for a record by its ID and type.</li>
			</ul>
			<p lang="en-GB">This API supports record types, so we can easily add more types of ratings without changing the system. The trade-off we made here is quite reasonable—the API is different on the basis of just one field (record type) from the API of a rating system designed just for movies. However, this gives us complete freedom in introducing new rating types in the future! Such a trade-off seems very reasonable given that we have decided we will certainly need those ratings in the future.</p>
			<h3 lang="en-GB">Should we split the application?</h3>
			<p lang="en-GB">Let’s provide a summary <a id="_idIndexMarker063"/>of the two parts of the application we have just described:</p>
			<ul>
				<li lang="en-GB">Movie metadata:<ul><li lang="en-GB">Retrieve the metadata for a movie by its ID.</li></ul></li>
				<li lang="en-GB">Ratings:<ul><li lang="en-GB">Store a rating for a record.</li><li lang="en-GB">Retrieve an aggregated rating for a record.</li></ul></li>
			</ul>
			<p lang="en-GB">After we abstracted<a id="_idIndexMarker064"/> the rating component by letting it support various record types, it stopped being a movie rating component and became a more generic record rating system. The movie metadata component is now loosely coupled to the rating system—the rating system can store the ratings for movies as well as for any other possible types of records.</p>
			<p lang="en-GB">As we discussed previously, the data models for both components are also quite different. The movie metadata component stores static data, which is going to be retrieved by ID, while the rating component stores dynamic data, which requires aggregation.</p>
			<p lang="en-GB">Both components seem to be relatively independent of each other. This is a perfect example of a situation where we may benefit from splitting the application into separate services:</p>
			<ul>
				<li lang="en-GB">Logic is loosely coupled</li>
				<li lang="en-GB">Data models are different</li>
				<li lang="en-GB">Data is generally independent</li>
			</ul>
			<p lang="en-GB">This list is not complete, and you need to consider all the aspects described in <a href="B18865_01.xhtml#_idTextAnchor015"><em class="italic" lang="">Chapter 1</em></a>, to make a decision on splitting the application. However, since this book covers microservice development, let’s make our decision here and decide to split the system into separate services.</p>
			<p lang="en-GB">Let’s list the services we would split the application into:</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Movie metadata service</strong>: Store<a id="_idIndexMarker065"/> and retrieve the movie metadata records by movie IDs.</li>
				<li lang="en-GB"><strong class="bold" lang="">Rating service</strong>: Store ratings for <a id="_idIndexMarker066"/>different types of records and retrieve aggregated ratings for records.</li>
				<li lang="en-GB"><strong class="bold" lang="">Movie service</strong>: Provide <a id="_idIndexMarker067"/>complete information to the callers about a movie or a set of movies, including the movie metadata and its rating.</li>
			</ul>
			<p lang="en-GB">Why did we end up with three services here? We did this for the following reasons:</p>
			<ul>
				<li lang="en-GB">The movie metadata service would be solely responsible for accessing the movie metadata records.</li>
				<li lang="en-GB">The movie service would provide the client-facing API, aggregating two separate types of records—movie metadata and ratings. The records would be stored in two separate systems, so this component would join them together and return to the caller.</li>
				<li lang="en-GB">If we introduce any other types of records in the system, such as likes, reviews, and recommendations, we will plug them into the movie service, not the movie metadata service. The movie metadata service would be used solely for accessing the static movie metadata, not any other types of records.</li>
				<li lang="en-GB">Movie metadata services can potentially evolve in the future by getting more metadata-related functionality, such as editing or adding descriptions in different languages. This also hints that it is better to keep this component solely for the metadata-related features.</li>
			</ul>
			<p lang="en-GB">Let’s <a id="_idIndexMarker068"/>illustrate these services in a diagram:</p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/Figure_2.1_B18865.jpg" alt="Figure 2.1 – Movie application services&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Movie application services</p>
			<p lang="en-GB">Now, as we have definitions of the three microservices, let’s finally proceed to the coding part.</p>
			<h2 id="_idParaDest-46" lang="en-GB"><a id="_idTextAnchor046"/>Application code structure</h2>
			<p lang="en-GB">Let’s align on how are we <a id="_idIndexMarker069"/>going to structure the code of all microservices in relation to each other. I would suggest storing them inside a single directory, which would be our application root. Create a new directory (you may call it <strong class="source-inline" lang="">movieapp</strong>), and inside it, create the following directories for our microservices:</p>
			<ul>
				<li lang="en-GB"><strong class="source-inline" lang="">rating</strong></li>
				<li lang="en-GB"><strong class="source-inline" lang="">metadata</strong></li>
				<li lang="en-GB"><strong class="source-inline" lang="">movie</strong></li>
			</ul>
			<p lang="en-GB">Throughout the book, I will use the directory paths relative to the application directory you’ve created, so when you see a directory or filename, assume it is stored in the app directory you chose for this.</p>
			<p lang="en-GB">From the <em class="italic" lang="">Project structure</em> section, we know that the logic containing the <strong class="source-inline" lang="">main</strong> function generally resides in the <strong class="source-inline" lang="">cmd</strong> directory. We will use this approach in our microservices—for example, the main file for the rating service would be called <strong class="source-inline" lang="">rating/cmd/main.go</strong>.</p>
			<p lang="en-GB">Each service may contain one or multiple packages related to the following logical roles:</p>
			<ul>
				<li lang="en-GB">API handlers</li>
				<li lang="en-GB">Business/application logic</li>
				<li lang="en-GB">Database logic</li>
				<li lang="en-GB">Interaction with other services</li>
			</ul>
			<p lang="en-GB">Note that handler and business/application logic are separate, even though the primary purpose of the application may be to handle the API requests. This is not absolutely necessary, but it’s a relatively good practice to separate the business logic from the API handling layer. This way, if you migrate from one type of API to another (for example, from HTTP to gRPC), or support both, you don’t need to implement the same logic twice or rewrite it. Instead, you would just call the business logic from your handler, keeping the handler as simple as possible and making its primary purpose to pass the requests to the relevant interfaces.</p>
			<p lang="en-GB">We can illustrate this <a id="_idIndexMarker070"/>relationship with the help of a diagram:</p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/Figure_2.2_B18865.jpg" alt="Figure 2.2 – Layers of a service&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Layers of a service</p>
			<p lang="en-GB">As you can <a id="_idIndexMarker071"/>see in the diagram, the API handler does not access the database directly. Instead, the database access is performed on a business logic layer.</p>
			<p lang="en-GB">There is no convention in the Go community on how to call packages serving these purposes, so we are free to choose the names for our packages providing such logic. It is, however, important that you keep these names consistent across all your microservices, so let’s align on a common naming convention for these types of packages.</p>
			<p lang="en-GB">In this book, we are going to use the following names for our application components:</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">controller</strong>: Business<a id="_idIndexMarker072"/> logic</li>
				<li lang="en-GB"><strong class="bold" lang="">gateway</strong>: Logic<a id="_idIndexMarker073"/> for interacting with other services</li>
				<li lang="en-GB"><strong class="bold" lang="">handler</strong>: API <a id="_idIndexMarker074"/>handlers</li>
				<li lang="en-GB"><strong class="bold" lang="">repository</strong>: Database <a id="_idIndexMarker075"/>logic</li>
			</ul>
			<p lang="en-GB">Now, since we are aligned on the naming, let’s proceed to the last step of setting up our project. Execute this command in the application root directory:</p>
			<pre class="source-code" lang="en-GB">
go mod init movieexample.com</pre>
			<p lang="en-GB">This <a id="_idIndexMarker076"/>command creates a Go module called <strong class="source-inline" lang="">movieexample.com</strong>. A Go module is a collection of related packages stored in a file tree. They help manage dependencies for your project, and we are going to use this feature in all the chapters.</p>
			<p lang="en-GB">Now, we can proceed to code scaffolding for our first microservice.</p>
			<h2 id="_idParaDest-47" lang="en-GB"><a id="_idTextAnchor047"/>Movie metadata service</h2>
			<p lang="en-GB">Let’s<a id="_idIndexMarker077"/> summarize<a id="_idIndexMarker078"/> the logic of the movie metadata service:</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">API</strong>: Get metadata for a movie</li>
				<li lang="en-GB"><strong class="bold" lang="">Database</strong>: Movie metadata database</li>
				<li lang="en-GB"><strong class="bold" lang="">Interacts with services</strong>: None</li>
				<li lang="en-GB"><strong class="bold" lang="">Data model type</strong>: Movie metadata</li>
			</ul>
			<p lang="en-GB">This logic would translate into the following packages:</p>
			<ul>
				<li lang="en-GB"><strong class="source-inline" lang="">cmd</strong>: Contains the main function for starting the service</li>
				<li lang="en-GB"><strong class="source-inline" lang="">controller</strong>: Our service logic (read the movie metadata)</li>
				<li lang="en-GB"><strong class="source-inline" lang="">handler</strong>: API handler for a service</li>
				<li lang="en-GB"><strong class="source-inline" lang="">repository</strong>: Logic for accessing the movie metadata database</li>
			</ul>
			<p lang="en-GB">Let’s store the logic of our service in a directory called <strong class="source-inline" lang="">metadata</strong>. Following the conventions we described earlier in the chapter, the executable code containing the main file is going to be stored in the <strong class="source-inline" lang="">cmd</strong> package. All code that we are not going to export will be stored in the <strong class="source-inline" lang="">internal</strong> directory and this will include most of our applications. The exported structures will reside in the <strong class="source-inline" lang="">pkg</strong> directory.</p>
			<p lang="en-GB">Applying the rules that<a id="_idIndexMarker079"/> we just described, we are going to structure our packages in the following way:</p>
			<ul>
				<li lang="en-GB"><strong class="source-inline" lang="">metadata/cmd</strong></li>
				<li lang="en-GB"><strong class="source-inline" lang="">metadata/internal/controller</strong></li>
				<li lang="en-GB"><strong class="source-inline" lang="">metadata/internal/handler</strong></li>
				<li lang="en-GB"><strong class="source-inline" lang="">metadata/internal/repository</strong></li>
				<li lang="en-GB"><strong class="source-inline" lang="">metadata/pkg</strong></li>
			</ul>
			<p lang="en-GB">Once you <a id="_idIndexMarker080"/>have created the directories listed here, let’s proceed to implement the code for our microservice.</p>
			<h3 lang="en-GB">Model</h3>
			<p lang="en-GB">First, we are going to <a id="_idIndexMarker081"/>implement the structure for the movie metadata. Inside the <strong class="source-inline" lang="">metadata/pkg</strong> directory, create a <strong class="source-inline" lang="">metadata.go</strong> file using the following code:</p>
			<pre class="source-code" lang="en-GB">
package model
// Metadata defines the movie metadata.
type Metadata struct {
    ID          string `json:"id"`
    Title       string `json:"title"`
    Description string `json:"description"`
    Director    string `json:"director"`
}</pre>
			<p lang="en-GB">This structure is going to be used by the callers of our service. It includes JSON annotations, which we are going to use later in this chapter.</p>
			<h3 lang="en-GB">Repository</h3>
			<p lang="en-GB">Now, let’s<a id="_idIndexMarker082"/> create the stub logic for handling the database logic. Inside the <strong class="source-inline" lang="">metadata/internal/repository</strong> directory, add an <strong class="source-inline" lang="">error.go</strong> file using the following code:</p>
			<pre class="source-code" lang="en-GB">
package repository
import "errors"
// ErrNotFound is returned when a requested record is not // found.
var ErrNotFound = errors.New("not found")</pre>
			<p lang="en-GB">This file defines an error for the case when the record is not found. We are going to use this error in our implementation.</p>
			<p lang="en-GB">In the next step, we are going to add the repository implementation. Even if you have some specific technology to work with for storing the data, it is often useful to provide more than one implementation of the database logic. I always find it useful to include an in-memory implementation of the database logic that can be used for testing and local development, reducing the need for any additional databases or extra libraries. I am going to illustrate how to do this.</p>
			<p lang="en-GB">Inside the <strong class="source-inline" lang="">metadata/internal/repository</strong> directory, create a directory called <strong class="source-inline" lang="">memory</strong> that will contain the in-memory implementation or our movie metadata database. Add a <strong class="source-inline" lang="">memory.go</strong> file to it, using the following code:</p>
			<pre class="source-code" lang="en-GB">
package memory
import (
    "context"
    "sync"
    "movieexample.com/metadata/internal/repository"
    "movieexample.com/metadata/pkg/model"
)
// Repository defines a memory movie metadata repository.
type Repository struct {
    sync.RWMutex
    data map[string]*model.Metadata
}
// New creates a new memory repository.
func New() *Repository {
    return &amp;Repository{data: map[string]*model.Metadata{}}
}
// Get retrieves movie metadata for by movie id.
func (r *Repository) Get(_ context.Context, id string) (*model.Metadata, error) {
    r.RLock()
    defer r.RUnlock()
    m, ok := r.data[id]
    if !ok {
         return nil, repository.ErrNotFound
    }
    return m, nil
}
// Put adds movie metadata for a given movie id.
func (r *Repository) Put(_ context.Context, id string, metadata *model.Metadata) error {
    r.Lock()
    defer r.Unlock()
    r.data[id] = metadata
    return nil
}</pre>
			<p lang="en-GB">Let’s highlight <a id="_idIndexMarker083"/>some aspects of the code we’ve just added:</p>
			<ul>
				<li lang="en-GB">First, we called the <strong class="source-inline" lang="">Repository</strong> structure because it provides a good name to the users when combined with the name of its package— <strong class="source-inline" lang="">memory.Repository</strong>.</li>
				<li lang="en-GB">Second, we used the exported <strong class="source-inline" lang="">ErrNotFound</strong> that we previously defined, so callers can check their code. It is usually good practice to do so because it allows the developers to check for a specific error in their code. We will illustrate how to write tests for it in <a href="B18865_08.xhtml#_idTextAnchor109"><em class="italic" lang="">Chapter 8</em></a>.</li>
				<li lang="en-GB">Additionally, the function creating the repository is called <strong class="source-inline" lang="">New</strong>. This is often a good name for short packages when there is just one type being created.</li>
				<li lang="en-GB">Our <strong class="source-inline" lang="">Get</strong> and <strong class="source-inline" lang="">Put</strong> functions accept context as the first argument. We mentioned this approach in the <em class="italic" lang="">Writing idiomatic Go code</em> section—all functions performing I/O operations must accept context.</li>
				<li lang="en-GB">Our implementation is using a <strong class="source-inline" lang="">sync.RWMutex</strong> structure to protect against concurrent writes and reads</li>
			</ul>
			<p lang="en-GB">Now, let’s move on to the business logic layer.</p>
			<h3 lang="en-GB">Controller</h3>
			<p lang="en-GB">The next step is to <a id="_idIndexMarker084"/>add a controller to encapsulate our business logic. Even if your logic is trivial, it is still a good practice to keep it separate from the handler from the beginning. This will help you avoid further changes and, more importantly, keep the structure of your applications consistent.</p>
			<p lang="en-GB">Inside the <strong class="source-inline" lang="">metadata/internal/controller</strong> package, add a directory called <strong class="source-inline" lang="">metadata</strong>. Inside it, add a <strong class="source-inline" lang="">controller.go</strong> file with the following logic:</p>
			<pre class="source-code" lang="en-GB">
package metadata
import (
    "context"
    "errors"
    "movieexample.com/metadata/internal/repository"
    "movieexample.com/metadata/pkg/model"
)
// ErrNotFound is returned when a requested record is not // found.
var ErrNotFound = errors.New("not found")
type metadataRepository interface {
    Get(ctx context.Context, id string) (*model.Metadata, error)
}
// Controller defines a metadata service controller.
type Controller struct {
    repo metadataRepository
}
// New creates a metadata service controller.
func New(repo metadataRepository) *Controller {
    return &amp;Controller{repo}
}
// Get returns movie metadata by id.
func (c *Controller) Get(ctx context.Context, id string) (*model.Metadata, error) {
    res, err := c.repo.Get(ctx, id)
    if err != nil &amp;&amp; errors.Is(err, repository.ErrNotFound) {
        return nil, ErrNotFound
    }
    return res, err
}</pre>
			<p lang="en-GB">The controller<a id="_idIndexMarker085"/> we created is currently just a wrapper around the repository. However, the controller will generally have more logic, so it is preferable to keep it separate.</p>
			<h3 lang="en-GB">Handler</h3>
			<p lang="en-GB">Now, we <a id="_idIndexMarker086"/>are going to create the API handler. Inside the <strong class="source-inline" lang="">metadata/internal/handler</strong> directory, create a directory called <strong class="source-inline" lang="">http</strong>. Inside  it, create a file called <strong class="source-inline" lang="">http.go</strong> with the following logic:</p>
			<pre class="source-code" lang="en-GB">
package http
import (
    "encoding/json"
    "errors"
    "log"
    "net/http"
    "movieexample.com/metadata/internal/controller/metadata"
    "movieexample.com/metadata/internal/repository"
)
// Handler defines a movie metadata HTTP handler.
type Handler struct {
    ctrl *metadata.Controller
}
// New creates a new movie metadata HTTP handler.
func New(ctrl *metadata.Controller) *Handler {
    return &amp;Handler{ctrl}
}</pre>
			<p lang="en-GB">Now, let’s implement<a id="_idIndexMarker087"/> the logic for retrieving movie metadata:</p>
			<pre class="source-code" lang="en-GB">
// GetMetadata handles GET /metadata requests.
func (h *Handler) GetMetadata(w http.ResponseWriter, req *http.Request) {
    id := req.FormValue("id")
    if id == "" {
        w.WriteHeader(http.StatusBadRequest)
        return
    }
    ctx := req.Context()
    m, err := h.ctrl.Get(ctx, id)
    if err != nil &amp;&amp; errors.Is(err, repository.ErrNotFound) {
        w.WriteHeader(http.StatusNotFound)
        return
    } else if err != nil {
        log.Printf("Repository get error: %v\n", err)
        w.WriteHeader(http.StatusInternalServerError)
        return
    }
    if err := json.NewEncoder(w).Encode(m); err != nil {
        log.Printf("Response encode error: %v\n", err)
    }
}</pre>
			<p lang="en-GB">The handler <a id="_idIndexMarker088"/>we just created uses our repository to retrieve the information and return it in JSON format. We chose JSON here just for simplicity. In <a href="B18865_04.xhtml#_idTextAnchor067"><em class="italic" lang="">Chapter 4</em></a>, we are going to cover more data formats and illustrate how they can benefit your applications.</p>
			<p lang="en-GB">You may notice that we have called the package for our HTTP handler <strong class="source-inline" lang="">http</strong>. There is a trade-off here—while we are certainly colliding with its namesake standard library package, we get a pretty descriptive <strong class="source-inline" lang="">http.Handler</strong> exported name. Since our package is going to be used internally, this trade-off is reasonable.</p>
			<h3 lang="en-GB">Main file</h3>
			<p lang="en-GB">Now, since <a id="_idIndexMarker089"/>we have created both a database and an API handler, let’s create the executable for the metadata service. Inside the <strong class="source-inline" lang="">metadata/cmd</strong> directory, create the <strong class="source-inline" lang="">main.go</strong> file and add the following code:</p>
			<pre class="source-code" lang="en-GB">
package main
import (
    "log"
    "net/http"
    "movieexample.com/metadata/internal/controller/metadata"
    httphandler "movieexample.com/metadata/internal/handler/http"
    "movieexample.com/metadata/internal/repository/memory"
)
func main() {
    log.Println("Starting the movie metadata service")
    repo := memory.New()
    ctrl := metadata.New(repo)
    h := httphandler.New(ctrl)
    http.Handle("/metadata", http.HandlerFunc(h.GetMetadata))
    if err := http.ListenAndServe(":8081", nil); err != nil {
        panic(err)
    }
}</pre>
			<p lang="en-GB">The function <a id="_idIndexMarker090"/>we just created initializes all structures of our service and starts the <strong class="source-inline" lang="">http</strong> API handler we implemented earlier. The service is ready to process user requests, so let’s move on to the other services.</p>
			<h3 lang="en-GB">Rating service</h3>
			<p lang="en-GB">Let’s summarize the logic <a id="_idIndexMarker091"/>of the rating service:</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">API</strong>: Get the aggregated rating for a record and write a rating.</li>
				<li lang="en-GB"><strong class="bold" lang="">Database</strong>: Rating database.</li>
				<li lang="en-GB"><strong class="bold" lang="">Interacts with services</strong>: None.</li>
				<li lang="en-GB"><strong class="bold" lang="">Data model type</strong>: Rating.</li>
			</ul>
			<p lang="en-GB">This logic would translate into the following packages:</p>
			<ul>
				<li lang="en-GB"><strong class="source-inline" lang="">cmd</strong>: Contains the main function for starting the service</li>
				<li lang="en-GB"><strong class="source-inline" lang="">controller</strong>: Our service logic (read and write ratings)</li>
				<li lang="en-GB"><strong class="source-inline" lang="">handler</strong>: API handler for a service</li>
				<li lang="en-GB"><strong class="source-inline" lang="">repository</strong>: Logic for accessing the movie metadata database</li>
			</ul>
			<p lang="en-GB">We are going to use exactly the same directory structure as we used for the metadata service:</p>
			<ul>
				<li lang="en-GB"><strong class="source-inline" lang="">rating/cmd</strong></li>
				<li lang="en-GB"><strong class="source-inline" lang="">rating/internal/controller</strong></li>
				<li lang="en-GB"><strong class="source-inline" lang="">rating/internal/handler</strong></li>
				<li lang="en-GB"><strong class="source-inline" lang="">rating/internal/repository</strong></li>
				<li lang="en-GB"><strong class="source-inline" lang="">rating/pkg</strong></li>
			</ul>
			<p lang="en-GB">Once you have created these directories, let’s move on to the implementation of the service.</p>
			<h3 lang="en-GB">Model</h3>
			<p lang="en-GB">Create a<a id="_idIndexMarker092"/> model directory inside <strong class="source-inline" lang="">rating/pkg</strong> and create a <strong class="source-inline" lang="">rating.go</strong> file, using the following code:</p>
			<pre class="source-code" lang="en-GB">
package model
// RecordID defines a record id. Together with RecordType
// identifies unique records across all types.
type RecordID string
// RecordType defines a record type. Together with RecordID
// identifies unique records across all types.
type RecordType string
// Existing record types.
const (
    RecordTypeMovie = RecordType("movie")
)
// UserID defines a user id.
type UserID string
// RatingValue defines a value of a rating record.
type RatingValue int
// Rating defines an individual rating created by a user for  // some record.
type Rating struct {
    RecordID   string      `json:"recordId"`
    RecordType string      `json:"recordType"`
    UserID     UserID      `json:"userId"`
    Value      RatingValue `json:"value"`
}</pre>
			<p lang="en-GB">The file <a id="_idIndexMarker093"/>contains the model for our rating service, which is also going to be used by other services interacting with it. Note that we created separate types, <strong class="source-inline" lang="">RecordID</strong>, <strong class="source-inline" lang="">RecordType</strong>, and <strong class="source-inline" lang="">UserID</strong>. This will help us with readability and add extra type protection, as you will see in the implementation.</p>
			<h3 lang="en-GB">Repository</h3>
			<p lang="en-GB">Create<a id="_idIndexMarker094"/> the in-memory implementation for our rating repository inside the <strong class="source-inline" lang="">rating/internal/repository/memory/memory.go</strong> file:</p>
			<pre class="source-code" lang="en-GB">
package memory
import (
    "context"
    "movieexample.com/rating/internal/repository"
    "movieexample.com/rating/pkg/model"
)
// Repository defines a rating repository.
type Repository struct {
    data map[model.RecordType]map[model.RecordID][]model.Rating
}
// New creates a new memory repository.
func New() *Repository {
    return &amp;Repository{map[model.RecordType]map[model.RecordID][]model.Rating{}}
}</pre>
			<p lang="en-GB">Then, add <a id="_idIndexMarker095"/>an implementation of the <strong class="source-inline" lang="">Get</strong> function to it, as shown in the following code block:</p>
			<pre class="source-code" lang="en-GB">
// Get retrieves all ratings for a given record.
func (r *Repository) Get(ctx context.Context, recordID model.RecordID, recordType model.RecordType) ([]model.Rating, error) {
    if _, ok := r.data[recordType]; !ok {
        return nil, repository.ErrNotFound
    }
    if ratings, ok := r.data[recordType][recordID]; !ok || len(ratings) == 0 {
        return nil, repository.ErrNotFound
    }
    return r.data[recordType][recordID], nil
}</pre>
			<p lang="en-GB">Finally, let’s implement a <strong class="source-inline" lang="">Put</strong> function inside it, as shown:</p>
			<pre class="source-code" lang="en-GB">
// Put adds a rating for a given record.
func (r *Repository) Put(ctx context.Context, recordID model.RecordID, recordType model.RecordType, rating *model.Rating) error {
    if _, ok := r.data[recordType]; !ok {
        r.data[recordType] = map[model.RecordID][]model.Rating{}
    }
    r.data[recordType][recordID] =
append(r.data[recordType][recordID], *rating)
    return nil
}</pre>
			<p lang="en-GB">The <a id="_idIndexMarker096"/>preceding implementation is using a nested map to store all records inside it. If we didn’t define separate types, <strong class="source-inline" lang="">RatingID</strong>, <strong class="source-inline" lang="">RatingType</strong>, and <strong class="source-inline" lang="">UserID</strong>, it would be harder to understand the types of the keys in the map because we would be using primitives such as <strong class="source-inline" lang="">string</strong> and <strong class="source-inline" lang="">int</strong>, which are less self-descriptive.</p>
			<h3 lang="en-GB">Controller</h3>
			<p lang="en-GB">Let’s add <a id="_idIndexMarker097"/>a controller for our rating service. In the <strong class="source-inline" lang="">rating/internal/controller/rating</strong> package, create a <strong class="source-inline" lang="">controller.go</strong> file:</p>
			<pre class="source-code" lang="en-GB">
package rating
import (
    "context"
    "errors"
    "movieexample.com/rating/internal/repository"
    "movieexample.com/rating/pkg/model"
)
// ErrNotFound is returned when no ratings are found for a
// record.
var ErrNotFound = errors.New("ratings not found for a record")
type ratingRepository interface {
    Get(ctx context.Context, recordID model.RecordID, recordType model.RecordType) ([]model.Rating, error)
    Put(ctx context.Context, recordID model.RecordID, recordType model.RecordType, rating *model.Rating) error
}
// Controller defines a rating service controller.
type Controller struct {
    repo ratingRepository
}
// New creates a rating service controller.
func New(repo ratingRepository) *Controller {
    return &amp;Controller{repo}
}</pre>
			<p lang="en-GB">Let’s add <a id="_idIndexMarker098"/>functions for writing and getting an aggregated rating:</p>
			<pre class="source-code" lang="en-GB">
// GetAggregatedRating returns the aggregated rating for a
// record or ErrNotFound if there are no ratings for it.
func (c *Controller) GetAggregatedRating(ctx context.Context, recordID model.RecordID, recordType model.RecordType) (float64, error) {
    ratings, err := c.repo.Get(ctx, recordID, recordType)
    if err != nil &amp;&amp; err == repository.ErrNotFound {
        return 0, ErrNotFound
    } else if err != nil {
        return 0, err
    }
    sum := float64(0)
    for _, r := range ratings {
        sum += float64(r.Value)
    }
    return sum / float64(len(ratings)), nil
}
// PutRating writes a rating for a given record.
func (c *Controller) PutRating(ctx context.Context, recordID model.RecordID, recordType model.RecordType, rating *model.Rating) error {
    return c.repo.Put(ctx, recordID, recordType, rating)
}</pre>
			<p lang="en-GB">In this example, it is <a id="_idIndexMarker099"/>easy to see how the controller logic is different from the repository one. The repository provides an interface to get all ratings for a record and the controller implements the aggregation logic for them.</p>
			<h3 lang="en-GB">Handler</h3>
			<p lang="en-GB">Let’s implement<a id="_idIndexMarker100"/> the service handler in the <strong class="source-inline" lang="">rating/internal/handler/http/http.go</strong> file, using the following code:</p>
			<pre class="source-code" lang="en-GB">
package http
import (
    "encoding/json"
    "errors"
    "log"
    "net/http"
    "strconv"
    "movieexample.com/rating/internal/controller"
    "movieexample.com/rating/pkg/model"
)
// Handler defines a rating service controller.
type Handler struct {
    ctrl *rating.Controller
}
// New creates a new rating service HTTP handler.
func New(ctrl *rating.Controller) *Handler {
    return &amp;Handler{ctrl}
}</pre>
			<p lang="en-GB">Now, let’s add a function for handling HTTP requests to our service:</p>
			<pre class="source-code" lang="en-GB">
// Handle handles PUT and GET /rating requests.
func (h *Handler) Handle(w http.ResponseWriter, req *http.Request) {
    recordID := model.RecordID(req.FormValue("id"))
    if recordID == "" {
        w.WriteHeader(http.StatusBadRequest)
        return
    }
    recordType := model.RecordType(req.FormValue("type"))
    if recordType == "" {
        w.WriteHeader(http.StatusBadRequest)
        return
    }
    switch req.Method {
    case http.MethodGet:
        v, err := h.ctrl.GetAggregatedRating(req.Context(), recordID, recordType)
        if err != nil &amp;&amp; errors.Is(err, rating.ErrNotFound) {
            w.WriteHeader(http.StatusNotFound)
            return
        }
        if err := json.NewEncoder(w).Encode(v); err != nil {
            log.Printf("Response encode error: %v\n", err)
        }
    case http.MethodPut:
        userID := model.UserID(req.FormValue("userId"))
        v, err := strconv.ParseFloat(req.FormValue("value"), 64)
        if err != nil {
            w.WriteHeader(http.StatusBadRequest)
            return
        }
        if err := h.ctrl.PutRating(req.Context(), recordID, recordType, &amp;model.Rating{UserID: userID, Value: model.RatingValue(v)}); err != nil {
            log.Printf("Repository put error: %v\n", err)
            w.WriteHeader(http.StatusInternalServerError)
        }
    default:
        w.WriteHeader(http.StatusBadRequest)
    }
}</pre>
			<p lang="en-GB">The<a id="_idIndexMarker101"/> handler we implemented handles both <strong class="source-inline" lang="">GET</strong> and <strong class="source-inline" lang="">PUT</strong> requests. Note the way we handle some special cases such as an empty <strong class="source-inline" lang="">id</strong> value from the request—in that case, we return a special error code, <strong class="source-inline" lang="">http.StatusBadRequest</strong>, indicating that the API request was invalid. If the record is not found, we return <strong class="source-inline" lang="">http.StatusNotFound</strong>, and if we encounter any unexpected errors when accessing our database, we return <strong class="source-inline" lang="">http.StatusInternalServerError</strong>.</p>
			<p lang="en-GB">Using such standard HTTP error codes helps the clients to differentiate between the types of errors and implement the logic for detecting and correctly handling such issues.</p>
			<h3 lang="en-GB">Main</h3>
			<p lang="en-GB">Let’s <a id="_idIndexMarker102"/>write the main file for our service. In <strong class="source-inline" lang="">rating/cmd/main.go</strong>, write the following logic:</p>
			<pre class="source-code" lang="en-GB">
package main
import (
    "log"
    "net/http"
    "movieexample.com/rating/internal/controller/rating"
    httphandler "movieexample.com/rating/internal/handler/http"
    "movieexample.com/rating/internal/repository/memory"
)
func main() {
    log.Println("Starting the rating service")
    repo := memory.New()
    ctrl := rating.New(repo)
    h := httphandler.New(ctrl)
    http.Handle("/rating", http.HandlerFunc(h.Handle))
    if err := http.ListenAndServe(":8082", nil); err != nil {
        panic(err)
    }
}</pre>
			<p lang="en-GB">The <strong class="source-inline" lang="">main</strong> function we created is similar to the main function of the metadata service; it initializes all<a id="_idIndexMarker103"/> components of a service and starts an HTTP handler.</p>
			<p lang="en-GB">Now, we are ready to implement our last service.</p>
			<h2 id="_idParaDest-48" lang="en-GB"><a id="_idTextAnchor048"/>Movie service</h2>
			<p lang="en-GB">Let’s summarize<a id="_idIndexMarker104"/> the<a id="_idIndexMarker105"/> logic of the movie service:</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">API</strong>: Get the details for a movie, including the aggregated movie rating and movie metadata.</li>
				<li lang="en-GB"><strong class="bold" lang="">Database</strong>: None.</li>
				<li lang="en-GB"><strong class="bold" lang="">Interacts with services</strong>: Movie metadata and rating.</li>
				<li lang="en-GB"><strong class="bold" lang="">Data model type</strong>: Movie details.</li>
			</ul>
			<p lang="en-GB">This logic would translate into the following packages:</p>
			<ul>
				<li lang="en-GB"><strong class="source-inline" lang="">cmd</strong>: Contains the main function for starting the service</li>
				<li lang="en-GB"><strong class="source-inline" lang="">controller</strong>: Our service logic (read rating and metadata)</li>
				<li lang="en-GB"><strong class="source-inline" lang="">gateway</strong>: Logic for calling the other services</li>
				<li lang="en-GB"><strong class="source-inline" lang="">handler</strong>: API handler for a service</li>
			</ul>
			<p lang="en-GB">The <a id="_idIndexMarker106"/>directory structure is as follows:</p>
			<ul>
				<li lang="en-GB"><strong class="source-inline" lang="">movie/cmd</strong></li>
				<li lang="en-GB"><strong class="source-inline" lang="">movie/internal/controller</strong></li>
				<li lang="en-GB"><strong class="source-inline" lang="">movie/internal/gateway</strong></li>
				<li lang="en-GB"><strong class="source-inline" lang="">movie/internal/handler</strong></li>
				<li lang="en-GB"><strong class="source-inline" lang="">movie/pkg</strong></li>
			</ul>
			<p lang="en-GB">Once you have created these directories, let’s move on to the implementation of the service.</p>
			<h3 lang="en-GB">Model</h3>
			<p lang="en-GB">Create<a id="_idIndexMarker107"/> a <strong class="source-inline" lang="">model.go</strong> file in the <strong class="source-inline" lang="">movie/pkg/model</strong> directory and write the following logic:</p>
			<pre class="source-code" lang="en-GB">
package model
import "movieexample.com/metadata/pkg/model"
// MovieDetails includes movie metadata its aggregated
// rating.
type MovieDetails struct {
    Rating   *float64    `json:"rating,omitEmpty"`
    Metadata model.Metadata `json:"metadata`
}</pre>
			<p lang="en-GB">Note that the file imports the model package of a metadata service containing the <strong class="source-inline" lang="">Metadata</strong> structure that we can reuse in our service.</p>
			<h3 lang="en-GB">Gateways</h3>
			<p lang="en-GB">In the <a id="_idIndexMarker108"/>previous examples, the services did not interact with each other and just provided an API for this. The movie service won’t access any database by itself but instead is going to interact with both the movie metadata and the rating service.</p>
			<p lang="en-GB">Let’s create the logic for interacting with both services.</p>
			<p lang="en-GB">First, let’s create an error that we are going to use in our gateways. In the <strong class="source-inline" lang="">movie/internal/gateway</strong> package, create an <strong class="source-inline" lang="">error.go</strong> file, using the following code block:</p>
			<pre class="source-code" lang="en-GB">
package gateway
import "errors"
// ErrNotFound is returned when the data is not found.
var ErrNotFound = errors.New("not found")</pre>
			<p lang="en-GB">Now, let’s write<a id="_idIndexMarker109"/> an HTTP gateway for the movie metadata service. In the <strong class="source-inline" lang="">movie/gateway/metadata/http</strong> directory, create a <strong class="source-inline" lang="">metadata.go</strong> file:</p>
			<pre class="source-code" lang="en-GB">
package http
import (
    "context"
    "encoding/json"
    "fmt"
    "net/http"
    "movieexample.com/metadata/pkg/model"
    "movieexample.com/movie/internal/gateway"
)
// Gateway defines a movie metadata HTTP gateway.
type Gateway struct {
    addr string
}
// New creates a new HTTP gateway for a movie metadata
// service.
func New(addr string) *Gateway {
    return &amp;Gateway{addr}
}</pre>
			<p lang="en-GB">Let’s<a id="_idIndexMarker110"/> implement a <strong class="source-inline" lang="">Get</strong> function in it:</p>
			<pre class="source-code" lang="en-GB">
// Get gets movie metadata by a movie id.
func (g *Gateway) Get(ctx context.Context, id string) (*model.Metadata, error) {
    req, err := http.NewRequest(http.MethodGet, g.addr+"/metadata", nil)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    values := req.URL.Query()
    values.Add("id", id)
    req.URL.RawQuery = values.Encode()
    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    if resp.StatusCode == http.StatusNotFound {
        return nil, gateway.ErrNotFound
    } else if resp.StatusCode/100 != 2 {
        return nil, fmt.Errorf("non-2xx response: %v", resp)
    }
    var v *model.Metadata
    if err := json.NewDecoder(resp.Body).Decode(&amp;v); err != nil {
        return nil, err
    }
    return v, nil
}</pre>
			<p lang="en-GB">Now, let’s write <a id="_idIndexMarker111"/>an HTTP gateway for the rating service. In the <strong class="source-inline" lang="">movie/gateway/rating/http</strong> directory, create a <strong class="source-inline" lang="">rating.go</strong> file:</p>
			<pre class="source-code" lang="en-GB">
package http
import (
    "context"
    "encoding/json"
    "fmt"
    "net/http"
    "movieexample.com/movie/internal/gateway"
    "movieexample.com/rating/pkg/model"
)
// Gateway defines an HTTP gateway for a rating service.
type Gateway struct {
    addr string
}
// New creates a new HTTP gateway for a rating service.
func New(addr string) *Gateway {
    return &amp;Gateway{addr}
}</pre>
			<p lang="en-GB">Let’s add logic for<a id="_idIndexMarker112"/> getting the aggregated rating:</p>
			<pre class="source-code" lang="en-GB">
// GetAggregatedRating returns the aggregated rating for a
// record or ErrNotFound if there are no ratings for it.
func (g *Gateway) GetAggregatedRating(ctx context.Context, recordID model.RecordID, recordType model.RecordType) (float64, error) {
    req, err := http.NewRequest(http.MethodGet, g.addr+"/rating", nil)
    if err != nil {
        return 0, err
    }
    req = req.WithContext(ctx)
    values := req.URL.Query()
    values.Add("id", string(recordID))
    values.Add("type", fmt.Sprintf("%v", recordType))
    req.URL.RawQuery = values.Encode()
    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        return 0, err
    }
    defer resp.Body.Close()
    if resp.StatusCode == http.StatusNotFound {
        return 0, gateway.ErrNotFound
    } else if resp.StatusCode/100 != 2 {
        return 0, fmt.Errorf("non-2xx response: %v", resp)
    }
    var v float64
    if err := json.NewDecoder(resp.Body).Decode(&amp;v); err != nil {
        return 0, err
    }
    return v, nil
}</pre>
			<p lang="en-GB">Finally, let’s <a id="_idIndexMarker113"/>add a function for handling a rating creation request:</p>
			<pre class="source-code" lang="en-GB">
// PutRating writes a rating.
func (g *Gateway) PutRating(ctx context.Context, recordID model.RecordID, recordType model.RecordType, rating *model.Rating) error {
    req, err := http.NewRequest(http.MethodPut, g.addr+"/rating", nil)
    if err != nil {
        return err
    }
    req = req.WithContext(ctx)
    values := req.URL.Query()
    values.Add("id", string(recordID))
    values.Add("type", fmt.Sprintf("%v", recordType))
    values.Add("userId", string(rating.UserID))
    values.Add("value", fmt.Sprintf("%v", rating.Value))
    req.URL.RawQuery = values.Encode()
    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()
    if resp.StatusCode/100 != 2 {
        return fmt.Errorf("non-2xx response: %v", resp)
    }
    return nil
}</pre>
			<p lang="en-GB">At this point, we<a id="_idIndexMarker114"/> have both gateways and can implement the controller aggregating the data from them.</p>
			<h3 lang="en-GB">Controller</h3>
			<p lang="en-GB">In <a id="_idIndexMarker115"/>the <strong class="source-inline" lang="">movie/internal/controller/movie</strong> directory, create a <strong class="source-inline" lang="">controller.go</strong> file:</p>
			<pre class="source-code" lang="en-GB">
package movie
import (
    "context"
    "errors"
    metadatamodel "movieexample.com/metadata/pkg/model"
    "movieexample.com/movie/internal/gateway"
    "movieexample.com/movie/pkg/model"
    ratingmodel "movieexample.com/rating/pkg/model"
)
// ErrNotFound is returned when the movie metadata is not
// found.
var ErrNotFound = errors.New("movie metadata not found")</pre>
			<p lang="en-GB">Let’s define <a id="_idIndexMarker116"/>the interfaces for the services we will be calling:</p>
			<pre class="source-code" lang="en-GB">
type ratingGateway interface {
    GetAggregatedRating(ctx context.Context, recordID ratingmodel.RecordID, recordType ratingmodel.RecordType) (float64, error)
    PutRating(ctx context.Context, recordID ratingmodel.RecordID, recordType ratingmodel.RecordType, rating *ratingmodel.Rating) error
}
type metadataGateway interface {
    Get(ctx context.Context, id string) (*metadatamodel.Metadata, error)
}</pre>
			<p lang="en-GB">Now, we can define our service controller:</p>
			<pre class="source-code" lang="en-GB">
// Controller defines a movie service controller.
type Controller struct {
    ratingGateway   ratingGateway
    metadataGateway metadataGateway
}
// New creates a new movie service controller.
func New(ratingGateway ratingGateway, metadataGateway metadataGateway) *Controller {
    return &amp;Controller{ratingGateway, metadataGateway}
}</pre>
			<p lang="en-GB">Finally, let’s implement <a id="_idIndexMarker117"/>the function for getting the movie details, including both its rating and metadata:</p>
			<pre class="source-code" lang="en-GB">
// Get returns the movie details including the aggregated
// rating and movie metadata.
// Get returns the movie details including the aggregated rating and movie metadata.
func (c *Controller) Get(ctx context.Context, id string) (*model.MovieDetails, error) {
    metadata, err := c.metadataGateway.Get(ctx, id)
    if err != nil &amp;&amp; errors.Is(err, gateway.ErrNotFound) {
        return nil, ErrNotFound
    } else if err != nil {
        return nil, err
    }
    details := &amp;model.MovieDetails{Metadata: *metadata}
    rating, err := c.ratingGateway.GetAggregatedRating(ctx, ratingmodel.RecordID(id), ratingmodel.RecordTypeMovie)
    if err != nil &amp;&amp; !errors.Is(err, gateway.ErrNotFound) {
        // Just proceed in this case, it's ok not to have ratings yet.
    } else if err != nil {
        return nil, err
    } else {
        details.Rating = &amp;rating
    }
    return details, nil
}</pre>
			<p lang="en-GB">Note that <a id="_idIndexMarker118"/>we redefine <strong class="source-inline" lang="">ErrNotFound</strong> in different components. While we could have just exported it to some shared package, sometimes it is better to keep it independent. Otherwise, we may confuse one error for another (for example, rating not found or metadata not found).</p>
			<h3 lang="en-GB">Handler</h3>
			<p lang="en-GB">In<a id="_idIndexMarker119"/> the <strong class="source-inline" lang="">movie/internal/handler/http</strong> package, add the <strong class="source-inline" lang="">http.go</strong> file, using the following logic:</p>
			<pre class="source-code" lang="en-GB">
package http
import (
    "encoding/json"
    "errors"
    "log"
    "net/http"
    "movieexample.com/movie/internal/controller/movie"
)
// Handler defines a movie handler.
type Handler struct {
    ctrl *movie.Controller
}
// New creates a new movie HTTP handler.
func New(ctrl *movie.Controller) *Handler {
     return &amp;Handler{ctrl}
}
// GetMovieDetails handles GET /movie requests.
func (h *Handler) GetMovieDetails(w http.ResponseWriter, req *http.Request) {
    id := req.FormValue("id")
    details, err := h.ctrl.Get(req.Context(), id)
    if err != nil &amp;&amp; errors.Is(err, movie.ErrNotFound) {
        w.WriteHeader(http.StatusNotFound)
        return
    } else if err != nil {
        log.Printf("Repository get error: %v\n", err)
        w.WriteHeader(http.StatusInternalServerError)
        return
    }
    if err := json.NewEncoder(w).Encode(details); err != nil {
        log.Printf("Response encode error: %v\n", err)
    }
}</pre>
			<p lang="en-GB">Now, we are finally<a id="_idIndexMarker120"/> ready to write a main file for the movie service.</p>
			<h3 lang="en-GB">Main file</h3>
			<p lang="en-GB">In the <strong class="source-inline" lang="">movie/cmd</strong> package, create a <strong class="source-inline" lang="">main.go</strong> file, using <a id="_idIndexMarker121"/>the following code block:</p>
			<pre class="source-code" lang="en-GB">
package main
import (
    "log"
    "net/http"
    "movieexample.com/movie/internal/controller/movie"
    metadatagateway "movieexample.com/movie/internal/gateway/metadata/http"
    ratinggateway "movieexample.com/movie/internal/gateway/rating/http"
    httphandler "movieexample.com/movie/internal/handler/http"
)
func main() {
    log.Println("Starting the movie service")
    metadataGateway := metadatagateway.New("localhost:8081")
    ratingGateway := ratinggateway.New("localhost:8082")
    ctrl := movie.New(ratingGateway, metadataGateway)
    h := httphandler.New(ctrl)
    http.Handle("/movie", http.HandlerFunc(h.GetMovieDetails))
    if err := http.ListenAndServe(":8083", nil); err != nil {
        panic(err)
    }
}</pre>
			<p lang="en-GB">At this <a id="_idIndexMarker122"/>point, we have the logic for all three services. Note that we used static service addresses, <strong class="source-inline" lang="">localhost:8081</strong>, <strong class="source-inline" lang="">localhost:8082</strong>, and <strong class="source-inline" lang="">localhost:8083</strong>, in this example. This allows you to run the services locally; however, this would not work if we deployed our services to the cloud or any other deployment platform. In the next chapter, we are going to cover this aspect and continue improving our microservices. You can run the services we just created by executing this command inside the <strong class="source-inline" lang="">cmd</strong> directory of each service:</p>
			<pre class="source-code" lang="en-GB">
go run *.go</pre>
			<p lang="en-GB">Then, you can call the metadata service API using the following command:</p>
			<pre class="source-code" lang="en-GB">
curl localhost:8081?id=1</pre>
			<p lang="en-GB">You can call the rating service API using a similar command:</p>
			<pre class="source-code" lang="en-GB">
curl localhost:8082?id=1&amp;type=2</pre>
			<p lang="en-GB">Finally, you can call the movie service using the following command:</p>
			<pre class="source-code" lang="en-GB">
curl localhost:8083?id=1</pre>
			<p lang="en-GB">All of the preceding requests should return an HTTP 404 error, indicating that records are not found—we do not have any data yet, so this is expected.</p>
			<p lang="en-GB">At this point, we have illustrated how to bootstrap and manually test our example microservices and are ready to move on to the next chapter.</p>
			<h1 id="_idParaDest-49" lang="en-GB"><a id="_idTextAnchor049"/>Summary</h1>
			<p lang="en-GB">In this section, we have covered lots of topics, including the most important recommendations for writing Go applications and the standards for the project layout of Go applications. The knowledge we gained helped us during the code scaffolding of our microservices—we have tried to implement our microservice code in an idiomatic way as much as possible.</p>
			<p lang="en-GB">You have also learned how to split each of your microservices into multiple layers, each responsible for its own logic. We have illustrated how to separate the business logic from the code accessing the database, and how to separate the API handler logic from both, as well as from the logic performing remote calls between the services.</p>
			<p lang="en-GB">While the amount of information in this chapter is quite overwhelming, we have made a solid start and are ready to move on to more advanced topics. In the next chapter, we are going to see how the microservices we created can explore each other, so we can finally test them.</p>
			<h1 id="_idParaDest-50" lang="en-GB"><a id="_idTextAnchor050"/>Further reading</h1>
			<ul>
				<li lang="en-GB"><em class="italic" lang="">Effective Go</em>: <a href="https://go.dev/doc/effective_go">https://go.dev/doc/effective_go</a></li>
				<li lang="en-GB"><em class="italic" lang="">Go Code Review Comments</em>: <a href="https://github.com/golang/go/wiki/CodeReviewComments">https://github.com/golang/go/wiki/CodeReviewComments</a></li>
				<li lang="en-GB"><em class="italic" lang="">Project layout</em>: <a href="https://github.com/golang-standards/project-layout">https://github.com/golang-standards/project-layout</a></li>
				<li lang="en-GB"><em class="italic" lang="">Package names</em>: <a href="https://go.dev/blog/package-names">https://go.dev/blog/package-names</a></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer015">
			</div>
		</div>
	</body></html>