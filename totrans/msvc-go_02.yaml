- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scaffolding a Go Microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will finally start scaffolding our microservice code. The
    goal of this chapter is to establish a solid foundation for writing Go microservices
    and setting the right structure for future changes. While Go makes it relatively
    easy to write small applications, there are multiple challenges that engineers
    may face along the way, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to set the right project structure to make it easier to evolve and maintain
    the code base
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write idiomatic Go code that is going to be consistent with the largest
    Go code bases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to separate the components of a microservice and wire them together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we are going to address each of these challenges. First, you
    will be introduced to the key aspects of writing idiomatic and conventional Go
    code. You will learn important recommendations for writing and organizing your
    code base, as well as how to set up the proper code structure for your services.
    Then, we are going to introduce you to an example application, which will consist
    of three microservices that we are going to use throughout the book. In the following
    chapters, we will add additional features to these services, illustrating all
    the important areas of microservice development.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Go basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaffolding an example application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete this chapter, you need to have Go 1.11 or above. If you don’t have
    Go installed, you can download it from the official website at [go.dev/dl](https://go.dev/dl).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the code examples for this chapter on GitHub: [https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter02](https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter02).'
  prefs: []
  type: TYPE_NORMAL
- en: Go basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go is a great language for writing microservices. It is relatively easy to learn
    and has a pretty smooth learning curve, making onboarding new engineers easier.
    While you may have already had some experience with Go, one of the purposes of
    this book is to provide enough information to all types of developers—from beginners
    to highly experienced professionals.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to summarize important concepts of the language.
    If you already have experience with Go, you can still quickly scan through this
    part. It also includes some useful recommendations and best practices commonly
    missed even by experienced engineers.
  prefs: []
  type: TYPE_NORMAL
- en: Core principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we proceed to look at the basics of Go, I’m going to share with you
    some fundamental principles that will help you make decisions when writing and
    organizing your code. These principles include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Always follow the official guidelines*. It is not uncommon for us engineers
    to have strong opinions about various styling and coding practices. However, in
    any developer community, consistency is more important than individual opinions.
    Make sure you get familiar with the most fundamental Go programming guidelines,
    written by the Go team:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Effective Go—an official set of guidelines for Go developers**: [https://go.dev/doc/effective_go](https://go.dev/doc/effective_go)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Go code review comments**: Another useful source of information on Go development,
    covering various aspects, including code style, naming, and error handling: [https://github.com/golang/go/wiki/CodeReviewComments](https://github.com/golang/go/wiki/CodeReviewComments)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Follow the style used in the standard library*. The standard Go library, which
    comes with any Go installation, is the best source of code examples and comments.
    Get familiar with some of the packages from the library, such as `context` and
    `net`. Following the coding style used in these packages will help you to write
    consistent, readable, and maintainable code, regardless of who will be using it
    later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Do not try to apply the ideas from other languages to Go*. Instead, understand
    the philosophy of Go and see the implementation of the most elegant Go packages—you
    can check the `net` package for some good examples: [https://pkg.go.dev/net](https://pkg.go.dev/net).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, as we are aligned on the core principles, let’s move on to the key recommendations
    for writing conventional and idiomatic Go code.
  prefs: []
  type: TYPE_NORMAL
- en: Writing idiomatic Go code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section summarizes the key topics described in the *Effective Go* document.
    Following the suggestions provided in this section will help you to keep your
    code consistent with the official guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: Naming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Naming is one of the most important aspects of Go development. Writing Go code
    in an idiomatic way requires an understanding of its core naming principles:'
  prefs: []
  type: TYPE_NORMAL
- en: Exported names start with an uppercase character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a variable, struct, or interface is imported from another package, its
    name includes a package name or alias, for example, `bytes.Buffer`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since references include package names, you should not prefix your names with
    the package name. If the package name is `xml`, use the name `Reader`, not `XMLReader`—in
    the second case, the full name would be `xml.XMLReader`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages are generally given lowercase, single-word names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not idiomatic to start the names of getters with the `Get` prefix. If
    your function returns the user’s age, call the function `Age()`, not `GetAge()`.
    Using the `Set` prefix, however, is fine; you can safely call your function `SetAge()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single-method interfaces are named using the method name plus an `er` suffix.
    For example, an interface with a `Write` function would be called `Writer`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialisms and acronyms should have a consistent case. The correct versions
    would be `URL`, `url` and `ID`, include while `Url`, `Id` would be incorrect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable names should be short rather than long. In general, follow this simple
    rule—the closer to declaration a name is used, the shorter it should be. For iterating
    over an array, use *i* for the index variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additional naming recommendations include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The package name should be short, concise, and evocative and should provide
    context for its contents, for example, `json`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep the contents of a package consistent with the name. If you start noticing
    that a package includes extra logic that has no relationship to the package name,
    consider exporting it to a separate one or using a more descriptive name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use name abbreviations only if they are widely used (for example, `fmt` or `cmd`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid name collisions, when possible. For example, if you introduce a set of
    string functions, avoid calling it `strings` package because a package with the
    same name exists in the Go standard library and is already widely used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider the client’s point of view when giving names to your code. Think about
    how the code is going to be used when giving a name to it, for example, the `Writer`
    interface for proving the write functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to these rules, remember to keep the naming consistent across your
    code base. It will help make it easier to read and write new code—good names will
    act as examples for other engineers as well.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Comments are the next important aspect of Go development. Go comments can be
    used in two different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Seeing the comments alongside the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewing the package documentation generated by the `godoc` tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'General principles for Go comments include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Every package should have a comment describing its contents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every exported name in Go should have a comment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comments should be complete sentences and end with a period.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first sentence of the comment should start with the name being exported
    and provide a summary of it, as in the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Go standard library provides many good examples of code comments, so I always
    suggest getting familiar with some examples from it.
  prefs: []
  type: TYPE_NORMAL
- en: Errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'General recommendations for Go errors include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Only use panics in truly exceptional cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always handle each error; don’t discard errors by using `_` assignment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error strings should start with a lowercase character, unless they begin with
    names requiring capitalization, such as acronyms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Error strings, unlike comments, should not end with punctuation marks, as in
    the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When calling a function returning an error, always handle the error first.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wrap errors if you want to add additional information to the clause. The conventional
    way of wrapping errors in Go is to use `%w` at the end of the formatted error:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'While checking for errors, using the `==` operator may result in improper handling
    of the wrapped errors. There are two solutions to this. For a comparison to a
    sentinel error, such as `errors.New("some error")`, use `errors.Is`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For error types, use `errors.As`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, keep errors descriptive yet compact. It should be always easy
    to understand what exactly went wrong by reading the error message.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Key principles of Go **interfaces** include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Do not define interfaces before they are used without a realistic example of
    usage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return concrete (using a pointer or struct) types instead of an interface in
    your functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single-method interfaces should be called by the method name and include the
    `er` suffix, for example, the `Writer` interface with a `Write` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See some built-in interfaces, such as `Writer` and `Reader`, to get a good example
    of defining and using interfaces in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to cover testing in detail in [*Chapter 8*](B18865_08.xhtml#_idTextAnchor109)
    of this book. Let’s provide here some key suggestions for writing Go tests in
    an idiomatic way:'
  prefs: []
  type: TYPE_NORMAL
- en: Tests should always provide information to the user on what exactly went wrong
    in case of a failure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider writing table-driven tests whenever possible. See this example: [https://github.com/golang/go/blob/master/src/fmt/errors_test.go](https://github.com/golang/go/blob/master/src/fmt/errors_test.go).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally, we should only test public functions. Your private function should
    be indirectly tested through them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure you always write tests for your code. Not only does this help with
    finding bugs earlier but it also helps to see how your code can be used. I personally
    find the latter especially useful.
  prefs: []
  type: TYPE_NORMAL
- en: Context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the key differences between the Go language and other popular languages
    is explicit context propagation. **Context propagation** is a mechanism of propagating
    an additional call argument, called **context**, into function calls, passing
    additional metadata.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go context has a type called `context.Context`. There are multiple ways of
    using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cancelation logic**: You can pass a special instance of a context that can
    get *canceled*. In that case, all functions you were to call with it would be
    able to detect this. Such logic can be useful for handling application shutdown
    or stopping any processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timeouts**: You can set the timeouts for your execution by using the corresponding
    context functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Propagating extra metadata**: You can propagate additional key-value metadata
    inside the context. This way, any downstream functions called would receive that
    metadata inside the context object. There are some useful applications of this
    approach, one of which is distributed tracing, which we are going to cover in
    the following chapters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will get back to context propagation in the following chapters. Now, we
    can define some important aspects of using context in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: Context is immutable but can be cloned with extra metadata.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions using context should accept it as their first argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, some context best practices are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Always pass context to functions performing I/O calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limit the usage of context for passing any metadata. You should use metadata
    propagation for truly exceptional cases, such as distributed tracing, mentioned
    earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not attach context to structures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, as we have discussed the key recommendations for writing idiomatic Go code,
    we can move on to the next section, which is going to cover the project structure
    recommendations and standards for Go applications.
  prefs: []
  type: TYPE_NORMAL
- en: Project structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project structure is the foundation of and plays a major role in the readability
    and maintainability of your code. As we discussed in the previous sections, in
    Go projects, the structure may play a more important role than in other languages,
    because each exported name generally includes the name of its package. This requires
    you to have good and descriptive naming for your packages and directories, as
    well as the right hierarchy of your code.
  prefs: []
  type: TYPE_NORMAL
- en: While the official guidelines define some strong recommendations for naming
    and coding styles there aren’t that many rules constraining the Go project structure.
    Each project is unique by its nature, and developers are generally free to choose
    the way they organize the code. However, there are some common practices and specifics
    of Go package organization that we are going to cover in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Private packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Go, all code stored inside a directory called `internal` can be imported
    and used only by packages stored within the same directory or one of the directories
    it includes. Putting code into an internal directory can ensure your code is not
    exported and used by external packages. This can be useful for the following different
    cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Hide the details of the implementation from the user if some of the types of
    functions need to be exported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure no external package relies on your types and functions, which you don’t
    want to expose widely.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove possible unnecessary dependencies between the packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid extra refactoring and maintenance difficulties if your code is unexpectedly
    used by other developers/teams.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I have found it useful to use internal packages as a protection against unwanted
    dependencies. This plays a big role in large repositories and applications, where
    there is a high possibility of unexpected dependencies between the packages. Large
    code bases that don’t have a separation between private and public packages often
    suffer from an effect called *spaghettification*—when packages depend on each
    other in an uncontrolled and chaotic way.
  prefs: []
  type: TYPE_NORMAL
- en: Public packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is another type of directory name with a semantic meaning in Go—a directory
    called `pkg`. It implies that it is OK to use the code from this package externally.
  prefs: []
  type: TYPE_NORMAL
- en: The `pkg` directory isn’t recommended officially, but it is widely used. Ironically,
    the Go team used this in the library code and then got rid of this pattern, while
    the rest of the Go community adopted it so widely that it became a common practice.
  prefs: []
  type: TYPE_NORMAL
- en: It is up to you whether you use a `pkg` directory in your applications. But
    in tandem with the internal directory, it can help to organize your code so that
    what is private and what is public is clear, easing the code navigation for the
    developers.
  prefs: []
  type: TYPE_NORMAL
- en: Executable packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `cmd` package is commonly used in the Go community to store the code of
    one or multiple executable packages with a `main` function. This may include the
    code starting your application or any code for your executable tools. For a single-app
    directory, you can store your Go code directly in the `cmd` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For a multi-app directory, you can include subpackages in `cmd` packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Other commonly used directories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following list includes some other commonly used directory or package names
    in the Go community:'
  prefs: []
  type: TYPE_NORMAL
- en: '`api`: JSON schema files and definitions in various protocols, including gRPC.
    We are going to cover these topics in [*Chapter 4*](B18865_04.xhtml#_idTextAnchor067).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`testdata`: Files containing the data used in tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`web`: Web application components and assets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a list of common filenames, which will keep your packages consistent
    with the official library and lots of third-party libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '`main.go`: A file containing the `main()` function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doc.go`: Package documentation (a separate file is not necessary for small
    packages)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*_test.go`: Test files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`README.md`: A read-me file written in the Markdown language'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LICENSE`: A license file, if there is one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONTRIBUTING.md`/CONTRIBUTORS/AUTHORS: List of contributors and/or authors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s cover the best practices for organizing the code base for Go applications.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, you can find a list of best practices for organizing the Go
    application project structure. It is going to help you to keep your code aligned
    with thousands of other Go packages and keep it conventional and idiomatic. The
    best practices of Go project organization include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Separate private code using an internal directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get familiar with the way popular open source Go projects, such as [https://github.com/kubernetes/kubernetes](https://github.com/kubernetes/kubernetes),
    are organized. This can provide you with great examples of how to structure your
    repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Split in a sufficiently granular way. Don’t split the packages too early but
    also avoid having a lot of logic in a single package. Generally, you will find
    that the easier it is to give a short and specific self-descriptive name to a
    package, the better your code composition is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid long package names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always be ready to change the structure if requirements are changed or if the
    structure no longer reflects the package name/original intent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This sums up the part of the chapter describing the core principles and best
    practices of Go application development and code organization. Now, we are ready
    to get to the practical side of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Scaffolding an example application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered the general recommendations for writing and organizing Go applications
    and we are finally ready to start writing the code! In this section, we are going
    to introduce an application, consisting of multiple microservices that are going
    to be used throughout the book. In each chapter, we are going to add to or improve
    them, converting them from small examples into production-grade services that
    are ready to be used.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn how to scaffold microservice code and split the code into separate
    logical parts, each having its own role. We are going to apply the project structure
    and Go knowledge you gained in this chapter to illustrate how to set the right
    structure for each service and write its code in a conventional and idiomatic
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Movie application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s imagine we are building an application for movie lovers. The application
    would provide the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the movie metadata (such as title, year, description, and director) and
    the aggregated movie rating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rate a movie
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the listed features seem to be closely related. However, let’s take a closer
    look at them.
  prefs: []
  type: TYPE_NORMAL
- en: Movie metadata
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s assume we have the metadata for a collection of movies, which includes
    the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Title
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Year
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Director
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List of actors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Such information about movies doesn’t generally change unless somebody wants
    to update the description, but for simplicity, we may assume that we are dealing
    with a static dataset. We would retrieve the records based on their IDs, so we
    could use any key-value or document database to store and access the metadata.
  prefs: []
  type: TYPE_NORMAL
- en: Ratings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s now review the functionality required for storing and retrieving movie
    ratings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, we would need to perform the following rating operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Store a movie rating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the aggregated movie rating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Later, we would also need to support rating deletion, but for now, we can just
    keep this logic in mind while designing the application.
  prefs: []
  type: TYPE_NORMAL
- en: The ratings data is quite different from the movie metadata—we can both append
    and delete the records. In addition to this, we need to return the aggregated
    rating, so we should either be able to return all stored ratings for an item and
    perform the aggregation on the go or have separate logic for performing and storing
    the aggregations. You will notice that the ways we access ratings and movie metadata
    are different. This hints that the ratings data can, and probably should, be stored
    separately from the movie metadata.
  prefs: []
  type: TYPE_NORMAL
- en: While designing the application, it is beneficial to think one step ahead and
    imagine how the application may evolve in the future. This does not mean that
    you should necessarily build the application trying to predict future use cases,
    because it can lead to unnecessary abstractions that may not be needed later if
    your plans change. However, thinking one step ahead may save you time later if
    you find more efficient ways of modeling and storing your data, which would help
    you to adapt to changing requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how the rating service can possibly evolve. At some point, we may
    want to extend the rating functionality to other types of movie-related records.
    A user may be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Rate the actor’s performance in some movies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rate the movie soundtrack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rate the movie’s costume design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When making decisions on supporting future use cases, you should ask yourself,
    how likely it is that I will need to implement that logic in the observable future
    (6 to 12 months)? You should generally avoid thinking much further ahead because
    the requirements and goals may change. However, if you are quite certain you have
    plans to support particular features, you should make sure your data model can
    support those features without major changes.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume we definitely want to implement the additional ratings mentioned
    earlier. In this case, we want to make sure we can design our application in a
    way that would support the ratings for different types of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define the API for such a rating component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Store the rating record, including the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ID of the user who gave the rating
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Type of record
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ID of the record
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Rating value
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the aggregated rating for a record by its ID and type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This API supports record types, so we can easily add more types of ratings without
    changing the system. The trade-off we made here is quite reasonable—the API is
    different on the basis of just one field (record type) from the API of a rating
    system designed just for movies. However, this gives us complete freedom in introducing
    new rating types in the future! Such a trade-off seems very reasonable given that
    we have decided we will certainly need those ratings in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Should we split the application?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s provide a summary of the two parts of the application we have just described:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Movie metadata:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve the metadata for a movie by its ID.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ratings:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store a rating for a record.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve an aggregated rating for a record.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: After we abstracted the rating component by letting it support various record
    types, it stopped being a movie rating component and became a more generic record
    rating system. The movie metadata component is now loosely coupled to the rating
    system—the rating system can store the ratings for movies as well as for any other
    possible types of records.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed previously, the data models for both components are also quite
    different. The movie metadata component stores static data, which is going to
    be retrieved by ID, while the rating component stores dynamic data, which requires
    aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both components seem to be relatively independent of each other. This is a
    perfect example of a situation where we may benefit from splitting the application
    into separate services:'
  prefs: []
  type: TYPE_NORMAL
- en: Logic is loosely coupled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data models are different
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data is generally independent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list is not complete, and you need to consider all the aspects described
    in [*Chapter 1*](B18865_01.xhtml#_idTextAnchor015), to make a decision on splitting
    the application. However, since this book covers microservice development, let’s
    make our decision here and decide to split the system into separate services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s list the services we would split the application into:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Movie metadata service**: Store and retrieve the movie metadata records by
    movie IDs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rating service**: Store ratings for different types of records and retrieve
    aggregated ratings for records.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Movie service**: Provide complete information to the callers about a movie
    or a set of movies, including the movie metadata and its rating.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Why did we end up with three services here? We did this for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The movie metadata service would be solely responsible for accessing the movie
    metadata records.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The movie service would provide the client-facing API, aggregating two separate
    types of records—movie metadata and ratings. The records would be stored in two
    separate systems, so this component would join them together and return to the
    caller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we introduce any other types of records in the system, such as likes, reviews,
    and recommendations, we will plug them into the movie service, not the movie metadata
    service. The movie metadata service would be used solely for accessing the static
    movie metadata, not any other types of records.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Movie metadata services can potentially evolve in the future by getting more
    metadata-related functionality, such as editing or adding descriptions in different
    languages. This also hints that it is better to keep this component solely for
    the metadata-related features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s illustrate these services in a diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Movie application services'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.1_B18865.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – Movie application services
  prefs: []
  type: TYPE_NORMAL
- en: Now, as we have definitions of the three microservices, let’s finally proceed
    to the coding part.
  prefs: []
  type: TYPE_NORMAL
- en: Application code structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s align on how are we going to structure the code of all microservices
    in relation to each other. I would suggest storing them inside a single directory,
    which would be our application root. Create a new directory (you may call it `movieapp`),
    and inside it, create the following directories for our microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rating`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`metadata`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`movie`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout the book, I will use the directory paths relative to the application
    directory you’ve created, so when you see a directory or filename, assume it is
    stored in the app directory you chose for this.
  prefs: []
  type: TYPE_NORMAL
- en: From the *Project structure* section, we know that the logic containing the
    `main` function generally resides in the `cmd` directory. We will use this approach
    in our microservices—for example, the main file for the rating service would be
    called `rating/cmd/main.go`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each service may contain one or multiple packages related to the following
    logical roles:'
  prefs: []
  type: TYPE_NORMAL
- en: API handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business/application logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interaction with other services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that handler and business/application logic are separate, even though the
    primary purpose of the application may be to handle the API requests. This is
    not absolutely necessary, but it’s a relatively good practice to separate the
    business logic from the API handling layer. This way, if you migrate from one
    type of API to another (for example, from HTTP to gRPC), or support both, you
    don’t need to implement the same logic twice or rewrite it. Instead, you would
    just call the business logic from your handler, keeping the handler as simple
    as possible and making its primary purpose to pass the requests to the relevant
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can illustrate this relationship with the help of a diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Layers of a service'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.2_B18865.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – Layers of a service
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the diagram, the API handler does not access the database
    directly. Instead, the database access is performed on a business logic layer.
  prefs: []
  type: TYPE_NORMAL
- en: There is no convention in the Go community on how to call packages serving these
    purposes, so we are free to choose the names for our packages providing such logic.
    It is, however, important that you keep these names consistent across all your
    microservices, so let’s align on a common naming convention for these types of
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we are going to use the following names for our application components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**controller**: Business logic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**gateway**: Logic for interacting with other services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**handler**: API handlers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**repository**: Database logic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, since we are aligned on the naming, let’s proceed to the last step of
    setting up our project. Execute this command in the application root directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This command creates a Go module called `movieexample.com`. A Go module is a
    collection of related packages stored in a file tree. They help manage dependencies
    for your project, and we are going to use this feature in all the chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can proceed to code scaffolding for our first microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Movie metadata service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s summarize the logic of the movie metadata service:'
  prefs: []
  type: TYPE_NORMAL
- en: '**API**: Get metadata for a movie'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database**: Movie metadata database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interacts with services**: None'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data model type**: Movie metadata'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This logic would translate into the following packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cmd`: Contains the main function for starting the service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`controller`: Our service logic (read the movie metadata)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handler`: API handler for a service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repository`: Logic for accessing the movie metadata database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s store the logic of our service in a directory called `metadata`. Following
    the conventions we described earlier in the chapter, the executable code containing
    the main file is going to be stored in the `cmd` package. All code that we are
    not going to export will be stored in the `internal` directory and this will include
    most of our applications. The exported structures will reside in the `pkg` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying the rules that we just described, we are going to structure our packages
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '`metadata/cmd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`metadata/internal/controller`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`metadata/internal/handler`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`metadata/internal/repository`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`metadata/pkg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have created the directories listed here, let’s proceed to implement
    the code for our microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we are going to implement the structure for the movie metadata. Inside
    the `metadata/pkg` directory, create a `metadata.go` file using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This structure is going to be used by the callers of our service. It includes
    JSON annotations, which we are going to use later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let’s create the stub logic for handling the database logic. Inside the
    `metadata/internal/repository` directory, add an `error.go` file using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This file defines an error for the case when the record is not found. We are
    going to use this error in our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we are going to add the repository implementation. Even if
    you have some specific technology to work with for storing the data, it is often
    useful to provide more than one implementation of the database logic. I always
    find it useful to include an in-memory implementation of the database logic that
    can be used for testing and local development, reducing the need for any additional
    databases or extra libraries. I am going to illustrate how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `metadata/internal/repository` directory, create a directory called
    `memory` that will contain the in-memory implementation or our movie metadata
    database. Add a `memory.go` file to it, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s highlight some aspects of the code we’ve just added:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we called the `Repository` structure because it provides a good name
    to the users when combined with the name of its package— `memory.Repository`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, we used the exported `ErrNotFound` that we previously defined, so callers
    can check their code. It is usually good practice to do so because it allows the
    developers to check for a specific error in their code. We will illustrate how
    to write tests for it in [*Chapter 8*](B18865_08.xhtml#_idTextAnchor109).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, the function creating the repository is called `New`. This is
    often a good name for short packages when there is just one type being created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our `Get` and `Put` functions accept context as the first argument. We mentioned
    this approach in the *Writing idiomatic Go code* section—all functions performing
    I/O operations must accept context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our implementation is using a `sync.RWMutex` structure to protect against concurrent
    writes and reads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s move on to the business logic layer.
  prefs: []
  type: TYPE_NORMAL
- en: Controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next step is to add a controller to encapsulate our business logic. Even
    if your logic is trivial, it is still a good practice to keep it separate from
    the handler from the beginning. This will help you avoid further changes and,
    more importantly, keep the structure of your applications consistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `metadata/internal/controller` package, add a directory called `metadata`.
    Inside it, add a `controller.go` file with the following logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The controller we created is currently just a wrapper around the repository.
    However, the controller will generally have more logic, so it is preferable to
    keep it separate.
  prefs: []
  type: TYPE_NORMAL
- en: Handler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we are going to create the API handler. Inside the `metadata/internal/handler`
    directory, create a directory called `http`. Inside it, create a file called `http.go`
    with the following logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s implement the logic for retrieving movie metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The handler we just created uses our repository to retrieve the information
    and return it in JSON format. We chose JSON here just for simplicity. In [*Chapter
    4*](B18865_04.xhtml#_idTextAnchor067), we are going to cover more data formats
    and illustrate how they can benefit your applications.
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that we have called the package for our HTTP handler `http`.
    There is a trade-off here—while we are certainly colliding with its namesake standard
    library package, we get a pretty descriptive `http.Handler` exported name. Since
    our package is going to be used internally, this trade-off is reasonable.
  prefs: []
  type: TYPE_NORMAL
- en: Main file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, since we have created both a database and an API handler, let’s create
    the executable for the metadata service. Inside the `metadata/cmd` directory,
    create the `main.go` file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The function we just created initializes all structures of our service and starts
    the `http` API handler we implemented earlier. The service is ready to process
    user requests, so let’s move on to the other services.
  prefs: []
  type: TYPE_NORMAL
- en: Rating service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s summarize the logic of the rating service:'
  prefs: []
  type: TYPE_NORMAL
- en: '**API**: Get the aggregated rating for a record and write a rating.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database**: Rating database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interacts with services**: None.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data model type**: Rating.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This logic would translate into the following packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cmd`: Contains the main function for starting the service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`controller`: Our service logic (read and write ratings)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handler`: API handler for a service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repository`: Logic for accessing the movie metadata database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are going to use exactly the same directory structure as we used for the
    metadata service:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rating/cmd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rating/internal/controller`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rating/internal/handler`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rating/internal/repository`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rating/pkg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have created these directories, let’s move on to the implementation
    of the service.
  prefs: []
  type: TYPE_NORMAL
- en: Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a model directory inside `rating/pkg` and create a `rating.go` file,
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The file contains the model for our rating service, which is also going to be
    used by other services interacting with it. Note that we created separate types,
    `RecordID`, `RecordType`, and `UserID`. This will help us with readability and
    add extra type protection, as you will see in the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create the in-memory implementation for our rating repository inside the `rating/internal/repository/memory/memory.go`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add an implementation of the `Get` function to it, as shown in the following
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let’s implement a `Put` function inside it, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding implementation is using a nested map to store all records inside
    it. If we didn’t define separate types, `RatingID`, `RatingType`, and `UserID`,
    it would be harder to understand the types of the keys in the map because we would
    be using primitives such as `string` and `int`, which are less self-descriptive.
  prefs: []
  type: TYPE_NORMAL
- en: Controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s add a controller for our rating service. In the `rating/internal/controller/rating`
    package, create a `controller.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s add functions for writing and getting an aggregated rating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this example, it is easy to see how the controller logic is different from
    the repository one. The repository provides an interface to get all ratings for
    a record and the controller implements the aggregation logic for them.
  prefs: []
  type: TYPE_NORMAL
- en: Handler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s implement the service handler in the `rating/internal/handler/http/http.go`
    file, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s add a function for handling HTTP requests to our service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The handler we implemented handles both `GET` and `PUT` requests. Note the way
    we handle some special cases such as an empty `id` value from the request—in that
    case, we return a special error code, `http.StatusBadRequest`, indicating that
    the API request was invalid. If the record is not found, we return `http.StatusNotFound`,
    and if we encounter any unexpected errors when accessing our database, we return
    `http.StatusInternalServerError`.
  prefs: []
  type: TYPE_NORMAL
- en: Using such standard HTTP error codes helps the clients to differentiate between
    the types of errors and implement the logic for detecting and correctly handling
    such issues.
  prefs: []
  type: TYPE_NORMAL
- en: Main
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s write the main file for our service. In `rating/cmd/main.go`, write the
    following logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `main` function we created is similar to the main function of the metadata
    service; it initializes all components of a service and starts an HTTP handler.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to implement our last service.
  prefs: []
  type: TYPE_NORMAL
- en: Movie service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s summarize the logic of the movie service:'
  prefs: []
  type: TYPE_NORMAL
- en: '**API**: Get the details for a movie, including the aggregated movie rating
    and movie metadata.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database**: None.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interacts with services**: Movie metadata and rating.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data model type**: Movie details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This logic would translate into the following packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cmd`: Contains the main function for starting the service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`controller`: Our service logic (read rating and metadata)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gateway`: Logic for calling the other services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handler`: API handler for a service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The directory structure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`movie/cmd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`movie/internal/controller`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`movie/internal/gateway`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`movie/internal/handler`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`movie/pkg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have created these directories, let’s move on to the implementation
    of the service.
  prefs: []
  type: TYPE_NORMAL
- en: Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a `model.go` file in the `movie/pkg/model` directory and write the following
    logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note that the file imports the model package of a metadata service containing
    the `Metadata` structure that we can reuse in our service.
  prefs: []
  type: TYPE_NORMAL
- en: Gateways
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous examples, the services did not interact with each other and
    just provided an API for this. The movie service won’t access any database by
    itself but instead is going to interact with both the movie metadata and the rating
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create the logic for interacting with both services.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create an error that we are going to use in our gateways. In the
    `movie/internal/gateway` package, create an `error.go` file, using the following
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s write an HTTP gateway for the movie metadata service. In the `movie/gateway/metadata/http`
    directory, create a `metadata.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s implement a `Get` function in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s write an HTTP gateway for the rating service. In the `movie/gateway/rating/http`
    directory, create a `rating.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s add logic for getting the aggregated rating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let’s add a function for handling a rating creation request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have both gateways and can implement the controller aggregating
    the data from them.
  prefs: []
  type: TYPE_NORMAL
- en: Controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `movie/internal/controller/movie` directory, create a `controller.go`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s define the interfaces for the services we will be calling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can define our service controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let’s implement the function for getting the movie details, including
    both its rating and metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note that we redefine `ErrNotFound` in different components. While we could
    have just exported it to some shared package, sometimes it is better to keep it
    independent. Otherwise, we may confuse one error for another (for example, rating
    not found or metadata not found).
  prefs: []
  type: TYPE_NORMAL
- en: Handler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `movie/internal/handler/http` package, add the `http.go` file, using
    the following logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are finally ready to write a main file for the movie service.
  prefs: []
  type: TYPE_NORMAL
- en: Main file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `movie/cmd` package, create a `main.go` file, using the following code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have the logic for all three services. Note that we used
    static service addresses, `localhost:8081`, `localhost:8082`, and `localhost:8083`,
    in this example. This allows you to run the services locally; however, this would
    not work if we deployed our services to the cloud or any other deployment platform.
    In the next chapter, we are going to cover this aspect and continue improving
    our microservices. You can run the services we just created by executing this
    command inside the `cmd` directory of each service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can call the metadata service API using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You can call the rating service API using a similar command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can call the movie service using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: All of the preceding requests should return an HTTP 404 error, indicating that
    records are not found—we do not have any data yet, so this is expected.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have illustrated how to bootstrap and manually test our example
    microservices and are ready to move on to the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we have covered lots of topics, including the most important
    recommendations for writing Go applications and the standards for the project
    layout of Go applications. The knowledge we gained helped us during the code scaffolding
    of our microservices—we have tried to implement our microservice code in an idiomatic
    way as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: You have also learned how to split each of your microservices into multiple
    layers, each responsible for its own logic. We have illustrated how to separate
    the business logic from the code accessing the database, and how to separate the
    API handler logic from both, as well as from the logic performing remote calls
    between the services.
  prefs: []
  type: TYPE_NORMAL
- en: While the amount of information in this chapter is quite overwhelming, we have
    made a solid start and are ready to move on to more advanced topics. In the next
    chapter, we are going to see how the microservices we created can explore each
    other, so we can finally test them.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Effective Go*: [https://go.dev/doc/effective_go](https://go.dev/doc/effective_go)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Go Code Review Comments*: [https://github.com/golang/go/wiki/CodeReviewComments](https://github.com/golang/go/wiki/CodeReviewComments)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Project layout*: [https://github.com/golang-standards/project-layout](https://github.com/golang-standards/project-layout)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Package names*: [https://go.dev/blog/package-names](https://go.dev/blog/package-names)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
