<html><head></head><body>
		<div id="_idContainer020">
			<h1 id="_idParaDest-51" class="chapter-number" lang="en-GB"><a id="_idTextAnchor051"/>3</h1>
			<h1 id="_idParaDest-52" lang="en-GB"><a id="_idTextAnchor052"/>Service Discovery</h1>
			<p lang="en-GB">In the previous chapter, we created our example microservices and let them communicate with each other, using static local addresses hardcoded into each service. This approach would work until we to add or remove service instances dynamically, known as service discovery – letting microservices find each other in a dynamic environment. Setting up service discovery is the first step for writing and preparing scalable microservices in a real production environment.</p>
			<p lang="en-GB">In this chapter, we are going to cover the following topics:</p>
			<ul>
				<li lang="en-GB">Service discovery overview</li>
				<li lang="en-GB">Service discovery solutions</li>
				<li lang="en-GB">Adopting service discovery</li>
			</ul>
			<p lang="en-GB">We will use the microservices we created in the previous chapter to illustrate how to use the service discovery solutions. Now, let’s move on to the overview of the service discovery concepts.</p>
			<h1 id="_idParaDest-53" lang="en-GB"><a id="_idTextAnchor053"/>Technical requirements</h1>
			<p lang="en-GB">In order to complete this chapter, you need Go 1.11 or above. Additionally, you will need a Docker tool, which you can download from <a href="https://www.docker.com">https://www.docker.com</a>.</p>
			<p lang="en-GB">You can find the source files for this chapter on GitHub: <a href="https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter03">https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter03</a>.</p>
			<h1 id="_idParaDest-54" lang="en-GB"><a id="_idTextAnchor054"/>Service discovery overview</h1>
			<p lang="en-GB">In the previous <a id="_idIndexMarker123"/>chapter, we created an application consisting of three microservices. The relationship between the services is illustrated in the following diagram:</p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/B18865_03_Figure_1.jpg" alt="Figure 3.1 – Relationship between our microservices&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Relationship between our microservices</p>
			<p lang="en-GB">As you can see, the movie service calls both the metadata and rating service for fetching the complete movie details.</p>
			<p lang="en-GB">But how would our services send requests? How would they know the addresses of each other?</p>
			<p lang="en-GB">In our example, we used pre-programmed static values for the API handlers. The settings <a id="_idIndexMarker124"/>we<a id="_idIndexMarker125"/> used <a id="_idIndexMarker126"/>were as follows:</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Metadata service</strong>: <strong class="source-inline" lang="">localhost:8081</strong></li>
				<li lang="en-GB"><strong class="bold" lang="">Rating service</strong>: <strong class="source-inline" lang="">localhost:8082</strong></li>
				<li lang="en-GB"><strong class="bold" lang="">Movie service</strong>: <strong class="source-inline" lang="">localhost:8083</strong></li>
			</ul>
			<p lang="en-GB">In our approach, each service would need to know the exact address of the other services it would communicate with. This approach would work until we more than one instance of each microservice. In this case, we would have multiple challenges:</p>
			<ul>
				<li lang="en-GB">What address should you use when you have multiple instances?</li>
				<li lang="en-GB">How to handle the situation when some instances become unavailable?</li>
			</ul>
			<p lang="en-GB">The first problem is relatively easy to solve if you have a static set of instances – your services would need to keep a list of addresses for each service they need to call. However, this approach is not flexible for the following reasons:</p>
			<ul>
				<li lang="en-GB">Each time you need to add or remove instances, you need to update the configuration of each calling service.</li>
				<li lang="en-GB">If an instance becomes unavailable for an extended period (for example, due to network failure), your services would still keep calling it until you updated their configuration.</li>
			</ul>
			<p lang="en-GB">How do you solve these problems properly?</p>
			<p lang="en-GB">The problem we just described for our microservices is <a id="_idIndexMarker127"/>called <strong class="bold" lang="">service discovery</strong>. In general, service discovery addresses multiple problems, as follows:</p>
			<ul>
				<li lang="en-GB">How to discover the instance(s) of a particular service</li>
				<li lang="en-GB">How to add and remove instances of service in a discoverable environment</li>
				<li lang="en-GB">How to handle the issue when instances become unresponsive</li>
			</ul>
			<p lang="en-GB">Let’s see how each of these features would work.</p>
			<h2 id="_idParaDest-55" lang="en-GB"><a id="_idTextAnchor055"/>Registry</h2>
			<p lang="en-GB">The<a id="_idIndexMarker128"/> foundation <a id="_idIndexMarker129"/>of service discovery is a registry (also known as a service registry), which stores information about available service instances. It has the <a id="_idIndexMarker130"/>following features:</p>
			<ul>
				<li lang="en-GB">Register an instance of a service.</li>
				<li lang="en-GB">Deregister an instance of a service.</li>
				<li lang="en-GB">Return the list of all the instances of the service in the form of their network addresses.</li>
			</ul>
			<p lang="en-GB">This is an <a id="_idIndexMarker131"/>example of service discovery registry data:</p>
			<table id="table001-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p lang="en-GB"><strong class="bold" lang="">Service name</strong></p>
						</td>
						<td class="No-Table-Style">
							<p lang="en-GB"><strong class="bold" lang="">Address list</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p lang="en-GB">Movie service</p>
						</td>
						<td class="No-Table-Style">
							<p lang="en-GB"><strong class="source-inline" lang="">172.18.10.2:2520</strong></p>
							<p lang="en-GB"><strong class="source-inline" lang="">172.18.12.55:8800</strong></p>
							<p lang="en-GB"><strong class="source-inline" lang="">172.18.89.10:2450</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p lang="en-GB">Rating service</p>
						</td>
						<td class="No-Table-Style">
							<p lang="en-GB"><strong class="source-inline" lang="">172.18.25.11:1100</strong></p>
							<p lang="en-GB"><strong class="source-inline" lang="">172.18.9.55:2830</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p lang="en-GB">Movie metadata service</p>
						</td>
						<td class="No-Table-Style">
							<p lang="en-GB"><strong class="source-inline" lang="">172.18.79.115:3512</strong></p>
							<p lang="en-GB"><strong class="source-inline" lang="">172.17.3.8:9900</strong></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 3.1 – Registry data</p>
			<p lang="en-GB">Each <a id="_idIndexMarker132"/>service <a id="_idIndexMarker133"/>can either register in the registry by itself or use some library or tool to register on service startup automatically. Once the service is registered, it starts being monitored via health checks to ensure the registry contains only available instances.</p>
			<p lang="en-GB">Let’s now see the two common models of adopting service discovery.</p>
			<h2 id="_idParaDest-56" lang="en-GB"><a id="_idTextAnchor056"/>Service discovery models</h2>
			<p lang="en-GB">For the <a id="_idIndexMarker134"/>applications, there are two ways of interacting with the<a id="_idIndexMarker135"/> registry:</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Client-side service discovery</strong>: Access the registry directly from the application using a registry client.</li>
				<li lang="en-GB"><strong class="bold" lang="">Server-side service discovery</strong>: Access the registry indirectly via a load balancer, a special server that forwards requests to available instances.</li>
			</ul>
			<p lang="en-GB">Let’s see the advantages and disadvantages of each model.</p>
			<h3 lang="en-GB">Client-side service discovery</h3>
			<p lang="en-GB">In the<a id="_idIndexMarker136"/> client-side service discovery model, each <a id="_idIndexMarker137"/>application or service accesses the service registry directly by requesting all available instances of a target service. When the application receives a response, it uses the addresses of the target service for making requests. The logic is illustrated in the following diagram:</p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/B18865_03_Figure_2.jpg" alt="Figure 3.2 – Client-side service discovery&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Client-side service discovery</p>
			<p lang="en-GB">In this <a id="_idIndexMarker138"/>model, the<a id="_idIndexMarker139"/> application is responsible for balancing the load on the service it is calling – if an application picked just one instance from the list and kept calling it all the time, it would overload that instance and underutilize the other ones.</p>
			<p lang="en-GB">The downside of this model is that the calling application needs to be programmed with load-balancing logic. In addition, this couples service discovery and load-balancing logic with the application code, making the application more complex.</p>
			<h3 lang="en-GB">Server-side service discovery</h3>
			<p lang="en-GB">The<a id="_idIndexMarker140"/> server-side service discovery model adds<a id="_idIndexMarker141"/> an extra layer to the interaction between the calling applications and the registry. Instead of calling the registry directly, applications send their requests to target microservices via a special server called a load balancer. The load balancer is responsible for interacting with the registry and distributing requests between all available instances.</p>
			<p lang="en-GB">The following diagram will help you understand the server-side service discovery model:</p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/B18865_03_Figure_3.jpg" alt="Figure 3.3 – Server-side service discovery&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Server-side service discovery</p>
			<p lang="en-GB">In the diagram, the <a id="_idIndexMarker142"/>application calls the target service via a load balancer, accessing the service <a id="_idIndexMarker143"/>registry to read the list of active service instances from it. In this model, the application does not need to know about the registry. This is the main benefit of the server-side service discovery model: it helps decouple the interaction with the service registry from each calling application, making the application logic simpler. The downside of the model is that it requires setting up and using a load balancer. The latter is rather an untrivial operation, and we are not going to cover it in this book.</p>
			<p lang="en-GB">Now, let’s see how the registry can keep the list of only active instances of each service.</p>
			<h2 id="_idParaDest-57" lang="en-GB"><a id="_idTextAnchor057"/>Service health monitoring</h2>
			<p lang="en-GB">The<a id="_idIndexMarker144"/> registry keeps the information about the instances up to date either via a pull or a push model:</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Pull model</strong>: The<a id="_idIndexMarker145"/> service registry periodically performs a health check for each known instance.</li>
				<li lang="en-GB"><strong class="bold" lang="">Push model</strong>: The <a id="_idIndexMarker146"/>application renews its status by contacting the registry.</li>
			</ul>
			<p lang="en-GB">The pull model removes the need to implement status renewal on a service level. In a push model, the application is responsible for renewing its status or telling the service registry about its healthy status.</p>
			<p lang="en-GB">Now, as we have covered the theoretical basics of service discovery, let’s see which existing solutions you can use to enable your microservices.</p>
			<h1 id="_idParaDest-58" lang="en-GB"><a id="_idTextAnchor058"/>Service discovery solutions</h1>
			<p lang="en-GB">In this section, we are going to describe the existing service discovery solutions available for your use – <strong class="bold" lang="">HashiCorp Consul</strong> and <strong class="bold" lang="">Kubernetes</strong>. Then, you will learn about the most popular tools that can be used by microservice developers to perform service discovery.</p>
			<h2 id="_idParaDest-59" lang="en-GB"><a id="_idTextAnchor059"/>HashiCorp Consul</h2>
			<p lang="en-GB">HashiCorp Consul<a id="_idIndexMarker147"/> has been a pretty popular<a id="_idIndexMarker148"/> solution for service discovery for many years. Written in Go, this tool allows you to set up service discovery for your services and applications quite easily, using its clients or API.</p>
			<p lang="en-GB">Consul has a pretty straightforward API, including the following key endpoints:</p>
			<ul>
				<li lang="en-GB"><strong class="source-inline" lang="">PUT /catalog/register</strong>: Register a service instance.</li>
				<li lang="en-GB"><strong class="source-inline" lang="">PUT /catalog/deregister</strong>: Deregister a service instance.</li>
				<li lang="en-GB"><strong class="source-inline" lang="">GET /catalog/services</strong>: Get the available instances of a service.</li>
			</ul>
			<p lang="en-GB">Client applications can access the Consul catalog either via the API or in server-side service discovery mode, using a DNS service.</p>
			<p lang="en-GB">You can learn more about Consul by checking the<a id="_idIndexMarker149"/> official website: <a href="https://consul.io">https://consul.io</a>.</p>
			<h2 id="_idParaDest-60" lang="en-GB"><a id="_idTextAnchor060"/>Kubernetes</h2>
			<p lang="en-GB">Kubernetes <a id="_idIndexMarker150"/>is a popular open source platform<a id="_idIndexMarker151"/> for running, scaling, and managing collections of applications, such as microservices.</p>
			<p lang="en-GB">One of the features of Kubernetes is the ability to register and discover the services that are running in it. Kubernetes provides an API for retrieving the list of network addresses of each service that is being updated automatically, so users can use it in client-side discovery mode. Alternatively, it allows its users to plug in a load balancer to use it for server-side discovery instead.</p>
			<p lang="en-GB">We are going to cover Kubernetes later, in <a href="B18865_08.xhtml#_idTextAnchor109"><em class="italic" lang="">Chapter 8</em></a> of this book. Now, let’s see how we can add service discovery to the applications we created in the previous chapter.</p>
			<h1 id="_idParaDest-61" lang="en-GB"><a id="_idTextAnchor061"/>Adopting service discovery</h1>
			<p lang="en-GB">In this section, we<a id="_idIndexMarker152"/> are going to illustrate how you can start using service discovery for your applications. We will be using the microservices we created in the previous chapter as an example. Then, you will learn how to add the logic responsible for service discovery to your microservice code.</p>
			<p lang="en-GB">When you consider enabling service discovery for your services, you have multiple questions to answer, such as the following:</p>
			<ul>
				<li lang="en-GB">Which model would you prefer to use – client-side or server-side discovery?</li>
				<li lang="en-GB">Which platform will you use for the deployment and orchestration of your microservices?</li>
			</ul>
			<p lang="en-GB">Answering the second question may already give you a solution – various deployment platforms, including Kubernetes, as well as popular clouds such as AWS, offer service discovery for your services.</p>
			<p lang="en-GB">If you don’t know which deployment platform you are going to use for your services and you are new to microservice development, you may consider client-side service discovery. The client-side discovery model is slightly simpler because your service directly coordinates with the service registry. Later, you will be able to switch to server-side service discovery, if you want.</p>
			<p lang="en-GB">Let’s start preparing your applications for adding service discovery logic.</p>
			<h2 id="_idParaDest-62" lang="en-GB"><a id="_idTextAnchor062"/>Preparing the application</h2>
			<p lang="en-GB">Let’s list what<a id="_idIndexMarker153"/> we want to achieve from our service discovery code.</p>
			<ul>
				<li lang="en-GB">The ability to register a service that we are going to use on service startup</li>
				<li lang="en-GB">The ability to deregister a service that we are going to use on service shutdown</li>
				<li lang="en-GB">The ability to get a list of addresses of a particular service that we are going to use for making the calls to the other services.</li>
				<li lang="en-GB">Set up service health monitoring so the service registry is able to remove inactive service instances</li>
			</ul>
			<p lang="en-GB">It would be <a id="_idIndexMarker154"/>great if our service discovery logic weren’t directly tied to a particular tool. It is usually a good practice to abstract the actual technology with a more generic interface, which allows us to swap implementations. We can illustrate this using an example – imagine we are using the Hashicorp Consul library, which returns a list of service addresses in the following form:</p>
			<pre class="source-code" lang="en-GB">
func Service(string, string) ([]*consul.ServiceEntry, *consul.QueryMeta, error)</pre>
			<p lang="en-GB">If we expose these Consul structures in our code and pass these structures around our code base, our service code will be heavily tied to Consul. If we ever decide to switch to another service discovery tool, we would need to replace not only the service discovery implementation logic but also all the code in which it is used.</p>
			<p lang="en-GB">Instead, let’s define a more generic and technology-agnostic interface. For providing the list of service instances, we can just return the list of URLs in the <strong class="source-inline" lang="">[]string</strong> format.</p>
			<p lang="en-GB">The complete interface for our service discovery logic would be as follows:</p>
			<pre class="source-code" lang="en-GB">
// registry defines a service registry.
type Registry interface {
    // Register creates a service instance record in the registry.
    Register(ctx context.Context, instanceID string, serviceName string, hostPort string) error
    // Deregister removes a service instance record from the registry.
    Deregister(ctx context.Context, instanceID string, serviceName string) error
    // ServiceAddresses returns the list of addresses of active instances of the given service.
    ServiceAddresses(ctx context.Context, serviceID string) ([]string, error)
    // ReportHealthyState is a push mechanism for reporting healthy state to the registry.
    ReportHealthyState(instanceID string, serviceName string) error
}</pre>
			<p lang="en-GB">As you may notice, the interface is pretty generic, yet it allows you to create multiple implementations based on different technologies if needed.</p>
			<p lang="en-GB">You may<a id="_idIndexMarker155"/> also notice that the interface includes a <strong class="source-inline" lang="">ReportHealthyState</strong> function for reporting the healthy state of a service instance. This function allows us to implement the push-based service health monitoring that we mentioned before, so each microservice would periodically report its health to the service registry. The registry would then be able to remove inactive instances of each service if they don’t report a healthy state within some defined interval of time (we are going to assume the interval is 5 seconds in our implementation).</p>
			<p lang="en-GB">Let’s now think about where we would store the service discovery logic for our microservices. I suggest using a package that all three services can access – let’s create it in the root directory of our application, under the <strong class="source-inline" lang="">pkg</strong> folder. We can call it <strong class="source-inline" lang="">pkg/discovery</strong>. Inside it, add a <strong class="source-inline" lang="">discovery.go</strong> file and add the following code to it:</p>
			<pre class="source-code" lang="en-GB">
package discovery
import (
    "context"
    "errors"
    "fmt"
    "math/rand"
    "time"
)
// Registry defines a service registry.
type Registry interface {
    // Register creates a service instance record in the
    // registry.
    Register(ctx context.Context, instanceID string, serviceName string, hostPort string) error
    // Deregister removes a service insttance record from
    // the registry.
    Deregister(ctx context.Context, instanceID string, serviceName string) error
    // ServiceAddresses returns the list of addresses of
    // active instances of the given service.
    ServiceAddresses(ctx context.Context, serviceID string) ([]string, error)
    // ReportHealthyState is a push mechanism for reporting
    // healthy state to the registry.
    ReportHealthyState(instanceID string, serviceName string) error
}
// ErrNotFound is returned when no service addresses are
// found.
var ErrNotFound = errors.New("no service addresses found")
// GenerateInstanceID generates a pseudo-random service
// instance identifier, using a service name
// suffixed by dash and a random number.
func GenerateInstanceID(serviceName string) string {
    return fmt.Sprintf("%s-%d", serviceName, rand.New(rand.NewSource(time.Now().UnixNano())).Int())
}</pre>
			<p lang="en-GB">In the code<a id="_idIndexMarker156"/> that we just added, we have defined a <strong class="source-inline" lang="">Registry</strong> interface for the service registry. Additionally, we defined the <strong class="source-inline" lang="">ErrNotFound</strong> error that would be returned from the <strong class="source-inline" lang="">ServiceAddresses</strong> function if no active service addresses were found. Finally, we created a <strong class="source-inline" lang="">GenerateInstanceID</strong> function that would help us to generate randomized instance identifiers for use with the <strong class="source-inline" lang="">Register</strong> and <strong class="source-inline" lang="">Deregister</strong> functions.</p>
			<p lang="en-GB">We are ready to begin our work on its implementation.</p>
			<h2 id="_idParaDest-63" lang="en-GB"><a id="_idTextAnchor063"/>Implementing the discovery logic</h2>
			<p lang="en-GB">One<a id="_idIndexMarker157"/> of the benefits of the interface that we defined earlier is that we can create multiple implementations and use them in our <a id="_idIndexMarker158"/>application. So, for example, we can create one implementation that we can later use in tests, whereas another implementation would be used in production. To illustrate this approach, we are going to create two implementations:</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">In-memory service discovery</strong>: Use<a id="_idIndexMarker159"/> an in-memory registry for storing the set of addresses.</li>
				<li lang="en-GB"><strong class="bold" lang="">Consul-based service discovery</strong>: Use<a id="_idIndexMarker160"/> the Hashicorp Consul service registry for storing and retrieving service addresses.</li>
			</ul>
			<p lang="en-GB">Now, let’s proceed to implement the logic.</p>
			<h3 lang="en-GB">In-memory implementation</h3>
			<p lang="en-GB">Let’s start with<a id="_idIndexMarker161"/> the in-memory implementation first. In this implementation, we will be storing the service registry records in memory using a simple map data structure. Here are the steps:</p>
			<ol>
				<li lang="en-GB">Create a <strong class="source-inline" lang="">pkg/discovery/memorypackage</strong> file and a  <strong class="source-inline" lang="">memory.go</strong> file, then add the<a id="_idIndexMarker162"/> following:<pre class="source-code" lang="en-GB">
package memory</pre><pre class="source-code" lang="en-GB">
import (</pre><pre class="source-code" lang="en-GB">
    "context"</pre><pre class="source-code" lang="en-GB">
    "errors"</pre><pre class="source-code" lang="en-GB">
    "net"</pre><pre class="source-code" lang="en-GB">
    "sync"</pre><pre class="source-code" lang="en-GB">
    "time"</pre><pre class="source-code" lang="en-GB">
    "movieexample.com/pkg/discovery"</pre><pre class="source-code" lang="en-GB">
)</pre><pre class="source-code" lang="en-GB">
type serviceName string</pre><pre class="source-code" lang="en-GB">
type instanceID string</pre><pre class="source-code" lang="en-GB">
// Registry defines an in-memory service registry.</pre><pre class="source-code" lang="en-GB">
type Registry struct {</pre><pre class="source-code" lang="en-GB">
    sync.RWMutex</pre><pre class="source-code" lang="en-GB">
    serviceAddrs map[serviceName]map[instanceID]*serviceInstance</pre><pre class="source-code" lang="en-GB">
}</pre><pre class="source-code" lang="en-GB">
type serviceInstance struct {</pre><pre class="source-code" lang="en-GB">
    hostPort   string</pre><pre class="source-code" lang="en-GB">
    lastActive time.Time</pre><pre class="source-code" lang="en-GB">
}</pre><pre class="source-code" lang="en-GB">
// NewRegistry creates a new in-memory service</pre><pre class="source-code" lang="en-GB">
// registry instance.</pre><pre class="source-code" lang="en-GB">
func NewRegistry() *Registry {</pre><pre class="source-code" lang="en-GB">
    return &amp;Registry{serviceAddrs: map[serviceName]map[instanceID]*serviceInstance{}}</pre><pre class="source-code" lang="en-GB">
}</pre></li>
				<li lang="en-GB">Let’s implement <a id="_idIndexMarker163"/>our <strong class="source-inline" lang="">Register</strong> and <strong class="source-inline" lang="">Deregister</strong> functions:<pre class="source-code" lang="en-GB">
// Register creates a service record in the registry.</pre><pre class="source-code" lang="en-GB">
func (r *Registry) Register(ctx context.Context, instanceID string, serviceName string, hostPort string) error {</pre><pre class="source-code" lang="en-GB">
    r.Lock()</pre><pre class="source-code" lang="en-GB">
    defer r.Unlock()</pre><pre class="source-code" lang="en-GB">
    if _, ok := r.serviceAddrs[serviceName]; !ok {</pre><pre class="source-code" lang="en-GB">
        r.serviceAddrs[serviceName] = map[string]*serviceInstance{}</pre><pre class="source-code" lang="en-GB">
    }</pre><pre class="source-code" lang="en-GB">
    r.serviceAddrs[serviceName][instanceID] = &amp;serviceInstance{hostPort: hostPort, lastActive: time.Now()}</pre><pre class="source-code" lang="en-GB">
    return nil</pre><pre class="source-code" lang="en-GB">
}</pre><pre class="source-code" lang="en-GB">
// Deregister removes a service record from the</pre><pre class="source-code" lang="en-GB">
// registry.</pre><pre class="source-code" lang="en-GB">
func (r *Registry) Deregister(ctx context.Context, instanceID string, serviceName string) error {</pre><pre class="source-code" lang="en-GB">
    r.Lock()</pre><pre class="source-code" lang="en-GB">
    defer r.Unlock()</pre><pre class="source-code" lang="en-GB">
    if _, ok := r.serviceAddrs[serviceName]; !ok {</pre><pre class="source-code" lang="en-GB">
        return nil</pre><pre class="source-code" lang="en-GB">
    }</pre><pre class="source-code" lang="en-GB">
    delete(r.serviceAddrs[serviceName], instanceID)</pre><pre class="source-code" lang="en-GB">
    return nil</pre><pre class="source-code" lang="en-GB">
}</pre></li>
				<li lang="en-GB">Finally, let’s<a id="_idIndexMarker164"/> implement the remaining two functions of the <strong class="source-inline" lang="">Registry</strong> interface:<pre class="source-code" lang="en-GB">
// ReportHealthyState is a push mechanism for</pre><pre class="source-code" lang="en-GB">
// reporting healthy state to the registry.</pre><pre class="source-code" lang="en-GB">
func (r *Registry) ReportHealthyState(instanceID string, serviceName string) error {</pre><pre class="source-code" lang="en-GB">
    r.Lock()</pre><pre class="source-code" lang="en-GB">
    defer r.Unlock()</pre><pre class="source-code" lang="en-GB">
    if _, ok := r.serviceAddrs[serviceName]; !ok {</pre><pre class="source-code" lang="en-GB">
        return errors.New("service is not registered yet")</pre><pre class="source-code" lang="en-GB">
    }</pre><pre class="source-code" lang="en-GB">
    if _, ok := r.serviceAddrs[serviceName][instanceID]; !ok {</pre><pre class="source-code" lang="en-GB">
        return errors.New("service instance is not registered yet")</pre><pre class="source-code" lang="en-GB">
    }</pre><pre class="source-code" lang="en-GB">
    r.serviceAddrs[serviceName][instanceID].lastActive = time.Now()</pre><pre class="source-code" lang="en-GB">
    return nil</pre><pre class="source-code" lang="en-GB">
}</pre><pre class="source-code" lang="en-GB">
// ServiceAddresses returns the list of addresses of</pre><pre class="source-code" lang="en-GB">
// active instances of the given service.</pre><pre class="source-code" lang="en-GB">
func (r *Registry) ServiceAddresses(ctx context.Context, serviceName string) ([]string, error) {</pre><pre class="source-code" lang="en-GB">
    r.RLock()</pre><pre class="source-code" lang="en-GB">
    defer r.RUnlock()</pre><pre class="source-code" lang="en-GB">
    if len(r.serviceAddrs[serviceName]) == 0 {</pre><pre class="source-code" lang="en-GB">
        return nil, discovery.ErrNotFound</pre><pre class="source-code" lang="en-GB">
    }</pre><pre class="source-code" lang="en-GB">
    var res []string</pre><pre class="source-code" lang="en-GB">
    for _, i := range r.serviceAddrs[serviceName] {</pre><pre class="source-code" lang="en-GB">
        if i.lastActive.Before(time.Now().Add(-5 * time.Second)) {</pre><pre class="source-code" lang="en-GB">
            continue</pre><pre class="source-code" lang="en-GB">
        }</pre><pre class="source-code" lang="en-GB">
        res = append(res, i.hostPort)</pre><pre class="source-code" lang="en-GB">
    }</pre><pre class="source-code" lang="en-GB">
    return res, nil</pre><pre class="source-code" lang="en-GB">
}</pre></li>
			</ol>
			<p lang="en-GB">This implementation can be used in tests or simple applications running on a single server. The implementation<a id="_idIndexMarker165"/> is based on a combination of a map data structure and <strong class="source-inline" lang="">sync.RWMutex</strong>, allowing reads and writes to the map concurrently. In the map, we store <strong class="source-inline" lang="">serviceInstance</strong> structures containing the instance address and the last time of a successful health check for it, which can be set by calling a <strong class="source-inline" lang="">ReportHealthyState</strong> function. In the <strong class="source-inline" lang="">ServiceAddresses</strong> function, we only return instances with successful health checks from within the last 5 seconds.</p>
			<p lang="en-GB">Let’s now move to the Consul-based service registry implementation.</p>
			<h3 lang="en-GB">Consul-based implementation</h3>
			<p lang="en-GB">The implementation<a id="_idIndexMarker166"/> that we are going to work on now will use Hashicorp Consul as a service registry:</p>
			<ol>
				<li lang="en-GB" value="1">First, create a <strong class="source-inline" lang="">pkg/discovery/consul</strong> package and add to it a file named <strong class="source-inline" lang="">consul.go</strong>:<pre class="source-code" lang="en-GB">
 package consul</pre><pre class="source-code" lang="en-GB">
import (</pre><pre class="source-code" lang="en-GB">
    "context"</pre><pre class="source-code" lang="en-GB">
    "errors"</pre><pre class="source-code" lang="en-GB">
    "fmt"</pre><pre class="source-code" lang="en-GB">
    "strconv"</pre><pre class="source-code" lang="en-GB">
    "strings"</pre><pre class="source-code" lang="en-GB">
    consul "github.com/hashicorp/consul/api"</pre><pre class="source-code" lang="en-GB">
    "movieexample.com/pkg/discovery"</pre><pre class="source-code" lang="en-GB">
)</pre><pre class="source-code" lang="en-GB">
// Registry defines a Consul-based service regisry.</pre><pre class="source-code" lang="en-GB">
type Registry struct {</pre><pre class="source-code" lang="en-GB">
    client *consul.Client</pre><pre class="source-code" lang="en-GB">
}</pre><pre class="source-code" lang="en-GB">
// NewRegistry creates a new Consul-based service</pre><pre class="source-code" lang="en-GB">
// registry instance.</pre><pre class="source-code" lang="en-GB">
func NewRegistry(addr string) (*Registry, error) {</pre><pre class="source-code" lang="en-GB">
    config := consul.DefaultConfig()</pre><pre class="source-code" lang="en-GB">
    config.Address = addr</pre><pre class="source-code" lang="en-GB">
    client, err := consul.NewClient(config)</pre><pre class="source-code" lang="en-GB">
    if err != nil {</pre><pre class="source-code" lang="en-GB">
        return nil, err</pre><pre class="source-code" lang="en-GB">
    }</pre><pre class="source-code" lang="en-GB">
    return &amp;Registry{client: client}, nil</pre><pre class="source-code" lang="en-GB">
}</pre></li>
				<li lang="en-GB">Now, let’s<a id="_idIndexMarker167"/> implement the functions of our interface to register and reregister the records:<pre class="source-code" lang="en-GB">
 // Register creates a service record in the registry.</pre><pre class="source-code" lang="en-GB">
func (r *Registry) Register(ctx context.Context, instanceID string, serviceName string, hostPort string) error {</pre><pre class="source-code" lang="en-GB">
    parts := strings.Split(hostPort, ":")</pre><pre class="source-code" lang="en-GB">
    if len(parts) != 2 {</pre><pre class="source-code" lang="en-GB">
        return errors.New("hostPort must be in a form of &lt;host&gt;:&lt;port&gt;, example: localhost:8081")</pre><pre class="source-code" lang="en-GB">
    }</pre><pre class="source-code" lang="en-GB">
    port, err := strconv.Atoi(parts[1])</pre><pre class="source-code" lang="en-GB">
    if err != nil {</pre><pre class="source-code" lang="en-GB">
        return err</pre><pre class="source-code" lang="en-GB">
    }</pre><pre class="source-code" lang="en-GB">
    return r.client.Agent().ServiceRegister(&amp;consul.AgentServiceRegistration{</pre><pre class="source-code" lang="en-GB">
        Address: parts[0],</pre><pre class="source-code" lang="en-GB">
        ID:      instanceID,</pre><pre class="source-code" lang="en-GB">
        Name:    serviceName,</pre><pre class="source-code" lang="en-GB">
        Port:    port,</pre><pre class="source-code" lang="en-GB">
        Check:   &amp;consul.AgentServiceCheck{CheckID: instanceID, TTL: "5s"},</pre><pre class="source-code" lang="en-GB">
    })</pre><pre class="source-code" lang="en-GB">
}</pre><pre class="source-code" lang="en-GB">
// Deregister removes a service record from the</pre><pre class="source-code" lang="en-GB">
// registry.</pre><pre class="source-code" lang="en-GB">
func (r *Registry) Deregister(ctx context.Context, instanceID string, _ string) error {</pre><pre class="source-code" lang="en-GB">
    return r.client.Agent().ServiceDeregister(instanceID)</pre><pre class="source-code" lang="en-GB">
}</pre></li>
				<li lang="en-GB">Finally, let’s<a id="_idIndexMarker168"/> implement the remaining registry functions:<pre class="source-code" lang="en-GB">
// ServiceAddresses returns the list of addresses of</pre><pre class="source-code" lang="en-GB">
// active instances of the given service.</pre><pre class="source-code" lang="en-GB">
func (r *Registry) ServiceAddresses(ctx context.Context, serviceName string) ([]string, error) {</pre><pre class="source-code" lang="en-GB">
    entries, _, err := r.client.Health().Service(serviceName, "", true, nil)</pre><pre class="source-code" lang="en-GB">
    if err != nil {</pre><pre class="source-code" lang="en-GB">
        return nil, err</pre><pre class="source-code" lang="en-GB">
    } else if len(entries) == 0 {</pre><pre class="source-code" lang="en-GB">
        return nil, discovery.ErrNotFound</pre><pre class="source-code" lang="en-GB">
    }</pre><pre class="source-code" lang="en-GB">
    var res []string</pre><pre class="source-code" lang="en-GB">
    for _, e := range entries {</pre><pre class="source-code" lang="en-GB">
        res = append(res, res = append(res, fmt.Sprintf("%s:%d", e.Service.Address, e.Service.Port)))</pre><pre class="source-code" lang="en-GB">
    }</pre><pre class="source-code" lang="en-GB">
    return res, nil</pre><pre class="source-code" lang="en-GB">
}</pre><pre class="source-code" lang="en-GB">
// ReportHealthyState is a push mechanism for</pre><pre class="source-code" lang="en-GB">
// reporting healthy state to the registry.</pre><pre class="source-code" lang="en-GB">
func (r *Registry) ReportHealthyState(instanceID string, _ string) error {</pre><pre class="source-code" lang="en-GB">
    return r.client.Agent().PassTTL(instanceID, "")</pre><pre class="source-code" lang="en-GB">
}</pre></li>
			</ol>
			<p lang="en-GB">Our client depends <a id="_idIndexMarker169"/>on an external library, <strong class="source-inline" lang="">github.com/hashicorp/consul/api</strong>. We need to fetch it now by running <strong class="source-inline" lang="">go mod tidy</strong> inside our <strong class="source-inline" lang="">src</strong> directory. After this, Go should fetch the dependency, and our logic should be able to compile.</p>
			<p lang="en-GB">Now, we are ready to plug the logic we just created into our microservices.</p>
			<h2 id="_idParaDest-64" lang="en-GB"><a id="_idTextAnchor064"/>Using the discovery logic</h2>
			<p lang="en-GB">Now, we<a id="_idIndexMarker170"/> need to add logic for initializing and discovering the services. Currently, only the movie service communicates with the other two, so we are going to illustrate how to add service discovery using the movie service as an example.</p>
			<p lang="en-GB">Let’s start with our gateways:</p>
			<ol>
				<li lang="en-GB" value="1">In the previous chapter, we created two gateways for calling the metadata and the rating services. Let’s modify their structures to the one shown here:<pre class="source-code" lang="en-GB">
type Gateway struct {</pre><pre class="source-code" lang="en-GB">
    registry discovery.Registry</pre><pre class="source-code" lang="en-GB">
}</pre></li>
				<li lang="en-GB">Also, change the <strong class="source-inline" lang="">New</strong> function format to the following:<pre class="source-code" lang="en-GB">
func New(registry discovery.Registry) *Gateway {</pre><pre class="source-code" lang="en-GB">
    return &amp;Gateway{registry}</pre><pre class="source-code" lang="en-GB">
}</pre></li>
				<li lang="en-GB">Now, the gateways <a id="_idIndexMarker171"/>require a registry on creation. We can change the beginning of the <strong class="source-inline" lang="">Get</strong> function of the metadata gateway to this now:<pre class="source-code" lang="en-GB">
func (g *Gateway) Get(ctx context.Context, id string) (*model.Metadata, error) {</pre><pre class="source-code" lang="en-GB">
    addrs, err := g.registry.ServiceAddresses(ctx, "metadata")</pre><pre class="source-code" lang="en-GB">
    if err != nil {</pre><pre class="source-code" lang="en-GB">
        return nil, err</pre><pre class="source-code" lang="en-GB">
    }</pre><pre class="source-code" lang="en-GB">
    url := "http://" + addrs[rand.Intn(len(addrs))] + "/metadata"</pre><pre class="source-code" lang="en-GB">
    log.Printf("Calling metadata service. Request: GET " + url)</pre><pre class="source-code" lang="en-GB">
    req, err := http.NewRequest(http.MethodGet, url, nil)</pre></li>
			</ol>
			<p lang="en-GB">You may notice that instead of calling a static pre-configured address, we now first get the <a id="_idIndexMarker172"/>available addresses of the metadata from the registry. This is the essence of service discovery – we use the data from the registry for making remote calls between our services. After we get the list of service addresses, we pick a random one using a <strong class="source-inline" lang="">rand.Intn</strong> function. By doing this, we balance the load between the active instances, randomly selecting any available instance on each request.</p>
			<ol>
				<li lang="en-GB" value="4">Now, updating the rating gateway in the same way, we changed the metadata service.</li>
				<li lang="en-GB">The next step is to update the <strong class="source-inline" lang="">main</strong> functions of our services so that each service will register and deregister itself in the service registry. Let’s update the metadata service first. Update its <strong class="source-inline" lang="">main</strong> function to the following:<pre class="source-code" lang="en-GB">
const serviceName = "metadata"</pre><pre class="source-code" lang="en-GB">
func main() {</pre><pre class="source-code" lang="en-GB">
    var port int</pre><pre class="source-code" lang="en-GB">
    flag.IntVar(&amp;port, "port", 8081, "API handler port")</pre><pre class="source-code" lang="en-GB">
    flag.Parse()</pre><pre class="source-code" lang="en-GB">
    log.Printf("Starting the metadata service on port %d", port)</pre><pre class="source-code" lang="en-GB">
    registry, err := consul.NewRegistry("localhost:8500")</pre><pre class="source-code" lang="en-GB">
    if err != nil {</pre><pre class="source-code" lang="en-GB">
        panic(err)</pre><pre class="source-code" lang="en-GB">
    }</pre><pre class="source-code" lang="en-GB">
    ctx := context.Background()</pre><pre class="source-code" lang="en-GB">
    instanceID := discovery.GenerateInstanceID(serviceName)</pre><pre class="source-code" lang="en-GB">
    if err := registry.Register(ctx, instanceID, serviceName, fmt.Sprintf("localhost:%d", port)); err != nil {</pre><pre class="source-code" lang="en-GB">
        panic(err)</pre><pre class="source-code" lang="en-GB">
    }</pre><pre class="source-code" lang="en-GB">
    go func() {</pre><pre class="source-code" lang="en-GB">
        for {</pre><pre class="source-code" lang="en-GB">
            if err := registry.ReportHealthyState(instanceID, serviceName); err != nil {</pre><pre class="source-code" lang="en-GB">
                log.Println("Failed to report healthy state: " + err.Error())</pre><pre class="source-code" lang="en-GB">
            }</pre><pre class="source-code" lang="en-GB">
            time.Sleep(1 * time.Second)</pre><pre class="source-code" lang="en-GB">
        }</pre><pre class="source-code" lang="en-GB">
    }()</pre><pre class="source-code" lang="en-GB">
    defer registry.Deregister(ctx, instanceID, serviceName)</pre><pre class="source-code" lang="en-GB">
    repo := memory.New()</pre><pre class="source-code" lang="en-GB">
    svc := metadata.New(repo)</pre><pre class="source-code" lang="en-GB">
    h := httphandler.New(svc)</pre><pre class="source-code" lang="en-GB">
    http.Handle("/metadata", http.HandlerFunc(h.GetMetadataByID))</pre><pre class="source-code" lang="en-GB">
    if err := http.ListenAndServe(fmt.Sprintf(":%d", port), nil); err != nil {</pre><pre class="source-code" lang="en-GB">
        panic(err)</pre><pre class="source-code" lang="en-GB">
    }</pre><pre class="source-code" lang="en-GB">
}</pre></li>
			</ol>
			<p lang="en-GB">In the preceding code, we added the logic for registering and deregistering the service in the Consul-based service registry and reporting its healthy state to it every second.</p>
			<ol>
				<li lang="en-GB" value="6">Let’s add <a id="_idIndexMarker173"/>similar logic to the rating service. Update its <strong class="source-inline" lang="">main</strong> function as follows:<pre class="source-code" lang="en-GB">
func main() {</pre><pre class="source-code" lang="en-GB">
    var port int</pre><pre class="source-code" lang="en-GB">
    flag.IntVar(&amp;port, "port", 8082, "API handler port")</pre><pre class="source-code" lang="en-GB">
    flag.Parse()</pre><pre class="source-code" lang="en-GB">
    log.Printf("Starting the rating service on port %d", port)</pre><pre class="source-code" lang="en-GB">
    registry, err := consul.NewRegistry("localhost:8500")</pre><pre class="source-code" lang="en-GB">
    if err != nil {</pre><pre class="source-code" lang="en-GB">
        panic(err)</pre><pre class="source-code" lang="en-GB">
    }</pre><pre class="source-code" lang="en-GB">
    ctx := context.Background()</pre><pre class="source-code" lang="en-GB">
    instanceID := discovery.GenerateInstanceID(serviceName)</pre><pre class="source-code" lang="en-GB">
    if err := registry.Register(ctx, instanceID, serviceName, fmt.Sprintf("localhost:%d", port)); err != nil {</pre><pre class="source-code" lang="en-GB">
        panic(err)</pre><pre class="source-code" lang="en-GB">
    }</pre><pre class="source-code" lang="en-GB">
    go func() {</pre><pre class="source-code" lang="en-GB">
        for {</pre><pre class="source-code" lang="en-GB">
            if err := registry.ReportHealthyState(instanceID, serviceName); err != nil {</pre><pre class="source-code" lang="en-GB">
                log.Println("Failed to report healthy state: " + err.Error())</pre><pre class="source-code" lang="en-GB">
            }</pre><pre class="source-code" lang="en-GB">
            time.Sleep(1 * time.Second)</pre><pre class="source-code" lang="en-GB">
        }</pre><pre class="source-code" lang="en-GB">
    }()</pre><pre class="source-code" lang="en-GB">
    defer registry.Deregister(ctx, instanceID, serviceName)</pre><pre class="source-code" lang="en-GB">
    repo := memory.New()</pre><pre class="source-code" lang="en-GB">
    svc := controller.New(repo)</pre><pre class="source-code" lang="en-GB">
    h := httphandler.New(svc)</pre><pre class="source-code" lang="en-GB">
    http.Handle("/rating", http.HandlerFunc(h.Handle))</pre><pre class="source-code" lang="en-GB">
    if err := http.ListenAndServe(fmt.Sprintf(":%d", port), nil); err != nil {</pre><pre class="source-code" lang="en-GB">
        panic(err)</pre><pre class="source-code" lang="en-GB">
    }</pre><pre class="source-code" lang="en-GB">
}</pre></li>
			</ol>
			<p lang="en-GB">The changes that<a id="_idIndexMarker174"/> we just made are similar to the ones we did for the metadata service.</p>
			<ol>
				<li lang="en-GB" value="7">The last step is to modify the <strong class="source-inline" lang="">main</strong> function of the movie service, replacing it with the following:<pre class="source-code" lang="en-GB">
 func main() {</pre><pre class="source-code" lang="en-GB">
    var port int</pre><pre class="source-code" lang="en-GB">
    flag.IntVar(&amp;port, "port", 8083, "API handler port")</pre><pre class="source-code" lang="en-GB">
    flag.Parse()</pre><pre class="source-code" lang="en-GB">
    log.Printf("Starting the movie service on port %d", port)</pre><pre class="source-code" lang="en-GB">
    registry, err := consul.NewRegistry("localhost:8500")</pre><pre class="source-code" lang="en-GB">
    if err != nil {</pre><pre class="source-code" lang="en-GB">
        panic(err)</pre><pre class="source-code" lang="en-GB">
    }</pre><pre class="source-code" lang="en-GB">
    ctx := context.Background()</pre><pre class="source-code" lang="en-GB">
    instanceID := discovery.GenerateInstanceID(serviceName)</pre><pre class="source-code" lang="en-GB">
    if err := registry.Register(ctx, instanceID, serviceName, fmt.Sprintf("localhost:%d", port)); err != nil {</pre><pre class="source-code" lang="en-GB">
        panic(err)</pre><pre class="source-code" lang="en-GB">
    }</pre><pre class="source-code" lang="en-GB">
    go func() {</pre><pre class="source-code" lang="en-GB">
        for {</pre><pre class="source-code" lang="en-GB">
            if err := registry.ReportHealthyState(instanceID, serviceName); err != nil {</pre><pre class="source-code" lang="en-GB">
                log.Println("Failed to report healthy state: " + err.Error())</pre><pre class="source-code" lang="en-GB">
            }</pre><pre class="source-code" lang="en-GB">
            time.Sleep(1 * time.Second)</pre><pre class="source-code" lang="en-GB">
        }</pre><pre class="source-code" lang="en-GB">
    }()</pre><pre class="source-code" lang="en-GB">
    defer registry.Deregister(ctx, instanceID, serviceName)</pre><pre class="source-code" lang="en-GB">
    metadataGateway := metadatagateway.New(registry)</pre><pre class="source-code" lang="en-GB">
    ratingGateway := ratinggateway.New(registry)</pre><pre class="source-code" lang="en-GB">
    svc := movie.New(ratingGateway, metadataGateway)</pre><pre class="source-code" lang="en-GB">
    h := httphandler.New(svc)</pre><pre class="source-code" lang="en-GB">
    http.Handle("/movie", http.HandlerFunc(h.GetMovieDetails))</pre><pre class="source-code" lang="en-GB">
    if err := http.ListenAndServe(fmt.Sprintf(":%d", port), nil); err != nil {</pre><pre class="source-code" lang="en-GB">
        panic(err)</pre><pre class="source-code" lang="en-GB">
    }</pre><pre class="source-code" lang="en-GB">
}</pre></li>
			</ol>
			<p lang="en-GB">At this point, we have<a id="_idIndexMarker175"/> successfully added Consul-based service discovery to our applications. Let’s illustrate how it works in practice:</p>
			<ol>
				<li lang="en-GB" value="1">In order to run our applications now, you would need Hashicorp Consul to run locally. The easiest way would be to run it using a Docker tool. Assuming you have already installed Docker <a id="_idIndexMarker176"/>from its website, <a href="http://docker.com">docker.com</a>, you can run the following command:</li>
			</ol>
			<pre class="source-code" lang="en-GB">
docker run -d -p 8500:8500 -p 8600:8600/udp --name=dev-consul consul agent -server -ui -node=server-1 -bootstrap-expect=1 -client=0.0.0.0</pre>
			<p lang="en-GB">The preceding command runs Hashicorp Consul inside Docker in development mode, exposing its ports <strong class="source-inline" lang="">8500</strong> and <strong class="source-inline" lang="">8600</strong> for local use.</p>
			<ol>
				<li lang="en-GB" value="2">Run each microservice by executing this command inside each <strong class="source-inline" lang="">cmd</strong> directory:</li>
			</ol>
			<pre class="source-code" lang="en-GB">
go run *.go</pre>
			<ol>
				<li lang="en-GB" value="3">Now, go to the Consul web UI via its link, <a href="http://localhost:8500/">http://localhost:8500/</a>. When you open the <strong class="bold" lang="">Services</strong> tab, you should see the list of our services and an active Consul instance:</li>
			</ol>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/B18865_04_Figure_3.jpg" alt="Figure 3.4 – Consul web view of active service instances&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Consul web view of active service instances</p>
			<p lang="en-GB">You can optionally add <a id="_idIndexMarker177"/>some additional instances of each service by running the following:</p>
			<pre class="source-code" lang="en-GB">
go run *.go --port &lt;PORT&gt;</pre>
			<p lang="en-GB">If you run the preceding command, replace the <strong class="source-inline" lang="">&lt;PORT&gt;</strong> placeholder with unique port numbers that are not in use yet (in our examples, we used ports <strong class="source-inline" lang="">8081</strong>, <strong class="source-inline" lang="">8082</strong>, and <strong class="source-inline" lang="">8083</strong>, so you can run with port numbers starting with <strong class="source-inline" lang="">8084</strong>). The result of each command would be additional healthy instances in the Consul service view illustrated earlier.</p>
			<p lang="en-GB">You can also try shutting down any service manually by terminating the <strong class="source-inline" lang="">go run</strong> commands and seeing how instances change their states from <strong class="source-inline" lang="">Passing</strong> to <strong class="source-inline" lang="">Critical</strong>.</p>
			<ol>
				<li lang="en-GB" value="4">To test API requests, ensure you have at least one healthy instance of each service and make the following request to a movie service:</li>
			</ol>
			<pre class="source-code" lang="en-GB">
curl -v localhost:8083/movie?id=1</pre>
			<ol>
				<li lang="en-GB" value="5">Check the<a id="_idIndexMarker178"/> output logs of the movie service now (you should be able to see them in the terminal where you ran the <strong class="source-inline" lang="">go run</strong> command for the movie service). If you did everything correctly, you should see a similar line:<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">2022/06/08 13:37:42 Calling metadata service. Request: GET http://localhost:8081/metadata</strong></pre></li>
			</ol>
			<p lang="en-GB">The preceding line is the result of a call to the service registry backed by the Consul. In our metadata service gateway implementation, we select a random active instance from the registry and log its address before making a call. If you have more than one instance of a metadata service, you can make multiple <strong class="source-inline" lang="">curl</strong> requests listed previously and see that the movie service always picks a random instance among them.</p>
			<p lang="en-GB">At this point, we have illustrated how to use service discovery with our microservices. We can now dynamically scale our microservices by adding and removing their instances without any need to change the service code. We also have two working implementations of a service registry that you can use in your code. Now, we are ready to move to the next chapter, covering another important topic, data serialization.</p>
			<h1 id="_idParaDest-65" lang="en-GB"><a id="_idTextAnchor065"/>Summary</h1>
			<p lang="en-GB">In this chapter, we did an overview of service discovery and compared its different models. You have learned what the service registry is and what its main service discovery models are. We have illustrated how to use a client-side service discovery model by providing two implementations, one using an in-memory set of data and another using Hashicorp Consul. We have also plugged the Consul-based implementation into our microservices to demonstrate how to use it in the microservice logic. Now, you know how to add and use service discovery in your applications.</p>
			<p lang="en-GB">In the next chapter, we are going to discuss another important topic: serialization. You will learn how to encode and decode the data transferred between the services. This will help us move to further topics, covering the communication between the services we will cover in <a href="B18865_05.xhtml#_idTextAnchor076"><em class="italic" lang="">Chapter 5</em></a>.</p>
			<h1 id="_idParaDest-66" lang="en-GB"><a id="_idTextAnchor066"/>Further reading</h1>
			<ul>
				<li lang="en-GB"><em class="italic" lang="">Service discovery overview</em>: <a href="https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture ">https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture</a></li>
				<li lang="en-GB"><em class="italic" lang="">Server-side service discovery</em>: <a href="https://microservices.io/patterns/server-side-discovery.html">https://microservices.io/patterns/server-side-discovery.html</a></li>
			</ul>
		</div>
	</body></html>