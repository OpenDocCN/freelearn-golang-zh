- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Service Discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we created our example microservices and let them communicate
    with each other, using static local addresses hardcoded into each service. This
    approach would work until we to add or remove service instances dynamically, known
    as service discovery – letting microservices find each other in a dynamic environment.
    Setting up service discovery is the first step for writing and preparing scalable
    microservices in a real production environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Service discovery overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service discovery solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adopting service discovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use the microservices we created in the previous chapter to illustrate
    how to use the service discovery solutions. Now, let’s move on to the overview
    of the service discovery concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to complete this chapter, you need Go 1.11 or above. Additionally,
    you will need a Docker tool, which you can download from [https://www.docker.com](https://www.docker.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the source files for this chapter on GitHub: [https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter03](https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter03).'
  prefs: []
  type: TYPE_NORMAL
- en: Service discovery overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we created an application consisting of three microservices.
    The relationship between the services is illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Relationship between our microservices'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18865_03_Figure_1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Relationship between our microservices
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the movie service calls both the metadata and rating service
    for fetching the complete movie details.
  prefs: []
  type: TYPE_NORMAL
- en: But how would our services send requests? How would they know the addresses
    of each other?
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we used pre-programmed static values for the API handlers.
    The settings we used were as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`localhost:8081`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`localhost:8082`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`localhost:8083`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our approach, each service would need to know the exact address of the other
    services it would communicate with. This approach would work until we more than
    one instance of each microservice. In this case, we would have multiple challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: What address should you use when you have multiple instances?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to handle the situation when some instances become unavailable?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first problem is relatively easy to solve if you have a static set of instances
    – your services would need to keep a list of addresses for each service they need
    to call. However, this approach is not flexible for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Each time you need to add or remove instances, you need to update the configuration
    of each calling service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an instance becomes unavailable for an extended period (for example, due
    to network failure), your services would still keep calling it until you updated
    their configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you solve these problems properly?
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem we just described for our microservices is called **service discovery**.
    In general, service discovery addresses multiple problems, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: How to discover the instance(s) of a particular service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to add and remove instances of service in a discoverable environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to handle the issue when instances become unresponsive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s see how each of these features would work.
  prefs: []
  type: TYPE_NORMAL
- en: Registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The foundation of service discovery is a registry (also known as a service
    registry), which stores information about available service instances. It has
    the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Register an instance of a service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deregister an instance of a service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return the list of all the instances of the service in the form of their network
    addresses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is an example of service discovery registry data:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Service name** | **Address list** |'
  prefs: []
  type: TYPE_TB
- en: '| Movie service | `172.18.10.2:2520``172.18.12.55:8800``172.18.89.10:2450`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Rating service | `172.18.25.11:1100``172.18.9.55:2830` |'
  prefs: []
  type: TYPE_TB
- en: '| Movie metadata service | `172.18.79.115:3512``172.17.3.8:9900` |'
  prefs: []
  type: TYPE_TB
- en: Table 3.1 – Registry data
  prefs: []
  type: TYPE_NORMAL
- en: Each service can either register in the registry by itself or use some library
    or tool to register on service startup automatically. Once the service is registered,
    it starts being monitored via health checks to ensure the registry contains only
    available instances.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now see the two common models of adopting service discovery.
  prefs: []
  type: TYPE_NORMAL
- en: Service discovery models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the applications, there are two ways of interacting with the registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client-side service discovery**: Access the registry directly from the application
    using a registry client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server-side service discovery**: Access the registry indirectly via a load
    balancer, a special server that forwards requests to available instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s see the advantages and disadvantages of each model.
  prefs: []
  type: TYPE_NORMAL
- en: Client-side service discovery
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the client-side service discovery model, each application or service accesses
    the service registry directly by requesting all available instances of a target
    service. When the application receives a response, it uses the addresses of the
    target service for making requests. The logic is illustrated in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Client-side service discovery'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18865_03_Figure_2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Client-side service discovery
  prefs: []
  type: TYPE_NORMAL
- en: In this model, the application is responsible for balancing the load on the
    service it is calling – if an application picked just one instance from the list
    and kept calling it all the time, it would overload that instance and underutilize
    the other ones.
  prefs: []
  type: TYPE_NORMAL
- en: The downside of this model is that the calling application needs to be programmed
    with load-balancing logic. In addition, this couples service discovery and load-balancing
    logic with the application code, making the application more complex.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side service discovery
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The server-side service discovery model adds an extra layer to the interaction
    between the calling applications and the registry. Instead of calling the registry
    directly, applications send their requests to target microservices via a special
    server called a load balancer. The load balancer is responsible for interacting
    with the registry and distributing requests between all available instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram will help you understand the server-side service discovery
    model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Server-side service discovery'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18865_03_Figure_3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Server-side service discovery
  prefs: []
  type: TYPE_NORMAL
- en: 'In the diagram, the application calls the target service via a load balancer,
    accessing the service registry to read the list of active service instances from
    it. In this model, the application does not need to know about the registry. This
    is the main benefit of the server-side service discovery model: it helps decouple
    the interaction with the service registry from each calling application, making
    the application logic simpler. The downside of the model is that it requires setting
    up and using a load balancer. The latter is rather an untrivial operation, and
    we are not going to cover it in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see how the registry can keep the list of only active instances of
    each service.
  prefs: []
  type: TYPE_NORMAL
- en: Service health monitoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The registry keeps the information about the instances up to date either via
    a pull or a push model:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pull model**: The service registry periodically performs a health check for
    each known instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Push model**: The application renews its status by contacting the registry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pull model removes the need to implement status renewal on a service level.
    In a push model, the application is responsible for renewing its status or telling
    the service registry about its healthy status.
  prefs: []
  type: TYPE_NORMAL
- en: Now, as we have covered the theoretical basics of service discovery, let’s see
    which existing solutions you can use to enable your microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Service discovery solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to describe the existing service discovery solutions
    available for your use – **HashiCorp Consul** and **Kubernetes**. Then, you will
    learn about the most popular tools that can be used by microservice developers
    to perform service discovery.
  prefs: []
  type: TYPE_NORMAL
- en: HashiCorp Consul
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HashiCorp Consul has been a pretty popular solution for service discovery for
    many years. Written in Go, this tool allows you to set up service discovery for
    your services and applications quite easily, using its clients or API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consul has a pretty straightforward API, including the following key endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PUT /catalog/register`: Register a service instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT /catalog/deregister`: Deregister a service instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /catalog/services`: Get the available instances of a service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client applications can access the Consul catalog either via the API or in server-side
    service discovery mode, using a DNS service.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about Consul by checking the official website: [https://consul.io](https://consul.io).'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes is a popular open source platform for running, scaling, and managing
    collections of applications, such as microservices.
  prefs: []
  type: TYPE_NORMAL
- en: One of the features of Kubernetes is the ability to register and discover the
    services that are running in it. Kubernetes provides an API for retrieving the
    list of network addresses of each service that is being updated automatically,
    so users can use it in client-side discovery mode. Alternatively, it allows its
    users to plug in a load balancer to use it for server-side discovery instead.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to cover Kubernetes later, in [*Chapter 8*](B18865_08.xhtml#_idTextAnchor109)
    of this book. Now, let’s see how we can add service discovery to the applications
    we created in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Adopting service discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to illustrate how you can start using service
    discovery for your applications. We will be using the microservices we created
    in the previous chapter as an example. Then, you will learn how to add the logic
    responsible for service discovery to your microservice code.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you consider enabling service discovery for your services, you have multiple
    questions to answer, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Which model would you prefer to use – client-side or server-side discovery?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which platform will you use for the deployment and orchestration of your microservices?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answering the second question may already give you a solution – various deployment
    platforms, including Kubernetes, as well as popular clouds such as AWS, offer
    service discovery for your services.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t know which deployment platform you are going to use for your services
    and you are new to microservice development, you may consider client-side service
    discovery. The client-side discovery model is slightly simpler because your service
    directly coordinates with the service registry. Later, you will be able to switch
    to server-side service discovery, if you want.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start preparing your applications for adding service discovery logic.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s list what we want to achieve from our service discovery code.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to register a service that we are going to use on service startup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to deregister a service that we are going to use on service shutdown
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to get a list of addresses of a particular service that we are going
    to use for making the calls to the other services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up service health monitoring so the service registry is able to remove inactive
    service instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It would be great if our service discovery logic weren’t directly tied to a
    particular tool. It is usually a good practice to abstract the actual technology
    with a more generic interface, which allows us to swap implementations. We can
    illustrate this using an example – imagine we are using the Hashicorp Consul library,
    which returns a list of service addresses in the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If we expose these Consul structures in our code and pass these structures around
    our code base, our service code will be heavily tied to Consul. If we ever decide
    to switch to another service discovery tool, we would need to replace not only
    the service discovery implementation logic but also all the code in which it is
    used.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, let’s define a more generic and technology-agnostic interface. For
    providing the list of service instances, we can just return the list of URLs in
    the `[]string` format.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete interface for our service discovery logic would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you may notice, the interface is pretty generic, yet it allows you to create
    multiple implementations based on different technologies if needed.
  prefs: []
  type: TYPE_NORMAL
- en: You may also notice that the interface includes a `ReportHealthyState` function
    for reporting the healthy state of a service instance. This function allows us
    to implement the push-based service health monitoring that we mentioned before,
    so each microservice would periodically report its health to the service registry.
    The registry would then be able to remove inactive instances of each service if
    they don’t report a healthy state within some defined interval of time (we are
    going to assume the interval is 5 seconds in our implementation).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now think about where we would store the service discovery logic for
    our microservices. I suggest using a package that all three services can access
    – let’s create it in the root directory of our application, under the `pkg` folder.
    We can call it `pkg/discovery`. Inside it, add a `discovery.go` file and add the
    following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the code that we just added, we have defined a `Registry` interface for the
    service registry. Additionally, we defined the `ErrNotFound` error that would
    be returned from the `ServiceAddresses` function if no active service addresses
    were found. Finally, we created a `GenerateInstanceID` function that would help
    us to generate randomized instance identifiers for use with the `Register` and
    `Deregister` functions.
  prefs: []
  type: TYPE_NORMAL
- en: We are ready to begin our work on its implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the discovery logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the benefits of the interface that we defined earlier is that we can
    create multiple implementations and use them in our application. So, for example,
    we can create one implementation that we can later use in tests, whereas another
    implementation would be used in production. To illustrate this approach, we are
    going to create two implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**In-memory service discovery**: Use an in-memory registry for storing the
    set of addresses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consul-based service discovery**: Use the Hashicorp Consul service registry
    for storing and retrieving service addresses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s proceed to implement the logic.
  prefs: []
  type: TYPE_NORMAL
- en: In-memory implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start with the in-memory implementation first. In this implementation,
    we will be storing the service registry records in memory using a simple map data
    structure. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `pkg/discovery/memorypackage` file and a `memory.go` file, then add
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s implement our `Register` and `Deregister` functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let’s implement the remaining two functions of the `Registry` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This implementation can be used in tests or simple applications running on a
    single server. The implementation is based on a combination of a map data structure
    and `sync.RWMutex`, allowing reads and writes to the map concurrently. In the
    map, we store `serviceInstance` structures containing the instance address and
    the last time of a successful health check for it, which can be set by calling
    a `ReportHealthyState` function. In the `ServiceAddresses` function, we only return
    instances with successful health checks from within the last 5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now move to the Consul-based service registry implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Consul-based implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The implementation that we are going to work on now will use Hashicorp Consul
    as a service registry:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a `pkg/discovery/consul` package and add to it a file named `consul.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s implement the functions of our interface to register and reregister
    the records:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let’s implement the remaining registry functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our client depends on an external library, `github.com/hashicorp/consul/api`.
    We need to fetch it now by running `go mod tidy` inside our `src` directory. After
    this, Go should fetch the dependency, and our logic should be able to compile.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to plug the logic we just created into our microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Using the discovery logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we need to add logic for initializing and discovering the services. Currently,
    only the movie service communicates with the other two, so we are going to illustrate
    how to add service discovery using the movie service as an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with our gateways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we created two gateways for calling the metadata and
    the rating services. Let’s modify their structures to the one shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, change the `New` function format to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, the gateways require a registry on creation. We can change the beginning
    of the `Get` function of the metadata gateway to this now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You may notice that instead of calling a static pre-configured address, we now
    first get the available addresses of the metadata from the registry. This is the
    essence of service discovery – we use the data from the registry for making remote
    calls between our services. After we get the list of service addresses, we pick
    a random one using a `rand.Intn` function. By doing this, we balance the load
    between the active instances, randomly selecting any available instance on each
    request.
  prefs: []
  type: TYPE_NORMAL
- en: Now, updating the rating gateway in the same way, we changed the metadata service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is to update the `main` functions of our services so that each
    service will register and deregister itself in the service registry. Let’s update
    the metadata service first. Update its `main` function to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE174]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE175]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE176]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE177]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE178]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE181]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE182]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE183]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE186]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE190]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE191]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE192]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we added the logic for registering and deregistering
    the service in the Consul-based service registry and reporting its healthy state
    to it every second.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add similar logic to the rating service. Update its `main` function as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE198]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE199]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE200]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE201]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE202]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE203]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE204]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE205]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE206]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE207]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE208]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE209]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE210]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE211]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE212]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE213]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE214]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE215]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE216]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE217]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE218]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE219]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE220]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE221]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE222]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE223]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE224]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The changes that we just made are similar to the ones we did for the metadata
    service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to modify the `main` function of the movie service, replacing
    it with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE226]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE227]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE228]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE229]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE230]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE231]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE232]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE233]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE234]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE235]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE236]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE237]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE238]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE239]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE240]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE241]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE242]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE243]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE244]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE245]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE246]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE247]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE248]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE249]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE250]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE251]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE252]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE253]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE254]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE255]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE256]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, we have successfully added Consul-based service discovery to
    our applications. Let’s illustrate how it works in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to run our applications now, you would need Hashicorp Consul to run
    locally. The easiest way would be to run it using a Docker tool. Assuming you
    have already installed Docker from its website, [docker.com](http://docker.com),
    you can run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command runs Hashicorp Consul inside Docker in development mode,
    exposing its ports `8500` and `8600` for local use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run each microservice by executing this command inside each `cmd` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go to the Consul web UI via its link, [http://localhost:8500/](http://localhost:8500/).
    When you open the **Services** tab, you should see the list of our services and
    an active Consul instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Consul web view of active service instances'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18865_04_Figure_3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Consul web view of active service instances
  prefs: []
  type: TYPE_NORMAL
- en: 'You can optionally add some additional instances of each service by running
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: If you run the preceding command, replace the `<PORT>` placeholder with unique
    port numbers that are not in use yet (in our examples, we used ports `8081`, `8082`,
    and `8083`, so you can run with port numbers starting with `8084`). The result
    of each command would be additional healthy instances in the Consul service view
    illustrated earlier.
  prefs: []
  type: TYPE_NORMAL
- en: You can also try shutting down any service manually by terminating the `go run`
    commands and seeing how instances change their states from `Passing` to `Critical`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test API requests, ensure you have at least one healthy instance of each
    service and make the following request to a movie service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the output logs of the movie service now (you should be able to see them
    in the terminal where you ran the `go run` command for the movie service). If
    you did everything correctly, you should see a similar line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding line is the result of a call to the service registry backed by
    the Consul. In our metadata service gateway implementation, we select a random
    active instance from the registry and log its address before making a call. If
    you have more than one instance of a metadata service, you can make multiple `curl`
    requests listed previously and see that the movie service always picks a random
    instance among them.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have illustrated how to use service discovery with our microservices.
    We can now dynamically scale our microservices by adding and removing their instances
    without any need to change the service code. We also have two working implementations
    of a service registry that you can use in your code. Now, we are ready to move
    to the next chapter, covering another important topic, data serialization.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we did an overview of service discovery and compared its different
    models. You have learned what the service registry is and what its main service
    discovery models are. We have illustrated how to use a client-side service discovery
    model by providing two implementations, one using an in-memory set of data and
    another using Hashicorp Consul. We have also plugged the Consul-based implementation
    into our microservices to demonstrate how to use it in the microservice logic.
    Now, you know how to add and use service discovery in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we are going to discuss another important topic: serialization.
    You will learn how to encode and decode the data transferred between the services.
    This will help us move to further topics, covering the communication between the
    services we will cover in [*Chapter 5*](B18865_05.xhtml#_idTextAnchor076).'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Service discovery overview*: [https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture](https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Server-side service discovery*: [https://microservices.io/patterns/server-side-discovery.html](https://microservices.io/patterns/server-side-discovery.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
