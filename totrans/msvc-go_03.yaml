- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Service Discovery
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现
- en: In the previous chapter, we created our example microservices and let them communicate
    with each other, using static local addresses hardcoded into each service. This
    approach would work until we to add or remove service instances dynamically, known
    as service discovery – letting microservices find each other in a dynamic environment.
    Setting up service discovery is the first step for writing and preparing scalable
    microservices in a real production environment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了我们的示例微服务，并让它们使用静态本地地址相互通信，这些地址硬编码在每个服务中。这种方法在需要动态添加或删除服务实例时（称为服务发现）会工作，即让微服务在动态环境中找到彼此。在真实的生产环境中编写和准备可扩展的微服务的第一步是设置服务发现。
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Service discovery overview
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现概述
- en: Service discovery solutions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现解决方案
- en: Adopting service discovery
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用服务发现
- en: We will use the microservices we created in the previous chapter to illustrate
    how to use the service discovery solutions. Now, let’s move on to the overview
    of the service discovery concepts.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用上一章中创建的微服务来说明如何使用服务发现解决方案。现在，让我们继续了解服务发现概念概述。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In order to complete this chapter, you need Go 1.11 or above. Additionally,
    you will need a Docker tool, which you can download from [https://www.docker.com](https://www.docker.com).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章，您需要 Go 1.11 或更高版本。此外，您还需要一个 Docker 工具，您可以从 [https://www.docker.com](https://www.docker.com)
    下载。
- en: 'You can find the source files for this chapter on GitHub: [https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter03](https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter03).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章的源文件：[https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter03](https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter03)。
- en: Service discovery overview
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现概述
- en: 'In the previous chapter, we created an application consisting of three microservices.
    The relationship between the services is illustrated in the following diagram:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个由三个微服务组成的应用程序。服务之间的关系如下图中所示：
- en: '![Figure 3.1 – Relationship between our microservices'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.1 – 我们微服务之间的关系]'
- en: '](img/B18865_03_Figure_1.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.1 – 我们微服务之间的关系](img/B18865_03_Figure_1.jpg)'
- en: Figure 3.1 – Relationship between our microservices
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 我们微服务之间的关系
- en: As you can see, the movie service calls both the metadata and rating service
    for fetching the complete movie details.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，电影服务调用元数据和评分服务以获取完整的电影详情。
- en: But how would our services send requests? How would they know the addresses
    of each other?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们的服务如何发送请求？它们如何知道彼此的地址？
- en: 'In our example, we used pre-programmed static values for the API handlers.
    The settings we used were as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们为 API 处理器使用了预编程的静态值。我们使用的设置如下：
- en: '`localhost:8081`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localhost:8081`'
- en: '`localhost:8082`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localhost:8082`'
- en: '`localhost:8083`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localhost:8083`'
- en: 'In our approach, each service would need to know the exact address of the other
    services it would communicate with. This approach would work until we more than
    one instance of each microservice. In this case, we would have multiple challenges:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的方法中，每个服务都需要知道它将与之通信的其他服务的确切地址。这种方法在只有一个微服务的每个实例的情况下会工作。在这种情况下，我们会面临多个挑战：
- en: What address should you use when you have multiple instances?
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您有多个实例时，您应该使用什么地址？
- en: How to handle the situation when some instances become unavailable?
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理某些实例不可用的情况？
- en: 'The first problem is relatively easy to solve if you have a static set of instances
    – your services would need to keep a list of addresses for each service they need
    to call. However, this approach is not flexible for the following reasons:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一组静态的实例集，第一个问题相对容易解决——您的服务需要保留每个需要调用的服务的地址列表。然而，这种方法以下列原因不够灵活：
- en: Each time you need to add or remove instances, you need to update the configuration
    of each calling service.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次您需要添加或删除实例时，您都需要更新每个调用服务的配置。
- en: If an instance becomes unavailable for an extended period (for example, due
    to network failure), your services would still keep calling it until you updated
    their configuration.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个实例因长时间不可用（例如，由于网络故障）而变得不可用，您的服务仍然会继续调用它，直到您更新它们的配置。
- en: How do you solve these problems properly?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如何正确解决这些问题？
- en: 'The problem we just described for our microservices is called **service discovery**.
    In general, service discovery addresses multiple problems, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才描述的微服务问题被称为**服务发现**。一般来说，服务发现解决多个问题，如下所述：
- en: How to discover the instance(s) of a particular service
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何发现特定服务的实例
- en: How to add and remove instances of service in a discoverable environment
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在可发现环境中添加和删除服务的实例
- en: How to handle the issue when instances become unresponsive
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理实例无响应的问题
- en: Let’s see how each of these features would work.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些功能是如何工作的。
- en: Registry
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册表
- en: 'The foundation of service discovery is a registry (also known as a service
    registry), which stores information about available service instances. It has
    the following features:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 服务发现的基础是一个注册表（也称为服务注册表），它存储有关可用服务实例的信息。它具有以下功能：
- en: Register an instance of a service.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册一个服务的实例。
- en: Deregister an instance of a service.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注销一个服务的实例。
- en: Return the list of all the instances of the service in the form of their network
    addresses.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以网络地址的形式返回服务的所有实例列表。
- en: 'This is an example of service discovery registry data:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个服务发现注册表数据的示例：
- en: '| **Service name** | **Address list** |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **服务名称** | **地址列表** |'
- en: '| Movie service | `172.18.10.2:2520``172.18.12.55:8800``172.18.89.10:2450`
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 电影服务 | `172.18.10.2:2520` `172.18.12.55:8800` `172.18.89.10:2450` |'
- en: '| Rating service | `172.18.25.11:1100``172.18.9.55:2830` |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 评分服务 | `172.18.25.11:1100` `172.18.9.55:2830` |'
- en: '| Movie metadata service | `172.18.79.115:3512``172.17.3.8:9900` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 电影元数据服务 | `172.18.79.115:3512` `172.17.3.8:9900` |'
- en: Table 3.1 – Registry data
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1 – 注册表数据
- en: Each service can either register in the registry by itself or use some library
    or tool to register on service startup automatically. Once the service is registered,
    it starts being monitored via health checks to ensure the registry contains only
    available instances.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务都可以自行在注册表中注册，或者使用某些库或工具在服务启动时自动注册。一旦服务注册，它将通过健康检查开始被监控，以确保注册表只包含可用实例。
- en: Let’s now see the two common models of adopting service discovery.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看采用服务发现的两种常见模型。
- en: Service discovery models
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务发现模型
- en: 'For the applications, there are two ways of interacting with the registry:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应用程序，有两种与注册表交互的方式：
- en: '**Client-side service discovery**: Access the registry directly from the application
    using a registry client.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端服务发现**：使用注册表客户端从应用程序直接访问注册表。'
- en: '**Server-side service discovery**: Access the registry indirectly via a load
    balancer, a special server that forwards requests to available instances.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器端服务发现**：通过负载均衡器间接访问注册表，这是一个特殊的服务器，它将请求转发到可用的实例。'
- en: Let’s see the advantages and disadvantages of each model.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每种模型的优缺点。
- en: Client-side service discovery
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端服务发现
- en: 'In the client-side service discovery model, each application or service accesses
    the service registry directly by requesting all available instances of a target
    service. When the application receives a response, it uses the addresses of the
    target service for making requests. The logic is illustrated in the following
    diagram:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端服务发现模型中，每个应用程序或服务通过直接请求目标服务的所有可用实例来直接访问服务注册表。当应用程序收到响应时，它使用目标服务的地址进行请求。逻辑如下所示：
- en: '![Figure 3.2 – Client-side service discovery'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.2 – 客户端服务发现](img/B18865_03_Figure_2.jpg)'
- en: '](img/B18865_03_Figure_2.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.2 – 客户端服务发现](img/B18865_03_Figure_2.jpg)'
- en: Figure 3.2 – Client-side service discovery
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 客户端服务发现
- en: In this model, the application is responsible for balancing the load on the
    service it is calling – if an application picked just one instance from the list
    and kept calling it all the time, it would overload that instance and underutilize
    the other ones.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模型中，应用程序负责平衡它所调用的服务的负载——如果应用程序只从列表中选择一个实例并一直调用它，那么它将超载该实例并低估其他实例。
- en: The downside of this model is that the calling application needs to be programmed
    with load-balancing logic. In addition, this couples service discovery and load-balancing
    logic with the application code, making the application more complex.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模型的缺点是调用应用程序需要编程负载均衡逻辑。此外，这会将服务发现和负载均衡逻辑与应用程序代码耦合在一起，使应用程序更加复杂。
- en: Server-side service discovery
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器端服务发现
- en: The server-side service discovery model adds an extra layer to the interaction
    between the calling applications and the registry. Instead of calling the registry
    directly, applications send their requests to target microservices via a special
    server called a load balancer. The load balancer is responsible for interacting
    with the registry and distributing requests between all available instances.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端服务发现模型在调用应用程序与注册表之间的交互中添加了一个额外的层。应用程序不是直接调用注册表，而是通过一个称为负载均衡器的特殊服务器将请求发送到目标微服务。负载均衡器负责与注册表交互并在所有可用实例之间分配请求。
- en: 'The following diagram will help you understand the server-side service discovery
    model:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图将帮助您理解服务器端服务发现模型：
- en: '![Figure 3.3 – Server-side service discovery'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 – 服务器端服务发现](img/B18865_03_Figure_3.jpg)'
- en: '](img/B18865_03_Figure_3.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 – 服务器端服务发现](img/B18865_03_Figure_3.jpg)'
- en: Figure 3.3 – Server-side service discovery
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 服务器端服务发现
- en: 'In the diagram, the application calls the target service via a load balancer,
    accessing the service registry to read the list of active service instances from
    it. In this model, the application does not need to know about the registry. This
    is the main benefit of the server-side service discovery model: it helps decouple
    the interaction with the service registry from each calling application, making
    the application logic simpler. The downside of the model is that it requires setting
    up and using a load balancer. The latter is rather an untrivial operation, and
    we are not going to cover it in this book.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，应用程序通过负载均衡器调用目标服务，通过服务注册表读取活动服务实例列表。在这个模型中，应用程序不需要了解注册表。这是服务器端服务发现模型的主要优势：它有助于将与服务注册表的交互与每个调用应用程序解耦，使应用程序逻辑更简单。该模型的缺点是需要设置和使用负载均衡器。后者是一个相当复杂的操作，我们不会在本书中涉及。
- en: Now, let’s see how the registry can keep the list of only active instances of
    each service.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看注册表如何仅保留每个服务的活动实例列表。
- en: Service health monitoring
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务健康监控
- en: 'The registry keeps the information about the instances up to date either via
    a pull or a push model:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表通过拉取或推送模型保持实例信息最新：
- en: '**Pull model**: The service registry periodically performs a health check for
    each known instance.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拉取模型**：服务注册表定期对每个已知实例进行健康检查。'
- en: '**Push model**: The application renews its status by contacting the registry.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推送模型**：应用程序通过联系注册表来更新其状态。'
- en: The pull model removes the need to implement status renewal on a service level.
    In a push model, the application is responsible for renewing its status or telling
    the service registry about its healthy status.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取模型消除了在服务级别实现状态更新的需求。在推送模型中，应用程序负责更新其状态或向服务注册表报告其健康状态。
- en: Now, as we have covered the theoretical basics of service discovery, let’s see
    which existing solutions you can use to enable your microservices.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经涵盖了服务发现的理论基础，让我们看看您可以使用哪些现有解决方案来启用您的微服务。
- en: Service discovery solutions
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现解决方案
- en: In this section, we are going to describe the existing service discovery solutions
    available for your use – **HashiCorp Consul** and **Kubernetes**. Then, you will
    learn about the most popular tools that can be used by microservice developers
    to perform service discovery.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将描述现有的服务发现解决方案，这些解决方案可供您使用——**HashiCorp Consul**和**Kubernetes**。然后，您将了解微服务开发者可以使用哪些最流行的工具来执行服务发现。
- en: HashiCorp Consul
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HashiCorp Consul
- en: HashiCorp Consul has been a pretty popular solution for service discovery for
    many years. Written in Go, this tool allows you to set up service discovery for
    your services and applications quite easily, using its clients or API.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: HashiCorp Consul多年来一直是一种非常流行的服务发现解决方案。这个用Go编写的工具允许您通过其客户端或API轻松设置服务和应用程序的服务发现。
- en: 'Consul has a pretty straightforward API, including the following key endpoints:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Consul有一个相当直观的API，包括以下关键端点：
- en: '`PUT /catalog/register`: Register a service instance.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT /catalog/register`：注册服务实例。'
- en: '`PUT /catalog/deregister`: Deregister a service instance.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT /catalog/deregister`：注销服务实例。'
- en: '`GET /catalog/services`: Get the available instances of a service.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /catalog/services`：获取服务的可用实例。'
- en: Client applications can access the Consul catalog either via the API or in server-side
    service discovery mode, using a DNS service.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序可以通过API或使用DNS服务在服务器端服务发现模式下访问Consul目录。
- en: 'You can learn more about Consul by checking the official website: [https://consul.io](https://consul.io).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过查看官方网站了解更多的Consul信息：[https://consul.io](https://consul.io)。
- en: Kubernetes
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes
- en: Kubernetes is a popular open source platform for running, scaling, and managing
    collections of applications, such as microservices.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes是一个流行的开源平台，用于运行、扩展和管理应用程序集合，如微服务。
- en: One of the features of Kubernetes is the ability to register and discover the
    services that are running in it. Kubernetes provides an API for retrieving the
    list of network addresses of each service that is being updated automatically,
    so users can use it in client-side discovery mode. Alternatively, it allows its
    users to plug in a load balancer to use it for server-side discovery instead.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes的一个特性是能够注册和发现其内部运行的服务。Kubernetes提供了一个API，用于检索每个正在更新的服务的网络地址列表，用户可以在客户端发现模式下使用它。或者，它允许用户插入一个负载均衡器，以用于服务器端发现。
- en: We are going to cover Kubernetes later, in [*Chapter 8*](B18865_08.xhtml#_idTextAnchor109)
    of this book. Now, let’s see how we can add service discovery to the applications
    we created in the previous chapter.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的[*第8章*](B18865_08.xhtml#_idTextAnchor109)中稍后介绍Kubernetes。现在，让我们看看我们如何可以将服务发现添加到上一章中创建的应用程序中。
- en: Adopting service discovery
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采用服务发现
- en: In this section, we are going to illustrate how you can start using service
    discovery for your applications. We will be using the microservices we created
    in the previous chapter as an example. Then, you will learn how to add the logic
    responsible for service discovery to your microservice code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将说明如何开始为你的应用程序使用服务发现。我们将使用上一章中创建的微服务作为示例。然后，你将学习如何将负责服务发现的逻辑添加到你的微服务代码中。
- en: 'When you consider enabling service discovery for your services, you have multiple
    questions to answer, such as the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当你考虑为你的服务启用服务发现时，你需要回答多个问题，例如以下问题：
- en: Which model would you prefer to use – client-side or server-side discovery?
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你更倾向于使用哪种模型——客户端或服务器端发现？
- en: Which platform will you use for the deployment and orchestration of your microservices?
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将使用哪个平台来部署和编排你的微服务？
- en: Answering the second question may already give you a solution – various deployment
    platforms, including Kubernetes, as well as popular clouds such as AWS, offer
    service discovery for your services.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 回答第二个问题可能已经给你提供了一个解决方案——包括Kubernetes在内的各种部署平台，以及像AWS这样的流行云服务，都为你提供了服务发现功能。
- en: If you don’t know which deployment platform you are going to use for your services
    and you are new to microservice development, you may consider client-side service
    discovery. The client-side discovery model is slightly simpler because your service
    directly coordinates with the service registry. Later, you will be able to switch
    to server-side service discovery, if you want.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道你将为你的服务使用哪个部署平台，并且你对微服务开发是新手，你可能考虑使用客户端服务发现。客户端发现模型稍微简单一些，因为你的服务直接与服务注册表协调。稍后，如果你想要的话，你可以切换到服务器端服务发现。
- en: Let’s start preparing your applications for adding service discovery logic.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始准备你的应用程序以添加服务发现逻辑。
- en: Preparing the application
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备应用程序
- en: Let’s list what we want to achieve from our service discovery code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出我们希望从我们的服务发现代码中实现的目标。
- en: The ability to register a service that we are going to use on service startup
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务启动时注册我们打算使用的服务的功能
- en: The ability to deregister a service that we are going to use on service shutdown
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务关闭时注销我们打算使用的服务的功能
- en: The ability to get a list of addresses of a particular service that we are going
    to use for making the calls to the other services.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取我们打算用于调用其他服务的特定服务的地址列表的功能。
- en: Set up service health monitoring so the service registry is able to remove inactive
    service instances
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置服务健康监控，以便服务注册表能够移除不活跃的服务实例
- en: 'It would be great if our service discovery logic weren’t directly tied to a
    particular tool. It is usually a good practice to abstract the actual technology
    with a more generic interface, which allows us to swap implementations. We can
    illustrate this using an example – imagine we are using the Hashicorp Consul library,
    which returns a list of service addresses in the following form:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的服务发现逻辑不直接绑定到特定的工具上，那就太好了。通常，使用更通用的接口来抽象实际技术是一种良好的实践，这允许我们交换实现。我们可以用一个例子来说明这一点——想象我们正在使用Hashicorp
    Consul库，它以以下形式返回服务地址列表：
- en: '[PRE0]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If we expose these Consul structures in our code and pass these structures around
    our code base, our service code will be heavily tied to Consul. If we ever decide
    to switch to another service discovery tool, we would need to replace not only
    the service discovery implementation logic but also all the code in which it is
    used.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在代码中公开这些Consul结构并在代码库中传递这些结构，我们的服务代码将与Consul紧密耦合。如果我们决定切换到另一个服务发现工具，我们需要替换不仅服务发现实现逻辑，还要替换所有使用它的代码。
- en: Instead, let’s define a more generic and technology-agnostic interface. For
    providing the list of service instances, we can just return the list of URLs in
    the `[]string` format.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，让我们定义一个更通用且与技术无关的接口。为了提供服务实例列表，我们可以简单地以`[]string`格式返回URL列表。
- en: 'The complete interface for our service discovery logic would be as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们服务发现逻辑的完整接口如下：
- en: '[PRE1]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you may notice, the interface is pretty generic, yet it allows you to create
    multiple implementations based on different technologies if needed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能注意到的，该接口相当通用，但它允许您根据需要创建基于不同技术的多个实现。
- en: You may also notice that the interface includes a `ReportHealthyState` function
    for reporting the healthy state of a service instance. This function allows us
    to implement the push-based service health monitoring that we mentioned before,
    so each microservice would periodically report its health to the service registry.
    The registry would then be able to remove inactive instances of each service if
    they don’t report a healthy state within some defined interval of time (we are
    going to assume the interval is 5 seconds in our implementation).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还会注意到，该接口包括一个`ReportHealthyState`函数，用于报告服务实例的健康状态。此函数允许我们实现之前提到的基于推送的服务健康监控，因此每个微服务将定期向服务注册表报告其健康状态。如果服务实例在定义的时间间隔内没有报告健康状态，注册表将能够删除每个服务的非活动实例（在我们的实现中，我们将假设该间隔为5秒）。
- en: 'Let’s now think about where we would store the service discovery logic for
    our microservices. I suggest using a package that all three services can access
    – let’s create it in the root directory of our application, under the `pkg` folder.
    We can call it `pkg/discovery`. Inside it, add a `discovery.go` file and add the
    following code to it:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑在哪里存储我们的微服务服务发现逻辑。我建议使用一个所有三个服务都可以访问的包——让我们在应用程序的根目录下`pkg`文件夹中创建它。我们可以称它为`pkg/discovery`。在其内部，添加一个`discovery.go`文件，并将以下代码添加到其中：
- en: '[PRE2]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the code that we just added, we have defined a `Registry` interface for the
    service registry. Additionally, we defined the `ErrNotFound` error that would
    be returned from the `ServiceAddresses` function if no active service addresses
    were found. Finally, we created a `GenerateInstanceID` function that would help
    us to generate randomized instance identifiers for use with the `Register` and
    `Deregister` functions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚添加的代码中，我们定义了一个`Registry`接口用于服务注册。此外，我们还定义了`ErrNotFound`错误，当`ServiceAddresses`函数找不到任何活动服务地址时将返回此错误。最后，我们创建了一个`GenerateInstanceID`函数，该函数将帮助我们生成用于`Register`和`Deregister`函数的随机实例标识符。
- en: We are ready to begin our work on its implementation.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好开始对其实现的工作。
- en: Implementing the discovery logic
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现发现逻辑
- en: 'One of the benefits of the interface that we defined earlier is that we can
    create multiple implementations and use them in our application. So, for example,
    we can create one implementation that we can later use in tests, whereas another
    implementation would be used in production. To illustrate this approach, we are
    going to create two implementations:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前定义的接口的一个好处是，我们可以创建多个实现并在我们的应用程序中使用它们。例如，我们可以创建一个用于测试的实现，而另一个实现则用于生产。为了说明这种方法，我们将创建两个实现：
- en: '**In-memory service discovery**: Use an in-memory registry for storing the
    set of addresses.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存服务发现**：使用内存注册表来存储地址集合。'
- en: '**Consul-based service discovery**: Use the Hashicorp Consul service registry
    for storing and retrieving service addresses.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于Consul的服务发现**：使用Hashicorp Consul服务注册表来存储和检索服务地址。'
- en: Now, let’s proceed to implement the logic.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续实现逻辑。
- en: In-memory implementation
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存实现
- en: 'Let’s start with the in-memory implementation first. In this implementation,
    we will be storing the service registry records in memory using a simple map data
    structure. Here are the steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从内存实现开始。在这个实现中，我们将使用简单的映射数据结构在内存中存储服务注册记录。以下是步骤：
- en: 'Create a `pkg/discovery/memorypackage` file and a `memory.go` file, then add
    the following:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pkg/discovery/memorypackage`的文件和一个名为`memory.go`的文件，然后添加以下内容：
- en: '[PRE3]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let’s implement our `Register` and `Deregister` functions:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们实现我们的`Register`和`Deregister`函数：
- en: '[PRE28]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, let’s implement the remaining two functions of the `Registry` interface:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们实现`Registry`接口的剩余两个函数：
- en: '[PRE49]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This implementation can be used in tests or simple applications running on a
    single server. The implementation is based on a combination of a map data structure
    and `sync.RWMutex`, allowing reads and writes to the map concurrently. In the
    map, we store `serviceInstance` structures containing the instance address and
    the last time of a successful health check for it, which can be set by calling
    a `ReportHealthyState` function. In the `ServiceAddresses` function, we only return
    instances with successful health checks from within the last 5 seconds.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现可以用于测试或运行在单个服务器上的简单应用程序。该实现基于一种组合的映射数据结构和`sync.RWMutex`，允许并发地对映射进行读写操作。在映射中，我们存储包含实例地址和最后一次成功健康检查时间的`serviceInstance`结构，这可以通过调用`ReportHealthyState`函数来设置。在`ServiceAddresses`函数中，我们只返回在过去5秒内成功进行健康检查的实例。
- en: Let’s now move to the Consul-based service registry implementation.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向基于Consul的服务注册实现。
- en: Consul-based implementation
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于Consul的实现
- en: 'The implementation that we are going to work on now will use Hashicorp Consul
    as a service registry:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将要工作的实现将使用Hashicorp Consul作为服务注册中心：
- en: 'First, create a `pkg/discovery/consul` package and add to it a file named `consul.go`:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`pkg/discovery/consul`的包，并向其中添加一个名为`consul.go`的文件：
- en: '[PRE80]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Now, let’s implement the functions of our interface to register and reregister
    the records:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实现我们接口的注册和重新注册记录的功能：
- en: '[PRE105]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Finally, let’s implement the remaining registry functions:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们实现剩余的注册功能：
- en: '[PRE128]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Our client depends on an external library, `github.com/hashicorp/consul/api`.
    We need to fetch it now by running `go mod tidy` inside our `src` directory. After
    this, Go should fetch the dependency, and our logic should be able to compile.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户端依赖于一个外部库，`github.com/hashicorp/consul/api`。我们需要现在通过在`src`目录内运行`go mod
    tidy`来获取它。之后，Go应该获取依赖项，我们的逻辑应该能够编译。
- en: Now, we are ready to plug the logic we just created into our microservices.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好将刚刚创建的逻辑应用到我们的微服务中。
- en: Using the discovery logic
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用发现逻辑
- en: Now, we need to add logic for initializing and discovering the services. Currently,
    only the movie service communicates with the other two, so we are going to illustrate
    how to add service discovery using the movie service as an example.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加初始化和发现服务的逻辑。目前，只有电影服务与其他两个服务进行通信，所以我们将以电影服务为例说明如何添加服务发现。
- en: 'Let’s start with our gateways:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的网关开始：
- en: 'In the previous chapter, we created two gateways for calling the metadata and
    the rating services. Let’s modify their structures to the one shown here:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了两个网关用于调用元数据和评分服务。让我们修改它们的结构，使其与下面所示的结构一致：
- en: '[PRE148]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Also, change the `New` function format to the following:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，将`New`函数的格式改为以下：
- en: '[PRE151]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Now, the gateways require a registry on creation. We can change the beginning
    of the `Get` function of the metadata gateway to this now:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，网关在创建时需要一个注册中心。我们可以将元数据网关的`Get`函数的开始部分改为现在这样：
- en: '[PRE154]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: You may notice that instead of calling a static pre-configured address, we now
    first get the available addresses of the metadata from the registry. This is the
    essence of service discovery – we use the data from the registry for making remote
    calls between our services. After we get the list of service addresses, we pick
    a random one using a `rand.Intn` function. By doing this, we balance the load
    between the active instances, randomly selecting any available instance on each
    request.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，我们现在不是调用静态预配置的地址，而是首先从注册中心获取元数据的可用地址。这就是服务发现的本质——我们使用注册中心的数据来在服务之间进行远程调用。在我们获取服务地址列表后，我们使用`rand.Intn`函数随机选择一个。通过这样做，我们在活动实例之间平衡负载，在每个请求中随机选择任何可用的实例。
- en: Now, updating the rating gateway in the same way, we changed the metadata service.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，以与修改元数据服务相同的方式更新评分网关。
- en: 'The next step is to update the `main` functions of our services so that each
    service will register and deregister itself in the service registry. Let’s update
    the metadata service first. Update its `main` function to the following:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是更新我们服务的`main`函数，以便每个服务将在服务注册中心中注册和注销自己。让我们首先更新元数据服务。将其`main`函数更新为以下：
- en: '[PRE162]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: In the preceding code, we added the logic for registering and deregistering
    the service in the Consul-based service registry and reporting its healthy state
    to it every second.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了在基于Consul的服务注册表中注册和注销服务的逻辑，并每秒向它报告其健康状态。
- en: 'Let’s add similar logic to the rating service. Update its `main` function as
    follows:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在评分服务中添加类似的逻辑。更新其`main`函数如下：
- en: '[PRE194]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE224]'
- en: The changes that we just made are similar to the ones we did for the metadata
    service.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚所做的更改与我们对元数据服务所做的更改类似。
- en: 'The last step is to modify the `main` function of the movie service, replacing
    it with the following:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是修改电影服务的`main`函数，将其替换为以下内容：
- en: '[PRE225]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE256]'
- en: 'At this point, we have successfully added Consul-based service discovery to
    our applications. Let’s illustrate how it works in practice:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经成功地将基于Consul的服务发现添加到我们的应用程序中。让我们通过实际操作来展示它是如何工作的：
- en: 'In order to run our applications now, you would need Hashicorp Consul to run
    locally. The easiest way would be to run it using a Docker tool. Assuming you
    have already installed Docker from its website, [docker.com](http://docker.com),
    you can run the following command:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了现在运行我们的应用程序，你需要本地运行Hashicorp Consul。最简单的方法是使用Docker工具运行它。假设你已经从其网站安装了Docker，[docker.com](http://docker.com)，你可以运行以下命令：
- en: '[PRE257]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: The preceding command runs Hashicorp Consul inside Docker in development mode,
    exposing its ports `8500` and `8600` for local use.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令在开发模式下运行Hashicorp Consul，将其端口`8500`和`8600`暴露给本地使用。
- en: 'Run each microservice by executing this command inside each `cmd` directory:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在每个`cmd`目录内执行此命令来运行每个微服务：
- en: '[PRE258]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: 'Now, go to the Consul web UI via its link, [http://localhost:8500/](http://localhost:8500/).
    When you open the **Services** tab, you should see the list of our services and
    an active Consul instance:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过其链接进入Consul的Web UI，[http://localhost:8500/](http://localhost:8500/)。当你打开**服务**标签时，你应该能看到我们的服务列表和一个活动的Consul实例：
- en: '![Figure 3.4 – Consul web view of active service instances'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4 – Consul Web视图中的活动服务实例'
- en: '](img/B18865_04_Figure_3.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B18865_04_Figure_3.jpg)'
- en: Figure 3.4 – Consul web view of active service instances
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – Consul Web视图中的活动服务实例
- en: 'You can optionally add some additional instances of each service by running
    the following:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择通过运行以下命令为每个服务添加一些额外的实例：
- en: '[PRE259]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: If you run the preceding command, replace the `<PORT>` placeholder with unique
    port numbers that are not in use yet (in our examples, we used ports `8081`, `8082`,
    and `8083`, so you can run with port numbers starting with `8084`). The result
    of each command would be additional healthy instances in the Consul service view
    illustrated earlier.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行上述命令，将`<PORT>`占位符替换为尚未使用的唯一端口号（在我们的示例中，我们使用了端口号`8081`、`8082`和`8083`，因此你可以从`8084`开始的端口号运行）。每个命令的结果将在之前展示的Consul服务视图中显示额外的健康实例。
- en: You can also try shutting down any service manually by terminating the `go run`
    commands and seeing how instances change their states from `Passing` to `Critical`.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以尝试手动关闭任何服务，通过终止`go run`命令，并观察实例状态如何从`通过`变为`关键`。
- en: 'To test API requests, ensure you have at least one healthy instance of each
    service and make the following request to a movie service:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试API请求，确保每个服务至少有一个健康的实例，并向电影服务发送以下请求：
- en: '[PRE260]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: 'Check the output logs of the movie service now (you should be able to see them
    in the terminal where you ran the `go run` command for the movie service). If
    you did everything correctly, you should see a similar line:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查电影服务的输出日志（你应该能在运行电影服务`go run`命令的终端中看到它们）。如果你一切操作正确，你应该能看到类似的行：
- en: '[PRE261]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE261]'
- en: The preceding line is the result of a call to the service registry backed by
    the Consul. In our metadata service gateway implementation, we select a random
    active instance from the registry and log its address before making a call. If
    you have more than one instance of a metadata service, you can make multiple `curl`
    requests listed previously and see that the movie service always picks a random
    instance among them.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的行是调用由Consul支持的服务注册表的结果。在我们的元数据服务网关实现中，我们从注册表中随机选择一个活动实例，并在调用之前记录其地址。如果你有多个元数据服务实例，你可以按照之前列出的多次执行`curl`请求，你会看到电影服务总是在它们中随机选择一个实例。
- en: At this point, we have illustrated how to use service discovery with our microservices.
    We can now dynamically scale our microservices by adding and removing their instances
    without any need to change the service code. We also have two working implementations
    of a service registry that you can use in your code. Now, we are ready to move
    to the next chapter, covering another important topic, data serialization.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经展示了如何使用服务发现来管理我们的微服务。现在，我们可以通过添加和删除它们的实例来动态扩展我们的微服务，而无需更改服务代码。我们还提供了两个服务注册表的实现，您可以在代码中使用。现在，我们准备进入下一章，讨论另一个重要主题，数据序列化。
- en: Summary
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we did an overview of service discovery and compared its different
    models. You have learned what the service registry is and what its main service
    discovery models are. We have illustrated how to use a client-side service discovery
    model by providing two implementations, one using an in-memory set of data and
    another using Hashicorp Consul. We have also plugged the Consul-based implementation
    into our microservices to demonstrate how to use it in the microservice logic.
    Now, you know how to add and use service discovery in your applications.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对服务发现进行了概述，并比较了其不同的模型。您已经了解了服务注册表是什么以及其主要的服务发现模型有哪些。我们通过提供两种实现来展示了如何使用客户端服务发现模型，一种使用内存中的数据集，另一种使用Hashicorp
    Consul。我们还把基于Consul的实现集成到我们的微服务中，以演示如何在微服务逻辑中使用它。现在，您已经知道如何在您的应用程序中添加和使用服务发现。
- en: 'In the next chapter, we are going to discuss another important topic: serialization.
    You will learn how to encode and decode the data transferred between the services.
    This will help us move to further topics, covering the communication between the
    services we will cover in [*Chapter 5*](B18865_05.xhtml#_idTextAnchor076).'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论另一个重要主题：序列化。您将学习如何编码和解码服务之间传输的数据。这将帮助我们进一步探讨服务之间的通信，我们将在[*第五章*](B18865_05.xhtml#_idTextAnchor076)中介绍。
- en: Further reading
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Service discovery overview*: [https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture](https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture
    )'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*服务发现概述*: [https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture](https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture)'
- en: '*Server-side service discovery*: [https://microservices.io/patterns/server-side-discovery.html](https://microservices.io/patterns/server-side-discovery.html)'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*服务器端服务发现*: [https://microservices.io/patterns/server-side-discovery.html](https://microservices.io/patterns/server-side-discovery.html)'
