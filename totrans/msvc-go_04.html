<html><head></head><body>
		<div id="_idContainer022">
			<h1 id="_idParaDest-67" class="chapter-number" lang="en-GB"><a id="_idTextAnchor067"/>4</h1>
			<h1 id="_idParaDest-68" lang="en-GB"><a id="_idTextAnchor068"/>Serialization</h1>
			<p lang="en-GB">In previous chapters, we have learned how to scaffold Go microservices, create HTTP API endpoints, and set up service discovery to let our microservices commsunicate with each other. This knowledge already provides a solid foundation for building microservices; however, we are going to continue our journey with more advanced topics.</p>
			<p lang="en-GB">In this chapter, we will explore <strong class="bold" lang="">serialization</strong>, a process that allows the encoding and decoding of data for storing or sending between services. </p>
			<p lang="en-GB">To illustrate how to use serialization, we are going to define data structures transferred between the services using the <strong class="bold" lang="">Protocol Buffers</strong> format, which is widely used across the industry and has a simple syntax, as well as very size-efficient encoding. </p>
			<p lang="en-GB">Finally, we are going to illustrate how you can generate code for the Protocol Buffers structures and demonstrate how efficient Protocol Buffers encoding is compared to some other formats, such as XML and JSON.</p>
			<p lang="en-GB">In this chapter, we are going to cover the following topics:</p>
			<ul>
				<li lang="en-GB">The basics of serialization</li>
				<li lang="en-GB">Using Protocol Buffers</li>
				<li lang="en-GB">Best practices with serialization</li>
			</ul>
			<p lang="en-GB">Now, let’s continue to the basics of serialization.</p>
			<h1 id="_idParaDest-69" lang="en-GB"><a id="_idTextAnchor069"/>Technical requirements</h1>
			<p lang="en-GB">To complete this chapter, you will need to have Go 1.11 or above and the Protocol Buffers compiler. We will be using the official Protocol Buffers compiler; you can install it by running the following:</p>
			<pre class="source-code" lang="en-GB">
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
export PATH="$PATH:$(go env GOPATH)/bin"</pre>
			<p lang="en-GB">You can find the code examples for this chapter on GitHub at the following link: </p>
			<p lang="en-GB">https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter04 </p>
			<h1 id="_idParaDest-70" lang="en-GB"><a id="_idTextAnchor070"/>The basics of serialization</h1>
			<p lang="en-GB"><strong class="bold" lang="">Serialization</strong> is the <a id="_idIndexMarker179"/>process of converting data into a format that allows you to transfer it, store it, and later deconstruct it back.</p>
			<p lang="en-GB">This process is illustrated in the following diagram:</p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/Figure_4.1_B18865.jpg" alt="Figure 4.1 – The serialization and deserialization process &#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – The serialization and deserialization process </p>
			<p lang="en-GB">As illustrated in the diagram, the process of transforming the original data is called <strong class="bold" lang="">serialization</strong>, and the<a id="_idIndexMarker180"/> reverse process of transforming it back is called <strong class="bold" lang="">deserialization</strong>.</p>
			<p lang="en-GB">Serialization has<a id="_idIndexMarker181"/> two primary use cases:</p>
			<ul>
				<li lang="en-GB">Transferring the data between services, acting as a common <em class="italic" lang="">language</em> between them</li>
				<li lang="en-GB">Encoding and decoding arbitrary data for storage, allowing you to store complex data structures as byte arrays or regular strings</li>
			</ul>
			<p lang="en-GB">In <a href="B18865_02.xhtml#_idTextAnchor027"><em class="italic" lang="">Chapter 2</em></a>, while <a id="_idIndexMarker182"/>scaffolding our applications, we created our HTTP API endpoints and set them to return JSON responses to the callers. In that case, JSON played the role<a id="_idIndexMarker183"/> of a <strong class="bold" lang="">serialization format</strong>, allowing us to transform our data structures into it and then decode them back.</p>
			<p lang="en-GB">Let’s take our <strong class="source-inline" lang="">Metadata</strong> structure defined in the <strong class="source-inline" lang="">metadata/pkg/model/metadata.go</strong> file as an example:</p>
			<pre class="source-code" lang="en-GB">
// Metadata defines the movie metadata.
type Metadata struct {
    ID          string `json:"id"`
    Title       string `json:"title"`
    Description string `json:"description"`
    Director    string `json:"director"`
}</pre>
			<p lang="en-GB">Our structure includes the records<a id="_idIndexMarker184"/> called <strong class="bold" lang="">annotations</strong> that help the JSON encoder transform our record into an output. For example, we create an instance of our structure:</p>
			<pre class="source-code" lang="en-GB">
Metadata{
    ID:          "123",
    Title:       "The Movie 2",
    Description: "Sequel of the legendary The Movie",
    Director:    "Foo Bars",
}</pre>
			<p lang="en-GB">When we then encode it with JSON, the result would be the following:</p>
			<pre class="source-code" lang="en-GB">
{"id":"123","title":"The Movie 2","description":"Sequel of the legendary The Movie","director":"Foo Bars"}</pre>
			<p lang="en-GB">Once the data is serialized, it can be used in many different ways. In our examples in<em class="italic" lang=""> </em><a href="B18865_02.xhtml#_idTextAnchor027"><em class="italic" lang="">Chapter 2</em></a>, we used JSON format for sending and receiving the data between our microservices. Some additional <a id="_idIndexMarker185"/>use cases of serialization include the following:</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Store configuration</strong>: Serialization formats are commonly used for storing configuration. For example, you can define your service settings using these kinds of formats and then read them in your service code.</li>
				<li lang="en-GB"><strong class="bold" lang="">Store records in a database</strong>: Formats such as JSON are frequently used for storing arbitrary data in databases. For example, key-value databases require encoding entire record values into byte arrays, and developers often use formats such as JSON to encode and decode these record values.</li>
				<li lang="en-GB"><strong class="bold" lang="">Logging</strong>: Application logs are often stored in JSON format, making them easy to read for both humans and various applications, such as data visualization software.</li>
			</ul>
			<p lang="en-GB">JSON is one of the most <a id="_idIndexMarker186"/>popular serialization formats at the moment and it has been essential to web development. It has the<a id="_idIndexMarker187"/> following benefits:</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Language support</strong>: Most programming languages include tools for encoding and decoding JSON.</li>
				<li lang="en-GB"><strong class="bold" lang="">Browser support</strong>: JSON has been an integral part of web applications and all modern browsers include developer tools to work with it in the browser itself.</li>
				<li lang="en-GB"><strong class="bold" lang="">Readability</strong>: JSON records are easily readable and are often easy to use during both the development and debugging of web applications.</li>
			</ul>
			<p lang="en-GB">However, it has certain<a id="_idIndexMarker188"/> limitations as well:</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Size</strong>: JSON is not a size-efficient format. In this chapter, we are going to see which formats and protocols provide output records that are smaller in size.</li>
				<li lang="en-GB"><strong class="bold" lang="">Speed</strong>: As with its output size, the encoding and decoding speed with JSON is not the fastest <a id="_idIndexMarker189"/>when set against other popular serialization protocols.</li>
			</ul>
			<p lang="en-GB">Let’s explore the other popular serialization formats.</p>
			<h1 id="_idParaDest-71" lang="en-GB"><a id="_idTextAnchor071"/>Popular serialization formats</h1>
			<p lang="en-GB">There are many popular <a id="_idIndexMarker190"/>serialization formats and protocols used in the industry. Let’s cover some of the most popular formats:</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">XML</strong></li>
				<li lang="en-GB"><strong class="bold" lang="">YAML</strong></li>
				<li lang="en-GB"><strong class="bold" lang="">Apache Thrift</strong></li>
				<li lang="en-GB"><strong class="bold" lang="">Apache Avro</strong></li>
				<li lang="en-GB"><strong class="bold" lang="">Protocol Buffers</strong></li>
			</ul>
			<p lang="en-GB">This section will provide a high-level overview of each one, as well as some key differences between these protocols.</p>
			<h3 lang="en-GB">XML</h3>
			<p lang="en-GB">XML is <a id="_idIndexMarker191"/>one of the earliest serialization formats for web service <a id="_idIndexMarker192"/>development. It was created in 1998 and is still widely used in the industry, especially in enterprise applications.</p>
			<p lang="en-GB">XML represents data as a tree of nodes called elements. An element example would be <strong class="source-inline" lang="">&lt;example&gt;Some value&lt;/example&gt;</strong>. If we serialized our metadata structure mentioned above, the result would be the following:</p>
			<pre class="source-code" lang="en-GB">
&lt;Metadata&gt;&lt;ID&gt;123&lt;/ID&gt;&lt;Title&gt;The Movie 2&lt;/Title&gt;&lt;Description&gt;Sequel of the legendary The Movie&lt;/Description&gt;&lt;Director&gt;Foo Bars&lt;/Director&gt;&lt;/Metadata&gt;</pre>
			<p lang="en-GB">You may notice that the serialized XML representation of our data is slightly longer than the JSON one. It is one of the downsides of XML format – the output is often the largest among all popular serialization protocols, making it harder to read and transfer the data. On the other hand, XML’s advantages include its wide adoption and popularity, readability, as well as its wide library support.</p>
			<h3 lang="en-GB">YAML</h3>
			<p lang="en-GB">YAML<a id="_idIndexMarker193"/> is a <a id="_idIndexMarker194"/>serialization format that was first released in 2001. It gained popularity over the years, becoming one of the most popular serialization formats in the industry. Designers of the language took a strong focus on its readability and compactness, making it a perfect tool for defining arbitrary human-readable data. We can illustrate this on our Metadata structure: in the YAML format, it would look as follows:</p>
			<pre class="source-code" lang="en-GB">
metadata:
  id: 123
  title: The Movie 2
  description: Sequel of the legendary The Movie
  director: Foo Bars</pre>
			<p lang="en-GB">The YAML format is widely used for storing configuration data. One of the reasons for this is the ability to include comments, which is lacking in other formats, such as JSON. The use of YAML for service-to-service communication is less common, primarily due to the greater size of the serialized data. Let’s get to some more size-efficient serialization formats.</p>
			<h3 lang="en-GB">Apache Thrift</h3>
			<p lang="en-GB">So far, we<a id="_idIndexMarker195"/> have <a id="_idIndexMarker196"/>reviewed JSON, XML, and YAML, and all are primarily used for defining and serializing arbitrary types of data. There are other solutions to a broader class of problems, when we want not only to serialize and deserialize the data but also to transfer it between multiple services. These solutions combine two<a id="_idIndexMarker197"/> roles: they act as both serialization formats and <strong class="bold" lang="">communication protocols</strong> — mechanisms for sending and receiving arbitrary data over the network. HTTP is an example of such a protocol but developers are not limited to using it in their applications.</p>
			<p lang="en-GB">Apache Thrift is <a id="_idIndexMarker198"/>a combination of serialization and a communication protocol that can be used for both defining your data types and allowing your services to communicate with each other by passing them. It was initially created at Facebook but later became a community-supported open source project under the Apache Software Foundation.</p>
			<p lang="en-GB">Thrift, unlike <a id="_idIndexMarker199"/>JSON and XML, requires you to define your structures in their own format first. In our example, for the Metadata structure, we would need to create a file with the <strong class="source-inline" lang="">.thrift</strong> extension, including the definition in Thrift language:</p>
			<pre class="source-code" lang="en-GB">
struct Metadata {
  1: string id,
  2: string title,
  3: string description,
  4: string director
}</pre>
			<p lang="en-GB">Once you have a Thrift file, you can use it with an automatic Thrift code generator to generate the code for most programming languages that would contain the defined structures and logic to encode and decode it. In addition to data structures, Thrift allows you to<a id="_idIndexMarker200"/> define <strong class="bold" lang="">Thrift services</strong> — sets of functions that can be called remotely. Here’s an example of a Thrift service definition:</p>
			<pre class="source-code" lang="en-GB">
service MetadataService {
  Metadata get(1: string id)
}</pre>
			<p lang="en-GB">The example here defines a service called <strong class="source-inline" lang="">MetadataService</strong>, which provides a <strong class="source-inline" lang="">get</strong> function, returning a <strong class="source-inline" lang="">Metadata</strong> Thrift object. A Thrift-compatible server can act as such a Thrift service, processing incoming requests from the client applications — we are going to learn how to write such servers in <a href="B18865_05.xhtml#_idTextAnchor076"><em class="italic" lang="">Chapter 5</em></a>.</p>
			<p lang="en-GB">Let’s explore the benefits<a id="_idIndexMarker201"/> and limitations of Apache Thrift. The benefits include the following:</p>
			<ul>
				<li lang="en-GB">A smaller output size and higher encoding and decoding speed compared to XML and JSON. Thrift-serialized data can be 30 to 50% smaller in size than XML and JSON.</li>
				<li lang="en-GB">The ability to define not only structures but entire services and generate code for them, allowing communication between the servers and their clients.</li>
			</ul>
			<p lang="en-GB">The limitations<a id="_idIndexMarker202"/> include the following:</p>
			<ul>
				<li lang="en-GB">Relatively low popularity and adoption in recent years due to moving to more popular and efficient formats.</li>
				<li lang="en-GB">It lacks official documentation. Thrift is a relatively complex technology, and most documentation is unofficial.</li>
				<li lang="en-GB">Unlike JSON and XML, Thrift-serialized data is not readable, so it’s trickier to use it for debugging.</li>
				<li lang="en-GB">Nearly no support in recent years – Facebook keeps maintaining a separate branch of it called Facebook Thrift, but it is much less popular than its Apache counterpart.</li>
			</ul>
			<p lang="en-GB">Let’s see the other popular serialization formats that are widely used across the industry.</p>
			<h3 lang="en-GB">Apache Avro</h3>
			<p lang="en-GB">Apache Avro<a id="_idIndexMarker203"/> is a combination of a serialization format<a id="_idIndexMarker204"/> and a communication protocol that is somewhat similar to Apache Thrift. Apache Avro also requires a developer to define a schema (written either in JSON or in its own language called Avro IDL) for their data. In our case, the Metadata structure would have the following schema:</p>
			<pre class="source-code" lang="en-GB">
{
   "namespace": "example.avro",
   "type": "record",
   "name": "Metadata",
   "fields": [
      {"name": "id", "type": "string"},
      {"name": "title", "type": "string"},
      {"name": "description", "type": "string"},
      {"name": "director", "type": "string"},
   ] 
}</pre>
			<p lang="en-GB">Then, the schema <a id="_idIndexMarker205"/>would be used for translating the structures into a serialized state and back.</p>
			<p lang="en-GB">It is not uncommon for types and structures to change over time, and microservice API and structure definitions need to evolve. With Avro, developers can create a new version of a<a id="_idIndexMarker206"/> schema (represented as a separate file, often suffixed with an incremental version number), and keep both the old and new versions in the code base. This way, the application can encode and decode data in either format, even if they have some incompatible changes, such as changes in field names. This is one of the key benefits of using Apache Avro over many other serialization protocols. Additionally, Apache Avro allows you to generate code for existing schemas, making it easier to translate between serialized data and corresponding data structures in different programming languages.</p>
			<h3 lang="en-GB">Protocol Buffers</h3>
			<p lang="en-GB">Protocol Buffers<a id="_idIndexMarker207"/> is <a id="_idIndexMarker208"/>a serialization format that was created at Google more than 20 years ago. In 2008, the format became public and immediately gained popularity among developers. The benefits of<a id="_idIndexMarker209"/> the format include the following:</p>
			<ul>
				<li lang="en-GB">The simplicity of the definition language</li>
				<li lang="en-GB">A small data output size</li>
				<li lang="en-GB">High performance of serialization and deserialization</li>
				<li lang="en-GB">The ability to define services in addition to data structures and compile client and server code in multiple languages</li>
				<li lang="en-GB">Protocol evolution and official support by Google</li>
			</ul>
			<p lang="en-GB">The popularity of Protocol Buffers and its simplicity, as well as the efficiency of its data encoding, makes it a great fit for using it in microservice development. We are going to use Protocol Buffers for serializing and deserializing the data transferred between our services, as well <a id="_idIndexMarker210"/>as defining our service APIs. In the next section, you will learn how to start using Protocol Buffers and move our microservice logic to Protocol Buffers from JSON.</p>
			<h1 id="_idParaDest-72" lang="en-GB"><a id="_idTextAnchor072"/>Using Protocol Buffers</h1>
			<p lang="en-GB">In this<a id="_idIndexMarker211"/> section, we are going to illustrate how you can use Protocol Buffers for your applications. We will use the microservice examples from the previous chapters and define our data model in the Protocol Buffers format. Then, we will be using the code generation tools with Protocol Buffers to generate our data structures. Finally, we will illustrate how to use our generated code for serializing and deserializing our data.</p>
			<p lang="en-GB">First, let’s prepare our application. Create the directory called <strong class="source-inline" lang="">api</strong> under our application’s <strong class="source-inline" lang="">src</strong> directory. Inside this directory, create a <strong class="source-inline" lang="">movie.proto</strong> file and add the following to it:</p>
			<pre class="source-code" lang="en-GB">
syntax = "proto3";
option go_package = "/gen";
 
message Metadata {
    string id = 1;
    string title = 2;
    string description = 3;
    string director = 4;
}
 
message MovieDetails {
    float rating = 1;
    Metadata metadata = 2;
}</pre>
			<p lang="en-GB">Let’s describe the code we just added. In the first line, we set the syntax to <strong class="source-inline" lang="">proto3</strong>, the latest version<a id="_idIndexMarker212"/> of the Protocol Buffers protocol. The second line defines the output path for the code generated. The rest of the file includes two structures that we need for our microservices, similar to the Go structures we created in <a href="B18865_02.xhtml#_idTextAnchor027"><em class="italic" lang="">Chapter 2</em></a>.</p>
			<p lang="en-GB">Now, let’s generate the code for our structures. In the <strong class="source-inline" lang="">src</strong> directory of our application, run the following command:</p>
			<pre class="source-code" lang="en-GB">
protoc -I=api --go_out=. movie.proto</pre>
			<p lang="en-GB">If the command executes successfully, you should find a new directory called <strong class="source-inline" lang="">src/gen</strong>. The directory should include a file called <strong class="source-inline" lang="">movie.pb.go</strong> with the generated code that includes our structures and the code to serialize and deserialize them. For example, the generated <strong class="source-inline" lang="">MovieDetails</strong> structure code would be the following:</p>
			<pre class="source-code" lang="en-GB">
type Metadata struct {
    state         protoimpl.MessageState
    sizeCache     protoimpl.SizeCache
    unknownFields protoimpl.UnknownFields
 
    Id          string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
    Title       string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
    Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
    Director    string `protobuf:"bytes,4,opt,name=director,proto3" json:"director,omitempty"`
}</pre>
			<p lang="en-GB">Let’s now describe what exactly we have just achieved. We have created a <strong class="source-inline" lang="">movie.proto</strong> file that defines<a id="_idIndexMarker213"/> our <strong class="bold" lang="">data schema</strong> — the definition of our data structures. The schema is now defined independently from our Go code, providing the following <a id="_idIndexMarker214"/>benefits to us:</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Explicit schema definition</strong>: Our data schema is now decoupled from the code and explicitly defines the application data types. This makes it easier to see the data types provided by application APIs.</li>
				<li lang="en-GB"><strong class="bold" lang="">Code generation</strong>: Our schema can be converted to code via code generation. We are going to use it later in <a href="B18865_05.xhtml#_idTextAnchor076"><em class="italic" lang="">Chapter 5</em></a> for sending the data between the services.</li>
				<li lang="en-GB"><strong class="bold" lang="">Cross-language support</strong>: We can generate our code not only for Go but also for other programming languages. If our model changes, we would not need to rewrite our structures for all languages. Instead, we can just re-generate the code for all languages by running a single command.</li>
			</ul>
			<p lang="en-GB">Let’s do a quick <a id="_idIndexMarker215"/>benchmark and compare the size of serialized data for three serialization protocols – XML, JSON, and Protocol Buffers. For this, let’s write a small tool to do so.</p>
			<p lang="en-GB">Inside the <strong class="source-inline" lang="">src</strong> directory, create a directory called <strong class="source-inline" lang="">cmd/sizecompare</strong> and add a <strong class="source-inline" lang="">main.go</strong> file to it with the following contents:</p>
			<pre class="source-code" lang="en-GB">
package main
import (
    "encoding/json"
    "encoding/xml"
    "fmt"
    "github.com/golang/protobuf/proto"
    "movieexample.com/gen"
    "movieexample.com/metadata/pkg/model"
)
var metadata = &amp;model.Metadata{
    ID:          "123",
    Title:       "The Movie 2",
    Description: "Sequel of the legendary The Movie",
    Director:    "Foo Bars",
}
var genMetadata = &amp;gen.Metadata{
    Id:          "123",
    Title:       "The Movie 2",
    Description: "Sequel of the legendary The Movie",
    Director:    "Foo Bars",
}</pre>
			<p lang="en-GB">Let’s implement<a id="_idIndexMarker216"/> the <strong class="source-inline" lang="">main</strong> function:</p>
			<pre class="source-code" lang="en-GB">
func main() {
    jsonBytes, err := serializeToJSON(metadata)
    if err != nil {
        panic(err)
    }
    xmlBytes, err := serializeToXML(metadata)
    if err != nil {
        panic(err)
    }
    protoBytes, err := serializeToProto(genMetadata)
    if err != nil {
        panic(err)
    }
    fmt.Printf("JSON size:\t%dB\n", len(jsonBytes))
    fmt.Printf("XML size:\t%dB\n", len(xmlBytes))
    fmt.Printf("Proto size:\t%dB\n", len(protoBytes))
}</pre>
			<p lang="en-GB">Additionally, add<a id="_idIndexMarker217"/> the following functions:</p>
			<pre class="source-code" lang="en-GB">
func serializeToJSON(m *model.Metadata) ([]byte, error) {
    return json.Marshal(m)
}
func serializeToXML(m *model.Metadata) ([]byte, error) {
    return xml.Marshal(m)
}
func serializeToProto(m *gen.Metadata) ([]byte, error) {
    return proto.Marshal(m)
}</pre>
			<p lang="en-GB">In the preceding code, we encode our <strong class="source-inline" lang="">Metadata</strong> structure using JSON, XML, and Protocol Buffers formats, and print the output sizes in bytes for each encoded result.</p>
			<p lang="en-GB">You may need <a id="_idIndexMarker218"/>to fetch the <strong class="source-inline" lang="">github.com/golang/protobuf/proto</strong> package required for our benchmark by running the following:</p>
			<pre class="source-code" lang="en-GB">
go mod tidy</pre>
			<p lang="en-GB">Now, you can run our benchmark by executing <strong class="source-inline" lang="">go run *.go</strong> inside its directory and will see following the output:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">JSON size: 106B</strong>
<strong class="bold" lang="">XML size: 148B</strong>
<strong class="bold" lang="">Proto size: 63B</strong></pre>
			<p lang="en-GB">The result is quite interesting. The XML output is almost 40% bigger than the JSON one. At the same time, Protocol Buffers’s output is more than 40% smaller than the JSON data and more than twice as small as the XML result. This illustrates quite well how efficient the Protocol Buffers format is compared to the other two in terms of output size. By switching from JSON to Protocol Buffers, we reduce the amount of data that we need to send over the network and make our communication faster.</p>
			<p lang="en-GB">Let’s now do an <a id="_idIndexMarker219"/>additional experiment and test serialization speed for all three formats. For this, we are going to do a <strong class="bold" lang="">benchmark</strong> — an automated performance check that is going to measure how fast a target operation is.</p>
			<p lang="en-GB">Create a file called <strong class="source-inline" lang="">main_test.go</strong> in the same directory and add the following to it:</p>
			<pre class="source-code" lang="en-GB">
package main
import (
    "testing"
)
func BenchmarkSerializeToJSON(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        serializeToJSON(metadata)
    }
}
func BenchmarkSerializeToXML(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        serializeToXML(metadata)
    }
}
func BenchmarkSerializeToProto(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        serializeToProto(genMetadata)
    }
}</pre>
			<p lang="en-GB">We have just <a id="_idIndexMarker220"/>created a Go benchmark, that is going to tell us how fast is JSON, XML, and Protocol Buffers encoding. We are going to cover the details of benchmarking in <a href="B18865_08.xhtml#_idTextAnchor109"><em class="italic" lang="">Chapter 8</em></a>, let’s now run the code to see the output by executing the following command:</p>
			<pre class="source-code" lang="en-GB">
go test -bench=.</pre>
			<p lang="en-GB">The result of the command should look as follows:</p>
			<pre class="source-code" lang="en-GB">
goos: darwin
goarch: amd64
pkg: movieexample.com/cmd/sizecompare
cpu: Intel(R) Core(TM) i7-8850H CPU @ 2.60GHz
BenchmarkSerializeToJSON-12          3308172           342.2 ns/op
BenchmarkSerializeToXML-12            480728          2519 ns/op
BenchmarkSerializeToProto-12         6596490           185.7 ns/op
PASS
ok      movieexample.com/cmd/sizecompare    5.239s</pre>
			<p lang="en-GB">You can see the names of three functions that we just implemented and two numbers next to them: </p>
			<ul>
				<li lang="en-GB">The first one is the number of times the function got executed</li>
				<li lang="en-GB">The second is the average processing speed, measured in nanoseconds per operation </li>
			</ul>
			<p lang="en-GB">From the <a id="_idIndexMarker221"/>output, we can see that Protocol Buffers serialization on average took 185.7 nanoseconds, while JSON serialization was almost two times slower at 342.2 nanoseconds. XML serialization on average took 2519 nanoseconds, being more than 13 times slower than Protocol Buffers, and more than 7 times slower than JSON serialization. </p>
			<p lang="en-GB">The benchmark is indeed interesting – it illustrates how different the average encoding speeds for various serialization formats are. If performance is important for your services, you should consider faster serialization formats to achieve a higher encoding and decoding speed.</p>
			<p lang="en-GB">For now, we are going to leave the generated structures in our repository. We will be using them in the next chapter, <a href="B18865_05.xhtml#_idTextAnchor076"><em class="italic" lang="">Chapter 5</em></a>, to replace our JSON API handlers.</p>
			<p lang="en-GB">Now, let’s learn some best practices for using serialization.</p>
			<h1 id="_idParaDest-73" lang="en-GB"><a id="_idTextAnchor073"/>Best practices for serialization</h1>
			<p lang="en-GB">This section<a id="_idIndexMarker222"/> summarizes the best practices for serializing and deserializing the data. These practices will help you make efficient decisions for using serialization in your applications and writing your schema definitions in Protocol Buffers and other formats:</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Keeping your schema backward compatible</strong>: Avoid any changes in your data schema that would break any existing callers. Such changes include modifications (renaming or removal) of field names and types.</li>
				<li lang="en-GB"><strong class="bold" lang="">Ensuring that data schemas are kept in sync between clients and servers</strong>: For serialization formats with explicit schema definitions, such as Apache Thrift, Protocol Buffers, and Apache Avro, you should keep clients and servers in sync with the latest schema versions.</li>
				<li lang="en-GB"><strong class="bold" lang="">Documenting implicit details</strong>: Let the callers know any implicit details related to your data schema. For example, if your API does not allow an empty value of a certain field of a structure, include this in the comments in the schema file.</li>
				<li lang="en-GB"><strong class="bold" lang="">Using built-in structures for representing time whenever possible</strong>: Protocol Buffers <a id="_idIndexMarker223"/>and some other serialization protocols provide built-in types for timestamps and durations. Taking Protocol Buffers as an example, having a <strong class="source-inline" lang="">int timestamp</strong> filed would be considered a bad practice. The right approach would be to use <strong class="source-inline" lang="">google.protobuf.Timestamp</strong>.</li>
				<li lang="en-GB"><strong class="bold" lang="">Using consistent naming</strong>: Opt for using consistent naming in your schema files, similarly to your code.</li>
				<li lang="en-GB"><strong class="bold" lang="">Following the official style guide</strong>: Get familiar with the official style guide if you are using a schema definition language, such as Thrift or Protocol Buffers. You can find the link to the official style guide for Protocol Buffers in the <em class="italic" lang="">Further reading</em> section below.</li>
			</ul>
			<p lang="en-GB">This list provides some high-level recommendations applicable to all serialization protocols. For protocol-specific recommendations, follow the official documentation and check the popular open source projects to get some real-world code examples.</p>
			<h1 id="_idParaDest-74" lang="en-GB"><a id="_idTextAnchor074"/>Summary</h1>
			<p lang="en-GB">In this chapter, we covered the basics of serialization and illustrated how our data structures could be encoded using various serialization protocols, including XML, JSON, and Protocol Buffers. You learned about the differences between the most popular serialization protocols and their main advantages and disadvantages. </p>
			<p lang="en-GB">We covered the basics of Protocol Buffers and showed how to define custom data structures in its schema definition language. Then, we used the example code to illustrate how to generate the schema files for the Go language. Finally, we covered the differences in compression efficiency between XML, JSON, and Protocol Buffers.</p>
			<p lang="en-GB">In the next chapter, we are going to continue using Protocol Buffers and will show how to use it for communication between services. </p>
			<h1 id="_idParaDest-75" lang="en-GB"><a id="_idTextAnchor075"/>Further reading</h1>
			<ul>
				<li lang="en-GB"><em class="italic" lang="">The Protocol Buffers documentation</em>: <a href="https://developers.google.com/protocol-buffers ">https://developers.google.com/protocol-buffers</a></li>
				<li lang="en-GB"><em class="italic" lang="">Comparison of serialization formats</em>: <a href="https://en.wikipedia.org/wiki/Comparison_of_data-serialization_formats ">https://en.wikipedia.org/wiki/Comparison_of_data-serialization_formats</a></li>
				<li lang="en-GB"><em class="italic" lang="">The Protocol Buffers official style guide</em>: <a href="https://developers.google.com/protocol-buffers/docs/style">https://developers.google.com/protocol-buffers/docs/style</a></li>
			</ul>
		</div>
	</body></html>