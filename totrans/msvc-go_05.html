<html><head></head><body>
		<div id="_idContainer024">
			<h1 id="_idParaDest-76" class="chapter-number" lang="en-GB"><a id="_idTextAnchor076"/>5</h1>
			<h1 id="_idParaDest-77" lang="en-GB"><a id="_idTextAnchor077"/>Synchronous Communication</h1>
			<p lang="en-GB">In this chapter, we are going to cover the most common way of communicating between microservices – synchronous communication. In <a href="B18865_02.xhtml#_idTextAnchor027"><em class="italic" lang="">Chapter 2</em></a>, we already implemented the logic for communicating between microservices via the HTTP protocol and returning results in JSON format. In <a href="B18865_04.xhtml#_idTextAnchor067"><em class="italic" lang="">Chapter 4</em></a>, we illustrated that the JSON format is not the most efficient in terms of data size, and there are many different formats providing additional benefits to developers, including code generation. In this chapter, we are going to show you how to define service APIs using Protocol Buffers and generate both client and server code for them.</p>
			<p lang="en-GB">By the end of this chapter, you will understand the key concepts of synchronous communication between microservices and will have learned how to implement microservice clients and servers.</p>
			<p lang="en-GB">The knowledge you gain in this chapter will help you to learn how to better organize the client and server code, generate the code for serialization and communication, and use it in your microservices. In this chapter, we will cover the following topics:</p>
			<ul>
				<li lang="en-GB">Introduction to synchronous communication</li>
				<li lang="en-GB">Defining a service API using Protocol Buffers</li>
				<li lang="en-GB">Implementing gateways and clients</li>
			</ul>
			<p lang="en-GB">Now, let’s proceed to the main concepts of synchronous communication.</p>
			<h1 id="_idParaDest-78" lang="en-GB"><a id="_idTextAnchor078"/>Technical requirements</h1>
			<p lang="en-GB">To complete this chapter, you will need Go 1.11, a Protocol Buffers compiler that we installed in the previous chapter, and a gRPC plugin.</p>
			<p lang="en-GB">You can install the gRPC plugin by running the following command:</p>
			<pre class="source-code" lang="en-GB">
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest 
export PATH="$PATH:$(go env GOPATH)/bin" </pre>
			<p lang="en-GB">You can find the GitHub code for this chapter at <a href="https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter05">https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter05</a>.</p>
			<h1 id="_idParaDest-79" lang="en-GB"><a id="_idTextAnchor079"/>Introduction to synchronous communication</h1>
			<p lang="en-GB">In this section, we are going to cover the basics of synchronous communication and introduce you to some additional benefits of Protocol Buffers that we are going to use for our microservices. </p>
			<p lang="en-GB"><strong class="bold" lang="">Synchronous communication</strong> is the way of interaction between network applications, such as microservices, in which services exchange data using a <strong class="bold" lang="">request-response model</strong>. The process is illustrated in the following diagram:</p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/Figure_5.1_B18865.jpg" alt="Figure 5.1 – Synchronous communication&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Synchronous communication</p>
			<p lang="en-GB">There are many <strong class="bold" lang="">protocols</strong> allowing<a id="_idIndexMarker224"/> applications to communicate in this way. HTTP is among the most popular protocols for synchronous communication. In <a href="B18865_02.xhtml#_idTextAnchor027"><em class="italic" lang="">Chapter 2</em></a>, we already implemented the logic for calling and handling HTTP requests in our microservices.</p>
			<p lang="en-GB">The HTTP protocol <a id="_idIndexMarker225"/>allows you to send request and response data in different ways:</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">URL parameters</strong>: In<a id="_idIndexMarker226"/> the case of the <strong class="source-inline" lang="">https://www.google.com/search?q=portugal</strong> URL, <strong class="source-inline" lang="">q=portugal</strong> is a URL parameter.</li>
				<li lang="en-GB"><strong class="bold" lang="">Headers</strong>: Each<a id="_idIndexMarker227"/> request and response includes optional key-value pairs called headers, allowing you to propagate additional metadata, such as the client or browser name; for example, <strong class="source-inline" lang="">User-Agent: Mozilla/5.0</strong>.</li>
				<li lang="en-GB"><strong class="bold" lang="">Request and response body</strong>: The<a id="_idIndexMarker228"/> request <a id="_idIndexMarker229"/>and response can include a body that contains arbitrary data. For example, when a client uploads a file to a server, the file contents are usually sent as a request body.</li>
			</ul>
			<p lang="en-GB">When a server cannot handle a client request due to an error or the request is not received due to network issues, the client receives a specific response indicating an error. In the case of the HTTP protocol, there are two types of errors:</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Client error</strong>: This <a id="_idIndexMarker230"/>error is caused by the client. Examples of such errors include invalid request arguments (such as an incorrect username), unauthorized access, and access to a resource that is not found (for example, a non-existing web page).</li>
				<li lang="en-GB"><strong class="bold" lang="">Server error</strong>: This <a id="_idIndexMarker231"/>error is caused by the server. This could be an application bug or an error with an upstream component, such as a database.</li>
			</ul>
			<p lang="en-GB">In <a href="B18865_02.xhtml#_idTextAnchor027"><em class="italic" lang="">Chapter 2</em></a>, we implemented our API handlers by sending the result data as an HTTP response body in JSON format. We achieved this by using the Go JSON encoder:</p>
			<pre class="source-code" lang="en-GB">
if err := json.NewEncoder(w).Encode(details); err != nil {
    log.Printf("Response encode error: %v\n", err)
}</pre>
			<p lang="en-GB">As discussed in the previous chapter, the JSON format is not the most optimal in terms of data size. Also, it does not offer useful tools, such as the cross-language code generation of data structures, that are provided by the formats, such as Protocol Buffers. Additionally, sending requests over HTTP and encoding the data manually is not the only form of communication between the services. There are some existing <strong class="bold" lang="">remote procedure call</strong> (<strong class="bold" lang="">RPC</strong>) libraries<a id="_idIndexMarker232"/> and frameworks that help to communicate between multiple services and offer some additional features to application developers:</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Client and server code generation</strong>: Developers can generate the client code for connecting and sending data to other microservices, as well as generate the<a id="_idIndexMarker233"/> server code for accepting incoming requests.</li>
				<li lang="en-GB"><strong class="bold" lang="">Authentification</strong>: Most RPC libraries and frameworks offer authentication options for cross-service requests, such as TLS-based and token-based authentication.</li>
				<li lang="en-GB"><strong class="bold" lang="">Context propagation</strong>: This is the ability to send additional data with requests, such as traces, which we are going to cover in <a href="B18865_11.xhtml#_idTextAnchor152"><em class="italic" lang="">Chapter 11</em></a>.</li>
				<li lang="en-GB"><strong class="bold" lang="">Documentation generation</strong>: Thrift can generate HTML documentation for services and data structures.</li>
			</ul>
			<p lang="en-GB">In the next section, we are going to cover some of the RPC libraries that you can use in your Go services, along with the features they provide.</p>
			<h2 id="_idParaDest-80" lang="en-GB"><a id="_idTextAnchor080"/>Go RPC frameworks and libraries</h2>
			<p lang="en-GB">Let’s review some popular RPC frameworks and libraries that are available for Go developers.</p>
			<h3 lang="en-GB">Apache Thrift</h3>
			<p lang="en-GB">We already<a id="_idIndexMarker234"/> covered Apache Thrift in <a href="B18865_04.xhtml#_idTextAnchor067"><em class="italic" lang="">Chapter 4</em></a> and mentioned its<a id="_idIndexMarker235"/> ability to define RPC services – sets of functions provided by an application, such as a microservice. Here is an example of a Thrift RPC service definition:</p>
			<pre class="source-code" lang="en-GB">
service MetadataService {
  Metadata get(1: string id)
}</pre>
			<p lang="en-GB">The Thrift definition of a service can be used to generate client and server code. The client code would include the logic for connecting to an instance of a service, as well as making requests to it, serializing and deserializing the request and response structures. The advantage of using a library such as Apache Thrift over making HTTP requests manually is the ability to generate such code for multiple languages: a service written in Go could easily talk to a service written in Java, while both would use the generated code for the communication, removing the need of implementing serialization/deserialization logic. Additionally, Thrift allows us to generate the documentation for RPC services.</p>
			<h3 lang="en-GB">gRPC</h3>
			<p lang="en-GB"><strong class="bold" lang="">gRPC</strong> is<a id="_idIndexMarker236"/> an<a id="_idIndexMarker237"/> RPC framework that was created at Google. gRPC uses HTTP/2 as the transport protocol and Protocol Buffers as a serialization format. Similar to Apache Thrift, it provides an ability to define RPC services and generate the client and server code for the services. In addition to this, it offers some extra features, such <a id="_idIndexMarker238"/>as the following:</p>
			<ul>
				<li lang="en-GB">Authentication</li>
				<li lang="en-GB">Context propagation</li>
				<li lang="en-GB">Documentation generation</li>
			</ul>
			<p lang="en-GB">gRPC adoption<a id="_idIndexMarker239"/> is much higher than for Apache Thrift, and its support of the popular Protocol Buffers format makes it a great fit for microservice developers. In this book, we are going to use gRPC as a framework for synchronous communication between our microservices. In the next section, we are going to illustrate how to leverage the features provided by Protocol Buffers to define our service APIs.</p>
			<h1 id="_idParaDest-81" lang="en-GB"><a id="_idTextAnchor081"/>Defining a service API using Protocol Buffers</h1>
			<p lang="en-GB">Let’s demonstrate <a id="_idIndexMarker240"/>how to define a service API using the Protocol Buffers format and generate the client and server gRPC code for communication with each of our services <a id="_idIndexMarker241"/>using a <strong class="bold" lang="">proto</strong> compiler. This knowledge will help you to establish a foundation for both defining and implementing APIs for your microservices using one of the industry’s most popular communication tools.</p>
			<p lang="en-GB">Let’s start with our metadata service and write its API definition in the Protocol Buffers schema language.</p>
			<p lang="en-GB">Open the <strong class="source-inline" lang="">api/movie.proto</strong> file that we created in the previous chapter and add the following to it:</p>
			<pre class="source-code" lang="en-GB">
service MetadataService {
    rpc GetMetadata(GetMetadataRequest) returns (GetMetadataResponse);
    rpc PutMetadata(PutMetadataRequest) returns (PutMetadataResponse);
}
 
message GetMetadataRequest {
    string movie_id = 1;
}
 
message GetMetadataResponse {
    Metadata metadata = 1;
}</pre>
			<p lang="en-GB">The code<a id="_idIndexMarker242"/> we just added defines our metadata service and its <strong class="source-inline" lang="">GetMetadata</strong> endpoint. We already have the <strong class="source-inline" lang="">Metadata</strong> structure from the previous chapter that we can reuse now.</p>
			<p lang="en-GB">Let’s note some aspects of the code we just added:</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Request and response structures</strong>: It’s a good practice to create a new structure for both a request and a response. In our example, they are <strong class="source-inline" lang="">GetMetadataRequest</strong> and <strong class="source-inline" lang="">GetMetadataResponse</strong>.</li>
				<li lang="en-GB"><strong class="bold" lang="">Naming</strong>: You should follow consistent naming rules for all your endpoints. We are going to prefix all request and response functions with the function name.</li>
			</ul>
			<p lang="en-GB">Now, let’s add the definition of the rating service to the same file:</p>
			<pre class="source-code" lang="en-GB">
service RatingService {
    rpc GetAggregatedRating(GetAggregatedRatingRequest) returns (GetAggregatedRatingResponse);
    rpc PutRating(PutRatingRequest) returns (PutRatingResponse);
}
 
message GetAggregatedRatingRequest {
    string record_id = 1;
    int32 record_type = 2;
}
 
message GetAggregatedRatingResponse {
    double rating_value = 1;
}
 
message PutRatingRequest {
    string user_id = 1;
    string record_id = 2;
    int32 record_type = 3;
    int32 rating_value = 4;
}
 
message PutRatingResponse {
}</pre>
			<p lang="en-GB">Our rating <a id="_idIndexMarker243"/>service has two endpoints, and we defined requests and responses for them in a similar way to the metadata service.</p>
			<p lang="en-GB">Finally, let’s add the definition of the movie service to the same file:</p>
			<pre class="source-code" lang="en-GB">
service MovieService {
    rpc GetMovieDetails(GetMovieDetailsRequest) returns (GetMovieDetailsResponse);
}
 
message GetMovieDetailsRequest {
    string movie_id = 1;
}
 
message GetMovieDetailsResponse {
    MovieDetails movie_details = 1;
}</pre>
			<p lang="en-GB">Now our <strong class="source-inline" lang="">movie.proto</strong> file includes both our structure definitions and the API definitions <a id="_idIndexMarker244"/>for our services. We are ready to generate code for the newly added service definitions. In the <strong class="source-inline" lang="">src</strong> directory of the application, run the following:</p>
			<pre class="source-code" lang="en-GB">
protoc -I=api --go_out=. --go-grpc_out=. movie.proto  </pre>
			<p lang="en-GB">The preceding command is similar to the command that we used in the previous chapter for generating code for our data structures. However, it also passes a <strong class="source-inline" lang="">--go-grpc_out</strong> flag to the compiler. This flag tells the Protocol Buffers compiler to generate the service code in gRPC format. </p>
			<p lang="en-GB">Let’s see the compiled code that was generated as the output for our command. If the command is executed without any errors, you will find a <strong class="source-inline" lang="">movie_grpc.pb.go</strong> file inside the <strong class="source-inline" lang="">src/gen</strong> directory. The file will include the generated Go code for our services. Let’s take a look at the generated client code:</p>
			<pre class="source-code" lang="en-GB">
type MetadataServiceClient interface {
    GetMetadata(ctx context.Context, in *GetMetadataRequest, opts ...grpc.CallOption) (*GetMetadataResponse, error)
}
 
type metadataServiceClient struct {
    cc grpc.ClientConnInterface
}
 
func NewMetadataServiceClient(cc grpc.ClientConnInterface) MetadataServiceClient {
    return &amp;metadataServiceClient{cc}
}
func (c *metadataServiceClient) GetMetadata(ctx context.Context, in *GetMetadataRequest, opts ...grpc.CallOption) (*GetMetadataResponse, error) {
    out := new(GetMetadataResponse)
    err := c.cc.Invoke(ctx, "/MetadataService/GetMetadata", in, out, opts...)
    if err != nil {
        return nil, err
    }
    return out, nil
}</pre>
			<p lang="en-GB">This <a id="_idIndexMarker245"/>generated code can be used in our applications to call our API from the Go applications. Additionally, we can generate such client code for other languages, such as Java, adding more arguments to the compiler command that we just executed. This is a great feature that can save us lots of time when writing microservice applications – instead of writing client logic for calling our services, we can use the generated clients and plug them into our applications.</p>
			<p lang="en-GB">In addition to the client code, the Protocol Buffers compiler also generates the service code that can <a id="_idIndexMarker246"/>be used for handling the requests. In the same <strong class="source-inline" lang="">movie_grpc.pb.go</strong> file, you will find the following:</p>
			<pre class="source-code" lang="en-GB">
type MetadataServiceServer interface {
    GetMetadata(context.Context, *GetMetadataRequest) (*GetMetadataResponse, error)
    mustEmbedUnimplementedMetadataServiceServer()
}
func RegisterMetadataServiceServer(s grpc.ServiceRegistrar, srv MetadataServiceServer) {
s.RegisterService(&amp;MetadataService_ServiceDesc, srv)
}</pre>
			<p lang="en-GB">We are going to use both the client and server code that we just saw in our application. In the next section, we are going to modify our API handlers to use the generated code and handle requests using the Protocol Buffers format.</p>
			<h1 id="_idParaDest-82" lang="en-GB"><a id="_idTextAnchor082"/>Implementing gateways and clients</h1>
			<p lang="en-GB">In this section, we are<a id="_idIndexMarker247"/> going to illustrate how to plug the generated client and server gRPC code into<a id="_idIndexMarker248"/> our microservices. This will help us to switch communication between them from JSON-serialized HTTP to Protocol Buffers gRPC calls.</p>
			<h2 id="_idParaDest-83" lang="en-GB"><a id="_idTextAnchor083"/>Metadata service</h2>
			<p lang="en-GB">In <a href="B18865_02.xhtml#_idTextAnchor027"><em class="italic" lang="">Chapter 2</em></a>, we<a id="_idIndexMarker249"/> created our internal model structures, such as metadata, and in <a href="B18865_04.xhtml#_idTextAnchor067"><em class="italic" lang="">Chapter 4</em></a>, we created their Protocol Buffers counterparts. Then, we generated the code for our Protocol Buffers definitions. As a result, we have two versions of our model structures – internal ones, as defined in <strong class="source-inline" lang="">metadata/pkg/model</strong>, and the generated ones, which are located in the <strong class="source-inline" lang="">gen</strong> package.</p>
			<p lang="en-GB">You might think that having two similar structures is now redundant. While there is certainly some <a id="_idIndexMarker250"/>level of redundancy in having such duplicate definitions, these structures practically serve different purposes:</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Internal model</strong>: The <a id="_idIndexMarker251"/>structures that you create manually for your application should be used across its code base, such as the repository, controller, and other logic.</li>
				<li lang="en-GB"><strong class="bold" lang="">Generated model</strong>: Structures <a id="_idIndexMarker252"/>generated by tools such as the protoc compiler, which we used in the last two chapters, should only be used for serialization. The use cases include transferring the data between the services or storing the serialized data.</li>
			</ul>
			<p lang="en-GB">You might be curious why it’s not recommended to use the generated structures across the application code base. There are multiple reasons for this, which are listed as follows:</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Unnecessary coupling between the application and serialization format</strong>: If you ever want to switch from one serialization format to another (for example, from Thrift to Protocol Buffers), and all your application code base uses generated structures for the previous serialization format, you would need to rewrite not only the serialization code but the entire application.</li>
				<li lang="en-GB"><strong class="bold" lang="">Generated code structure could vary between different versions</strong>: While the field naming and high-level structure of the generated structures are generally stable between different versions of code generation tooling, the internal functions and structure of the generated code could vary from version to version. If any part of your application uses some generated functions that get changed, your application could break unexpectedly during a version update of a code generator.</li>
				<li lang="en-GB"><strong class="bold" lang="">Generated code is often harder to use</strong>: In formats such as Protocol Buffers, all fields are always optional. In generated code, this results in lots of fields that can have nil values. For an application developer, this means doing more nil checks across all applications to prevent possible panics.</li>
			</ul>
			<p lang="en-GB">Because of these reasons, the best practice is to keep both internal structures and the generated ones and only use the generated structures for serialization. Let’s illustrate how to achieve this. </p>
			<p lang="en-GB">We would <a id="_idIndexMarker253"/>need to add some <strong class="bold" lang="">mapping</strong> logic<a id="_idIndexMarker254"/> to translate the internal data structures and their generated counterparts. In the <strong class="source-inline" lang="">metadata/pkg/model</strong> directory, create a <strong class="source-inline" lang="">mapper.go</strong> file and add the following to it:</p>
			<pre class="source-code" lang="en-GB">
package model
 
import (
    "movieexample.com/gen"
)
 
// MetadataToProto converts a Metadata struct into a 
// generated proto counterpart.
func MetadataToProto(m *Metadata) *gen.Metadata {
    return &amp;gen.Metadata{
        Id:          m.ID,
        Title:       m.Title,
        Description: m.Description,
        Director:    m.Director,
    }
}
 
// MetadataFromProto converts a generated proto counterpart 
// into a Metadata struct.
func MetadataFromProto(m *gen.Metadata) *Metadata {
    return &amp;Metadata{
        ID:          m.Id,
        Title:       m.Title,
        Description: m.Description,
        Director:    m.Director,
    }
}</pre>
			<p lang="en-GB">The code <a id="_idIndexMarker255"/>we just added transforms the internal model into the generated structures and back. In the following code block, we are going to use it in the server code.</p>
			<p lang="en-GB">Now, let’s implement a gRPC handler for the metadata service that would handle the client requests to the service. In the <strong class="source-inline" lang="">metadata/internal/handler</strong> package, create a <strong class="source-inline" lang="">grpc</strong> directory and add a <strong class="source-inline" lang="">grpc.go</strong> file:</p>
			<pre class="source-code" lang="en-GB">
package grpc
 
import (
    "context"
    "errors"
 
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
    "movieexample.com/gen"
    "movieexample.com/metadata/internal/controller"
    "movieexample.com/metadata/internal/repository"
    "movieexample.com/metadata/pkg/model"
)
 
// Handler defines a movie metadata gRPC handler.
type Handler struct {
    gen.UnimplementedMetadataServiceServer
    svc *controller.MetadataService
}
 
// New creates a new movie metadata gRPC handler.
func New(ctrl *metadata.Controller) *Handler {
    return &amp;Handler{ctrl: ctrl}
}</pre>
			<p lang="en-GB">Let’s implement<a id="_idIndexMarker256"/> the <strong class="source-inline" lang="">GetMetadataByID</strong> function:</p>
			<pre class="source-code" lang="en-GB">
// GetMetadataByID returns movie metadata by id.
func (h *Handler) GetMetadata(ctx context.Context, req *gen.GetMetadataRequest) (*gen.GetMetadataResponse, error) {
    if req == nil || req.MovieId == "" {
        return nil, status.Errorf(codes.InvalidArgument, "nil req or empty id")
    }
    m, err := h.svc.Get(ctx, req.MovieId)
    if err != nil &amp;&amp; errors.Is(err, controller.ErrNotFound) {
        return nil, status.Errorf(codes.NotFound, err.Error())
    } else if err != nil {
        return nil, status.Errorf(codes.Internal, err.Error())
    }
    return &amp;gen.GetMetadataResponse{Metadata: model.MetadataToProto(m)}, nil
}</pre>
			<p lang="en-GB">Let’s highlight<a id="_idIndexMarker257"/> some parts of this implementation:</p>
			<ul>
				<li lang="en-GB">The handler embeds the generated <strong class="source-inline" lang="">gen.UnimplementedMetadataServiceServer</strong> structure. This is required by a Protocol Buffers compiler to enforce future compatibility.</li>
				<li lang="en-GB">Our handler implements the <strong class="source-inline" lang="">GetMetadata</strong> function in exactly the same format as defined in the generated <strong class="source-inline" lang="">MetadataServiceServer</strong> interface.</li>
				<li lang="en-GB">We are using the <strong class="source-inline" lang="">MetadataToProto</strong> mapping function to transform our internal structures into the generated ones.</li>
			</ul>
			<p lang="en-GB">Now we are ready to update our main file and switch it to the gRPC handler. Update the <strong class="source-inline" lang="">metadata/cmd/main.go</strong> file, changing its contents to the following:</p>
			<pre class="source-code" lang="en-GB">
package main
 
import (
    "context"
    "flag"
    "fmt"
    "log"
    "net"
    "time"
 
    "google.golang.org/grpc"
    "movieexample.com/gen"
    "movieexample.com/metadata/internal/controller"
    grpchandler "movieexample.com/metadata/internal/handler/grpc"
    "movieexample.com/metadata/internal/repository/memory"
    "movieexample.com/metadata/pkg/model"
)
 
func main() {
    log.Println("Starting the movie metadata service")
    repo := memory.New()
    svc := controller.New(repo)
    h := grpchandler.New(svc)
    lis, err := net.Listen("tcp", "localhost:8081")
    if err != nil {
        log.Fatalf("failed to listen: %v", err)
    }
    srv := grpc.NewServer()
    gen.RegisterMetadataServiceServer(srv, h)
    srv.Serve(lis)
}</pre>
			<p lang="en-GB">The <a id="_idIndexMarker258"/>updated <strong class="source-inline" lang="">main</strong> function illustrates how we instantiate our gRPC server and start listening for requests in it. The rest of the function is similar to the one we had before.</p>
			<p lang="en-GB">We are done with the changes to the metadata service and can now proceed to the rating service.</p>
			<h2 id="_idParaDest-84" lang="en-GB"><a id="_idTextAnchor084"/>Rating service</h2>
			<p lang="en-GB">Let’s create <a id="_idIndexMarker259"/>a gRPC handler for the rating service. In the <strong class="source-inline" lang="">rating/internal/handler</strong> package, create a <strong class="source-inline" lang="">grpc</strong> directory and add a <strong class="source-inline" lang="">grpc.go</strong> file with the following code:</p>
			<pre class="source-code" lang="en-GB">
package grpc
 
import (
    "context"
    "errors"
 
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/status"
    "movieexample.com/gen"
    "movieexample.com/rating/internal/controller"
    "movieexample.com/rating/pkg/model"
)
 
// Handler defines a gRPC rating API handler.
type Handler struct {
    gen.UnimplementedRatingServiceServer
    svc *controller.RatingService
}
 
// New creates a new movie metadata gRPC handler.
func New(svc *controller.RatingService) *Handler {
    return &amp;Handler{ctrl: ctrl}
}</pre>
			<p lang="en-GB">Now, let’s<a id="_idIndexMarker260"/> implement the <strong class="source-inline" lang="">GetAggregatedRating</strong> endpoint:</p>
			<pre class="source-code" lang="en-GB">
// GetAggregatedRating returns the aggregated rating for a 
// record.
func (h *Handler) GetAggregatedRating(ctx context.Context, req *gen.GetAggregatedRatingRequest) (*gen.GetAggregatedRatingResponse, error) {
    if req == nil || req.RecordId == "" || req.RecordType == "" {
        return nil, status.Errorf(codes.InvalidArgument, "nil req or empty id")
    }
    v, err := h.svc.GetAggregatedRating(ctx, model.RecordID(req.RecordId), model.RecordType(req.RecordType))
    if err != nil &amp;&amp; errors.Is(err, controller.ErrNotFound) {
        return nil, status.Errorf(codes.NotFound, err.Error())
    } else if err != nil {
        return nil, status.Errorf(codes.Internal, err.Error())
    }
    return &amp;gen.GetAggregatedRatingResponse{RatingValue: v}, nil
}</pre>
			<p lang="en-GB">Finally, let’s implement the <strong class="source-inline" lang="">PutRating</strong> endpoint:</p>
			<pre class="source-code" lang="en-GB">
// PutRating writes a rating for a given record.
func (h *Handler) PutRating(ctx context.Context, req *gen.PutRatingRequest) (*gen.PutRatingResponse, error) {
    if req == nil || req.RecordId == "" || req.UserId == "" {
        return nil, status.Errorf(codes.InvalidArgument, "nil req or empty user id or record id")
    }
    if err := h.svc.PutRating(ctx, model.RecordID(req.RecordId), model.RecordType(req.RecordType), &amp;model.Rating{UserID: model.UserID(req.UserId), Value: model.RatingValue(req.RatingValue)}); err != nil {
        return nil, err
    }
    return &amp;gen.PutRatingResponse{}, nil
}</pre>
			<p lang="en-GB">Now, we are <a id="_idIndexMarker261"/>ready to update our <strong class="source-inline" lang="">rating/cmd/main.go</strong> file. Replace it with the following:</p>
			<pre class="source-code" lang="en-GB">
package main
 
import (
    "log"
    "net"
 
    "google.golang.org/grpc"
    "movieexample.com/gen"
    "movieexample.com/rating/internal/controller"
    grpchandler "movieexample.com/rating/internal/handler/grpc"
    "movieexample.com/rating/internal/repository/memory"
)
 
func main() {
    log.Println("Starting the rating service")
    repo := memory.New()
    svc := controller.New(repo)
    h := grpchandler.New(svc)
    lis, err := net.Listen("tcp", "localhost:8082")
    if err != nil {
        log.Fatalf("failed to listen: %v", err)
    }
    srv := grpc.NewServer()
    gen.RegisterRatingServiceServer(srv, h)
    srv.Serve(lis)
}</pre>
			<p lang="en-GB">The way we <a id="_idIndexMarker262"/>start the service is similar to the metadata service. Now, we are ready to link the movie service to both the metadata and rating services.</p>
			<h2 id="_idParaDest-85" lang="en-GB"><a id="_idTextAnchor085"/>Movie service</h2>
			<p lang="en-GB">In <a id="_idIndexMarker263"/>the previous examples, we created gRPC servers to handle client requests. Now, let’s illustrate how to add logic for calling our servers. This will help us to establish communication between our microservices via gRPC.</p>
			<p lang="en-GB">First, let’s implement a function that we can reuse in our service gateways. Create the <strong class="source-inline" lang="">src/internal/grpcutil</strong> directory, and add a file called <strong class="source-inline" lang="">grpcutil.go</strong> to it. Add the following <a id="_idIndexMarker264"/>code to it:</p>
			<pre class="source-code" lang="en-GB">
package grpcutil
import (
    "context"
    "math/rand"
    "pkg/discovery"
    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
    "movieexample.com/pkg/discovery"
)
// ServiceConnection attempts to select a random service 
// instance and returns a gRPC connection to it.
func ServiceConnection(ctx context.Context, serviceName string, registry discovery.Registry) (*grpc.ClientConn, error) {
    addrs, err := registry.ServiceAddresses(ctx, serviceName)
    if err != nil {
        return nil, err
    }
    return grpc.Dial(addrs[rand.Intn(len(addrs))], grpc.WithTransportCredentials(insecure.NewCredentials()))
}</pre>
			<p lang="en-GB">The function that we just implemented will try to pick a random instance of the target service using the provided service registry, and then it will create a gRPC connection for it.</p>
			<p lang="en-GB">Now, let’s<a id="_idIndexMarker265"/> create a gateway for our metadata service. In the <strong class="source-inline" lang="">movie/internal/gateway</strong> package, create a directory called <strong class="source-inline" lang="">metadata</strong>. Inside it, create a <strong class="source-inline" lang="">grpc</strong> directory with a <strong class="source-inline" lang="">metadata.go</strong> file, containing the following code:</p>
			<pre class="source-code" lang="en-GB">
package grpc
 
import (
    "context"
    "google.golang.org/grpc"
    "movieexample.com/gen"
    "movieexample.com/internal/grpcutil"
    "movieexample.com/metadata/pkg/model"
    "movieexample.com/pkg/discovery"
)
 
// Gateway defines a movie metadata gRPC gateway.
type Gateway struct {
    registry discovery.Registry
}
 
// New creates a new gRPC gateway for a movie metadata 
// service.
func New(registry discovery.Registry) *Gateway {
    return &amp;Gateway{registry}
}</pre>
			<p lang="en-GB">Let’s implement<a id="_idIndexMarker266"/> the function for getting the metadata from a remote gRPC service:</p>
			<pre class="source-code" lang="en-GB">
// Get returns movie metadata by a movie id.
func (g *Gateway) Get(ctx context.Context, id string) (*model.Metadata, error) {
    conn, err := grpcutil.ServiceConnection(ctx, "metadata", g.registry)
    if err != nil {
        return nil, err
    }
    defer conn.Close()
    client := gen.NewMetadataServiceClient(conn)
    resp, err := client.GetMetadataByID(ctx, &amp;gen.GetMetadataByIDRequest{MovieId: id})
    if err != nil {
        return nil, err
    }
    return model.MetadataFromProto(resp.Metadata), nil
}</pre>
			<p lang="en-GB">Let’s highlight some details of our gateway implementation:</p>
			<ul>
				<li lang="en-GB">We use the <strong class="source-inline" lang="">grpcutil.ServiceConnection</strong> function to create a connection to our metadata service.</li>
				<li lang="en-GB">We create a client using the generated client code from the <strong class="source-inline" lang="">gen</strong> package.</li>
				<li lang="en-GB">We use the <strong class="source-inline" lang="">MetadataFromProto</strong> mapping function to convert the generated structures into internal ones.</li>
			</ul>
			<p lang="en-GB">Now we are ready <a id="_idIndexMarker267"/>to create a gateway for our rating service. Inside the <strong class="source-inline" lang="">movie/internal/gateway</strong> package, create a <strong class="source-inline" lang="">rating/grpc</strong> directory and add a <strong class="source-inline" lang="">grpc.go</strong> file with the following contents:</p>
			<pre class="source-code" lang="en-GB">
package grpc
 
import (
    "context"
    "pkg/discovery"
    "rating/pkg/model"
 
    "google.golang.org/grpc"
    "movieexample.com/internal/grpcutil"
    "movieexample.com/gen"
)
 
// Gateway defines an gRPC gateway for a rating service.
type Gateway struct {
    registry discovery.Registry
}
 
// New creates a new gRPC gateway for a rating service.
func New(registry discovery.Registry) *Gateway {
    return &amp;Gateway{registry}
}</pre>
			<p lang="en-GB">Add the implementation of the <strong class="source-inline" lang="">GetAggregatedRating</strong> function:</p>
			<pre class="source-code" lang="en-GB">
// GetAggregatedRating returns the aggregated rating for a 
// record or ErrNotFound if there are no ratings for it.
func (g *Gateway) GetAggregatedRating(ctx context.Context, recordID model.RecordID, recordType model.RecordType) (float64, error) {
    conn, err := grpcutil.ServiceConnection(ctx, "rating", g.registry)
    if err != nil {
        return 0, err
    }
    defer conn.Close()
    client := gen.NewRatingServiceClient(conn)
    resp, err := client.GetAggregatedRating(ctx, &amp;gen.GetAggregatedRatingRequest{RecordId: string(recordID), RecordType: string(recordType)})
    if err != nil {
        return 0, err
    }
    return resp.RatingValue, nil
}</pre>
			<p lang="en-GB">At this point, we <a id="_idIndexMarker268"/>are almost done with the changes. The last step is to update the <strong class="source-inline" lang="">main</strong> function of the movie service. Change it to the following:</p>
			<pre class="source-code" lang="en-GB">
package main
 
import (
    "context"
    "log"
    "net"
 
    "google.golang.org/grpc"
    "movieexample.com/gen"
    "movieexample.com/movie/internal/controller"
    metadatagateway "movieexample.com/movie/internal/gateway/metadata/grpc"
    ratinggateway "movieexample.com/movie/internal/gateway/rating/grpc"
    grpchandler "movieexample.com/movie/internal/handler/grpc"
"movieexample.com/pkg/discovery/static"
)
func main() {
    log.Println("Starting the movie service")
    registry := static.NewRegistry(map[string][]string{
        "metadata": {"localhost:8081"},
        "rating":   {"localhost:8082"},
        "movie":    {"localhost:8083"},
    })
    ctx := context.Background()
    if err := registry.Register(ctx, "movie", "localhost:8083"); err != nil {
        panic(err)
    }
    defer registry.Deregister(ctx, "movie")
    metadataGateway := metadatagateway.New(registry)
    ratingGateway := ratinggateway.New(registry)
    svc := controller.New(ratingGateway, metadataGateway)
    h := grpchandler.New(svc)
    lis, err := net.Listen("tcp", "localhost:8083")
    if err != nil {
        log.Fatalf("failed to listen: %v", err)
    }
    srv := grpc.NewServer()
    gen.RegisterMovieServiceServer(srv, h)
    srv.Serve(lis)
}</pre>
			<p lang="en-GB">You might <a id="_idIndexMarker269"/>have noticed that the format hasn’t changed, and we just updated the imports for our gateways, changing them from HTTP to gRPC.</p>
			<p lang="en-GB">We are done with the changes to our services. Now the services can communicate with each other using the Protocol Buffers serialization, and you can run them using the <strong class="source-inline" lang="">go run *.go</strong> command inside each <strong class="source-inline" lang="">cmd</strong> directory.</p>
			<h1 id="_idParaDest-86" lang="en-GB"><a id="_idTextAnchor086"/>Summary</h1>
			<p lang="en-GB">In this chapter, we covered the basics of synchronous communication and learned how to make microservices communicate with each other using the Protocol Buffers format. We illustrated how to define our service APIs using the Protocol Buffers schema language and generate code that can be reused in microservice applications written in Go and other languages.</p>
			<p lang="en-GB">The knowledge you gained in this chapter should help you write and maintain the existing services using Protocol Buffers and gRPC. It also serves as an example of how to use code generation for your services. In the next chapter, we are going to continue our journey into different ways of communication by covering another model, asynchronous communication.</p>
			<h1 id="_idParaDest-87" lang="en-GB"><a id="_idTextAnchor087"/>Further reading</h1>
			<ul>
				<li lang="en-GB"><em class="italic" lang="">gRPC</em>: <a href="https://grpc.io">https://grpc.io</a></li>
				<li lang="en-GB"><em class="italic" lang="">HTTP/2 detailed overview</em>: <a href="https://web.dev/performance-http2">https://web.dev/performance-http2</a></li>
			</ul>
		</div>
	</body></html>