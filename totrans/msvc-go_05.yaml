- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Synchronous Communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to cover the most common way of communicating
    between microservices – synchronous communication. In [*Chapter 2*](B18865_02.xhtml#_idTextAnchor027),
    we already implemented the logic for communicating between microservices via the
    HTTP protocol and returning results in JSON format. In [*Chapter 4*](B18865_04.xhtml#_idTextAnchor067),
    we illustrated that the JSON format is not the most efficient in terms of data
    size, and there are many different formats providing additional benefits to developers,
    including code generation. In this chapter, we are going to show you how to define
    service APIs using Protocol Buffers and generate both client and server code for
    them.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand the key concepts of synchronous
    communication between microservices and will have learned how to implement microservice
    clients and servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The knowledge you gain in this chapter will help you to learn how to better
    organize the client and server code, generate the code for serialization and communication,
    and use it in your microservices. In this chapter, we will cover the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to synchronous communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a service API using Protocol Buffers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing gateways and clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s proceed to the main concepts of synchronous communication.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete this chapter, you will need Go 1.11, a Protocol Buffers compiler
    that we installed in the previous chapter, and a gRPC plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install the gRPC plugin by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can find the GitHub code for this chapter at [https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter05](https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to synchronous communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to cover the basics of synchronous communication
    and introduce you to some additional benefits of Protocol Buffers that we are
    going to use for our microservices.
  prefs: []
  type: TYPE_NORMAL
- en: '**Synchronous communication** is the way of interaction between network applications,
    such as microservices, in which services exchange data using a **request-response
    model**. The process is illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Synchronous communication'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.1_B18865.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – Synchronous communication
  prefs: []
  type: TYPE_NORMAL
- en: There are many **protocols** allowing applications to communicate in this way.
    HTTP is among the most popular protocols for synchronous communication. In [*Chapter
    2*](B18865_02.xhtml#_idTextAnchor027), we already implemented the logic for calling
    and handling HTTP requests in our microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTTP protocol allows you to send request and response data in different
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://www.google.com/search?q=portugal` URL, `q=portugal` is a URL parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`User-Agent: Mozilla/5.0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request and response body**: The request and response can include a body
    that contains arbitrary data. For example, when a client uploads a file to a server,
    the file contents are usually sent as a request body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When a server cannot handle a client request due to an error or the request
    is not received due to network issues, the client receives a specific response
    indicating an error. In the case of the HTTP protocol, there are two types of
    errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client error**: This error is caused by the client. Examples of such errors
    include invalid request arguments (such as an incorrect username), unauthorized
    access, and access to a resource that is not found (for example, a non-existing
    web page).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server error**: This error is caused by the server. This could be an application
    bug or an error with an upstream component, such as a database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [*Chapter 2*](B18865_02.xhtml#_idTextAnchor027), we implemented our API
    handlers by sending the result data as an HTTP response body in JSON format. We
    achieved this by using the Go JSON encoder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As discussed in the previous chapter, the JSON format is not the most optimal
    in terms of data size. Also, it does not offer useful tools, such as the cross-language
    code generation of data structures, that are provided by the formats, such as
    Protocol Buffers. Additionally, sending requests over HTTP and encoding the data
    manually is not the only form of communication between the services. There are
    some existing **remote procedure call** (**RPC**) libraries and frameworks that
    help to communicate between multiple services and offer some additional features
    to application developers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client and server code generation**: Developers can generate the client code
    for connecting and sending data to other microservices, as well as generate the
    server code for accepting incoming requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authentification**: Most RPC libraries and frameworks offer authentication
    options for cross-service requests, such as TLS-based and token-based authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Context propagation**: This is the ability to send additional data with requests,
    such as traces, which we are going to cover in [*Chapter 11*](B18865_11.xhtml#_idTextAnchor152).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation generation**: Thrift can generate HTML documentation for services
    and data structures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we are going to cover some of the RPC libraries that you
    can use in your Go services, along with the features they provide.
  prefs: []
  type: TYPE_NORMAL
- en: Go RPC frameworks and libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s review some popular RPC frameworks and libraries that are available for
    Go developers.
  prefs: []
  type: TYPE_NORMAL
- en: Apache Thrift
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We already covered Apache Thrift in [*Chapter 4*](B18865_04.xhtml#_idTextAnchor067)
    and mentioned its ability to define RPC services – sets of functions provided
    by an application, such as a microservice. Here is an example of a Thrift RPC
    service definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The Thrift definition of a service can be used to generate client and server
    code. The client code would include the logic for connecting to an instance of
    a service, as well as making requests to it, serializing and deserializing the
    request and response structures. The advantage of using a library such as Apache
    Thrift over making HTTP requests manually is the ability to generate such code
    for multiple languages: a service written in Go could easily talk to a service
    written in Java, while both would use the generated code for the communication,
    removing the need of implementing serialization/deserialization logic. Additionally,
    Thrift allows us to generate the documentation for RPC services.'
  prefs: []
  type: TYPE_NORMAL
- en: gRPC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**gRPC** is an RPC framework that was created at Google. gRPC uses HTTP/2 as
    the transport protocol and Protocol Buffers as a serialization format. Similar
    to Apache Thrift, it provides an ability to define RPC services and generate the
    client and server code for the services. In addition to this, it offers some extra
    features, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Context propagation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: gRPC adoption is much higher than for Apache Thrift, and its support of the
    popular Protocol Buffers format makes it a great fit for microservice developers.
    In this book, we are going to use gRPC as a framework for synchronous communication
    between our microservices. In the next section, we are going to illustrate how
    to leverage the features provided by Protocol Buffers to define our service APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a service API using Protocol Buffers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s demonstrate how to define a service API using the Protocol Buffers format
    and generate the client and server gRPC code for communication with each of our
    services using a **proto** compiler. This knowledge will help you to establish
    a foundation for both defining and implementing APIs for your microservices using
    one of the industry’s most popular communication tools.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with our metadata service and write its API definition in the Protocol
    Buffers schema language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `api/movie.proto` file that we created in the previous chapter and
    add the following to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The code we just added defines our metadata service and its `GetMetadata` endpoint.
    We already have the `Metadata` structure from the previous chapter that we can
    reuse now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s note some aspects of the code we just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetMetadataRequest` and `GetMetadataResponse`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Naming**: You should follow consistent naming rules for all your endpoints.
    We are going to prefix all request and response functions with the function name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s add the definition of the rating service to the same file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Our rating service has two endpoints, and we defined requests and responses
    for them in a similar way to the metadata service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s add the definition of the movie service to the same file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our `movie.proto` file includes both our structure definitions and the
    API definitions for our services. We are ready to generate code for the newly
    added service definitions. In the `src` directory of the application, run the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command is similar to the command that we used in the previous
    chapter for generating code for our data structures. However, it also passes a
    `--go-grpc_out` flag to the compiler. This flag tells the Protocol Buffers compiler
    to generate the service code in gRPC format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see the compiled code that was generated as the output for our command.
    If the command is executed without any errors, you will find a `movie_grpc.pb.go`
    file inside the `src/gen` directory. The file will include the generated Go code
    for our services. Let’s take a look at the generated client code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This generated code can be used in our applications to call our API from the
    Go applications. Additionally, we can generate such client code for other languages,
    such as Java, adding more arguments to the compiler command that we just executed.
    This is a great feature that can save us lots of time when writing microservice
    applications – instead of writing client logic for calling our services, we can
    use the generated clients and plug them into our applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the client code, the Protocol Buffers compiler also generates
    the service code that can be used for handling the requests. In the same `movie_grpc.pb.go`
    file, you will find the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We are going to use both the client and server code that we just saw in our
    application. In the next section, we are going to modify our API handlers to use
    the generated code and handle requests using the Protocol Buffers format.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing gateways and clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to illustrate how to plug the generated client
    and server gRPC code into our microservices. This will help us to switch communication
    between them from JSON-serialized HTTP to Protocol Buffers gRPC calls.
  prefs: []
  type: TYPE_NORMAL
- en: Metadata service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B18865_02.xhtml#_idTextAnchor027), we created our internal
    model structures, such as metadata, and in [*Chapter 4*](B18865_04.xhtml#_idTextAnchor067),
    we created their Protocol Buffers counterparts. Then, we generated the code for
    our Protocol Buffers definitions. As a result, we have two versions of our model
    structures – internal ones, as defined in `metadata/pkg/model`, and the generated
    ones, which are located in the `gen` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might think that having two similar structures is now redundant. While
    there is certainly some level of redundancy in having such duplicate definitions,
    these structures practically serve different purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Internal model**: The structures that you create manually for your application
    should be used across its code base, such as the repository, controller, and other
    logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generated model**: Structures generated by tools such as the protoc compiler,
    which we used in the last two chapters, should only be used for serialization.
    The use cases include transferring the data between the services or storing the
    serialized data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You might be curious why it’s not recommended to use the generated structures
    across the application code base. There are multiple reasons for this, which are
    listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unnecessary coupling between the application and serialization format**:
    If you ever want to switch from one serialization format to another (for example,
    from Thrift to Protocol Buffers), and all your application code base uses generated
    structures for the previous serialization format, you would need to rewrite not
    only the serialization code but the entire application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generated code structure could vary between different versions**: While the
    field naming and high-level structure of the generated structures are generally
    stable between different versions of code generation tooling, the internal functions
    and structure of the generated code could vary from version to version. If any
    part of your application uses some generated functions that get changed, your
    application could break unexpectedly during a version update of a code generator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generated code is often harder to use**: In formats such as Protocol Buffers,
    all fields are always optional. In generated code, this results in lots of fields
    that can have nil values. For an application developer, this means doing more
    nil checks across all applications to prevent possible panics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of these reasons, the best practice is to keep both internal structures
    and the generated ones and only use the generated structures for serialization.
    Let’s illustrate how to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would need to add some `metadata/pkg/model` directory, create a `mapper.go`
    file and add the following to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The code we just added transforms the internal model into the generated structures
    and back. In the following code block, we are going to use it in the server code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s implement a gRPC handler for the metadata service that would handle
    the client requests to the service. In the `metadata/internal/handler` package,
    create a `grpc` directory and add a `grpc.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s implement the `GetMetadataByID` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s highlight some parts of this implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: The handler embeds the generated `gen.UnimplementedMetadataServiceServer` structure.
    This is required by a Protocol Buffers compiler to enforce future compatibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our handler implements the `GetMetadata` function in exactly the same format
    as defined in the generated `MetadataServiceServer` interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are using the `MetadataToProto` mapping function to transform our internal
    structures into the generated ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we are ready to update our main file and switch it to the gRPC handler.
    Update the `metadata/cmd/main.go` file, changing its contents to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The updated `main` function illustrates how we instantiate our gRPC server and
    start listening for requests in it. The rest of the function is similar to the
    one we had before.
  prefs: []
  type: TYPE_NORMAL
- en: We are done with the changes to the metadata service and can now proceed to
    the rating service.
  prefs: []
  type: TYPE_NORMAL
- en: Rating service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a gRPC handler for the rating service. In the `rating/internal/handler`
    package, create a `grpc` directory and add a `grpc.go` file with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s implement the `GetAggregatedRating` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let’s implement the `PutRating` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to update our `rating/cmd/main.go` file. Replace it with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The way we start the service is similar to the metadata service. Now, we are
    ready to link the movie service to both the metadata and rating services.
  prefs: []
  type: TYPE_NORMAL
- en: Movie service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous examples, we created gRPC servers to handle client requests.
    Now, let’s illustrate how to add logic for calling our servers. This will help
    us to establish communication between our microservices via gRPC.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s implement a function that we can reuse in our service gateways.
    Create the `src/internal/grpcutil` directory, and add a file called `grpcutil.go`
    to it. Add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The function that we just implemented will try to pick a random instance of
    the target service using the provided service registry, and then it will create
    a gRPC connection for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s create a gateway for our metadata service. In the `movie/internal/gateway`
    package, create a directory called `metadata`. Inside it, create a `grpc` directory
    with a `metadata.go` file, containing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s implement the function for getting the metadata from a remote gRPC service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s highlight some details of our gateway implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: We use the `grpcutil.ServiceConnection` function to create a connection to our
    metadata service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create a client using the generated client code from the `gen` package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the `MetadataFromProto` mapping function to convert the generated structures
    into internal ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we are ready to create a gateway for our rating service. Inside the `movie/internal/gateway`
    package, create a `rating/grpc` directory and add a `grpc.go` file with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the implementation of the `GetAggregatedRating` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we are almost done with the changes. The last step is to update
    the `main` function of the movie service. Change it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You might have noticed that the format hasn’t changed, and we just updated the
    imports for our gateways, changing them from HTTP to gRPC.
  prefs: []
  type: TYPE_NORMAL
- en: We are done with the changes to our services. Now the services can communicate
    with each other using the Protocol Buffers serialization, and you can run them
    using the `go run *.go` command inside each `cmd` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the basics of synchronous communication and learned
    how to make microservices communicate with each other using the Protocol Buffers
    format. We illustrated how to define our service APIs using the Protocol Buffers
    schema language and generate code that can be reused in microservice applications
    written in Go and other languages.
  prefs: []
  type: TYPE_NORMAL
- en: The knowledge you gained in this chapter should help you write and maintain
    the existing services using Protocol Buffers and gRPC. It also serves as an example
    of how to use code generation for your services. In the next chapter, we are going
    to continue our journey into different ways of communication by covering another
    model, asynchronous communication.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*gRPC*: [https://grpc.io](https://grpc.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*HTTP/2 detailed overview*: [https://web.dev/performance-http2](https://web.dev/performance-http2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
