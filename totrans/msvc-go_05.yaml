- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Synchronous Communication
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步通信
- en: In this chapter, we are going to cover the most common way of communicating
    between microservices – synchronous communication. In [*Chapter 2*](B18865_02.xhtml#_idTextAnchor027),
    we already implemented the logic for communicating between microservices via the
    HTTP protocol and returning results in JSON format. In [*Chapter 4*](B18865_04.xhtml#_idTextAnchor067),
    we illustrated that the JSON format is not the most efficient in terms of data
    size, and there are many different formats providing additional benefits to developers,
    including code generation. In this chapter, we are going to show you how to define
    service APIs using Protocol Buffers and generate both client and server code for
    them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍微服务之间最常见的通信方式——同步通信。在 [*第 2 章*](B18865_02.xhtml#_idTextAnchor027)
    中，我们已经在我们的微服务中实现了通过 HTTP 协议进行通信并在 JSON 格式返回结果的逻辑。在 [*第 4 章*](B18865_04.xhtml#_idTextAnchor067)
    中，我们说明了 JSON 格式在数据大小方面并不是最有效的，并且有许多不同的格式为开发者提供了额外的优势，包括代码生成。在本章中，我们将向您展示如何使用 Protocol
    Buffers 定义服务 API 并为它们生成客户端和服务器代码。
- en: By the end of this chapter, you will understand the key concepts of synchronous
    communication between microservices and will have learned how to implement microservice
    clients and servers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解微服务之间同步通信的关键概念，并学会如何实现微服务的客户端和服务器。
- en: 'The knowledge you gain in this chapter will help you to learn how to better
    organize the client and server code, generate the code for serialization and communication,
    and use it in your microservices. In this chapter, we will cover the following
    topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 您在本章中获得的知识将帮助您更好地组织客户端和服务器代码，生成序列化和通信的代码，并在您的微服务中使用它。在本章中，我们将涵盖以下主题：
- en: Introduction to synchronous communication
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步通信简介
- en: Defining a service API using Protocol Buffers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Protocol Buffers 定义服务 API
- en: Implementing gateways and clients
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现网关和客户端
- en: Now, let’s proceed to the main concepts of synchronous communication.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续探讨同步通信的主要概念。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete this chapter, you will need Go 1.11, a Protocol Buffers compiler
    that we installed in the previous chapter, and a gRPC plugin.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，您需要 Go 1.11、我们在上一章中安装的 Protocol Buffers 编译器以及一个 gRPC 插件。
- en: 'You can install the gRPC plugin by running the following command:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令来安装 gRPC 插件：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can find the GitHub code for this chapter at [https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter05](https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter05).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter05](https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter05)
    找到本章的 GitHub 代码。
- en: Introduction to synchronous communication
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步通信简介
- en: In this section, we are going to cover the basics of synchronous communication
    and introduce you to some additional benefits of Protocol Buffers that we are
    going to use for our microservices.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍同步通信的基础知识，并介绍我们将用于微服务的 Protocol Buffers 的额外好处。
- en: '**Synchronous communication** is the way of interaction between network applications,
    such as microservices, in which services exchange data using a **request-response
    model**. The process is illustrated in the following diagram:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**同步通信**是网络应用（如微服务）之间交互的方式，其中服务通过**请求-响应模型**交换数据。该过程在以下图中展示：'
- en: '![Figure 5.1 – Synchronous communication'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1 – 同步通信'
- en: '](img/Figure_5.1_B18865.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.1_B18865.jpg)'
- en: Figure 5.1 – Synchronous communication
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 同步通信
- en: There are many **protocols** allowing applications to communicate in this way.
    HTTP is among the most popular protocols for synchronous communication. In [*Chapter
    2*](B18865_02.xhtml#_idTextAnchor027), we already implemented the logic for calling
    and handling HTTP requests in our microservices.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多**协议**允许应用以这种方式进行通信。HTTP 是同步通信中最受欢迎的协议之一。在 [*第 2 章*](B18865_02.xhtml#_idTextAnchor027)
    中，我们已经在我们的微服务中实现了调用和处理 HTTP 请求的逻辑。
- en: 'The HTTP protocol allows you to send request and response data in different
    ways:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 协议允许您以不同的方式发送请求和响应数据：
- en: '`https://www.google.com/search?q=portugal` URL, `q=portugal` is a URL parameter.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://www.google.com/search?q=portugal` URL，`q=portugal` 是一个 URL 参数。'
- en: '`User-Agent: Mozilla/5.0`.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`User-Agent: Mozilla/5.0`.'
- en: '**Request and response body**: The request and response can include a body
    that contains arbitrary data. For example, when a client uploads a file to a server,
    the file contents are usually sent as a request body.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求和响应体**：请求和响应可以包含包含任意数据的正文。例如，当客户端将文件上传到服务器时，文件内容通常作为请求正文发送。'
- en: 'When a server cannot handle a client request due to an error or the request
    is not received due to network issues, the client receives a specific response
    indicating an error. In the case of the HTTP protocol, there are two types of
    errors:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器由于错误无法处理客户端请求，或者由于网络问题未收到请求时，客户端会收到一个特定的响应，表明发生了错误。在HTTP协议的情况下，有两种类型的错误：
- en: '**Client error**: This error is caused by the client. Examples of such errors
    include invalid request arguments (such as an incorrect username), unauthorized
    access, and access to a resource that is not found (for example, a non-existing
    web page).'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端错误**：这种错误是由客户端引起的。此类错误的例子包括无效的请求参数（例如错误的用户名）、未经授权的访问以及访问未找到的资源（例如，不存在的网页）。'
- en: '**Server error**: This error is caused by the server. This could be an application
    bug or an error with an upstream component, such as a database.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器错误**：这种错误是由服务器引起的。这可能是一个应用程序错误或上游组件（例如数据库）的错误。'
- en: 'In [*Chapter 2*](B18865_02.xhtml#_idTextAnchor027), we implemented our API
    handlers by sending the result data as an HTTP response body in JSON format. We
    achieved this by using the Go JSON encoder:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第2章*](B18865_02.xhtml#_idTextAnchor027)中，我们通过将结果数据作为JSON格式的HTTP响应体发送来实现我们的API处理器。我们通过使用Go
    JSON编码器实现了这一点：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As discussed in the previous chapter, the JSON format is not the most optimal
    in terms of data size. Also, it does not offer useful tools, such as the cross-language
    code generation of data structures, that are provided by the formats, such as
    Protocol Buffers. Additionally, sending requests over HTTP and encoding the data
    manually is not the only form of communication between the services. There are
    some existing **remote procedure call** (**RPC**) libraries and frameworks that
    help to communicate between multiple services and offer some additional features
    to application developers:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，JSON格式在数据大小方面并不是最优的。此外，它不提供有用的工具，例如由Protocol Buffers等格式提供的数据结构的跨语言代码生成工具。此外，通过HTTP发送请求并手动编码数据不是服务之间通信的唯一形式。有一些现有的**远程过程调用**（RPC）库和框架有助于在多个服务之间进行通信，并为应用程序开发者提供一些附加功能：
- en: '**Client and server code generation**: Developers can generate the client code
    for connecting and sending data to other microservices, as well as generate the
    server code for accepting incoming requests.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端和服务器代码生成**：开发者可以生成连接到其他微服务并发送数据的客户端代码，以及生成接受传入请求的服务器代码。'
- en: '**Authentification**: Most RPC libraries and frameworks offer authentication
    options for cross-service requests, such as TLS-based and token-based authentication.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证**：大多数RPC库和框架为跨服务请求提供认证选项，例如基于TLS和基于令牌的认证。'
- en: '**Context propagation**: This is the ability to send additional data with requests,
    such as traces, which we are going to cover in [*Chapter 11*](B18865_11.xhtml#_idTextAnchor152).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文传播**：这是在请求中发送附加数据的能力，例如跟踪，我们将在[*第11章*](B18865_11.xhtml#_idTextAnchor152)中介绍。'
- en: '**Documentation generation**: Thrift can generate HTML documentation for services
    and data structures.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档生成**：Thrift可以为服务和数据结构生成HTML文档。'
- en: In the next section, we are going to cover some of the RPC libraries that you
    can use in your Go services, along with the features they provide.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍一些您可以在Go服务中使用并了解它们提供的功能的RPC库。
- en: Go RPC frameworks and libraries
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go RPC框架和库
- en: Let’s review some popular RPC frameworks and libraries that are available for
    Go developers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一些适用于Go开发者的流行RPC框架和库。
- en: Apache Thrift
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Apache Thrift
- en: 'We already covered Apache Thrift in [*Chapter 4*](B18865_04.xhtml#_idTextAnchor067)
    and mentioned its ability to define RPC services – sets of functions provided
    by an application, such as a microservice. Here is an example of a Thrift RPC
    service definition:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第4章*](B18865_04.xhtml#_idTextAnchor067)中介绍了Apache Thrift，并提到了其定义RPC服务的能力——由应用程序提供的一组函数，例如微服务。以下是一个Thrift
    RPC服务定义的示例：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The Thrift definition of a service can be used to generate client and server
    code. The client code would include the logic for connecting to an instance of
    a service, as well as making requests to it, serializing and deserializing the
    request and response structures. The advantage of using a library such as Apache
    Thrift over making HTTP requests manually is the ability to generate such code
    for multiple languages: a service written in Go could easily talk to a service
    written in Java, while both would use the generated code for the communication,
    removing the need of implementing serialization/deserialization logic. Additionally,
    Thrift allows us to generate the documentation for RPC services.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的 Thrift 定义可以用来生成客户端和服务器代码。客户端代码将包括连接到服务实例的逻辑，以及向其发送请求、序列化和反序列化请求和响应结构。使用如
    Apache Thrift 这样的库而不是手动进行 HTTP 请求的优势是能够为多种语言生成这样的代码：用 Go 编写的服务可以轻松与用 Java 编写的服务通信，而两者都将使用生成的代码进行通信，从而消除了实现序列化/反序列化逻辑的需求。此外，Thrift
    允许我们为 RPC 服务生成文档。
- en: gRPC
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: gRPC
- en: '**gRPC** is an RPC framework that was created at Google. gRPC uses HTTP/2 as
    the transport protocol and Protocol Buffers as a serialization format. Similar
    to Apache Thrift, it provides an ability to define RPC services and generate the
    client and server code for the services. In addition to this, it offers some extra
    features, such as the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**gRPC** 是由 Google 创建的一个 RPC 框架。gRPC 使用 HTTP/2 作为传输协议，并使用 Protocol Buffers
    作为序列化格式。类似于 Apache Thrift，它提供了定义 RPC 服务并生成服务客户端和服务器代码的能力。除此之外，它还提供了一些额外功能，例如以下内容：'
- en: Authentication
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证
- en: Context propagation
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文传播
- en: Documentation generation
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档生成
- en: gRPC adoption is much higher than for Apache Thrift, and its support of the
    popular Protocol Buffers format makes it a great fit for microservice developers.
    In this book, we are going to use gRPC as a framework for synchronous communication
    between our microservices. In the next section, we are going to illustrate how
    to leverage the features provided by Protocol Buffers to define our service APIs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 的采用率比 Apache Thrift 高得多，它对流行的 Protocol Buffers 格式的支持使其非常适合微服务开发者。在本章中，我们将使用
    gRPC 作为我们微服务之间同步通信的框架。在下一节中，我们将展示如何利用 Protocol Buffers 提供的功能来定义我们的服务 API。
- en: Defining a service API using Protocol Buffers
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Protocol Buffers 定义服务 API
- en: Let’s demonstrate how to define a service API using the Protocol Buffers format
    and generate the client and server gRPC code for communication with each of our
    services using a **proto** compiler. This knowledge will help you to establish
    a foundation for both defining and implementing APIs for your microservices using
    one of the industry’s most popular communication tools.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们演示如何使用 Protocol Buffers 格式定义服务 API，并使用 **proto** 编译器为与我们的每个服务进行通信生成客户端和服务器
    gRPC 代码。这些知识将帮助您为使用行业中最受欢迎的通信工具之一，为您的微服务定义和实现 API 建立基础。
- en: Let’s start with our metadata service and write its API definition in the Protocol
    Buffers schema language.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的元数据服务开始，并使用 Protocol Buffers 模式语言编写其 API 定义。
- en: 'Open the `api/movie.proto` file that we created in the previous chapter and
    add the following to it:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 打开我们在上一章中创建的 `api/movie.proto` 文件，并向其中添加以下内容：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code we just added defines our metadata service and its `GetMetadata` endpoint.
    We already have the `Metadata` structure from the previous chapter that we can
    reuse now.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加的代码定义了我们的元数据服务和其 `GetMetadata` 端点。我们现在已经有了上一章中的 `Metadata` 结构，现在可以重用它。
- en: 'Let’s note some aspects of the code we just added:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们注意我们刚刚添加的代码的一些方面：
- en: '`GetMetadataRequest` and `GetMetadataResponse`.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetMetadataRequest` 和 `GetMetadataResponse`。'
- en: '**Naming**: You should follow consistent naming rules for all your endpoints.
    We are going to prefix all request and response functions with the function name.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名规范**：您应该为所有端点遵循一致的命名规则。我们将使用函数名作为所有请求和响应函数的前缀。'
- en: 'Now, let’s add the definition of the rating service to the same file:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将评分服务的定义添加到同一个文件中：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our rating service has two endpoints, and we defined requests and responses
    for them in a similar way to the metadata service.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务评分有两个端点，我们以与元数据服务类似的方式定义了它们的请求和响应。
- en: 'Finally, let’s add the definition of the movie service to the same file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将电影服务的定义添加到同一个文件中：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now our `movie.proto` file includes both our structure definitions and the
    API definitions for our services. We are ready to generate code for the newly
    added service definitions. In the `src` directory of the application, run the
    following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的 `movie.proto` 文件包括了我们的结构定义和服务的 API 定义。我们准备好为新添加的服务定义生成代码。在应用程序的 `src`
    目录中运行以下命令：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding command is similar to the command that we used in the previous
    chapter for generating code for our data structures. However, it also passes a
    `--go-grpc_out` flag to the compiler. This flag tells the Protocol Buffers compiler
    to generate the service code in gRPC format.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令与我们之前用于生成数据结构代码的命令类似。然而，它还向编译器传递了一个 `--go-grpc_out` 标志。此标志告诉 Protocol Buffers
    编译器以 gRPC 格式生成服务代码。
- en: 'Let’s see the compiled code that was generated as the output for our command.
    If the command is executed without any errors, you will find a `movie_grpc.pb.go`
    file inside the `src/gen` directory. The file will include the generated Go code
    for our services. Let’s take a look at the generated client code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的命令生成的输出编译后的代码。如果命令执行没有错误，你将在 `src/gen` 目录下找到一个 `movie_grpc.pb.go` 文件。该文件将包含为我们服务生成的
    Go 代码。让我们看看生成的客户端代码：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This generated code can be used in our applications to call our API from the
    Go applications. Additionally, we can generate such client code for other languages,
    such as Java, adding more arguments to the compiler command that we just executed.
    This is a great feature that can save us lots of time when writing microservice
    applications – instead of writing client logic for calling our services, we can
    use the generated clients and plug them into our applications.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成的代码可以用于我们的应用程序中，从 Go 应用程序调用我们的 API。此外，我们可以为其他语言，如 Java，生成这样的客户端代码，向编译器命令中添加更多参数。这是一个可以节省我们大量时间的出色功能——在编写微服务应用程序时，我们不必编写调用我们服务的客户端逻辑，而可以使用生成的客户端并将它们插入到我们的应用程序中。
- en: 'In addition to the client code, the Protocol Buffers compiler also generates
    the service code that can be used for handling the requests. In the same `movie_grpc.pb.go`
    file, you will find the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 除了客户端代码外，Protocol Buffers 编译器还生成了可以用于处理请求的服务代码。在同一个 `movie_grpc.pb.go` 文件中，你会找到以下内容：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We are going to use both the client and server code that we just saw in our
    application. In the next section, we are going to modify our API handlers to use
    the generated code and handle requests using the Protocol Buffers format.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的应用程序中使用我们刚刚看到的客户端和服务器代码。在下一节中，我们将修改我们的 API 处理程序以使用生成的代码，并使用 Protocol
    Buffers 格式处理请求。
- en: Implementing gateways and clients
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现网关和客户端
- en: In this section, we are going to illustrate how to plug the generated client
    and server gRPC code into our microservices. This will help us to switch communication
    between them from JSON-serialized HTTP to Protocol Buffers gRPC calls.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将说明如何将生成的客户端和服务器 gRPC 代码插入到我们的微服务中。这将帮助我们切换它们之间的通信，从 JSON 序列化的 HTTP 到
    Protocol Buffers gRPC 调用。
- en: Metadata service
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元数据服务
- en: In [*Chapter 2*](B18865_02.xhtml#_idTextAnchor027), we created our internal
    model structures, such as metadata, and in [*Chapter 4*](B18865_04.xhtml#_idTextAnchor067),
    we created their Protocol Buffers counterparts. Then, we generated the code for
    our Protocol Buffers definitions. As a result, we have two versions of our model
    structures – internal ones, as defined in `metadata/pkg/model`, and the generated
    ones, which are located in the `gen` package.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](B18865_02.xhtml#_idTextAnchor027)中，我们创建了我们的内部模型结构，例如元数据，而在[*第四章*](B18865_04.xhtml#_idTextAnchor067)中，我们创建了它们的
    Protocol Buffers 对应版本。然后，我们为我们的 Protocol Buffers 定义生成了代码。结果，我们有了我们模型结构的两个版本——内部版本，定义在
    `metadata/pkg/model` 中，以及生成的版本，位于 `gen` 包中。
- en: 'You might think that having two similar structures is now redundant. While
    there is certainly some level of redundancy in having such duplicate definitions,
    these structures practically serve different purposes:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为现在有两个类似的结构是多余的。虽然确实存在一定程度的冗余，因为这些重复定义，但这些结构实际上服务于不同的目的：
- en: '**Internal model**: The structures that you create manually for your application
    should be used across its code base, such as the repository, controller, and other
    logic.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部模型**：您为应用程序手动创建的结构应在其代码库中跨用，例如存储库、控制器和其他逻辑。'
- en: '**Generated model**: Structures generated by tools such as the protoc compiler,
    which we used in the last two chapters, should only be used for serialization.
    The use cases include transferring the data between the services or storing the
    serialized data.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成的模型**：由像protoc编译器这样的工具生成的结构，我们在前两章中使用过，应仅用于序列化。用例包括在服务之间传输数据或存储序列化数据。'
- en: 'You might be curious why it’s not recommended to use the generated structures
    across the application code base. There are multiple reasons for this, which are
    listed as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能好奇为什么不建议在应用程序代码库中使用生成的结构。这里有多个原因，如下列所示：
- en: '**Unnecessary coupling between the application and serialization format**:
    If you ever want to switch from one serialization format to another (for example,
    from Thrift to Protocol Buffers), and all your application code base uses generated
    structures for the previous serialization format, you would need to rewrite not
    only the serialization code but the entire application.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序和序列化格式之间的不必要耦合**：如果你想要从一种序列化格式切换到另一种格式（例如，从Thrift切换到Protocol Buffers），并且你的所有应用程序代码库都使用为先前序列化格式生成的结构，那么你需要重写不仅序列化代码，而且整个应用程序。'
- en: '**Generated code structure could vary between different versions**: While the
    field naming and high-level structure of the generated structures are generally
    stable between different versions of code generation tooling, the internal functions
    and structure of the generated code could vary from version to version. If any
    part of your application uses some generated functions that get changed, your
    application could break unexpectedly during a version update of a code generator.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成的代码结构可能在不同版本之间有所不同**：虽然生成的结构的字段命名和高级结构在代码生成工具的不同版本之间通常是稳定的，但生成的代码的内部函数和结构可能从版本到版本有所不同。如果你的应用程序的任何部分使用了一些在代码生成器版本更新期间发生变化的生成函数，那么在代码生成器版本更新期间，你的应用程序可能会意外地崩溃。'
- en: '**Generated code is often harder to use**: In formats such as Protocol Buffers,
    all fields are always optional. In generated code, this results in lots of fields
    that can have nil values. For an application developer, this means doing more
    nil checks across all applications to prevent possible panics.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成的代码通常更难使用**：在如Protocol Buffers这样的格式中，所有字段始终是可选的。在生成的代码中，这导致了许多可以具有nil值的字段。对于应用程序开发者来说，这意味着需要在所有应用程序中进行更多的nil检查，以防止可能的panic。'
- en: Because of these reasons, the best practice is to keep both internal structures
    and the generated ones and only use the generated structures for serialization.
    Let’s illustrate how to achieve this.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，最佳实践是保留内部结构和生成的结构，并且仅使用生成的结构进行序列化。让我们通过以下示例说明如何实现这一点。
- en: 'We would need to add some `metadata/pkg/model` directory, create a `mapper.go`
    file and add the following to it:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加一些`metadata/pkg/model`目录，创建一个`mapper.go`文件，并将其内容添加如下：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The code we just added transforms the internal model into the generated structures
    and back. In the following code block, we are going to use it in the server code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加的代码将内部模型转换为生成的结构，然后再转换回来。在以下代码块中，我们将在服务器代码中使用它。
- en: 'Now, let’s implement a gRPC handler for the metadata service that would handle
    the client requests to the service. In the `metadata/internal/handler` package,
    create a `grpc` directory and add a `grpc.go` file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现一个处理元数据服务的gRPC处理器，该处理器将处理对服务的客户端请求。在`metadata/internal/handler`包中，创建一个`grpc`目录并添加一个`grpc.go`文件：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s implement the `GetMetadataByID` function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现`GetMetadataByID`函数：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s highlight some parts of this implementation:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们突出显示实现中的某些部分：
- en: The handler embeds the generated `gen.UnimplementedMetadataServiceServer` structure.
    This is required by a Protocol Buffers compiler to enforce future compatibility.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器嵌入生成的`gen.UnimplementedMetadataServiceServer`结构。这是由Protocol Buffers编译器强制执行未来兼容性所必需的。
- en: Our handler implements the `GetMetadata` function in exactly the same format
    as defined in the generated `MetadataServiceServer` interface.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的处理器以与生成的`MetadataServiceServer`接口中定义的完全相同的格式实现了`GetMetadata`函数。
- en: We are using the `MetadataToProto` mapping function to transform our internal
    structures into the generated ones.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在使用`MetadataToProto`映射函数将我们的内部结构转换为生成的结构。
- en: 'Now we are ready to update our main file and switch it to the gRPC handler.
    Update the `metadata/cmd/main.go` file, changing its contents to the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好更新主文件并将其切换到gRPC处理器。更新`metadata/cmd/main.go`文件，更改其内容如下：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The updated `main` function illustrates how we instantiate our gRPC server and
    start listening for requests in it. The rest of the function is similar to the
    one we had before.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的`main`函数说明了我们如何实例化我们的gRPC服务器并在其中监听请求。函数的其余部分与之前类似。
- en: We are done with the changes to the metadata service and can now proceed to
    the rating service.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了对元数据服务的更改，现在可以继续进行评分服务的开发。
- en: Rating service
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评分服务
- en: 'Let’s create a gRPC handler for the rating service. In the `rating/internal/handler`
    package, create a `grpc` directory and add a `grpc.go` file with the following
    code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为评分服务创建一个gRPC处理器。在`rating/internal/handler`包中创建一个`grpc`目录，并向其中添加一个包含以下代码的`grpc.go`文件：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let’s implement the `GetAggregatedRating` endpoint:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现`GetAggregatedRating`端点：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, let’s implement the `PutRating` endpoint:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们实现`PutRating`端点：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we are ready to update our `rating/cmd/main.go` file. Replace it with
    the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好更新我们的`rating/cmd/main.go`文件。用以下内容替换它：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The way we start the service is similar to the metadata service. Now, we are
    ready to link the movie service to both the metadata and rating services.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动服务的方式与元数据服务类似。现在，我们准备好将电影服务链接到元数据和评分服务。
- en: Movie service
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电影服务
- en: In the previous examples, we created gRPC servers to handle client requests.
    Now, let’s illustrate how to add logic for calling our servers. This will help
    us to establish communication between our microservices via gRPC.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了gRPC服务器来处理客户端请求。现在，让我们说明如何添加调用我们的服务器的逻辑。这将帮助我们通过gRPC在我们的微服务之间建立通信。
- en: 'First, let’s implement a function that we can reuse in our service gateways.
    Create the `src/internal/grpcutil` directory, and add a file called `grpcutil.go`
    to it. Add the following code to it:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们实现一个可以在我们的服务网关中重用的函数。创建`src/internal/grpcutil`目录，并向其中添加一个名为`grpcutil.go`的文件。向其中添加以下代码：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The function that we just implemented will try to pick a random instance of
    the target service using the provided service registry, and then it will create
    a gRPC connection for it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚实现的函数将尝试使用提供的服务注册表随机选择目标服务的一个实例，然后为它创建一个gRPC连接。
- en: 'Now, let’s create a gateway for our metadata service. In the `movie/internal/gateway`
    package, create a directory called `metadata`. Inside it, create a `grpc` directory
    with a `metadata.go` file, containing the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的元数据服务创建一个网关。在`movie/internal/gateway`包中，创建一个名为`metadata`的目录。在其内部，创建一个名为`grpc`的目录，并添加一个`metadata.go`文件，其中包含以下代码：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let’s implement the function for getting the metadata from a remote gRPC service:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现从远程gRPC服务获取元数据的函数：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s highlight some details of our gateway implementation:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们突出显示我们网关实现的一些细节：
- en: We use the `grpcutil.ServiceConnection` function to create a connection to our
    metadata service.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`grpcutil.ServiceConnection`函数创建到我们的元数据服务的连接。
- en: We create a client using the generated client code from the `gen` package.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用来自`gen`包生成的客户端代码创建一个客户端。
- en: We use the `MetadataFromProto` mapping function to convert the generated structures
    into internal ones.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`MetadataFromProto`映射函数将生成的结构转换为内部结构。
- en: 'Now we are ready to create a gateway for our rating service. Inside the `movie/internal/gateway`
    package, create a `rating/grpc` directory and add a `grpc.go` file with the following
    contents:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好为我们的评分服务创建一个网关。在`movie/internal/gateway`包内，创建一个`rating/grpc`目录，并向其中添加一个包含以下内容的`grpc.go`文件：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add the implementation of the `GetAggregatedRating` function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`GetAggregatedRating`函数的实现：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'At this point, we are almost done with the changes. The last step is to update
    the `main` function of the movie service. Change it to the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了大部分更改。最后一步是更新电影服务的`main`函数。将其更改为以下内容：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You might have noticed that the format hasn’t changed, and we just updated the
    imports for our gateways, changing them from HTTP to gRPC.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到格式没有改变，我们只是更新了网关的导入，将它们从HTTP更改为gRPC。
- en: We are done with the changes to our services. Now the services can communicate
    with each other using the Protocol Buffers serialization, and you can run them
    using the `go run *.go` command inside each `cmd` directory.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了对服务的更改。现在，服务可以使用Protocol Buffers序列化相互通信，并且您可以在每个`cmd`目录内使用`go run *.go`命令运行它们。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the basics of synchronous communication and learned
    how to make microservices communicate with each other using the Protocol Buffers
    format. We illustrated how to define our service APIs using the Protocol Buffers
    schema language and generate code that can be reused in microservice applications
    written in Go and other languages.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了同步通信的基础，并学习了如何使用 Protocol Buffers 格式使微服务相互通信。我们展示了如何使用 Protocol Buffers
    架构语言定义我们的服务 API，并生成可在用 Go 和其他语言编写的微服务应用程序中重用的代码。
- en: The knowledge you gained in this chapter should help you write and maintain
    the existing services using Protocol Buffers and gRPC. It also serves as an example
    of how to use code generation for your services. In the next chapter, we are going
    to continue our journey into different ways of communication by covering another
    model, asynchronous communication.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所获得的知识应有助于您使用 Protocol Buffers 和 gRPC 编写和维护现有服务。它还作为了如何为您的服务使用代码生成的一个示例。在下一章中，我们将继续探索不同的通信方式，通过介绍另一个模型，即异步通信。
- en: Further reading
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*gRPC*: [https://grpc.io](https://grpc.io)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*gRPC*: [https://grpc.io](https://grpc.io)'
- en: '*HTTP/2 detailed overview*: [https://web.dev/performance-http2](https://web.dev/performance-http2)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*HTTP/2 详细概述*: [https://web.dev/performance-http2](https://web.dev/performance-http2)'
