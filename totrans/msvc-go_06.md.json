["```go\n[{\"userId\":\"105\",\"recordId\":\"1\",\"recordType\":1,\"value\":5,\"providerId\":\"test-provider\",\"eventType\":\"put\"},{\"userId\":\"105\",\"recordId\":\"2\",\"recordType\":1,\"value\":4,\"providerId\":\"test-provider\",\"eventType\":\"put\"}]\n```", "```go\n// RatingEvent defines an event containing rating information.\ntype RatingEvent struct {\n    UserID     UserID      `json:\"userId\"`\n    RecordID   RecordID    `json:\"recordId\"`\n    RecordType RecordType  `json:\"recordType\"`\n    Value      RatingValue `json:\"value\"`\n    EventType  RatingEventType `json:\"eventType\"`\n}\n// RatingEventType defines the type of a rating event.\ntype RatingEventType string\n// Rating event types.\nconst (\n    RatingEventTypePut    = \"put\"\n    RatingEventTypeDelete = \"delete\"\n)\n```", "```go\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n    \"time\"\n\n    \"github.com/confluentinc/confluent-kafka-go/kafka\"\n    \"movieexample.com/rating/pkg/model\"\n)\n\nfunc main() {\n    fmt.Println(\"Creating a Kafka producer\")\n\n    producer, err := kafka.NewProducer(&kafka.ConfigMap{\"bootstrap.servers\": \"localhost\"})\n    if err != nil {\n        panic(err)\n    }\n    defer producer.Close()\n\n    const fileName = \"ratingsdata.json\"\n    fmt.Println(\"Reading rating events from file \" + fileName)\n\n    ratingEvents, err := readRatingEvents(fileName)\n    if err != nil {\n        panic(err)\n    }\n\n    const topic = \"ratings\"\n    if err := produceRatingEvents(topic, producer, ratingEvents); err != nil {\n        panic(err)\n    }\n\n    const timeout = 10 * time.Second\n    fmt.Println(\"Waiting \" + timeout.String() + \" until all events get produced\")\n\n    producer.Flush(int(timeout.Milliseconds()))\n}\n```", "```go\nfunc readRatingEvents(fileName string) ([]model.RatingEvent, error) {\n    f, err := os.Open(fileName)\n    if err != nil {\n        return nil, err\n    }\n    defer f.Close()\n    var ratings []model.RatingEvent\n    if err := json.NewDecoder(f).Decode(&ratings); err != nil {\n        return nil, err\n    }\n    return ratings, nil\n}\n```", "```go\nfunc produceRatingEvents(topic string, producer kafka.Producer, events []model.RatingEvent) error {\n    for _, ratingEvent := range ratingEvents {\n        encodedEvent, err := json.Marshal(ratingEvent)\n    if err != nil {\n        return err\n    }\n\n    if err := p.Produce(&kafka.Message{\nTopicPartition: kafka.TopicPartition{Topic: &topic, Partition: kafka.PartitionAny},\nValue:          []byte(encodedEvent),\n}, nil); err != nil {\n        return err\n    }\n    return nil\n}\n```", "```go\ngo mod tidy\n```", "```go\n[{\"userId\":\"105\",\"recordId\":\"1\",\"recordType\":1,\"value\":5,\"providerId\":\"test-provider\",\"eventType\":\"put\"},{\"userId\":\"105\",\"recordId\":\"2\",\"recordType\":1,\"value\":4,\"providerId\":\"test-provider\",\"eventType\":\"put\"}]\n```", "```go\npackage kafka\n\nimport (\n    \"context\"\n    \"encoding/json\"\n    \"fmt\"\n    \"rating/pkg/model\"\n\n    \"github.com/confluentinc/confluent-kafka-go/kafka\"\n    \"movieexample.com/rating/pkg/model\"\n)\n\n// Ingester defines a Kafka ingester.\ntype Ingester struct {\n    consumer kafka.Consumer\n    topic    string\n}\n\n// NewIngester creates a new Kafka ingester.\nfunc NewIngester(addr string, groupID string, topic string) (*Ingester, error) {\n    consumer, err := kafka.NewConsumer(&kafka.ConfigMap{\n        \"bootstrap.servers\": addr,\n        \"group.id\":          groupID,\n        \"auto.offset.reset\": \"earliest\",\n    })\n    if err != nil {\n        return nil, err\n    }\n    return &Ingester{consumer, topic}, nil\n}\n```", "```go\n// Ingest starts ingestion from Kafka and returns a channel // containing rating events\n// representing the data consumed from the topic.\nfunc (i *Ingester) Ingest(ctx context.Context) (chan model.RatingEvent, error) {\n    if err := i.consumer.SubscribeTopics([]string{i.topic}, nil); err != nil {\n        return nil, err\n    }\n\n    ch := make(chan model.RatingEvent, 1)\n    go func() {\n        for {\n            select {\n            case <-ctx.Done():\n                close(ch)\n                i.consumer.Close()\n            default:\n        }\n        msg, err := i.consumer.ReadMessage(-1)\n        if err != nil {\n            fmt.Println(\"Consumer error: \" + err.Error())\n            continue\n        }\n        var event model.RatingEvent\n        if err := json.Unmarshal(msg.Value, &event); err != nil { \n            fmt.Println(\"Unmarshal error: \" + err.Error())\n            continue\n        }\n        ch <- event\n        }\n    }()\n    return ch, nil\n}\n```", "```go\ntype ratingIngester interface {\n    Ingest(ctx context.Context) (chan model.RatingEvent, error)\n} \n// StartIngestion starts the ingestion of rating events.\nfunc (s *RatingService) StartIngestion(ctx context.Context) error {\n    ch, err := s.ingester.Ingest(ctx)\n    if err != nil {\n        return err\n    }\n    for e := range ch {\n        if err := s.PutRating(ctx, e.RecordID, e.RecordType, &model.Rating{UserID: e.UserID, Value: e.Value}); err != nil {\n            return err\n        }\n    }\n    return nil\n}\n```", "```go\n// RatingService encapsulates the rating service business \n// logic.\ntype RatingService struct {\n    repo     ratingRepository\n    ingester ratingIngester\n}\n\n// New creates a rating service.\nfunc New(repo ratingRepository, ingester ratingIngester) *RatingService {\n    return &RatingService{repo, ingester}\n}\n```", "```go\n{\"recordID\": \"1\", \"rating\": 5}\n{\"recordID\": \"2\", \"rating\": 17, \"userId\": \"alex\"}\n```", "```go\n{\"recordID\": \"1\", \"rating\": 5, \"version\": 1}\n{\"recordID\": \"2\", \"rating\": 17, \"userId\": \"alex\", \"version\": 2}\n```", "```go\nif err := p.Produce(&kafka.Message{\nTopicPartition: kafka.TopicPartition{Topic: &topic, Partition: kafka.PartitionAny},\nValue:          []byte(encodedEvent),\n}, nil); err != nil {\n    return err\n}\n```"]