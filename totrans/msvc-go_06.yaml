- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Asynchronous Communication
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步通信
- en: In the previous chapter, we illustrated how services can communicate with each
    other using a synchronous request-response model. There are other communication
    models that provide various benefits to the application developer, such as asynchronous
    communication, which we are going to cover in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们展示了服务如何使用同步请求-响应模型相互通信。还有其他通信模型可以为应用开发者提供各种好处，例如异步通信，我们将在本章中介绍。
- en: In this chapter, you are going to learn the basics of asynchronous communication
    and some common techniques for using it, as well as some benefits and challenges
    it brings to microservice developers. We will cover a popular piece of asynchronous
    communication software, Apache Kafka, and illustrate how to use it for establishing
    communication between our microservices.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习异步通信的基础和一些使用它的常见技术，以及它给微服务开发者带来的好处和挑战。我们将介绍一种流行的异步通信软件Apache Kafka，并说明如何使用它来建立微服务之间的通信。
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Asynchronous communication basics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步通信基础
- en: Using Apache Kafka for messaging
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Apache Kafka进行消息传递
- en: Asynchronous communication best practices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步通信的最佳实践
- en: Let’s proceed to the basics of asynchronous communication.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探讨异步通信的基础。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete this chapter, you need Go 1.11+ or above, similar to the previous
    chapters.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章，您需要Go 1.11或更高版本，类似于前几章。
- en: 'You can find the GitHub code for this chapter here: [https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter06](https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter06)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章的GitHub代码：[https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter06](https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter06)
- en: Asynchronous communication basics
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步通信基础
- en: In this section, we are going to cover some theoretical aspects of asynchronous
    communication. You will learn the benefits and the common issues of an asynchronous
    communication model, and the common ways of using it, as well as getting some
    real-world examples of asynchronous communication.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论异步通信的一些理论方面。您将了解异步通信模型的好处和常见问题，以及常见的使用方式，以及一些异步通信的实例。
- en: Asynchronous communication is communication between a sender and one or multiple
    receivers, where a sender does not necessarily expect an immediate response to
    their messages. In the synchronous communication model, which we covered in [*Chapter
    5*](B18865_05.xhtml#_idTextAnchor076), the caller sending the request would expect
    an immediate (or nearly immediate, taking into account network latency) response
    to it. In asynchronous communication, it may take an arbitrary amount of time
    for the receiver to respond to the request, or to not respond at all (for example,
    when receiving a no-reply notification).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 异步通信是发送者和一个或多个接收者之间的通信，其中发送者并不一定期望立即收到对他们的消息的回复。在我们在[*第五章*](B18865_05.xhtml#_idTextAnchor076)中讨论的同步通信模型中，发送请求的调用者会期望立即（或几乎是立即，考虑到网络延迟）收到对请求的响应。在异步通信中，接收者对请求的回复可能需要任意长的时间，或者根本不回复（例如，在收到无回复通知时）。
- en: We can illustrate the differences between the two models using two examples.
    An example of synchronous communication is a phone call – two people having a
    phone conversation are in direct and immediate communication with each other,
    and they expect to hear the responses in real time. An example of asynchronous
    communication is sending mail to people. It can take time to respond to such mail,
    and the sender does not expect an immediate response to their messages.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两个例子来说明这两种模型之间的区别。同步通信的一个例子是电话通话——两个进行电话交谈的人直接并且立即相互通信，并且他们期望实时听到对方的回复。异步通信的一个例子是给人们发送邮件。回复这样的邮件可能需要时间，发送者并不期望立即收到对他们的消息的回复。
- en: 'It does not mean, however, that asynchronous communication is necessarily slower
    than the synchronous model. In most cases, asynchronous processing is as quick
    as synchronous processing and often can be even faster: asynchronous processing
    is often much less interruptive and leads to higher processing efficiency. It’s
    like replying to 10 emails, one by one, compared to switching between 10 parallel
    phone calls — the latter example of synchronous processing can sometimes be way
    slower due to context switching and frequent interruptions.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不意味着异步通信必然比同步模型慢。在大多数情况下，异步处理与同步处理一样快，有时甚至更快：异步处理通常中断较少，导致更高的处理效率。这就像逐个回复10封电子邮件，而不是在10个并行电话之间切换——后者是同步处理的例子，有时可能因为上下文切换和频繁的中断而变得非常慢。
- en: Benefits and challenges of asynchronous communication
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步通信的优缺点
- en: 'The asynchronous communication model comes with its own benefits and challenges.
    Developers need to consider both in order to make a decision on whether to use
    this model. What are the benefits of using asynchronous communication? Let’s find
    out:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 异步通信模型有其自身的优点和挑战。开发者需要考虑这两者，以便决定是否使用这种模型。使用异步通信有哪些好处？让我们来了解一下：
- en: The first benefit is a more streamlined approach to processing messages. Imagine
    you have a service whose purpose is to process data and report the status to another
    service. The reporting service does not necessarily need to wait for any response
    back from the service it is reporting to, as it would do in the synchronous model.
    In asynchronous mode, it just needs confirmation that the status message was sent
    successfully. This is similar to sending a large number of postcards to your relatives
    – if you send a dozen postcards, you don’t want to wait until each card gets delivered
    before sending the next one!
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个好处是处理消息的更流畅的方法。想象一下，你有一个服务，其目的是处理数据并向另一个服务报告状态。报告服务不需要等待它所报告的服务返回任何响应，就像在同步模型中那样。在异步模式下，它只需要确认状态消息已成功发送。这就像给亲戚寄大量的明信片——如果你寄了十几张明信片，你不想在寄下一张之前等待每张明信片送达！
- en: The second benefit of an asynchronous communication model is the ability to
    de-couple the sending and processing of requests. Imagine a caller requesting
    to download a large video and a remote server that needs to perform such a task.
    In a synchronous model, the caller would be waiting in real time until the entire
    video is processed. This could easily take minutes and sometimes even hours, making
    such waiting very inefficient. Instead, such a task could be performed in an asynchronous
    way, where the caller would send the task to a server, get an acknowledgment that
    the task was received, and perform any other activity until an eventual notification
    of completion (or processing failure) is received.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步通信模型的第二个好处是能够解耦请求的发送和处理。想象一下，一个呼叫者请求下载一个大视频，而远程服务器需要执行这样的任务。在同步模型中，呼叫者将实时等待整个视频处理完毕。这可能会花费几分钟甚至几个小时，使得这种等待非常低效。相反，这样的任务可以通过异步方式执行，其中呼叫者将任务发送到服务器，收到任务已接收的确认，然后执行任何其他活动，直到最终收到完成通知（或处理失败通知）。
- en: The third benefit of asynchronous communication is better load balancing. Certain
    applications can have uneven request loads and are prone to sudden spikes of requests.
    If communication is synchronous, the server needs to answer every request in real
    time, and this can easily overload it. Imagine a waiter in a restaurant receiving
    a thousand dinner orders – such a high number of requests would completely overwhelm
    the worker, and also affect the clients.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步通信的第三个好处是更好的负载均衡。某些应用程序可能存在不均匀的请求负载，并且容易发生请求的突然激增。如果通信是同步的，服务器需要实时回答每个请求，这很容易导致服务器过载。想象一下，一位餐厅服务员接到一千份晚餐订单——如此高的请求量将完全压垮工作人员，并影响客户。
- en: 'The benefits that we just described are quite significant, and in many cases,
    asynchronous communication is the only way to perform certain types of tasks or
    to provide better system performance. Examples of problems for which asynchronous
    communication is a good fit include the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才描述的好处相当显著，在许多情况下，异步通信是执行某些类型任务或提供更好系统性能的唯一方式。以下是一些适合异步通信的问题示例：
- en: '**Long-running processing tasks**: Long-running tasks, such as video processing,
    are often better done asynchronously. The caller requesting such processing would
    not necessarily need to wait until it is completed and would eventually get notified
    of the final result.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长时间运行的处理任务**：长时间运行的任务，如视频处理，通常更适合异步执行。请求此类处理的调用者不一定需要等待其完成，最终会收到最终结果的通知。'
- en: '**Send once, processed by multiple components**: Certain types of messages,
    such as status reports, can be processed by multiple independent components. Imagine
    a system where multiple employees need to receive the same message – instead of
    sending it to each one independently, the message can get published to a component
    that can be consumed by everyone interested.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一次发送，由多个组件处理**：某些类型的消息，如状态报告，可以由多个独立组件处理。想象一个系统，其中多个员工需要接收相同的信息——而不是独立地给每个人发送，消息可以发布到一个可以被所有感兴趣的人消费的组件。'
- en: '**High-performance sequential processing**: Certain types of operations are
    more efficient when performed sequentially and/or in batches. For example, some
    operations, such as writes to HDD are often more performant when done sequentially
    (an example would be writing a very large file sequentially, without any interruptions).
    For such scenarios, asynchronous processing offers great performance improvements
    compared to more interactive and interruptive synchronous communication because
    the receiver of such requests can control the processing speed and process tasks
    one after another.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高性能顺序处理**：某些类型的操作在顺序执行和/或批量执行时更为高效。例如，某些操作，如对硬盘的写入，通常在顺序执行时性能更佳（例如，顺序写入一个非常大的文件，没有任何中断）。在这种情况下，与更互动和中断的同步通信相比，异步处理提供了巨大的性能提升，因为请求的接收者可以控制处理速度并依次处理任务。'
- en: 'While the described benefits of asynchronous communication may seem appealing,
    it is important to note that it often brings some difficult challenges to developers:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然异步通信的描述性好处可能看起来很有吸引力，但重要的是要注意，它通常会给开发者带来一些难以克服的挑战：
- en: '**More complex error handling**: Imagine sending a message to your friend and
    not receiving a response back. Was it because the friend did not receive the message?
    Did something happen during this time? Did the response get lost? In synchronous
    communication, such as a phone call, we would immediately know if the friend is
    not available and would be able to call back. In the case of an asynchronous scenario,
    we would need to think about more possible issues, such as the ones we described.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更复杂的错误处理**：想象一下你给朋友发了一条消息，但没有收到回复。这是否是因为朋友没有收到消息？在这段时间内是否发生了什么？回复是否丢失了？在同步通信，例如电话通话中，我们会立即知道朋友是否可用，并且能够回拨。在异步场景中，我们需要考虑更多可能的问题，例如我们之前描述的那些。'
- en: '**Reliance on additional components for message delivery**: Certain asynchronous
    communication use cases, such as the publisher-subscriber or message broker models
    described in the next section, require additional software for delivering messages.
    Such software often performs additional operations, such as message batching and
    storing, bringing additional complexity to the system in exchange for additional
    features it provides.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖额外的组件进行消息传递**：某些异步通信用例，如下一节中描述的发布-订阅或消息代理模型，需要额外的软件来传递消息。此类软件通常执行额外的操作，如消息批处理和存储，以换取它提供的额外功能，从而给系统带来额外的复杂性。'
- en: '**Asynchronous data flow may seem non-intuitive to many developers and be more
    complex**: Unlike the synchronous request-response model, where each request is
    logically followed by a response to it, asynchronous communication may be **unidirectional**
    (no responses are received at all) or may require the caller to perform additional
    steps in order to receive a response (for example, when the response is sent as
    a separate notification). Because of this, data flow in asynchronous systems may
    be more complex than in synchronous request-response interactions.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步数据流对许多开发者来说可能看起来不直观，并且更复杂**：与同步请求-响应模型不同，其中每个请求在逻辑上都会跟随一个响应，异步通信可能是**单向的**（根本不会收到任何响应）或者可能需要调用者执行额外的步骤以接收响应（例如，当响应作为单独的通知发送时）。因此，异步系统中的数据流可能比同步请求-响应交互更复杂。'
- en: Now, let’s cover some asynchronous communication techniques and patterns that
    can help you in organizing your services and establishing asynchronous communication
    between them.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来探讨一些可以帮助您组织服务和在它们之间建立异步通信的异步通信技术和模式。
- en: Techniques and patterns of asynchronous communication
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步通信的技术和模式
- en: There are various techniques that help to make the asynchronous interaction
    between multiple services more efficient in various scenarios, such as sending
    a message to multiple recipients. In this section, we are going to describe multiple
    patterns that help to facilitate such interactions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种技术可以帮助在各种场景中使多个服务之间的异步交互更高效，例如向多个收件人发送消息。在本节中，我们将描述多个有助于促进此类交互的模式。
- en: Message broker
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消息代理
- en: 'A **message broker** is an intermediary component in the communication chain
    that can play multiple roles:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息代理**是通信链中的一个中介组件，可以扮演多个角色：'
- en: '**Message delivery**: It performs the delivery of a message to one or multiple
    receivers.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息投递**：它执行将消息投递给一个或多个接收者的操作。'
- en: '**Message transformation**: It transforms an incoming message into another
    format that can be later consumed by receivers.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息转换**：它将传入的消息转换成可以被接收者稍后消费的另一种格式。'
- en: '**Message aggregation**: It aggregates multiple messages into a single one
    for more efficient delivery or processing.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息聚合**：它将多个消息聚合为一个，以实现更高效的投递或处理。'
- en: '**Message routing**: It routes incoming messages to the appropriate destination
    based on pre-defined rules.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息路由**：它根据预定义的规则将传入的消息路由到适当的目的地。'
- en: 'When you send a postcard to your friend or a relative, the post office plays
    the role of a message broker, playing an intermediary role in delivering it to
    the destination. In this example, the main benefit of using the message broker
    would be the convenience of sending the message (postcard, in our example) without
    any need to think about how to deliver it. Another benefit of using message brokers
    is delivery guarantees. A message broker can provide various levels of guarantees
    for message delivery. Examples of these guarantees include the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当你给你的朋友或亲戚寄明信片时，邮局扮演了消息代理的角色，在将其投递到目的地时起到中介作用。在这个例子中，使用消息代理的主要好处是发送消息（在我们的例子中是明信片）的便利性，无需考虑如何投递。使用消息代理的另一个好处是投递保证。消息代理可以提供各种级别的投递保证。以下是一些保证的例子：
- en: '**At-least-once**: The message gets delivered at least once, but may be delivered
    multiple times in case of failures.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**至少一次**：消息至少被投递一次，但在出现故障的情况下可能会被多次投递。'
- en: '**Exactly-once**: The message broker guarantees that the message gets delivered
    and it will be delivered exactly once.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**精确一次**：消息代理保证消息被投递，并且它将恰好被投递一次。'
- en: '**At-most-once**: The message can be delivered 0 or 1 time.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**至多一次**：消息可以被投递0次或1次。'
- en: The exactly-once guarantee is often harder to achieve in practice than at-least-once
    and at-most-once. In the at-least-once model, a message broker can just re-send
    the message in case of any failure (such as a sudden power loss or a restart).
    In the exactly-once model, the message broker needs to perform additional checks
    or store extra metadata to ensure the message is never re-sent to the receiver
    in any possible case.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，精确一次保证通常比至少一次和至多一次更难实现。在至少一次模型中，消息代理在出现任何故障（例如突然断电或重启）的情况下可以重新发送消息。在精确一次模型中，消息代理需要执行额外的检查或存储额外的元数据，以确保在任何可能的情况下消息都不会被重新发送给接收者。
- en: 'Another classification of message brokers is based on the possibility of them
    losing messages:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 消息代理的另一种分类是基于它们丢失消息的可能性：
- en: '**Lossy**: A message broker that can occasionally (for example, in case of
    failures) lose messages'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**损失性**：偶尔（例如，在出现故障的情况下）会丢失消息的消息代理'
- en: '**Lossless**: A message broker that provides a guarantee of not losing any
    messages'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无损**：提供不丢失任何消息保证的消息代理'
- en: The at-most-once guarantee is an example of a lossy message broker, and at-least-once
    and exactly-once brokers are examples of lossless ones. Lossy message brokers
    are faster than lossless ones because they don’t need to handle extra logic for
    guaranteeing message delivery, such as persisting messages.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 至多一次保证是损失性消息代理的一个例子，而至少一次和精确一次代理是无损性代理的例子。损失性消息代理比无损性代理更快，因为它们不需要处理额外的逻辑来保证消息的投递，例如持久化消息。
- en: The publisher-subscriber model
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布-订阅模型
- en: The **publisher-subscriber model** is a model of communication between multiple
    components (such as microservices) where every component can publish messages
    and subscribe to the relevant ones.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**发布-订阅模型**是多组件（如微服务）之间通信的模型，其中每个组件都可以发布消息并订阅相关的消息。'
- en: Let’s take Twitter as an example. Any user can publish messages to their feeds,
    and other users can subscribe to them. Similarly, microservices can communicate
    by publishing the data that other services can consume. Imagine that we have a
    set of services that process various types of user data, such as user photos,
    videos, and text messages. If a user deleted their profile, we would need to notify
    all services about this. Instead of notifying each service one by one, we could
    publish a single event that would indicate that a user profile is deleted, and
    all services could consume it and perform any relevant actions, such as archiving
    user data.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以 Twitter 为例。任何用户都可以向他们的动态发布消息，其他用户可以订阅它们。同样，微服务可以通过发布其他服务可以消费的数据来进行通信。想象一下，我们有一组处理各种类型用户数据的微服务，例如用户照片、视频和文本消息。如果用户删除了他们的个人资料，我们需要通知所有服务。而不是逐个通知每个服务，我们可以发布一个事件，表明用户个人资料已被删除，所有服务都可以消费它并执行任何相关的操作，例如存档用户数据。
- en: 'The relationship between the publishers, the subscribers, and the data produced
    by the publisher is illustrated in the following diagram:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者、订阅者以及发布者产生的数据之间的关系在以下图中展示：
- en: '![Figure 6.1 – The publisher-subscriber model'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.1 – 发布-订阅模型'
- en: '](img/Figure_6.1_B18865.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.1_B18865.jpg)'
- en: Figure 6.1 – The publisher-subscriber model
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 发布-订阅模型
- en: The publisher-subscriber model provides a flexible solution for sending and
    delivering data in a system where messages can be processed by multiple components.
    Each publisher can publish their messages without caring about the delivery process
    and any difficulties in delivering messages to an arbitrary number (even a very
    large one) of receivers. Each subscriber can subscribe to the relevant messages
    and get them delivered without needing to contact the publisher directly and check
    if there is any new data to consume. The latter feature is especially useful for
    scenarios with low message rates, such as occasional notification delivery.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 发布-订阅模型为在消息可以被多个组件处理的环境中发送和传递数据提供了一个灵活的解决方案。每个发布者可以发布他们的消息，而不必关心交付过程以及将消息发送到任意数量（甚至是非常大的数量）的接收者可能遇到的任何困难。每个订阅者可以订阅相关的消息并接收它们，而不需要直接联系发布者并检查是否有任何新的数据可以消费。后一个特性对于消息率较低的场景特别有用，例如偶尔的通知交付。
- en: Now, as we have covered some high-level asynchronous communication models, let’s
    move on to the practical side of the chapter and illustrate how you can implement
    asynchronous communication in your microservices.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经介绍了一些高级异步通信模型，接下来让我们转向本章的实际部分，并说明如何在您的微服务中实现异步通信。
- en: Using Apache Kafka for messaging
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Apache Kafka 进行消息传递
- en: In this section, we are going to introduce you to Apache Kafka, a popular message
    broker system that we are going to use to establish asynchronous communication
    between our microservices. You will learn the basics of Kafka, how to publish
    messages to it, and how to consume such messages from the microservices we created
    in the previous chapters.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您介绍 Apache Kafka，这是一个流行的消息代理系统，我们将使用它来在我们的微服务之间建立异步通信。您将学习 Kafka 的基础知识，如何向其发布消息，以及如何从我们在前几章中创建的微服务中消费这些消息。
- en: Apache Kafka basics
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Apache Kafka 基础
- en: Apache Kafka is an open source message broker system that provides the ability
    to publish and subscribe to messages containing arbitrary data. Originally developed
    at LinkedIn, Kafka has become perhaps the most popular open source message broker
    software and is used by thousands of companies around the world.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Kafka 是一个开源的消息代理系统，它提供了发布和订阅包含任意数据的消息的能力。最初在 LinkedIn 开发，Kafka 已经成为可能最受欢迎的开源消息代理软件，并被全球成千上万家公司使用。
- en: In the Kafka model, a component that publishes messages is called a **producer**.
    Messages are published in sequential order to objects called **topics**. Each
    message in a topic has a unique numerical **offset** in it. Kafka provides APIs
    for consuming messages (the component for consuming messages is called a **consumer**)
    for the existing topics. Topics can also be partitioned to allow multiple consumers
    to consume from them (for example, for parallel data processing).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kafka模型中，一个发布消息的组件被称为**生产者**。消息按照顺序发布到称为**主题**的对象中。每个主题中的消息都有一个唯一的数值**偏移量**。Kafka为现有主题提供了消费消息的API（消费消息的组件称为**消费者**）。主题也可以分区，以便多个消费者从中消费（例如，用于并行数据处理）。
- en: 'We can illustrate the Kafka data model in the following diagram:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下图中说明Kafka数据模型：
- en: '![Figure 6.2 – The Apache Kafka data model'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2 – Apache Kafka数据模型'
- en: '](img/Figure_6.2_B18865.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.2_B18865.jpg)'
- en: Figure 6.2 – The Apache Kafka data model
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – Apache Kafka数据模型
- en: 'Having such a seemingly simple data model, Kafka is a powerful system that
    offers lots of benefits to its users:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数据模型看似简单，但Kafka是一个强大的系统，为用户提供了许多好处：
- en: '**High write and read throughput**: Kafka is optimized for highly performant
    write and read operations. It achieves this by doing as many sequential writes
    and reads as possible, allowing it to efficiently make use of hardware such as
    hard disk drives, as well as sequentially sending large amounts of data over the
    network.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高读写吞吐量**：Kafka针对高性能的读写操作进行了优化。它通过尽可能多地执行顺序读写来实现这一点，从而使其能够有效地利用硬盘驱动器等硬件，以及顺序发送大量数据到网络上。'
- en: '**Scalability**: Developers can leverage topic partitioning provided by Kafka
    to achieve more performant parallel processing of their data.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可伸缩性**：开发者可以利用Kafka提供的主题分区来实现数据的高效并行处理。'
- en: '**Flexible durability**: Kafka allows users to configure the policies for storing
    data, such as message retention. Messages can be stored for a fixed amount of
    time (for example, for 7 days) or indefinitely until there is enough space on
    the data storage.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活的持久性**：Kafka允许用户配置存储数据的策略，例如消息保留。消息可以存储固定的时间（例如，7天）或无限期地，直到数据存储空间足够。'
- en: Note
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While Kafka provides many benefits for developers, it is important to note that
    it is a fairly complex infrastructure component that may be nontrivial to manage
    and maintain. We are going to use it in this chapter for illustrative purposes,
    especially taking into account its wide adoption and popularity in the developer
    community. In this chapter, we will avoid the difficulties of setting up a Kafka
    cluster by using its Docker version, but for production use cases you may need
    to get familiar with the relevant Kafka maintenance documentation, available at
    [https://kafka.apache.org/documentation/](https://kafka.apache.org/documentation/)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Kafka为开发者提供了许多好处，但重要的是要注意，它是一个相当复杂的基础设施组件，可能难以管理和维护。在本章中，我们将为了说明目的使用它，特别是考虑到它在开发者社区中的广泛采用和流行。在本章中，我们将通过使用其Docker版本来避免设置Kafka集群的困难，但对于生产用例，你可能需要熟悉可用的相关Kafka维护文档，可在[https://kafka.apache.org/documentation/](https://kafka.apache.org/documentation/)找到。
- en: Let’s explore how we can leverage the benefits offered by Kafka for the microservices
    we developed in the previous chapters.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索如何利用Kafka为我们之前章节中开发的微服务提供的优势。
- en: Adopting Kafka for our microservices
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的微服务中采用Kafka
- en: Let’s get back to the rating service example from the previous chapters. The
    service provided a synchronous API for inserting rating records, allowing its
    callers to call an endpoint and get an immediate response from the service. Such
    an API would be useful in many practical use cases, including one where the user
    submits a rating from a user interface or a web form.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到前几章中的评分服务示例。该服务提供了一个同步API用于插入评分记录，允许调用者调用端点并立即从服务中获得响应。这样的API在许多实际用例中都很有用，包括用户从用户界面或网页表单提交评分的情况。
- en: Now consider a scenario where we work with a data provider who frequently publishes
    rating records (for example, movie ratings from a popular movie database, such
    as IMDb) that we can use in our rating service. Here, we would need to consume
    such records and ingest them into our system, so we could use them in addition
    to the data that was created through our API. The publisher-subscriber model that
    we described earlier in this chapter would be a great fit for this use case –
    the publisher would be the data provider that provides the rating data, and the
    subscriber would be a part of our application (such as a rating service), which
    would consume the data.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一个场景，其中我们与一个经常发布评分记录（例如，来自流行的电影数据库，如 IMDb 的电影评分）的数据提供者合作，我们可以在我们的评分服务中使用这些记录。在这里，我们需要消费此类记录并将它们摄入到我们的系统中，以便我们可以使用这些数据，以及通过我们的
    API 创建的数据。我们在本章前面描述的发布-订阅模型非常适合这个用例 – 发布者将是提供评分数据的数据提供者，而订阅者将是我们的应用程序的一部分（例如，评分服务），它将消费数据。
- en: 'We can illustrate the described model using the following diagram:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下图表来说明所描述的模型：
- en: '![Figure 6.3 – The publisher-subscriber model of rating ingestion from a data
    provider'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.3 – 从数据提供者处获取评分的发布-订阅模型](img/Figure_6.3_B18865.jpg)'
- en: '](img/Figure_6.3_B18865.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.3_B18865.jpg)'
- en: Figure 6.3 – The publisher-subscriber model of rating ingestion from a data
    provider
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 从数据提供者处获取评分的发布-订阅模型
- en: The model of interaction between the data provider and the rating service is
    a perfect example of asynchronous communication – the rating service does not
    necessarily need to process the provider’s data immediately. It is up to us when
    and how to consume this data – our rating service could do this periodically (for
    example, once an hour, or once a day), or handle the new rating data as soon as
    it gets published. Let’s choose the second approach in this chapter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 数据提供者和评分服务之间的交互模型是异步通信的一个完美示例 – 评分服务不一定要立即处理提供者的数据。何时以及如何消费这些数据取决于我们 – 我们的评分服务可以定期（例如，每小时一次，或每天一次）执行此操作，或者在新评分数据发布时立即处理新评分数据。让我们在本章中选择第二种方法。
- en: The only missing piece in our model is the component that allows us to publish
    the rating data from the data provider and subscribe to it from our rating service.
    Apache Kafka, which we described earlier, is a great fit for this use case – it
    provides a performant, scalable, and durable solution for producing and consuming
    arbitrary data, allowing us to use it as a rating data message broker.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模型中唯一缺少的部分是允许我们从数据提供者发布评分数据并从我们的评分服务订阅它的组件。我们之前描述的 Apache Kafka 对于这个用例非常合适
    – 它提供了一个高性能、可扩展且持久的解决方案，用于生产和消费任意数据，使我们能够将其用作评分数据消息代理。
- en: 'To illustrate the model that we have just described, let’s implement the following
    logic:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明我们刚刚描述的模型，让我们实现以下逻辑：
- en: A new example application that will produce rating data for Apache Kafka
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个新的示例应用程序，将为 Apache Kafka 生成评分数据
- en: Logic in the rating service to consume the rating data from Apache Kafka and
    save it to our rating database
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评分服务中用于从 Apache Kafka 消费评分数据并将其保存到我们的评分数据库的逻辑
- en: 'Before we proceed to implement both components, we need to decide which data
    serialization format to use between them. For simplicity, let’s assume the data
    provider provides us with the rating data in JSON format. An example of the provided
    rating data would be as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续实现这两个组件之前，我们需要决定在它们之间使用哪种数据序列化格式。为了简单起见，让我们假设数据提供者以 JSON 格式提供评分数据。提供的评分数据的一个示例如下：
- en: '[PRE0]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s define a Go structure for such rating records. In the `src/rating/pkg/model/rating.go`
    file, add the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个用于此类评分记录的 Go 结构。在 `src/rating/pkg/model/rating.go` 文件中，添加以下代码：
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let’s implement the example application that reads rating data from a
    provided file and produces it in Kafka. Create a `cmd/ratingingester` directory
    and add a `main.go` file, containing the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现一个示例应用程序，该应用程序从提供的文件中读取评分数据并将其输出到 Kafka。创建一个 `cmd/ratingingester` 目录并添加一个
    `main.go` 文件，包含以下代码：
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the code that we just added, we initialize a Kafka producer by calling `kafka.NewProducer`,
    read the rating data from a file, and produce rating events containing the rating
    data in Kafka. Note that we import the `github.com/confluentinc/confluent-kafka-go`
    Kafka library — a Kafka client made by Confluent, a company founded by the creators
    of Kafka. There are multiple popular open source Kafka libraries for Go, including
    `github.com/Shopify/sarama`, which is well maintained and is widely used across
    many Go projects. You can use either library in your projects depending on your
    preference.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚添加的代码中，我们通过调用`kafka.NewProducer`初始化了一个Kafka生产者，从文件中读取评分数据，并在Kafka中生产包含评分数据的评分事件。请注意，我们导入了`github.com/confluentinc/confluent-kafka-go`
    Kafka库——由Kafka的创始人创立的公司Confluent制作的Kafka客户端。对于Go，有多个流行的开源Kafka库，包括`github.com/Shopify/sarama`，它维护良好，并被广泛用于许多Go项目中。你可以根据你的偏好在你的项目中使用任一库。
- en: 'Now, let’s add a function for reading rating events to the file we just created:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为刚刚创建的文件添加一个用于读取评分事件的函数：
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, add a function for producing rating events:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加一个用于生产评分事件的函数：
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s describe some parts of the code that we just wrote:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述一下我们刚刚编写的代码的一些部分：
- en: We created a Kafka producer by calling a `kafka.NewProducer` function and providing
    `localhost` as the Kafka address for testing it locally.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过调用`kafka.NewProducer`函数并使用`localhost`作为本地测试的Kafka地址来创建了一个Kafka生产者。
- en: The program that we created is expected to read rating data from the `ratingsdata.json`
    file.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建的程序预期将从`ratingsdata.json`文件中读取评分数据。
- en: When we produce events to Kafka using a `Produce` function, we specify a topic
    partition using a `kafka.TopicPartition` structure. In the structure, we provide
    the topic name (in our example, we call it `ratings`) and the topic partition
    (in our example, we use `kafka.PartitionAny` to produce a partition — we will
    cover this part later, in the *Asynchronous communication best practices* section).
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们使用`Produce`函数向Kafka生产事件时，我们使用`kafka.TopicPartition`结构指定一个主题分区。在这个结构中，我们提供了主题名称（在我们的例子中，我们称之为`ratings`）和主题分区（在我们的例子中，我们使用`kafka.PartitionAny`来生产一个分区——我们将在后面的*异步通信最佳实践*部分中介绍这部分）。
- en: At the end of our main function, we call the `Flush` function to make sure all
    messages are sent to Kafka.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们主函数的末尾，我们调用`Flush`函数以确保所有消息都已发送到Kafka。
- en: 'The function that we just created is using the `github.com/confluentinc/confluent-kafka-go/kafka`
    library, which we need to include in our Go module. Let’s do this by running the
    following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的函数正在使用`github.com/confluentinc/confluent-kafka-go/kafka`库，我们需要将其包含在我们的Go模块中。让我们通过运行以下代码来完成此操作：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s also add a file containing the rating events. In the directory that we
    just used, create a `ratingsdata.json` file, containing the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也在该目录中添加一个包含评分事件的文件。在刚刚使用的目录中创建一个`ratingsdata.json`文件，内容如下：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, our application is ready. We have implemented the logic to read the rating
    data from a file and publish it to Apache Kafka for further consumption by the
    rating service. Let’s implement the logic in the rating service to consume the
    published data. Create a `rating/internal/ingester/kafka` directory and add an
    `ingester.go` file with the following contents:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序已经准备好了。我们已经实现了从文件中读取评分数据并将其发布到Apache Kafka的逻辑，以便评分服务进一步消费。让我们在评分服务中实现消费已发布数据的逻辑。创建一个`rating/internal/ingester/kafka`目录，并添加一个`ingester.go`文件，内容如下：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Additionally, add this piece of code to it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，添加以下代码段：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the code we just created, we have implemented a `NewIngester` function to
    create a new Kafka ingester, the component that will ingest rating events from
    it. The `Ingest` function starts message ingestion in the background and returns
    a Go channel with `RatingEvent` structures.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚创建的代码中，我们实现了一个`NewIngester`函数来创建一个新的Kafka ingester，该组件将从其中摄取评分事件。`Ingest`函数在后台启动消息摄取并返回一个包含`RatingEvent`结构的Go通道。
- en: You may notice that in our call to the `ReadMessage` function, we provided `-1`
    as an argument. We specified a `-1` is specific to Kafka and means that we will
    always consume from the beginning of the topic, reading all existing messages.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，在我们的`ReadMessage`函数调用中，我们提供了`-1`作为参数。我们指定的`-1`是Kafka特有的，意味着我们将始终从主题的开始处消费，读取所有现有消息。
- en: 'Let’s use this structure in our rating service controller. In our `rating/internal/controller/controller.go`
    file, add the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的评分服务控制器中使用这个结构。在我们的`rating/internal/controller/controller.go`文件中，添加以下代码：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In our code, we call the `Ingest` function and get back a Go channel containing
    rating events from the topic. We iterate over it using the `for` operator. It
    keeps returning us available rating events until the channel is closed (for example,
    when the Kafka client is closed on service shutdown).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们调用`Ingest`函数，并返回一个包含来自主题的评分事件的Go通道。我们使用`for`运算符遍历它。它将一直返回可用的评分事件，直到通道关闭（例如，当服务关闭时Kafka客户端关闭）。
- en: 'Now, update the existing `RatingService` structure and the `New` function in
    this file to the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，更新此文件中现有的`RatingService`结构和`New`函数，如下所示：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, our rating service is able to asynchronously consume rating events from
    Kafka, and execute the `Put` function for each one, writing it to the rating database.
    At this point, the rating service provides both a synchronous API for the callers
    that want to create ratings in real time and asynchronous logic for ingesting
    rating events from Apache Kafka.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的评分服务能够异步消费来自Kafka的评分事件，并为每个事件执行`Put`函数，将其写入评分数据库。在此阶段，评分服务为希望实时创建评分的调用者提供同步API，并为从Apache
    Kafka摄取评分事件提供异步逻辑。
- en: We have covered the basics of asynchronous communication and illustrated how
    to use it in our microservices. Let’s proceed to the final part of the chapter
    to see some best practices you should keep in mind while using this model.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了异步通信的基础知识，并展示了如何在我们的微服务中使用它。现在，让我们继续本章的最后一部分，看看在使用此模型时应牢记的一些最佳实践。
- en: Asynchronous communication best practices
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步通信最佳实践
- en: In this section, we are going to cover the best practices of using the asynchronous
    communication model. You will learn some high-level recommendations for adopting
    the model in your applications and using it in a way that would maximize its benefits
    for you.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍使用异步通信模型的最佳实践。您将了解一些针对在您的应用程序中采用该模型和使用它的建议，以最大限度地发挥其为您带来的好处。
- en: Versioning
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本控制
- en: '**Versioning** is the technique of associating the format (or a schema) of
    the data with its version. Imagine you are working on a rating service, and you
    use a publisher-subscriber model for producing and consuming rating events. If
    at some point the format of your rating events gets changed, some of the events
    that are already produced will have an old data format, and some will have the
    new one. This situation may be hard to handle because the logic consuming such
    data would need to know how to differentiate between such formats and how to handle
    each one. Differentiating between two formats without knowing the data schema
    or its version could be a nontrivial task. Imagine that we have two JSON events:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**版本控制**是将数据格式（或模式）与其版本关联的技术。想象一下，您正在开发一个评分服务，并使用发布者-订阅模型来生产和使用评分事件。如果在某个时刻，您的评分事件格式发生变化，一些已经生产的事件将具有旧的数据格式，而一些将具有新的格式。这种情况可能很难处理，因为消费此类数据的逻辑需要知道如何区分这些格式以及如何处理每个格式。在不了解数据模式或其版本的情况下区分两种格式可能是一项非平凡的任务。想象一下，我们有两个JSON事件：'
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The second event has a `userId` field that is not present in the first. Is it
    because the producer did not provide it or because the data format did not have
    this field before?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个事件有一个不在第一个事件中存在的`userId`字段。这是否是因为生产者没有提供它，或者因为数据格式之前没有这个字段？
- en: 'Providing the schema version explicitly would help the data consumer handle
    this problem. Consider these updated examples:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 明确提供模式版本将帮助数据消费者处理这个问题。考虑以下更新后的示例：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In these examples, we know the versions of events and can now handle each one
    separately. For example, we may completely ignore events of a certain version
    (assume there was an application bug and we want to re-process events with an
    updated version instead) or use the version-specific validation (for instance,
    allow the records without a `userId` field for version 1, but disallow for the
    higher versions).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，我们知道事件的版本，现在可以单独处理每个事件。例如，我们可能完全忽略某个版本的某些事件（假设存在应用程序错误，我们希望用更新的版本重新处理事件）或使用特定版本的验证（例如，对于版本1允许没有`userId`字段的记录，但对于更高版本则不允许）。
- en: Versioning is very important to systems that can evolve over time because it
    makes dealing with different data formats easier. Even if you don’t expect your
    data format to change, consider using versioning to increase your system’s maintainability
    in the future.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制对于可以随时间演变的系统非常重要，因为它使得处理不同的数据格式变得更容易。即使您不期望您的数据格式发生变化，也请考虑使用版本控制来提高您系统未来的可维护性。
- en: Leveraging partitioning
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用分区
- en: 'In the code examples in the *Adopting Apache Kafka for our microservices* section,
    we implemented the logic for producing our data to message topics in Apache Kafka.
    The function for producing a message was as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在“采用 Apache Kafka 为我们的微服务”部分的代码示例中，我们实现了将我们的数据生产到 Apache Kafka 消息主题的逻辑。生产消息的函数如下：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this function, we used the `kafka.PartitionAny` option. As we mentioned
    in the *Apache Kafka basics* section, Kafka topics can be partitioned to allow
    multiple consumers to consume different partitions of a topic. Imagine you have
    a topic with three partitions – you can consume each one independently, as illustrated
    in the following diagram:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们使用了 `kafka.PartitionAny` 选项。正如我们在“Apache Kafka 基础”部分中提到的，Kafka 主题可以被分区，以便多个消费者可以消费主题的不同分区。想象一下，你有一个包含三个分区的主题
    – 你可以独立地消费每一个，如下面的图示所示：
- en: '![Figure 6.4 – A partitioned topic consumption example'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.4 – 分区主题消费示例'
- en: '](img/Figure_6.4_B18865.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.4_B18865.jpg)'
- en: Figure 6.4 – A partitioned topic consumption example
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 分区主题消费示例
- en: You can control the number of topic partitions, as well as the partition for
    each message your services produce. Setting a partition manually may help you
    to achieve **data locality** — the ability to co-locate the data for various records,
    storing it together (in our use case, in the same topic partition). For example,
    you can partition the data using a user identifier, making sure the data for any
    user is stored on a single topic partition, helping you simplify the data search
    across the topic partitions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以控制主题分区的数量，以及你服务产生的每个消息的分区。手动设置分区可能有助于你实现**数据本地性** — 将各种记录的数据存储在一起的能力（在我们的用例中，在同一个主题分区中）。例如，你可以使用用户标识符来分区数据，确保任何用户的数据都存储在单个主题分区中，这有助于你简化跨主题分区的数据搜索。
- en: The list of best practices that we just described is not comprehensive. It does
    not cover all recommendations for using asynchronous communication in your microservices,
    but it provides some great ideas for what you should consider. Get familiar with
    the articles listed in the *Further reading* section for some additional ideas
    and recommendations.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才描述的最佳实践列表并不全面。它并没有涵盖在微服务中使用异步通信的所有建议，但它提供了一些你应该考虑的极好想法。熟悉“进一步阅读”部分中列出的文章，以获取更多想法和建议。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered the basics of asynchronous communication and
    illustrated how to use it in your microservices. You have learned the benefits
    of asynchronous communication and the common patterns, such as publisher-subscriber
    and message broker. In addition to this, we have covered the basics of the Apache
    Kafka message broker and illustrated how to use it in our microservices and how
    to implement the logic for producing and consuming data from it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了异步通信的基础，并说明了如何在微服务中使用它。你学习了异步通信的好处以及常见的模式，如发布-订阅和消息代理。除此之外，我们还介绍了
    Apache Kafka 消息代理的基础，并说明了如何在我们的微服务中使用它以及如何实现从它生产和使用数据的逻辑。
- en: In the next chapter, we are going to cover another important topic of microservice
    development – data storage. You will learn how to persist and read different types
    of service data, as well as how to implement the logic for working with MySQL
    database in your Go microservices.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍微服务开发中的另一个重要主题 – 数据存储。你将学习如何持久化和读取不同类型的服务数据，以及如何在你的 Go 微服务中实现与 MySQL
    数据库交互的逻辑。
- en: Further reading
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Apache Kafka documentation*: [https://kafka.apache.org/documentation/](https://kafka.apache.org/documentation/)'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Apache Kafka 文档*: [https://kafka.apache.org/documentation/](https://kafka.apache.org/documentation/)'
- en: '*Publish-subscribe pattern*: [https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*发布-订阅模式*: [https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern)'
- en: '*Asynchronous message-based communication*: [https://docs.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/asynchronous-message-based-communication](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/asynchronous-message-based-communication
    )'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*异步消息通信*: [https://docs.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/asynchronous-message-based-communication](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/asynchronous-message-based-communication
    )'
