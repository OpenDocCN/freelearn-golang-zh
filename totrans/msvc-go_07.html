<html><head></head><body>
		<div id="_idContainer032">
			<h1 id="_idParaDest-101" class="chapter-number" lang="en-GB"><a id="_idTextAnchor102"/>7</h1>
			<h1 id="_idParaDest-102" lang="en-GB"><a id="_idTextAnchor103"/>Storing Service Data</h1>
			<p lang="en-GB">In this chapter, we are going to review a very important topic: storing service data in persistent databases. In the previous chapters, we stored movie metadata and user ratings using in-memory repositories. While it was easy to implement in-memory storages of our data, using them would be impractical due to many reasons. One such reason is a lack of a persistence guarantee: if our service instances storing the data were restarted (for example, due to application failure or on host restart), we would lose all our data that was stored in the memory of a previously running instance. To guarantee that our data won’t be lost over time, we need a solution that can persist our data and allow us to read and write it to our microservices. Among such solutions are databases, which we are going to review in this chapter.</p>
			<p lang="en-GB">We will cover the following topics:</p>
			<ul>
				<li lang="en-GB">Introduction to databases</li>
				<li lang="en-GB">Using MySQL to store our service data</li>
			</ul>
			<p lang="en-GB">Let’s proceed to the first section of this chapter, which will provide an overview of microservice persistent storage solutions.</p>
			<h1 id="_idParaDest-103" lang="en-GB"><a id="_idTextAnchor104"/>Technical requirements</h1>
			<p lang="en-GB">To complete this chapter, you will need Go 1.11+ or above. Additionally, you will need the following tools:</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Docker</strong>: https://www.docker.com</li>
				<li lang="en-GB"><strong class="bold" lang="">grpcurl</strong>: <a href="https://github.com/fullstorydev/grpcurl">https://github.com/fullstorydev/grpcurl</a></li>
			</ul>
			<p lang="en-GB">You can find the GitHub code for this chapter here: https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter07.</p>
			<h1 id="_idParaDest-104" lang="en-GB"><a id="_idTextAnchor105"/>Introduction to databases</h1>
			<p lang="en-GB"><strong class="bold" lang="">Databases</strong> are systems that allow us to store and retrieve different types of data. Databases offer a variety of guarantees related to data storage, such as <strong class="bold" lang="">durability</strong> – a guarantee that all records and any related data changes will be persistent over time. A durability guarantee helps ensure that the data stored in a database won’t be lost in case of various events such as software and hardware restarts, which are pretty common for microservices</p>
			<p lang="en-GB">Databases help solve lots of different other problems related to data storage. Let’s illustrate one such problem using the metadata service that we created in <a href="B18865_02.xhtml#_idTextAnchor027"><em class="italic" lang="">Chapter 2</em></a>. In our metadata service code, we implemented an in-memory repository for storing and retrieving the movie data that provides two functions, <strong class="source-inline" lang="">Get</strong> and <strong class="source-inline" lang="">Put</strong>. If we have just one instance of the metadata service, all its callers would be able to successfully write and read metadata records from the service memory, so long as a service instance does not perform a restart. However, let’s imagine that we add another instance of a metadata service, as illustrated in the following diagram:</p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/Figure_7.1_B18865.jpg" alt="Figure 7.1 – Interaction between the movie service and two instances of the metadata service&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Interaction between the movie service and two instances of the metadata service</p>
			<p lang="en-GB">Imagine that the movie service wants to write movie metadata and calls the metadata service to do this. The movie service instance would pick an instance of a metadata service (let’s assume it picks instance 0) and send a write request to it, storing the record in memory of the instance that processes the request.</p>
			<p lang="en-GB">Now, let’s assume the movie service wants to read the previously stored movie metadata and sends a read request to the metadata service. Depending on which instance handles the request, there would be two possible outcomes:</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Instance 0</strong>: Successfully return the previously saved movie metadata</li>
				<li lang="en-GB"><strong class="bold" lang="">Instance 1</strong>: Return <strong class="source-inline" lang="">ErrNotFound</strong></li>
			</ul>
			<p lang="en-GB">We just illustrated a case where the data is inconsistent between the two instances of the metadata repository. Because we have not implemented any coordination between our in-memory metadata repositories, each one acts as an independent data storage. Using our metadata service in such a way would be highly impractical: each newly added service instance would store a completely independent dataset.</p>
			<p lang="en-GB">To solve our data inconsistency problem, we can use a database to store the movie metadata: a database will handle all writes and reads from all the available metadata service instances, helping to co-locate the data from them inside a single type of logical storage. Such a scenario is illustrated in the following diagram:</p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/Figure_7.2_B18865.jpg" alt="Figure 7.2 – Using a shared metadata database among multiple instances&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Using a shared metadata database among multiple instances</p>
			<p lang="en-GB">In our diagram, multiple instances of a metadata service are using a shared database. This helps us aggregate and store the data coming from different metadata service instances.</p>
			<p lang="en-GB">We just illustrated how a <a id="_idIndexMarker271"/>database can help provide data durability to our services. There are other benefits that this can provide:</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Transaction support</strong>: Many<a id="_idIndexMarker272"/> databases support transactions – types of data changes – that have the following properties, abbreviated as <strong class="bold" lang="">ACID</strong>:<ul><li lang="en-GB"><strong class="bold" lang="">Atomicity</strong><span class="Annotation-reference" lang="">:</span> A change <a id="_idIndexMarker273"/>either happens entirely or does not happen at all</li><li lang="en-GB"><strong class="bold" lang="">Consistency</strong>: A <a id="_idIndexMarker274"/>change brings a database from one valid state to another</li><li lang="en-GB"><strong class="bold" lang="">Isolation</strong>: Concurrent <a id="_idIndexMarker275"/>changes get executed as they were executed sequentially</li><li lang="en-GB"><strong class="bold" lang="">Durability</strong>: All <a id="_idIndexMarker276"/>changes get persisted</li></ul></li>
			</ul>
			<p lang="en-GB">These transaction properties help provide a reliable way to modify different types of data (for example, simultaneously updating two financial account balances).</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Data replication</strong>: A <a id="_idIndexMarker277"/>database can offer data replication – a mechanism of duplicating data to additional instances, called <strong class="bold" lang="">replicas</strong>. Replication <a id="_idIndexMarker278"/>can help make the database more resilient to data losses (for example, when a database host becomes unavailable, data can be accessed on its replica) and reduce read latency (for example, when a user reads data from a replica that is located closer to them).</li>
				<li lang="en-GB"><strong class="bold" lang="">Additional query capabilities</strong>: There<a id="_idIndexMarker279"/> are many databases (such as MySQL and PostgreSQL), that offer support for different<a id="_idIndexMarker280"/> query languages, such as SQL (<a href="https://en.wikipedia.org/wiki/SQL">https://en.wikipedia.org/wiki/SQL</a>).</li>
			</ul>
			<p lang="en-GB">Different types of databases can help you efficiently store and retrieve various types of data. Let’s review some of these popular database types:</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Key-value databases</strong>: These<a id="_idIndexMarker281"/> are databases that<a id="_idIndexMarker282"/> store data in key-value format, where each record contains a key (for example, user identifier) and a value (for example, user metadata). Keys and values are often represented as strings or byte arrays. Operations provided by key-value databases are often limited to key-based writes (store a value for the provided key) and key-based reads (read a value for the provided key). Because of their functional simplicity, key-value databases are among the most performant, since they don’t involve any complex data processing or indexing.</li>
				<li lang="en-GB"><strong class="bold" lang="">Relational databases</strong>: These<a id="_idIndexMarker283"/> are databases that<a id="_idIndexMarker284"/> store the data as a collection of tables, each consisting of a set of rows and columns. Users can run SQL queries to retrieve the data from one or multiple tables, being able to join the data between them or perform complex searching based on a variety of conditions. Historically, relational databases have been the most popular across all database types due to their ability to execute queries of any complexity, as well as their ability to store various types of structured (having a well-defined schema that maps row data to table columns) data.</li>
				<li lang="en-GB"><strong class="bold" lang="">Document databases</strong>: These <a id="_idIndexMarker285"/>are databases that store data in a document format, such <a id="_idIndexMarker286"/>as JSON or XML. Document databases don’t require you to define data schemas, so they’re a great fit for storing various kinds of differently structured documents (for example, a collection of YAML files containing movie metadata from multiple websites in different formats).</li>
				<li lang="en-GB"><strong class="bold" lang="">Graph databases</strong>: These<a id="_idIndexMarker287"/> are databases<a id="_idIndexMarker288"/> that store information in the form of <em class="italic" lang="">vertices</em> – objects that have different properties (for example, user details), and <em class="italic" lang="">edges</em> – the relationships between vertices (for example, if user A is following user B). Graph databases are different from relational databases in terms of the types of read queries they offer: most graph databases support <em class="italic" lang="">traversal</em> queries (checking each vertex in a graph), <em class="italic" lang="">connectivity</em> queries (getting all vertices connected to the target one), and many other ones.</li>
				<li lang="en-GB"><strong class="bold" lang="">Blob databases</strong>: These<a id="_idIndexMarker289"/> are databases for <a id="_idIndexMarker290"/>storing <em class="italic" lang="">blob</em> (binary large object) data, such as audio or video files. Blob records are generally immutable (their content never gets changed after a successful write), so blob databases are well optimized for <em class="italic" lang="">append-only</em> writes (such as writing new files), as well as blob reads (such as retrieving the contents of a large file).</li>
			</ul>
			<p lang="en-GB">We won’t go into the details of various types of databases because this is a topic for a separate book, but it is important to note that there is no <em class="italic" lang="">one-size-fits-all</em> solution among all of them, and each database provides a unique set of features that can be useful for solving a specific problem. For example, if the only purpose of your service is to store files, using a blob database would be sufficient, while a graph database could help with building a social network to store user relationship data. However, many use cases can be modeled using the relational model that powers relational databases: since it was introduced in 1970 by E.F. Codd, it has been used across the software development industry for nearly all types of problems. Popular relational databases, such as MySQL and PostgreSQL, remain the top-used software solutions, helping to build various types of applications, from tiny services running on a single host to large-scale clusters spanning hundreds of thousands of hosts. Because of the wide adoption and maturity of popular relational databases, many companies use them as a standard way to store various types of data. We are going to illustrate how to store our microservice data using a popular relational database: MySQL. </p>
			<h1 id="_idParaDest-105" lang="en-GB"><a id="_idTextAnchor106"/>Using MySQL to store our service data</h1>
			<p lang="en-GB">In this<a id="_idIndexMarker291"/> section, we are going to provide a brief overview of MySQL and demonstrate how to write and read data from the microservices that we created in the previous chapters.</p>
			<p lang="en-GB">MySQL is<a id="_idIndexMarker292"/> an open source relational database that was created in 1995 and since <a id="_idIndexMarker293"/>then has become one of the top-used databases across the development industry, according to DB-Engines ranking (<a href="https://db-engines.com/en/ranking">https://db-engines.com/en/ranking</a>). It stores data as a set of tables, each consisting of rows and columns of predefined types (such as string, numeric, binary, or more), and allows to data via SQL queries. For example, assume you have the following data, stored as a table<a id="_idIndexMarker294"/> called <strong class="bold" lang="">movies</strong>:</p>
			<table id="table001-2" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p lang="en-GB">id</p>
						</td>
						<td class="No-Table-Style">
							<p lang="en-GB">title</p>
						</td>
						<td class="No-Table-Style">
							<p lang="en-GB">director</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p lang="en-GB">922</p>
						</td>
						<td class="No-Table-Style">
							<p lang="en-GB">New York Stories</p>
						</td>
						<td class="No-Table-Style">
							<p lang="en-GB">John Jones</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p lang="en-GB">1055</p>
						</td>
						<td class="No-Table-Style">
							<p lang="en-GB">Christmas Day</p>
						</td>
						<td class="No-Table-Style">
							<p lang="en-GB">Ben Miles</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p lang="en-GB">1057</p>
						</td>
						<td class="No-Table-Style">
							<p lang="en-GB">Sunny Weather 3</p>
						</td>
						<td class="No-Table-Style">
							<p lang="en-GB">Ben Miles</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 7.1 – Movie table example</p>
			<p lang="en-GB">A SQL query to get all movies filmed by a particular director would look as follows:</p>
			<pre class="source-code" lang="en-GB">
SELECT * FROM movies WHERE director = "Ben Miles"</pre>
			<p lang="en-GB">Now, let’s imagine we have in the same database <a id="_idIndexMarker295"/>called <strong class="bold" lang="">ratings</strong> that contains the following data:</p>
			<table id="table002" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p lang="en-GB">record_id</p>
						</td>
						<td class="No-Table-Style">
							<p lang="en-GB">record_type</p>
						</td>
						<td class="No-Table-Style">
							<p lang="en-GB">user_id</p>
						</td>
						<td class="No-Table-Style">
							<p lang="en-GB">rating</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p lang="en-GB">1055</p>
						</td>
						<td class="No-Table-Style">
							<p lang="en-GB">movie</p>
						</td>
						<td class="No-Table-Style">
							<p lang="en-GB">alex001</p>
						</td>
						<td class="No-Table-Style">
							<p lang="en-GB">5</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p lang="en-GB">1055</p>
						</td>
						<td class="No-Table-Style">
							<p lang="en-GB">movie</p>
						</td>
						<td class="No-Table-Style">
							<p lang="en-GB">chris.rocks</p>
						</td>
						<td class="No-Table-Style">
							<p lang="en-GB">3</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p lang="en-GB">1057</p>
						</td>
						<td class="No-Table-Style">
							<p lang="en-GB">movie</p>
						</td>
						<td class="No-Table-Style">
							<p lang="en-GB">alex001</p>
						</td>
						<td class="No-Table-Style">
							<p lang="en-GB">4</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 7.2 – Rating table example</p>
			<p lang="en-GB">Using <a id="_idIndexMarker296"/>SQL language, we can write a more complex query to get all ratings that are associated with movies of a certain director:</p>
			<pre class="source-code" lang="en-GB">
SELECT * FROM ratings r INNER JOIN movies m ON r.record_id = m.id WHERE r.record_type = "movie" AND m.director = "Ben Miles"</pre>
			<p lang="en-GB">In our SQL query, we perform a <strong class="bold" lang="">join</strong> of two tables – an operation that allows us to group the data belonging to two tables and perform additional filtering (in our case, we will only select rating events where the <strong class="bold" lang="">record_type</strong> column’s value is equal to <em class="italic" lang="">movie</em> and the <strong class="bold" lang="">director</strong> column’s value is equal to <em class="italic" lang="">Ben Miles</em>).</p>
			<p lang="en-GB">To <a id="_idIndexMarker297"/>demonstrate how to use MySQL to store our service data, let’s define which data we want to store and how we want to access it. Let’s start with the metadata service, which performs two data storage operations:</p>
			<ul>
				<li lang="en-GB">Stores movie metadata for a given movie ID</li>
				<li lang="en-GB">Gets movie metadata for a given movie ID</li>
			</ul>
			<p lang="en-GB">Now, let’s review <a id="_idIndexMarker298"/>the data schema of the movie metadata object. Our movie metadata contains the following fields:</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">ID</strong>: String</li>
				<li lang="en-GB"><strong class="bold" lang="">Title</strong>: String</li>
				<li lang="en-GB"><strong class="bold" lang="">Description</strong>: String</li>
				<li lang="en-GB"><strong class="bold" lang="">Director</strong>: String</li>
			</ul>
			<p lang="en-GB">Now, let’s see which data is stored by our rating service, which performs the following storage-related operations:</p>
			<ul>
				<li lang="en-GB">Stores a rating for a given record (identified by a combination of a record ID and its type)</li>
				<li lang="en-GB">Gets all ratings for a given record</li>
			</ul>
			<p lang="en-GB">Let’s <a id="_idIndexMarker299"/>review the <a id="_idIndexMarker300"/>data schema of a rating:</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">User ID</strong>: String</li>
				<li lang="en-GB"><strong class="bold" lang="">Record ID</strong>: String</li>
				<li lang="en-GB"><strong class="bold" lang="">Record type</strong>: String</li>
				<li lang="en-GB"><strong class="bold" lang="">Rating value</strong>: Integer</li>
			</ul>
			<p lang="en-GB">At this point, we know which data we want to store in the database and can set up our database. We will use a Docker version of MySQL that you can run by executing the following command:</p>
			<pre class="source-code" lang="en-GB">
docker run --name movieexample_db -e MYSQL_ROOT_PASSWORD=password -e MYSQL_DATABASE=movieexample -p 3306:3306 -d mysql:latest</pre>
			<p lang="en-GB">In our<a id="_idIndexMarker301"/> command, we set the password for the MySQL root user to <strong class="source-inline" lang="">password</strong> so that we can use it for testing. We also set the database name to <strong class="source-inline" lang="">movieexample</strong> and exposed it on port <strong class="source-inline" lang="">3306</strong> so that we can use it to access our MySQL database.</p>
			<p lang="en-GB">Let’s verify that our container started successfully. Run the following command to see the list of running Docker containers:</p>
			<pre class="source-code" lang="en-GB">
docker ps</pre>
			<p lang="en-GB">The output should include a container with a <strong class="source-inline" lang="">movieexample_db</strong> name, a <strong class="source-inline" lang="">mysql:latest</strong> image, and an <strong class="source-inline" lang="">Up</strong> status.</p>
			<p lang="en-GB">The next step is to create our data schema. We will define it in a separate folder in our <strong class="source-inline" lang="">src</strong> directory, called <strong class="source-inline" lang="">schema</strong>. Create this directory and a <strong class="source-inline" lang="">schema.sql</strong> file in it, and add the following code to the newly created file:</p>
			<pre class="source-code" lang="en-GB">
CREATE TABLE IF NOT EXISTS movies (id VARCHAR(255), title VARCHAR(255), description TEXT, director VARCHAR(255));
CREATE TABLE IF NOT EXISTS ratings (record_id VARCHAR(255), record_type VARCHAR(255), user_id VARCHAR(255), value INT);</pre>
			<p lang="en-GB">In our schema file, we define two tables, called <strong class="source-inline" lang="">movies</strong> and <strong class="source-inline" lang="">ratings</strong>. The tables that we just defined consist of <strong class="source-inline" lang="">VARCHAR(255)</strong> and <strong class="source-inline" lang="">TEXT</strong> columns. <strong class="source-inline" lang="">VARCHAR</strong> is a MySQL type for storing string data, and <strong class="source-inline" lang="">255</strong> is the maximal size of a column value. <strong class="source-inline" lang="">TEXT</strong> is another MySQL type that is often used for storing long text records, so we used it for storing movie descriptions that may contain long texts.</p>
			<p lang="en-GB">Now, let’s <a id="_idIndexMarker302"/>connect to our newly provisioned database and initialize our data schema. Run the following command inside the <strong class="source-inline" lang="">src</strong> directory of our project:</p>
			<pre class="source-code" lang="en-GB">
docker exec -i movieexample_db mysql movieexample -h localhost -P 3306 --protocol=tcp -uroot -ppassword &lt; schema/schema.sql</pre>
			<p lang="en-GB">If everything <a id="_idIndexMarker303"/>worked correctly, our database should be ready to use. You can check if the tables were created successfully by running the following command:</p>
			<pre class="source-code" lang="en-GB">
docker exec -i movieexample_db mysql movieexample -h localhost -P 3306 --protocol=tcp -uroot -ppassword -e "SHOW tables"</pre>
			<p lang="en-GB">The output of the preceding command should include our two tables:</p>
			<pre class="source-code" lang="en-GB">
Tables_in_movieexample
movies
ratings</pre>
			<p lang="en-GB">We are ready to<a id="_idIndexMarker304"/> implement the logic to write and read from it. Create a <strong class="source-inline" lang="">metadata/internal/repository/mysql</strong> directory and add a file called <strong class="source-inline" lang="">mysql.go</strong> to it <a id="_idIndexMarker305"/>with the following contents:</p>
			<pre class="source-code" lang="en-GB">
package mysql
import (
    "context"
    "database/sql"
    "metadata/pkg/model"
    _ "github.com/go-sql-driver/mysql"
    "movieexample.com/metadata/internal/repository"
    "movieexample.com/metadata/pkg/model"
)
// Repository defines a MySQL-based movie matadata repository.
type Repository struct {
    db *sql.DB
}
// New creates a new MySQL-based repository.
func New() (*Repository, error) {
    db, err := sql.Open("mysql", "root:password@/movieexample")
    if err != nil {
        return nil, err
    }
    return &amp;Repository{db}, nil
}</pre>
			<p lang="en-GB">In <a id="_idIndexMarker306"/>our code, we defined a MySQL-based repository<a id="_idIndexMarker307"/> that we will use to store and retrieve the movie metadata. Note that we added the following line to our imports:</p>
			<pre class="source-code" lang="en-GB">
_ "github.com/go-sql-driver/mysql"</pre>
			<p lang="en-GB">The line that we added initializes a <a id="_idIndexMarker308"/>Go MySQL <strong class="bold" lang="">driver</strong>, which is required to access our MySQL database. We also used <strong class="source-inline" lang="">root:password@/movieexample</strong> inside our <strong class="source-inline" lang="">New</strong> function – the value is called a <strong class="bold" lang="">connection string</strong> and<a id="_idIndexMarker309"/> it includes the name of the user, its password, and the name of the database to be connected. The connection string may also include the name of the host, MySQL port, and other values, but we don’t need to set them as we are using the default values to access the local version of MySQL.</p>
			<p class="callout-heading" lang="en-GB">Important Note</p>
			<p class="callout" lang="en-GB">Please note that storing database credentials in code is a bad practice, and it is recommended to store such data (often called <em class="italic" lang="">secrets</em>) separately: for example, as separate configuration files. In <a href="B18865_08.xhtml#_idTextAnchor109"><em class="italic" lang="">Chapter 8</em></a>, we will review how to create and use configuration files with Go microservices.</p>
			<p lang="en-GB">Now, add <a id="_idIndexMarker310"/>the following code to the file that we just created:</p>
			<pre class="source-code" lang="en-GB">
// Get retrieves movie metadata for by movie id.
func (r *Repository) Get(ctx context.Context, id string) (*model.Metadata, error) {
    var title, description, director string
    row := r.db.QueryRowContext(ctx, "SELECT title, description, director FROM movies WHERE id = ?", id)
    if err := row.Scan(&amp;title, &amp;description, &amp;director); err != nil {
        if err == sql.ErrNoRows {
            return nil, repository.ErrNotFound
        }
        return nil, err
    }
    return &amp;model.Metadata{
        ID:          id,
        Title:       title,
        Description: description,
        Director:    director,
    }, nil
}
// Put adds movie metadata for a given movie id.
func (r *Repository) Put(ctx context.Context, id string, metadata *model.Metadata) error {
    _, err := r.db.ExecContext(ctx, "INSERT INTO movies (id, title, description, director) VALUES (?, ?, ?, ?)",
        id, metadata.Title, metadata.Description, metadata.Director)
    return err
}</pre>
			<p lang="en-GB">In <a id="_idIndexMarker311"/>our code, we implemented the <strong class="source-inline" lang="">Get</strong> and <strong class="source-inline" lang="">Put</strong> functions so that <a id="_idIndexMarker312"/>we can store and retrieve the movie metadata from MySQL. Inside our <strong class="source-inline" lang="">Get</strong> function, we use the <strong class="source-inline" lang="">QueryRowContext</strong> function of our database instance to read a single row from our table. In the case of a query error, we check if it is equal to <strong class="source-inline" lang="">sql.ErrNoRows</strong>; if so, we return <strong class="source-inline" lang="">ErrNotFound</strong>.</p>
			<p lang="en-GB">Now, let’s implement<a id="_idIndexMarker313"/> our MySQL rating repository. Create a <strong class="source-inline" lang="">rating/internal/repository/mysql</strong> directory and add a <strong class="source-inline" lang="">mysql.go</strong> file to it with the following contents:</p>
			<pre class="source-code" lang="en-GB">
package mysql
import (
    "context"
    "database/sql"
    "rating/pkg/model"
    _ "github.com/go-sql-driver/mysql"
    "movieexample.com/rating/internal/repository"
    "movieexample.com/rating/pkg/model"
)
// Repository defines a MySQL-based rating repository.
type Repository struct {
    db *sql.DB
}
// New creates a new MySQL-based rating repository.
func New() (*Repository, error) {
    db, err := sql.Open("mysql", "root:password@/movieexample")
    if err != nil {
        return nil, err
    }
    return &amp;Repository{db}, nil
}</pre>
			<p lang="en-GB">So far, our <a id="_idIndexMarker314"/>rating repository code is similar to the metadata<a id="_idIndexMarker315"/> repository. Inside the same file, let’s implement two functions to read and write rating data:</p>
			<pre class="source-code" lang="en-GB">
// Get retrieves all ratings for a given record.
func (r *Repository) Get(ctx context.Context, recordID model.RecordID, recordType model.RecordType) ([]model.Rating, error) {
    rows, err := r.db.QueryContext(ctx, "SELECT user_id, value FROM ratings WHERE record_id = ? AND record_type = ?", recordID, recordType)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    var res []model.Rating
    for rows.Next() {
        var userID string
        var value int32
        if err := rows.Scan(&amp;userID, &amp;value); err != nil {
            return nil, err
        }
        res = append(res, model.Rating{
            UserID: model.UserID(userID),
            Value:  model.RatingValue(value),
        })
    }
    if len(res) == 0 {
        return nil, repository.ErrNotFound
    }
    return res, nil
}
// Put adds a rating for a given record.
func (r *Repository) Put(ctx context.Context, recordID model.RecordID, recordType model.RecordType, rating *model.Rating) error {
    _, err := r.db.ExecContext(ctx, "INSERT INTO ratings (record_id, record_type, user_id, value) VALUES (?, ?, ?, ?)",
        recordID, recordType, rating.UserID, rating.Value)
    return err
}</pre>
			<p lang="en-GB">In <a id="_idIndexMarker316"/>our <strong class="source-inline" lang="">Get</strong> handler, we use the <strong class="source-inline" lang="">Query</strong> function to read<a id="_idIndexMarker317"/> rating rows from our table. We scan each row by calling the <strong class="source-inline" lang="">rows.Scan</strong> function, converting MySQL data into the necessary structures.</p>
			<p lang="en-GB">Our repository code is ready, so we can import the newly used package, <strong class="source-inline" lang="">github.com/go-sql-driver/mysql</strong>, by running the following command:</p>
			<pre class="source-code" lang="en-GB">
go mod tidy</pre>
			<p lang="en-GB">Let’s verify that our logic is correct by manually testing the rating repository:</p>
			<ol>
				<li lang="en-GB">Inside the <strong class="source-inline" lang="">rating/cmd/main.go</strong> file, change the <strong class="source-inline" lang="">movieexample.com/rating/internal/repository/memory</strong> import to <strong class="source-inline" lang="">movieexample.com/rating/internal/repository/mysql</strong>.</li>
				<li lang="en-GB">Inside the same file, find the following block:</li>
			</ol>
			<pre class="source-code" lang="en-GB">
repo := memory.New()</pre>
			<ol>
				<li lang="en-GB" value="3">Change it to the following:</li>
			</ol>
			<pre class="source-code" lang="en-GB">
repo := mysql.New()
if err != nil {
    panic(err)
}</pre>
			<ol>
				<li lang="en-GB" value="4">Navigate<a id="_idIndexMarker318"/> to the <strong class="source-inline" lang="">cmd</strong> directory of the rating service and run the following command:</li>
			</ol>
			<pre class="source-code" lang="en-GB">
go run *.go</pre>
			<ol>
				<li lang="en-GB" value="5">Make a manual request to write a rating:</li>
			</ol>
			<pre class="source-code" lang="en-GB">
grpcurl -plaintext -d '{"record_id":"1", "record_type": "movie"}' localhost:8082 RatingService/GetAggregatedRating</pre>
			<p lang="en-GB">You should see the following message:</p>
			<pre class="source-code" lang="en-GB">
ERROR:
  Code: NotFound
  Message: ratings not found for a record</pre>
			<ol>
				<li lang="en-GB" value="6">Now, let’s<a id="_idIndexMarker319"/> write a rating to test that our database works correctly. Execute the following command:</li>
			</ol>
			<pre class="source-code" lang="en-GB">
grpcurl -plaintext -d '{"record_id":"1", "record_type": "movie", "user_id": "alex", "rating_value": 5}' localhost:8082 RatingService/PutRating</pre>
			<ol>
				<li lang="en-GB" value="7">Now, let’s fetch <a id="_idIndexMarker320"/>an updated rating for the same movie. Execute the same command as in <em class="italic" lang="">step 4</em>:</li>
			</ol>
			<pre class="source-code" lang="en-GB">
grpcurl -plaintext -d '{"record_id":"1", "record_type": "movie"}' localhost:8082 RatingService/GetAggregatedRating</pre>
			<ol>
				<li lang="en-GB" value="8">You should get the following response:</li>
			</ol>
			<pre class="source-code" lang="en-GB">
{
  "ratingValue": 5
}</pre>
			<p lang="en-GB">Hooray, we just confirmed that our repository logic works! You can now shut down the rating service, rerun it, and repeat <em class="italic" lang="">step 6</em>. When you do this, you will get the same result, and this will confirm that our data is persistent now and does not get impacted by service restarts.</p>
			<h1 id="_idParaDest-106" lang="en-GB"><a id="_idTextAnchor107"/>Summary</h1>
			<p lang="en-GB">In this chapter, we provided a brief overview of database storage solutions for storing microservice data. We illustrated how to write the logic for writing and reading our service data into MySQL, a popular open source relational database that is widely used across the software development industry. </p>
			<p lang="en-GB">In the next chapter, we are going to illustrate how to build and run our service instances using a popular platform, Kubernetes, that allows us to coordinate various service-related operations, such as code updates, automated service instance count increases, and many more.</p>
			<h1 id="_idParaDest-107" lang="en-GB"><a id="_idTextAnchor108"/>Further reading</h1>
			<p lang="en-GB">To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
			<ul>
				<li lang="en-GB">Types of databases: <a href="https://www.prisma.io/dataguide/intro/comparing-database-types">https://www.prisma.io/dataguide/intro/comparing-database-types</a></li>
				<li lang="en-GB">DB engines ranking: <a href="https://db-engines.com/en/ranking">https://db-engines.com/en/ranking</a></li>
			</ul>
		</div>
	</body></html>