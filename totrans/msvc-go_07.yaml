- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Storing Service Data
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储服务数据
- en: 'In this chapter, we are going to review a very important topic: storing service
    data in persistent databases. In the previous chapters, we stored movie metadata
    and user ratings using in-memory repositories. While it was easy to implement
    in-memory storages of our data, using them would be impractical due to many reasons.
    One such reason is a lack of a persistence guarantee: if our service instances
    storing the data were restarted (for example, due to application failure or on
    host restart), we would lose all our data that was stored in the memory of a previously
    running instance. To guarantee that our data won’t be lost over time, we need
    a solution that can persist our data and allow us to read and write it to our
    microservices. Among such solutions are databases, which we are going to review
    in this chapter.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾一个非常重要的主题：在持久数据库中存储服务数据。在前几章中，我们使用内存存储库存储和检索电影元数据和用户评分。虽然实现内存存储数据很容易，但由于许多原因，使用它们将是不切实际的。其中一个原因是缺乏持久性保证：如果存储数据的我们的服务实例重启（例如，由于应用程序故障或主机重启），我们就会丢失存储在先前运行的实例内存中的所有数据。为了确保我们的数据不会随时间丢失，我们需要一个可以持久化我们的数据并允许我们在微服务中读取和写入它的解决方案。此类解决方案中包括数据库，我们将在本章中对其进行回顾。
- en: 'We will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Introduction to databases
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库简介
- en: Using MySQL to store our service data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MySQL存储我们的服务数据
- en: Let’s proceed to the first section of this chapter, which will provide an overview
    of microservice persistent storage solutions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续本章的第一部分，它将概述微服务持久存储解决方案。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you will need Go 1.11+ or above. Additionally, you
    will need the following tools:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章，你需要Go 1.11或更高版本。此外，你还需要以下工具：
- en: '**Docker**: https://www.docker.com'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker**: https://www.docker.com'
- en: '**grpcurl**: [https://github.com/fullstorydev/grpcurl](https://github.com/fullstorydev/grpcurl)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**grpcurl**: [https://github.com/fullstorydev/grpcurl](https://github.com/fullstorydev/grpcurl)'
- en: 'You can find the GitHub code for this chapter here: https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter07.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到本章的GitHub代码：https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter07。
- en: Introduction to databases
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库简介
- en: '**Databases** are systems that allow us to store and retrieve different types
    of data. Databases offer a variety of guarantees related to data storage, such
    as **durability** – a guarantee that all records and any related data changes
    will be persistent over time. A durability guarantee helps ensure that the data
    stored in a database won’t be lost in case of various events such as software
    and hardware restarts, which are pretty common for microservices'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据库**是允许我们存储和检索不同类型数据的系统。数据库提供了与数据存储相关的各种保证，例如**持久性** – 一个保证所有记录以及任何相关的数据更改都将随时间持久化的保证。持久性保证有助于确保存储在数据库中的数据在软件和硬件重启等事件中不会丢失，这对于微服务来说相当常见。'
- en: 'Databases help solve lots of different other problems related to data storage.
    Let’s illustrate one such problem using the metadata service that we created in
    [*Chapter 2*](B18865_02.xhtml#_idTextAnchor027). In our metadata service code,
    we implemented an in-memory repository for storing and retrieving the movie data
    that provides two functions, `Get` and `Put`. If we have just one instance of
    the metadata service, all its callers would be able to successfully write and
    read metadata records from the service memory, so long as a service instance does
    not perform a restart. However, let’s imagine that we add another instance of
    a metadata service, as illustrated in the following diagram:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库有助于解决与数据存储相关的许多其他问题。让我们用一个我们创建在[*第二章*](B18865_02.xhtml#_idTextAnchor027)中的元数据服务来说明这样一个问题。在我们的元数据服务代码中，我们实现了一个内存存储库来存储和检索电影数据，它提供了两个函数，`Get`和`Put`。如果我们只有一个元数据服务实例，所有调用者都能够成功从服务内存中写入和读取元数据记录，只要服务实例不重启。然而，让我们想象一下，我们添加了另一个元数据服务实例，如下面的图所示：
- en: '![Figure 7.1 – Interaction between the movie service and two instances of the
    metadata service'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 – 电影服务与两个元数据服务实例之间的交互'
- en: '](img/Figure_7.1_B18865.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.1_B18865.jpg)'
- en: Figure 7.1 – Interaction between the movie service and two instances of the
    metadata service
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 电影服务与两个元数据服务实例之间的交互
- en: Imagine that the movie service wants to write movie metadata and calls the metadata
    service to do this. The movie service instance would pick an instance of a metadata
    service (let’s assume it picks instance 0) and send a write request to it, storing
    the record in memory of the instance that processes the request.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 假设电影服务想要写入电影元数据，并调用元数据服务来完成此操作。电影服务实例会选择一个元数据服务的实例（让我们假设它选择了实例 0）并向其发送一个写入请求，将记录存储在处理请求的实例的内存中。
- en: 'Now, let’s assume the movie service wants to read the previously stored movie
    metadata and sends a read request to the metadata service. Depending on which
    instance handles the request, there would be two possible outcomes:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设电影服务想要读取之前存储的电影元数据，并向元数据服务发送一个读取请求。根据处理请求的实例，可能会有两种可能的后果：
- en: '**Instance 0**: Successfully return the previously saved movie metadata'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实例 0**：成功返回之前保存的电影元数据'
- en: '`ErrNotFound`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ErrNotFound`'
- en: 'We just illustrated a case where the data is inconsistent between the two instances
    of the metadata repository. Because we have not implemented any coordination between
    our in-memory metadata repositories, each one acts as an independent data storage.
    Using our metadata service in such a way would be highly impractical: each newly
    added service instance would store a completely independent dataset.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚展示了在元数据仓库的两个实例之间数据不一致的情况。因为我们没有在我们的内存元数据仓库之间实现任何协调，每个仓库都作为一个独立的数据存储。以这种方式使用我们的元数据服务将非常不切实际：每个新添加的服务实例都会存储一个完全独立的数据集。
- en: 'To solve our data inconsistency problem, we can use a database to store the
    movie metadata: a database will handle all writes and reads from all the available
    metadata service instances, helping to co-locate the data from them inside a single
    type of logical storage. Such a scenario is illustrated in the following diagram:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决我们的数据不一致问题，我们可以使用数据库来存储电影元数据：数据库将处理来自所有可用元数据服务实例的所有写入和读取操作，帮助将它们的数据集中存储在单一类型的逻辑存储中。以下图示了这种情况：
- en: '![Figure 7.2 – Using a shared metadata database among multiple instances'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.2 – 在多个实例间使用共享元数据数据库'
- en: '](img/Figure_7.2_B18865.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.2 – 在多个实例间使用共享元数据数据库](img/Figure_7.2_B18865.jpg)'
- en: Figure 7.2 – Using a shared metadata database among multiple instances
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 在多个实例间使用共享元数据数据库
- en: In our diagram, multiple instances of a metadata service are using a shared
    database. This helps us aggregate and store the data coming from different metadata
    service instances.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的图中，多个元数据服务的实例正在使用一个共享数据库。这有助于我们聚合和存储来自不同元数据服务实例的数据。
- en: 'We just illustrated how a database can help provide data durability to our
    services. There are other benefits that this can provide:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚展示了数据库如何帮助为我们的服务提供数据持久性。这还可以提供其他好处：
- en: '**Transaction support**: Many databases support transactions – types of data
    changes – that have the following properties, abbreviated as **ACID**:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务支持**：许多数据库支持事务 – 数据变更的类型 – 它们具有以下属性，简称为 **ACID**：'
- en: '**Atomicity**: A change either happens entirely or does not happen at all'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子性**：一个变更要么完全发生，要么完全不发生'
- en: '**Consistency**: A change brings a database from one valid state to another'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：一个变更将数据库从一个有效状态带到另一个有效状态'
- en: '**Isolation**: Concurrent changes get executed as they were executed sequentially'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离性**：并发变更按顺序执行'
- en: '**Durability**: All changes get persisted'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**：所有变更都会被持久化'
- en: These transaction properties help provide a reliable way to modify different
    types of data (for example, simultaneously updating two financial account balances).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事务属性帮助提供了一种可靠的方式来修改不同类型的数据（例如，同时更新两个财务账户余额）。
- en: '**Data replication**: A database can offer data replication – a mechanism of
    duplicating data to additional instances, called **replicas**. Replication can
    help make the database more resilient to data losses (for example, when a database
    host becomes unavailable, data can be accessed on its replica) and reduce read
    latency (for example, when a user reads data from a replica that is located closer
    to them).'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据复制**：数据库可以提供数据复制 – 将数据复制到额外的实例，称为 **副本**。复制可以帮助使数据库对数据丢失更具弹性（例如，当数据库主机不可用时，可以在其副本上访问数据）并减少读取延迟（例如，当用户从位于更近处的副本读取数据时）。'
- en: '**Additional query capabilities**: There are many databases (such as MySQL
    and PostgreSQL), that offer support for different query languages, such as SQL
    ([https://en.wikipedia.org/wiki/SQL](https://en.wikipedia.org/wiki/SQL)).'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**额外的查询功能**：有许多数据库（如MySQL和PostgreSQL），提供对不同的查询语言的支持，例如SQL ([https://en.wikipedia.org/wiki/SQL](https://en.wikipedia.org/wiki/SQL))).'
- en: 'Different types of databases can help you efficiently store and retrieve various
    types of data. Let’s review some of these popular database types:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 不同类型的数据库可以帮助您高效地存储和检索各种类型的数据。让我们回顾一些这些流行的数据库类型：
- en: '**Key-value databases**: These are databases that store data in key-value format,
    where each record contains a key (for example, user identifier) and a value (for
    example, user metadata). Keys and values are often represented as strings or byte
    arrays. Operations provided by key-value databases are often limited to key-based
    writes (store a value for the provided key) and key-based reads (read a value
    for the provided key). Because of their functional simplicity, key-value databases
    are among the most performant, since they don’t involve any complex data processing
    or indexing.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**键值数据库**：这些数据库以键值格式存储数据，其中每条记录包含一个键（例如，用户标识符）和一个值（例如，用户元数据）。键和值通常表示为字符串或字节数组。键值数据库提供的操作通常限于基于键的写入（为提供的键存储值）和基于键的读取（为提供的键读取值）。由于它们的函数简单性，键值数据库在性能方面表现优异，因为它们不涉及任何复杂的数据处理或索引。'
- en: '**Relational databases**: These are databases that store the data as a collection
    of tables, each consisting of a set of rows and columns. Users can run SQL queries
    to retrieve the data from one or multiple tables, being able to join the data
    between them or perform complex searching based on a variety of conditions. Historically,
    relational databases have been the most popular across all database types due
    to their ability to execute queries of any complexity, as well as their ability
    to store various types of structured (having a well-defined schema that maps row
    data to table columns) data.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关系数据库**：这些数据库将数据存储为表的集合，每个表由一组行和列组成。用户可以运行SQL查询从单个或多个表中检索数据，能够将它们之间的数据进行连接或根据各种条件执行复杂搜索。历史上，由于它们能够执行任何复杂度的查询以及存储各种类型的结构化数据（具有将行数据映射到表列的明确模式），关系数据库在所有数据库类型中一直是最受欢迎的。'
- en: '**Document databases**: These are databases that store data in a document format,
    such as JSON or XML. Document databases don’t require you to define data schemas,
    so they’re a great fit for storing various kinds of differently structured documents
    (for example, a collection of YAML files containing movie metadata from multiple
    websites in different formats).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档数据库**：这些数据库以文档格式存储数据，例如JSON或XML。文档数据库不需要您定义数据模式，因此非常适合存储各种不同结构的文档（例如，包含来自多个网站、不同格式的电影元数据的YAML文件集合）。'
- en: '**Graph databases**: These are databases that store information in the form
    of *vertices* – objects that have different properties (for example, user details),
    and *edges* – the relationships between vertices (for example, if user A is following
    user B). Graph databases are different from relational databases in terms of the
    types of read queries they offer: most graph databases support *traversal* queries
    (checking each vertex in a graph), *connectivity* queries (getting all vertices
    connected to the target one), and many other ones.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图数据库**：这些数据库以*顶点*的形式存储信息——具有不同属性的对象（例如，用户详细信息），以及*边*——顶点之间的关系（例如，如果用户A正在关注用户B）。图数据库在提供的读取查询类型方面与关系数据库不同：大多数图数据库支持*遍历*查询（检查图中的每个顶点）、*连通性*查询（获取与目标顶点相连的所有顶点），以及许多其他查询。'
- en: '**Blob databases**: These are databases for storing *blob* (binary large object)
    data, such as audio or video files. Blob records are generally immutable (their
    content never gets changed after a successful write), so blob databases are well
    optimized for *append-only* writes (such as writing new files), as well as blob
    reads (such as retrieving the contents of a large file).'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Blob数据库**：这些数据库用于存储*Blob*（二进制大对象）数据，例如音频或视频文件。Blob记录通常是不可变的（在成功写入后其内容不会改变），因此Blob数据库非常适合于*追加写入*（例如写入新文件），以及Blob读取（例如检索大文件的内容）。'
- en: 'We won’t go into the details of various types of databases because this is
    a topic for a separate book, but it is important to note that there is no *one-size-fits-all*
    solution among all of them, and each database provides a unique set of features
    that can be useful for solving a specific problem. For example, if the only purpose
    of your service is to store files, using a blob database would be sufficient,
    while a graph database could help with building a social network to store user
    relationship data. However, many use cases can be modeled using the relational
    model that powers relational databases: since it was introduced in 1970 by E.F.
    Codd, it has been used across the software development industry for nearly all
    types of problems. Popular relational databases, such as MySQL and PostgreSQL,
    remain the top-used software solutions, helping to build various types of applications,
    from tiny services running on a single host to large-scale clusters spanning hundreds
    of thousands of hosts. Because of the wide adoption and maturity of popular relational
    databases, many companies use them as a standard way to store various types of
    data. We are going to illustrate how to store our microservice data using a popular
    relational database: MySQL.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨各种数据库类型，因为这是一个单独书籍的主题，但重要的是要注意，在它们中并没有一个 **万能** 的解决方案，每个数据库都提供一组独特的功能，这些功能可以用于解决特定问题。例如，如果你的服务唯一目的是存储文件，使用
    blob 数据库就足够了，而图数据库可以帮助构建社交网络以存储用户关系数据。然而，许多用例可以使用关系模型来建模，该模型是关系数据库的基石：自 1970 年由
    E.F. Codd 提出，它已在软件开发行业中用于几乎所有类型的问题。流行的关系型数据库，如 MySQL 和 PostgreSQL，仍然是使用最广泛的软件解决方案，帮助构建各种类型的应用程序，从小型单主机运行的服务到跨越数十万个主机的超大规模集群。由于流行关系型数据库的广泛采用和成熟，许多公司将它们作为存储各种类型数据的标准方式。我们将展示如何使用流行的关系型数据库：MySQL
    来存储我们的微服务数据。
- en: Using MySQL to store our service data
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MySQL 存储我们的服务数据
- en: In this section, we are going to provide a brief overview of MySQL and demonstrate
    how to write and read data from the microservices that we created in the previous
    chapters.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要介绍 MySQL 并演示如何从我们在前几章中创建的微服务中写入和读取数据。
- en: 'MySQL is an open source relational database that was created in 1995 and since
    then has become one of the top-used databases across the development industry,
    according to DB-Engines ranking ([https://db-engines.com/en/ranking](https://db-engines.com/en/ranking)).
    It stores data as a set of tables, each consisting of rows and columns of predefined
    types (such as string, numeric, binary, or more), and allows to data via SQL queries.
    For example, assume you have the following data, stored as a table called **movies**:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 是一个开源的关系型数据库，它于 1995 年创建，根据 DB-Engines 排名（[https://db-engines.com/en/ranking](https://db-engines.com/en/ranking)），自那时起已成为开发行业中最常用的数据库之一。它将数据存储为一系列表，每个表由预定义类型的行和列组成（例如字符串、数值、二进制等），并允许通过
    SQL 查询来访问数据。例如，假设你有以下数据，存储在一个名为 **movies** 的表中：
- en: '| id | title | director |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| id | title | director |'
- en: '| 922 | New York Stories | John Jones |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 922 | New York Stories | John Jones |'
- en: '| 1055 | Christmas Day | Ben Miles |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 1055 | Christmas Day | Ben Miles |'
- en: '| 1057 | Sunny Weather 3 | Ben Miles |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 1057 | Sunny Weather 3 | Ben Miles |'
- en: Table 7.1 – Movie table example
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.1 – 电影表示例
- en: 'A SQL query to get all movies filmed by a particular director would look as
    follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取由特定导演拍摄的所有电影的 SQL 查询如下所示：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let’s imagine we have in the same database called **ratings** that contains
    the following data:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设在同一个名为 **ratings** 的数据库中包含以下数据：
- en: '| record_id | record_type | user_id | rating |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| record_id | record_type | user_id | rating |'
- en: '| 1055 | movie | alex001 | 5 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 1055 | movie | alex001 | 5 |'
- en: '| 1055 | movie | chris.rocks | 3 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 1055 | movie | chris.rocks | 3 |'
- en: '| 1057 | movie | alex001 | 4 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 1057 | movie | alex001 | 4 |'
- en: Table 7.2 – Rating table example
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.2 – 评分表示例
- en: 'Using SQL language, we can write a more complex query to get all ratings that
    are associated with movies of a certain director:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SQL 语言，我们可以编写一个更复杂的查询来获取与特定导演的电影相关的所有评分：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In our SQL query, we perform a **join** of two tables – an operation that allows
    us to group the data belonging to two tables and perform additional filtering
    (in our case, we will only select rating events where the **record_type** column’s
    value is equal to *movie* and the **director** column’s value is equal to *Ben
    Miles*).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 SQL 查询中，我们执行了两个表的 **连接** 操作 – 这是一个允许我们将两个表中的数据分组并执行额外过滤（在我们的情况下，我们只选择 **record_type**
    列的值等于 *movie* 且 **director** 列的值等于 *Ben Miles* 的评分事件）的操作。
- en: 'To demonstrate how to use MySQL to store our service data, let’s define which
    data we want to store and how we want to access it. Let’s start with the metadata
    service, which performs two data storage operations:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何使用MySQL存储我们的服务数据，让我们定义我们想要存储的数据以及我们想要如何访问它。让我们从元数据服务开始，它执行两个数据存储操作：
- en: Stores movie metadata for a given movie ID
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为给定电影ID存储电影元数据
- en: Gets movie metadata for a given movie ID
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取给定电影ID的电影元数据
- en: 'Now, let’s review the data schema of the movie metadata object. Our movie metadata
    contains the following fields:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾电影元数据对象的数据模式。我们的电影元数据包含以下字段：
- en: '**ID**: String'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ID**: 字符串'
- en: '**Title**: String'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标题**: 字符串'
- en: '**Description**: String'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**: 字符串'
- en: '**Director**: String'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导演**: 字符串'
- en: 'Now, let’s see which data is stored by our rating service, which performs the
    following storage-related operations:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看评分服务存储了哪些数据，该服务执行以下存储相关操作：
- en: Stores a rating for a given record (identified by a combination of a record
    ID and its type)
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储给定记录（通过记录ID及其类型组合标识）的评分
- en: Gets all ratings for a given record
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取给定记录的所有评分
- en: 'Let’s review the data schema of a rating:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾评分的数据模式：
- en: '**User ID**: String'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户ID**: 字符串'
- en: '**Record ID**: String'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录ID**: 字符串'
- en: '**Record type**: String'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录类型**: 字符串'
- en: '**Rating value**: Integer'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**评分值**: 整数'
- en: 'At this point, we know which data we want to store in the database and can
    set up our database. We will use a Docker version of MySQL that you can run by
    executing the following command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道我们想在数据库中存储哪些数据，并可以设置我们的数据库。我们将使用一个可以通过执行以下命令运行的MySQL Docker版本：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In our command, we set the password for the MySQL root user to `password` so
    that we can use it for testing. We also set the database name to `movieexample`
    and exposed it on port `3306` so that we can use it to access our MySQL database.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的命令中，我们将MySQL root用户的密码设置为`password`，以便我们可以用于测试。我们还设置了数据库名为`movieexample`，并在端口`3306`上公开，以便我们可以使用它来访问我们的MySQL数据库。
- en: 'Let’s verify that our container started successfully. Run the following command
    to see the list of running Docker containers:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证我们的容器是否成功启动。运行以下命令以查看正在运行的Docker容器列表：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The output should include a container with a `movieexample_db` name, a `mysql:latest`
    image, and an `Up` status.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应包括一个名为`movieexample_db`的容器，一个`mysql:latest`镜像，以及一个`Up`状态。
- en: 'The next step is to create our data schema. We will define it in a separate
    folder in our `src` directory, called `schema`. Create this directory and a `schema.sql`
    file in it, and add the following code to the newly created file:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建我们的数据模式。我们将在`src`目录的单独文件夹中定义它，称为`schema`。创建此目录并在其中创建一个`schema.sql`文件，然后将以下代码添加到新创建的文件中：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In our schema file, we define two tables, called `movies` and `ratings`. The
    tables that we just defined consist of `VARCHAR(255)` and `TEXT` columns. `VARCHAR`
    is a MySQL type for storing string data, and `255` is the maximal size of a column
    value. `TEXT` is another MySQL type that is often used for storing long text records,
    so we used it for storing movie descriptions that may contain long texts.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模式文件中，我们定义了两个表，分别称为`movies`和`ratings`。我们刚刚定义的表由`VARCHAR(255)`和`TEXT`列组成。`VARCHAR`是MySQL用于存储字符串数据的数据类型，`255`是列值的最大长度。`TEXT`是另一种MySQL数据类型，常用于存储长文本记录，因此我们使用它来存储可能包含长文本的电影描述。
- en: 'Now, let’s connect to our newly provisioned database and initialize our data
    schema. Run the following command inside the `src` directory of our project:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们连接到我们新配置的数据库并初始化我们的数据模式。在我们的项目`src`目录中运行以下命令：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If everything worked correctly, our database should be ready to use. You can
    check if the tables were created successfully by running the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，我们的数据库应该准备好使用。你可以通过运行以下命令来检查表是否已成功创建：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output of the preceding command should include our two tables:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令的输出应包括我们的两个表：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We are ready to implement the logic to write and read from it. Create a `metadata/internal/repository/mysql`
    directory and add a file called `mysql.go` to it with the following contents:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好实现写入和读取它的逻辑。创建一个`metadata/internal/repository/mysql`目录，并向其中添加一个名为`mysql.go`的文件，其内容如下：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In our code, we defined a MySQL-based repository that we will use to store
    and retrieve the movie metadata. Note that we added the following line to our
    imports:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们定义了一个基于MySQL的存储库，我们将使用它来存储和检索电影元数据。请注意，我们在导入中添加了以下行：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The line that we added initializes a Go MySQL `root:password@/movieexample`
    inside our `New` function – the value is called a **connection string** and it
    includes the name of the user, its password, and the name of the database to be
    connected. The connection string may also include the name of the host, MySQL
    port, and other values, but we don’t need to set them as we are using the default
    values to access the local version of MySQL.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的行在`New`函数中初始化了一个Go MySQL `root:password@/movieexample`连接 - 这个值被称为**连接字符串**，它包括用户名、密码和要连接的数据库名。连接字符串还可以包括主机名、MySQL端口和其他值，但因为我们正在使用默认值来访问本地版本的MySQL，所以我们不需要设置它们。
- en: Important Note
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Please note that storing database credentials in code is a bad practice, and
    it is recommended to store such data (often called *secrets*) separately: for
    example, as separate configuration files. In [*Chapter 8*](B18865_08.xhtml#_idTextAnchor109),
    we will review how to create and use configuration files with Go microservices.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，将数据库凭据存储在代码中是一种不良做法，建议将此类数据（通常称为*机密*)单独存储：例如，作为单独的配置文件。在[*第 8 章*](B18865_08.xhtml#_idTextAnchor109)中，我们将回顾如何使用Go微服务创建和使用配置文件。
- en: 'Now, add the following code to the file that we just created:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，向刚刚创建的文件中添加以下代码：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In our code, we implemented the `Get` and `Put` functions so that we can store
    and retrieve the movie metadata from MySQL. Inside our `Get` function, we use
    the `QueryRowContext` function of our database instance to read a single row from
    our table. In the case of a query error, we check if it is equal to `sql.ErrNoRows`;
    if so, we return `ErrNotFound`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们实现了`Get`和`Put`函数，以便我们可以从MySQL存储和检索电影元数据。在我们的`Get`函数内部，我们使用数据库实例的`QueryRowContext`函数从我们的表中读取一行。如果查询错误，我们检查它是否等于`sql.ErrNoRows`；如果是，我们返回`ErrNotFound`。
- en: 'Now, let’s implement our MySQL rating repository. Create a `rating/internal/repository/mysql`
    directory and add a `mysql.go` file to it with the following contents:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现我们的MySQL评分仓库。创建一个`rating/internal/repository/mysql`目录，并向其中添加一个`mysql.go`文件，内容如下：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So far, our rating repository code is similar to the metadata repository. Inside
    the same file, let’s implement two functions to read and write rating data:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的评分仓库代码与元数据仓库代码相似。在同一个文件中，让我们实现两个函数来读取和写入评分数据：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In our `Get` handler, we use the `Query` function to read rating rows from our
    table. We scan each row by calling the `rows.Scan` function, converting MySQL
    data into the necessary structures.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Get`处理程序中，我们使用`Query`函数从我们的表中读取评分行。我们通过调用`rows.Scan`函数扫描每一行，将MySQL数据转换为必要的结构。
- en: 'Our repository code is ready, so we can import the newly used package, `github.com/go-sql-driver/mysql`,
    by running the following command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的仓库代码已经准备好了，所以我们可以通过运行以下命令来导入新使用的包`github.com/go-sql-driver/mysql`：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s verify that our logic is correct by manually testing the rating repository:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过手动测试评分仓库来验证我们的逻辑是否正确：
- en: Inside the `rating/cmd/main.go` file, change the `movieexample.com/rating/internal/repository/memory`
    import to `movieexample.com/rating/internal/repository/mysql`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`rating/cmd/main.go`文件中，将`movieexample.com/rating/internal/repository/memory`导入更改为`movieexample.com/rating/internal/repository/mysql`。
- en: 'Inside the same file, find the following block:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个文件中，找到以下代码块：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Change it to the following:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其更改为以下内容：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Navigate to the `cmd` directory of the rating service and run the following
    command:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到评分服务的`cmd`目录，并运行以下命令：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Make a manual request to write a rating:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手动发送一个写入评分的请求：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should see the following message:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下信息：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let’s write a rating to test that our database works correctly. Execute
    the following command:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们写入一个评分来测试我们的数据库是否正确工作。执行以下命令：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let’s fetch an updated rating for the same movie. Execute the same command
    as in *step 4*:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们获取同一电影的更新评分。执行与*步骤 4*相同的命令：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You should get the following response:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该得到以下响应：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Hooray, we just confirmed that our repository logic works! You can now shut
    down the rating service, rerun it, and repeat *step 6*. When you do this, you
    will get the same result, and this will confirm that our data is persistent now
    and does not get impacted by service restarts.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 哈喽，我们刚刚确认我们的仓库逻辑是有效的！你现在可以关闭评分服务，重新运行它，并重复*步骤 6*。当你这样做时，你会得到相同的结果，这将确认我们的数据现在是持久的，并且不会受到服务重启的影响。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we provided a brief overview of database storage solutions
    for storing microservice data. We illustrated how to write the logic for writing
    and reading our service data into MySQL, a popular open source relational database
    that is widely used across the software development industry.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要概述了用于存储微服务数据的数据库存储解决方案。我们说明了如何将我们的服务数据写入MySQL的逻辑，MySQL是一个流行的开源关系型数据库，在软件开发行业中得到广泛应用。
- en: In the next chapter, we are going to illustrate how to build and run our service
    instances using a popular platform, Kubernetes, that allows us to coordinate various
    service-related operations, such as code updates, automated service instance count
    increases, and many more.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将展示如何使用流行的平台Kubernetes构建和运行我们的服务实例，该平台允许我们协调各种与服务相关的操作，例如代码更新、自动增加服务实例数量等。
- en: Further reading
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章所涉及的主题，请查看以下资源：
- en: 'Types of databases: [https://www.prisma.io/dataguide/intro/comparing-database-types](https://www.prisma.io/dataguide/intro/comparing-database-types)'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库类型：[https://www.prisma.io/dataguide/intro/comparing-database-types](https://www.prisma.io/dataguide/intro/comparing-database-types)
- en: 'DB engines ranking: [https://db-engines.com/en/ranking](https://db-engines.com/en/ranking)'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库引擎排名：[https://db-engines.com/en/ranking](https://db-engines.com/en/ranking)
