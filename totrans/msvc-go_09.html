<html><head></head><body>
		<div id="_idContainer036">
			<h1 id="_idParaDest-123" class="chapter-number" lang="en-GB"><a id="_idTextAnchor124"/>9</h1>
			<h1 id="_idParaDest-124" lang="en-GB"><a id="_idTextAnchor125"/>Unit and Integration Testing</h1>
			<p lang="en-GB">Testing <a id="_idIndexMarker374"/>is an integral part of any development process. It is always important to cover your code with automated tests, ensuring that all important logic is continuously tested on all code changes. Writing good tests often helps ensure that any changes made throughout the development process will keep the code working and reliable.</p>
			<p lang="en-GB">Testing is especially important in microservice development, but it brings some additional challenges to developers. It’s not enough to test each service – it’s also important to test the integrations between the services, ensuring every service can work with the others.</p>
			<p lang="en-GB">In this chapter, we will cover both unit testing and integration testing and illustrate how to add tests to the microservices we created in the previous chapters. We will cover the following topics:</p>
			<ul>
				<li lang="en-GB">Go testing overview</li>
				<li lang="en-GB">Unit tests</li>
				<li lang="en-GB">Integration tests</li>
				<li lang="en-GB">Testing best practices</li>
			</ul>
			<p lang="en-GB">You will learn how to write unit and integration tests in Go, how to use the mocking technique, and how to organize the testing code for your microservices. This knowledge will help you to build more reliable services.</p>
			<p lang="en-GB">Let’s proceed to the overview of Go testing tools and techniques.</p>
			<h1 id="_idParaDest-125" lang="en-GB"><a id="_idTextAnchor126"/>Technical requirements</h1>
			<p lang="en-GB">To complete this chapter, you need Go version 1.11+ or above.</p>
			<p lang="en-GB">You can find the GitHub code for this chapter here: <a href="https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter09">https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter09</a>.</p>
			<h1 id="_idParaDest-126" lang="en-GB"><a id="_idTextAnchor127"/>Go testing overview</h1>
			<p lang="en-GB">In <a id="_idIndexMarker375"/>this section, we are going to provide a high-level overview of Go’s testing capabilities. We will cover the basics of writing tests for Go code, list the useful functions and libraries provided with the Go SDK, and describe various techniques for writing tests that will help you in microservice development.</p>
			<p lang="en-GB">First, let’s cover the basics of writing tests for Go applications.</p>
			<p lang="en-GB">Go language has built-in support for writing automated tests and provides a package called <strong class="source-inline" lang="">testing</strong> for this purpose.</p>
			<p lang="en-GB">There is a conventional relationship between the Go code and its tests. If you have a file called <strong class="source-inline" lang="">example.go</strong>, its tests would reside in the same package in a file called <strong class="source-inline" lang="">example_test.go</strong>. Using a <strong class="source-inline" lang="">_test</strong> file name suffix allows you to differentiate between the code being tested and the tests for it, making it easier to navigate the source code.</p>
			<p lang="en-GB">Go test functions follow this conventional name format, with each test function name starting with the <strong class="source-inline" lang="">Test</strong> prefix:</p>
			<pre class="source-code" lang="en-GB">
func TestXxx(t *testing.T)</pre>
			<p lang="en-GB">Inside these functions, you can use the <strong class="source-inline" lang="">testing.T</strong> structure to report test failures or use any additional helper functions provided by it.</p>
			<p lang="en-GB">Let’s take this test as an example:</p>
			<pre class="source-code" lang="en-GB">
func TestAdd(t *testing.T) {
  a, b := 1, 2
  if got, want := Add(1, 2), 3; got != want {
    t.Errorf("Add(%v, %v) = %v, want %v", a, b, got, want)
  }
}</pre>
			<p lang="en-GB">In the preceding function, we used <strong class="source-inline" lang="">testing.T</strong> to report a test failure in case the <strong class="source-inline" lang="">Add</strong> function provides an unexpected output.</p>
			<p lang="en-GB">When it comes to execution, we can run the following command:</p>
			<pre class="source-code" lang="en-GB">
go test</pre>
			<p lang="en-GB">The<a id="_idIndexMarker376"/> command executes each test in the target directory and prints the output, containing error messages for any failing tests or any other necessary data.</p>
			<p lang="en-GB">Developers are free to choose the format of their tests; however, there are some common techniques, such <a id="_idIndexMarker377"/>as <strong class="bold" lang="">table-driven tests</strong>, that often help organize test code elegantly.</p>
			<p lang="en-GB">Table-driven tests are tests in which inputs are stored in the form of a table or a set of rows. Let’s take this example:</p>
			<pre class="source-code" lang="en-GB">
func TestAdd(t *testing.T) {
    tests := []struct {
        a    int
        b    int
        want int
    }{
        {a: 1, b: 2, want: 3},
        {a: -1, b: -2, want: -3},
        {a: -3, b: 3, want: 0},
        {a: 0, b: 0, want: 0},
    }
    for _, tt := range tests {
        assert.Equal(t, tt.want, Add(tt.a, tt.b), fmt.Sprintf("Add(%v, %v)", tt.a, tt.b))
    }
}</pre>
			<p lang="en-GB">In this code, we initialize the <strong class="source-inline" lang="">tests</strong> variable with the test cases for our function and then iterate over it. Note that we use the <strong class="source-inline" lang="">assert.Equal</strong> function provided by the <strong class="source-inline" lang="">github.com/stretchr/testify</strong> library to compare the expected and the actual result of the function being tested. This library provides a set of convenient functions that can simplify your test logic. Without using the <strong class="source-inline" lang="">assert</strong> library, the code comparing the test result would look like the following:</p>
			<pre class="source-code" lang="en-GB">
        if got, want := Add(tt.a, tt.b), tt.want; got != want {
            t.Errorf ("Add(%v, %v) = %v, want %v", tt.a, tt.b, got, want)
        }</pre>
			<p lang="en-GB">Table-driven tests help reduce the repetitiveness of tests by separating test cases and the logic that performs actual checks. In general, these tests are good practice when you need to perform lots of similar checks against the defined goal states, as shown in our example. </p>
			<p lang="en-GB">The table-driven format <a id="_idIndexMarker378"/>also helps us improve the readability of test code, making it easier to see and compare different test cases for the same functions. The format is quite common in Go tests; however, you can always organize your test code in the way that is the best for your use case.</p>
			<p lang="en-GB">Now, let’s review the basic features provided by Go’s built-in testing library.</p>
			<h3 lang="en-GB">Subtests</h3>
			<p lang="en-GB">One of the interesting features of the Go testing library is the ability to create <strong class="bold" lang="">subtests</strong> — tests that get<a id="_idIndexMarker379"/> executed inside <a id="_idIndexMarker380"/>other ones. Among the benefits of subtests is the ability to execute them separately, as well as to execute them in parallel for long-running tests and structure the test output in a more granular way. </p>
			<p lang="en-GB">Subtests are created by calling the <strong class="source-inline" lang="">Run</strong> function of the <strong class="source-inline" lang="">testing</strong> library:</p>
			<pre class="source-code" lang="en-GB">
func (t *T) Run(name string, f func(t *T)) bool</pre>
			<p lang="en-GB">When using the <strong class="source-inline" lang="">Run</strong> function, you need to pass the name of the test case and the function to execute, and Go will take care of executing each test case separately. Here’s an example of a test using the <strong class="source-inline" lang="">Run</strong> function:</p>
			<pre class="source-code" lang="en-GB">
func TestProcess(t *testing.T) {
  t.Run("test case 1", func(t *testing.T) {
    // Test case 1 logic.
  })
  t.Run("test case 2", func(t *testing.T) {
    // Test case 2 logic.
  })
}</pre>
			<p lang="en-GB">In the preceding<a id="_idIndexMarker381"/> example, we created two<a id="_idIndexMarker382"/> subtests by calling the <strong class="source-inline" lang="">Run</strong> function twice, one time for each subtest.</p>
			<p lang="en-GB">To achieve more fine-grained control over subtests, you can use the following options:</p>
			<ul>
				<li lang="en-GB">Each subtest, either passing or failing, can be shown separately in the output when running the <strong class="source-inline" lang="">go test</strong> command with the <strong class="source-inline" lang="">-v</strong> argument</li>
				<li lang="en-GB">You can run an individual test case by using a <strong class="source-inline" lang="">-run</strong> argument of the <strong class="source-inline" lang="">go test</strong> command</li>
			</ul>
			<p lang="en-GB">There is one other interesting benefit of using the <strong class="source-inline" lang="">Run</strong> function. Let’s imagine that you have a function called <strong class="source-inline" lang="">Process</strong> that takes seconds to complete. If you have a table test with lots of test cases and you execute them sequentially, the execution of the entire test may take a lot of time. In this case, you could let the Go test runner execute tests in parallel mode by calling the <strong class="source-inline" lang="">t.Parallel()</strong> function. Let’s illustrate this in the following example:</p>
			<pre class="source-code" lang="en-GB">
func TestProcess(t *testing.T) {
    tests := []struct {
        name  string
        input string
           want  string
    }{
        {name: "empty", input: "", want: ""},
        {name: "dog", input: "animal that barks", want: "dog"},
        {name: "cat", input: "animal that meows", want: "cat"},
    }
    for _, tt := range tests {
        input := tt.input
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel()
            assert.Equal(t, tt.want, Process(input), fmt.Sprintf("Process(%v)", input))
        })
    }
}</pre>
			<p lang="en-GB">In our <a id="_idIndexMarker383"/>example, we call the <strong class="source-inline" lang="">t.Run</strong> function for each test case, passing the test case name and the<a id="_idIndexMarker384"/> function to be executed. Then, we call <strong class="source-inline" lang="">t.Parallel()</strong> to make each test case execute in parallel. This optimization would significantly reduce the execution time in the case that our <strong class="source-inline" lang="">Process</strong> function is very slow.</p>
			<h3 lang="en-GB">Skipping</h3>
			<p lang="en-GB">Imagine that you <a id="_idIndexMarker385"/>want to execute your Go tests after each change on your computer, but you have some slow tests that take a long time to run. In that case, you would want to find a way to skip running tests under certain conditions. The Go testing library has <a id="_idIndexMarker386"/>built-in support for this – the <strong class="source-inline" lang="">Skip</strong> function. Let’s take this test function as an example:</p>
			<pre class="source-code" lang="en-GB">
func TestProcess(t *testing.T) {
  if os.Getenv("RUNTIME_ENV") == "development" {
    t.Skip("Skipping a test in development environment")
  }
  ...
}</pre>
			<p lang="en-GB">In the preceding code, we skip the test execution if there is a <strong class="source-inline" lang="">RUNTIME_ENV</strong> runtime environment variable with the <strong class="source-inline" lang="">development</strong> value. Note that we also provide the reason for skipping it inside the <strong class="source-inline" lang="">t.Skip</strong> call so that it is logged on test execution.</p>
			<p lang="en-GB">The skipping feature can be particularly useful for bypassing the execution of long-running tests, such as the tests performing slow I/O operations or doing lots of data processing. To support this, the Go testing library provides an ability to pass a specific flag, <strong class="source-inline" lang="">-test.short</strong>, to the <strong class="source-inline" lang="">go test</strong> command: </p>
			<pre class="source-code" lang="en-GB">
go test -test.short</pre>
			<p lang="en-GB">With the <strong class="source-inline" lang="">-test.short</strong> flag, you can let the Go <a id="_idIndexMarker387"/>test runner know that you want to run tests in <strong class="bold" lang="">short mode</strong> — a testing mode when only special, short tests are getting executed. You can add the <a id="_idIndexMarker388"/>following logic to all long-running tests to exclude<a id="_idIndexMarker389"/> them in short mode:</p>
			<pre class="source-code" lang="en-GB">
func TestLongRunningProcess(t *testing.T) {
  if testing.Short() {
    t.Skip("Skipping a test in short mode")
  }
  ...
}</pre>
			<p lang="en-GB">In the preceding example, the test is skipped when the <strong class="source-inline" lang="">-test.short</strong> flag is passed to the <strong class="source-inline" lang="">test</strong> command.</p>
			<p lang="en-GB">Using the short testing mode is useful when some of your tests are much slower than others and you need to run tests very frequently. Skipping the slow tests and executing them less frequently could significantly increase your development speed and make your development experience much better.</p>
			<p lang="en-GB">You can get familiar with the other Go testing features by checking out the official documentation for the <strong class="source-inline" lang="">testing</strong> package: <a href="https://pkg.go.dev/testing">https://pkg.go.dev/testing</a>. We are now going to proceed to the next section and focus on the details of implementing unit tests for our microservices.</p>
			<h1 id="_idParaDest-127" lang="en-GB"><a id="_idTextAnchor128"/>Unit tests</h1>
			<p lang="en-GB">We have covered many useful features for automated testing of Go applications and are now ready to illustrate how to use them in our microservice code. First, we are going to start with <strong class="bold" lang="">unit tests</strong> — tests <a id="_idIndexMarker390"/>of individual units of code, such as structures and individual functions.</p>
			<p lang="en-GB">Let’s walk through the process of implementing unit tests for our code using the metadata service controller as an example. Currently, our controller file looks like this:</p>
			<pre class="source-code" lang="en-GB">
package metadata
import (
    "context"
    "movieexample.com/metadata/pkg/model"
)
type metadataRepository interface {
    Get(ctx context.Context, id string) (*model.Metadata, error)
}
// Controller defines a metadata service controller.
Type Controller struct {
    repo metadataRepository
}
// New creates a metadata service controller.
Func New(repo metadataRepository) *Controller {
    return &amp;Controller{repo}
}
// Get returns movie metadata by id.
Func (c *Controller) Get(ctx context.Context, id string) (*model.Metadata, error) {
    return c.repo.Get(ctx, id)
}</pre>
			<p lang="en-GB">Let’s list what we would like to test in our code:</p>
			<ul>
				<li lang="en-GB">A <strong class="source-inline" lang="">Get</strong> call when the repository returns <strong class="source-inline" lang="">ErrNotFound</strong></li>
				<li lang="en-GB">A <strong class="source-inline" lang="">Get</strong> call when the repository returns an error other than <strong class="source-inline" lang="">ErrNotFound</strong></li>
				<li lang="en-GB">A <strong class="source-inline" lang="">Get</strong> call when the repository returns metadata and no error</li>
			</ul>
			<p lang="en-GB">So far, we have three<a id="_idIndexMarker391"/> test cases to implement. All test cases need to perform operations on the metadata repository and we need to simulate three different responses from it. How exactly should we simulate the responses from our metadata repository in the test? Let’s explore the powerful technique that allows us to achieve this with our testing code.</p>
			<h2 id="_idParaDest-128" lang="en-GB"><a id="_idTextAnchor129"/>Mocking</h2>
			<p lang="en-GB">The technique of simulating responses from a component is <a id="_idIndexMarker392"/>called <strong class="bold" lang="">mocking</strong>. Mocking is often used in tests to simulate various scenarios, such as returning specific results or errors. There are multiple ways of using mocking in Go code. The first one is to implement the <em class="italic" lang="">fake</em> version of <a id="_idIndexMarker393"/>components, called <strong class="bold" lang="">mocks</strong>, manually. Let’s illustrate how to implement these mocks using our metadata repository as an example. Our metadata repository interface is defined in the following way:</p>
			<pre class="source-code" lang="en-GB">
type metadataRepository interface {
    Get(ctx context.Context, id string) (*model.Metadata, error)
}</pre>
			<p lang="en-GB">The mock <a id="_idIndexMarker394"/>implementation of this interface could look like this:</p>
			<pre class="source-code" lang="en-GB">
type mockMetadataRepository struct {
    returnRes *model.Metadata
    returnErr error
}
func (m *mockMetadataRepository) setReturnValues(res *model.Metadata, err error) {
    m.returnRes = res
    m.returnErr = err
}
func (m *mockMetadataRepository) Get(ctx context.Context, id string) (*model.Metadata, error) {
    return m.returnRes, m.returnErr
}</pre>
			<p lang="en-GB">In our example mock of the metadata repository, we allow set values to be returned on the upcoming calls to the <strong class="source-inline" lang="">Get</strong> function by providing the <strong class="source-inline" lang="">setReturnValues</strong> function. The mock could be used to test our controller in the following way:</p>
			<pre class="source-code" lang="en-GB">
m := mockMetadataRepository{}
m.setReturnValues(nil, repository.ErrNotFound)
c := New(m)
res, err := c.Get(context.Background(), "some-id")
// Check res, err.</pre>
			<p lang="en-GB">Manual implementation of mocks is a relatively simple way to test calls to various components that are outside of the scope of the package being tested. The downside of this approach is that you need to write mock code by yourself and update its code on any interface changes.</p>
			<p lang="en-GB">The other way of<a id="_idIndexMarker395"/> using mocks is to use libraries that generate mocking code. An example of this kind of library is <a href="https://github.com/golang/mock">https://github.com/golang/mock</a>, which contains a mock generation tool called <strong class="source-inline" lang="">mockgen</strong>. You can install it by running the following command:</p>
			<pre class="source-code" lang="en-GB">
go install github.com/golang/mock/mockgen</pre>
			<p lang="en-GB">The <strong class="source-inline" lang="">mockgen</strong> tool can then be used in the following way:</p>
			<pre class="source-code" lang="en-GB">
mockgen -source=foo.go [options]</pre>
			<p lang="en-GB">Let’s illustrate how to generate mock code for our metadata repository. Run the following command from the <strong class="source-inline" lang="">src</strong> directory of our project:</p>
			<pre class="source-code" lang="en-GB">
mockgen -package=repository -source=metadata/internal/controller/metadata/controller.go</pre>
			<p lang="en-GB">You should get the contents of a mock source file as the output. The contents would be similar to this:</p>
			<pre class="source-code" lang="en-GB">
// MockmetadataRepository is a mock of metadataRepository 
// interface
type MockmetadataRepository struct {
    ctrl     *gomock.Controller
    recorder *MockmetadataRepositoryMockRecorder
}
// NewMockmetadataRepository creates a new mock instance
func NewMockmetadataRepository(ctrl *gomock.Controller) *MockmetadataRepository {
    mock := &amp;MockmetadataRepository{ctrl: ctrl}
    mock.recorder = &amp;MockmetadataRepositoryMockRecorder{mock}
    return mock
}
// EXPECT returns an object that allows the caller to indicate // expected use
func (m *MockmetadataRepository) EXPECT() *MockmetadataRepositoryMockRecorder {
    return m.recorder
}
// Get mocks base method.
func (m *MockmetadataRepository) Get(ctx context.Context, id string) (*model.Metadata, error) {
    ret := m.ctrl.Call(m, "Get", ctx, id)
    ret0, _ := ret[0].(*model.Metadata)
    ret1, _ := ret[1].(error)
    return ret0, ret1
}</pre>
			<p lang="en-GB">The generated <a id="_idIndexMarker396"/>mock code implements our interface and allows us to set the expected responses to our <strong class="source-inline" lang="">Get</strong> function in the following way:</p>
			<pre class="source-code" lang="en-GB">
ctrl := gomock.NewController(t)
defer ctrl.Finish()
m := NewMockmetadataRepository(gomock.NewController())
ctx := context.Background()
id := "some-id"
m.EXPECT().Get(ctx, id).Return(nil, repository.ErrNotFound)</pre>
			<p lang="en-GB">The mock code generated by the <strong class="source-inline" lang="">gomock</strong> library<a id="_idIndexMarker397"/> provides some useful features that we have not implemented in our manually created mock version. One of them is the ability to set the expected number of times that the target function should be called using the <strong class="source-inline" lang="">Times</strong> function:</p>
			<pre class="source-code" lang="en-GB">
m.EXPECT().Get(ctx, id).Return(nil, repository.ErrNotFound).Times(1)</pre>
			<p lang="en-GB">In the preceding<a id="_idIndexMarker398"/> example, we limit the number of times the <strong class="source-inline" lang="">Get</strong> function is called to one. The <strong class="source-inline" lang="">gomock</strong> library verifies these constraints at the end of the test execution and reports whether the function was called a different number of times. This mechanism is pretty useful when you want to make sure the target function has definitely been called in your test.</p>
			<p lang="en-GB">So far, we have shown how to use mocks in two different ways, and you may ask what the preferred way of using them is. Let’s compare the two approaches to find out the answer. </p>
			<p lang="en-GB">The benefit of implementing mocks manually is the ability to do so without using any external libraries, such as <strong class="source-inline" lang="">gomock</strong>. However, the <a id="_idIndexMarker399"/>downsides of this approach would be the following:</p>
			<ul>
				<li lang="en-GB">Manual implementation of mocks takes time</li>
				<li lang="en-GB">Any changes to the mocked interfaces would require manual updates to the mock code</li>
				<li lang="en-GB">Harder to implement extra features that are provided by libraries such as <strong class="source-inline" lang="">gomock</strong>, such as call count verification</li>
			</ul>
			<p lang="en-GB">Using a library such as <strong class="source-inline" lang="">gomock</strong> for providing mock code would be beneficial for the following reasons:</p>
			<ul>
				<li lang="en-GB">Higher code consistency when all mocks are generated in the same way</li>
				<li lang="en-GB">No need to write boilerplate code</li>
				<li lang="en-GB">An extended mock feature set</li>
			</ul>
			<p lang="en-GB">In our comparison, automatic mock code generation seems to provide more advantages, so we will follow the <strong class="source-inline" lang="">gomock</strong>-based approach for automatic mock generation. In the next section, we are going to demonstrate how to do this for our services.</p>
			<h2 id="_idParaDest-129" lang="en-GB"><a id="_idTextAnchor130"/>Implementing unit tests</h2>
			<p lang="en-GB">We are going to <a id="_idIndexMarker400"/>illustrate how to implement controller unit tests using the generated <strong class="source-inline" lang="">gomock</strong> code. First, we will need to find a good place in our repository to put the generated code. We already have a directory called <strong class="source-inline" lang="">gen</strong> that is shared among the services. We can create a sub-directory called <strong class="source-inline" lang="">mock</strong> that we can use for various generated mocks. Run the mock generation command for the metadata repository again:</p>
			<pre class="source-code" lang="en-GB">
mockgen -package=repository -source=metadata/internal/controller/metadata/controller.go</pre>
			<p lang="en-GB">Copy its output to the file called <strong class="source-inline" lang="">gen/mock/metadata/repository/repository.go</strong>. Now, let’s add a test for our metadata service controller. Create a file called <strong class="source-inline" lang="">controller_test.go</strong> in its directory and add to it the following code:</p>
			<pre class="source-code" lang="en-GB">
package metadata
import (
    "context"
    "errors"
    "testing"
    "github.com/golang/mock/gomock"
    "github.com/stretchr/testify/assert"
    gen "movieexample.com/gen/mock/metadata/repository"
    "movieexample.com/metadata/internal/repository"
    "movieexample.com/metadata/pkg/model"
)</pre>
			<p lang="en-GB">Then, add the<a id="_idIndexMarker401"/> following code, containing the test cases in a table format:</p>
			<pre class="source-code" lang="en-GB">
func TestController(t *testing.T) {
    tests := []struct {
        name       string
        expRepoRes *model.Metadata
        expRepoErr error
        wantRes    *model.Metadata
        wantErr    error
    }{
        {
            name:       "not found",
            expRepoErr: repository.ErrNotFound,
            wantErr:    ErrNotFound,
        },
        {
            name:       "unexpected error",
            expRepoErr: errors.New("unexpected error"),
            wantErr:    errors.New("unexpected error"),
        },
        {
            name:       "success",
            expRepoRes: &amp;model.Metadata{},
            wantRes:    &amp;model.Metadata{},
        },
    }</pre>
			<p lang="en-GB">Finally, add the<a id="_idIndexMarker402"/> code to execute our tests:</p>
			<pre class="source-code" lang="en-GB">
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            ctrl := gomock.NewController(t)
            defer ctrl.Finish()
            repoMock := gen.NewMockmetadataRepository(ctrl)
            c := New(repoMock)
            ctx := context.Background()
            id := "id"
            repoMock.EXPECT().Get(ctx, id).Return(tt.expRepoRes, tt.expRepoErr)
            res, err := c.Get(ctx, id)
            assert.Equal(t, tt.wantRes, res, tt.name)
            assert.Equal(t, tt.wantErr, err, tt.name)
        })
    }
}</pre>
			<p lang="en-GB">The code that we just added implements three different test cases for our <strong class="source-inline" lang="">Get</strong> function using the generated repository mock. We let the mock return the specific values by calling the <strong class="source-inline" lang="">EXPECT</strong> function and passing the desired values. We organized our test in a table-driven way, which we described earlier in the chapter.</p>
			<p lang="en-GB">To run the tests, use the regular command:</p>
			<pre class="source-code" lang="en-GB">
go test</pre>
			<p lang="en-GB">If you did everything correctly, the output of the test should include <strong class="source-inline" lang="">ok</strong>. Congratulations, we have just implemented the unit tests and demonstrated how to use mocks! We will let you implement the remaining tests for the microservices yourself — it’s going to be a fair amount of work, but this is always a great investment for ensuring the code remains tested and reliable.</p>
			<p lang="en-GB">In the next section, we are going to work on another type of test – integration tests. Knowing why and how to write integration tests in addition to regular unit tests for your microservices will help you to write more stable code and make sure all services work well in integration with each other.</p>
			<h1 id="_idParaDest-130" lang="en-GB"><a id="_idTextAnchor131"/>Integration tests</h1>
			<p lang="en-GB"><strong class="bold" lang="">Integration tests</strong> are <a id="_idIndexMarker403"/>automated tests that verify the correctness of integrations between the individual units of your services and the services themselves. In this section, you are going to learn how to write integration tests and how to structure the logic inside them, as well as get some useful tips that will help you write your own integration tests in the future.</p>
			<p lang="en-GB">Unlike unit tests that test the individual pieces of code, such as functions and structures, integration tests help ensure that the combinations of individual pieces still work well together.</p>
			<p lang="en-GB">Let’s provide an example of an integration test, taking our rating service as an example. The integration test for our service would instantiate both the service instance and the client for it and ensure that client requests would produce the expected results. As you remember, our rating service provides two API endpoints:</p>
			<ul>
				<li lang="en-GB"><strong class="source-inline" lang="">PutRating</strong>: Writes a rating to the database</li>
				<li lang="en-GB"><strong class="source-inline" lang="">GetAggregatedRating</strong>: Retrieves the ratings for a provided record (such as a movie) and returns the aggregated value</li>
			</ul>
			<p lang="en-GB">Our integration test for the rating service could have the following sequence of calls:</p>
			<ul>
				<li lang="en-GB">Writes some data using the <strong class="source-inline" lang="">PutRating</strong> endpoint</li>
				<li lang="en-GB">Verifies the data using the <strong class="source-inline" lang="">GetAggregatedRating</strong> endpoint</li>
				<li lang="en-GB">Writes new data using the <strong class="source-inline" lang="">PutRating</strong> endpoint</li>
				<li lang="en-GB">Calls the <strong class="source-inline" lang="">GetAggregatedRating</strong> endpoint and checks that the aggregated value reflects the latest rating update</li>
			</ul>
			<p lang="en-GB">In microservice development, integration tests usually test individual services or combinations of them – developers can write tests that target an arbitrary number of services.</p>
			<p lang="en-GB">Unlike unit tests—which<a id="_idIndexMarker404"/> generally reside together with the code being tested and can access some internal functions, structures, constants, and variables—integration tests often treat the components being tested as <strong class="bold" lang="">black boxes</strong>. Black boxes<a id="_idIndexMarker405"/> are logical blocks for which the implementation details remain unknown and can only be accessed through publicly exposed APIs or user interfaces. This way of testing is called <strong class="bold" lang="">black box testing</strong> – testing of <a id="_idIndexMarker406"/>a system using a public interface, such as an API, instead of calling individual internal functions or accessing internal components of the system.</p>
			<p lang="en-GB">Microservice integration tests are often performed by instantiating service instances and performing requests either by calling service APIs or via asynchronous events in case the system handles requests in an asynchronous fashion. The structure of an integration test usually follows a similar pattern:</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Set up the test</strong>: Instantiate <a id="_idIndexMarker407"/>the components being tested and any clients that can access their interfaces</li>
				<li lang="en-GB"><strong class="bold" lang="">Perform test operations and verify the correctness of results</strong>: Run an arbitrary number of operations and compare the outputs from the system being tested, such as a microservice, to the expected values</li>
				<li lang="en-GB"><strong class="bold" lang="">Tear down the test</strong>: Gracefully terminate the test by tearing down the components instantiated in the<a id="_idIndexMarker408"/> setup, closing any clients if needed</li>
			</ul>
			<p lang="en-GB">To illustrate how to write an integration test, let’s take three microservices from the previous chapters – metadata, movie, and rating services. To set up our test, we would need to instantiate six components – a server and a client for each microservice. To make it easier to run the test, we can instantiate servers using in-memory implementations of service registries and repositories.</p>
			<p lang="en-GB">Before you write the test, it’s often helpful to write down the set of operations to be tested and determine the expected outputs for each step. Let’s write down the plan for our integration test:</p>
			<ol>
				<li lang="en-GB">Write<a id="_idIndexMarker409"/> metadata for an example movie using the metadata service API (the <strong class="source-inline" lang="">PutMetadata</strong> endpoint) and check that the operation does not return any errors.</li>
				<li lang="en-GB">Retrieve the metadata for the same movie using the metadata service API (the <strong class="source-inline" lang="">GetMetadata</strong> endpoint) and check it matches the record that we submitted earlier.</li>
				<li lang="en-GB">Get the movie details (which should only consist of metadata) for our example movie using the movie service API (the <strong class="source-inline" lang="">GetMovieDetails</strong> endpoint) and make sure the result matches the data that we submitted earlier.</li>
				<li lang="en-GB">Write the first rating for our example movie using the rating service API (the <strong class="source-inline" lang="">PutRating</strong> endpoint) and check the operation does not return any errors.</li>
				<li lang="en-GB">Retrieve the initial aggregated rating for our movie using the rating service API (the <strong class="source-inline" lang="">GetAggregatedRating</strong> endpoint) and check that the value matches the one that we just submitted in the previous step.</li>
				<li lang="en-GB">Write the second rating for our example movie using the rating service API and check that the operation does not return any errors.</li>
				<li lang="en-GB">Retrieve the new aggregated rating for our movie using the rating service API and check that the value reflects the last rating.</li>
				<li lang="en-GB">Get the movie details for our example movie and check that the result includes the updated rating.</li>
			</ol>
			<p lang="en-GB">Having this kind of plan makes it easier to write the code for the integration test and brings us to the last step — actually implementing it:</p>
			<ol>
				<li lang="en-GB" value="1">Create<a id="_idIndexMarker410"/> a <strong class="source-inline" lang="">test/integration</strong> directory and add the file called <strong class="source-inline" lang="">main.go</strong> with the following code:<pre class="source-code" lang="en-GB">
package main</pre><pre class="source-code" lang="en-GB">
import (</pre><pre class="source-code" lang="en-GB">
    "context"</pre><pre class="source-code" lang="en-GB">
    "log"</pre><pre class="source-code" lang="en-GB">
    "net"</pre><pre class="source-code" lang="en-GB">
    "github.com/google/go-cmp/cmp"</pre><pre class="source-code" lang="en-GB">
    "github.com/google/go-cmp/cmp/cmpopts"</pre><pre class="source-code" lang="en-GB">
    "google.golang.org/grpc"</pre><pre class="source-code" lang="en-GB">
    "movieexample.com/gen"</pre><pre class="source-code" lang="en-GB">
    metadatatest "movieexample.com/metadata/pkg/testutil"</pre><pre class="source-code" lang="en-GB">
    movietest "movieexample.com/movie/pkg/testutil"</pre><pre class="source-code" lang="en-GB">
    "movieexample.com/pkg/discovery"</pre><pre class="source-code" lang="en-GB">
    "movieexample.com/pkg/discovery/memory"</pre><pre class="source-code" lang="en-GB">
    ratingtest "movieexample.com/rating/pkg/testutil"</pre><pre class="source-code" lang="en-GB">
    "google.golang.org/grpc/credentials/insecure"</pre><pre class="source-code" lang="en-GB">
)</pre></li>
				<li lang="en-GB">Let’s add <a id="_idIndexMarker411"/>some constants with service names and addresses that we can use later in the test to the file:<pre class="source-code" lang="en-GB">
const (</pre><pre class="source-code" lang="en-GB">
    metadataServiceName = "metadata"</pre><pre class="source-code" lang="en-GB">
    ratingServiceName   = "rating"</pre><pre class="source-code" lang="en-GB">
    movieServiceName    = "movie"</pre><pre class="source-code" lang="en-GB">
    metadataServiceAddr = "localhost:8081"</pre><pre class="source-code" lang="en-GB">
    ratingServiceAddr   = "localhost:8082"</pre><pre class="source-code" lang="en-GB">
    movieServiceAddr    = "localhost:8083"</pre><pre class="source-code" lang="en-GB">
)</pre></li>
				<li lang="en-GB">The next step is to implement the setup code to instantiate our service servers:<pre class="source-code" lang="en-GB">
func main() {</pre><pre class="source-code" lang="en-GB">
    log.Println("Starting the integration test")</pre><pre class="source-code" lang="en-GB">
    ctx := context.Background()</pre><pre class="source-code" lang="en-GB">
    registry := memory.NewRegistry()</pre><pre class="source-code" lang="en-GB">
    log.Println("Setting up service handlers and clients")</pre><pre class="source-code" lang="en-GB">
    metadataSrv := startMetadataService(ctx, registry)</pre><pre class="source-code" lang="en-GB">
    defer metadataSrv.GracefulStop()</pre><pre class="source-code" lang="en-GB">
    ratingSrv := startRatingService(ctx, registry)</pre><pre class="source-code" lang="en-GB">
    defer ratingSrv.GracefulStop()</pre><pre class="source-code" lang="en-GB">
    movieSrv := startMovieService(ctx, registry)</pre><pre class="source-code" lang="en-GB">
    defer movieSrv.GracefulStop()</pre></li>
			</ol>
			<p lang="en-GB">Note that <strong class="source-inline" lang="">defer</strong> calls to the <strong class="source-inline" lang="">GracefulStop</strong> function of each server — this code is a <a id="_idIndexMarker412"/>part of the tear-down logic of our test for terminating all servers gracefully.</p>
			<ol>
				<li lang="en-GB" value="4">Now, let’s set up the test clients for our services:<pre class="source-code" lang="en-GB">
    opts := grpc.WithTransportCredentials(insecure.NewCredentials())</pre><pre class="source-code" lang="en-GB">
    metadataConn, err := grpc.Dial(metadataServiceAddr, opts)</pre><pre class="source-code" lang="en-GB">
    if err != nil {</pre><pre class="source-code" lang="en-GB">
        panic(err)</pre><pre class="source-code" lang="en-GB">
    }</pre><pre class="source-code" lang="en-GB">
    defer metadataConn.Close()</pre><pre class="source-code" lang="en-GB">
    metadataClient := gen.NewMetadataServiceClient(metadataConn)</pre><pre class="source-code" lang="en-GB">
    </pre><pre class="source-code" lang="en-GB">
    ratingConn, err := grpc.Dial(ratingServiceAddr, opts)</pre><pre class="source-code" lang="en-GB">
    if err != nil {</pre><pre class="source-code" lang="en-GB">
        panic(err)</pre><pre class="source-code" lang="en-GB">
    }</pre><pre class="source-code" lang="en-GB">
    defer ratingConn.Close()</pre><pre class="source-code" lang="en-GB">
    ratingClient := gen.NewRatingServiceClient(ratingConn)</pre><pre class="source-code" lang="en-GB">
    movieConn, err := grpc.Dial(movieServiceAddr, opts)</pre><pre class="source-code" lang="en-GB">
    if err != nil {</pre><pre class="source-code" lang="en-GB">
        panic(err)</pre><pre class="source-code" lang="en-GB">
    }</pre><pre class="source-code" lang="en-GB">
    defer movieConn.Close()</pre><pre class="source-code" lang="en-GB">
    movieClient := gen.NewMovieServiceClient(movieConn)</pre></li>
			</ol>
			<p lang="en-GB">Now, we are ready to implement the sequence of our test commands. The first step is to test, write, and <a id="_idIndexMarker413"/>read the operations of the metadata service:</p>
			<pre class="source-code" lang="en-GB">
    log.Println("Saving test metadata via metadata service")
    m := &amp;gen.Metadata{
        Id:          "the-movie",
        Title:       "The Movie",
        Description: "The Movie, the one and only",
        Director:    "Mr. D",
    }
    if _, err := metadataClient.PutMetadata(ctx, &amp;gen.PutMetadataRequest{Metadata: m}); err != nil {
        log.Fatalf("put metadata: %v", err)
    }
    log.Println("Retrieving test metadata via metadata service")
    getMetadataResp, err := metadataClient.GetMetadata(ctx, &amp;gen.GetMetadataRequest{MovieId: m.Id})
    if err != nil {
        log.Fatalf("get metadata: %v", err)
    }
    if diff := cmp.Diff(getMetadataResp.Metadata, m, cmpopts.IgnoreUnexported(gen.Metadata{})); diff != "" {
        log.Fatalf("get metadata after put mismatch: %v", diff)
    }</pre>
			<p lang="en-GB">You may notice that we used the <strong class="source-inline" lang="">cmpopts.IgnoreUnexported(gen.Metadata{})</strong> option inside the call to the <strong class="source-inline" lang="">cmp.Diff</strong> function — this tells the <strong class="source-inline" lang="">cmp</strong> library to ignore the unexported fields in the <strong class="source-inline" lang="">gen.Metadata</strong> structure. We have added this option because the <strong class="source-inline" lang="">gen.Metadata</strong> structure, generated by the Protocol Buffers code generator, includes some private fields that we want to ignore in the comparison.</p>
			<p lang="en-GB">The next test in our<a id="_idIndexMarker414"/> sequence would be to retrieve the movie details and check that the metadata matches the record that we submitted earlier:</p>
			<pre class="source-code" lang="en-GB">
    log.Println("Getting movie details via movie service")
    wantMovieDetails := &amp;gen.MovieDetails{
        Metadata: m,
    }
    getMovieDetailsResp, err := movieClient.GetMovieDetails(ctx, &amp;gen.GetMovieDetailsRequest{MovieId: m.Id})
    if err != nil {
        log.Fatalf("get movie details: %v", err)
    }
    if diff := cmp.Diff(getMovieDetailsResp.MovieDetails, wantMovieDetails, cmpopts.IgnoreUnexported(gen.MovieDetails{}, gen.Metadata{})); diff != "" {
        log.Fatalf("get movie details after put mismatch: %v", err)
    }</pre>
			<p lang="en-GB">Now, we are ready to <a id="_idIndexMarker415"/>test the rating service. </p>
			<p lang="en-GB">Let’s implement two tests – one for writing a rating and one for retrieving the initial aggregated value, which should match the first rating:</p>
			<pre class="source-code" lang="en-GB">
    log.Println("Saving first rating via rating service")
    const userID = "user0"
    const recordTypeMovie = "movie"
    firstRating := int32(5)
    if _, err = ratingClient.PutRating(ctx, &amp;gen.PutRatingRequest{
        UserId:      userID,
        RecordId:    m.Id,
        RecordType:  recordTypeMovie,
        RatingValue: firstRating,
    }); err != nil {
        log.Fatalf("put rating: %v", err)
    }
    log.Println("Retrieving initial aggregated rating via rating service")
    getAggregatedRatingResp, err := ratingClient.GetAggregatedRating(ctx, &amp;gen.GetAggregatedRatingRequest{
        RecordId:   m.Id,
        RecordType: recordTypeMovie,
    })
    if err != nil {
        log.Fatalf("get aggreggated rating: %v", err)
    }
    if got, want := getAggregatedRatingResp.RatingValue, float64(5); got != want {
        log.Fatalf("rating mismatch: got %v want %v", got, want)
    }</pre>
			<p lang="en-GB">The next part of the <a id="_idIndexMarker416"/>test would be to submit the second rating and check that the aggregated value was changed:</p>
			<pre class="source-code" lang="en-GB">
    log.Println("Saving second rating via rating service")
    secondRating := int32(1)
    if _, err = ratingClient.PutRating(ctx, &amp;gen.PutRatingRequest{
        UserId:      userID,
        RecordId:    m.Id,
        RecordType:  recordTypeMovie,
        RatingValue: secondRating,
    }); err != nil {
        log.Fatalf("put rating: %v", err)
    }
    log.Println("Saving new aggregated rating via rating service")
    getAggregatedRatingResp, err = ratingClient.GetAggregatedRating(ctx, &amp;gen.GetAggregatedRatingRequest{
        RecordId:   m.Id,
        RecordType: recordTypeMovie,
    })
    if err != nil {
        log.Fatalf("get aggreggated rating: %v", err)
    }
    wantRating := float64((firstRating + secondRating) / 2)
    if got, want := getAggregatedRatingResp.RatingValue, wantRating; got != want {
        log.Fatalf("rating mismatch: got %v want %v", got, want)
    }</pre>
			<p lang="en-GB">We are almost <a id="_idIndexMarker417"/>done with our <strong class="source-inline" lang="">main</strong> function – let’s implement the last check:</p>
			<pre class="source-code" lang="en-GB">
    log.Println("Getting updated movie details via movie service")
    getMovieDetailsResp, err = movieClient.GetMovieDetails(ctx, &amp;gen.GetMovieDetailsRequest{MovieId: m.Id})
    if err != nil {
        log.Fatalf("get movie details: %v", err)
    }
    wantMovieDetails.Rating = wantRating
    if diff := cmp.Diff(getMovieDetailsResp.MovieDetails, wantMovieDetails, cmpopts.IgnoreUnexported(gen.MovieDetails{}, gen.Metadata{})); diff != "" {
        log.Fatalf("get movie details after update mismatch: %v", err)
    }
    log.Println("Integration test execution successful")
}</pre>
			<p lang="en-GB">Our integration test is <a id="_idIndexMarker418"/>almost ready. Let’s add the functions for initializing the servers for our services below the <strong class="source-inline" lang="">main</strong> function. First, add the function for creating the server for a metadata service:</p>
			<pre class="source-code" lang="en-GB">
func startMetadataService(ctx context.Context, registry discovery.Registry) *grpc.Server {
    log.Println("Starting metadata service on " + metadataServiceAddr)
    h := metadatatest.NewTestMetadataGRPCServer()
    l, err := net.Listen("tcp", metadataServiceAddr)
    if err != nil {
        log.Fatalf("failed to listen: %v", err)
    }
    srv := grpc.NewServer()
    gen.RegisterMetadataServiceServer(srv, h)
    go func() {
        if err := srv.Serve(l); err != nil {
            panic(err)
        }
    }()
    id := discovery.GenerateInstanceID(metadataServiceName)
    if err := registry.Register(ctx, id, metadataServiceName, metadataServiceAddr); err != nil {
        panic(err)
    }
    return srv
}</pre>
			<p lang="en-GB">You may notice that we call the <strong class="source-inline" lang="">srv.Serve</strong> function inside a goroutine — this way, it doesn’t block the execution and allows us to immediately return from the function.</p>
			<p lang="en-GB">Let’s add a similar <a id="_idIndexMarker419"/>implementation for the rating service server to the same file:</p>
			<pre class="source-code" lang="en-GB">
func startRatingService(ctx context.Context, registry discovery.Registry) *grpc.Server {
    log.Println("Starting rating service on " + ratingServiceAddr)
    h := ratingtest.NewTestRatingGRPCServer()
    l, err := net.Listen("tcp", ratingServiceAddr)
    if err != nil {
        log.Fatalf("failed to listen: %v", err)
    }
    srv := grpc.NewServer()
    gen.RegisterRatingServiceServer(srv, h)
    go func() {
        if err := srv.Serve(l); err != nil {
            panic(err)
        }
    }()
    id := discovery.GenerateInstanceID(ratingServiceName)
    if err := registry.Register(ctx, id, ratingServiceName, ratingServiceAddr); err != nil {
        panic(err)
    }
    return srv
}</pre>
			<p lang="en-GB">Finally, let’s add a<a id="_idIndexMarker420"/> function for initializing the movie server:</p>
			<pre class="source-code" lang="en-GB">
func startMovieService(ctx context.Context, registry discovery.Registry) *grpc.Server {
    log.Println("Starting movie service on " + movieServiceAddr)
    h := movietest.NewTestMovieGRPCServer(registry)
    l, err := net.Listen("tcp", movieServiceAddr)
    if err != nil {
        log.Fatalf("failed to listen: %v", err)
    }
    srv := grpc.NewServer()
    gen.RegisterMovieServiceServer(srv, h)
    go func() {
        if err := srv.Serve(l); err != nil {
            panic(err)
        }
    }()
    id := discovery.GenerateInstanceID(movieServiceName)
    if err := registry.Register(ctx, id, movieServiceName, movieServiceAddr); err != nil {
        panic(err)
    }
    return srv
}</pre>
			<p lang="en-GB">Our integration test is ready! You can run it by executing the following command:</p>
			<pre class="source-code" lang="en-GB">
go run test/integration/*.go</pre>
			<p lang="en-GB">If everything is correct, you<a id="_idIndexMarker421"/> should see the following output:</p>
			<pre class="source-code" lang="en-GB">
2022/07/16 16:20:46 Starting the integration test
2022/07/16 16:20:46 Setting up service handlers and clients
2022/07/16 16:20:46 Starting metadata service on localhost:8081
2022/07/16 16:20:46 Starting rating service on localhost:8082
2022/07/16 16:20:46 Starting movie service on localhost:8083
2022/07/16 16:20:46 Saving test metadata via metadata service
2022/07/16 16:20:46 Retrieving test metadata via metadata service
2022/07/16 16:20:46 Getting movie details via movie service
2022/07/16 16:20:46 Saving first rating via rating service
2022/07/16 16:20:46 Retrieving initial aggregated rating via rating service
2022/07/16 16:20:46 Saving second rating via rating service
2022/07/16 16:20:46 Saving new aggregated rating via rating service
2022/07/16 16:20:46 Getting updated movie details via movie service
2022/07/16 16:20:46 Integration test execution successful</pre>
			<p lang="en-GB">As you may notice, the structure of our integration test precisely matches the sequence of test operations that we defined earlier. We implemented our integration test as an executable command and added enough log messages to help you with debugging – if any step fails, it is therefore easier to understand at which step the failure occurred and which operations preceded that step.</p>
			<p lang="en-GB">It is important to note that we used the in-memory versions of the metadata and rating repositories in our integration test. An alternative approach would be to set up an integration test that stores the data in some persistent databases, such as MySQL. However, there are some challenges with using existing persistent databases<a id="_idIndexMarker422"/> in integration tests:</p>
			<ul>
				<li lang="en-GB">Integration test data should not interfere with user data. Otherwise, it may cause unexpected effects on existing service users.</li>
				<li lang="en-GB">Ideally, test data should be cleaned up after test execution so that the database does not get filled with unnecessary, temporary data.</li>
			</ul>
			<p lang="en-GB">In order to avoid interference with the existing user data, I would suggest running integration tests on non-production environments, such as staging. Additionally, I would suggest always generating random identifiers for your test records to make sure that individual test executions don’t affect each other. For example, you can use the <a href="http://github.com/google/uuid">github.com/google/uuid</a> library to generate new identifiers using the <strong class="source-inline" lang="">uuid.New()</strong> function. Lastly, I would recommend always including cleanup code at the end of each integration test that uses persistent data storage to clean up the created records, whenever this is possible. </p>
			<p lang="en-GB">Now, the question is when we should write integration tests. It is always up to you; however, I do have some<a id="_idIndexMarker423"/> general suggestions:</p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Test critical flows</strong>: Make sure you test the entire flows, such as user signups and logins</li>
				<li lang="en-GB"><strong class="bold" lang="">Test critical endpoints</strong>: Perform the tests of the most critical endpoints that your services provide to <a id="_idIndexMarker424"/>your users</li>
			</ul>
			<p lang="en-GB">Additionally, you may have integration tests that are executed after each code change. Systems such as Jenkins provide these kinds of features and allow you to plug any custom logic that would be executed into each update of your code. We won’t cover Jenkins<a id="_idIndexMarker425"/> setup in this book, but you can familiarize yourself with its documentation on the official website (https://www.jenkins.io).</p>
			<p lang="en-GB">As we have illustrated how to write both unit and integration tests, let’s proceed to the next section of the book, describing some of the best practices of Go testing.</p>
			<h1 id="_idParaDest-131" lang="en-GB"><a id="_idTextAnchor132"/>Testing best practices</h1>
			<p lang="en-GB">In this section, we are going to list some additional useful testing tips that are going to help you to improve the quality of your tests.</p>
			<h2 id="_idParaDest-132" lang="en-GB"><a id="_idTextAnchor133"/>Using helpful messages</h2>
			<p lang="en-GB">One of the most important <a id="_idIndexMarker426"/>aspects of writing tests is providing enough information in error logs that it is easy to understand exactly what went wrong and which test case triggered the failure. Consider the following test case code:</p>
			<pre class="source-code" lang="en-GB">
if got, want := Process(tt.in), tt.want; got != want {
  t.Errorf("Result mismatch")
}</pre>
			<p lang="en-GB">The error log does not include both the expected and the actual value received from the function being tested, making it harder to understand what the function returned and how it was different from the expected value.</p>
			<p lang="en-GB">The better log line would be as follows:</p>
			<pre class="source-code" lang="en-GB">
t.Errorf("got %v, want %v", got, want)</pre>
			<p lang="en-GB">This log line includes the expected and the actual returned value of the function and provides much more context to you when you debug the test.</p>
			<p class="callout-heading" lang="en-GB">Important note</p>
			<p class="callout" lang="en-GB">Note that in our test logs, first, we log the actual value and then the expected one. This order is recommended by the Go team as the conventional way of logging the values in tests and is followed in all libraries and packages. Follow the same order in your logs for consistency.</p>
			<p lang="en-GB">An even better error message would be as follows:</p>
			<pre class="source-code" lang="en-GB">
t.Errorf("YourFunc(%v) = %v, want %v", tt.in, got, want)</pre>
			<p lang="en-GB">This error log message includes some additional information – the function being called and the input argument that was passed to it.</p>
			<p lang="en-GB">To standardize the code for your test cases, you can use the <strong class="source-inline" lang="">github.com/stretchr/testify</strong> library. The following example illustrates how to compare the expected and the actual value and log the name of the function being tested, as well as the argument passed to it:</p>
			<pre class="source-code" lang="en-GB">
assert.Equal(t, want, got, fmt.Sprintf("YourFunc(%v)", tt.in))</pre>
			<p lang="en-GB">The assert <a id="_idIndexMarker427"/>package of the <strong class="source-inline" lang="">github.com/stretchr/testify</strong> library prints both the expected and the actual value of the test result, as well as providing the details about the test case (the <strong class="source-inline" lang="">fmt.Sprintf</strong> result, in our case).</p>
			<h2 id="_idParaDest-133" lang="en-GB"><a id="_idTextAnchor134"/>Avoiding the use of Fatal in your logs</h2>
			<p lang="en-GB">The built-in <a id="_idIndexMarker428"/>Go testing library includes different functions for logging errors, including <strong class="source-inline" lang="">Error</strong>, <strong class="source-inline" lang="">Errorf</strong>, <strong class="source-inline" lang="">Fatal</strong>, and <strong class="source-inline" lang="">Fatalf</strong>. The last two functions print the logs and interrupt the execution of the tests. Consider this test code:</p>
			<pre class="source-code" lang="en-GB">
if err := Process(tt.in); err != nil {
  t.Fatalf("Process(%v): %v, want nil", err)
} </pre>
			<p lang="en-GB">The call to the <strong class="source-inline" lang="">Fatalf</strong> function interrupts the test execution. Interrupting test execution is often not the best idea because it leads to fewer tests being executed. Executing fewer tests leaves the developer with less information for the remaining failing test cases. Fixing one error and running all the tests again may be a suboptimal experience for many developers and it is often better to continue the test execution whenever possible.</p>
			<p lang="en-GB">The previous example can be re-written as follows:</p>
			<pre class="source-code" lang="en-GB">
if err := Process(tt.in); err != nil {
  t.Errorf("Process(%v): %v, want nil", err)
} </pre>
			<p lang="en-GB">If you use this <a id="_idIndexMarker429"/>code in a loop, you can add <strong class="source-inline" lang="">continue</strong> after the <strong class="source-inline" lang="">Errorf</strong> call to proceed to the next test cases.</p>
			<h2 id="_idParaDest-134" lang="en-GB"><a id="_idTextAnchor135"/>Making a comparison using a cmp library</h2>
			<p lang="en-GB">Imagine that you<a id="_idIndexMarker430"/> have a test that compares the <strong class="source-inline" lang="">Metadata</strong> structure that we defined in <a href="B18865_02.xhtml#_idTextAnchor027"><em class="italic" lang="">Chapter 2</em></a>:</p>
			<pre class="source-code" lang="en-GB">
want := &amp;model.Metadata{ID: "123", Title: "Some title"}
id := "123"
if got := GetMetadata(ctx, "123"); got != want {
  t.Errorf("GetMetadata(%v): %v, want %v", id, got, want)
}</pre>
			<p lang="en-GB">The code here would not work for structure references – in our code, the <strong class="source-inline" lang="">want</strong> variable holds a pointer to the <strong class="source-inline" lang="">model.Metadata</strong> structure, so the <strong class="source-inline" lang="">!=</strong> operator will return <strong class="source-inline" lang="">true</strong> even for structures with the same field values if these structures are created separately.</p>
			<p lang="en-GB">A comparison of structure pointers can be made in Go using the <strong class="source-inline" lang="">reflect.DeepEqual</strong> function:</p>
			<pre class="source-code" lang="en-GB">
if !reflect.DeepEqual(GetMetadata(ctx, "123"), want); {
  t.Errorf("GetMetadata(%v): %v, want %v", id, *got, *want)
}</pre>
			<p lang="en-GB">However, the output of the test may not be easy to read. Consider that you have lots of fields inside the <strong class="source-inline" lang="">Metadata</strong> structure – if only one field is different, you will need to scan through both structures to find the difference. There is a convenient library that simplifies comparison in tests <a id="_idIndexMarker431"/>called <strong class="source-inline" lang="">cmp</strong> (https://pkg.go.dev/github.com/google/go-cmp/cmp).</p>
			<p lang="en-GB">The <strong class="source-inline" lang="">cmp</strong> library allows you to compare arbitrary Go structures in the same way as with <strong class="source-inline" lang="">reflect.DeepEqual</strong>, but it also provides human-readable output. Here’s an example of using the function:</p>
			<pre class="source-code" lang="en-GB">
if diff := cmp.Diff(want, got); diff != "" {
  t.Errorf("GetMetadata(%v): mismatch (-want +got):\n%s", tt.in, diff)
}</pre>
			<p lang="en-GB">If the structures don’t match, the <strong class="source-inline" lang="">diff</strong> variable will be a non-empty string, including the printable representation of the differences between them. Here’s an example of this kind of output:</p>
			<pre class="source-code" lang="en-GB">
GetMetadata(123) mismatch (-want +got):
  model.Metadata{
      ID:      "123",
-     Tiitle: s"Title",
+     IPAddress: s"The Title",
  }</pre>
			<p lang="en-GB">Note how the <strong class="source-inline" lang="">cmp</strong> library <a id="_idIndexMarker432"/>highlighted the <a id="_idIndexMarker433"/>differences between both structures using the <strong class="source-inline" lang="">–</strong> and <strong class="source-inline" lang="">+</strong> prefixes. Now, it is easy to read the test output and notice the differences between the structures — this kind of optimization will save you lots of time during debugging.</p>
			<p lang="en-GB">This summarizes our short collection of Go testing best practices — you can find more tips by reading the documents mentioned in the <em class="italic" lang="">Further reading</em> section. Make sure to familiarize yourself with the official recommendations and the comments for the <strong class="source-inline" lang="">testing</strong> package to learn how to write tests in a conventional way and leverage all the features provided by the built-in Go testing library.</p>
			<h1 id="_idParaDest-135" lang="en-GB"><a id="_idTextAnchor136"/>Summary</h1>
			<p lang="en-GB">In this chapter, we covered multiple topics related to Go testing, including the common features of the Go testing library and the basics of writing unit and integration tests for your code. You have learned how to add tests to your microservices, optimize test execution in various cases, create test mocks, and maximize the quality of your tests by following the best testing practices. The knowledge you gained from reading this chapter should help you to increase the efficiency of your testing logic and increase the reliability of your microservices.</p>
			<p lang="en-GB">In the next chapter, we will move to a new topic, that will cover the main aspects of service reliability and describe various techniques for making your services resilient to various types of failures.</p>
			<h1 id="_idParaDest-136" lang="en-GB"><a id="_idTextAnchor137"/>Further reading</h1>
			<ul>
				<li lang="en-GB">Golang test comments: <a href="https://github.com/golang/go/wiki/TestComments ">https://github.com/golang/go/wiki/TestComments</a></li>
				<li lang="en-GB">Golang testing package documentation: <a href="https://pkg.go.dev/testing">https://pkg.go.dev/testing</a></li>
				<li lang="en-GB"><em class="italic" lang="">Using Subtests and Sub-benchmarks</em>: <a href="https://go.dev/blog/subtests">https://go.dev/blog/subtests</a></li>
			</ul>
		</div>
	

		<div id="_idContainer037" class="Content">
			<h1 id="_idParaDest-137" lang="en-GB"><a id="_idTextAnchor138"/>Part 3: Maintenance</h1>
			<p lang="en-GB">This part covers some advanced topics of Go microservice development, such as reliability, observability, alerting, ownership, and security. You will learn how to handle different types of microservice-related issues, how to collect and analyze service performance data, how to set up automated service incident alerting, and how to secure communication between your microservices. The part includes lots of best practices and examples that will help to apply the newly gained knowledge to your microservices.</p>
			<p lang="en-GB">This contains the following chapters:</p>
			<ul>
				<li lang="en-GB"><a href="B18865_10.xhtml#_idTextAnchor139"><em class="italic" lang="">Chapter 10</em></a>, Reliability Overview</li>
				<li lang="en-GB"><a href="B18865_11.xhtml#_idTextAnchor152"><em class="italic" lang="">Chapter 11</em></a>, Collecting Service Telemetry Data</li>
				<li lang="en-GB"><a href="B18865_12.xhtml#_idTextAnchor171"><em class="italic" lang="">Chapter 12</em></a>, Setting up Service Alerting</li>
				<li lang="en-GB"><a href="B18865_13.xhtml#_idTextAnchor181"><em class="italic" lang="">Chapter 13</em></a>, Advanced Topics</li>
			</ul>
		</div>
	</body></html>