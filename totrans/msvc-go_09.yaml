- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Unit and Integration Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元和集成测试
- en: Testing is an integral part of any development process. It is always important
    to cover your code with automated tests, ensuring that all important logic is
    continuously tested on all code changes. Writing good tests often helps ensure
    that any changes made throughout the development process will keep the code working
    and reliable.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是任何开发过程的重要组成部分。始终重要的是用自动化测试覆盖你的代码，确保所有重要的逻辑在所有代码更改上都能持续测试。编写好的测试通常有助于确保在整个开发过程中所做的任何更改都能保持代码的正常和可靠运行。
- en: Testing is especially important in microservice development, but it brings some
    additional challenges to developers. It’s not enough to test each service – it’s
    also important to test the integrations between the services, ensuring every service
    can work with the others.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务开发中，测试尤为重要，但它也给开发者带来了一些额外的挑战。仅仅测试每个服务是不够的——测试服务之间的集成也同样重要，确保每个服务都能与其他服务协同工作。
- en: 'In this chapter, we will cover both unit testing and integration testing and
    illustrate how to add tests to the microservices we created in the previous chapters.
    We will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖单元测试和集成测试，并说明如何将测试添加到我们在前几章中创建的微服务中。我们将涵盖以下主题：
- en: Go testing overview
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 测试概述
- en: Unit tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Integration tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: Testing best practices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试最佳实践
- en: You will learn how to write unit and integration tests in Go, how to use the
    mocking technique, and how to organize the testing code for your microservices.
    This knowledge will help you to build more reliable services.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习如何在 Go 中编写单元和集成测试，如何使用模拟技术，以及如何组织微服务的测试代码。这些知识将帮助你构建更可靠的服务。
- en: Let’s proceed to the overview of Go testing tools and techniques.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续概述 Go 测试工具和技术。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete this chapter, you need Go version 1.11+ or above.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，你需要 Go 版本 1.11 或更高版本。
- en: 'You can find the GitHub code for this chapter here: [https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter09](https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter09).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此处找到本章的 GitHub 代码：[https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter09](https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter09)。
- en: Go testing overview
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 测试概述
- en: In this section, we are going to provide a high-level overview of Go’s testing
    capabilities. We will cover the basics of writing tests for Go code, list the
    useful functions and libraries provided with the Go SDK, and describe various
    techniques for writing tests that will help you in microservice development.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将提供一个关于 Go 测试功能的概述。我们将涵盖为 Go 代码编写测试的基础，列出 Go SDK 提供的有用函数和库，并描述各种测试编写技术，这些技术将有助于你在微服务开发中。
- en: First, let’s cover the basics of writing tests for Go applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来了解一下为 Go 应用程序编写测试的基础。
- en: Go language has built-in support for writing automated tests and provides a
    package called `testing` for this purpose.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言内置了对编写自动化测试的支持，并提供了一个名为 `testing` 的包来实现这一目的。
- en: There is a conventional relationship between the Go code and its tests. If you
    have a file called `example.go`, its tests would reside in the same package in
    a file called `example_test.go`. Using a `_test` file name suffix allows you to
    differentiate between the code being tested and the tests for it, making it easier
    to navigate the source code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Go 代码与其测试之间存在一种约定关系。如果你有一个名为 `example.go` 的文件，其测试将位于同一包中的名为 `example_test.go`
    的文件中。使用 `_test` 文件名后缀可以让你区分被测试的代码及其测试，从而更容易地导航源代码。
- en: 'Go test functions follow this conventional name format, with each test function
    name starting with the `Test` prefix:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Go 测试函数遵循这种约定名称格式，每个测试函数名称都以 `Test` 前缀开头：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Inside these functions, you can use the `testing.T` structure to report test
    failures or use any additional helper functions provided by it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些函数内部，你可以使用 `testing.T` 结构来报告测试失败或使用它提供的任何其他辅助函数。
- en: 'Let’s take this test as an example:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以这个测试为例：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding function, we used `testing.T` to report a test failure in case
    the `Add` function provides an unexpected output.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，我们使用了 `testing.T` 来报告测试失败，如果 `Add` 函数提供了意外的输出。
- en: 'When it comes to execution, we can run the following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行方面，我们可以运行以下命令：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The command executes each test in the target directory and prints the output,
    containing error messages for any failing tests or any other necessary data.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令会执行目标目录中的每个测试，并打印输出，其中包含任何失败的测试或其他必要的数据的错误消息。
- en: Developers are free to choose the format of their tests; however, there are
    some common techniques, such as **table-driven tests**, that often help organize
    test code elegantly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以自由选择测试的格式；然而，有一些常见的技巧，如**表驱动测试**，通常有助于优雅地组织测试代码。
- en: 'Table-driven tests are tests in which inputs are stored in the form of a table
    or a set of rows. Let’s take this example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表驱动测试是指将输入以表格或一系列行的形式存储的测试。让我们以这个例子为例：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this code, we initialize the `tests` variable with the test cases for our
    function and then iterate over it. Note that we use the `assert.Equal` function
    provided by the `github.com/stretchr/testify` library to compare the expected
    and the actual result of the function being tested. This library provides a set
    of convenient functions that can simplify your test logic. Without using the `assert`
    library, the code comparing the test result would look like the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们使用我们的函数的测试用例初始化`tests`变量，然后遍历它。请注意，我们使用`github.com/stretchr/testify`库提供的`assert.Equal`函数来比较被测试函数的预期结果和实际结果。这个库提供了一组方便的函数，可以简化你的测试逻辑。如果不使用`assert`库，比较测试结果的代码将如下所示：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Table-driven tests help reduce the repetitiveness of tests by separating test
    cases and the logic that performs actual checks. In general, these tests are good
    practice when you need to perform lots of similar checks against the defined goal
    states, as shown in our example.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 表驱动测试通过将测试用例和执行实际检查的逻辑分离，有助于减少测试的重复性。通常，当你需要针对定义的目标状态执行大量类似检查时，这些测试是良好的实践，如我们的示例所示。
- en: The table-driven format also helps us improve the readability of test code,
    making it easier to see and compare different test cases for the same functions.
    The format is quite common in Go tests; however, you can always organize your
    test code in the way that is the best for your use case.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 表驱动格式还有助于提高测试代码的可读性，使得查看和比较相同函数的不同测试用例变得更加容易。这种格式在Go测试中相当常见；然而，你始终可以根据你的用例组织测试代码。
- en: Now, let’s review the basic features provided by Go’s built-in testing library.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾Go内置测试库提供的基本功能。
- en: Subtests
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子测试
- en: One of the interesting features of the Go testing library is the ability to
    create **subtests** — tests that get executed inside other ones. Among the benefits
    of subtests is the ability to execute them separately, as well as to execute them
    in parallel for long-running tests and structure the test output in a more granular
    way.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Go测试库的一个有趣特性是能够创建**子测试**——在另一个测试中执行的测试。子测试的好处之一是能够单独执行它们，以及在长时间运行的测试中并行执行它们，并以更细粒度的方式结构化测试输出。
- en: 'Subtests are created by calling the `Run` function of the `testing` library:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 子测试是通过调用`testing`库的`Run`函数创建的：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When using the `Run` function, you need to pass the name of the test case and
    the function to execute, and Go will take care of executing each test case separately.
    Here’s an example of a test using the `Run` function:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`Run`函数时，你需要传递测试用例的名称和要执行的功能，Go将负责单独执行每个测试用例。以下是一个使用`Run`函数的测试示例：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding example, we created two subtests by calling the `Run` function
    twice, one time for each subtest.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们通过两次调用`Run`函数创建了两个子测试，一次为每个子测试。
- en: 'To achieve more fine-grained control over subtests, you can use the following
    options:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对子测试有更精细的控制，你可以使用以下选项：
- en: Each subtest, either passing or failing, can be shown separately in the output
    when running the `go test` command with the `-v` argument
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用带有`-v`参数的`go test`命令运行测试时，每个子测试（无论是通过还是失败）都可以在输出中单独显示
- en: You can run an individual test case by using a `-run` argument of the `go test`
    command
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用`go test`命令的`-run`参数运行单个测试用例
- en: 'There is one other interesting benefit of using the `Run` function. Let’s imagine
    that you have a function called `Process` that takes seconds to complete. If you
    have a table test with lots of test cases and you execute them sequentially, the
    execution of the entire test may take a lot of time. In this case, you could let
    the Go test runner execute tests in parallel mode by calling the `t.Parallel()`
    function. Let’s illustrate this in the following example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Run`函数还有另一个有趣的优点。让我们想象一下，你有一个名为`Process`的函数，它需要几秒钟才能完成。如果你有一个包含大量测试用例的表格测试，并且按顺序执行它们，整个测试的执行可能需要很长时间。在这种情况下，你可以通过调用`t.Parallel()`函数让Go测试运行器以并行模式执行测试。以下是一个示例：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In our example, we call the `t.Run` function for each test case, passing the
    test case name and the function to be executed. Then, we call `t.Parallel()` to
    make each test case execute in parallel. This optimization would significantly
    reduce the execution time in the case that our `Process` function is very slow.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们为每个测试用例调用 `t.Run` 函数，传递测试用例名称和要执行的功能。然后，我们调用 `t.Parallel()` 使每个测试用例并行执行。这种优化将显著减少我们的
    `Process` 函数运行缓慢时的执行时间。
- en: Skipping
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跳过
- en: 'Imagine that you want to execute your Go tests after each change on your computer,
    but you have some slow tests that take a long time to run. In that case, you would
    want to find a way to skip running tests under certain conditions. The Go testing
    library has built-in support for this – the `Skip` function. Let’s take this test
    function as an example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你希望在计算机上的每次更改后执行你的 Go 测试，但你有一些运行缓慢的测试，需要很长时间才能运行。在这种情况下，你将想要找到一种方法在特定条件下跳过运行测试。Go
    测试库对此有内置支持——`Skip` 函数。让我们以这个测试函数为例：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, we skip the test execution if there is a `RUNTIME_ENV`
    runtime environment variable with the `development` value. Note that we also provide
    the reason for skipping it inside the `t.Skip` call so that it is logged on test
    execution.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，如果存在具有 `development` 值的 `RUNTIME_ENV` 运行时环境变量，则会跳过测试执行。请注意，我们在 `t.Skip`
    调用中也提供了跳过的原因，以便在测试执行时记录。
- en: 'The skipping feature can be particularly useful for bypassing the execution
    of long-running tests, such as the tests performing slow I/O operations or doing
    lots of data processing. To support this, the Go testing library provides an ability
    to pass a specific flag, `-test.short`, to the `go test` command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过功能可以特别有用，用于绕过执行长时间运行的测试，例如执行缓慢的 I/O 操作或进行大量数据处理。为此，Go 测试库提供了一种将特定标志 `-test.short`
    传递给 `go test` 命令的能力：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With the `-test.short` flag, you can let the Go test runner know that you want
    to run tests in **short mode** — a testing mode when only special, short tests
    are getting executed. You can add the following logic to all long-running tests
    to exclude them in short mode:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-test.short` 标志，你可以让 Go 测试运行器知道你想要以 **简短模式** 运行测试——在这种模式下，只有特殊的短测试被执行。你可以在所有长时间运行的测试中添加以下逻辑来排除它们在简短模式下的执行：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding example, the test is skipped when the `-test.short` flag is
    passed to the `test` command.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，当将 `-test.short` 标志传递给 `test` 命令时，会跳过测试。
- en: Using the short testing mode is useful when some of your tests are much slower
    than others and you need to run tests very frequently. Skipping the slow tests
    and executing them less frequently could significantly increase your development
    speed and make your development experience much better.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当一些测试用例比其他测试用例慢得多，并且你需要非常频繁地运行测试时，使用简短测试模式是有用的。跳过慢速测试并减少它们的执行频率可以显著提高你的开发速度，并使你的开发体验变得更好。
- en: 'You can get familiar with the other Go testing features by checking out the
    official documentation for the `testing` package: [https://pkg.go.dev/testing](https://pkg.go.dev/testing).
    We are now going to proceed to the next section and focus on the details of implementing
    unit tests for our microservices.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过查看 `testing` 包的官方文档来熟悉其他 Go 测试功能：[https://pkg.go.dev/testing](https://pkg.go.dev/testing)。我们现在将进入下一节，重点关注为我们的微服务实现单元测试的细节。
- en: Unit tests
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: We have covered many useful features for automated testing of Go applications
    and are now ready to illustrate how to use them in our microservice code. First,
    we are going to start with **unit tests** — tests of individual units of code,
    such as structures and individual functions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了为 Go 应用程序自动化测试的许多有用功能，现在我们准备说明如何在我们的微服务代码中使用它们。首先，我们将从 **单元测试** 开始——对单个代码单元的测试，例如结构和单个函数。
- en: 'Let’s walk through the process of implementing unit tests for our code using
    the metadata service controller as an example. Currently, our controller file
    looks like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以元数据服务控制器为例，通过实现单元测试的过程。目前，我们的控制器文件看起来像这样：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s list what we would like to test in our code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出我们希望在代码中测试的内容：
- en: A `Get` call when the repository returns `ErrNotFound`
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当仓库返回 `ErrNotFound` 时进行的 `Get` 调用
- en: A `Get` call when the repository returns an error other than `ErrNotFound`
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当仓库返回除 `ErrNotFound` 之外的错误时的 `Get` 调用
- en: A `Get` call when the repository returns metadata and no error
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当仓库返回元数据和没有错误时的 `Get` 调用
- en: So far, we have three test cases to implement. All test cases need to perform
    operations on the metadata repository and we need to simulate three different
    responses from it. How exactly should we simulate the responses from our metadata
    repository in the test? Let’s explore the powerful technique that allows us to
    achieve this with our testing code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有三个测试案例需要实现。所有测试案例都需要对元数据仓库进行操作，我们需要模拟它从三个不同的响应。我们如何在测试中模拟元数据仓库的响应呢？让我们探索一种强大的技术，它允许我们通过测试代码实现这一点。
- en: Mocking
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟
- en: 'The technique of simulating responses from a component is called **mocking**.
    Mocking is often used in tests to simulate various scenarios, such as returning
    specific results or errors. There are multiple ways of using mocking in Go code.
    The first one is to implement the *fake* version of components, called **mocks**,
    manually. Let’s illustrate how to implement these mocks using our metadata repository
    as an example. Our metadata repository interface is defined in the following way:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从组件模拟响应的技术称为**模拟**。模拟通常用于测试以模拟各种场景，例如返回特定的结果或错误。在Go代码中，有多种使用模拟的方法。第一种是手动实现组件的*假*版本，称为**模拟**。让我们以我们的元数据仓库为例说明如何实现这些模拟。我们的元数据仓库接口定义如下：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The mock implementation of this interface could look like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口的模拟实现可能看起来像这样：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In our example mock of the metadata repository, we allow set values to be returned
    on the upcoming calls to the `Get` function by providing the `setReturnValues`
    function. The mock could be used to test our controller in the following way:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的元数据仓库示例模拟中，我们通过提供`setReturnValues`函数允许在即将到来的`Get`函数调用中返回设置值。模拟可以用来测试我们的控制器如下：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Manual implementation of mocks is a relatively simple way to test calls to various
    components that are outside of the scope of the package being tested. The downside
    of this approach is that you need to write mock code by yourself and update its
    code on any interface changes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 手动实现模拟是测试测试包范围之外的各个组件调用的相对简单的方法。这种方法的不利之处在于，你需要自己编写模拟代码，并在任何接口更改时更新其代码。
- en: 'The other way of using mocks is to use libraries that generate mocking code.
    An example of this kind of library is [https://github.com/golang/mock](https://github.com/golang/mock),
    which contains a mock generation tool called `mockgen`. You can install it by
    running the following command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模拟的另一种方法是使用生成模拟代码的库。这类库的一个例子是[https://github.com/golang/mock](https://github.com/golang/mock)，它包含一个名为`mockgen`的模拟生成工具。你可以通过运行以下命令来安装它：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `mockgen` tool can then be used in the following way:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以使用`mockgen`工具如下所示：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s illustrate how to generate mock code for our metadata repository. Run
    the following command from the `src` directory of our project:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下命令从我们项目的`src`目录生成我们元数据仓库的模拟代码：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should get the contents of a mock source file as the output. The contents
    would be similar to this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到模拟源文件的 内容作为输出。内容将类似于以下内容：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The generated mock code implements our interface and allows us to set the expected
    responses to our `Get` function in the following way:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的模拟代码实现了我们的接口，并允许我们以下方式设置对`Get`函数的预期响应：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The mock code generated by the `gomock` library provides some useful features
    that we have not implemented in our manually created mock version. One of them
    is the ability to set the expected number of times that the target function should
    be called using the `Times` function:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由`gomock`库生成的模拟代码提供了一些我们在手动创建的模拟版本中没有实现的有用功能。其中之一是使用`Times`函数设置目标函数应被调用的预期次数的能力：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding example, we limit the number of times the `Get` function is
    called to one. The `gomock` library verifies these constraints at the end of the
    test execution and reports whether the function was called a different number
    of times. This mechanism is pretty useful when you want to make sure the target
    function has definitely been called in your test.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们将`Get`函数被调用的次数限制为一次。`gomock`库在测试执行结束时验证这些约束，并报告函数是否被调用不同次数。当你想确保目标函数在测试中确实被调用时，这种机制非常有用。
- en: So far, we have shown how to use mocks in two different ways, and you may ask
    what the preferred way of using them is. Let’s compare the two approaches to find
    out the answer.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经展示了两种不同的使用模拟的方法，你可能想知道哪种方法是首选的。让我们比较这两种方法来找出答案。
- en: 'The benefit of implementing mocks manually is the ability to do so without
    using any external libraries, such as `gomock`. However, the downsides of this
    approach would be the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 手动实现模拟的好处是可以在不使用任何外部库的情况下进行，例如`gomock`。然而，这种方法的缺点如下：
- en: Manual implementation of mocks takes time
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动实现模拟需要花费时间
- en: Any changes to the mocked interfaces would require manual updates to the mock
    code
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对模拟接口的任何更改都需要手动更新模拟代码
- en: Harder to implement extra features that are provided by libraries such as `gomock`,
    such as call count verification
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现由如`gomock`之类的库提供的额外功能（如调用计数验证）更困难
- en: 'Using a library such as `gomock` for providing mock code would be beneficial
    for the following reasons:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用如`gomock`之类的库提供模拟代码将具有以下好处：
- en: Higher code consistency when all mocks are generated in the same way
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当所有模拟以相同方式生成时，代码一致性更高
- en: No need to write boilerplate code
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需编写样板代码
- en: An extended mock feature set
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展的模拟功能集
- en: In our comparison, automatic mock code generation seems to provide more advantages,
    so we will follow the `gomock`-based approach for automatic mock generation. In
    the next section, we are going to demonstrate how to do this for our services.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的比较中，自动模拟代码生成似乎提供了更多的优势，因此我们将遵循基于`gomock`的自动模拟生成方法。在下一节中，我们将展示如何为我们服务实现这一点。
- en: Implementing unit tests
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现单元测试
- en: 'We are going to illustrate how to implement controller unit tests using the
    generated `gomock` code. First, we will need to find a good place in our repository
    to put the generated code. We already have a directory called `gen` that is shared
    among the services. We can create a sub-directory called `mock` that we can use
    for various generated mocks. Run the mock generation command for the metadata
    repository again:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示如何使用生成的`gomock`代码实现控制器单元测试。首先，我们需要在我们的仓库中找到一个合适的地方来放置生成的代码。我们已经有了一个名为`gen`的目录，它被服务共享。我们可以创建一个名为`mock`的子目录，我们可以用它来存储各种生成的模拟。再次运行元数据仓库的模拟生成命令：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Copy its output to the file called `gen/mock/metadata/repository/repository.go`.
    Now, let’s add a test for our metadata service controller. Create a file called
    `controller_test.go` in its directory and add to it the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将其输出复制到名为`gen/mock/metadata/repository/repository.go`的文件中。现在，让我们为我们的元数据服务控制器添加一个测试。在其目录中创建一个名为`controller_test.go`的文件，并添加以下代码：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, add the following code, containing the test cases in a table format:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加以下代码，包含以表格格式组织的测试用例：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, add the code to execute our tests:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加执行我们的测试的代码：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The code that we just added implements three different test cases for our `Get`
    function using the generated repository mock. We let the mock return the specific
    values by calling the `EXPECT` function and passing the desired values. We organized
    our test in a table-driven way, which we described earlier in the chapter.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加的代码实现了针对我们的`Get`函数的三个不同测试用例，使用了生成的仓库模拟。我们通过调用`EXPECT`函数并传递期望的值，让模拟返回特定的值。我们以表格驱动的方式组织了我们的测试，这在章节中已经描述过。
- en: 'To run the tests, use the regular command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，请使用常规命令：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you did everything correctly, the output of the test should include `ok`.
    Congratulations, we have just implemented the unit tests and demonstrated how
    to use mocks! We will let you implement the remaining tests for the microservices
    yourself — it’s going to be a fair amount of work, but this is always a great
    investment for ensuring the code remains tested and reliable.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一切操作都正确，测试的输出应该包含`ok`。恭喜你，我们刚刚实现了单元测试并展示了如何使用模拟！我们将让你自己实现微服务的剩余测试——这将是一项相当多的工作，但这是确保代码始终经过测试和可靠的绝佳投资。
- en: In the next section, we are going to work on another type of test – integration
    tests. Knowing why and how to write integration tests in addition to regular unit
    tests for your microservices will help you to write more stable code and make
    sure all services work well in integration with each other.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将要处理另一种类型的测试——集成测试。了解为什么以及如何为你的微服务编写集成测试，除了常规的单元测试，将帮助你编写更稳定的代码，并确保所有服务在集成时能良好工作。
- en: Integration tests
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: '**Integration tests** are automated tests that verify the correctness of integrations
    between the individual units of your services and the services themselves. In
    this section, you are going to learn how to write integration tests and how to
    structure the logic inside them, as well as get some useful tips that will help
    you write your own integration tests in the future.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成测试**是自动化的测试，用于验证服务各个单元与自身之间的集成正确性。在本节中，您将学习如何编写集成测试以及如何在其中构建逻辑，同时获得一些有用的提示，这将帮助您在未来编写自己的集成测试。'
- en: Unlike unit tests that test the individual pieces of code, such as functions
    and structures, integration tests help ensure that the combinations of individual
    pieces still work well together.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与测试单个代码片段（如函数和结构）的单元测试不同，集成测试有助于确保各个代码片段的组合仍然能够良好地协同工作。
- en: 'Let’s provide an example of an integration test, taking our rating service
    as an example. The integration test for our service would instantiate both the
    service instance and the client for it and ensure that client requests would produce
    the expected results. As you remember, our rating service provides two API endpoints:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以我们的评级服务为例，提供一个集成测试的例子。我们的服务集成测试将实例化服务实例及其客户端，并确保客户端请求会产生预期的结果。如您所记，我们的评级服务提供了两个API端点：
- en: '`PutRating`: Writes a rating to the database'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PutRating`：将评级写入数据库'
- en: '`GetAggregatedRating`: Retrieves the ratings for a provided record (such as
    a movie) and returns the aggregated value'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetAggregatedRating`：检索提供的记录（如电影）的评级并返回聚合值'
- en: 'Our integration test for the rating service could have the following sequence
    of calls:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对评级服务的集成测试可能包含以下调用序列：
- en: Writes some data using the `PutRating` endpoint
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`PutRating`端点写入一些数据
- en: Verifies the data using the `GetAggregatedRating` endpoint
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`GetAggregatedRating`端点验证数据
- en: Writes new data using the `PutRating` endpoint
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`PutRating`端点写入新的数据
- en: Calls the `GetAggregatedRating` endpoint and checks that the aggregated value
    reflects the latest rating update
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`GetAggregatedRating`端点并检查聚合值是否反映了最新的评级更新
- en: In microservice development, integration tests usually test individual services
    or combinations of them – developers can write tests that target an arbitrary
    number of services.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务开发中，集成测试通常测试单个服务或它们的组合——开发者可以编写针对任意数量服务的测试。
- en: Unlike unit tests—which generally reside together with the code being tested
    and can access some internal functions, structures, constants, and variables—integration
    tests often treat the components being tested as **black boxes**. Black boxes
    are logical blocks for which the implementation details remain unknown and can
    only be accessed through publicly exposed APIs or user interfaces. This way of
    testing is called **black box testing** – testing of a system using a public interface,
    such as an API, instead of calling individual internal functions or accessing
    internal components of the system.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与通常与被测试代码一起存在并可以访问一些内部函数、结构、常量和变量的单元测试不同，集成测试通常将测试的组件视为**黑盒**。黑盒是逻辑块，其实现细节未知，只能通过公开的API或用户界面访问。这种测试方式被称为**黑盒测试**——使用公共接口（如API）测试系统，而不是调用单个内部函数或访问系统的内部组件。
- en: 'Microservice integration tests are often performed by instantiating service
    instances and performing requests either by calling service APIs or via asynchronous
    events in case the system handles requests in an asynchronous fashion. The structure
    of an integration test usually follows a similar pattern:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务集成测试通常通过实例化服务实例并执行请求来执行，这些请求可以通过调用服务API或通过异步事件（如果系统以异步方式处理请求）进行。集成测试的结构通常遵循类似的模式：
- en: '**Set up the test**: Instantiate the components being tested and any clients
    that can access their interfaces'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置测试**：实例化被测试的组件和任何可以访问其接口的客户端'
- en: '**Perform test operations and verify the correctness of results**: Run an arbitrary
    number of operations and compare the outputs from the system being tested, such
    as a microservice, to the expected values'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行测试操作并验证结果的正确性**：运行任意数量的操作，并将测试系统（如微服务）的输出与预期值进行比较'
- en: '**Tear down the test**: Gracefully terminate the test by tearing down the components
    instantiated in the setup, closing any clients if needed'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清理测试**：通过清理设置中实例化的组件，优雅地终止测试，如有必要关闭任何客户端'
- en: To illustrate how to write an integration test, let’s take three microservices
    from the previous chapters – metadata, movie, and rating services. To set up our
    test, we would need to instantiate six components – a server and a client for
    each microservice. To make it easier to run the test, we can instantiate servers
    using in-memory implementations of service registries and repositories.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何编写集成测试，让我们从上一章中的三个微服务——元数据、电影和评分服务——中取三个。为了设置我们的测试，我们需要实例化六个组件——每个微服务的服务器和客户端。为了更容易运行测试，我们可以使用服务注册表和存储库的内存实现来实例化服务器。
- en: 'Before you write the test, it’s often helpful to write down the set of operations
    to be tested and determine the expected outputs for each step. Let’s write down
    the plan for our integration test:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试之前，通常很有帮助的是写下要测试的操作集以及每个步骤的预期输出。让我们写下我们的集成测试计划：
- en: Write metadata for an example movie using the metadata service API (the `PutMetadata`
    endpoint) and check that the operation does not return any errors.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用元数据服务API（`PutMetadata`端点）为示例电影编写元数据，并检查操作没有返回任何错误。
- en: Retrieve the metadata for the same movie using the metadata service API (the
    `GetMetadata` endpoint) and check it matches the record that we submitted earlier.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用元数据服务API（`GetMetadata`端点）检索相同电影的元数据，并检查它是否与我们之前提交的记录匹配。
- en: Get the movie details (which should only consist of metadata) for our example
    movie using the movie service API (the `GetMovieDetails` endpoint) and make sure
    the result matches the data that we submitted earlier.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用电影服务API（`GetMovieDetails`端点）获取我们示例电影的详细信息（应仅包含元数据），并确保结果与之前提交的数据匹配。
- en: Write the first rating for our example movie using the rating service API (the
    `PutRating` endpoint) and check the operation does not return any errors.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用评分服务API（`PutRating`端点）为我们的示例电影写入第一个评分，并检查操作没有返回任何错误。
- en: Retrieve the initial aggregated rating for our movie using the rating service
    API (the `GetAggregatedRating` endpoint) and check that the value matches the
    one that we just submitted in the previous step.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用评分服务API（`GetAggregatedRating`端点）检索我们电影的初始聚合评分，并检查该值是否与我们之前步骤中提交的值匹配。
- en: Write the second rating for our example movie using the rating service API and
    check that the operation does not return any errors.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用评分服务API为我们的示例电影写入第二个评分，并检查操作没有返回任何错误。
- en: Retrieve the new aggregated rating for our movie using the rating service API
    and check that the value reflects the last rating.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用评分服务API检索我们电影的最新聚合评分，并检查该值反映了最后一个评分。
- en: Get the movie details for our example movie and check that the result includes
    the updated rating.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取我们示例电影的详细信息，并检查结果是否包含更新的评分。
- en: 'Having this kind of plan makes it easier to write the code for the integration
    test and brings us to the last step — actually implementing it:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有这样的计划使得编写集成测试的代码更容易，并带我们来到最后一步——实际实现它：
- en: 'Create a `test/integration` directory and add the file called `main.go` with
    the following code:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`test/integration`的目录，并添加一个名为`main.go`的文件，其中包含以下代码：
- en: '[PRE26]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let’s add some constants with service names and addresses that we can use later
    in the test to the file:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在文件中添加一些具有服务名称和地址的常量，我们可以在测试中稍后使用：
- en: '[PRE42]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The next step is to implement the setup code to instantiate our service servers:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是实现设置代码以实例化我们的服务服务器：
- en: '[PRE50]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note that `defer` calls to the `GracefulStop` function of each server — this
    code is a part of the tear-down logic of our test for terminating all servers
    gracefully.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意对每个服务器的`GracefulStop`函数的`defer`调用——这段代码是我们测试的拆除逻辑的一部分，用于优雅地终止所有服务器。
- en: 'Now, let’s set up the test clients for our services:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们设置我们的服务测试客户端：
- en: '[PRE61]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now, we are ready to implement the sequence of our test commands. The first
    step is to test, write, and read the operations of the metadata service:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好实现测试命令的序列。第一步是测试、编写和读取元数据服务的操作：
- en: '[PRE80]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: You may notice that we used the `cmpopts.IgnoreUnexported(gen.Metadata{})` option
    inside the call to the `cmp.Diff` function — this tells the `cmp` library to ignore
    the unexported fields in the `gen.Metadata` structure. We have added this option
    because the `gen.Metadata` structure, generated by the Protocol Buffers code generator,
    includes some private fields that we want to ignore in the comparison.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到我们在调用`cmp.Diff`函数时使用了`cmpopts.IgnoreUnexported(gen.Metadata{})`选项——这告诉`cmp`库忽略`gen.Metadata`结构中的未导出字段。我们添加此选项是因为由Protocol
    Buffers代码生成器生成的`gen.Metadata`结构包括一些我们希望在比较中忽略的私有字段。
- en: 'The next test in our sequence would be to retrieve the movie details and check
    that the metadata matches the record that we submitted earlier:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们序列中的下一个测试将是检索电影详情并检查元数据是否与我们之前提交的记录匹配：
- en: '[PRE81]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Now, we are ready to test the rating service.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好测试评分服务了。
- en: 'Let’s implement two tests – one for writing a rating and one for retrieving
    the initial aggregated value, which should match the first rating:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现两个测试——一个用于写入评分，另一个用于检索初始聚合值，它应该与第一个评分匹配：
- en: '[PRE82]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The next part of the test would be to submit the second rating and check that
    the aggregated value was changed:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的下一部分将是提交第二个评分并检查聚合值是否已更改：
- en: '[PRE83]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We are almost done with our `main` function – let’s implement the last check:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了`main`函数的实现——让我们实现最后的检查：
- en: '[PRE84]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Our integration test is almost ready. Let’s add the functions for initializing
    the servers for our services below the `main` function. First, add the function
    for creating the server for a metadata service:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的集成测试几乎准备好了。让我们在`main`函数下方添加初始化我们服务服务器的函数。首先，添加创建元数据服务服务器的函数：
- en: '[PRE85]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: You may notice that we call the `srv.Serve` function inside a goroutine — this
    way, it doesn’t block the execution and allows us to immediately return from the
    function.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到我们在goroutine内部调用了`srv.Serve`函数——这样它就不会阻塞执行，并允许我们立即从函数返回。
- en: 'Let’s add a similar implementation for the rating service server to the same
    file:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在同一文件中添加与评分服务服务器类似的实现：
- en: '[PRE86]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Finally, let’s add a function for initializing the movie server:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们添加一个初始化电影服务器的函数：
- en: '[PRE87]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Our integration test is ready! You can run it by executing the following command:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的集成测试已经准备好了！你可以通过执行以下命令来运行它：
- en: '[PRE88]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'If everything is correct, you should see the following output:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正确，你应该看到以下输出：
- en: '[PRE89]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: As you may notice, the structure of our integration test precisely matches the
    sequence of test operations that we defined earlier. We implemented our integration
    test as an executable command and added enough log messages to help you with debugging
    – if any step fails, it is therefore easier to understand at which step the failure
    occurred and which operations preceded that step.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，我们的集成测试的结构与之前定义的测试操作序列精确匹配。我们将集成测试实现为一个可执行命令，并添加了足够的日志消息以帮助您进行调试——如果任何步骤失败，因此更容易理解失败发生在哪个步骤以及哪些操作先于该步骤。
- en: 'It is important to note that we used the in-memory versions of the metadata
    and rating repositories in our integration test. An alternative approach would
    be to set up an integration test that stores the data in some persistent databases,
    such as MySQL. However, there are some challenges with using existing persistent
    databases in integration tests:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们在集成测试中使用了元数据和评分存储库的内存版本。另一种方法是设置一个将数据存储在某些持久数据库（如MySQL）中的集成测试。然而，在集成测试中使用现有的持久数据库存在一些挑战：
- en: Integration test data should not interfere with user data. Otherwise, it may
    cause unexpected effects on existing service users.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试数据不应干扰用户数据。否则，它可能对现有服务用户产生意外影响。
- en: Ideally, test data should be cleaned up after test execution so that the database
    does not get filled with unnecessary, temporary data.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理想情况下，测试执行后应该清理测试数据，以免数据库被不必要的临时数据填满。
- en: In order to avoid interference with the existing user data, I would suggest
    running integration tests on non-production environments, such as staging. Additionally,
    I would suggest always generating random identifiers for your test records to
    make sure that individual test executions don’t affect each other. For example,
    you can use the [github.com/google/uuid](http://github.com/google/uuid) library
    to generate new identifiers using the `uuid.New()` function. Lastly, I would recommend
    always including cleanup code at the end of each integration test that uses persistent
    data storage to clean up the created records, whenever this is possible.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免与现有用户数据发生干扰，我建议在非生产环境中运行集成测试，例如在预发布环境中。此外，我建议始终为你的测试记录生成随机标识符，以确保单个测试执行不会相互影响。例如，你可以使用[github.com/google/uuid](http://github.com/google/uuid)库通过`uuid.New()`函数生成新的标识符。最后，我建议在可能的情况下，始终在每个使用持久数据存储的集成测试结束时包含清理代码，以清理创建的记录。
- en: 'Now, the question is when we should write integration tests. It is always up
    to you; however, I do have some general suggestions:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问题是我们在什么时候应该编写集成测试。这始终取决于你；然而，我确实有一些一般性的建议：
- en: '**Test critical flows**: Make sure you test the entire flows, such as user
    signups and logins'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试关键流程**：确保你测试整个流程，例如用户注册和登录'
- en: '**Test critical endpoints**: Perform the tests of the most critical endpoints
    that your services provide to your users'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试关键端点**：执行对你用户提供的最关键端点的测试'
- en: Additionally, you may have integration tests that are executed after each code
    change. Systems such as Jenkins provide these kinds of features and allow you
    to plug any custom logic that would be executed into each update of your code.
    We won’t cover Jenkins setup in this book, but you can familiarize yourself with
    its documentation on the official website (https://www.jenkins.io).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可能有一些在每次代码更改后执行的集成测试。像Jenkins这样的系统提供了这些功能，并允许你将任何自定义逻辑插入到代码的每次更新中。本书不会涵盖Jenkins的设置，但你可以在官方网站（https://www.jenkins.io）上熟悉其文档。
- en: As we have illustrated how to write both unit and integration tests, let’s proceed
    to the next section of the book, describing some of the best practices of Go testing.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所展示的如何编写单元测试和集成测试，让我们继续到本书的下一部分，描述一些Go测试的最佳实践。
- en: Testing best practices
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试最佳实践
- en: In this section, we are going to list some additional useful testing tips that
    are going to help you to improve the quality of your tests.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将列出一些额外的有用测试技巧，这些技巧将帮助你提高测试质量。
- en: Using helpful messages
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用有帮助的消息
- en: 'One of the most important aspects of writing tests is providing enough information
    in error logs that it is easy to understand exactly what went wrong and which
    test case triggered the failure. Consider the following test case code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试最重要的方面之一是在错误日志中提供足够的信息，以便容易理解到底发生了什么错误，以及哪个测试用例触发了失败。考虑以下测试用例代码：
- en: '[PRE90]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The error log does not include both the expected and the actual value received
    from the function being tested, making it harder to understand what the function
    returned and how it was different from the expected value.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 错误日志没有包括从被测试的函数接收到的预期和实际值，这使得理解函数返回的内容以及它与预期值的不同变得更加困难。
- en: 'The better log line would be as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的日志行应该是这样的：
- en: '[PRE91]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This log line includes the expected and the actual returned value of the function
    and provides much more context to you when you debug the test.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这条日志行包含了函数预期的和实际返回的值，并在调试测试时为你提供了更多的上下文。
- en: Important note
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that in our test logs, first, we log the actual value and then the expected
    one. This order is recommended by the Go team as the conventional way of logging
    the values in tests and is followed in all libraries and packages. Follow the
    same order in your logs for consistency.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在我们的测试日志中，首先记录实际值，然后是预期值。这种顺序是由Go团队推荐的测试中记录值的传统方式，并且被所有库和包遵循。在你的日志中遵循相同的顺序以保持一致性。
- en: 'An even better error message would be as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的错误消息如下：
- en: '[PRE92]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This error log message includes some additional information – the function being
    called and the input argument that was passed to it.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误日志消息包括一些额外的信息——被调用的函数以及传递给它的输入参数。
- en: 'To standardize the code for your test cases, you can use the `github.com/stretchr/testify`
    library. The following example illustrates how to compare the expected and the
    actual value and log the name of the function being tested, as well as the argument
    passed to it:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了标准化测试用例的代码，你可以使用 `github.com/stretchr/testify` 库。以下示例说明了如何比较预期值和实际值，并记录正在测试的函数名称以及传递给它的参数：
- en: '[PRE93]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The assert package of the `github.com/stretchr/testify` library prints both
    the expected and the actual value of the test result, as well as providing the
    details about the test case (the `fmt.Sprintf` result, in our case).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`github.com/stretchr/testify` 库的 assert 包会打印测试结果的预期值和实际值，并提供关于测试用例的详细信息（在我们的例子中是
    `fmt.Sprintf` 的结果）。'
- en: Avoiding the use of Fatal in your logs
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免在日志中使用 `Fatal`
- en: 'The built-in Go testing library includes different functions for logging errors,
    including `Error`, `Errorf`, `Fatal`, and `Fatalf`. The last two functions print
    the logs and interrupt the execution of the tests. Consider this test code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 Go 测试库包含了用于记录错误的多个函数，包括 `Error`、`Errorf`、`Fatal` 和 `Fatalf`。后两个函数会打印日志并中断测试的执行。考虑以下测试代码：
- en: '[PRE94]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The call to the `Fatalf` function interrupts the test execution. Interrupting
    test execution is often not the best idea because it leads to fewer tests being
    executed. Executing fewer tests leaves the developer with less information for
    the remaining failing test cases. Fixing one error and running all the tests again
    may be a suboptimal experience for many developers and it is often better to continue
    the test execution whenever possible.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `Fatalf` 函数会中断测试执行。中断测试执行通常不是最佳选择，因为它会导致执行的测试较少。执行较少的测试会使开发者对剩余的失败测试用例的信息更少。对于许多开发者来说，修复一个错误并重新运行所有测试可能是一个次优体验，并且尽可能继续测试执行通常更好。
- en: 'The previous example can be re-written as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以重写如下：
- en: '[PRE95]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: If you use this code in a loop, you can add `continue` after the `Errorf` call
    to proceed to the next test cases.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个循环中使用此代码，你可以在 `Errorf` 调用之后添加 `continue` 以继续下一个测试用例。
- en: Making a comparison using a cmp library
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 cmp 库进行比较
- en: 'Imagine that you have a test that compares the `Metadata` structure that we
    defined in [*Chapter 2*](B18865_02.xhtml#_idTextAnchor027):'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个测试，它比较我们在 [*第 2 章*](B18865_02.xhtml#_idTextAnchor027) 中定义的 `Metadata`
    结构：
- en: '[PRE96]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The code here would not work for structure references – in our code, the `want`
    variable holds a pointer to the `model.Metadata` structure, so the `!=` operator
    will return `true` even for structures with the same field values if these structures
    are created separately.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码对于结构引用将不起作用——在我们的代码中，`want` 变量持有 `model.Metadata` 结构的指针，因此即使这些结构具有相同的字段值，`!=`
    操作符也会返回 `true`，前提是这些结构是分别创建的。
- en: 'A comparison of structure pointers can be made in Go using the `reflect.DeepEqual`
    function:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，可以使用 `reflect.DeepEqual` 函数比较结构指针：
- en: '[PRE97]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: However, the output of the test may not be easy to read. Consider that you have
    lots of fields inside the `Metadata` structure – if only one field is different,
    you will need to scan through both structures to find the difference. There is
    a convenient library that simplifies comparison in tests called `cmp` (https://pkg.go.dev/github.com/google/go-cmp/cmp).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，测试的输出可能不易阅读。考虑一下，`Metadata` 结构内部有很多字段——如果只有一个字段不同，你需要扫描两个结构以找到差异。有一个方便的库可以简化测试中的比较，称为
    `cmp`（https://pkg.go.dev/github.com/google/go-cmp/cmp）。
- en: 'The `cmp` library allows you to compare arbitrary Go structures in the same
    way as with `reflect.DeepEqual`, but it also provides human-readable output. Here’s
    an example of using the function:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmp` 库允许你以与 `reflect.DeepEqual` 相同的方式比较任意的 Go 结构，但它还提供了可读性强的输出。以下是一个使用该函数的示例：'
- en: '[PRE98]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'If the structures don’t match, the `diff` variable will be a non-empty string,
    including the printable representation of the differences between them. Here’s
    an example of this kind of output:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结构不匹配，`diff` 变量将是一个非空字符串，包括它们之间差异的可打印表示。以下是一个此类输出的示例：
- en: '[PRE99]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Note how the `cmp` library highlighted the differences between both structures
    using the `–` and `+` prefixes. Now, it is easy to read the test output and notice
    the differences between the structures — this kind of optimization will save you
    lots of time during debugging.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `cmp` 库如何使用 `–` 和 `+` 前缀突出显示两个结构之间的差异。现在，阅读测试输出并注意结构之间的差异变得容易——这种优化将在调试过程中为你节省大量时间。
- en: This summarizes our short collection of Go testing best practices — you can
    find more tips by reading the documents mentioned in the *Further reading* section.
    Make sure to familiarize yourself with the official recommendations and the comments
    for the `testing` package to learn how to write tests in a conventional way and
    leverage all the features provided by the built-in Go testing library.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这总结了我们的 Go 测试最佳实践简编——您可以通过阅读*进一步阅读*部分中提到的文档来找到更多提示。请确保熟悉官方推荐和`testing`包的注释，以了解如何以传统方式编写测试并利用内置的
    Go 测试库提供的所有功能。
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered multiple topics related to Go testing, including
    the common features of the Go testing library and the basics of writing unit and
    integration tests for your code. You have learned how to add tests to your microservices,
    optimize test execution in various cases, create test mocks, and maximize the
    quality of your tests by following the best testing practices. The knowledge you
    gained from reading this chapter should help you to increase the efficiency of
    your testing logic and increase the reliability of your microservices.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了与 Go 测试相关的多个主题，包括 Go 测试库的常见特性和编写单元和集成测试的基础。您已经学会了如何向您的微服务添加测试，如何在各种情况下优化测试执行，创建测试模拟，并通过遵循最佳测试实践来最大化测试质量。您从阅读本章中获得的知识应该有助于提高您测试逻辑的效率，并提高您微服务的可靠性。
- en: In the next chapter, we will move to a new topic, that will cover the main aspects
    of service reliability and describe various techniques for making your services
    resilient to various types of failures.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将转向一个新的主题，该主题将涵盖服务可靠性的主要方面，并描述各种使您的服务能够应对各种类型故障的技术。
- en: Further reading
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Golang test comments: [https://github.com/golang/go/wiki/TestComments](https://github.com/golang/go/wiki/TestComments
    )'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Golang 测试注释：[https://github.com/golang/go/wiki/TestComments](https://github.com/golang/go/wiki/TestComments)
- en: 'Golang testing package documentation: [https://pkg.go.dev/testing](https://pkg.go.dev/testing)'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Golang 测试包文档：[https://pkg.go.dev/testing](https://pkg.go.dev/testing)
- en: '*Using Subtests and Sub-benchmarks*: [https://go.dev/blog/subtests](https://go.dev/blog/subtests)'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用子测试和子基准测试*：[https://go.dev/blog/subtests](https://go.dev/blog/subtests)'
- en: 'Part 3: Maintenance'
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：维护
- en: This part covers some advanced topics of Go microservice development, such as
    reliability, observability, alerting, ownership, and security. You will learn
    how to handle different types of microservice-related issues, how to collect and
    analyze service performance data, how to set up automated service incident alerting,
    and how to secure communication between your microservices. The part includes
    lots of best practices and examples that will help to apply the newly gained knowledge
    to your microservices.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分涵盖了 Go 微服务开发的一些高级主题，例如可靠性、可观察性、警报、所有权和安全。您将学习如何处理不同类型的微服务相关问题，如何收集和分析服务性能数据，如何设置自动服务事件警报，以及如何确保微服务之间的通信安全。本部分包括许多最佳实践和示例，这些示例将帮助您将新获得的知识应用到您的微服务中。
- en: 'This contains the following chapters:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括以下章节：
- en: '[*Chapter 10*](B18865_10.xhtml#_idTextAnchor139), Reliability Overview'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B18865_10.xhtml#_idTextAnchor139)，可靠性概述'
- en: '[*Chapter 11*](B18865_11.xhtml#_idTextAnchor152), Collecting Service Telemetry
    Data'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B18865_11.xhtml#_idTextAnchor152)，收集服务遥测数据'
- en: '[*Chapter 12*](B18865_12.xhtml#_idTextAnchor171), Setting up Service Alerting'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B18865_12.xhtml#_idTextAnchor171)，设置服务警报'
- en: '[*Chapter 13*](B18865_13.xhtml#_idTextAnchor181), Advanced Topics'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B18865_13.xhtml#_idTextAnchor181)，高级主题'
