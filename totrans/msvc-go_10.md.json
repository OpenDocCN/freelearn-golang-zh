["```go\n    resp, err := client.GetMetadata(ctx, &gen.GetMetadataRequest{MovieId: id})\n    if err != nil {\n        return nil, err\n    }\n```", "```go\nfunc (h *Handler) GetMetadata(ctx context.Context, req *gen.GetMetadataRequest) (*gen.GetMetadataResponse, error) {\n    if req == nil || req.MovieId == \"\" {\n        return nil, status.Errorf(codes.InvalidArgument, \"nil req or empty id\")\n    }\n    m, err := h.ctrl.Get(ctx, req.MovieId)\n    if err != nil && errors.Is(err, metadata.ErrNotFound) {\n        return nil, status.Errorf(codes.NotFound, err.Error())\n    } else if err != nil {\n        return nil, status.Errorf(codes.Internal, err.Error())\n    }\n    return &gen.GetMetadataResponse{Metadata: model.MetadataToProto(m)}, nil\n}\n```", "```go\n// Get returns movie metadata by a movie id.\nfunc (g *Gateway) Get(ctx context.Context, id string) (*model.Metadata, error) {\n    conn, err := grpcutil.ServiceConnection(ctx, \"metadata\", g.registry)\n    if err != nil {\n        return nil, err\n    }\n    defer conn.Close()\n    client := gen.NewMetadataServiceClient(conn)\n    var resp *model.Metadata\n    const maxRetries = 5\n    for i := 0; i < maxRetries; i++ {\n        resp, err = client.GetMetadata(ctx, &gen.GetMetadataRequest{MovieId: id})\n        if err != nil {\n            if shouldRetry(err) {\n                continue\n            }\n            return nil, err\n        }\n        return model.MetadataFromProto(resp.Metadata), nil\n    }\n    return nil, err\n}\n```", "```go\nfunc shouldRetry(err error) bool {\n    e, ok := status.FromError(err)\n    if !ok {\n        return false\n    }\n    return e.Code() == codes.DeadlineExceeded || e.Code() == codes.ResourceExhausted || e.Code() == codes.Unavailable\n}\n```", "```go\nfunc TimeoutExample(ctx context.Context, args Args) {\n    const timeout = 10 * time.Second\n    ctx, cancel := context.WithTimeout(ctx, timeout)\n    defer cancel()\n    resp, err := SomeOperation(ctx, args)\n}\n```", "```go\ndeadline := time.Parse(time.RFC3339, \"2074-01-01T00:00:00Z\")\nctx, cancel := context.WithDeadline(ctx, deadline)\ndefer cancel()\nresp, err := SomeOperation(ctx, args)\n```", "```go\n    ratings, err := c.repo.Get(ctx, recordID, recordType)\n    if err != nil && err == repository.ErrNotFound {\n        return 0, ErrNotFound\n    } else if err != nil {\n        log.Printf(\"Failed to get ratings for %v %v: %v\", recordID, recordType, err)\n        log.Printf(\"Fallback: returning locally cached ratings for %v %v\", recordID, recordType)\n        return c.getCachedRatings(recordID, recordType)\n    }\n```", "```go\npackage main\nimport (\n    \"fmt\"\n    \"golang.org/x/time/rate\"\n)\nfunc main() {\n    limit := 3\n    burst := 3\n    limiter := rate.NewLimiter(rate.Limit(limit), burst)\n    for i := 0; i < 100; i++ {\n        if limiter.Allow() {\n            fmt.Println(\"allowed\")\n        } else {\n            fmt.Println(\"not allowed\")\n        }\n    }\n}\n```", "```go\n    “github.com/grpc-ecosystem/go-grpc-middleware/ratelimit\"\n    ```", "```go\n        const limit = 100\n    ```", "```go\n        const burst = 100\n    ```", "```go\n        l := newLimiter(100, 100)\n    ```", "```go\n        srv := grpc.NewServer(grpc.UnaryInterceptor(ratelimit.UnaryServerInterceptor(l)))\n    ```", "```go\n    type limiter struct {\n    ```", "```go\n        l *rate.Limiter\n    ```", "```go\n    }\n    ```", "```go\n    func newLimiter(limit int, burst int) *limiter {\n    ```", "```go\n        return &limiter{rate.NewLimiter(rate.Limit(limit), burst)}\n    ```", "```go\n    }\n    ```", "```go\n    func (l *limiter) Limit() bool {\n    ```", "```go\n        return l.l.Allow()\n    ```", "```go\n    }\n    ```", "```go\n    sigChan := make(chan os.Signal, 1)\n    signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)\n    var wg sync.WaitGroup\n    wg.Add(1)\n    go func() {\n        defer wg.Done()\n        s := <-sigChan\n        log.Printf(\"Received signal %v, attempting graceful shutdown\", s)\n        // Graceful shutdown logic.\n    }()\n    wg.Wait()\n```", "```go\nfunc main() {\n    defer func() {\n        if err := recover(); err != nil {\n            log.Printf(\"Panic occurred, attempting graceful shutdown\")\n            // Graceful shutdown logic.\n        }\n    }()\n    panic(\"panic example\")\n}\n```", "```go\nctx, cancel := context.WithCancel(context.Background())\n```", "```go\n    sigChan := make(chan os.Signal, 1)\n    signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)\n    var wg sync.WaitGroup\n    wg.Add(1)\n    go func() {\n        defer wg.Done()\n        s := <-sigChan\n        cancel()\n        log.Printf(\"Received signal %v, attempting graceful shutdown\", s)\n        srv.GracefulStop()\n        log.Println(\"Gracefully stopped the gRPC server\")\n    }()\n```", "```go\nwg.Wait()\n```", "```go\n2022/10/13 08:55:05 Received signal interrupt, attempting graceful shutdown\n2022/10/13 08:55:05 Gracefully stopped the gRPC server\n```", "```go\nrating_service_fd_limit_reached:\n  mitigation: Restart the service\n```"]