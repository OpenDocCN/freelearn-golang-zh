["```go\n2022/06/06 23:00:00 Service started\n2022/06/06 23:00:01 Connecting to the database\n2022/06/06 23:00:11 Unable to connect to the database: timeout error\n```", "```go\nlog.Printf(\"Starting the metadata service on port %d\", port)\n```", "```go\n2022/07/01 13:05:21 Starting the metadata service on port 8081\n```", "```go\n    2022/11/10 23:00:00 network unavailable\n    ```", "```go\n    panic: network unavailable\n    ```", "```go\n{\"level\":\"info\", \"time\":\"2022-09-04T20:10:10+1:00\",\"message\":\"Service started\", \"service\":\"metadata\"}\n```", "```go\n2022/06/06 23:00:00 Connection terminated\n```", "```go\npackage main\nimport \"go.uber.org/zap\"\nfunc main() {\n    logger, _ := zap.NewProduction()\n    logger.Info(\"Started the service\", zap.String(\"serviceName\", \"metadata\"))\n}\n```", "```go\n{\"level\":\"info\",\"ts\":1257894000,\"caller\":\"sandbox1575103092/prog.go:11\",\"msg\":\"Started the service\",\"serviceName\":\"metadata\"}\n```", "```go\nlogger.Info(\"Request timed out\", zap.Duration(\"timeout\", 10*time.Second))\n```", "```go\n// Metadata defines the movie metadata.\ntype Metadata struct {\n    ID          string `json:\"id\"`\n    Title       string `json:\"title\"`\n    Description string `json:\"description\"`\n    Director    string `json:\"director\"`\n}\n```", "```go\nfunc (m *Metadata) String() string {\n    return fmt.Sprintf(\"Metadata{id=%s, title=%s, description=%s, director=%s}\", m.ID, m.Title, m.Description, m.Director)\n}\n```", "```go\nlogger.Debug(\"Retrieved movie metadata\", zap.Stringer(\"metadata\", metadata))\n```", "```go\n{\"level\":\"debug\",\"msg\":\"Retrieved movie metadata\",\"metadata\":\"Metadata{id=id, title=title, description=description, director=director}\"}\n```", "```go\nlogger = logger.With(zap.String(\"endpoint\", \"PutRating\"), zap.String(\"ratingId\", ratingID))\nlogger.Debug(\"Received a PutRating request\")\n// endpoint logic\nlogger.Debug(\"Processed a PutRating request\")\n```", "```go\nfunc New(logger *zap.Logger, ctrl *rating.Controller) *Handler{ \n    return &Handler{logger.With(\"component\": \"ratingController\"), ctrl}\n}\n```", "```go\nlogger.Infof(\"User %s successfully registered\", userID)\n```", "```go\nlogger.Infof(\"User successfully registered\", zap.String(\"userId\", userID))\n```", "```go\n    package logging\n    ```", "```go\n    const (\n    ```", "```go\n      FieldService  = \"service\"\n    ```", "```go\n      FieldEndpoint = \"endpoint\"\n    ```", "```go\n    ...\n    ```", "```go\n    )\n    ```", "```go\n    func (h *Handler) PutRating(ctx context.Context, req *PutRatingRequest) (*PutRatingResponse, error) {\n    ```", "```go\n        logger := h.logger.With(logging.FieldEndpoint, \"putRating\")\n    ```", "```go\n        // Now we can make sure the endpoint field is set across all handler logic.\n    ```", "```go\n    ...\n    ```", "```go\n    }\n    ```", "```go\n    func main() {\n    ```", "```go\n        logger, _ := zap.NewProduction()\n    ```", "```go\n        logger = logger.With(logging.FieldService, \"rating\")\n    ```", "```go\n        // Pass the initialized logger to all service components.\n    ```", "```go\n{\"level\":\"error\", \"time\":\"2022-09-04T20:10:10+1:00\",\"message\":\"Request timed out\"}\n```", "```go\n{\"level\":\"error\", \"time\":\"2022-09-04T20:10:10+1:00\",\"message\":\"Request timed out\", \"service\":\"rating\", \"component\": \"handler\", \"endpoint\": \"putRating\", \"file\": \"handler.go\"}\n```", "```go\ntype Counter interface {\n    // Inc increments the counter by a delta.\n    Inc(delta int64)\n}\n```", "```go\ntype Gauge interface {\n    // Update sets the gauges absolute value.\n    Update(value float64)\n}\n```", "```go\nhttp_requests_total{environment=\"production\",method!=\"GET\"}\n```", "```go\nstatter, err := statsd.NewBufferedClient(\"127.0.0.1:8125\",\"stats\", time.Second, 1440)\nif err != nil {\n    panic(err)\n}\nreporter := tallystatsd.NewReporter(statter, tallystatsd.Options{\n    SampleRate: 1.0,\n})\nscope, closer := tally.NewRootScope(tally.ScopeOptions{\n    Tags:     map[string]string{\"service\": \"rating\"},\n    Reporter: reporter,\n}, time.Second)\n```", "```go\ncounter := scope.Counter(\"request_count\")\ncounter.Inc(1)\n```", "```go\ncounter := scope.Tagged(map[string]string{\"operation\": \"put\"}).Counter(\"request_count\")\n```", "```go\ngauge := scope.Gauge(\"active_user_count\")\ngauge.Update(userCount)\n```", "```go\nfunc latencyTrackingExample(scope tally.Scope) {\n    timer := scope.Timer(\"operation_latency\")\n    stopwatch := timer.Start()\n    defer stopwatch.Stop()\n    // Function logic.\n}\n```", "```go\nfunc DefaultHistogramBuckets() []float64 {\n    return []float64{\n        ms,\n        2 * ms,\n        5 * ms,\n        10 * ms,\n        20 * ms,\n        50 * ms,\n        100 * ms,\n        200 * ms,\n        500 * ms,\n        1000 * ms,\n        2000 * ms,\n        5000 * ms,\n        10000 * ms,\n    }\n}\n```", "```go\nhistogram := scope.Histogram(\"user_age_distribution\", tally.MustMakeLinearValueBuckets(0, 1, 130))\nhistogram.RecordValue(userAgeInYears)\n```", "```go\n--storage.tsdb.retention.time=60d\n```", "```go\nfunc ProcessRequest(ctx context.Context, ...) {\n    return ProcessAnotherRequest(ctx, ...)\n}\n```", "```go\nfunc ProcessRequest(ctx context.Context, ...) {\n    newCtx = context.WithValue(ctx, someKey, someValue)\n    return ProcessAnotherRequest(newCtx, ...)\n}\n```", "```go\n    package main\n    ```", "```go\n    type config struct {\n    ```", "```go\n        API    apiConfig    `yaml:\"api\"`\n    ```", "```go\n        Jaeger jaegerConfig `yaml:\"jaeger\"`\n    ```", "```go\n    }\n    ```", "```go\n    type apiConfig struct {\n    ```", "```go\n        Port int `yaml:\"port\"`\n    ```", "```go\n    }\n    ```", "```go\n    type jaegerConfig struct {\n    ```", "```go\n        URL string `yaml:\"url\"`\n    ```", "```go\n    }\n    ```", "```go\n    jaeger:\n    ```", "```go\n      url: http://localhost:14268/api/traces\n    ```", "```go\n    package tracing\n    ```", "```go\n    import (\n    ```", "```go\n        \"go.opentelemetry.io/otel/exporters/jaeger\"\n    ```", "```go\n        \"go.opentelemetry.io/otel/sdk/resource\"\n    ```", "```go\n        tracesdk \"go.opentelemetry.io/otel/sdk/trace\"\n    ```", "```go\n        semconv \"go.opentelemetry.io/otel/semconv/v1.12.0\"\n    ```", "```go\n    )\n    ```", "```go\n    // NewJaegerProvider returns a new jaeger-based tracing provider.\n    ```", "```go\n    func NewJaegerProvider(url string, serviceName string) (*tracesdk.TracerProvider, error) {\n    ```", "```go\n        exp, err := jaeger.New(jaeger.WithCollectorEndpoint(jaeger.WithEndpoint(url)))\n    ```", "```go\n        if err != nil {\n    ```", "```go\n            return nil, err\n    ```", "```go\n        }\n    ```", "```go\n        tp := tracesdk.NewTracerProvider(\n    ```", "```go\n            tracesdk.WithBatcher(exp),\n    ```", "```go\n            tracesdk.WithResource(resource.NewWithAttributes(\n    ```", "```go\n                semconv.SchemaURL,\n    ```", "```go\n                semconv.ServiceNameKey.String(serviceName),\n    ```", "```go\n            )),\n    ```", "```go\n        )\n    ```", "```go\n        return tp, nil\n    ```", "```go\n    }\n    ```", "```go\n        tp, err := tracing.NewJaegerProvider(cfg.Jaeger.URL, serviceName)\n    ```", "```go\n        if err != nil {\n    ```", "```go\n            log.Fatal(err)\n    ```", "```go\n        }\n    ```", "```go\n        defer func() {\n    ```", "```go\n            if err := tp.Shutdown(ctx); err != nil {\n    ```", "```go\n                log.Fatal(err)\n    ```", "```go\n            }\n    ```", "```go\n        }()\n    ```", "```go\n        otel.SetTracerProvider(tp)\n    ```", "```go\n        otel.SetTextMapPropagator(propagation.TraceContext{})\n    ```", "```go\n    package grpcutil\n    ```", "```go\n    import (\n    ```", "```go\n        \"context\"\n    ```", "```go\n        \"math/rand\"\n    ```", "```go\n        \"go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc\"\n    ```", "```go\n        \"google.golang.org/grpc\"\n    ```", "```go\n        \"google.golang.org/grpc/credentials/insecure\"\n    ```", "```go\n        \"movieexample.com/pkg/discovery\"\n    ```", "```go\n    )\n    ```", "```go\n    // ServiceConnection attempts to select a random service // instance and returns a gRPC connection to it.\n    ```", "```go\n    func ServiceConnection(ctx context.Context, serviceName string, registry discovery.Registry) (*grpc.ClientConn, error) {\n    ```", "```go\n        addrs, err := registry.ServiceAddresses(ctx, serviceName)\n    ```", "```go\n        if err != nil {\n    ```", "```go\n            return nil, err\n    ```", "```go\n        }\n    ```", "```go\n        return grpc.Dial(\n    ```", "```go\n            addrs[rand.Intn(len(addrs))],\n    ```", "```go\n            grpc.WithTransportCredentials(insecure.NewCredentials()),\n    ```", "```go\n            grpc.WithUnaryInterceptor(otelgrpc.UnaryClientInterceptor()),\n    ```", "```go\n        )\n    ```", "```go\n    }\n    ```", "```go\n    srv := grpc.NewServer(grpc.UnaryInterceptor(otelgrpc.UnaryServerInterceptor()))\n    ```", "```go\n    go mod tidy\n    ```", "```go\n    docker run -d --name jaeger \\\n    ```", "```go\n      -e COLLECTOR_OTLP_ENABLED=true \\\n    ```", "```go\n      -p 6831:6831/udp \\\n    ```", "```go\n      -p 6832:6832/udp \\\n    ```", "```go\n      -p 5778:5778 \\\n    ```", "```go\n      -p 16686:16686 \\\n    ```", "```go\n      -p 4317:4317 \\\n    ```", "```go\n      -p 4318:4318 \\\n    ```", "```go\n      -p 14250:14250 \\\n    ```", "```go\n      -p 14268:14268 \\\n    ```", "```go\n      -p 14269:14269 \\\n    ```", "```go\n      -p 9411:9411 \\\n    ```", "```go\n      jaegertracing/all-in-one:1.37\n    ```", "```go\n    grpcurl -plaintext -d '{\"movie_id\":\"1\"}' localhost:8083 MovieService/GetMovieDetails\n    ```", "```go\n    const tracerID = \"metadata-repository-memory\"\n    ```", "```go\n    _, span := otel.Tracer(tracerID).Start(ctx, \"Repository/Get\")\n    ```", "```go\n    defer span.End()\n    ```", "```go\n    _, span := otel.Tracer(tracerID).Start(ctx, \"Repository/Put\")\n    ```", "```go\n    defer span.End()\n    ```"]