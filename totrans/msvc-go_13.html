<html><head></head><body>
		<div id="_idContainer063">
			<h1 id="_idParaDest-180" class="chapter-number" lang="en-GB"><a id="_idTextAnchor181"/>13</h1>
			<h1 id="_idParaDest-181" lang="en-GB"><a id="_idTextAnchor182"/>Advanced Topics</h1>
			<p lang="en-GB">If you are reading this chapter – congratulations, you have reached the very final part of this book! We have discussed many topics related to microservice development, but some remain that are important to cover. The topics in this chapter span many areas, from observability and debugging to service ownership and security. You may find these topics useful at various points in time: some of them will be helpful once you have working services serving production traffic, while others will be useful while your services are still in <span class="No-Break" lang="">active development.</span></p>
			<p lang="en-GB">In this chapter, we will cover the <span class="No-Break" lang="">following topics:</span></p>
			<ul>
				<li lang="en-GB">Profiling <span class="No-Break" lang="">Go services</span></li>
				<li lang="en-GB">Creating <span class="No-Break" lang="">microservice dashboards</span></li>
				<li lang="en-GB"><span class="No-Break" lang="">Frameworks</span></li>
				<li lang="en-GB">Storing microservice <span class="No-Break" lang="">ownership data</span></li>
				<li lang="en-GB">Securing microservice communication <span class="No-Break" lang="">with JWT</span></li>
			</ul>
			<p lang="en-GB">Let’s proceed to the first section of this chapter, which covers <span class="No-Break" lang="">service profiling.</span></p>
			<h1 id="_idParaDest-182" lang="en-GB"><a id="_idTextAnchor183"/>Technical requirements</h1>
			<p lang="en-GB">To complete this chapter, you will need Go 1.11+ or above. Additionally, you will need the <span class="No-Break" lang="">following tools:</span></p>
			<ul>
				<li lang="en-GB"><span class="No-Break" lang=""><strong class="bold" lang="">Graphviz</strong></span><span class="No-Break" lang="">: </span><a href="https://graphviz.org"><span class="No-Break" lang="">https://graphviz.org</span></a></li>
				<li lang="en-GB"><span class="No-Break" lang=""><strong class="bold" lang="">Docker</strong></span><span class="No-Break" lang="">: </span><a href="https://www.docker.com"><span class="No-Break" lang="">https://www.docker.com</span></a></li>
			</ul>
			<p lang="en-GB">You can find the code examples for this chapter on <span class="No-Break" lang="">GitHub: </span><span class="No-Break" lang="">https://github.com/PacktPublishing/microservices-with-go/tree/main/Chapter13</span><span class="No-Break" lang="">.</span></p>
			<h1 id="_idParaDest-183" lang="en-GB"><a id="_idTextAnchor184"/>Profiling Go services</h1>
			<p lang="en-GB">In this section, we are going to review a technique called <strong class="bold" lang="">profiling</strong>, which involves collecting real-time performance data of a running process, such as a Go service. Profiling is a powerful technique that can help you analyze various types of service <span class="No-Break" lang="">performance data:</span></p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">CPU usage</strong>: Which operations used the most CPU power and what was the distribution of CPU usage <span class="No-Break" lang="">among them?</span></li>
				<li lang="en-GB"><strong class="bold" lang="">Heap allocation</strong>: Which operations used heap (dynamic memory allocated in Go applications) and what amount of memory <span class="No-Break" lang="">was used?</span></li>
				<li lang="en-GB"><strong class="bold" lang="">Call graph</strong>: In which order were service <span class="No-Break" lang="">functions executed?</span></li>
			</ul>
			<p lang="en-GB">Profiling may help you in <span class="No-Break" lang="">different situations:</span></p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Identifying CPU-intensive logic</strong>: At some point, you may notice that your service is consuming most of your CPU power. To understand this problem, you can collect the CPU profile – a graph showing the CPU usage of various service components, such as individual functions. Components that consume too much CPU power may indicate various issues, such as inefficient implementations or <span class="No-Break" lang="">code bugs.</span></li>
				<li lang="en-GB"><strong class="bold" lang="">Capturing the service memory footprint</strong>: Similar to high CPU consumption, your service may be using too much memory (for example, to allocate too much data to the heap), resulting in occasional service crashes due to out-of-memory panics. Performing memory profiling may help you analyze the memory usage of various parts of your service and find components that have unexpectedly high <span class="No-Break" lang="">memory usage.</span></li>
			</ul>
			<p lang="en-GB">Let’s illustrate how to profile Go services using the pprof tool, which is a part of the Go SDK. To visualize the results of the tool, you will need to install the Graphviz <span class="No-Break" lang="">library: </span><a href="https://graphviz.org/"><span class="No-Break" lang="">https://graphviz.org/</span></a><span class="No-Break" lang="">.</span></p>
			<p lang="en-GB">We will use the metadata service that we implemented in <a href="B18865_02.xhtml#_idTextAnchor027"><span class="No-Break" lang=""><em class="italic" lang="">Chapter 2</em></span></a> as an example. Open the <strong class="source-inline" lang="">metadata/cmd/main.go</strong> file and add the <strong class="source-inline" lang="">flag</strong> package to the <strong class="source-inline" lang="">imports</strong> block. Then, add the following code to the beginning of the main function, immediately after the <span class="No-Break" lang="">logger initialization:</span></p>
			<pre class="source-code" lang="en-GB">
simulateCPULoad := flag.Bool("simulatecpuload",
    false,"simulate CPU load for profiling")
    flag.Parse()
    if *simulateCPULoad {
        go heavyOperation()
    }
go func() {
    if err := http.ListenAndServe("localhost:6060", nil);
    err != nil {
        logger.Fatal("Failed to start profiler handler",
            zap.Error(err))
    }
}()</pre>
			<p lang="en-GB">In the code we just added, we introduced an additional flag called <strong class="source-inline" lang="">simulatecpuload</strong> that will let us simulate a CPU-intensive operation for our profiling. We also started an HTTP handler that we will use to access the profiler data from the <span class="No-Break" lang="">command line.</span></p>
			<p lang="en-GB">Now, let’s add another function to the same file that will run a continuous loop and execute some CPU-intensive operations. We will generate random 1,024-byte arrays and calculate their md5 hashes (you can read about the md5 operation in the comments of its Go package at https://pkg.go.dev/crypto/md5). Our selection of such logic is fully arbitrary: we could easily choose any other operation that would consume some visible part of the <span class="No-Break" lang="">CPU load.</span></p>
			<p lang="en-GB">Add the following code to the <strong class="source-inline" lang="">main.go</strong> file that we <span class="No-Break" lang="">just updated:</span></p>
			<pre class="source-code" lang="en-GB">
func heavyOperation() {
    for {
        token := make([]byte, 1024)
        rand.Read(token)
        md5.New().Write(token)
    }
}</pre>
			<p lang="en-GB">Now, we are ready to test our profiling logic. Run the service with the <strong class="source-inline" lang="">--</strong><span class="No-Break" lang=""><strong class="source-inline" lang="">simulatecpuload</strong></span><span class="No-Break" lang=""> argument:</span></p>
			<pre class="source-code" lang="en-GB">
go run *.go --simulatecpuload</pre>
			<p lang="en-GB">Now, execute the <span class="No-Break" lang="">following command:</span></p>
			<pre class="source-code" lang="en-GB">
go tool pprof http://localhost:6060/debug/pprof/profile?seconds=5</pre>
			<p lang="en-GB">The command should take 5 seconds to complete. If it executes successfully, the pprof tool will be running, as <span class="No-Break" lang="">shown here:</span></p>
			<pre class="source-code" lang="en-GB">
Type: cpu
Time: Sep 13, 2022 at 5:37pm (+05)
Duration: 5.14s, Total samples = 4.42s (85.92%)
Entering interactive mode (type "help" for commands,
    "o" for options)
(pprof)</pre>
			<p lang="en-GB">Type <strong class="source-inline" lang="">web</strong> in the command prompt of the tool and press <em class="italic" lang="">Enter</em>. If everything worked well, you will be redirected to a browser window containing a CPU <span class="No-Break" lang="">profile graph:</span></p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/Figure_13.1_B18865.jpg" alt="Figure 13.1 – Go CPU profile example&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – Go CPU profile example</p>
			<p lang="en-GB">Let’s walk through the data from the graph to understand how to interpret it. Each node on the graph includes the <span class="No-Break" lang="">following data:</span></p>
			<ul>
				<li lang="en-GB"><span class="No-Break" lang="">Package name</span></li>
				<li lang="en-GB"><span class="No-Break" lang="">Function name</span></li>
				<li lang="en-GB">Elapsed time and the total time of <span class="No-Break" lang="">the execution</span></li>
			</ul>
			<p lang="en-GB">For example, the <strong class="source-inline" lang="">heavyOperation</strong> function took just 0.01 seconds, but all the operations that were executed in it (including all function calls inside it) took 4.39 seconds, taking most of the <span class="No-Break" lang="">elapsed time.</span></p>
			<p lang="en-GB">If you walk through the graph, you will see the distribution of the elapsed time by sub-operations. In our case, <strong class="source-inline" lang="">heavyOperation</strong> executed two functions that got recorded by the CPU profiler: <strong class="source-inline" lang="">md5.Write</strong> and <strong class="source-inline" lang="">rand.Read</strong>. The <strong class="source-inline" lang="">md5.Write</strong> function took 2.78 seconds in total, while <strong class="source-inline" lang="">rand.Read</strong> took 1.59 seconds of the execution time. Level by level, you can analyze the calls and find the <span class="No-Break" lang="">CPU-intensive functions.</span></p>
			<p lang="en-GB">When working with the CPU profiler data, notice the functions that take the most processing time. Such functions are illustrated as larger rectangles to help you find them. If you notice that some functions have unexpectedly high processing time, spend some time analyzing their code to see whether there is any opportunity to <span class="No-Break" lang="">optimize them.</span></p>
			<p lang="en-GB">Now, let’s illustrate another example of profiler data. This time, we will be capturing a <strong class="bold" lang="">heap profile</strong> – a profile showing dynamic memory allocation by a Go process. Run the <span class="No-Break" lang="">following command:</span></p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">go tool pprof http://localhost:6060/debug/pprof/heap</strong></pre>
			<p lang="en-GB">Similar to the previous example, successfully executing this command should run the pprof tool, where we can execute a web command. The result will contain the <span class="No-Break" lang="">following graph:</span></p>
			<p class="IMG---Figure" lang="en-GB"> </p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/Figure_13.2_B18865.jpg" alt="Figure 13.2 – Go heap profile example&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – Go heap profile example</p>
			<p lang="en-GB">This diagram is similar to the CPU profile. The last line inside each node shows the ratio between the memory used by the function and the total heap memory allocated by <span class="No-Break" lang="">the process.</span></p>
			<p lang="en-GB">In our example, three high-level operations are consuming the <span class="No-Break" lang="">heap memory:</span></p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">api.serviceRegister</strong>: A function that registers a service via the <span class="No-Break" lang="">Consul API</span></li>
				<li lang="en-GB"><strong class="bold" lang="">zap.NewProduction</strong>: Logger initialization via the <span class="No-Break" lang=""><strong class="source-inline" lang="">zap</strong></span><span class="No-Break" lang=""> library</span></li>
				<li lang="en-GB"><strong class="bold" lang="">trace.init</strong>: Initializes the <span class="No-Break" lang="">tracing logic</span></li>
			</ul>
			<ol>
				<li lang="en-GB">Looking at the heap profiler data, it’s easy to find functions allocating an unexpectedly high amount of heap memory. Similar to CPU profiler graphs, heap profilers display the functions that have the highest heap allocation as larger rectangles, making it easier to visualize the most <span class="No-Break" lang="">memory-consuming functions.</span></li>
				<li lang="en-GB">I suggest that you practice with the pprof tool and try the other operations it provides. Being able to profile Go applications is a highly valuable skill in production debugging that should help you optimize your services and solve different performance-related issues. The following are some other useful tips for profiling <span class="No-Break" lang="">Go services:</span><ul><li lang="en-GB">You can profile Go tests without adding any extra logic to your code. Running the <strong class="source-inline" lang="">go test</strong> command with the <strong class="source-inline" lang="">-cpuprofile</strong> and <strong class="source-inline" lang="">-memprofile</strong> flags will capture the CPU and memory profiles of your <span class="No-Break" lang="">logic, respectively.</span></li><li lang="en-GB">The <strong class="source-inline" lang="">top</strong> command of the pprof tool is a convenient way of showing the top memory consumers. There is also the <strong class="source-inline" lang="">top10</strong> command, which shows the top 10 <span class="No-Break" lang="">memory consumers.</span></li><li lang="en-GB">Using the <strong class="source-inline" lang="">roroutine</strong> mode of the pprof tool, you can get a profile of all used goroutines, as well as their <span class="No-Break" lang="">stack traces.</span></li></ul></li>
			</ol>
			<p lang="en-GB">Now that we have covered the basics of Go profiling, let’s move on to the next topic of this chapter: <span class="No-Break" lang="">service dashboarding.</span></p>
			<h1 id="_idParaDest-184" lang="en-GB"><a id="_idTextAnchor185"/>Creating microservice dashboards</h1>
			<p lang="en-GB">In the previous two chapters, we reviewed various ways of working with service metrics. In <a href="B18865_11.xhtml#_idTextAnchor152"><span class="No-Break" lang=""><em class="italic" lang="">Chapter 11</em></span></a>, we demonstrated how to collect the service metrics, while in <a href="B18865_12.xhtml#_idTextAnchor171"><span class="No-Break" lang=""><em class="italic" lang="">Chapter 12</em></span></a>, we showed you how to aggregate and query them using the Prometheus tool. In this section, we will describe one more way of accessing the metrics data that can help you explore your metrics and plot them as charts. The technique that we will cover is called <strong class="bold" lang="">dashboarding</strong> and is useful for visualizing various <span class="No-Break" lang="">service metrics.</span></p>
			<p lang="en-GB">Let’s provide an example of a dashboard – a set of charts representing different metrics. The following figure shows the dashboard of a Go service containing some system-level metrics, such as the goroutine count, the number of Go threads, and allocated <span class="No-Break" lang="">memory size:</span></p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/Figure_13.3_B18865.jpg" alt="Figure 13.3 – Go process dashboard example from the Grafana tool&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 – Go process dashboard example from the Grafana tool</p>
			<p lang="en-GB">Dashboards help visualize various types of data, such as time series datasets, allowing us to analyze service performance. The following are some other use cases for <span class="No-Break" lang="">using dashboards:</span></p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Debugging</strong>: Being able to visualize various service performance metrics helps us identify service issues and notice any anomalies in <span class="No-Break" lang="">system activity</span></li>
				<li lang="en-GB"><strong class="bold" lang="">Data correlation</strong>: Having a side-by-side representation of multiple service performance charts helps us find related events, such as an increase in server errors or a sudden drop in <span class="No-Break" lang="">available memory</span></li>
			</ul>
			<p lang="en-GB">It’s a great practice to have a dashboard for each of your services, as well as some dashboards that span all services, to get some high-level system performance data, such as the number of active service instances, network throughput, and <span class="No-Break" lang="">much more.</span></p>
			<p lang="en-GB">Let’s demonstrate how to set up an example dashboard for the Prometheus data that we collected in <a href="B18865_12.xhtml#_idTextAnchor171"><span class="No-Break" lang=""><em class="italic" lang="">Chapter 12</em></span></a>. For this, we will use the open source tool called Grafana, which has built-in support for various types of time series data and provides a convenient user interface for setting up different dashboards. Follow these instructions to set up a <span class="No-Break" lang="">Grafana dashboard:</span></p>
			<ol>
				<li lang="en-GB" value="1">Execute the following command to run the Grafana <span class="No-Break" lang="">Docker image:</span><pre class="source-code" lang="en-GB">
docker run -d -p 3000:3000 grafana/grafana-oss</pre></li>
			</ol>
			<p lang="en-GB">This command should fetch and run the open source version of Grafana (Grafana also comes in an enterprise version, which we won’t cover in this chapter) and expose port <strong class="source-inline" lang="">3000</strong> so that we can access it <span class="No-Break" lang="">via HTTP.</span></p>
			<p class="callout-heading" lang="en-GB">Note</p>
			<p class="callout" lang="en-GB">Similar to Prometheus, Grafana is also written in Go and is another example of a popular open source Go project widely used across the software <span class="No-Break" lang="">development industry.</span></p>
			<ol>
				<li lang="en-GB" value="2">Once you’ve run the preceding command, open <a href="http://localhost:3000">http://localhost:3000</a> in your browser. This will lead you to the Grafana login page. By default, the Docker-based version of Grafana includes a user with <strong class="source-inline" lang="">admin</strong> as both its username and password, so you can use these credentials to <span class="No-Break" lang="">log in.</span></li>
				<li lang="en-GB">From the side menu, <span class="No-Break" lang="">select </span><span class="No-Break" lang=""><strong class="bold" lang="">Configuration</strong></span><span class="No-Break" lang="">:</span></li>
			</ol>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/Figure_13.4_B18865.jpg" alt="Figure 13.4 – Grafana data source configuration menu&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4 – Grafana data source configuration menu</p>
			<ol>
				<li lang="en-GB" value="4">On the <strong class="bold" lang="">Configuration</strong> page, click on the <strong class="bold" lang="">Data sources</strong> menu item, then click <strong class="bold" lang="">Add data source</strong> and choose <strong class="bold" lang="">Prometheus</strong> from the list of available data sources. Doing so will open a new page that displays Prometheus settings. In the <strong class="bold" lang="">HTTP</strong> section, set <strong class="bold" lang="">URL</strong> to <a href="http://host.docker.internal:9090">http://host.docker.internal:9090</a>, as shown in the <span class="No-Break" lang="">following screenshot:</span></li>
			</ol>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/Figure_13.5_B18865.jpg" alt="Figure 13.5 – Grafana configuration for a Prometheus data source&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5 – Grafana configuration for a Prometheus data source</p>
			<ol>
				<li lang="en-GB" value="5">Now, you can click the <strong class="bold" lang="">Save and test</strong> button at the bottom of the page, which should let you know whether the operation was successful. If you did everything well, Grafana should be ready to display your metrics <span class="No-Break" lang="">from Prometheus.</span></li>
				<li lang="en-GB">From the side menu, click on <span class="No-Break" lang=""><strong class="bold" lang="">New dashboard</strong></span><span class="No-Break" lang="">:</span></li>
			</ol>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/Figure_13.6_B18865.jpg" alt="Figure 13.6 – Grafana’s New dashboard menu item for dashboard creation&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.6 – Grafana’s New dashboard menu item for dashboard creation</p>
			<ol>
				<li lang="en-GB" value="7">This should open an empty <span class="No-Break" lang="">dashboard page.</span></li>
				<li lang="en-GB">Click on the <strong class="bold" lang="">Add a new panel</strong> button on this dashboard page; you will be redirected to the panel <span class="No-Break" lang="">creation page.</span></li>
			</ol>
			<p lang="en-GB">A panel is a core element of a Grafana dashboard and its purpose is to visualize the provided dataset. To illustrate how to use it, let’s select our Prometheus data source and some of the metrics that it already has. On the panel view, choose <strong class="bold" lang="">Prometheus</strong> as the data source and, in the <strong class="bold" lang="">Metric</strong> field, find the <strong class="source-inline" lang="">process_open_fds</strong> element and select it. Now, click on the <strong class="bold" lang="">Run queries</strong> button; you should see the <span class="No-Break" lang="">following view:</span></p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/Figure_13.7_B18865.jpg" alt="Figure 13.7 – Grafana panel view&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.7 – Grafana panel view</p>
			<p lang="en-GB">We just configured the dashboard panel to display the <strong class="source-inline" lang="">process_open_fds</strong> time series stored in Prometheus. Each data point on the chart shows the value of the time series at a different time, displayed below the chart. On the right-hand panel, you can set the panel title to <strong class="bold" lang="">Open fd count</strong>. Now, save the dashboard by clicking the <strong class="bold" lang="">Apply</strong> button provided in the top menu. You will be redirected to the <span class="No-Break" lang="">dashboard page.</span></p>
			<p lang="en-GB">In the top menu, you will find the <strong class="bold" lang="">Add panel</strong> button, which you can use to add a new panel to our dashboard. If you follow the same steps that we did for the previous panel and choose the <strong class="source-inline" lang="">go_gc_duration_seconds</strong> metric, you will add a new panel to the dashboard that will visualize the <strong class="source-inline" lang="">go_gc_duration_seconds</strong> time series <span class="No-Break" lang="">from Prometheus.</span></p>
			<p lang="en-GB">The resulting dashboard should look <span class="No-Break" lang="">like this:</span></p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/Figure_13.8_B18865.jpg" alt="Figure 13.8 – Example Grafana dashboard&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.8 – Example Grafana dashboard</p>
			<p lang="en-GB">We just created an example dashboard that has two panels that display some existing Prometheus metrics. You can use the same approach to create any dashboards for your services, as well as high-level dashboards showing the system-global metrics, such as the total number of API requests, network throughput, or the total number of all <span class="No-Break" lang="">service instances.</span></p>
			<p lang="en-GB">Let’s provide some examples of metrics that can be useful for setting up a dashboard for an individual service. This includes <em class="italic" lang="">The Four Golden Signals</em>, which we mentioned in <a href="B18865_12.xhtml#_idTextAnchor171"><span class="No-Break" lang=""><em class="italic" lang="">Chapter 12</em></span></a><span class="No-Break" lang="">:</span></p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Client error rate</strong>: The ratio between client errors (such as invalid or unauthenticated requests) and all requests to <span class="No-Break" lang="">the service</span></li>
				<li lang="en-GB"><strong class="bold" lang="">Server error rate</strong>: The ratio between server errors (such as database write errors) and all requests to <span class="No-Break" lang="">the service</span></li>
				<li lang="en-GB"><strong class="bold" lang="">API throughput</strong>: Number of API requests <span class="No-Break" lang="">per second/minute</span></li>
				<li lang="en-GB"><strong class="bold" lang="">API latency</strong>: API request processing latency, usually measured in percentiles, such as p90/p95/p99 (you can learn about percentiles by reading this blog <span class="No-Break" lang="">post: </span><span class="No-Break" lang="">https://www.elastic.co/blog/averages-can-dangerous-use-percentile</span><span class="No-Break" lang="">)</span></li>
				<li lang="en-GB"><strong class="bold" lang="">CPU utilization</strong>: Current usage of CPUs (100% means all CPUs are <span class="No-Break" lang="">fully loaded)</span></li>
				<li lang="en-GB"><strong class="bold" lang="">Memory utilization</strong>: Ratio between used and total memory across all <span class="No-Break" lang="">service instances</span></li>
				<li lang="en-GB"><strong class="bold" lang="">Network throughput</strong>: Total amount of network write/read traffic <span class="No-Break" lang="">per second/minute</span></li>
			</ul>
			<p lang="en-GB">Depending on the operations performed by your service (for example, database writes or reads, cache usage, Kafka consumption, or production), you may wish to include additional panels that will help you visualize your service performance. Make sure that you cover all the high-level functionality of the service so that you can visually notice any service malfunctions on <span class="No-Break" lang="">your dashboards.</span></p>
			<p lang="en-GB">The Grafana tool, which we used in our example, also supports lots of different visualization options, such as displaying tables, heatmaps, numerical values, and much more. We will not cover these features in this chapter, but you can get familiar with them by reading the official documentation: https://grafana.com/docs/. Using the full power of Grafana will help you set up excellent dashboards for your services, simplifying your debugging and <span class="No-Break" lang="">performance analysis.</span></p>
			<p lang="en-GB">Now, let’s move on to the next section, where we will describe <span class="No-Break" lang="">Go frameworks.</span></p>
			<h1 id="_idParaDest-185" lang="en-GB"><a id="_idTextAnchor186"/>Frameworks</h1>
			<p lang="en-GB">In <a href="B18865_02.xhtml#_idTextAnchor027"><span class="No-Break" lang=""><em class="italic" lang="">Chapter 2</em></span></a>, we covered the topic of the Go project structure, as well as some common patterns of organizing your Go code. The code organization principles that we described are generally based on conventions – written agreements or statements that define specific rules for naming and placing Go files. Some of the conventions that we followed were proposed by the authors of the Go language, while others are commonly used and proposed by authors of various <span class="No-Break" lang="">Go libraries.</span></p>
			<p lang="en-GB">While conventions play an important role in establishing the common principles of organizing Go code, there are other ways of enforcing specific code structures. One such way is using frameworks, which we are going to cover in <span class="No-Break" lang="">this section.</span></p>
			<p lang="en-GB">Generally speaking, <strong class="bold" lang="">frameworks</strong> are tools that establish a structure for various components of your code. Let’s take the following code snippet as <span class="No-Break" lang="">an example:</span></p>
			<pre class="source-code" lang="en-GB">
package main
import (
    "fmt"
    "net/http"
)
func main() {
    http.HandleFunc("/echo",
        func(w http.ResponseWriter, _ *http.Request) {
            fmt.Fprintf(w, "Hi!")
        })
    if err := http.ListenAndServe(":8080", nil);
    err != nil {
        panic(err)
    }
}</pre>
			<p lang="en-GB">Here, we are registering an HTTP handler function and letting it handle HTTP requests on the <strong class="source-inline" lang="">localhost:8080/echo</strong> endpoint. The code for our example is extremely simple, yet it does a lot of background work (you can check the source of the <strong class="source-inline" lang="">net/http</strong> package to see how complex the internal part of the HTTP handling logic is) to start an HTTP server, accept all incoming requests, and respond to them by executing the function provided by us. Most importantly, our code allows us to add additional HTTP handlers by following the same format of calling the <strong class="source-inline" lang="">http.HandleFunc</strong> function and passing handler functions to it. The <strong class="source-inline" lang="">net/http</strong> library that we used in our example established a structure for handling HTTP calls to various endpoints, acting as a framework for our <span class="No-Break" lang="">Go application.</span></p>
			<p lang="en-GB">The authors of the <strong class="source-inline" lang="">net/http</strong> package were able to add additional HTTP endpoint handlers (provided by the <strong class="source-inline" lang="">http.HandleFunc</strong> function) by following a pattern called <strong class="bold" lang="">inversion of control</strong> (<strong class="bold" lang="">IoC</strong>). IoC is a way of organizing code in which some component (in our case, the <strong class="source-inline" lang="">net/http</strong> package) takes control of the execution flow by calling the other components of it (in our case, the function provided as an argument to <strong class="source-inline" lang="">http.HandleFunc</strong>). In our example, the moment we call the <strong class="source-inline" lang="">http.ListenAndServe</strong> function, the <strong class="source-inline" lang="">net/http</strong> package takes control of executing the HTTP handler functions: each time the HTTP server receives an incoming request, our function is <span class="No-Break" lang="">called automatically.</span></p>
			<p lang="en-GB">IaC is a primary mechanism of most frameworks that allows them to establish a foundation for various parts of application code. In general, most frameworks work by taking control of an application, or a part of it, and handling some routing operations, such as resource management (opening and closing incoming connections, writing and reading files, and so on), serialization and deserialization, and <span class="No-Break" lang="">many more.</span></p>
			<p lang="en-GB">What are the primary use cases for using Go frameworks? We can list some of the most <span class="No-Break" lang="">common ones:</span></p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Writing web servers</strong>: Similar to our example of an HTTP server, there can be other types of web servers handling requests to different endpoints using different protocols, such as Apache Thrift <span class="No-Break" lang="">or gRPC.</span></li>
				<li lang="en-GB"><strong class="bold" lang="">Async event processing</strong>: There are libraries for various asynchronous communication tools, such as Apache Kafka, that help organize code in an IoC way by passing handler functions for various types of events (such as Kafka messages belonging to different topics), which get called automatically each time there is a new <span class="No-Break" lang="">unprocessed message.</span></li>
			</ul>
			<p lang="en-GB">It is important to note that frameworks have some <span class="No-Break" lang="">significant downsides:</span></p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Harder to debug and understand the execution flow</strong>: In addition to taking control of the execution flow, frameworks also perform lots of background work that is hidden from developers. Because of this, it is usually much harder to understand how your code is being executed, as well as to debug various issues, such as initialization errors (you may find more information on this in the following <span class="No-Break" lang="">article: </span><a href="https://www.baeldung.com/cs/framework-vs-library"><span class="No-Break" lang="">https://www.baeldung.com/cs/framework-vs-library</span></a><span class="No-Break" lang="">).</span></li>
				<li lang="en-GB"><strong class="bold" lang="">Steeper learning curve</strong>: Frameworks generally require a good understanding of the logic and abstractions they provide. This requires developers to spend more time reading the related documentation or learning some key lessons <span class="No-Break" lang="">in practice.</span></li>
				<li lang="en-GB"><strong class="bold" lang="">Harder to catch some trivial bugs via static checks</strong>: Frameworks often use dynamic code invocation libraries, such as <strong class="source-inline" lang="">reflect</strong> (https://pkg.go.dev/reflect). Such operations are performed when executing a program, making it hard to catch various types of issues, such as the incorrect implementation of interfaces or <span class="No-Break" lang="">invalid naming.</span></li>
			</ul>
			<p lang="en-GB">When deciding on using a specific framework, you should do some analysis and compare the advantages it provides to you with the downsides it brings, especially in the long term. Many developers underestimate the complexity that frameworks bring to them or the other developers in their organizations: most frameworks perform a fair amount of <em class="italic" lang="">magic</em> to provide a convenient code structure to application developers. In general, you should always start from a simpler option (in our case, not using a particular framework) and only decide to use a framework if its benefits outweigh <span class="No-Break" lang="">its downsides.</span></p>
			<p lang="en-GB">Now that we have discussed the topic of frameworks, let’s move on to the next section, where we will describe the different aspects of <span class="No-Break" lang="">microservice ownership.</span></p>
			<h1 id="_idParaDest-186" lang="en-GB"><a id="_idTextAnchor187"/>Storing microservice ownership data</h1>
			<p lang="en-GB">One of the key benefits of using microservice architectures is the ability to distribute their development: each service can be developed and maintained by a separate team, and teams can be distributed across the globe. While the distributed development model helps different teams build various parts of their systems independently, it brings some new challenges, such as <span class="No-Break" lang="">service ownership.</span></p>
			<p lang="en-GB">To illustrate the problem of service ownership, imagine that you are working in a company with thousands of microservices. One day, the security engineers of your company find out that there is a critical security vulnerability in a popular Go library that is used in most of the company’s services. How can you communicate with the right teams and find out who would be responsible for making the changes in <span class="No-Break" lang="">each service?</span></p>
			<p lang="en-GB">There are numerous companies with thousands of microservices. In such companies, it becomes impossible to remember which team and which developers are responsible for each of them. In such companies, it becomes crucial to find a solution to the service <span class="No-Break" lang="">ownership problem.</span></p>
			<p class="callout-heading" lang="en-GB">Note</p>
			<p class="callout" lang="en-GB">While we are discussing the ownership problem for microservices, the same principles apply to many other types of technological assets, such as Kafka topics and <span class="No-Break" lang="">database tables.</span></p>
			<p lang="en-GB">How can we define <span class="No-Break" lang="">service ownership?</span></p>
			<p lang="en-GB">There are many different ways of doing this, each of which is equally important for some specific <span class="No-Break" lang="">use cases:</span></p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Accountability</strong>: Which person/entity is accountable for the service and who can act as the primary point of contact or the main authority <span class="No-Break" lang="">for it?</span></li>
				<li lang="en-GB"><strong class="bold" lang="">Support</strong>: Who is going to provide support for the service, such as a service bug, feature request, or <span class="No-Break" lang="">user question?</span></li>
				<li lang="en-GB"><strong class="bold" lang="">On-call</strong>: Who is currently on-call for the service? Who can we contact in case of an <span class="No-Break" lang="">emergency issue?</span></li>
			</ul>
			<p lang="en-GB">As you can see, there are many ways of interpreting the word ownership, depending on the use case. Let’s look at some ways to define each role, starting with accountability: who should be accountable, or liable, for <span class="No-Break" lang="">a service?</span></p>
			<p lang="en-GB">In most organizations, liability is attributed to engineering managers: every engineering manager acts as an accountable individual for some unique domain. If you define a mapping between your services and the engineering managers that are responsible for them, you can solve the service accountability problem by allowing them to easily find the relevant point of contact, such as an engineering manager that is liable <span class="No-Break" lang="">for it.</span></p>
			<p lang="en-GB">An alternative way of defining service accountability is to associate services with teams. However, there can be multiple issues <span class="No-Break" lang="">with this:</span></p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Shared accountability does not always work</strong>: If you have multiple people that are responsible for a service, it becomes unclear who the final authority among <span class="No-Break" lang="">them is.</span></li>
				<li lang="en-GB"><strong class="bold" lang="">A team is a loosely defined concept in many organizations</strong>: Unless you have a single, well-defined registry of teams in your company, it’s better to avoid referencing team names in <span class="No-Break" lang="">your systems.</span></li>
			</ul>
			<p lang="en-GB">Now, let’s discuss the support aspect of ownership. Ideally, each service should have a mechanism for reporting any issues or bugs. Such a mechanism can take one of the <span class="No-Break" lang="">following forms:</span></p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Support channel</strong>: The identifier or URL of a messaging channel for leaving support requests, such as a link to the relevant Google group, Slack channel, or any other <span class="No-Break" lang="">similar tool.</span></li>
				<li lang="en-GB"><strong class="bold" lang="">Ticketing system URL</strong>: The URL to a system/page that allows you to create a support request ticket. Developers often use Atlassian Jira for <span class="No-Break" lang="">this purpose.</span></li>
			</ul>
			<p lang="en-GB">If you provide such metadata for all your services, you will significantly simplify user support: all service users, such as other developers, will always know how to request support for them or report any bugs or <span class="No-Break" lang="">other issues.</span></p>
			<p lang="en-GB">Let’s move on to the on-call ownership metadata. An easy solution to this is to link each service to its on-call rotation. If you use PagerDuty, you can store the relationships between service names and their corresponding PagerDuty <span class="No-Break" lang="">rotation identifiers.</span></p>
			<p lang="en-GB">An example of the ownership metadata that we just described is <span class="No-Break" lang="">as follows:</span></p>
			<pre class="source-code" lang="en-GB">
ownership:
    rating-service:
        accountable: example@somecompany.com
            support:
                slack: rating-service-support-group
                    oncall:
                        pagerduty_rotation:SOME_ROTATION_ID</pre>
			<p lang="en-GB">Our example is defined in YAML format, though it may be preferable to store this data in some system that would allow us to query or modify it via an API. This way, you can automatically submit new ownership changes (for example, when people leave the company and you want to reassign the ownership automatically). I would also suggest making the ownership data mandatory for all services. To enforce this, you can establish a service creation process that will request the ownership data before developers provision <span class="No-Break" lang="">new services.</span></p>
			<p lang="en-GB">Now that we’ve discussed service ownership, let’s move on to the next section, where we will describe the basics of Go <span class="No-Break" lang="">microservice security.</span></p>
			<h1 id="_idParaDest-187" lang="en-GB"><a id="_idTextAnchor188"/>Securing microservice communication with JWT</h1>
			<p lang="en-GB">In this section, we are going to review some basic concepts of microservice security, such as authentication and authorization. You will learn how to implement such logic in Go using a popular <strong class="bold" lang="">JSON Web Token</strong> (<span class="No-Break" lang=""><strong class="bold" lang="">JWT</strong></span><span class="No-Break" lang="">) protocol.</span></p>
			<p lang="en-GB">Let’s start with one of the primary aspects of security: <strong class="bold" lang="">authentication</strong>. Authentication is the process of verifying someone’s identity, such as via user credentials. When you log into some system, such as Gmail, you generally go through the authentication process by providing your login details (username and password). The system that performs authentication performs verification by comparing the provided data with the existing records it stores. Verification can take one or multiple steps: some types of authentication, such as two-factor authentication, require some additional actions, such as verifying access to a phone number <span class="No-Break" lang="">via SMS.</span></p>
			<p lang="en-GB">A successful authentication often results in granting the caller access to some resources, such as user data (for example, user emails in Gmail). Additionally, the server performing this authentication may provide a security token to the caller that can be used on subsequent calls to skip the <span class="No-Break" lang="">verification process.</span></p>
			<p lang="en-GB">Another form of access control, known as <strong class="bold" lang="">authorization</strong>, involves specifying access rights to various resources. Authorization is often performed to check whether a user has permission to perform a certain action, such as viewing a specific admin page. Authorization is often performed by using a security token that was obtained during authentication, as illustrated in the <span class="No-Break" lang="">following diagram:</span></p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/Figure_13.9_B18865.jpg" alt="Figure 13.9 – Authorization request providing a token&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.9 – Authorization request providing a token</p>
			<p lang="en-GB">There are many different ways to implement authentication and authorization in microservices. Among the most popular protocols is JWT, a proposed internet standard for creating security tokens that can contain any number of facts about the caller’s identity, such as them being an administrator. Let’s review the basics of the protocol to help you understand how to use it in <span class="No-Break" lang="">your services.</span></p>
			<h2 id="_idParaDest-188" lang="en-GB"><a id="_idTextAnchor189"/>JWT basics</h2>
			<p lang="en-GB">JWTs are<a id="_idIndexMarker743"/> generated by components that perform authentication or authorization. Each token consists of three parts: a header, a payload, and a signature. The payload<a id="_idIndexMarker744"/> is the main part of the token and it contains a set <a id="_idIndexMarker745"/>of <strong class="bold" lang="">claims</strong> – statements about the caller’s identity, such as a user identifier or a role <a id="_idIndexMarker746"/>in the system. The following code shows an example of a <span class="No-Break" lang="">token payload:</span></p>
			<pre class="source-code" lang="en-GB">
{
    "name": "Alexander",
    "role": "admin",
    "iat": 1663880774
}</pre>
			<p lang="en-GB">Our example payload contains three<a id="_idIndexMarker747"/> claims: the user’s name, role (<strong class="source-inline" lang="">admin</strong> in our example), and token issuance time (<strong class="source-inline" lang="">iat</strong> is a standard field name that is a part of the JWT protocol). Such claims could be used in various flows – for example, when checking whether a user has the <strong class="source-inline" lang="">admin</strong> role to access a <span class="No-Break" lang="">system dashboard.</span></p>
			<p lang="en-GB">As a protection mechanism against modifications, each token contains<a id="_idIndexMarker748"/> a <strong class="bold" lang="">signature</strong> – a cryptographic function of its payload - a header, and a special value, called a <strong class="bold" lang="">secret</strong>, that is known<a id="_idIndexMarker749"/> only to the authentication server. The following <a id="_idIndexMarker750"/>pseudocode provides an example of token <span class="No-Break" lang="">signature calculation:</span></p>
			<pre class="source-code" lang="en-GB">
HMACSHA256(
    base64UrlEncode(header) + "." +
    base64UrlEncode(payload),
    secret,
)</pre>
			<p lang="en-GB">The algorithm that is used for creating a token signature is <a id="_idIndexMarker751"/>defined in a <strong class="bold" lang="">token header</strong>. The following JSON record provides an example of <span class="No-Break" lang="">a header:</span></p>
			<pre class="source-code" lang="en-GB">
{
    "alg": "HS256",
    "typ": "JWT"
}</pre>
			<p lang="en-GB">In our example, the token is using <strong class="source-inline" lang="">HMAC-SHA256</strong>, a cryptographic algorithm that is commonly used for signing JWTs. Our selection of <strong class="source-inline" lang="">HMAC-SHA256</strong> is primarily due to its popularity; if you wish to learn about other signing algorithms, you can find a link to an overview of them in the <em class="italic" lang="">Further reading</em> section of <span class="No-Break" lang="">the chapter.</span></p>
			<p lang="en-GB">The resulting JWT is a concatenation of the token’s header, payload, and signature, encoded with the <em class="italic" lang="">Base64uri</em> protocol. For example, the following value is a JWT that’s been created by combining the header and the payload from our code snippets, signed with a secret string <span class="No-Break" lang="">called </span><span class="No-Break" lang=""><strong class="source-inline" lang="">our-secret</strong></span><span class="No-Break" lang="">:</span></p>
			<pre class="source-code" lang="en-GB">
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiQWxleGFuZGVyIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNjYzODgwNzc0fQ.FqogLyrV28wR5po6SMouJ7qs2Y3m6gmpaPg6MUthWpQ</pre>
			<p lang="en-GB">To practice JWT creation, I suggest using the JWT tool available at <a href="https://jwt.io">https://jwt.io</a> to try encoding<a id="_idIndexMarker752"/> arbitrary JWTs and see the resulting <span class="No-Break" lang="">token values.</span></p>
			<p lang="en-GB">Now that we have discussed the high-level details of JWT, let’s move on to the practical part of this section – implementing basic authentication and authorization in Go microservices <span class="No-Break" lang="">using JWTs.</span></p>
			<h2 id="_idParaDest-189" lang="en-GB"><a id="_idTextAnchor190"/>Implementing authentication and authorization with JWTs</h2>
			<p lang="en-GB">In this section, we will provide some examples of implementing basic access control via authentication and authorization <span class="No-Break" lang="">using Go.</span></p>
			<p lang="en-GB">Let’s start with<a id="_idIndexMarker753"/> the authentication <a id="_idIndexMarker754"/>process. A simple credential-based authentication flow can be summarized <span class="No-Break" lang="">as follows:</span></p>
			<ul>
				<li lang="en-GB">The client initiating authentication would call a specified endpoint (for example, HTTPS POST <strong class="source-inline" lang="">/auth</strong>) while providing the user credentials, such as username <span class="No-Break" lang="">and password.</span></li>
				<li lang="en-GB">The server handling authentication would verify the credentials and perform one of <span class="No-Break" lang="">two actions:</span><ul><li lang="en-GB">Return an error if the credentials are invalid (for example, an HTTP error with a <span class="No-Break" lang=""><strong class="source-inline" lang="">401</strong></span><span class="No-Break" lang=""> code).</span></li><li lang="en-GB">Return a successful response with a <strong class="source-inline" lang="">200</strong> code, containing a JWT, that is signed with the <span class="No-Break" lang="">server’s secret.</span></li></ul></li>
				<li lang="en-GB">If <a id="_idIndexMarker755"/>authentication<a id="_idIndexMarker756"/> is successful, the client can store the received token so that it can be used in the <span class="No-Break" lang="">following requests.</span></li>
			</ul>
			<p lang="en-GB">Let’s illustrate how to implement the server logic for the authentication flow that we just described. To generate JWTs in our Go code, we will use the <span class="No-Break" lang=""><strong class="source-inline" lang="">https://github.com/golang-jwt/jwt</strong></span><span class="No-Break" lang=""> library.</span></p>
			<p lang="en-GB">The following code provides an example of handling an HTTP authentication request. It performs credential validation and returns a successful response with a signed JWT if the <span class="No-Break" lang="">validation passes:</span></p>
			<pre class="source-code" lang="en-GB">
const secret = "our-secret"
func Authenticate(w http.ResponseWriter, req *http.Request) {
    username := req.FormValue("username")
    password := req.FormValue("password")
    if !validCredentials(username, password) {
        http.Error(w, "invalid credentials", http.StatusUnauthorized)
        return
    }
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
        "username": username,
        "iat": time.Now().Unix(),
    })
    tokenString, err := token.SignedString(secret)
    if err != nil {
        http.Error(w, "failed to create a token", http.StatusInternalServerError)
        return
    }
    fmt.Fprintf(w, tokenString)
}
func validCredentials(username, password string) bool {
    // Implement your credential verification here.
    return false
}</pre>
			<p lang="en-GB">In the preceding <a id="_idIndexMarker757"/>code, we created a <a id="_idIndexMarker758"/>token using the <strong class="source-inline" lang="">jwt.NewWithClaims</strong> function. The token includes <span class="No-Break" lang="">two fields:</span></p>
			<ul>
				<li lang="en-GB"><strong class="source-inline" lang="">username</strong>: Name of the <span class="No-Break" lang="">authenticated user</span></li>
				<li lang="en-GB"><strong class="source-inline" lang="">iat</strong>: Time of <span class="No-Break" lang="">token creation</span></li>
			</ul>
			<p lang="en-GB">The server code that we just created is using the secret value to sign the token. Any attempts to modify the token would be impossible without knowing the secret: the token signature allows us to check whether the token <span class="No-Break" lang="">is correct.</span></p>
			<p lang="en-GB">Now, let’s illustrate how the client can perform requests using the token that it receives after <span class="No-Break" lang="">successfully authenticating:</span></p>
			<pre class="source-code" lang="en-GB">
func authorizationExample(
    token string, operationURL string) error {
        req, err := http.NewRequest(
            http.MethodPost, operationURL, nil)
            if err != nil {
                return err
            }
        req.Header.Set("Authorization", "Bearer "+token)
        resp, err := http.DefaultClient.Do(req)
        // Handle response.
    }</pre>
			<p lang="en-GB">In our <a id="_idIndexMarker759"/>example of an authorized operation, we <a id="_idIndexMarker760"/>added an <strong class="source-inline" lang="">Authorization</strong> header to the request while using the token value with the <strong class="source-inline" lang="">Bearer</strong> prefix. The <strong class="source-inline" lang="">Bearer</strong> prefix defines a <strong class="bold" lang="">bearer token</strong> – a <a id="_idIndexMarker761"/>token that intends to give access to <span class="No-Break" lang="">its bearer.</span></p>
			<p lang="en-GB">Let’s also provide the logic of a server handler that would handle such an authorized request and verify whether the provided token <span class="No-Break" lang="">is correct:</span></p>
			<pre class="source-code" lang="en-GB">
func AuthorizedOperationExample(w http.ResponseWriter,
    req *http.Request) {
        authHeaderValue := req.Header.Get("Authorization")
        const bearerPrefix = "Bearer "
        if !strings.HasPrefix(authHeaderValue,
            bearerPrefix) {
                http.Error(w,
                    "request does not contain an Authorization Bearer token", http.StatusUnauthorized)
                return
            }
        tokenString := strings.TrimPrefix(authHeaderValue,
            bearerPrefix)
        // Validate token.
        token, err := jwt.Parse(tokenString,
            func(token *jwt.Token) (interface{}, error) {
                if _, ok := token.Method.(
                    *jwt.SigningMethodHMAC); !ok {
                        return nil,
                        fmt.Errorf(
                            "unexpected signing method:
                                %v", token.Header["alg"])
            }
            return secret, nil
        })
        if err != nil {
            http.Error(w, "invalid token",
                http.StatusUnauthorized)
        }
        claims, ok := token.Claims.(jwt.MapClaims)
        if !ok || !token.Valid {
            http.Error(w, "invalid token",
                http.StatusUnauthorized)
            return
        }
        username := claims["username"]
        fmt.Fprintf(w, "Hello, "+username.(string))
    }</pre>
			<p lang="en-GB">Let’s describe <a id="_idIndexMarker762"/>some highlights of the <a id="_idIndexMarker763"/><span class="No-Break" lang="">provided example:</span></p>
			<ul>
				<li lang="en-GB">We use the <strong class="source-inline" lang="">jwt.Parse</strong> function to parse the token and validate it. We return an error if the signature algorithm does not match <strong class="source-inline" lang="">HMAC-SHA256</strong>, which we <span class="No-Break" lang="">used previously.</span></li>
				<li lang="en-GB">The parsed token contains the <strong class="source-inline" lang="">Claims</strong> field, which contains the claims from the <span class="No-Break" lang="">token payload</span></li>
				<li lang="en-GB">We use the <strong class="source-inline" lang="">username</strong> claim from the token payload in our function. Once we successfully parse the token and verify that it is valid, we can assume that the information in its payload has been securely passed to us and can <span class="No-Break" lang="">trust it.</span></li>
			</ul>
			<p lang="en-GB">Now that we have provided examples of Go authentication and authorization using JWTs, let’s list some best practices for using<a id="_idIndexMarker764"/> JWTs to secure <span class="No-Break" lang="">microservice communication:</span></p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">Set a token expiration time</strong>: When issuing JWTs, it is useful to set the token expiration time (the <strong class="source-inline" lang="">exp</strong> JWT claim field) to avoid situations where users use old authorization records. By having an expiration time set in each token payload, you can verify it against authorization requests. For example, when a user authenticates as a system administrator, you can set a short token expiration time (for example, a few hours) to avoid situations where a former administrator can still perform critical actions in <span class="No-Break" lang="">the system.</span></li>
				<li lang="en-GB"><strong class="bold" lang="">Include the token issuance time</strong>: Additional metadata, such as the token issuance time (the <strong class="source-inline" lang="">ist</strong> JWT claim field), can be useful in many practical situations. For example, if you identify a security breach that happened at a certain point in time, you can invalidate all access tokens that were issued before that moment by using the token issuance <span class="No-Break" lang="">time metadata.</span></li>
				<li lang="en-GB"><strong class="bold" lang="">Use JWTs with HTTPS instead of HTTP</strong>: The HTTPS protocol encrypts request metadata, such as authorization request headers, preventing various types of security attacks. An example of such a security attack is a <em class="italic" lang="">man-in-the-middle</em> attack, which is when some third party (such as a hacker trying to obtain a user’s access token) captures network traffic to extract JWTs from <span class="No-Break" lang="">request headers.</span></li>
				<li lang="en-GB"><strong class="bold" lang="">Prefer standard JWT claim fields to custom ones</strong>: When including metadata in the JWT <a id="_idIndexMarker765"/>payload, make sure that there is no standard field for the same purpose. You can find a list of standard JWT claim fields<a id="_idIndexMarker766"/> <span class="No-Break" lang="">at </span><span class="No-Break" lang="">https://en.wikipedia.org/wiki/JSON_Web_Token#Standard_fields</span><span class="No-Break" lang="">.</span></li>
			</ul>
			<p lang="en-GB">The <a href="https://jwt.io/">https://jwt.io/</a> website contains some additional tips on using JWTs, as well as an online tool for encoding and decoding JWTs, that you can use to debug your <span class="No-Break" lang="">service communication.</span></p>
			<h1 id="_idParaDest-190" lang="en-GB"><a id="_idTextAnchor191"/>Summary</h1>
			<p lang="en-GB">With that, we have finished the last chapter of this book by reviewing lots of microservice development topics that were not included in the previous chapters. You learned how to profile Go services, create microservice dashboards so that you can monitor their performance, define and store microservice ownership data, and secure microservice communication with JWTs. I hope that you have found lots of interesting tips in this chapter that will help you build scalable, highly performant, and <span class="No-Break" lang="">secure microservices.</span></p>
			<p lang="en-GB">The Go language keeps evolving, as well as the tooling for it. Each day, developers release new libraries and tools for it that can solve various microservice development problems that we described in this book. While this book provided you with lots of tips on Go microservice development, you should keep improving your skills and make your services simpler and easier <span class="No-Break" lang="">to maintain.</span></p>
			<p lang="en-GB">I also want to thank you for reading this book. I hope you enjoyed reading it and gained lots of useful experience that will help you in mastering the art of Go microservice development. Let your Go microservices be highly performant, secure, and easy <span class="No-Break" lang="">to maintain!</span></p>
			<h1 id="_idParaDest-191" lang="en-GB"><a id="_idTextAnchor192"/>Further reading</h1>
			<p lang="en-GB">To learn more about the topics that were covered in this chapter, take a look at the <span class="No-Break" lang="">following resources:</span></p>
			<ul>
				<li lang="en-GB"><em class="italic" lang="">Profiling Go </em><span class="No-Break" lang=""><em class="italic" lang="">Programs</em></span><span class="No-Break" lang="">: </span><a href="https://go.dev/blog/pprof"><span class="No-Break" lang="">https://go.dev/blog/pprof</span></a></li>
				<li lang="en-GB">Grafana <span class="No-Break" lang="">documentation: </span><a href="https://grafana.com/docs/"><span class="No-Break" lang="">https://grafana.com/docs/</span></a></li>
				<li lang="en-GB"><em class="italic" lang="">Grafana support for </em><span class="No-Break" lang=""><em class="italic" lang="">Prometheus</em></span><span class="No-Break" lang="">: </span><a href="https://prometheus.io/docs/visualization/grafana/"><span class="No-Break" lang="">https://prometheus.io/docs/visualization/grafana/</span></a></li>
				<li lang="en-GB">Top Go <span class="No-Break" lang="">frameworks: </span><a href="https://github.com/mingrammer/go-web-framework-stars"><span class="No-Break" lang="">https://github.com/mingrammer/go-web-framework-stars</span></a></li>
				<li lang="en-GB">JSON web <span class="No-Break" lang="">token: </span><a href="https://jwt.io/"><span class="No-Break" lang="">https://jwt.io/</span></a></li>
				<li lang="en-GB"><em class="italic" lang="">JSON Web Token (JWT) Signing Algorithms </em><span class="No-Break" lang=""><em class="italic" lang="">Overview</em></span><span class="No-Break" lang="">: </span><span class="No-Break" lang="">https://auth0.com/blog/json-web-token-signing-algorithms-overview/</span></li>
			</ul>
			<p lang="en-GB">We suggest that you use these resources to stay up to date with the latest news related to Go <span class="No-Break" lang="">microservice development:</span></p>
			<ul>
				<li lang="en-GB"><strong class="bold" lang="">The Go </strong><span class="No-Break" lang=""><strong class="bold" lang="">blog</strong></span><span class="No-Break" lang="">: </span><a href="https://go.dev/blog/"><span class="No-Break" lang="">https://go.dev/blog/</span></a></li>
				<li lang="en-GB"><strong class="bold" lang="">Microservice </strong><span class="No-Break" lang=""><strong class="bold" lang="">architecture</strong></span><span class="No-Break" lang="">: </span><span class="No-Break" lang="">https://microservices.io</span></li>
				<li lang="en-GB"><strong class="bold" lang="">A curated list of awesome Go </strong><span class="No-Break" lang=""><strong class="bold" lang="">software</strong></span><span class="No-Break" lang="">: </span><a href="https://github.com/avelino/awesome-go"><span class="No-Break" lang="">https://github.com/avelino/awesome-go</span></a></li>
			</ul>
		</div>
	</body></html>