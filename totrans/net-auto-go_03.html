<html><head></head><body>
<div id="_idContainer044">
<h1 class="chapter-number" id="_idParaDest-68"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-69"><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.2.1">Getting Started with Go</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we dive into the Go basics and the characteristics that make it comparable to a dynamically typed language, but with the efficiency and safety of a statically typed, </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">compiled language.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">We also explore different Go packages to manipulate data in different formats and how to scale programs with Go’s concurrency model. </span><span class="koboSpan" id="kobo.5.2">Being able to manipulate data effectively and take advantage of all the resources of systems running multi-core processors are key elements to keep in mind when </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">automating networks.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">During this chapter, we cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">key topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Go </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">variable types</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Go’s arithmetic, comparison, and </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">logical operators</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.13.1">Control flow</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Functions </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">in Go</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Interfaces </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">in Go</span></span></li>
<li><span class="koboSpan" id="kobo.18.1">Input and </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">output operations</span></span></li>
<li><span class="koboSpan" id="kobo.20.1">Decoding and encoding </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">with Go</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.22.1">Concurrency</span></span></li>
</ul>
<h1 id="_idParaDest-70"><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.23.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.24.1">We assume basic familiarity with the command line, Git, and GitHub. </span><span class="koboSpan" id="kobo.24.2">You can find the code examples for this chapter in the book’s GitHub repository at </span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go"><span class="koboSpan" id="kobo.25.1">https://github.com/PacktPublishing/Network-Automation-with-Go</span></a><span class="koboSpan" id="kobo.26.1">, under the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.27.1">ch03</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.28.1"> folder.</span></span></p>
<p><span class="koboSpan" id="kobo.29.1">To run the examples, perform the </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.31.1">Install Go 1.17 or later for your operating system. </span><span class="koboSpan" id="kobo.31.2">You can follow the instructions in </span><a href="B16971_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.32.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.33.1">, </span><em class="italic"><span class="koboSpan" id="kobo.34.1">Introduction</span></em><span class="koboSpan" id="kobo.35.1">, in the </span><em class="italic"><span class="koboSpan" id="kobo.36.1">Installing Go</span></em><span class="koboSpan" id="kobo.37.1"> section, or go </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">to </span></span><a href="https://go.dev/doc/install"><span class="No-Break"><span class="koboSpan" id="kobo.39.1">https://go.dev/doc/install</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.40.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.41.1">Clone the book’s GitHub repository with </span><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">git </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.43.1">clone </span></strong></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go.git"><span class="No-Break"><span class="koboSpan" id="kobo.44.1">https://github.com/PacktPublishing/Network-Automation-with-Go.git</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.45.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.46.1">Change the directory to an </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">example folder:</span></span><pre class="console"><span class="koboSpan" id="kobo.48.1">cd Network-Automation-with-Go/ch03/json.</span></pre></li>
<li><span class="koboSpan" id="kobo.49.1">Execute </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">go </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">run main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">.</span></span></li>
</ol>
<h1 id="_idParaDest-71"><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.53.1">Go’s type system</span></h1>
<p><span class="koboSpan" id="kobo.54.1">Go is</span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.55.1"> a statically</span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.56.1"> typed language, which means the compiler must know the types of all variables to build a program. </span><span class="koboSpan" id="kobo.56.2">The compiler looks for a special variable declaration signature and allocates enough memory to store </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">its value:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.58.1">func</span></span><span class="koboSpan" id="kobo.59.1"> main() {
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.60.1">var</span></span><span class="koboSpan" id="kobo.61.1"> n </span><span class="Code_Purple"><span class="koboSpan" id="kobo.62.1">int</span></span><span class="koboSpan" id="kobo.63.1">
    n </span><span class="Code_Red"><span class="koboSpan" id="kobo.64.1">=</span></span><span class="koboSpan" id="kobo.65.1"> 42
}</span></pre>
<p><span class="koboSpan" id="kobo.66.1">By default, Go initializes the memory with the zero value corresponding to its type. </span><span class="koboSpan" id="kobo.66.2">In the preceding example, we declare </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">n</span></strong><span class="koboSpan" id="kobo.68.1">, which has an initial value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">0</span></strong><span class="koboSpan" id="kobo.70.1">. </span><span class="koboSpan" id="kobo.70.2">We later assign a new value </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">42</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<span class="koboSpan" id="kobo.74.1"><img alt="Table 3.1 – Zero values" src="image/Figure_3.1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.75.1">Table 3.1 – Zero values</span></p>
<p><span class="koboSpan" id="kobo.76.1">As its name suggests, a variable can change its value, but only as long as its type remains the same. </span><span class="koboSpan" id="kobo.76.2">If you try to assign a value with a different type or redeclare a variable, the compiler complains with an appropriate </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">error message.</span></span></p>
<p><span class="koboSpan" id="kobo.78.1">If we </span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.79.1">append a line with </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">n = "Hello"</span></strong><span class="koboSpan" id="kobo.81.1"> to the last code example, the program wouldn’t compile, and it would return the following error message: </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">cannot use "Hello" (type untyped string) as type int </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">in assignment</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.85.1">You can use type inference as a shortcut for variable declarations. </span><span class="koboSpan" id="kobo.85.2">In that case, you omit an explicit type argument in your declaration. </span><span class="koboSpan" id="kobo.85.3">Just keep in mind that Go has limited support for type inference inside of </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">a function.</span></span></p>
<p><span class="koboSpan" id="kobo.87.1">Instead of explicitly defining a type for each variable, you can use a special short assignment symbol, </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">:=</span></strong><span class="koboSpan" id="kobo.89.1">, and let the compiler guess the variable type based on its value, as in the next example, where the compiler assumes the variable </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">n</span></strong><span class="koboSpan" id="kobo.91.1"> is of </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">type </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">int</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.95.1">func</span></span><span class="koboSpan" id="kobo.96.1"> main() {
    n :</span><span class="Code_Red"><span class="koboSpan" id="kobo.97.1">=</span></span><span class="koboSpan" id="kobo.98.1"> 42
}</span></pre>
<p><span class="koboSpan" id="kobo.99.1">Just like with variables, the compiler can also infer a constant type. </span><span class="koboSpan" id="kobo.99.2">The value of constants cannot change throughout the program and we generally use them to represent real-world values such as the number </span><em class="italic"><span class="koboSpan" id="kobo.100.1">π</span></em><span class="koboSpan" id="kobo.101.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.102.1">Pi</span></strong><span class="koboSpan" id="kobo.103.1">), static names of objects or places, and </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">so on:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.105.1">const</span></span><span class="koboSpan" id="kobo.106.1"> Book </span><span class="Code_Red"><span class="koboSpan" id="kobo.107.1">= "Network Automation with Go"</span></span></pre>
<p><span class="koboSpan" id="kobo.108.1">Now, let’s have a closer look at the different types available in Go and their common </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">use cases.</span></span></p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.110.1">Basic types</span></h2>
<p><span class="koboSpan" id="kobo.111.1">According </span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.112.1">to Go’s language specification, there are four groups of basic </span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.113.1">or primitive types</span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.114.1"> predeclared globally and available to all Go programs </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">by default:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.116.1">Numeric</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.117.1">Strings</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.118.1">Boolean</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.119.1">Error</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.120.1">Numeric</span></h3>
<p><span class="koboSpan" id="kobo.121.1">Go defines</span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.122.1"> several numeric types to store integers and real numbers of </span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.123.1">different sizes. </span><span class="koboSpan" id="kobo.123.2">Type names normally contain information about their sign and the size of the value (in bits). </span><span class="koboSpan" id="kobo.123.3">The only notable exceptions are </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">int</span></strong><span class="koboSpan" id="kobo.125.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">uint</span></strong><span class="koboSpan" id="kobo.127.1"> types, whose values depend on the machine and normally default to 32 bits for 32-bit CPUs, or 64 bits for 64-bit </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">CPU architectures:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<span class="koboSpan" id="kobo.129.1"><img alt="Table 3.2 – Numeric type variables" src="image/Figure_3.2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.130.1">Table 3.2 – Numeric type variables</span></p>
<p><span class="koboSpan" id="kobo.131.1">Here are some examples of how to instantiate variables of numeric types. </span><span class="koboSpan" id="kobo.131.2">These are all valid options, and you can use whichever is most appropriate for the range of values you need to store or produce. </span><span class="koboSpan" id="kobo.131.3">You can test this code from </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">ch03/type-definition/main.go</span></strong><span class="koboSpan" id="kobo.133.1"> (in the </span><em class="italic"><span class="koboSpan" id="kobo.134.1">Further reading</span></em><span class="koboSpan" id="kobo.135.1"> section). </span><span class="koboSpan" id="kobo.135.2">Notice we use type inference for </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">a</span></strong><span class="koboSpan" id="kobo.137.1">, so its type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">int</span></strong><span class="koboSpan" id="kobo.139.1"> and its size is 8 bytes on a 64-bit machine. </span><span class="koboSpan" id="kobo.139.2">The second variable (</span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">b</span></strong><span class="koboSpan" id="kobo.141.1">) is an unsigned 32-bit integer (4 bytes). </span><span class="koboSpan" id="kobo.141.2">The last variable (</span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">c</span></strong><span class="koboSpan" id="kobo.143.1">) is a floating-point number (</span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">4 bytes):</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.145.1">func</span></span><span class="koboSpan" id="kobo.146.1"> main() {
    a :</span><span class="Code_Red"><span class="koboSpan" id="kobo.147.1">= -</span></span><span class="koboSpan" id="kobo.148.1">1
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.149.1">var</span></span><span class="koboSpan" id="kobo.150.1"> b </span><span class="Code_Purple"><span class="koboSpan" id="kobo.151.1">uint32</span></span><span class="koboSpan" id="kobo.152.1">
    b </span><span class="Code_Red"><span class="koboSpan" id="kobo.153.1">=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.154.1">4294967295</span></span><span class="koboSpan" id="kobo.155.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.156.1">var</span></span><span class="koboSpan" id="kobo.157.1"> c </span><span class="Code_Purple"><span class="koboSpan" id="kobo.158.1">float32</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.159.1">=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.160.1">42.1</span></span><span class="koboSpan" id="kobo.161.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.162.1">You can also </span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.163.1">convert a </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">v</span></strong><span class="koboSpan" id="kobo.165.1"> value to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">T</span></strong><span class="koboSpan" id="kobo.167.1"> type with the expression </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">T(v)</span></strong><span class="koboSpan" id="kobo.169.1">, as in the</span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.170.1"> next example. </span><span class="koboSpan" id="kobo.170.2">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">b</span></strong><span class="koboSpan" id="kobo.172.1"> results from converting </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">a</span></strong><span class="koboSpan" id="kobo.174.1">, an integer, to an unsigned 32-bit integer, and finally, </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">c</span></strong><span class="koboSpan" id="kobo.176.1"> is a floating-point number from </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">converting </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">b</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.180.1">func</span></span><span class="koboSpan" id="kobo.181.1"> main() {
    a :</span><span class="Code_Red"><span class="koboSpan" id="kobo.182.1">=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.183.1">4294967295</span></span><span class="koboSpan" id="kobo.184.1">
    b :</span><span class="Code_Red"><span class="koboSpan" id="kobo.185.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.186.1">uint32</span></span><span class="koboSpan" id="kobo.187.1">(a)
    c :</span><span class="Code_Red"><span class="koboSpan" id="kobo.188.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.189.1">float32</span></span><span class="koboSpan" id="kobo.190.1">(b)
}</span></pre>
<p><span class="koboSpan" id="kobo.191.1">Once you have defined a type for a variable, any new operation has to match this type on both sides of the assignment operator (</span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">=</span></strong><span class="koboSpan" id="kobo.193.1">). </span><span class="koboSpan" id="kobo.193.2">You could not append </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">b = int64(c)</span></strong><span class="koboSpan" id="kobo.195.1"> at the end of the preceding example, as </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">b</span></strong><span class="koboSpan" id="kobo.197.1"> would be of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">uint32</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.199.1"> type.</span></span></p>
<p><span class="koboSpan" id="kobo.200.1">Type conversion is always explicit in Go, unlike other programming languages that may do this implicitly and sometimes call this </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">type casting.</span></span></p>
<h3><span class="koboSpan" id="kobo.202.1">Strings</span></h3>
<p><span class="koboSpan" id="kobo.203.1">Go supports two </span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.204.1">styles of string literals: you can enclose the characters with double-quotes to </span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.205.1">make it an interpreted literal, or use back-quotes for raw string literals, as in the </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">next example:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.207.1">func</span></span><span class="koboSpan" id="kobo.208.1"> main() {
    d :</span><span class="Code_Red"><span class="koboSpan" id="kobo.209.1">= "interpreted\nliteral"</span></span><span class="koboSpan" id="kobo.210.1">
    e :</span><span class="Code_Red"><span class="koboSpan" id="kobo.211.1">= `raw</span></span>
<span class="Code_Red"><span class="koboSpan" id="kobo.212.1">literal`</span></span><span class="koboSpan" id="kobo.213.1">
    fmt.Println(d)
    fmt.Println(e)
}</span></pre>
<p><span class="koboSpan" id="kobo.214.1">Notice the escape sequence in </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">d</span></strong><span class="koboSpan" id="kobo.216.1">. </span><span class="koboSpan" id="kobo.216.2">Go interprets this to generate a new line character within the string. </span><span class="koboSpan" id="kobo.216.3">The following is the output of this program, which you can find at </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">ch03/string-literals/main.go</span></strong><span class="koboSpan" id="kobo.218.1"> (in the </span><em class="italic"><span class="koboSpan" id="kobo.219.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.220.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.221.1"> section):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.222.1">ch03/string-literals</span><span class="Code_Blue"><span class="koboSpan" id="kobo.223.1">$ go</span></span><strong class="bold"><span class="koboSpan" id="kobo.224.1"> run main.go</span></strong><span class="koboSpan" id="kobo.225.1">
interpreted
literal
raw
literal</span></pre>
<p><span class="koboSpan" id="kobo.226.1">You can compare strings with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">==</span></strong><span class="koboSpan" id="kobo.228.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">!=</span></strong><span class="koboSpan" id="kobo.230.1"> operators. </span><span class="koboSpan" id="kobo.230.2">You can concatenate strings with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">+</span></strong><span class="koboSpan" id="kobo.232.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">+=</span></strong><span class="koboSpan" id="kobo.234.1"> operators. </span><span class="koboSpan" id="kobo.234.2">The example at </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">ch03/string-concatenate/main.go</span></strong><span class="koboSpan" id="kobo.236.1"> (in the </span><em class="italic"><span class="koboSpan" id="kobo.237.1">Further reading</span></em><span class="koboSpan" id="kobo.238.1"> section) shows these operators </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">in action:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.240.1">func</span></span><span class="koboSpan" id="kobo.241.1"> main() {
    s1 :</span><span class="Code_Red"><span class="koboSpan" id="kobo.242.1">= "Net"</span></span><span class="koboSpan" id="kobo.243.1">
    s2 :</span><span class="Code_Red"><span class="koboSpan" id="kobo.244.1">= `work`</span></span><span class="koboSpan" id="kobo.245.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.246.1">if</span></span><span class="koboSpan" id="kobo.247.1"> s1 </span><span class="Code_Red"><span class="koboSpan" id="kobo.248.1">!=</span></span><span class="koboSpan" id="kobo.249.1"> s2 {
        fmt.Println(s1 </span><span class="Code_Red"><span class="koboSpan" id="kobo.250.1">+</span></span><span class="koboSpan" id="kobo.251.1"> s2 </span><span class="Code_Red"><span class="koboSpan" id="kobo.252.1">+ " Automation"</span></span><span class="koboSpan" id="kobo.253.1">)
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.254.1">Until this point, nothing</span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.255.1"> seems to be too different from other programing </span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.256.1">languages. </span><span class="koboSpan" id="kobo.256.2">But in Go, a string is actually a slice of bytes, or to be more precise, a sequence of UTF-8 Unicode points. </span><span class="koboSpan" id="kobo.256.3">In memory, Go represents this as a two-word structure containing a pointer to the string data and </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">its length.</span></span></p>
<p><span class="koboSpan" id="kobo.258.1">Let’s define a new string, </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">n</span></strong><span class="koboSpan" id="kobo.260.1">, with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">Network Automation</span></strong><span class="koboSpan" id="kobo.262.1"> string literal in </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">ch03/string-memory/main.go</span></strong><span class="koboSpan" id="kobo.264.1"> (in the </span><em class="italic"><span class="koboSpan" id="kobo.265.1">Further reading</span></em><span class="koboSpan" id="kobo.266.1"> section). </span><span class="koboSpan" id="kobo.266.2">We can store each character as one or more bytes using the variable-width character encoding UTF-8. </span><span class="koboSpan" id="kobo.266.3">For English, we use one byte per character, so the string literal in this case is 18 </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">bytes long:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.268.1">func</span></span><span class="koboSpan" id="kobo.269.1"> main() {
    n :</span><span class="Code_Red"><span class="koboSpan" id="kobo.270.1">= "Network Automation"</span></span><span class="koboSpan" id="kobo.271.1">
    fmt.Println(</span><span class="Code_Blue"><span class="koboSpan" id="kobo.272.1">len</span></span><span class="koboSpan" id="kobo.273.1">(n))
    w :</span><span class="Code_Red"><span class="koboSpan" id="kobo.274.1">=</span></span><span class="koboSpan" id="kobo.275.1"> n[3:7]
    fmt.Println(w)
}</span></pre>
<p><span class="koboSpan" id="kobo.276.1">We can define another string as a subset of another. </span><span class="koboSpan" id="kobo.276.2">For this, we specify the lower bound in the original string and the upper bound. </span><span class="koboSpan" id="kobo.276.3">The index count starts at zero and the resulting string doesn’t include the character in the upper bound index. </span><span class="koboSpan" id="kobo.276.4">For </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">n[3:7]</span></strong><span class="koboSpan" id="kobo.278.1">, we set the boundaries at characters “</span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">w</span></strong><span class="koboSpan" id="kobo.280.1">” and “</span><strong class="source-inline"> </strong><span class="koboSpan" id="kobo.281.1">“. </span><span class="koboSpan" id="kobo.281.2">The program prints </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.283.1">ch03/string-memory</span><span class="Code_Blue"><span class="koboSpan" id="kobo.284.1">$ go</span></span><strong class="bold"><span class="koboSpan" id="kobo.285.1"> run main.go</span></strong><span class="koboSpan" id="kobo.286.1">
18
work</span></pre>
<p><span class="koboSpan" id="kobo.287.1">While the </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">n</span></strong><span class="koboSpan" id="kobo.289.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">w</span></strong><span class="koboSpan" id="kobo.291.1"> variables reference strings of different lengths, the variable size of both is the same, just like</span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.292.1"> for any other string variable. </span><span class="koboSpan" id="kobo.292.2">A string variable is a two-word structure. </span><span class="koboSpan" id="kobo.292.3">A </span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.293.1">word is usually 32 or 64 bits depending on the CPU architecture. </span><span class="koboSpan" id="kobo.293.2">Two 64-bit words are 16 bytes (2 x 8-byte), so for 64-bit platforms, a string is a 16-byte data structure. </span><span class="koboSpan" id="kobo.293.3">Out of those 16 bytes, 8 bytes are a pointer to the actual string data (a slice), and the remaining 8 bytes are to store the length of the string slice. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.294.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.295.1">.1</span></em><span class="koboSpan" id="kobo.296.1"> shows what this looks like </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">in memory:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<span class="koboSpan" id="kobo.298.1"><img alt="Figure 3.1 – What a string looks like in memory" src="image/Figure_3.3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.299.1">Figure 3.1 – What a string looks like in memory</span></p>
<p><span class="koboSpan" id="kobo.300.1">It’s OK that more than one string references the same underlying slice, as this slice is immutable, meaning that you can’t change its contents. </span><span class="koboSpan" id="kobo.300.2">While the slice stores the string data, you can’t change a character of the string by referencing an index of the slice, because </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">it’s immutable.</span></span></p>
<p><span class="koboSpan" id="kobo.302.1">By contrast, if you want to change the value of a string variable, let’s say you need to assign a different text to it, Go points the string data structure to a new underlying slice with the new string content you supply. </span><span class="koboSpan" id="kobo.302.2">All this happens behind the scenes, so you don’t need to worry </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">about this.</span></span></p>
<h3><span class="koboSpan" id="kobo.304.1">Boolean</span></h3>
<p><span class="koboSpan" id="kobo.305.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">bool</span></strong><span class="koboSpan" id="kobo.307.1"> data type </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.308.1">uses one byte of memory, and it stores a value of </span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.309.1">either </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">true</span></strong><span class="koboSpan" id="kobo.311.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">false</span></strong><span class="koboSpan" id="kobo.313.1">. </span><span class="koboSpan" id="kobo.313.2">As in other programming languages, you can use variables of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">bool</span></strong><span class="koboSpan" id="kobo.315.1"> type in conditional statements to change the control flow of a program. </span><span class="koboSpan" id="kobo.315.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">if</span></strong><span class="koboSpan" id="kobo.317.1"> conditional explicitly requires a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">bool</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.319.1"> type:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.320.1">func</span></span><span class="koboSpan" id="kobo.321.1"> main() {
    condition :</span><span class="Code_Red"><span class="koboSpan" id="kobo.322.1">=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.323.1">true</span></span><span class="koboSpan" id="kobo.324.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.325.1">if</span></span><span class="koboSpan" id="kobo.326.1"> condition {
        fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.327.1">"Type: %T, Value: %t \n"</span></span><span class="koboSpan" id="kobo.328.1">,
                    condition, condition)
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.329.1">If you run this program at </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">ch03/boolean/main.go</span></strong><span class="koboSpan" id="kobo.331.1"> (in the </span><em class="italic"><span class="koboSpan" id="kobo.332.1">Further reading</span></em><span class="koboSpan" id="kobo.333.1"> section), you get the </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">following output:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.335.1">ch03/boolean</span><span class="Code_Blue"><span class="koboSpan" id="kobo.336.1">$ go</span></span><span class="koboSpan" id="kobo.337.1"> run main.go
Type: bool, Value: </span><span class="Code_Blue"><span class="koboSpan" id="kobo.338.1">true</span></span></pre>
<p><span class="koboSpan" id="kobo.339.1">Because the condition is </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">true</span></strong><span class="koboSpan" id="kobo.341.1">, we print the </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">condition</span></strong><span class="koboSpan" id="kobo.343.1"> variable type </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">and value.</span></span></p>
<h3><span class="koboSpan" id="kobo.345.1">Error</span></h3>
<p><span class="koboSpan" id="kobo.346.1">Go has a </span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.347.1">unique approach to error handling and defines a special </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">error</span></strong><span class="koboSpan" id="kobo.349.1"> type to </span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.350.1">represent a failure condition. </span><span class="koboSpan" id="kobo.350.2">You can generate errors, change them, print them on a screen, or use them to change the control flow of a program. </span><span class="koboSpan" id="kobo.350.3">The next code sample shows the two most common ways of generating a new variable of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">Error</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.352.1"> type:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.353.1">func</span></span><span class="koboSpan" id="kobo.354.1"> main() {
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.355.1">    // Creates a variable of 'error' type</span></span><span class="koboSpan" id="kobo.356.1">
    err1 :</span><span class="Code_Red"><span class="koboSpan" id="kobo.357.1">=</span></span><span class="koboSpan" id="kobo.358.1"> errors.New(</span><span class="Code_Red"><span class="koboSpan" id="kobo.359.1">"This is a new error"</span></span><span class="koboSpan" id="kobo.360.1">)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.361.1">// string formatting when building an error message</span></span><span class="koboSpan" id="kobo.362.1">
    msg :</span><span class="Code_Red"><span class="koboSpan" id="kobo.363.1">= "another error message"</span></span><span class="koboSpan" id="kobo.364.1">
    err2 :</span><span class="Code_Red"><span class="koboSpan" id="kobo.365.1">=</span></span><span class="koboSpan" id="kobo.366.1"> fmt.Errorf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.367.1">"This is %s"</span></span><span class="koboSpan" id="kobo.368.1">, msg)
}</span></pre>
<p><span class="koboSpan" id="kobo.369.1">You can </span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.370.1">make any user-defined type an error, as long as it implements a special </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">Error()</span></strong><span class="koboSpan" id="kobo.372.1"> method that returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">string</span></strong><span class="koboSpan" id="kobo.374.1">. </span><span class="koboSpan" id="kobo.374.2">We talk more about implementing methods in the </span><em class="italic"><span class="koboSpan" id="kobo.375.1">Interfaces</span></em><span class="koboSpan" id="kobo.376.1"> section later in </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.378.1">One common </span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.379.1">way of error handling is to allow it to bubble up until a point in a program where you can decide how to react to it — whether to fail and stop the execution or log and retry. </span><span class="koboSpan" id="kobo.379.2">Regardless of that, the use of errors is pervasive in Go, and all functions that can fail return an error as their last argument, so the following pattern is very common in </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">Go programs:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.381.1">func</span></span><span class="koboSpan" id="kobo.382.1"> main() {
    result, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.383.1">=</span></span><span class="koboSpan" id="kobo.384.1"> myFunction()
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.385.1">if</span></span><span class="koboSpan" id="kobo.386.1"> err </span><span class="Code_Red"><span class="koboSpan" id="kobo.387.1">!=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.388.1">nil</span></span><span class="koboSpan" id="kobo.389.1"> {
        fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.390.1">"Received an error: %s"</span></span><span class="koboSpan" id="kobo.391.1">, err)
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.392.1">return</span></span><span class="koboSpan" id="kobo.393.1"> err
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.394.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">myFunction</span></strong><span class="koboSpan" id="kobo.396.1"> function returns two values. </span><span class="koboSpan" id="kobo.396.2">In the outer function in the preceding example, we store the first return value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">myFunction</span></strong><span class="koboSpan" id="kobo.398.1"> in a variable named </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">result</span></strong><span class="koboSpan" id="kobo.400.1">, and the second return value in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">err</span></strong><span class="koboSpan" id="kobo.402.1"> variable, to store the value of any potential error inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">myFunction</span></strong><span class="koboSpan" id="kobo.404.1">, which now surfaces to the </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">calling function.</span></span></p>
<p><span class="koboSpan" id="kobo.406.1">Depending on the logic of the program, you need to decide how to handle the error. </span><span class="koboSpan" id="kobo.406.2">Here, if the error isn’t null (</span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">nil</span></strong><span class="koboSpan" id="kobo.408.1">), we print the error message and finish the execution of the function (</span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">return</span></strong><span class="koboSpan" id="kobo.410.1">). </span><span class="koboSpan" id="kobo.410.2">We could also have just logged it and allowed the program </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">to continue.</span></span></p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.412.1">Container types</span></h2>
<p><span class="koboSpan" id="kobo.413.1">The </span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.414.1">next level up from the primitive types is a container type. </span><span class="koboSpan" id="kobo.414.2">These</span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.415.1"> are still standard types that are available to any Go program without any explicit import statement. </span><span class="koboSpan" id="kobo.415.2">But, they represent more than just a single value. </span><span class="koboSpan" id="kobo.415.3">We use container types in Go to store different values of the same type; these include </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">the following:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.417.1">Arrays</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.418.1">Slices</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.419.1">Maps</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.420.1">In the following sections, we discuss the use cases and implementation details of these </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">three types.</span></span></p>
<h3><span class="koboSpan" id="kobo.422.1">Arrays</span></h3>
<p><span class="koboSpan" id="kobo.423.1">One of </span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.424.1">the first things any programmer needs, after they’ve gained</span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.425.1"> the ability to deal with primitive types, is the ability to store collections of values of these types. </span><span class="koboSpan" id="kobo.425.2">For example, a network inventory may store a list of device hostnames or IP addresses. </span><span class="koboSpan" id="kobo.425.3">The most common solution for this problem is a data structure called an </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">array</span></strong><span class="koboSpan" id="kobo.427.1">. </span><span class="koboSpan" id="kobo.427.2">Go’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">array</span></strong><span class="koboSpan" id="kobo.429.1"> types have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">[n]T</span></strong><span class="koboSpan" id="kobo.431.1"> signature, where </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">n</span></strong><span class="koboSpan" id="kobo.433.1"> is the length of the array and </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">T</span></strong><span class="koboSpan" id="kobo.435.1"> is the value type you store in </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">the array.</span></span></p>
<p><span class="koboSpan" id="kobo.437.1">Here is an example of how you can </span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.438.1">use arrays in Go with strings. </span><span class="koboSpan" id="kobo.438.2">We purposely mix different semantic ways you can define an array, so you can choose the style you prefer. </span><span class="koboSpan" id="kobo.438.3">We first define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">hostnames</span></strong><span class="koboSpan" id="kobo.440.1"> array on a single line and then the </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">ips</span></strong><span class="koboSpan" id="kobo.442.1"> array on a </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">multiline statement:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.444.1">func</span></span><span class="koboSpan" id="kobo.445.1"> main() {
    hostnames :</span><span class="Code_Red"><span class="koboSpan" id="kobo.446.1">=</span></span><span class="koboSpan" id="kobo.447.1"> [2]</span><span class="Code_Purple"><span class="koboSpan" id="kobo.448.1">string</span></span><span class="koboSpan" id="kobo.449.1">{</span><span class="Code_Red"><span class="koboSpan" id="kobo.450.1">"router1.example.com"</span></span><span class="koboSpan" id="kobo.451.1">,
                        </span><span class="Code_Red"><span class="koboSpan" id="kobo.452.1">"router2.example.com"</span></span><span class="koboSpan" id="kobo.453.1">}
    ips :</span><span class="Code_Red"><span class="koboSpan" id="kobo.454.1">=</span></span><span class="koboSpan" id="kobo.455.1"> [3]</span><span class="Code_Purple"><span class="koboSpan" id="kobo.456.1">string</span></span><span class="koboSpan" id="kobo.457.1">{
        </span><span class="Code_Red"><span class="koboSpan" id="kobo.458.1">"192.0.2.1/32"</span></span><span class="koboSpan" id="kobo.459.1">,
        </span><span class="Code_Red"><span class="koboSpan" id="kobo.460.1">"198.51.100.1/32"</span></span><span class="koboSpan" id="kobo.461.1">,
        </span><span class="Code_Red"><span class="koboSpan" id="kobo.462.1">"203.0.113.1/32"</span></span><span class="koboSpan" id="kobo.463.1">,
    }
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.464.1">// Prints router2.example.com</span></span><span class="koboSpan" id="kobo.465.1">
    fmt.Println(hostnames[</span><span class="Code_Green"><span class="koboSpan" id="kobo.466.1">1</span></span><span class="koboSpan" id="kobo.467.1">])
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.468.1">// Prints 203.0.113.1/32</span></span><span class="koboSpan" id="kobo.469.1">
    fmt.Println(ips[</span><span class="Code_Green"><span class="koboSpan" id="kobo.470.1">2</span></span><span class="koboSpan" id="kobo.471.1">])
}</span></pre>
<p><span class="koboSpan" id="kobo.472.1">This gets </span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.473.1">even more interesting for network engineers when working with arrays</span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.474.1"> of bytes. </span><span class="koboSpan" id="kobo.474.2">Look at the next example of how Go reads the input decimal number (</span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">127</span></strong><span class="koboSpan" id="kobo.476.1"> for example), and the binary data is at your fingertips. </span><span class="koboSpan" id="kobo.476.2">Both array examples are available at </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">ch03/arrays/main.go</span></strong><span class="koboSpan" id="kobo.478.1"> (see the </span><em class="italic"><span class="koboSpan" id="kobo.479.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.480.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.481.1"> section):</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.482.1">func</span></span><span class="koboSpan" id="kobo.483.1"> main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.484.1">// ipv4 is [0000 0000, 0000 0000, 0000 0000, 0000 0000]</span></span><span class="koboSpan" id="kobo.485.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.486.1">var</span></span><span class="koboSpan" id="kobo.487.1"> ipAddr [</span><span class="Code_Green"><span class="koboSpan" id="kobo.488.1">4</span></span><span class="koboSpan" id="kobo.489.1">]</span><span class="Code_Purple"><span class="koboSpan" id="kobo.490.1">byte</span></span><span class="koboSpan" id="kobo.491.1">
    // ipv4 is [1111 1111, 0000 0000, 0000 0000, 0000 0001]
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.492.1">var</span></span><span class="koboSpan" id="kobo.493.1"> localhost = [</span><span class="Code_Green"><span class="koboSpan" id="kobo.494.1">4</span></span><span class="koboSpan" id="kobo.495.1">]</span><span class="Code_Purple"><span class="koboSpan" id="kobo.496.1">byte</span></span><span class="koboSpan" id="kobo.497.1">{</span><span class="Code_Green"><span class="koboSpan" id="kobo.498.1">127</span></span><span class="koboSpan" id="kobo.499.1">, </span><span class="Code_Green"><span class="koboSpan" id="kobo.500.1">0</span></span><span class="koboSpan" id="kobo.501.1">, </span><span class="Code_Green"><span class="koboSpan" id="kobo.502.1">0</span></span><span class="koboSpan" id="kobo.503.1">, </span><span class="Code_Green"><span class="koboSpan" id="kobo.504.1">1</span></span><span class="koboSpan" id="kobo.505.1">}
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.506.1">// prints 4</span></span><span class="koboSpan" id="kobo.507.1">
    fmt.Println(</span><span class="Code_Blue"><span class="koboSpan" id="kobo.508.1">len</span></span><span class="koboSpan" id="kobo.509.1">(localhost))
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.510.1">// prints [1111111 0 0 1]</span></span><span class="koboSpan" id="kobo.511.1">
    fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.512.1">"%b\n"</span></span><span class="koboSpan" id="kobo.513.1">, localhost)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.514.1">// prints false</span></span><span class="koboSpan" id="kobo.515.1">
    fmt.Println(ipAddr </span><span class="Code_Red"><span class="koboSpan" id="kobo.516.1">==</span></span><span class="koboSpan" id="kobo.517.1"> localhost)
}</span></pre>
<p><span class="koboSpan" id="kobo.518.1">Go arrays have</span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.519.1"> many benefits. </span><span class="koboSpan" id="kobo.519.2">They are very memory efficient, as they</span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.520.1"> store values sequentially and don’t have any extra metadata overhead. </span><span class="koboSpan" id="kobo.520.2">They are also comparable, meaning you can check whether two arrays are equal, assuming their values have </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">comparable types.</span></span></p>
<p><span class="koboSpan" id="kobo.522.1">But, because of their fixed size, we rarely use arrays directly in Go. </span><span class="koboSpan" id="kobo.522.2">The only exception is when you know the size of your dataset ahead of time. </span><span class="koboSpan" id="kobo.522.3">With that in mind, in networking, we deal with a lot of fixed-sized datasets; they make up most of the network protocol headers, so arrays can be convenient for that and things such as IP and MAC addresses, port or sequence numbers, and various </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">VPN labels.</span></span></p>
<h3><span class="koboSpan" id="kobo.524.1">Slices</span></h3>
<p><span class="koboSpan" id="kobo.525.1">Arrays</span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.526.1"> have an </span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.527.1">immutable structure by definition (fixed-size). </span><span class="koboSpan" id="kobo.527.2">While you can alter the value within an array, they cannot grow and shrink as the size of the stored data changes. </span><span class="koboSpan" id="kobo.527.3">But, implementation-wise, this has never been a problem. </span><span class="koboSpan" id="kobo.527.4">Many languages implement arrays as dynamic data structures that change their size behind </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">the scenes.</span></span></p>
<p><span class="koboSpan" id="kobo.529.1">Of course, there is some performance penalty involved when growing an array, but with some clever algorithms, it’s possible to reduce the number of changes and make the end user experience as frictionless as possible. </span><span class="koboSpan" id="kobo.529.2">Slices play this role in Go; they are the most widely used array-like data structure </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">in Go.</span></span></p>
<p><span class="koboSpan" id="kobo.531.1">Providing the length of the slice when creating it is optional. </span><span class="koboSpan" id="kobo.531.2">Behind the scenes, Go creates a backing array that defines the upper bound to what size the slice can grow to. </span><span class="koboSpan" id="kobo.531.3">That upper bound is what we know as</span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.532.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.533.1">capacity</span></strong><span class="koboSpan" id="kobo.534.1"> of the slice. </span><span class="koboSpan" id="kobo.534.2">In general, the capacity is equal to the length of the slice, but that is not always the case. </span><span class="koboSpan" id="kobo.534.3">If the slice needs to grow beyond its capacity, Go creates a new larger backing array and copies over the contents of the original array. </span><span class="koboSpan" id="kobo.534.4">The next example shows three ways to create a slice and the values for capacity and length for </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">each slice:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.536.1">func</span></span><span class="koboSpan" id="kobo.537.1"> main() {
    empty :</span><span class="Code_Red"><span class="koboSpan" id="kobo.538.1">=</span></span><span class="koboSpan" id="kobo.539.1"> []</span><span class="Code_Purple"><span class="koboSpan" id="kobo.540.1">string</span></span><span class="koboSpan" id="kobo.541.1">{}
    words :</span><span class="Code_Red"><span class="koboSpan" id="kobo.542.1">=</span></span><span class="koboSpan" id="kobo.543.1"> []</span><span class="Code_Purple"><span class="koboSpan" id="kobo.544.1">string</span></span><span class="koboSpan" id="kobo.545.1">{</span><span class="Code_Red"><span class="koboSpan" id="kobo.546.1">"zero"</span></span><span class="koboSpan" id="kobo.547.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.548.1">"one"</span></span><span class="koboSpan" id="kobo.549.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.550.1">"two"</span></span><span class="koboSpan" id="kobo.551.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.552.1">"three"</span></span><span class="koboSpan" id="kobo.553.1">,
                    </span><span class="Code_Red"><span class="koboSpan" id="kobo.554.1">"four"</span></span><span class="koboSpan" id="kobo.555.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.556.1">"five"</span></span><span class="koboSpan" id="kobo.557.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.558.1">"six"</span></span><span class="koboSpan" id="kobo.559.1">}
    three :</span><span class="Code_Red"><span class="koboSpan" id="kobo.560.1">=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.561.1">make</span></span><span class="koboSpan" id="kobo.562.1">([]</span><span class="Code_Purple"><span class="koboSpan" id="kobo.563.1">string</span></span><span class="koboSpan" id="kobo.564.1">, 3)
    fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.565.1">"empty: length: %d, capacity: %d, %v\n"</span></span><span class="koboSpan" id="kobo.566.1">,
                     </span><span class="Code_Blue"><span class="koboSpan" id="kobo.567.1">len</span></span><span class="koboSpan" id="kobo.568.1">(empty), </span><span class="Code_Blue"><span class="koboSpan" id="kobo.569.1">cap</span></span><span class="koboSpan" id="kobo.570.1">(empty), empty)
    fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.571.1">"words: length: %d, capacity: %d, %v\n"</span></span><span class="koboSpan" id="kobo.572.1">,
                    </span><span class="Code_Blue"><span class="koboSpan" id="kobo.573.1">len</span></span><span class="koboSpan" id="kobo.574.1">(words), </span><span class="Code_Blue"><span class="koboSpan" id="kobo.575.1">cap</span></span><span class="koboSpan" id="kobo.576.1">(words), words)
    fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.577.1">"three: length: %d, capacity: %d, %v\n"</span></span><span class="koboSpan" id="kobo.578.1">,
                    len(three), </span><span class="Code_Blue"><span class="koboSpan" id="kobo.579.1">cap</span></span><span class="koboSpan" id="kobo.580.1">(three), three)
    /* ... </span><span class="koboSpan" id="kobo.580.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.580.3">*/
}</span></pre>
<p><span class="koboSpan" id="kobo.581.1">This program, which</span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.582.1"> you can find at </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">ch03/slices/main.go</span></strong><span class="koboSpan" id="kobo.584.1"> (see the </span><em class="italic"><span class="koboSpan" id="kobo.585.1">Further reading</span></em><span class="koboSpan" id="kobo.586.1"> section), prints </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.588.1">ch03/slices</span><span class="Code_Blue"><span class="koboSpan" id="kobo.589.1">$ go</span></span><span class="koboSpan" id="kobo.590.1"> run main.go
empty: length: </span><span class="Code_Green"><span class="koboSpan" id="kobo.591.1">0</span></span><span class="koboSpan" id="kobo.592.1">, capacity: </span><span class="Code_Green"><span class="koboSpan" id="kobo.593.1">0</span></span><span class="koboSpan" id="kobo.594.1">, []
words: length: </span><span class="Code_Green"><span class="koboSpan" id="kobo.595.1">7</span></span><span class="koboSpan" id="kobo.596.1">, capacity: </span><span class="Code_Green"><span class="koboSpan" id="kobo.597.1">7</span></span><span class="koboSpan" id="kobo.598.1">, [zero one two three four five six]
three: length: </span><span class="Code_Green"><span class="koboSpan" id="kobo.599.1">3</span></span><span class="koboSpan" id="kobo.600.1">, capacity: </span><span class="Code_Green"><span class="koboSpan" id="kobo.601.1">3</span></span><span class="koboSpan" id="kobo.602.1">, [  ]</span></pre>
<p><span class="koboSpan" id="kobo.603.1">Just like with strings, you</span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.604.1"> can slice a slice, which creates a new reference to a section of the same backing array. </span><span class="koboSpan" id="kobo.604.2">For example, if you create a new slice based on the slice words from the preceding example with </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">words[1:3]</span></strong><span class="koboSpan" id="kobo.606.1">, you end up with a slice that has </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">one</span></strong><span class="koboSpan" id="kobo.608.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">two</span></strong><span class="koboSpan" id="kobo.610.1"> elements, so the length of this slice is two. </span><span class="koboSpan" id="kobo.610.2">Its capacity is six, though. </span><span class="koboSpan" id="kobo.610.3">Why six? </span><span class="koboSpan" id="kobo.610.4">The backing array is the same, but the new slice starts at index one, and the last index of the backing array is seven. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.611.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.612.1">.2</span></em><span class="koboSpan" id="kobo.613.1"> shows what this looks like </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">in memory:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer030">
<span class="koboSpan" id="kobo.615.1"><img alt="Figure 3.2 – What slices look like in memory" src="image/Figure_3.4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.616.1">Figure 3.2 – What slices look like in memory</span></p>
<p><span class="koboSpan" id="kobo.617.1">To add</span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.618.1"> elements to the end of slice, you can use the built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">append</span></strong><span class="koboSpan" id="kobo.620.1"> function. </span><span class="koboSpan" id="kobo.620.2">Let’s start from the </span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.621.1">slice we were just referencing and call </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">mySlice</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.625.1">func</span></span><span class="koboSpan" id="kobo.626.1"> main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.627.1">/* ... </span><span class="koboSpan" id="kobo.627.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.627.3">*/</span></span><span class="koboSpan" id="kobo.628.1">
    mySlice :</span><span class="Code_Red"><span class="koboSpan" id="kobo.629.1">=</span></span><span class="koboSpan" id="kobo.630.1"> words[</span><span class="Code_Green"><span class="koboSpan" id="kobo.631.1">1</span></span><span class="koboSpan" id="kobo.632.1">:</span><span class="Code_Green"><span class="koboSpan" id="kobo.633.1">3</span></span><span class="koboSpan" id="kobo.634.1">]
    fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.635.1">" mySlice: length: %d, capacity: %d, %v\n"</span></span><span class="koboSpan" id="kobo.636.1">,
            </span><span class="Code_Blue"><span class="koboSpan" id="kobo.637.1">len</span></span><span class="koboSpan" id="kobo.638.1">(mySlice), </span><span class="Code_Blue"><span class="koboSpan" id="kobo.639.1">cap</span></span><span class="koboSpan" id="kobo.640.1">(mySlice), mySlice)
    mySlice = </span><span class="Code_Blue"><span class="koboSpan" id="kobo.641.1">append</span></span><span class="koboSpan" id="kobo.642.1">(mySlice, </span><span class="Code_Red"><span class="koboSpan" id="kobo.643.1">"seven"</span></span><span class="koboSpan" id="kobo.644.1">)
    fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.645.1">" mySlice: length: %d, capacity: %d, %v\n"</span></span><span class="koboSpan" id="kobo.646.1">,
            </span><span class="Code_Blue"><span class="koboSpan" id="kobo.647.1">len</span></span><span class="koboSpan" id="kobo.648.1">(mySlice), </span><span class="Code_Blue"><span class="koboSpan" id="kobo.649.1">cap</span></span><span class="koboSpan" id="kobo.650.1">(mySlice), mySlice)
    mySlice = </span><span class="Code_Blue"><span class="koboSpan" id="kobo.651.1">append</span></span><span class="koboSpan" id="kobo.652.1">(mySlice, </span><span class="Code_Red"><span class="koboSpan" id="kobo.653.1">"eight"</span></span><span class="koboSpan" id="kobo.654.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.655.1">"nine"</span></span><span class="koboSpan" id="kobo.656.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.657.1">"ten"</span></span><span class="koboSpan" id="kobo.658.1">,
                    </span><span class="Code_Red"><span class="koboSpan" id="kobo.659.1">"eleven"</span></span><span class="koboSpan" id="kobo.660.1">)
    fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.661.1">" mySlice: length: %d, capacity: %d, %v\n"</span></span><span class="koboSpan" id="kobo.662.1">,
            </span><span class="Code_Blue"><span class="koboSpan" id="kobo.663.1">len</span></span><span class="koboSpan" id="kobo.664.1">(mySlice), </span><span class="Code_Blue"><span class="koboSpan" id="kobo.665.1">cap</span></span><span class="koboSpan" id="kobo.666.1">(mySlice), mySlice)
}</span></pre>
<p><span class="koboSpan" id="kobo.667.1">If we run</span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.668.1"> this program from </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">ch03/slices/main.go</span></strong><span class="koboSpan" id="kobo.670.1"> (see the </span><em class="italic"><span class="koboSpan" id="kobo.671.1">Further reading</span></em><span class="koboSpan" id="kobo.672.1"> section), we can</span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.673.1"> see how Go allocates a new backing array when it needs extra capacity. </span><span class="koboSpan" id="kobo.673.2">When it had three elements already, and we asked to add another four to a slice with a capacity of six, Go automatically allocated a new backing array with a capacity of 12 to support the extra elements and </span><span class="No-Break"><span class="koboSpan" id="kobo.674.1">future growth:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.675.1">ch03/slices</span><span class="Code_Blue"><span class="koboSpan" id="kobo.676.1">$ go</span></span><strong class="bold"><span class="koboSpan" id="kobo.677.1"> run main.go</span></strong><span class="koboSpan" id="kobo.678.1">
...
 </span><span class="koboSpan" id="kobo.678.2">mySlice: length: </span><span class="Code_Green"><span class="koboSpan" id="kobo.679.1">2</span></span><span class="koboSpan" id="kobo.680.1">, capacity: </span><span class="Code_Green"><span class="koboSpan" id="kobo.681.1">6</span></span><span class="koboSpan" id="kobo.682.1">, [one two]
 mySlice: length: </span><span class="Code_Green"><span class="koboSpan" id="kobo.683.1">3</span></span><span class="koboSpan" id="kobo.684.1">, capacity: </span><span class="Code_Green"><span class="koboSpan" id="kobo.685.1">6</span></span><span class="koboSpan" id="kobo.686.1">, [one two seven]
 mySlice: length: </span><span class="Code_Green"><span class="koboSpan" id="kobo.687.1">7</span></span><span class="koboSpan" id="kobo.688.1">, capacity: </span><span class="Code_Green"><span class="koboSpan" id="kobo.689.1">12</span></span><span class="koboSpan" id="kobo.690.1">, [one two seven eight nine ten eleven]</span></pre>
<p><span class="koboSpan" id="kobo.691.1">The bottom line is that while this might sound hard to grasp, it all happens behind the scenes. </span><span class="koboSpan" id="kobo.691.2">What we want to leave you with about slices is that they are a three-word data structure, and are 24 bytes on most </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">computers nowadays.</span></span></p>
<h3><span class="koboSpan" id="kobo.693.1">Maps</span></h3>
<p><span class="koboSpan" id="kobo.694.1">Maps </span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.695.1">are a container type that makes it possible to store a mapping between</span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.696.1"> one type, for example, a string or an integer, as the key to another type stored as the value. </span><span class="koboSpan" id="kobo.696.2">A map is of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">map[KeyType]ValueType</span></strong><span class="koboSpan" id="kobo.698.1"> form, where </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">KeyType</span></strong><span class="koboSpan" id="kobo.700.1"> is any type that is comparable and </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">ValueType</span></strong><span class="koboSpan" id="kobo.702.1"> may be any type at all. </span><span class="koboSpan" id="kobo.702.2">One example would </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">be </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">map[int]string</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.706.1">One way to initialize a</span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.707.1"> map is with the built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">make</span></strong><span class="koboSpan" id="kobo.709.1"> function as in the next example, where we create a map of </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">string</span></strong><span class="koboSpan" id="kobo.711.1"> as key and also with </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">string</span></strong><span class="koboSpan" id="kobo.713.1"> as value. </span><span class="koboSpan" id="kobo.713.2">You can add new values to the map, referencing the key you want to associate that value with. </span><span class="koboSpan" id="kobo.713.3">In the example, we map </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">spine</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.715.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">192.168.100.1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.718.1">func</span></span><span class="koboSpan" id="kobo.719.1"> main() {
    dc := make(</span><span class="Code_Purple"><span class="koboSpan" id="kobo.720.1">map</span></span><span class="koboSpan" id="kobo.721.1">[</span><span class="Code_Purple"><span class="koboSpan" id="kobo.722.1">string</span></span><span class="koboSpan" id="kobo.723.1">]</span><span class="Code_Purple"><span class="koboSpan" id="kobo.724.1">string</span></span><span class="koboSpan" id="kobo.725.1">)
    dc[</span><span class="Code_Red"><span class="koboSpan" id="kobo.726.1">"spine"</span></span><span class="koboSpan" id="kobo.727.1">] </span><span class="Code_Red"><span class="koboSpan" id="kobo.728.1">= "192.168.100.1"</span></span><span class="koboSpan" id="kobo.729.1">
    ip :</span><span class="Code_Red"><span class="koboSpan" id="kobo.730.1">=</span></span><span class="koboSpan" id="kobo.731.1"> dc[</span><span class="Code_Red"><span class="koboSpan" id="kobo.732.1">"spine"</span></span><span class="koboSpan" id="kobo.733.1">]
    ip, exists :</span><span class="Code_Red"><span class="koboSpan" id="kobo.734.1">=</span></span><span class="koboSpan" id="kobo.735.1"> dc[</span><span class="Code_Red"><span class="koboSpan" id="kobo.736.1">"spine"</span></span><span class="koboSpan" id="kobo.737.1">]
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.738.1">if</span></span><span class="koboSpan" id="kobo.739.1"> exists {
        fmt.Println(ip)
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.740.1">To</span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.741.1"> retrieve a </span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.742.1">value and assign it to a variable, you can reference the key just like when adding values, but this time, on the right side of the equals sign, as in the preceding example, where we assigned the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">dc["spine"]</span></strong><span class="koboSpan" id="kobo.744.1"> to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">ip</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.746.1"> variable.</span></span></p>
<p><span class="koboSpan" id="kobo.747.1">You can also do membership testing, to check whether a certain key is on the map. </span><span class="koboSpan" id="kobo.747.2">A two-value assignment tests for the existence of a key, as in </span><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">ip, exists := dc["spine"]</span></strong><span class="koboSpan" id="kobo.749.1">, where </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">exists</span></strong><span class="koboSpan" id="kobo.751.1"> is a Boolean value that is only </span><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">true</span></strong><span class="koboSpan" id="kobo.753.1"> if </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">dc["spine"]</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.755.1"> exists.</span></span></p>
<p><span class="koboSpan" id="kobo.756.1">Another way to initialize a map is with data, as in the next example. </span><span class="koboSpan" id="kobo.756.2">To delete elements, you can use the built-in </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">delete</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.758.1"> function:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.759.1">func</span></span><span class="koboSpan" id="kobo.760.1"> main() {
    inv :</span><span class="Code_Red"><span class="koboSpan" id="kobo.761.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.762.1">map</span></span><span class="koboSpan" id="kobo.763.1">[</span><span class="Code_Purple"><span class="koboSpan" id="kobo.764.1">string</span></span><span class="koboSpan" id="kobo.765.1">]</span><span class="Code_Purple"><span class="koboSpan" id="kobo.766.1">string</span></span><span class="koboSpan" id="kobo.767.1">{
        </span><span class="Code_Red"><span class="koboSpan" id="kobo.768.1">"router1.example.com"</span></span><span class="koboSpan" id="kobo.769.1">: </span><span class="Code_Red"><span class="koboSpan" id="kobo.770.1">"192.0.2.1/32"</span></span><span class="koboSpan" id="kobo.771.1">,
        </span><span class="Code_Red"><span class="koboSpan" id="kobo.772.1">"router2.example.com"</span></span><span class="koboSpan" id="kobo.773.1">: </span><span class="Code_Red"><span class="koboSpan" id="kobo.774.1">"198.51.100.1/32"</span></span><span class="koboSpan" id="kobo.775.1">,
    }
    fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.776.1">"inventory: length: %d, %v\n"</span></span><span class="koboSpan" id="kobo.777.1">, </span><span class="Code_Blue"><span class="koboSpan" id="kobo.778.1">len</span></span><span class="koboSpan" id="kobo.779.1">(inv),
                inv)
    </span><span class="Code_Blue"><span class="koboSpan" id="kobo.780.1">delete</span></span><span class="koboSpan" id="kobo.781.1">(inv, </span><span class="Code_Red"><span class="koboSpan" id="kobo.782.1">"router1.example.com"</span></span><span class="koboSpan" id="kobo.783.1">)
    fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.784.1">"inventory: length: %d, %v\n"</span></span><span class="koboSpan" id="kobo.785.1">, </span><span class="Code_Blue"><span class="koboSpan" id="kobo.786.1">len</span></span><span class="koboSpan" id="kobo.787.1">(inv),
                inv)
}</span></pre>
<p><span class="koboSpan" id="kobo.788.1">This</span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.789.1"> program</span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.790.1"> prints </span><span class="No-Break"><span class="koboSpan" id="kobo.791.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.792.1">ch03/maps</span><span class="Code_Blue"><span class="koboSpan" id="kobo.793.1">$ go</span></span><span class="koboSpan" id="kobo.794.1"> run main.go
inventory: length: </span><span class="Code_Green"><span class="koboSpan" id="kobo.795.1">2</span></span><span class="koboSpan" id="kobo.796.1">, map[router1.example.com:192.0.2.1/32 router2.example.com:198.51.100.1/32]
inventory: length: </span><span class="Code_Green"><span class="koboSpan" id="kobo.797.1">1</span></span><span class="koboSpan" id="kobo.798.1">, map[router2.example.com:198.51.100.1/32]</span></pre>
<p><span class="koboSpan" id="kobo.799.1">The full code for this section is available at </span><strong class="source-inline"><span class="koboSpan" id="kobo.800.1">ch03/maps/main.go</span></strong><span class="koboSpan" id="kobo.801.1"> (see the </span><em class="italic"><span class="koboSpan" id="kobo.802.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.803.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.804.1"> section).</span></span></p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.805.1">User-defined types</span></h2>
<p><span class="koboSpan" id="kobo.806.1">Unlike</span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.807.1"> the types we discussed before, user-defined types, as the name </span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.808.1">suggests, are types that you define. </span><span class="koboSpan" id="kobo.808.2">In this category we have </span><a id="_idIndexMarker175"/><span class="No-Break"><span class="koboSpan" id="kobo.809.1">the following:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.810.1">Structs</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.811.1">Interfaces</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.812.1">Interfaces are the</span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.813.1"> only abstract type in Go and define a contract for concrete types, such as structs. </span><span class="koboSpan" id="kobo.813.2">They describe behavior, not implementation details, which helps us break the business logic of our programs into building blocks with interfaces between them. </span><span class="koboSpan" id="kobo.813.3">We cover them in detail in a dedicated section for interfaces later in </span><span class="No-Break"><span class="koboSpan" id="kobo.814.1">this chapter.</span></span></p>
<h3><span class="koboSpan" id="kobo.815.1">Structs</span></h3>
<p><span class="koboSpan" id="kobo.816.1">A struct is</span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.817.1"> a data</span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.818.1"> structure that represents a collection of fields with their data types. </span><span class="koboSpan" id="kobo.818.2">Structs look a bit like mappings, except the keys in this case are fixed. </span><span class="koboSpan" id="kobo.818.3">They become an extension of the </span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">variable name.</span></span></p>
<p><span class="koboSpan" id="kobo.820.1">Let’s define a router (</span><strong class="source-inline"><span class="koboSpan" id="kobo.821.1">Router</span></strong><span class="koboSpan" id="kobo.822.1">) that has four </span><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">string</span></strong><span class="koboSpan" id="kobo.824.1"> fields and one </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">bool</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.826.1"> field:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.827.1">type</span></span><span class="koboSpan" id="kobo.828.1"> Router </span><span class="Code_Purple"><span class="koboSpan" id="kobo.829.1">struct</span></span><span class="koboSpan" id="kobo.830.1"> {
    Hostname  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.831.1">string</span></span><span class="koboSpan" id="kobo.832.1">
    Platform  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.833.1">string</span></span><span class="koboSpan" id="kobo.834.1">
    Username  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.835.1">string</span></span><span class="koboSpan" id="kobo.836.1">
    Password  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.837.1">string</span></span><span class="koboSpan" id="kobo.838.1">
    StrictKey </span><span class="Code_Purple"><span class="koboSpan" id="kobo.839.1">bool</span></span><span class="koboSpan" id="kobo.840.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.841.1">Now, this new type can also be part of another user-defined type, as in the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">Inventory</span></strong><span class="koboSpan" id="kobo.843.1"> type, which has a slice of these routers we </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">just defined:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.845.1">type</span></span><span class="koboSpan" id="kobo.846.1"> Inventory </span><span class="Code_Purple"><span class="koboSpan" id="kobo.847.1">struct</span></span><span class="koboSpan" id="kobo.848.1"> {
    Routers []Router
}</span></pre>
<p><span class="koboSpan" id="kobo.849.1">Here are a few examples of how to create an instance of a struct and assign values to </span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">its fields:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.851.1">func</span></span><span class="koboSpan" id="kobo.852.1"> main() {
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.853.1">var</span></span><span class="koboSpan" id="kobo.854.1"> r1 Router
    r1.Hostname </span><span class="Code_Red"><span class="koboSpan" id="kobo.855.1">= "router1.example.com"</span></span><span class="koboSpan" id="kobo.856.1">
    r2 :</span><span class="Code_Red"><span class="koboSpan" id="kobo.857.1">=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.858.1">new</span></span><span class="koboSpan" id="kobo.859.1">(Router)
    r2.Hostname </span><span class="Code_Red"><span class="koboSpan" id="kobo.860.1">= "router2.example.com"</span></span><span class="koboSpan" id="kobo.861.1">
    r3 := Router{
        Hostname:  </span><span class="Code_Red"><span class="koboSpan" id="kobo.862.1">"router3.example.com"</span></span><span class="koboSpan" id="kobo.863.1">,
        Platform:  </span><span class="Code_Red"><span class="koboSpan" id="kobo.864.1">"cisco_iosxr"</span></span><span class="koboSpan" id="kobo.865.1">,
        Username:  </span><span class="Code_Red"><span class="koboSpan" id="kobo.866.1">"user"</span></span><span class="koboSpan" id="kobo.867.1">,
        Password:  </span><span class="Code_Red"><span class="koboSpan" id="kobo.868.1">"secret"</span></span><span class="koboSpan" id="kobo.869.1">,
        StrictKey: </span><span class="Code_Blue"><span class="koboSpan" id="kobo.870.1">false</span></span><span class="koboSpan" id="kobo.871.1">,
    }
    /* ... </span><span class="koboSpan" id="kobo.871.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.871.3">*/
}</span></pre>
<p><span class="koboSpan" id="kobo.872.1">The caveat</span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.873.1"> is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">r2</span></strong><span class="koboSpan" id="kobo.875.1"> is now actually a pointer to </span><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">Router</span></strong><span class="koboSpan" id="kobo.877.1"> (that’s how </span><strong class="source-inline"><span class="koboSpan" id="kobo.878.1">new</span></strong><span class="koboSpan" id="kobo.879.1"> works), but it’s not something </span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.880.1">we need to worry about right now. </span><span class="koboSpan" id="kobo.880.2">Let’s put all the routers in an </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">Inventory</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.882.1">type variable:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.883.1">func</span></span><span class="koboSpan" id="kobo.884.1"> main() {
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.885.1">    /* ... </span><span class="koboSpan" id="kobo.885.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.885.3">*/</span></span><span class="koboSpan" id="kobo.886.1">
    inv :</span><span class="Code_Red"><span class="koboSpan" id="kobo.887.1">=</span></span><span class="koboSpan" id="kobo.888.1"> Inventory{
        Routers: []Router{r1, </span><span class="Code_Red"><span class="koboSpan" id="kobo.889.1">*</span></span><span class="koboSpan" id="kobo.890.1">r2, r3},
    }
    fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.891.1">"Inventory: %+v\n"</span></span><span class="koboSpan" id="kobo.892.1">, inv)
}</span></pre>
<p><span class="koboSpan" id="kobo.893.1">Now, we have all our routers conveniently in a variable we can use. </span><span class="koboSpan" id="kobo.893.2">All the fields we haven’t assigned a value yet are zero value (</span><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">""</span></strong><span class="koboSpan" id="kobo.895.1">, or empty </span><span class="No-Break"><span class="koboSpan" id="kobo.896.1">for strings):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.897.1">ch03/structs</span><span class="Code_Blue"><span class="koboSpan" id="kobo.898.1">$ go</span></span><span class="koboSpan" id="kobo.899.1"> run main.go
Inventory: {Routers:[{Hostname:router1.example.com Platform: Username: Password: StrictKey:false} {Hostname:router2.example.com Platform: Username: Password: StrictKey:false} {Hostname:router3.example.com Platform:cisco_iosxr Username:user Password:secret StrictKey:false}]}</span></pre>
<p><span class="koboSpan" id="kobo.900.1">The code in this</span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.901.1"> example is available at </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">ch03/structs/main.go</span></strong><span class="koboSpan" id="kobo.903.1"> (see the </span><em class="italic"><span class="koboSpan" id="kobo.904.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.905.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.906.1"> section).</span></span></p>
<p><span class="koboSpan" id="kobo.907.1">Until this point, we </span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.908.1">have not talked about other variable types such as pointers, channels, and functions. </span><span class="koboSpan" id="kobo.908.2">We cover these in other sections of this chapter. </span><span class="koboSpan" id="kobo.908.3">Please bear with us. </span><span class="koboSpan" id="kobo.908.4">In the next section, we introduce some math and logical operators that allow us to execute different actions in </span><span class="No-Break"><span class="koboSpan" id="kobo.909.1">our programs.</span></span></p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.910.1">Arithmetic, comparison, and logical operators</span></h1>
<p><span class="koboSpan" id="kobo.911.1">Operators are</span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.912.1"> special symbols that perform specific mathematical, logical, or relational computations on variables of different types. </span><span class="koboSpan" id="kobo.912.2">We cover the following three types of operators in </span><span class="No-Break"><span class="koboSpan" id="kobo.913.1">this section:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.914.1">Arithmetic operators</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.915.1">Logical operators</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.916.1">Comparison operators</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.917.1">While we don’t cover all corner cases and permutations of types, we’d like to focus on a few operators that might be interesting in the network </span><span class="No-Break"><span class="koboSpan" id="kobo.918.1">automation context.</span></span></p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.919.1">Arithmetic operators</span></h2>
<p><span class="koboSpan" id="kobo.920.1">These </span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.921.1">operators</span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.922.1"> perform mathematical calculations with numeric values. </span><span class="koboSpan" id="kobo.922.2">The resulting value depends on the order and type of </span><span class="No-Break"><span class="koboSpan" id="kobo.923.1">the operands:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer031">
<span class="koboSpan" id="kobo.924.1"><img alt="Table 3.3 – Arithmetic operators " src="image/Figure_3.5.jpg"/></span>
</div>
</div>
<p class="IMG---Figure"><span class="koboSpan" id="kobo.925.1">Table 3.3 – Arithmetic operators</span></p>
<p><span class="koboSpan" id="kobo.926.1">They</span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.927.1"> follow the standard mathematical logic implemented in most </span><a id="_idIndexMarker187"/><span class="No-Break"><span class="koboSpan" id="kobo.928.1">programming languages:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.929.1">func</span></span><span class="koboSpan" id="kobo.930.1"> main() {
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.931.1">    // sum s == 42</span></span><span class="koboSpan" id="kobo.932.1">
    s :</span><span class="Code_Red"><span class="koboSpan" id="kobo.933.1">=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.934.1">40</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.935.1">+</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.936.1">2</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.937.1">    // difference d == 0.14</span></span><span class="koboSpan" id="kobo.938.1">
    d :</span><span class="Code_Red"><span class="koboSpan" id="kobo.939.1">=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.940.1">3.14</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.941.1">-</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.942.1">3</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.943.1">    // product p == 9.42</span></span><span class="koboSpan" id="kobo.944.1">
    p :</span><span class="Code_Red"><span class="koboSpan" id="kobo.945.1">=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.946.1">3</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.947.1">*</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.948.1">3.14</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.949.1">    // quotient q == 0</span></span><span class="koboSpan" id="kobo.950.1">
    q :</span><span class="Code_Red"><span class="koboSpan" id="kobo.951.1">=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.952.1">3.0</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.953.1">/</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.954.1">5</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.955.1">    // remainder r == 2</span></span><span class="koboSpan" id="kobo.956.1">
    r :</span><span class="Code_Red"><span class="koboSpan" id="kobo.957.1">=</span></span><span class="koboSpan" id="kobo.958.1">  </span><span class="Code_Green"><span class="koboSpan" id="kobo.959.1">5</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.960.1">%</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.961.1">3</span></span><span class="koboSpan" id="kobo.962.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.963.1">Strings are the </span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.964.1">only non-numeric type that can make use of an arithmetic </span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.965.1">operator. </span><span class="koboSpan" id="kobo.965.2">You can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">+</span></strong><span class="koboSpan" id="kobo.967.1"> for string concatenation, to link together two or more text strings into </span><span class="No-Break"><span class="koboSpan" id="kobo.968.1">one string:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.969.1">func </span></span><span class="koboSpan" id="kobo.970.1">main() {
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.971.1">    // s == "Hello, World"</span></span><span class="koboSpan" id="kobo.972.1">
    s :</span><span class="Code_Red"><span class="koboSpan" id="kobo.973.1">= "Hello" + ", " + "World"</span></span><span class="koboSpan" id="kobo.974.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.975.1">One of the most interesting applications of arithmetic operations is interacting with binary data, something that many network engineers are </span><span class="No-Break"><span class="koboSpan" id="kobo.976.1">familiar with.</span></span></p>
<p><span class="koboSpan" id="kobo.977.1">Network protocols have deterministic structures expressed in a set of headers that contain forwarding information and facts of the </span><span class="No-Break"><span class="koboSpan" id="kobo.978.1">encapsulated payload.</span></span></p>
<p><span class="koboSpan" id="kobo.979.1">You can use the arithmetic operators bit shift and bitwise (</span><strong class="source-inline"><span class="koboSpan" id="kobo.980.1">OR</span></strong><span class="koboSpan" id="kobo.981.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.982.1">AND</span></strong><span class="koboSpan" id="kobo.983.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.984.1">XOR</span></strong><span class="koboSpan" id="kobo.985.1">) to create or extract data from </span><span class="No-Break"><span class="koboSpan" id="kobo.986.1">network headers.</span></span></p>
<p><span class="koboSpan" id="kobo.987.1">To see this in action, let’s work with a 20-byte long </span><strong class="bold"><span class="koboSpan" id="kobo.988.1">Transmission Control Protocol</span></strong><span class="koboSpan" id="kobo.989.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.990.1">TCP</span></strong><span class="koboSpan" id="kobo.991.1">) header </span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.992.1">that has the </span><span class="No-Break"><span class="koboSpan" id="kobo.993.1">following information:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.994.1">Source port address – </span><span class="No-Break"><span class="koboSpan" id="kobo.995.1">2 bytes</span></span></li>
<li><span class="koboSpan" id="kobo.996.1">Destination port address – </span><span class="No-Break"><span class="koboSpan" id="kobo.997.1">2 bytes</span></span></li>
<li><span class="koboSpan" id="kobo.998.1">Sequence number – </span><span class="No-Break"><span class="koboSpan" id="kobo.999.1">4 bytes</span></span></li>
<li><span class="koboSpan" id="kobo.1000.1">Acknowledgment number – </span><span class="No-Break"><span class="koboSpan" id="kobo.1001.1">4 bytes</span></span></li>
<li><span class="koboSpan" id="kobo.1002.1">Header length and reserved – </span><span class="No-Break"><span class="koboSpan" id="kobo.1003.1">1 byte</span></span></li>
<li><span class="koboSpan" id="kobo.1004.1">Control</span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.1005.1"> flags – </span><span class="No-Break"><span class="koboSpan" id="kobo.1006.1">1 byte:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">CWR</span></strong><span class="koboSpan" id="kobo.1008.1">: </span><strong class="bold"><span class="koboSpan" id="kobo.1009.1">Congestion Window </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1010.1">Reduced</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1011.1"> flag</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1012.1">ECE</span></strong><span class="koboSpan" id="kobo.1013.1">: </span><strong class="bold"><span class="koboSpan" id="kobo.1014.1">Explicit Congestion Notification</span></strong><span class="koboSpan" id="kobo.1015.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1016.1">ECN</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1017.1">)-echo</span></span><span class="No-Break"><a id="_idIndexMarker192"/></span><span class="No-Break"><span class="koboSpan" id="kobo.1018.1"> flag</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1019.1">URG</span></strong><span class="koboSpan" id="kobo.1020.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.1021.1">Urgent pointer</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1022.1">ACK</span></strong><span class="koboSpan" id="kobo.1023.1">: Acknowledgment number </span><span class="No-Break"><span class="koboSpan" id="kobo.1024.1">is valid</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1025.1">PSH</span></strong><span class="koboSpan" id="kobo.1026.1">: Request </span><span class="No-Break"><span class="koboSpan" id="kobo.1027.1">for push</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1028.1">RST</span></strong><span class="koboSpan" id="kobo.1029.1">: Reset </span><span class="No-Break"><span class="koboSpan" id="kobo.1030.1">the connection</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1031.1">SYN</span></strong><span class="koboSpan" id="kobo.1032.1">: Synchronize </span><span class="No-Break"><span class="koboSpan" id="kobo.1033.1">sequence numbers</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1034.1">FIN</span></strong><span class="koboSpan" id="kobo.1035.1">: Terminate </span><span class="No-Break"><span class="koboSpan" id="kobo.1036.1">the connection</span></span></li>
</ul></li>
<li><span class="koboSpan" id="kobo.1037.1">Window size – </span><span class="No-Break"><span class="koboSpan" id="kobo.1038.1">2 bytes</span></span></li>
<li><span class="koboSpan" id="kobo.1039.1">Checksum – </span><span class="No-Break"><span class="koboSpan" id="kobo.1040.1">2 bytes</span></span></li>
<li><span class="koboSpan" id="kobo.1041.1">Urgent pointer – </span><span class="No-Break"><span class="koboSpan" id="kobo.1042.1">2 bytes</span></span></li>
</ul>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1043.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1044.1">.3</span></em><span class="koboSpan" id="kobo.1045.1"> shows the TCP header structure </span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.1046.1">including all the mandatory fields we </span><span class="No-Break"><span class="koboSpan" id="kobo.1047.1">just listed:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<span class="koboSpan" id="kobo.1048.1"><img alt="Figure 3.3 – TCP header structure" src="image/Figure_3.6.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1049.1">Figure 3.3 – TCP header structure</span></p>
<p><span class="koboSpan" id="kobo.1050.1">In the next </span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.1051.1">code example, we build a TCP header from an empty slice of bytes. </span><span class="koboSpan" id="kobo.1051.2">We write its length in the first four bits of byte 13 and then set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1052.1">SYN</span></strong><span class="koboSpan" id="kobo.1053.1"> flag in byte 14 of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1054.1">TCP header.</span></span></p>
<p><span class="koboSpan" id="kobo.1055.1">The header length field of the TCP header represents the number of 32-bit words the TCP header has. </span><span class="koboSpan" id="kobo.1055.2">You can see it as the number of rows in it, as </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1056.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1057.1">.3</span></em><span class="koboSpan" id="kobo.1058.1"> shows. </span><span class="koboSpan" id="kobo.1058.2">Here, the length</span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.1059.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.1060.1">five words.</span></span></p>
<p><span class="koboSpan" id="kobo.1061.1">The following code snippet (the full version is at </span><strong class="source-inline"><span class="koboSpan" id="kobo.1062.1">ch03/tcp-header/main.go</span></strong><span class="koboSpan" id="kobo.1063.1"> (see the </span><em class="italic"><span class="koboSpan" id="kobo.1064.1">Further reading</span></em><span class="koboSpan" id="kobo.1065.1"> section)) shows</span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.1066.1"> how to set this length on a TCP header using </span><span class="No-Break"><span class="koboSpan" id="kobo.1067.1">arithmetic operations:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1068.1">func</span></span><span class="koboSpan" id="kobo.1069.1"> main() {
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1070.1">    // Header length (measured in 32-bit words) is 5</span></span><span class="koboSpan" id="kobo.1071.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1072.1">var</span></span><span class="koboSpan" id="kobo.1073.1"> headerWords </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1074.1">uint8</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.1075.1">=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1076.1">5</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.1077.1">    // Header length in bytes is 20</span></span><span class="koboSpan" id="kobo.1078.1">
    headerLen :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1079.1">=</span></span><span class="koboSpan" id="kobo.1080.1"> headerWords </span><span class="Code_Red"><span class="koboSpan" id="kobo.1081.1">*</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1082.1">32</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.1083.1">/</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1084.1">8</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.1085.1">    // Build a slice of 20 bytes to store the TCP header</span></span><span class="koboSpan" id="kobo.1086.1">
    b :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1087.1">=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.1088.1">make</span></span><span class="koboSpan" id="kobo.1089.1">([]</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1090.1">byte</span></span><span class="koboSpan" id="kobo.1091.1">, headerLen)
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1092.1">    // Shift header words bits to the left to fit</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.1093.1">    // the Header Length field of the TCP header</span></span><span class="koboSpan" id="kobo.1094.1">
    s :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1095.1">=</span></span><span class="koboSpan" id="kobo.1096.1"> headerWords </span><span class="Code_Red"><span class="koboSpan" id="kobo.1097.1">&lt;&lt;</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1098.1">4</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.1099.1">    // OR operation on byte 13 and the store new value</span></span><span class="koboSpan" id="kobo.1100.1">
    b[</span><span class="Code_Green"><span class="koboSpan" id="kobo.1101.1">13</span></span><span class="koboSpan" id="kobo.1102.1">] </span><span class="Code_Red"><span class="koboSpan" id="kobo.1103.1">=</span></span><span class="koboSpan" id="kobo.1104.1"> b[</span><span class="Code_Green"><span class="koboSpan" id="kobo.1105.1">13</span></span><span class="koboSpan" id="kobo.1106.1">] </span><span class="Code_Red"><span class="koboSpan" id="kobo.1107.1">|</span></span><span class="koboSpan" id="kobo.1108.1"> s
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1109.1">    // Print the 13 byte of the TCP header -&gt; [01010000]</span></span><span class="koboSpan" id="kobo.1110.1">
    fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1111.1">"%08b\n"</span></span><span class="koboSpan" id="kobo.1112.1">, b[</span><span class="Code_Green"><span class="koboSpan" id="kobo.1113.1">13</span></span><span class="koboSpan" id="kobo.1114.1">])
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1115.1">    /* ... </span><span class="koboSpan" id="kobo.1115.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.1115.3">*/</span></span><span class="koboSpan" id="kobo.1116.1">
}</span></pre>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1117.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1118.1">.4</span></em><span class="koboSpan" id="kobo.1119.1"> shows how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1120.1">headerWords</span></strong><span class="koboSpan" id="kobo.1121.1"> 8-bit unsigned integer variable, which is compatible with the size of a single byte, got bit-shifted left to fit into its appropriate positions in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1122.1">header’s field.</span></span></p>
<p><span class="koboSpan" id="kobo.1123.1">The left </span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.1124.1">shift operation moves the original bits, dropping the overflowing bits on the right and replacing the bits on the left with zeros. </span><span class="koboSpan" id="kobo.1124.2">The bitwise </span><strong class="source-inline"><span class="koboSpan" id="kobo.1125.1">OR</span></strong><span class="koboSpan" id="kobo.1126.1"> operator combines the resulting value with the existing byte. </span><span class="koboSpan" id="kobo.1126.2">This is a common pattern to make sure that none of the bits you configured before get lost since the bitwise </span><strong class="source-inline"><span class="koboSpan" id="kobo.1127.1">OR</span></strong><span class="koboSpan" id="kobo.1128.1"> operator always keeps the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1129.1">1</span></strong><span class="koboSpan" id="kobo.1130.1"> bits if they are present in any of </span><span class="No-Break"><span class="koboSpan" id="kobo.1131.1">the operands:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer033">
<span class="koboSpan" id="kobo.1132.1"><img alt="Figure 3.4 – Building a TCP header, part one" src="image/Figure_3.7.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1133.1">Figure 3.4 – Building a TCP header, part one</span></p>
<p><span class="koboSpan" id="kobo.1134.1">To set a flag, we can</span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.1135.1"> do something similar, where we set one bit and shift it to the left to leave it in the second position to </span><span class="No-Break"><span class="koboSpan" id="kobo.1136.1">signal </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1137.1">SYN</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1138.1">:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1139.1">func</span></span><span class="koboSpan" id="kobo.1140.1"> main() {
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1141.1">    /* ... </span><span class="koboSpan" id="kobo.1141.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.1141.3">*/</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.1142.1">    // assume that this is the initial TCP SYN message</span></span><span class="koboSpan" id="kobo.1143.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1144.1">var</span></span><span class="koboSpan" id="kobo.1145.1"> tcpSyn </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1146.1">uint8</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.1147.1">=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1148.1">1</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.1149.1">    // SYN flag is the second bit from the right so</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.1150.1">    // we shift it by 1 position</span></span><span class="koboSpan" id="kobo.1151.1">
    f :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1152.1">=</span></span><span class="koboSpan" id="kobo.1153.1"> tcpSyn </span><span class="Code_Red"><span class="koboSpan" id="kobo.1154.1">&lt;&lt;</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1155.1">1</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.1156.1">    // OR operation on byte 14 and store the new value</span></span><span class="koboSpan" id="kobo.1157.1">
    b[</span><span class="Code_Green"><span class="koboSpan" id="kobo.1158.1">14</span></span><span class="koboSpan" id="kobo.1159.1">] </span><span class="Code_Red"><span class="koboSpan" id="kobo.1160.1">=</span></span><span class="koboSpan" id="kobo.1161.1"> b[</span><span class="Code_Green"><span class="koboSpan" id="kobo.1162.1">14</span></span><span class="koboSpan" id="kobo.1163.1">] </span><span class="Code_Red"><span class="koboSpan" id="kobo.1164.1">|</span></span><span class="koboSpan" id="kobo.1165.1"> f
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1166.1">    // Print the 14 byte of the TCP header -&gt; [00000010]</span></span><span class="koboSpan" id="kobo.1167.1">
    fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1168.1">"%08b\n"</span></span><span class="koboSpan" id="kobo.1169.1">, b[</span><span class="Code_Green"><span class="koboSpan" id="kobo.1170.1">14</span></span><span class="koboSpan" id="kobo.1171.1">])
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1172.1">    /* ... </span><span class="koboSpan" id="kobo.1172.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.1172.3">*/</span></span><span class="koboSpan" id="kobo.1173.1">
}</span></pre>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1174.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1175.1">.5</span></em><span class="koboSpan" id="kobo.1176.1"> depicts the </span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.1177.1">bit operations in the preceding </span><span class="No-Break"><span class="koboSpan" id="kobo.1178.1">code example:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer034">
<span class="koboSpan" id="kobo.1179.1"><img alt="Figure 3.5 – Building a TCP header, part two" src="image/Figure_3.5_NEW.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1180.1">Figure 3.5 – Building a TCP header, part two</span></p>
<p><span class="koboSpan" id="kobo.1181.1">Now, let’s see how the reverse process of parsing those two bytes on the receiving side </span><span class="No-Break"><span class="koboSpan" id="kobo.1182.1">can look:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1183.1">func</span></span><span class="koboSpan" id="kobo.1184.1"> main() {
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1185.1">    /* ... </span><span class="koboSpan" id="kobo.1185.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.1185.3">*/</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.1186.1">    // only interested if a TCP SYN flag has been set</span></span><span class="koboSpan" id="kobo.1187.1">
    tcpSynFlag :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1188.1">=</span></span><span class="koboSpan" id="kobo.1189.1"> (b[</span><span class="Code_Green"><span class="koboSpan" id="kobo.1190.1">14</span></span><span class="koboSpan" id="kobo.1191.1">] </span><span class="Code_Red"><span class="koboSpan" id="kobo.1192.1">&amp;</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1193.1">0x02</span></span><span class="koboSpan" id="kobo.1194.1">) </span><span class="Code_Red"><span class="koboSpan" id="kobo.1195.1">!=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1196.1">0</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.1197.1">    // Shift header length right, drop any low-order bits</span></span><span class="koboSpan" id="kobo.1198.1">
    parsedHeaderWords :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1199.1">=</span></span><span class="koboSpan" id="kobo.1200.1"> b[</span><span class="Code_Green"><span class="koboSpan" id="kobo.1201.1">13</span></span><span class="koboSpan" id="kobo.1202.1">] </span><span class="Code_Red"><span class="koboSpan" id="kobo.1203.1">&gt;&gt;</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1204.1">4</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.1205.1">    // prints "TCP Flag is set: true"</span></span><span class="koboSpan" id="kobo.1206.1">
    fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1207.1">"TCP Flag is set: %t\n"</span></span><span class="koboSpan" id="kobo.1208.1">, tcpSynFlag)
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1209.1">    // prints "TCP header words: 5"</span></span><span class="koboSpan" id="kobo.1210.1">
    fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1211.1">"TCP header words: %d\n"</span></span><span class="koboSpan" id="kobo.1212.1">, parsedHeaderWords)
}</span></pre>
<p><span class="koboSpan" id="kobo.1213.1">This time, we’re </span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.1214.1">using the opposite set of bit operations. </span><span class="koboSpan" id="kobo.1214.2">The right shift moves all bits from left to right, dropping the bits on the right and adding zeros to </span><span class="No-Break"><span class="koboSpan" id="kobo.1215.1">the left:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer035">
<span class="koboSpan" id="kobo.1216.1"><img alt="Figure 3.6 – Parsing a TCP header, part one" src="image/Figure_3.61.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1217.1">Figure 3.6 – Parsing a TCP header, part one</span></p>
<p><span class="koboSpan" id="kobo.1218.1">The bitwise </span><strong class="source-inline"><span class="koboSpan" id="kobo.1219.1">AND</span></strong><span class="koboSpan" id="kobo.1220.1"> operator </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.1221.1">has the same behavior as a network mask. </span><span class="koboSpan" id="kobo.1221.2">It keeps the bits that are set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1222.1">1</span></strong><span class="koboSpan" id="kobo.1223.1"> and resets everything else to zero, effectively hiding the non-important bits. </span><span class="koboSpan" id="kobo.1223.2">In our case, we’re using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1224.1">0x02</span></strong><span class="koboSpan" id="kobo.1225.1"> mask value or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1226.1">0000 0010</span></strong><span class="koboSpan" id="kobo.1227.1"> in binary, which hides everything else and only leaves us with</span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.1228.1"> the second bit from the right. </span><span class="koboSpan" id="kobo.1228.2">We can then shift that bit to the right and check </span><span class="No-Break"><span class="koboSpan" id="kobo.1229.1">its value:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer036">
<span class="koboSpan" id="kobo.1230.1"><img alt="Figure 3.7 – Parsing a TCP header, part two" src="image/Figure_3.71.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1231.1">Figure 3.7 – Parsing a TCP header, part two</span></p>
<p><span class="koboSpan" id="kobo.1232.1">Being able to work at the bit and byte level is a powerful </span><span class="No-Break"><span class="koboSpan" id="kobo.1233.1">programming capability.</span></span></p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.1234.1">Logical operators</span></h2>
<p><span class="koboSpan" id="kobo.1235.1">Logical operators</span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.1236.1"> are a basic set of Boolean operations</span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.1237.1"> that follow the rules of Boolean algebra — conjunction, disjunction, </span><span class="No-Break"><span class="koboSpan" id="kobo.1238.1">and negation:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer037">
<span class="koboSpan" id="kobo.1239.1"><img alt="Table 3.4 – Logical operators " src="image/Figure_3.11.jpg"/></span>
</div>
</div>
<p class="IMG---Figure"><span class="koboSpan" id="kobo.1240.1">Table 3.4 – Logical operators</span></p>
<p><span class="koboSpan" id="kobo.1241.1">There is nothing surprising in Go’s implementation of these logical operators, the only thing worth remembering is that there is no syntactic sugar for them, so the only acceptable values are </span><strong class="source-inline"><span class="koboSpan" id="kobo.1242.1">&amp;&amp;</span></strong><span class="koboSpan" id="kobo.1243.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1244.1">AND</span></strong><span class="koboSpan" id="kobo.1245.1"> , </span><strong class="source-inline"><span class="koboSpan" id="kobo.1246.1">||</span></strong><span class="koboSpan" id="kobo.1247.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1248.1">OR</span></strong><span class="koboSpan" id="kobo.1249.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1250.1">!</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1251.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1252.1">NOT</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1253.1">.</span></span></p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.1254.1">Comparison operators</span></h2>
<p><span class="koboSpan" id="kobo.1255.1">We </span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.1256.1">use the equal and not equal (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1257.1">==</span></strong><span class="koboSpan" id="kobo.1258.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1259.1">!=</span></strong><span class="koboSpan" id="kobo.1260.1"> ) operators to compare a </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.1261.1">pair of comparable values and return a Boolean (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1262.1">true</span></strong><span class="koboSpan" id="kobo.1263.1">|</span><strong class="source-inline"><span class="koboSpan" id="kobo.1264.1">false</span></strong><span class="koboSpan" id="kobo.1265.1">). </span><span class="koboSpan" id="kobo.1265.2">You can apply greater than and less than operators (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1266.1">&lt;</span></strong><span class="koboSpan" id="kobo.1267.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1268.1">&lt;=</span></strong><span class="koboSpan" id="kobo.1269.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1270.1">&gt;</span></strong><span class="koboSpan" id="kobo.1271.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1272.1">&gt;=</span></strong><span class="koboSpan" id="kobo.1273.1">) to </span><span class="No-Break"><span class="koboSpan" id="kobo.1274.1">ordered values:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer038">
<span class="koboSpan" id="kobo.1275.1"><img alt="Table 3.5 – Comparison operators " src="image/Figure_3.12.jpg"/></span>
</div>
</div>
<p class="IMG---Figure"><span class="koboSpan" id="kobo.1276.1">Table 3.5 – Comparison operators</span></p>
<p><span class="koboSpan" id="kobo.1277.1">Here’s a brief example of comparison operators in action, with their most </span><span class="No-Break"><span class="koboSpan" id="kobo.1278.1">common types:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1279.1">func</span></span><span class="koboSpan" id="kobo.1280.1"> main() {
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1281.1">    // all strings are comparable</span></span><span class="koboSpan" id="kobo.1282.1">
    fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1283.1">"hello" == "hello"</span></span><span class="koboSpan" id="kobo.1284.1">)
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1285.1">    // strings are ordered alphabetically</span></span><span class="koboSpan" id="kobo.1286.1">
    fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1287.1">"hello" &lt; "world"</span></span><span class="koboSpan" id="kobo.1288.1">)
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1289.1">    // integers are comparable and ordered</span></span><span class="koboSpan" id="kobo.1290.1">
    fmt.Println(</span><span class="Code_Green"><span class="koboSpan" id="kobo.1291.1">1</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.1292.1">&lt;</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1293.1">10</span></span><span class="koboSpan" id="kobo.1294.1">)
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1295.1">    // floating point numbers are also comparable</span></span><span class="koboSpan" id="kobo.1296.1">
    fmt.Println(</span><span class="Code_Green"><span class="koboSpan" id="kobo.1297.1">10.0</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.1298.1">&gt;=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1299.1">1.1</span></span><span class="koboSpan" id="kobo.1300.1">)
}</span></pre>
<p><span class="koboSpan" id="kobo.1301.1">In the </span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.1302.1">preceding example, all statements evaluate and print </span><strong class="source-inline"><span class="koboSpan" id="kobo.1303.1">true</span></strong><span class="koboSpan" id="kobo.1304.1">. </span><span class="koboSpan" id="kobo.1304.2">You</span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.1305.1"> can find the complete list of comparable and ordered properties of other Go types, such as pointers, channels, and arrays, in the </span><em class="italic"><span class="koboSpan" id="kobo.1306.1">Comparison operators</span></em><span class="koboSpan" id="kobo.1307.1"> section of the Go language specification (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1308.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1309.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.1310.1">This concludes this introduction to the Go data types and different operators used to perform day-to-day operations. </span><span class="koboSpan" id="kobo.1310.2">Now, it’s time to put together the first building blocks of our programs as we dive into Go’s control flow </span><span class="No-Break"><span class="koboSpan" id="kobo.1311.1">and functions.</span></span></p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.1312.1">Control flow</span></h1>
<p><span class="koboSpan" id="kobo.1313.1">Control flow </span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.1314.1">constructs are a key building block of any computer program, as they allow you to express complex behaviors with conditions and iteration. </span><span class="koboSpan" id="kobo.1314.2">Go’s support for control flow reflects its minimalistic design, which is why you’d mostly see a couple of variations of conditional statements and one version of loop in the entire language specification. </span><span class="koboSpan" id="kobo.1314.3">It may seem surprising, but this makes Go easier to read, as it forces the same design patterns on all programs. </span><span class="koboSpan" id="kobo.1314.4">Let’s start with the simplest and the most common control </span><span class="No-Break"><span class="koboSpan" id="kobo.1315.1">flow blocks.</span></span></p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.1316.1">for loops</span></h2>
<p><span class="koboSpan" id="kobo.1317.1">In its simplest </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.1318.1">form, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1319.1">for</span></strong><span class="koboSpan" id="kobo.1320.1"> loop </span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.1321.1">allows you to iterate over a range of integers while doing some work in each iteration. </span><span class="koboSpan" id="kobo.1321.2">For example, this is how you would print all numbers from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1322.1">0</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1323.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1324.1">4</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1325.1">:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1326.1">func</span></span><span class="koboSpan" id="kobo.1327.1"> main() {
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1328.1">for</span></span><span class="koboSpan" id="kobo.1329.1"> i :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1330.1">=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1331.1">0</span></span><span class="koboSpan" id="kobo.1332.1">; i </span><span class="Code_Red"><span class="koboSpan" id="kobo.1333.1">&lt;</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1334.1">5</span></span><span class="koboSpan" id="kobo.1335.1">; i</span><span class="Code_Red"><span class="koboSpan" id="kobo.1336.1">++</span></span><span class="koboSpan" id="kobo.1337.1"> {
        fmt.Println(i)
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.1338.1">The first line has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1339.1">init</span></strong><span class="koboSpan" id="kobo.1340.1"> statement, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1341.1">i := 0</span></strong><span class="koboSpan" id="kobo.1342.1">, the condition statement, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1343.1">i &lt; 5</span></strong><span class="koboSpan" id="kobo.1344.1">, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1345.1">post</span></strong><span class="koboSpan" id="kobo.1346.1"> (each iteration) statement, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1347.1">i++</span></strong><span class="koboSpan" id="kobo.1348.1">, separated by semicolons (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1349.1">;</span></strong><span class="koboSpan" id="kobo.1350.1">). </span><span class="koboSpan" id="kobo.1350.2">The code continues to </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.1351.1">evaluate the condition statement and the post statement of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1352.1">for</span></strong><span class="koboSpan" id="kobo.1353.1"> loop </span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.1354.1">until the condition is no longer </span><strong class="source-inline"><span class="koboSpan" id="kobo.1355.1">true</span></strong><span class="koboSpan" id="kobo.1356.1">, that is, until </span><strong class="source-inline"><span class="koboSpan" id="kobo.1357.1">i &gt;= </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1358.1">5</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1359.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1360.1">This loop type (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1361.1">for</span></strong><span class="koboSpan" id="kobo.1362.1">) has many variations and one of the most common ones is the iteration over a container type. </span><span class="koboSpan" id="kobo.1362.2">Here are </span><span class="No-Break"><span class="koboSpan" id="kobo.1363.1">two examples:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1364.1">This is an example of iterating over </span><span class="No-Break"><span class="koboSpan" id="kobo.1365.1">a slice:</span></span><pre class="console"><span class="Code_Purple"><span class="koboSpan" id="kobo.1366.1">func</span></span><span class="koboSpan" id="kobo.1367.1"> main() {</span></pre><pre class="console"><span class="koboSpan" id="kobo.1368.1">    slice :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1369.1">=</span></span><span class="koboSpan" id="kobo.1370.1"> []</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1371.1">string</span></span><span class="koboSpan" id="kobo.1372.1">{</span><span class="Code_Red"><span class="koboSpan" id="kobo.1373.1">"r1"</span></span><span class="koboSpan" id="kobo.1374.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.1375.1">"r2"</span></span><span class="koboSpan" id="kobo.1376.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.1377.1">"r3"</span></span><span class="koboSpan" id="kobo.1378.1">}</span></pre><pre class="console"><span class="koboSpan" id="kobo.1379.1">    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1380.1">for</span></span><span class="koboSpan" id="kobo.1381.1"> i, v :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1382.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.1383.1">range </span></span><span class="koboSpan" id="kobo.1384.1">slice {</span></pre><pre class="console"><span class="koboSpan" id="kobo.1385.1">        fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1386.1">"index %d: value: %s\n"</span></span><span class="koboSpan" id="kobo.1387.1">, i, v)</span></pre><pre class="console"><span class="koboSpan" id="kobo.1388.1">    }</span></pre><pre class="console"><span class="koboSpan" id="kobo.1389.1">}</span></pre></li>
<li><span class="koboSpan" id="kobo.1390.1">This is an example of iterating over </span><span class="No-Break"><span class="koboSpan" id="kobo.1391.1">a map:</span></span><pre class="console"><span class="Code_Purple"><span class="koboSpan" id="kobo.1392.1">func</span></span><span class="koboSpan" id="kobo.1393.1"> main() {</span></pre><pre class="console"><span class="koboSpan" id="kobo.1394.1">    hashMap := </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1395.1">map</span></span><span class="koboSpan" id="kobo.1396.1">[</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1397.1">int</span></span><span class="koboSpan" id="kobo.1398.1">]</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1399.1">string</span></span><span class="koboSpan" id="kobo.1400.1">{</span></pre><pre class="console"><span class="koboSpan" id="kobo.1401.1">        </span><span class="Code_Green"><span class="koboSpan" id="kobo.1402.1">1</span></span><span class="koboSpan" id="kobo.1403.1">: </span><span class="Code_Red"><span class="koboSpan" id="kobo.1404.1">"r1"</span></span><span class="koboSpan" id="kobo.1405.1">,</span></pre><pre class="console"><span class="koboSpan" id="kobo.1406.1">        </span><span class="Code_Green"><span class="koboSpan" id="kobo.1407.1">2</span></span><span class="koboSpan" id="kobo.1408.1">: </span><span class="Code_Red"><span class="koboSpan" id="kobo.1409.1">"r2"</span></span><span class="koboSpan" id="kobo.1410.1">,</span></pre><pre class="console"><span class="koboSpan" id="kobo.1411.1">        </span><span class="Code_Green"><span class="koboSpan" id="kobo.1412.1">3</span></span><span class="koboSpan" id="kobo.1413.1">: </span><span class="Code_Red"><span class="koboSpan" id="kobo.1414.1">"r3"</span></span><span class="koboSpan" id="kobo.1415.1">,</span></pre><pre class="console"><span class="koboSpan" id="kobo.1416.1">    }</span></pre><pre class="console"><span class="koboSpan" id="kobo.1417.1">    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1418.1">for</span></span><span class="koboSpan" id="kobo.1419.1"> i, v :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1420.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.1421.1">range </span></span><span class="koboSpan" id="kobo.1422.1">hashMap {</span></pre><pre class="console"><span class="koboSpan" id="kobo.1423.1">        fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1424.1">"key %d: value: %s\n"</span></span><span class="koboSpan" id="kobo.1425.1">, i, v)</span></pre><pre class="console"><span class="koboSpan" id="kobo.1426.1">    }</span></pre><pre class="console"><span class="koboSpan" id="kobo.1427.1">}</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.1428.1">The special </span><strong class="source-inline"><span class="koboSpan" id="kobo.1429.1">range</span></strong><span class="koboSpan" id="kobo.1430.1"> keyword loops through all values of a slice or a map, creating a copy of the current item on </span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.1431.1">a new pair of key/value variables for each iteration (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1432.1">i</span></strong><span class="koboSpan" id="kobo.1433.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1434.1">v</span></strong><span class="koboSpan" id="kobo.1435.1"> in the examples). </span><span class="koboSpan" id="kobo.1435.2">You</span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.1436.1"> can also use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1437.1">range</span></strong><span class="koboSpan" id="kobo.1438.1"> to iterate over arrays and strings. </span><span class="koboSpan" id="kobo.1438.2">This keyword has special behavior for channels, which we cover later in the </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1439.1">Concurrency</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1440.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.1441.1">Another common variation of this loop construct is the infinite loop. </span><span class="koboSpan" id="kobo.1441.2">You can use this when you don’t know the number of iterations ahead of time, but you know when </span><span class="No-Break"><span class="koboSpan" id="kobo.1442.1">to stop:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1443.1">func</span></span><span class="koboSpan" id="kobo.1444.1"> main() {
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1445.1">for</span></span><span class="koboSpan" id="kobo.1446.1"> {
        time.Sleep(time.Second)
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1447.1">break</span></span><span class="koboSpan" id="kobo.1448.1">
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.1449.1">The key distinction here is the absence of any conditions in the loop definition, which is a shorthand for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1450.1">true</span></strong><span class="koboSpan" id="kobo.1451.1">; that is, the condition statement always evaluates to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1452.1">true</span></strong><span class="koboSpan" id="kobo.1453.1"> and the loop iterates infinitely. </span><span class="koboSpan" id="kobo.1453.2">The only way to stop this kind of loop is to use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1454.1">break</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1455.1"> keyword.</span></span></p>
<p><span class="koboSpan" id="kobo.1456.1">Go doesn’t have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1457.1">while</span></strong><span class="koboSpan" id="kobo.1458.1"> keyword for loops, which you can find in many other programming languages. </span><span class="koboSpan" id="kobo.1458.2">But, you can make Go’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1459.1">for</span></strong><span class="koboSpan" id="kobo.1460.1"> loop act in the same way as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1461.1">while</span></strong><span class="koboSpan" id="kobo.1462.1">, by dropping the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1463.1">init</span></strong><span class="koboSpan" id="kobo.1464.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1465.1">post</span></strong><span class="koboSpan" id="kobo.1466.1"> statements as the next code </span><span class="No-Break"><span class="koboSpan" id="kobo.1467.1">example shows:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1468.1">func</span></span><span class="koboSpan" id="kobo.1469.1"> main() {
    i :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1470.1">=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1471.1">0</span></span><span class="koboSpan" id="kobo.1472.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1473.1">for</span></span><span class="koboSpan" id="kobo.1474.1"> i </span><span class="Code_Red"><span class="koboSpan" id="kobo.1475.1">&lt;</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1476.1">5</span></span><span class="koboSpan" id="kobo.1477.1"> {
        fmt.Println(i)
        i</span><span class="Code_Red"><span class="koboSpan" id="kobo.1478.1">++</span></span><span class="koboSpan" id="kobo.1479.1">
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.1480.1">Another special keyword worth mentioning in this context is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1481.1">continue</span></strong><span class="koboSpan" id="kobo.1482.1">, which skips the remainder</span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.1483.1"> of the current iteration of a loop. </span><span class="koboSpan" id="kobo.1483.2">The following example</span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.1484.1"> prints all numbers from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1485.1">0</span></strong><span class="koboSpan" id="kobo.1486.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1487.1">4</span></strong><span class="koboSpan" id="kobo.1488.1">, but only if they </span><span class="No-Break"><span class="koboSpan" id="kobo.1489.1">are even:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1490.1">func</span></span><strong class="bold"> </strong><span class="koboSpan" id="kobo.1491.1">main() {
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1492.1">    // prints 0 2 4</span></span><span class="koboSpan" id="kobo.1493.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1494.1">for</span></span><span class="koboSpan" id="kobo.1495.1"> i :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1496.1">=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1497.1">0</span></span><span class="koboSpan" id="kobo.1498.1">; i </span><span class="Code_Red"><span class="koboSpan" id="kobo.1499.1">&lt;</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1500.1">5</span></span><span class="koboSpan" id="kobo.1501.1">; i</span><span class="Code_Red"><span class="koboSpan" id="kobo.1502.1">++</span></span><span class="koboSpan" id="kobo.1503.1"> {
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1504.1">if</span></span><span class="koboSpan" id="kobo.1505.1"> i </span><span class="Code_Red"><span class="koboSpan" id="kobo.1506.1">%</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1507.1">2</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.1508.1">!=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1509.1">0</span></span><span class="koboSpan" id="kobo.1510.1"> {
            </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1511.1">continue</span></span><span class="koboSpan" id="kobo.1512.1">
        }
        fmt.Println(i)
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.1513.1">In this example, we skip numbers that have a non-zero remainder when divided by two with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1514.1">if i % 2 != 0</span></strong><span class="koboSpan" id="kobo.1515.1"> clause. </span><span class="koboSpan" id="kobo.1515.2">This is a conditional statement, which is the topic of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1516.1">next section.</span></span></p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.1517.1">Conditional statements</span></h2>
<p><span class="koboSpan" id="kobo.1518.1">Control structures </span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.1519.1">help you define the behavior or direction to follow when a program can follow different </span><span class="No-Break"><span class="koboSpan" id="kobo.1520.1">execution paths.</span></span></p>
<p><span class="koboSpan" id="kobo.1521.1">Let’s start with a two-way </span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.1522.1">conditional statement. </span><span class="koboSpan" id="kobo.1522.2">We try to connect to a website (</span><a href="https://www.tkng.io/"><span class="koboSpan" id="kobo.1523.1">https://www.tkng.io/</span></a><span class="koboSpan" id="kobo.1524.1">) and then print the response we receive if the connection is successful, or we return the error message if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1525.1">HTTP GET</span></strong><span class="koboSpan" id="kobo.1526.1"> operation fails. </span><span class="koboSpan" id="kobo.1526.2">If the error is not null (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1527.1">err != nil</span></strong><span class="koboSpan" id="kobo.1528.1">), we return. </span><span class="koboSpan" id="kobo.1528.2">Otherwise (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1529.1">else</span></strong><span class="koboSpan" id="kobo.1530.1">), we print the </span><span class="No-Break"><span class="koboSpan" id="kobo.1531.1">information (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1532.1">fmt.Printf</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1533.1">):</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1534.1">func</span></span><span class="koboSpan" id="kobo.1535.1"> main() {
    resp, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1536.1">=</span></span><span class="koboSpan" id="kobo.1537.1"> http.Get(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1538.1">"https://www.tkng.io/"</span></span><span class="koboSpan" id="kobo.1539.1">)
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1540.1">if</span></span><span class="koboSpan" id="kobo.1541.1"> err </span><span class="Code_Red"><span class="koboSpan" id="kobo.1542.1">!=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.1543.1">nil</span></span><span class="koboSpan" id="kobo.1544.1"> {
            log.Fatalf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1545.1">"Could not connect: %v"</span></span><span class="koboSpan" id="kobo.1546.1">, err)
    } </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1547.1">else</span></span><span class="koboSpan" id="kobo.1548.1"> {
            fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1549.1">"Received response: %v"</span></span><span class="koboSpan" id="kobo.1550.1">,
                        resp.Status)
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.1551.1">One </span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.1552.1">way to improve the readability of the preceding example is to left-align the successful execution path of the program, meaning that if </span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.1553.1">one of the branches of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1554.1">if</span></strong><span class="koboSpan" id="kobo.1555.1"> condition ends in a terminating statement, as in our case with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1556.1">return</span></strong><span class="koboSpan" id="kobo.1557.1">, you can drop the entire </span><strong class="source-inline"><span class="koboSpan" id="kobo.1558.1">else</span></strong><span class="koboSpan" id="kobo.1559.1"> clause and rewrite the code </span><span class="No-Break"><span class="koboSpan" id="kobo.1560.1">as follows:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1561.1">func</span></span><span class="koboSpan" id="kobo.1562.1"> main() {
    resp, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1563.1">=</span></span><span class="koboSpan" id="kobo.1564.1"> http.Get(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1565.1">"https://www.tkng.io/"</span></span><span class="koboSpan" id="kobo.1566.1">)
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1567.1">if</span></span><span class="koboSpan" id="kobo.1568.1"> err </span><span class="Code_Red"><span class="koboSpan" id="kobo.1569.1">!=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.1570.1">nil</span></span><span class="koboSpan" id="kobo.1571.1"> {
            log.Fatalf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1572.1">"Could not connect: %v"</span></span><span class="koboSpan" id="kobo.1573.1">, err)
    }
    fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1574.1">"Received response: %v"</span></span><span class="koboSpan" id="kobo.1575.1">, resp.Status)
}</span></pre>
<p><span class="koboSpan" id="kobo.1576.1">Like any typical </span><strong class="source-inline"><span class="koboSpan" id="kobo.1577.1">if</span></strong><span class="koboSpan" id="kobo.1578.1">-</span><strong class="source-inline"><span class="koboSpan" id="kobo.1579.1">then</span></strong><span class="koboSpan" id="kobo.1580.1">-</span><strong class="source-inline"><span class="koboSpan" id="kobo.1581.1">else</span></strong><span class="koboSpan" id="kobo.1582.1"> construct, Go’s conditional statements can encode multi-way conditions with many </span><strong class="source-inline"><span class="koboSpan" id="kobo.1583.1">if</span></strong><span class="koboSpan" id="kobo.1584.1">-</span><strong class="source-inline"><span class="koboSpan" id="kobo.1585.1">else</span></strong><span class="koboSpan" id="kobo.1586.1"> statements. </span><span class="koboSpan" id="kobo.1586.2">But, Go developers usually prefer to use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1587.1">switch</span></strong><span class="koboSpan" id="kobo.1588.1"> statement in this scenario, because it’s a more concise and readable form of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1589.1">multi-stage </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1590.1">if</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1591.1">-</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1592.1">then</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1593.1">-</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1594.1">else</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1595.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1596.1">Consider the following example, which sends an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1597.1">HTTP GET</span></strong><span class="koboSpan" id="kobo.1598.1"> request and prints a message based on the returned status code. </span><span class="koboSpan" id="kobo.1598.2">The full code is at </span><strong class="source-inline"><span class="koboSpan" id="kobo.1599.1">ch03/switch/main.go</span></strong><span class="koboSpan" id="kobo.1600.1"> (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1601.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1602.1">):</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1603.1">func</span></span><span class="koboSpan" id="kobo.1604.1"> main() {
    resp, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1605.1">=</span></span><span class="koboSpan" id="kobo.1606.1"> http.Get(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1607.1">"http://httpstat.us/304"</span></span><span class="koboSpan" id="kobo.1608.1">)
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1609.1">if</span></span><span class="koboSpan" id="kobo.1610.1"> err </span><span class="Code_Red"><span class="koboSpan" id="kobo.1611.1">!=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.1612.1">nil</span></span><span class="koboSpan" id="kobo.1613.1"> {
        log.Fatalf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1614.1">"Could not connect: %v"</span></span><span class="koboSpan" id="kobo.1615.1">, err)
    }
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1616.1">switch</span></span><span class="koboSpan" id="kobo.1617.1"> {
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1618.1">case</span></span><span class="koboSpan" id="kobo.1619.1"> resp.StatusCode </span><span class="Code_Red"><span class="koboSpan" id="kobo.1620.1">&gt;=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1621.1">600</span></span><span class="koboSpan" id="kobo.1622.1">:
        fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1623.1">"Unknown"</span></span><span class="koboSpan" id="kobo.1624.1">)
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1625.1">case</span></span><span class="koboSpan" id="kobo.1626.1"> resp.StatusCode </span><span class="Code_Red"><span class="koboSpan" id="kobo.1627.1">&gt;=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1628.1">500</span></span><span class="koboSpan" id="kobo.1629.1">:
        fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1630.1">"Server Error"</span></span><span class="koboSpan" id="kobo.1631.1">)
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1632.1">case</span></span><span class="koboSpan" id="kobo.1633.1"> resp.StatusCode </span><span class="Code_Red"><span class="koboSpan" id="kobo.1634.1">&gt;=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1635.1">400</span></span><span class="koboSpan" id="kobo.1636.1">:
        fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1637.1">"Client Error"</span></span><span class="koboSpan" id="kobo.1638.1">)
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1639.1">case</span></span><span class="koboSpan" id="kobo.1640.1"> resp.StatusCode </span><span class="Code_Red"><span class="koboSpan" id="kobo.1641.1">&gt;=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1642.1">300</span></span><span class="koboSpan" id="kobo.1643.1">:
        fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1644.1">"Redirect"</span></span><span class="koboSpan" id="kobo.1645.1">)
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1646.1">case</span></span><span class="koboSpan" id="kobo.1647.1"> resp.StatusCode </span><span class="Code_Red"><span class="koboSpan" id="kobo.1648.1">&gt;=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1649.1">200</span></span><span class="koboSpan" id="kobo.1650.1">:
        fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1651.1">"Success"</span></span><span class="koboSpan" id="kobo.1652.1">)
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1653.1">case</span></span><span class="koboSpan" id="kobo.1654.1"> resp.StatusCode </span><span class="Code_Red"><span class="koboSpan" id="kobo.1655.1">&gt;=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1656.1">100</span></span><span class="koboSpan" id="kobo.1657.1">:
        fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1658.1">"Informational"</span></span><span class="koboSpan" id="kobo.1659.1">)
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1660.1">default</span></span><span class="koboSpan" id="kobo.1661.1">:
        fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1662.1">"Incorrect"</span></span><span class="koboSpan" id="kobo.1663.1">)
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.1664.1">You can write this</span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.1665.1"> example as a chain of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1666.1">if</span></strong><span class="koboSpan" id="kobo.1667.1">-</span><strong class="source-inline"><span class="koboSpan" id="kobo.1668.1">then</span></strong><span class="koboSpan" id="kobo.1669.1">-</span><strong class="source-inline"><span class="koboSpan" id="kobo.1670.1">else</span></strong><span class="koboSpan" id="kobo.1671.1"> statements</span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.1672.1"> as well, but using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1673.1">switch</span></strong><span class="koboSpan" id="kobo.1674.1"> makes your code cleaner, and many Go developers consider it good practice for </span><span class="No-Break"><span class="koboSpan" id="kobo.1675.1">these situations.</span></span></p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.1676.1">goto statements</span></h2>
<p><span class="koboSpan" id="kobo.1677.1">Another way </span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.1678.1">you can transfer the control from one part of a program </span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.1679.1">to another is by using a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1680.1">goto</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1681.1"> statement.</span></span></p>
<p><span class="koboSpan" id="kobo.1682.1">You can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1683.1">goto</span></strong><span class="koboSpan" id="kobo.1684.1"> statements to break out of a nested or infinite loop or to </span><span class="No-Break"><span class="koboSpan" id="kobo.1685.1">implement logic.</span></span></p>
<p><span class="koboSpan" id="kobo.1686.1">Building upon the preceding code example, let’s see how we can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1687.1">goto</span></strong><span class="koboSpan" id="kobo.1688.1"> statements to implement various exit points from a function. </span><span class="koboSpan" id="kobo.1688.2">You can find the full code of the example at </span><strong class="source-inline"><span class="koboSpan" id="kobo.1689.1">ch03/goto/main.go</span></strong><span class="koboSpan" id="kobo.1690.1"> (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1691.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1692.1">):</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1693.1">func</span></span><span class="koboSpan" id="kobo.1694.1"> main() {
    resp, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1695.1">=</span></span><span class="koboSpan" id="kobo.1696.1"> http.Get(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1697.1">"http://httpstat.us/304"</span></span><span class="koboSpan" id="kobo.1698.1">)
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1699.1">if</span></span><span class="koboSpan" id="kobo.1700.1"> err </span><span class="Code_Red"><span class="koboSpan" id="kobo.1701.1">!=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.1702.1">nil</span></span><span class="koboSpan" id="kobo.1703.1"> {
        log.Fatalf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1704.1">"Could not connect: %v"</span></span><span class="koboSpan" id="kobo.1705.1">, err)
    }
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1706.1">switch</span></span><span class="koboSpan" id="kobo.1707.1"> {
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1708.1">case </span></span><span class="koboSpan" id="kobo.1709.1">resp.StatusCode </span><span class="Code_Red"><span class="koboSpan" id="kobo.1710.1">&gt;=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1711.1">600</span></span><span class="koboSpan" id="kobo.1712.1">:
        fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1713.1">"Unknown"</span></span><span class="koboSpan" id="kobo.1714.1">)
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1715.1">goto</span></span><span class="koboSpan" id="kobo.1716.1"> exception
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1717.1">case </span></span><span class="koboSpan" id="kobo.1718.1">resp.StatusCode </span><span class="Code_Red"><span class="koboSpan" id="kobo.1719.1">&gt;=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1720.1">500</span></span><span class="koboSpan" id="kobo.1721.1">:
        fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1722.1">"Server Error"</span></span><span class="koboSpan" id="kobo.1723.1">)
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1724.1">goto</span></span><span class="koboSpan" id="kobo.1725.1"> failure
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1726.1">case</span></span><span class="koboSpan" id="kobo.1727.1"> resp.StatusCode </span><span class="Code_Red"><span class="koboSpan" id="kobo.1728.1">&gt;=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1729.1">400</span></span><span class="koboSpan" id="kobo.1730.1">:
        fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1731.1">"Client Error"</span></span><span class="koboSpan" id="kobo.1732.1">)
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1733.1">goto</span></span><span class="koboSpan" id="kobo.1734.1"> failure
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1735.1">case</span></span><span class="koboSpan" id="kobo.1736.1"> resp.StatusCode </span><span class="Code_Red"><span class="koboSpan" id="kobo.1737.1">&gt;=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1738.1">300</span></span><span class="koboSpan" id="kobo.1739.1">:
        fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1740.1">"Redirect"</span></span><span class="koboSpan" id="kobo.1741.1">)
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1742.1">goto</span></span><span class="koboSpan" id="kobo.1743.1"> exit
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1744.1">case</span></span><span class="koboSpan" id="kobo.1745.1"> resp.StatusCode </span><span class="Code_Red"><span class="koboSpan" id="kobo.1746.1">&gt;=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1747.1">200</span></span><span class="koboSpan" id="kobo.1748.1">:
        fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1749.1">"Success"</span></span><span class="koboSpan" id="kobo.1750.1">)
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1751.1">goto</span></span><span class="koboSpan" id="kobo.1752.1"> exit
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1753.1">case</span></span><span class="koboSpan" id="kobo.1754.1"> resp.StatusCode </span><span class="Code_Red"><span class="koboSpan" id="kobo.1755.1">&gt;=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1756.1">100</span></span><span class="koboSpan" id="kobo.1757.1">:
        fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1758.1">"Informational"</span></span><span class="koboSpan" id="kobo.1759.1">)
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1760.1">goto</span></span><span class="koboSpan" id="kobo.1761.1"> exit
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1762.1">default</span></span><span class="koboSpan" id="kobo.1763.1">:
        fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1764.1">"Incorrect"</span></span><span class="koboSpan" id="kobo.1765.1">)
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1766.1">goto</span></span><span class="koboSpan" id="kobo.1767.1"> exception
    }
   exception:
    </span><span class="Code_Blue"><span class="koboSpan" id="kobo.1768.1">panic</span></span><span class="koboSpan" id="kobo.1769.1">(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1770.1">"Unexpected response"</span></span><span class="koboSpan" id="kobo.1771.1">)
   failure:
    log.Fatalf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1772.1">"Failed to connect: %v"</span></span><span class="koboSpan" id="kobo.1773.1">, err)
   exit:
    fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1774.1">"Connection successful"</span></span><span class="koboSpan" id="kobo.1775.1">)
}</span></pre>
<p><span class="koboSpan" id="kobo.1776.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1777.1">goto</span></strong><span class="koboSpan" id="kobo.1778.1"> statements </span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.1779.1">have a somewhat evil reputation in </span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.1780.1">most programming languages because of their power to break the flow of a program, often making it harder to read, with many prominent computer scientists warning against their inconsiderate use. </span><span class="koboSpan" id="kobo.1780.2">Still, these statements do have their place and you can find them in many projects and even in the Go </span><span class="No-Break"><span class="koboSpan" id="kobo.1781.1">standard library.</span></span></p>
<p><span class="koboSpan" id="kobo.1782.1">Loops, conditional statements, and things like </span><strong class="source-inline"><span class="koboSpan" id="kobo.1783.1">goto</span></strong><span class="koboSpan" id="kobo.1784.1"> help you define the control flow of your Go programs. </span><span class="koboSpan" id="kobo.1784.2">We</span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.1785.1"> still haven’t covered some extra control flow constructs and corner cases used together</span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.1786.1"> with channel types. </span><span class="koboSpan" id="kobo.1786.2">We cover them later in the </span><em class="italic"><span class="koboSpan" id="kobo.1787.1">Concurrency</span></em><span class="koboSpan" id="kobo.1788.1"> section of this chapter, but before we get there, we first need to talk about another important area of code </span><span class="No-Break"><span class="koboSpan" id="kobo.1789.1">organization: functions.</span></span></p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.1790.1">Functions</span></h1>
<p><span class="koboSpan" id="kobo.1791.1">On the </span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.1792.1">surface, a Go function is exactly the same as in any other programming language: a section of code designed to perform a certain task grouped into a reusable container. </span><span class="koboSpan" id="kobo.1792.2">Thanks to the static nature of the language, all functions have a signature that defines the number and types of acceptable input arguments and </span><span class="No-Break"><span class="koboSpan" id="kobo.1793.1">output values.</span></span></p>
<p><span class="koboSpan" id="kobo.1794.1">Consider the following function (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1795.1">generateName</span></strong><span class="koboSpan" id="kobo.1796.1">), which generates a new name based on a pair of input strings (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1797.1">base</span></strong><span class="koboSpan" id="kobo.1798.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1799.1">suffix</span></strong><span class="koboSpan" id="kobo.1800.1">). </span><span class="koboSpan" id="kobo.1800.2">You can find the full code of the next example at </span><strong class="source-inline"><span class="koboSpan" id="kobo.1801.1">ch03/functions1/main.go</span></strong><span class="koboSpan" id="kobo.1802.1"> (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1803.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1804.1">):</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1805.1">func</span></span><span class="koboSpan" id="kobo.1806.1"> generateName(base </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1807.1">string</span></span><span class="koboSpan" id="kobo.1808.1">, suffix </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1809.1">string</span></span><span class="koboSpan" id="kobo.1810.1">) </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1811.1">string </span></span><span class="koboSpan" id="kobo.1812.1">{
    parts :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1813.1">=</span></span><span class="koboSpan" id="kobo.1814.1"> []</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1815.1">string</span></span><span class="koboSpan" id="kobo.1816.1">{base, suffix}
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1817.1">return</span></span><span class="koboSpan" id="kobo.1818.1"> strings.Join(parts, </span><span class="Code_Red"><span class="koboSpan" id="kobo.1819.1">"-"</span></span><span class="koboSpan" id="kobo.1820.1">)
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1821.1">func</span></span><span class="koboSpan" id="kobo.1822.1"> main() {
    s :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1823.1">=</span></span><span class="koboSpan" id="kobo.1824.1"> generateName(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1825.1">"device"</span></span><span class="koboSpan" id="kobo.1826.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.1827.1">"01"</span></span><span class="koboSpan" id="kobo.1828.1">)
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1829.1">    // prints "device-01"</span></span><span class="koboSpan" id="kobo.1830.1">
    fmt.Println(s)
}</span></pre>
<p><span class="koboSpan" id="kobo.1831.1">This function’s signature is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1832.1">func (string, string) string</span></strong><span class="koboSpan" id="kobo.1833.1">, meaning that it accepts two arguments of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1834.1">string</span></strong><span class="koboSpan" id="kobo.1835.1"> type and returns another string. </span><span class="koboSpan" id="kobo.1835.2">You can assign the returned value to a variable or pass it as an argument directly to </span><span class="No-Break"><span class="koboSpan" id="kobo.1836.1">another function.</span></span></p>
<p><span class="koboSpan" id="kobo.1837.1">Go’s functions are values, which means you can pass them as an input argument and even return them as the output from </span><span class="No-Break"><span class="koboSpan" id="kobo.1838.1">another function.</span></span></p>
<p><span class="koboSpan" id="kobo.1839.1">To illustrate </span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.1840.1">this, we define a new function named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1841.1">processDevice</span></strong><span class="koboSpan" id="kobo.1842.1">, which takes two parameters, a function with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1843.1">func (string, string) string</span></strong><span class="koboSpan" id="kobo.1844.1"> signature, and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1845.1">string</span></strong><span class="koboSpan" id="kobo.1846.1">. </span><span class="koboSpan" id="kobo.1846.2">In the body of this function, two relevant strings are in play: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1847.1">base</span></strong><span class="koboSpan" id="kobo.1848.1">, which is statically set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1849.1">device</span></strong><span class="koboSpan" id="kobo.1850.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1851.1">ip</span></strong><span class="koboSpan" id="kobo.1852.1">, which is the string the function receives as the </span><span class="No-Break"><span class="koboSpan" id="kobo.1853.1">second argument:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1854.1">func</span></span><span class="koboSpan" id="kobo.1855.1"> processDevice(getName </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1856.1">func</span></span><span class="koboSpan" id="kobo.1857.1"> (</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1858.1">string</span></span><span class="koboSpan" id="kobo.1859.1">, </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1860.1">string</span></span><span class="koboSpan" id="kobo.1861.1">) </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1862.1">string</span></span><span class="koboSpan" id="kobo.1863.1">, ip </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1864.1">string</span></span><span class="koboSpan" id="kobo.1865.1">) {
    base :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1866.1">= "device"</span></span><span class="koboSpan" id="kobo.1867.1">
    name :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1868.1">=</span></span><span class="koboSpan" id="kobo.1869.1"> getName(base, ip)
    fmt.Println(name)
}</span></pre>
<p><span class="koboSpan" id="kobo.1870.1">The most interesting part of this function is on the second line of its body, where it calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1871.1">getName</span></strong><span class="koboSpan" id="kobo.1872.1"> function. </span><span class="koboSpan" id="kobo.1872.2">This function is what </span><strong class="source-inline"><span class="koboSpan" id="kobo.1873.1">processDevice</span></strong><span class="koboSpan" id="kobo.1874.1"> received as an argument, which could be any function as long as it takes two strings as arguments and returns just one string. </span><span class="koboSpan" id="kobo.1874.2">That’s the case with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1875.1">generateName</span></strong><span class="koboSpan" id="kobo.1876.1"> function we defined for an earlier example, which means we can pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.1877.1">generateName</span></strong><span class="koboSpan" id="kobo.1878.1"> as an argument to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1879.1">processDevice</span></strong><span class="koboSpan" id="kobo.1880.1"> to build a unique device name. </span><span class="koboSpan" id="kobo.1880.2">Let’s see what this would look like. </span><span class="koboSpan" id="kobo.1880.3">The code of this example is available at </span><strong class="source-inline"><span class="koboSpan" id="kobo.1881.1">ch03/functions1/main.go</span></strong><span class="koboSpan" id="kobo.1882.1"> (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1883.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1884.1">):</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1885.1">func</span></span><span class="koboSpan" id="kobo.1886.1"> main() {
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1887.1">    // prints "device-192.0.2.1"</span></span><span class="koboSpan" id="kobo.1888.1">
    processDevice(generateName, </span><span class="Code_Red"><span class="koboSpan" id="kobo.1889.1">"192.0.2.1"</span></span><span class="koboSpan" id="kobo.1890.1">)
}</span></pre>
<p><span class="koboSpan" id="kobo.1891.1">The benefit of this approach is the pluggable nature of the first argument. </span><span class="koboSpan" id="kobo.1891.2">If we decide at any point that another function (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1892.1">generateName2</span></strong><span class="koboSpan" id="kobo.1893.1">) is a better fit because it uses a different format to join the strings or something else, or maybe you want to make a change to create the device names differently but don’t want to alter the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1894.1">generateName</span></strong><span class="koboSpan" id="kobo.1895.1"> function in </span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.1896.1">case you need to roll back your changes quickly, then you can use a temporary </span><strong class="source-inline"><span class="koboSpan" id="kobo.1897.1">clone</span></strong><span class="koboSpan" id="kobo.1898.1"> function with a different name where you make </span><span class="No-Break"><span class="koboSpan" id="kobo.1899.1">the adjustments.</span></span></p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.1900.1">Function arguments</span></h2>
<p><span class="koboSpan" id="kobo.1901.1">In Go, we pass</span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.1902.1"> the function arguments by value, meaning that Go creates a copy of every input variable and passes that copy to the called function. </span><span class="koboSpan" id="kobo.1902.2">Go saves the new function-scoped variables in the stack memory, as long as the compiler knows their lifetime and memory footprint at compile time. </span><span class="koboSpan" id="kobo.1902.3">The stack is a very efficient region in memory designed to store variables that don’t need to be garbage collected, as it allocates or de-allocates memory automatically when the function returns. </span><span class="koboSpan" id="kobo.1902.4">Memory that needs to be garbage collected goes to another location in memory known as </span><span class="No-Break"><span class="koboSpan" id="kobo.1903.1">the heap.</span></span></p>
<p><span class="koboSpan" id="kobo.1904.1">Consider the following example of a function attempting to mutate an input string. </span><span class="koboSpan" id="kobo.1904.2">You can access the code for the next example at </span><strong class="source-inline"><span class="koboSpan" id="kobo.1905.1">ch03/functions2/main.go</span></strong><span class="koboSpan" id="kobo.1906.1"> (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1907.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1908.1">):</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1909.1">type</span></span><span class="koboSpan" id="kobo.1910.1"> Device </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1911.1">struct </span></span><span class="koboSpan" id="kobo.1912.1">{
    name </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1913.1">string</span></span><span class="koboSpan" id="kobo.1914.1">
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1915.1">func</span></span><span class="koboSpan" id="kobo.1916.1"> mutate(input Device) {
    input.name </span><span class="Code_Red"><span class="koboSpan" id="kobo.1917.1">+= "-suffix"</span></span><span class="koboSpan" id="kobo.1918.1">
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1919.1">func</span></span><span class="koboSpan" id="kobo.1920.1"> main() {
    d :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1921.1">=</span></span><span class="koboSpan" id="kobo.1922.1"> Device{name: </span><span class="Code_Red"><span class="koboSpan" id="kobo.1923.1">"myname"</span></span><span class="koboSpan" id="kobo.1924.1">}
    mutate(d)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1925.1">// prints "myname"</span></span><span class="koboSpan" id="kobo.1926.1">
    fmt.Println(d.name)
}</span></pre>
<p><span class="koboSpan" id="kobo.1927.1">Since Go </span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.1928.1">creates a copy of the input </span><strong class="source-inline"><span class="koboSpan" id="kobo.1929.1">Device</span></strong><span class="koboSpan" id="kobo.1930.1"> when passing it as a value to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1931.1">mutate</span></strong><span class="koboSpan" id="kobo.1932.1"> function, any changes that happen to that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1933.1">Device</span></strong><span class="koboSpan" id="kobo.1934.1"> inside the body of this function are not visible outside of it, hence it doesn’t affect the original variable, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1935.1">d</span></strong><span class="koboSpan" id="kobo.1936.1">. </span><span class="koboSpan" id="kobo.1936.2">That is why </span><strong class="source-inline"><span class="koboSpan" id="kobo.1937.1">d.name</span></strong><span class="koboSpan" id="kobo.1938.1"> prints </span><strong class="source-inline"><span class="koboSpan" id="kobo.1939.1">myname</span></strong><span class="koboSpan" id="kobo.1940.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.1941.1">not </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1942.1">myname-suffix</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1943.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1944.1">In Go, we have two types of data we can work with: values and the memory addresses of those values (pointers). </span><span class="koboSpan" id="kobo.1944.2">With this in mind, there are two ways to implement the desired (mutating) behavior when passing values to </span><span class="No-Break"><span class="koboSpan" id="kobo.1945.1">a function:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1946.1">Change the function to return the mutated value and assign it to a variable. </span><span class="koboSpan" id="kobo.1946.2">Still, this does not really mutate the original value but actually generates a new </span><span class="No-Break"><span class="koboSpan" id="kobo.1947.1">one instead.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1948.1">Change the function to accept a pointer to a variable that stores a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1949.1">Device</span></strong><span class="koboSpan" id="kobo.1950.1">. </span><span class="koboSpan" id="kobo.1950.2">This is what our program would look like in </span><span class="No-Break"><span class="koboSpan" id="kobo.1951.1">this case:</span></span></p>
<pre class="console"><span class="Code_Purple"><span class="koboSpan" id="kobo.1952.1">type</span></span><span class="koboSpan" id="kobo.1953.1"> Device </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1954.1">struct</span></span><span class="koboSpan" id="kobo.1955.1"> {
    name </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1956.1">string</span></span><span class="koboSpan" id="kobo.1957.1">
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1958.1">func</span></span><span class="koboSpan" id="kobo.1959.1"> mutate(input </span><span class="Code_Red"><span class="koboSpan" id="kobo.1960.1">*</span></span><span class="koboSpan" id="kobo.1961.1">Device) {
    input.name </span><span class="Code_Red"><span class="koboSpan" id="kobo.1962.1">+= "-suffix"</span></span><span class="koboSpan" id="kobo.1963.1">
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1964.1">func</span></span><span class="koboSpan" id="kobo.1965.1"> main() {
    d :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1966.1">=</span></span><span class="koboSpan" id="kobo.1967.1"> Device{name: </span><span class="Code_Red"><span class="koboSpan" id="kobo.1968.1">"myname"</span></span><span class="koboSpan" id="kobo.1969.1">}
    mutate(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1970.1">&amp;</span></span><span class="koboSpan" id="kobo.1971.1">d)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1972.1">// prints "myname-suffix"</span></span><span class="koboSpan" id="kobo.1973.1">
    fmt.Println(d.name)
}</span></pre>
<p><span class="koboSpan" id="kobo.1974.1">Pointers are </span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.1975.1">a common way of sharing data across program boundaries in Go, such as function calls. </span><span class="koboSpan" id="kobo.1975.2">In this case, we still pass the input argument by value (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1976.1">&amp;d</span></strong><span class="koboSpan" id="kobo.1977.1">), but this time, the value we copy and pass is a pointer to a memory address, instead of the actual content of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1978.1">d</span></strong><span class="koboSpan" id="kobo.1979.1"> variable. </span><span class="koboSpan" id="kobo.1979.2">Now, when you change what that memory address is pointing to, you are mutating the value of the original </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1980.1">d</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1981.1"> variable:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer039">
<span class="koboSpan" id="kobo.1982.1"><img alt="Figure 3.8 – Values and pointers" src="image/Figure_3.8.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1983.1">Figure 3.8 – Values and pointers</span></p>
<p><span class="koboSpan" id="kobo.1984.1">Go pointers are a powerful idea. </span><span class="koboSpan" id="kobo.1984.2">The key operations you need to be aware of are </span><span class="No-Break"><span class="koboSpan" id="kobo.1985.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1986.1">Taking an address of a variable using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1987.1">&amp;</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1988.1">operator</span></span></li>
<li><span class="koboSpan" id="kobo.1989.1">Dereferencing a pointer, that is, getting the address of the referenced value using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1990.1">*</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1991.1">operator</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1992.1">Whenever</span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.1993.1"> you need to change the value of a variable, or when a variable is big enough to make copying it inefficient, you need to make sure that you pass it by a pointer. </span><span class="koboSpan" id="kobo.1993.2">This rule applies to all the primitive types — </span><strong class="source-inline"><span class="koboSpan" id="kobo.1994.1">integer</span></strong><span class="koboSpan" id="kobo.1995.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1996.1">string</span></strong><span class="koboSpan" id="kobo.1997.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1998.1">boolean</span></strong><span class="koboSpan" id="kobo.1999.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.2000.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.2001.1">A couple of types in Go do not hold the actual value but point to its memory address instead. </span><span class="koboSpan" id="kobo.2001.2">While these are internal implementation details, it’s something worth keeping in mind. </span><span class="koboSpan" id="kobo.2001.3">For example, channels and maps are two types that are actually pointers to internal data structures (runtime types). </span><span class="koboSpan" id="kobo.2001.4">This means that even if you pass them around by value, you end up mutating the contents of the channel or map. </span><span class="koboSpan" id="kobo.2001.5">The same, by the way, applies </span><span class="No-Break"><span class="koboSpan" id="kobo.2002.1">to functions.</span></span></p>
<p><span class="koboSpan" id="kobo.2003.1">See the following example where we pass a map (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2004.1">m</span></strong><span class="koboSpan" id="kobo.2005.1">) by value to a function (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2006.1">fn</span></strong><span class="koboSpan" id="kobo.2007.1">). </span><span class="koboSpan" id="kobo.2007.2">This function adds a new key-value pair to the map, a value that the outer function (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2008.1">main</span></strong><span class="koboSpan" id="kobo.2009.1">) can access </span><span class="No-Break"><span class="koboSpan" id="kobo.2010.1">as well:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.2011.1">func</span></span><span class="koboSpan" id="kobo.2012.1"> fn(m </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2013.1">map</span></span><span class="koboSpan" id="kobo.2014.1">[</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2015.1">int</span></span><span class="koboSpan" id="kobo.2016.1">]</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2017.1">int</span></span><span class="koboSpan" id="kobo.2018.1">) {
    m[</span><span class="Code_Green"><span class="koboSpan" id="kobo.2019.1">1</span></span><span class="koboSpan" id="kobo.2020.1">] </span><span class="Code_Red"><span class="koboSpan" id="kobo.2021.1">=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.2022.1">11</span></span><span class="koboSpan" id="kobo.2023.1">
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2024.1">func</span></span><span class="koboSpan" id="kobo.2025.1"> main() {
    m := </span><span class="Code_Blue"><span class="koboSpan" id="kobo.2026.1">make</span></span><span class="koboSpan" id="kobo.2027.1">(</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2028.1">map</span></span><span class="koboSpan" id="kobo.2029.1">[</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2030.1">int</span></span><span class="koboSpan" id="kobo.2031.1">]</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2032.1">int</span></span><span class="koboSpan" id="kobo.2033.1">)
    fn(m)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.2034.1">// prints 11</span></span><span class="koboSpan" id="kobo.2035.1">
    fmt.Println(m[</span><span class="Code_Green"><span class="koboSpan" id="kobo.2036.1">1</span></span><span class="koboSpan" id="kobo.2037.1">])
}</span></pre>
<p><span class="koboSpan" id="kobo.2038.1">In the </span><em class="italic"><span class="koboSpan" id="kobo.2039.1">Go’s type system</span></em><span class="koboSpan" id="kobo.2040.1"> section in this chapter, we learned that a slice is a type in Go that stores metadata about the underlying data along with a pointer to it. </span><span class="koboSpan" id="kobo.2040.2">It may be tempting to assume that you can pass around this data type as a value and be able to mutate it. </span><span class="koboSpan" id="kobo.2040.3">But, while this data structure has a pointer in it, you also create a copy of the rest of the metadata values (length and capacity), creating a disconnection between the slice in the called and </span><span class="No-Break"><span class="koboSpan" id="kobo.2041.1">calling functions.</span></span></p>
<p><span class="koboSpan" id="kobo.2042.1">For this reason, mutations </span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.2043.1">in slices may have an unpredictable result. </span><span class="koboSpan" id="kobo.2043.2">In-place changes may be visible but appends may not. </span><span class="koboSpan" id="kobo.2043.3">This is why they always recommend passing them as pointers to avoid subtle bugs such as the </span><span class="No-Break"><span class="koboSpan" id="kobo.2044.1">following one:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.2045.1">func</span></span> <strong class="bold"><span class="koboSpan" id="kobo.2046.1">mutateV</span></strong><span class="koboSpan" id="kobo.2047.1">(input []</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2048.1">string</span></span><span class="koboSpan" id="kobo.2049.1">) {
    input [</span><span class="Code_Green"><span class="koboSpan" id="kobo.2050.1">0</span></span><span class="koboSpan" id="kobo.2051.1">] </span><span class="Code_Red"><span class="koboSpan" id="kobo.2052.1">= "r03"</span></span><span class="koboSpan" id="kobo.2053.1">
    input  </span><span class="Code_Red"><span class="koboSpan" id="kobo.2054.1">=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.2055.1">append</span></span><span class="koboSpan" id="kobo.2056.1">(input , </span><span class="Code_Red"><span class="koboSpan" id="kobo.2057.1">"r04"</span></span><span class="koboSpan" id="kobo.2058.1">)
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2059.1">func</span></span> <strong class="bold"><span class="koboSpan" id="kobo.2060.1">main</span></strong><span class="koboSpan" id="kobo.2061.1">() {
    d1 :</span><span class="Code_Red"><span class="koboSpan" id="kobo.2062.1">=</span></span><span class="koboSpan" id="kobo.2063.1"> []</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2064.1">string</span></span><span class="koboSpan" id="kobo.2065.1">{</span><span class="Code_Red"><span class="koboSpan" id="kobo.2066.1">"r01"</span></span><span class="koboSpan" id="kobo.2067.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.2068.1">"r02"</span></span><span class="koboSpan" id="kobo.2069.1">}
    mutateV(d1)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.2070.1">// prints "[r03 r02]"</span></span><span class="koboSpan" id="kobo.2071.1">
    fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.2072.1">"%v\n"</span></span><span class="koboSpan" id="kobo.2073.1">, d1)
}</span></pre>
<p><span class="koboSpan" id="kobo.2074.1">You can avoid this bug if you use a pointer instead, in which case, all changes to the underlying slice are reflected in the </span><span class="No-Break"><span class="koboSpan" id="kobo.2075.1">outer context:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.2076.1">func</span></span> <strong class="bold"><span class="koboSpan" id="kobo.2077.1">mutateP</span></strong><strong class="bold"><span class="koboSpan" id="kobo.2078.1">(</span></strong><span class="koboSpan" id="kobo.2079.1">input *[]</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2080.1">string</span></span><span class="koboSpan" id="kobo.2081.1">) {
    (*input)[</span><span class="Code_Green"><span class="koboSpan" id="kobo.2082.1">0</span></span><span class="koboSpan" id="kobo.2083.1">] </span><span class="Code_Red"><span class="koboSpan" id="kobo.2084.1">= "r03"</span></span><span class="koboSpan" id="kobo.2085.1">
    *input </span><span class="Code_Red"><span class="koboSpan" id="kobo.2086.1">=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.2087.1">append</span></span><span class="koboSpan" id="kobo.2088.1">(*input, </span><span class="Code_Red"><span class="koboSpan" id="kobo.2089.1">"r04"</span></span><span class="koboSpan" id="kobo.2090.1">)
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2091.1">func</span></span> <strong class="bold"><span class="koboSpan" id="kobo.2092.1">main</span></strong><span class="koboSpan" id="kobo.2093.1">() {
    d2 :</span><span class="Code_Red"><span class="koboSpan" id="kobo.2094.1">=</span></span><span class="koboSpan" id="kobo.2095.1"> []</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2096.1">string</span></span><span class="koboSpan" id="kobo.2097.1">{</span><span class="Code_Red"><span class="koboSpan" id="kobo.2098.1">"r01"</span></span><span class="koboSpan" id="kobo.2099.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.2100.1">"r02"</span></span><span class="koboSpan" id="kobo.2101.1">}
    mutateP(&amp;d2)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.2102.1">// prints "[r03 r02 r04]"</span></span><span class="koboSpan" id="kobo.2103.1">
    fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.2104.1">"%v\n"</span></span><span class="koboSpan" id="kobo.2105.1">, d2)
}</span></pre>
<p><span class="koboSpan" id="kobo.2106.1">The full code for </span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.2107.1">both of these examples is at </span><strong class="source-inline"><span class="koboSpan" id="kobo.2108.1">ch03/mutate-slice/main.go</span></strong><span class="koboSpan" id="kobo.2109.1"> (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.2110.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.2111.1">).</span></span></p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.2112.1">Error handling</span></h2>
<p><span class="koboSpan" id="kobo.2113.1">In Go, errors</span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.2114.1"> are not exceptions that you have to handle somewhere</span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.2115.1"> else in the code. </span><span class="koboSpan" id="kobo.2115.2">We handle them as they come along. </span><span class="koboSpan" id="kobo.2115.3">An error might require you to immediately stop the execution of a program, or maybe you could continue to run the program and propagate the error to another part of the program or the user so they can make an informed decision about what to do with this error. </span><span class="koboSpan" id="kobo.2115.4">Remember, </span><em class="italic"><span class="koboSpan" id="kobo.2116.1">don’t just check errors, handle </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.2117.1">them gracefully</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.2118.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.2119.1">When it comes to writing functions, the rule of thumb is that if a function is likely to run into an error, it must return it to </span><span class="No-Break"><span class="koboSpan" id="kobo.2120.1">the caller:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.2121.1">func</span></span> <strong class="bold"><span class="koboSpan" id="kobo.2122.1">makeCall</span></strong><span class="koboSpan" id="kobo.2123.1">(url </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2124.1">string</span></span><span class="koboSpan" id="kobo.2125.1">) (</span><span class="Code_Red"><span class="koboSpan" id="kobo.2126.1">*</span></span><span class="koboSpan" id="kobo.2127.1">http.Response, </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2128.1">error</span></span><span class="koboSpan" id="kobo.2129.1">) {
    resp, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.2130.1">=</span></span><span class="koboSpan" id="kobo.2131.1"> http.Get(</span><span class="Code_Red"><span class="koboSpan" id="kobo.2132.1">"example.com"</span></span><span class="koboSpan" id="kobo.2133.1">)
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2134.1">if</span></span><span class="koboSpan" id="kobo.2135.1"> err </span><span class="Code_Red"><span class="koboSpan" id="kobo.2136.1">!=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.2137.1">nil</span></span><span class="koboSpan" id="kobo.2138.1"> {
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2139.1">return</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.2140.1">nil</span></span><span class="koboSpan" id="kobo.2141.1">, fmt.Errorf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.2142.1">"error in makeCall: %w"</span></span><span class="koboSpan" id="kobo.2143.1">,
                                err)
    }
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2144.1">return</span></span><span class="koboSpan" id="kobo.2145.1"> resp, </span><span class="Code_Blue"><span class="koboSpan" id="kobo.2146.1">nil</span></span><span class="koboSpan" id="kobo.2147.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.2148.1">The error message should be meaningful and offer enough context to the user to be able to identify the</span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.2149.1"> cause of the error and the place in the code where it happened. </span><span class="koboSpan" id="kobo.2149.2">It’s up to the caller of this function to decide what to do with this error</span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.2150.1"> from the following </span><span class="No-Break"><span class="koboSpan" id="kobo.2151.1">possible actions:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.2152.1">Log it </span><span class="No-Break"><span class="koboSpan" id="kobo.2153.1">and continue.</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.2154.1">Ignore it.</span></span></li>
<li><span class="koboSpan" id="kobo.2155.1">Interrupt execution </span><span class="No-Break"><span class="koboSpan" id="kobo.2156.1">and panic.</span></span></li>
<li><span class="koboSpan" id="kobo.2157.1">Pass it up to the </span><span class="No-Break"><span class="koboSpan" id="kobo.2158.1">outer function.</span></span></li>
</ul>
<h2 id="_idParaDest-86"><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.2159.1">Methods</span></h2>
<p><span class="koboSpan" id="kobo.2160.1">Methods </span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.2161.1">are a</span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.2162.1"> way of adding behavior to user-defined types, which, by default, can only store values. </span><span class="koboSpan" id="kobo.2162.2">If you want those types to act, you can add a special function that would contain the name of the associated data type (method receiver) between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2163.1">func</span></strong><span class="koboSpan" id="kobo.2164.1"> keyword and the function name, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.2165.1">GetFullName</span></strong><span class="koboSpan" id="kobo.2166.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.2167.1">next example:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.2168.1">type</span></span><span class="koboSpan" id="kobo.2169.1"> Device </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2170.1">struct</span></span><span class="koboSpan" id="kobo.2171.1"> {
    name </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2172.1">string</span></span><span class="koboSpan" id="kobo.2173.1">
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2174.1">func</span></span><span class="koboSpan" id="kobo.2175.1"> (d Device) </span><strong class="bold"><span class="koboSpan" id="kobo.2176.1">GetFullName</span></strong><span class="koboSpan" id="kobo.2177.1">() </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2178.1">string</span></span><span class="koboSpan" id="kobo.2179.1"> {
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2180.1">return</span></span><span class="koboSpan" id="kobo.2181.1"> d.name
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2182.1">func</span></span> <strong class="bold"><span class="koboSpan" id="kobo.2183.1">main</span></strong><span class="koboSpan" id="kobo.2184.1">() {
    d1 :</span><span class="Code_Red"><span class="koboSpan" id="kobo.2185.1">=</span></span><span class="koboSpan" id="kobo.2186.1"> Device{name: </span><span class="Code_Red"><span class="koboSpan" id="kobo.2187.1">"r1"</span></span><span class="koboSpan" id="kobo.2188.1">}
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.2189.1">// prints "r1"</span></span><span class="koboSpan" id="kobo.2190.1">
    fmt.Println(d1.GetFullName())
}</span></pre>
<p><span class="koboSpan" id="kobo.2191.1">In all aspects, methods</span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.2192.1"> are just like functions — they accept zero or more arguments and return zero or more values. </span><span class="koboSpan" id="kobo.2192.2">The biggest difference is that methods also have access to their receiver and can at the very least read its fields, as you’ve seen in the </span><span class="No-Break"><span class="koboSpan" id="kobo.2193.1">preceding example.</span></span></p>
<p><span class="koboSpan" id="kobo.2194.1">It’s also possible to</span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.2195.1"> create a method that mutates the receiving type by defining it on </span><span class="No-Break"><span class="koboSpan" id="kobo.2196.1">a pointer:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.2197.1">type</span></span><span class="koboSpan" id="kobo.2198.1"> Device </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2199.1">struct</span></span><span class="koboSpan" id="kobo.2200.1"> {
    name </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2201.1">string</span></span><span class="koboSpan" id="kobo.2202.1">
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2203.1">func</span></span><span class="koboSpan" id="kobo.2204.1"> (d </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2205.1">*</span></span><span class="koboSpan" id="kobo.2206.1">Device) GenerateName() {
    d.name </span><span class="Code_Red"><span class="koboSpan" id="kobo.2207.1">= "device-" +</span></span><span class="koboSpan" id="kobo.2208.1"> d.name
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2209.1">func</span></span><span class="koboSpan" id="kobo.2210.1"> (d Device) GetFullName() </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2211.1">string</span></span><span class="koboSpan" id="kobo.2212.1"> {
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2213.1">return</span></span><span class="koboSpan" id="kobo.2214.1"> d.name
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2215.1">func</span></span> <strong class="bold"><span class="koboSpan" id="kobo.2216.1">main</span></strong><span class="koboSpan" id="kobo.2217.1">() {
    d2 :</span><span class="Code_Red"><span class="koboSpan" id="kobo.2218.1">=</span></span><span class="koboSpan" id="kobo.2219.1"> Device{name: </span><span class="Code_Red"><span class="koboSpan" id="kobo.2220.1">"r2"</span></span><span class="koboSpan" id="kobo.2221.1">}
    d2.GenerateName()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.2222.1">// prints "device-r2"</span></span><span class="koboSpan" id="kobo.2223.1">
    fmt.Println(d2.GetFullName())
}</span></pre>
<p><span class="koboSpan" id="kobo.2224.1">In this case, we</span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.2225.1"> define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2226.1">GenerateName</span></strong><span class="koboSpan" id="kobo.2227.1"> method on a pointer</span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.2228.1"> receiver and, thus, can safely set, delete or change its values — all these changes are visible in the </span><span class="No-Break"><span class="koboSpan" id="kobo.2229.1">outer scope.</span></span></p>
<p><span class="koboSpan" id="kobo.2230.1">The full code for the method code examples is available at </span><strong class="source-inline"><span class="koboSpan" id="kobo.2231.1">ch03/methods/main.go</span></strong><span class="koboSpan" id="kobo.2232.1"> (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.2233.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.2234.1">).</span></span></p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.2235.1">Variadic functions</span></h2>
<p><span class="koboSpan" id="kobo.2236.1">So far, we’ve </span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.2237.1">only seen examples with functions that take a strictly pre-defined number of arguments. </span><span class="koboSpan" id="kobo.2237.2">But, that’s not the only option in Go; you can actually </span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.2238.1">pass an arbitrary number of arguments to a function as long as you meet the </span><span class="No-Break"><span class="koboSpan" id="kobo.2239.1">following conditions:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.2240.1">All extra arguments are of the </span><span class="No-Break"><span class="koboSpan" id="kobo.2241.1">same type.</span></span></li>
<li><span class="koboSpan" id="kobo.2242.1">They are always the last arguments to </span><span class="No-Break"><span class="koboSpan" id="kobo.2243.1">a function.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.2244.1">The function signature looks slightly different. </span><span class="koboSpan" id="kobo.2244.2">All extra arguments are automatically grouped into a slice and you denote them with three dots (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2245.1">...</span></strong><span class="koboSpan" id="kobo.2246.1">) before </span><span class="No-Break"><span class="koboSpan" id="kobo.2247.1">their type:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.2248.1">func</span></span><span class="koboSpan" id="kobo.2249.1"> printOctets(octets ...</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2250.1">string</span></span><span class="koboSpan" id="kobo.2251.1">) {
    fmt.Println(strings.Join(octets, </span><span class="Code_Red"><span class="koboSpan" id="kobo.2252.1">"."</span></span><span class="koboSpan" id="kobo.2253.1">))
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2254.1">func</span></span> <strong class="bold"><span class="koboSpan" id="kobo.2255.1">main</span></strong><span class="koboSpan" id="kobo.2256.1">() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.2257.1">// prints "127.1"</span></span><span class="koboSpan" id="kobo.2258.1">
    printOctets(</span><span class="Code_Red"><span class="koboSpan" id="kobo.2259.1">"127"</span></span><span class="koboSpan" id="kobo.2260.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.2261.1">"1"</span></span><span class="koboSpan" id="kobo.2262.1">)
    ip :</span><span class="Code_Red"><span class="koboSpan" id="kobo.2263.1">=</span></span><span class="koboSpan" id="kobo.2264.1"> []</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2265.1">string</span></span><span class="koboSpan" id="kobo.2266.1">{</span><span class="Code_Red"><span class="koboSpan" id="kobo.2267.1">"192"</span></span><span class="koboSpan" id="kobo.2268.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.2269.1">"0"</span></span><span class="koboSpan" id="kobo.2270.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.2271.1">"2"</span></span><span class="koboSpan" id="kobo.2272.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.2273.1">"1"</span></span><span class="koboSpan" id="kobo.2274.1">}
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.2275.1">// prints "192.0.2.1"</span></span><span class="koboSpan" id="kobo.2276.1">
    printOctets(ip...)
}</span></pre>
<p><span class="koboSpan" id="kobo.2277.1">One benefit of variadic arguments, compared to declaring them as a slice argument instead, is the</span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.2278.1"> flexibility; you don’t have to create a slice before calling a function, and you can completely omit any trailing arguments if they are not </span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.2279.1">needed and still satisfy the </span><span class="No-Break"><span class="koboSpan" id="kobo.2280.1">function’s signature.</span></span></p>
<p><span class="koboSpan" id="kobo.2281.1">The full code for</span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.2282.1"> the variadic code example is available at </span><strong class="source-inline"><span class="koboSpan" id="kobo.2283.1">ch03/variadic/main.go</span></strong><span class="koboSpan" id="kobo.2284.1"> (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.2285.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.2286.1">).</span></span></p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.2287.1">Closures</span></h2>
<p><span class="koboSpan" id="kobo.2288.1">Functions in </span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.2289.1">Go have different properties. </span><span class="koboSpan" id="kobo.2289.2">They are values, so a function </span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.2290.1">can accept another one as </span><span class="No-Break"><span class="koboSpan" id="kobo.2291.1">its argument.</span></span></p>
<p><span class="koboSpan" id="kobo.2292.1">Another interesting property is that when one function (outer) returns another function (inner), the inner function remembers and it has complete access to all variables that you defined in the scope of the </span><span class="No-Break"><span class="koboSpan" id="kobo.2293.1">outer function.</span></span></p>
<p><span class="koboSpan" id="kobo.2294.1">This is what’s called</span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.2295.1"> a </span><strong class="bold"><span class="koboSpan" id="kobo.2296.1">function closure</span></strong><span class="koboSpan" id="kobo.2297.1">, and here’s a canonical example of how you can use it to generate a sequence of numbers. </span><span class="koboSpan" id="kobo.2297.2">Here, the inner anonymous function with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2298.1">func() string</span></strong><span class="koboSpan" id="kobo.2299.1"> signature mutates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2300.1">i</span></strong><span class="koboSpan" id="kobo.2301.1"> variable defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2302.1">suffixGenerator</span></strong><span class="koboSpan" id="kobo.2303.1"> outer function every time </span><span class="No-Break"><span class="koboSpan" id="kobo.2304.1">it’s called:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.2305.1">func</span></span><span class="koboSpan" id="kobo.2306.1"> suffixGenerator() </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2307.1">func</span></span><span class="koboSpan" id="kobo.2308.1">() </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2309.1">string</span></span><span class="koboSpan" id="kobo.2310.1"> {
    i :</span><span class="Code_Red"><span class="koboSpan" id="kobo.2311.1">=</span></span><span class="koboSpan" id="kobo.2312.1"> 0
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2313.1">return func</span></span><span class="koboSpan" id="kobo.2314.1">() </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2315.1">string</span></span><span class="koboSpan" id="kobo.2316.1"> {
        i++
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2317.1">return</span></span><span class="koboSpan" id="kobo.2318.1"> fmt.Sprintf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.2319.1">"%02d"</span></span><span class="koboSpan" id="kobo.2320.1">, i)
    }
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2321.1">func</span></span> <strong class="bold"><span class="koboSpan" id="kobo.2322.1">main</span></strong><span class="koboSpan" id="kobo.2323.1">() {
    generator1 :</span><span class="Code_Red"><span class="koboSpan" id="kobo.2324.1">=</span></span><span class="koboSpan" id="kobo.2325.1"> suffixGenerator()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.2326.1">// prints "device-01"</span></span><span class="koboSpan" id="kobo.2327.1">
    fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.2328.1">"%s-%s\n"</span></span><span class="koboSpan" id="kobo.2329.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.2330.1">"device"</span></span><span class="koboSpan" id="kobo.2331.1">, generator1())
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.2332.1">// prints "device-02"</span></span><span class="koboSpan" id="kobo.2333.1">
    fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.2334.1">"%s-%s\n"</span></span><span class="koboSpan" id="kobo.2335.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.2336.1">"device"</span></span><span class="koboSpan" id="kobo.2337.1">, generator1())
    generator2 :</span><span class="Code_Red"><span class="koboSpan" id="kobo.2338.1">=</span></span><span class="koboSpan" id="kobo.2339.1"> suffixGenerator()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.2340.1">// prints "device-01"</span></span><span class="koboSpan" id="kobo.2341.1">
    fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.2342.1">"%s-%s\n"</span></span><span class="koboSpan" id="kobo.2343.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.2344.1">"device"</span></span><span class="koboSpan" id="kobo.2345.1">, generator2())
}</span></pre>
<p><span class="koboSpan" id="kobo.2346.1">Every </span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.2347.1">time we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.2348.1">suffixGenerator</span></strong><span class="koboSpan" id="kobo.2349.1">, we assign a new instance of the anonymous function it returns to a variable. </span><strong class="source-inline"><span class="koboSpan" id="kobo.2350.1">generator1</span></strong><span class="koboSpan" id="kobo.2351.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2352.1">generator2</span></strong><span class="koboSpan" id="kobo.2353.1"> are now functions that keep track of the number of times we call </span><span class="No-Break"><span class="koboSpan" id="kobo.2354.1">each one.</span></span></p>
<p><span class="koboSpan" id="kobo.2355.1">Closures</span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.2356.1"> are a popular technique to create a surrounding context (environment). </span><span class="koboSpan" id="kobo.2356.2">For example, API call functions in middleware software use closures to perform logging and telemetry data collection on every call, without the API caller needing to care about </span><span class="No-Break"><span class="koboSpan" id="kobo.2357.1">those details.</span></span></p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.2358.1">Defer</span></h2>
<p><span class="koboSpan" id="kobo.2359.1">When </span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.2360.1">writing a</span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.2361.1"> program that opens remote network connections or local files, it’s important to promptly close these as soon as you no longer need them to prevent resource leaks — all operating systems have limitations on the number of open files </span><span class="No-Break"><span class="koboSpan" id="kobo.2362.1">or connections.</span></span></p>
<p><span class="koboSpan" id="kobo.2363.1">Go’s idiomatic way of dealing with this class of problems is to address them as early in the code as possible with the help of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2364.1">defer</span></strong><span class="koboSpan" id="kobo.2365.1"> statement. </span><span class="koboSpan" id="kobo.2365.2">You should place this statement right next to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2366.1">open</span></strong><span class="koboSpan" id="kobo.2367.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.2368.1">connect</span></strong><span class="koboSpan" id="kobo.2369.1"> function call. </span><span class="koboSpan" id="kobo.2369.2">Go only evaluates this statement when the </span><span class="No-Break"><span class="koboSpan" id="kobo.2370.1">function returns.</span></span></p>
<p><span class="koboSpan" id="kobo.2371.1">In the following example, the two </span><strong class="source-inline"><span class="koboSpan" id="kobo.2372.1">defer</span></strong><span class="koboSpan" id="kobo.2373.1"> statements run only </span><em class="italic"><span class="koboSpan" id="kobo.2374.1">after</span></em><span class="koboSpan" id="kobo.2375.1"> the final statement of </span><span class="No-Break"><span class="koboSpan" id="kobo.2376.1">the function:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.2377.1">func</span></span> <strong class="bold"><span class="koboSpan" id="kobo.2378.1">main</span></strong><span class="koboSpan" id="kobo.2379.1">() {
    resp, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.2380.1">=</span></span><span class="koboSpan" id="kobo.2381.1"> http.Get(</span><span class="Code_Red"><span class="koboSpan" id="kobo.2382.1">"http://example.com"</span></span><span class="koboSpan" id="kobo.2383.1">)
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2384.1">if</span></span><span class="koboSpan" id="kobo.2385.1"> err </span><span class="Code_Red"><span class="koboSpan" id="kobo.2386.1">!=</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.2387.1">nil</span></span><span class="koboSpan" id="kobo.2388.1"> {
        </span><span class="Code_Blue"><span class="koboSpan" id="kobo.2389.1">panic</span></span><span class="koboSpan" id="kobo.2390.1">(err)
    }
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2391.1">defer</span></span><span class="koboSpan" id="kobo.2392.1"> resp.Body.Close()
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2393.1">defer</span></span><span class="koboSpan" id="kobo.2394.1"> fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.2395.1">"Deferred cleanup"</span></span><span class="koboSpan" id="kobo.2396.1">)
    fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.2397.1">"Response status:"</span></span><span class="koboSpan" id="kobo.2398.1">, resp.Status)
}</span></pre>
<p><span class="koboSpan" id="kobo.2399.1">You can stack </span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.2400.1">together </span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.2401.1">many </span><strong class="source-inline"><span class="koboSpan" id="kobo.2402.1">defer</span></strong><span class="koboSpan" id="kobo.2403.1"> statements to perform staged cleanup. </span><span class="koboSpan" id="kobo.2403.2">They execute in last-in-first-out order – </span><strong class="source-inline"><span class="koboSpan" id="kobo.2404.1">Println("Deferred cleanup")</span></strong><span class="koboSpan" id="kobo.2405.1"> runs before </span><strong class="source-inline"><span class="koboSpan" id="kobo.2406.1">resp.Body.Close()</span></strong><span class="koboSpan" id="kobo.2407.1">. </span><span class="koboSpan" id="kobo.2407.2">This is what you see when you run </span><span class="No-Break"><span class="koboSpan" id="kobo.2408.1">this program:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.2409.1">ch03/defer</span><span class="Code_Blue"><span class="koboSpan" id="kobo.2410.1">$ go</span></span><strong class="bold"><span class="koboSpan" id="kobo.2411.1"> run main.go</span></strong><span class="koboSpan" id="kobo.2412.1">
Response status: </span><span class="Code_Green"><span class="koboSpan" id="kobo.2413.1">200</span></span><span class="koboSpan" id="kobo.2414.1"> OK
Deferred cleanup</span></pre>
<p><span class="koboSpan" id="kobo.2415.1">The full code for this code example is available at </span><strong class="source-inline"><span class="koboSpan" id="kobo.2416.1">ch03/defer/main.go</span></strong><span class="koboSpan" id="kobo.2417.1"> (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.2418.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.2419.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.2420.1">Now that we’ve covered the Go functions fundamentals, it’s time to move onto the next level of abstraction that describes object behaviors through a unique set of </span><span class="No-Break"><span class="koboSpan" id="kobo.2421.1">methods: interfaces.</span></span></p>
<h1 id="_idParaDest-90"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.2422.1">Interfaces</span></h1>
<p><span class="koboSpan" id="kobo.2423.1">Interfaces </span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.2424.1">are one of the most powerful constructs in Go, so it’s very important to understand what they do and when you can use them. </span><span class="koboSpan" id="kobo.2424.2">From a purely theoretical point of view, interfaces are an abstract type. </span><span class="koboSpan" id="kobo.2424.3">They do not contain implementation details but define a set of behaviors through </span><span class="No-Break"><span class="koboSpan" id="kobo.2425.1">method signatures.</span></span></p>
<p><span class="koboSpan" id="kobo.2426.1">If a Go type defines</span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.2427.1"> all method signatures declared by an interface, this Go type </span><em class="italic"><span class="koboSpan" id="kobo.2428.1">implements</span></em><span class="koboSpan" id="kobo.2429.1"> that interface implicitly, with no explicit declaration. </span><span class="koboSpan" id="kobo.2429.2">This is how Go deals with common behaviors exhibited by more than one type, and what other languages often express through </span><span class="No-Break"><span class="koboSpan" id="kobo.2430.1">object inheritance.</span></span></p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.2431.1">Network automation example</span></h2>
<p><span class="koboSpan" id="kobo.2432.1">To </span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.2433.1">introduce the idea, we use a contrived </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.2434.1">network automation example. </span><span class="koboSpan" id="kobo.2434.2">Let’s say we are developing a Go package to deal with common tasks across different network devices. </span><span class="koboSpan" id="kobo.2434.3">We model a Cisco IOS XE device as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.2435.1">CiscoIOS</span></strong><span class="koboSpan" id="kobo.2436.1"> type with two fields — one that identifies the hostname of a device (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2437.1">Hostname</span></strong><span class="koboSpan" id="kobo.2438.1">) and another that identifies the underlying hardware platform (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2439.1">Platform</span></strong><span class="koboSpan" id="kobo.2440.1">). </span><span class="koboSpan" id="kobo.2440.2">For this </span><strong class="source-inline"><span class="koboSpan" id="kobo.2441.1">CiscoIOS</span></strong><span class="koboSpan" id="kobo.2442.1"> type, we define a method that gets us the uptime of a device (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2443.1">getUptime</span></strong><span class="koboSpan" id="kobo.2444.1">) as an integer. </span><span class="koboSpan" id="kobo.2444.2">Finally, we define a function to compare two devices and find out which one has been running longer without </span><span class="No-Break"><span class="koboSpan" id="kobo.2445.1">a reboot:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.2446.1">type</span></span><span class="koboSpan" id="kobo.2447.1"> CiscoIOS </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2448.1">struct</span></span><span class="koboSpan" id="kobo.2449.1"> {
    Hostname </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2450.1">string</span></span><span class="koboSpan" id="kobo.2451.1">
    Platform </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2452.1">string</span></span><span class="koboSpan" id="kobo.2453.1">
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2454.1">func</span></span><span class="koboSpan" id="kobo.2455.1"> (r CiscoIOS) </span><strong class="bold"><span class="koboSpan" id="kobo.2456.1">getUptime</span></strong><span class="koboSpan" id="kobo.2457.1">() </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2458.1">int</span></span><span class="koboSpan" id="kobo.2459.1"> {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.2460.1">/* ... </span><span class="koboSpan" id="kobo.2460.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.2460.3">*/</span></span><span class="koboSpan" id="kobo.2461.1">
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2462.1">func</span></span><span class="koboSpan" id="kobo.2463.1"> LastToReboot(r1, r2 CiscoIOS) </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2464.1">bool</span></span><span class="koboSpan" id="kobo.2465.1"> {
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2466.1">return</span></span><span class="koboSpan" id="kobo.2467.1"> r1.getUptime() &lt; r2.getUptime()
}</span></pre>
<p><span class="koboSpan" id="kobo.2468.1">Everything works fine until we add another platform to the mix. </span><span class="koboSpan" id="kobo.2468.2">Let’s say we now also have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.2469.1">CiscoNXOS</span></strong><span class="koboSpan" id="kobo.2470.1"> type and it has </span><strong class="source-inline"><span class="koboSpan" id="kobo.2471.1">Hostname</span></strong><span class="koboSpan" id="kobo.2472.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2473.1">Platform</span></strong><span class="koboSpan" id="kobo.2474.1"> fields, but it also has a Boolean </span><strong class="source-inline"><span class="koboSpan" id="kobo.2475.1">ACI</span></strong><span class="koboSpan" id="kobo.2476.1"> field to show </span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.2477.1">whether this switch is ACI-enabled. </span><span class="koboSpan" id="kobo.2477.2">As with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2478.1">CiscoIOS</span></strong><span class="koboSpan" id="kobo.2479.1"> type, we </span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.2480.1">define a method that returns the uptime of a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2481.1">CiscoNXOS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2482.1"> device:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.2483.1">type</span></span><span class="koboSpan" id="kobo.2484.1"> CiscoNXOS </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2485.1">struct</span></span><span class="koboSpan" id="kobo.2486.1"> {
    Hostname </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2487.1">string</span></span><span class="koboSpan" id="kobo.2488.1">
    Platform </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2489.1">string</span></span><span class="koboSpan" id="kobo.2490.1">
    ACI      </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2491.1">bool</span></span><span class="koboSpan" id="kobo.2492.1">
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2493.1">func</span></span><span class="koboSpan" id="kobo.2494.1"> (s CiscoNXOS) getUptime() </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2495.1">int</span></span><span class="koboSpan" id="kobo.2496.1"> {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.2497.1">/* ... </span><span class="koboSpan" id="kobo.2497.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.2497.3">*/</span></span><span class="koboSpan" id="kobo.2498.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.2499.1">The challenge now is to compare the uptime of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.2500.1">CiscoNXOS</span></strong><span class="koboSpan" id="kobo.2501.1"> device type with the uptime of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.2502.1">CiscoIOS</span></strong><span class="koboSpan" id="kobo.2503.1"> device type. </span><span class="koboSpan" id="kobo.2503.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2504.1">LastToReboot</span></strong><span class="koboSpan" id="kobo.2505.1"> function signature tells us it only accepts variables of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.2506.1">CiscoIOS</span></strong><span class="koboSpan" id="kobo.2507.1"> type as an argument, so we cannot pass an element of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.2508.1">CiscoNXOS</span></strong><span class="koboSpan" id="kobo.2509.1"> type </span><span class="No-Break"><span class="koboSpan" id="kobo.2510.1">to it.</span></span></p>
<p><span class="koboSpan" id="kobo.2511.1">You can fix this by creating an interface. </span><span class="koboSpan" id="kobo.2511.2">By doing this, you abstract away the implementation details of the device and only focus on the need to present the device uptime as an integer via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2512.1">getUptime</span></strong><span class="koboSpan" id="kobo.2513.1"> function. </span><span class="koboSpan" id="kobo.2513.2">Let’s call this </span><span class="No-Break"><span class="koboSpan" id="kobo.2514.1">interface </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2515.1">NetworkDevice</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2516.1">:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.2517.1">type</span></span><span class="koboSpan" id="kobo.2518.1"> NetworkDevice </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2519.1">interface</span></span><span class="koboSpan" id="kobo.2520.1"> {
    getUptime() </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2521.1">int</span></span><span class="koboSpan" id="kobo.2522.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.2523.1">The next step is to change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2524.1">LastToReboot</span></strong><span class="koboSpan" id="kobo.2525.1"> function to accept a </span><strong class="source-inline"><span class="koboSpan" id="kobo.2526.1">NetworkDevice</span></strong><span class="koboSpan" id="kobo.2527.1"> type instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.2528.1">CiscoIOS</span></strong><span class="koboSpan" id="kobo.2529.1">, as in the next </span><span class="No-Break"><span class="koboSpan" id="kobo.2530.1">code snippet:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.2531.1">func</span></span><span class="koboSpan" id="kobo.2532.1"> LastToReboot(r1, r2 NetworkDevice) </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2533.1">bool</span></span><span class="koboSpan" id="kobo.2534.1"> {
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2535.1">return</span></span><span class="koboSpan" id="kobo.2536.1"> r1.getUptime() </span><span class="Code_Red"><span class="koboSpan" id="kobo.2537.1">&lt;</span></span><span class="koboSpan" id="kobo.2538.1"> r2.getUptime()
}</span></pre>
<p><span class="koboSpan" id="kobo.2539.1">Because both </span><strong class="source-inline"><span class="koboSpan" id="kobo.2540.1">CiscoIOS</span></strong><span class="koboSpan" id="kobo.2541.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2542.1">CiscoNXOS</span></strong><span class="koboSpan" id="kobo.2543.1"> have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.2544.1">getUptime() int</span></strong><span class="koboSpan" id="kobo.2545.1"> method, they implicitly satisfy the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2546.1">NetworkDevice</span></strong><span class="koboSpan" id="kobo.2547.1"> interface, hence you can pass either one of them as a parameter to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2548.1">LastToReboot</span></strong><span class="koboSpan" id="kobo.2549.1"> function. </span><span class="koboSpan" id="kobo.2549.2">A </span><strong class="bold"><span class="koboSpan" id="kobo.2550.1">sample program</span></strong><span class="koboSpan" id="kobo.2551.1"> (see </span><em class="italic"><span class="koboSpan" id="kobo.2552.1">Further reading</span></em><span class="koboSpan" id="kobo.2553.1">) that </span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.2554.1">uses these definitions to compare</span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.2555.1"> the uptime of these two device types would look </span><span class="No-Break"><span class="koboSpan" id="kobo.2556.1">as follows:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.2557.1">func</span></span><span class="koboSpan" id="kobo.2558.1"> main() {
    ios :</span><span class="Code_Red"><span class="koboSpan" id="kobo.2559.1">=</span></span><span class="koboSpan" id="kobo.2560.1"> CiscoIOS{}
    nexus :</span><span class="Code_Red"><span class="koboSpan" id="kobo.2561.1">=</span></span><span class="koboSpan" id="kobo.2562.1"> CiscoNXOS{}
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2563.1">if</span></span><span class="koboSpan" id="kobo.2564.1"> LastToReboot(ios, nexus) {
        fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.2565.1">"IOS-XE has been running for less time, so it was the last to be rebooted"</span></span><span class="koboSpan" id="kobo.2566.1">)
        os.Exit(0)
    }
    fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.2567.1">"NXOS was the last one to reboot"</span></span><span class="koboSpan" id="kobo.2568.1">)
}</span></pre>
<p><span class="koboSpan" id="kobo.2569.1">Interfaces can help you scale your programs. </span><span class="koboSpan" id="kobo.2569.2">The interface </span><strong class="source-inline"><span class="koboSpan" id="kobo.2570.1">NetworkDevice</span></strong><span class="koboSpan" id="kobo.2571.1"> enables us to add any number of device types. </span><span class="koboSpan" id="kobo.2571.2">It’s not only a great resource for good code design but also to set clear expectations of what the data should do in an API, regardless of what the data is. </span><span class="koboSpan" id="kobo.2571.3">In the example, we don’t care what operating system the device is running, only that we have a method available to get its uptime as </span><span class="No-Break"><span class="koboSpan" id="kobo.2572.1">an integer.</span></span></p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.2573.1">Standard library example</span></h2>
<p><span class="koboSpan" id="kobo.2574.1">For a </span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.2575.1">more real-world example, let’s turn our attention to </span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.2576.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2577.1">net</span></strong><span class="koboSpan" id="kobo.2578.1"> package in the standard library, which has an interface that represents a network connection (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2579.1">Conn</span></strong><span class="koboSpan" id="kobo.2580.1">). </span><span class="koboSpan" id="kobo.2580.2">Interface fields are often verbs that describe behavior and not state (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.2581.1">SetDeadline</span></strong><span class="koboSpan" id="kobo.2582.1"> for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2583.1">Conn</span></strong><span class="koboSpan" id="kobo.2584.1"> interface). </span><span class="koboSpan" id="kobo.2584.2">By contrast, a more descriptive name for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2585.1">RemoteAddr</span></strong><span class="koboSpan" id="kobo.2586.1"> method might have </span><span class="No-Break"><span class="koboSpan" id="kobo.2587.1">been </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2588.1">getRemoteAddr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2589.1">:</span></span></p>
<pre class="source-code"><span class="Code_Brown"><span class="koboSpan" id="kobo.2590.1">// src/net/net.go</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.2591.1">// Conn is a generic stream-oriented network connection.</span></span>
<span class="Code_Purple"><span class="koboSpan" id="kobo.2592.1">type</span></span><span class="koboSpan" id="kobo.2593.1"> Conn </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2594.1">interface</span></span><span class="koboSpan" id="kobo.2595.1"> {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.2596.1">/* ... </span><span class="koboSpan" id="kobo.2596.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.2596.3">*/</span></span><span class="koboSpan" id="kobo.2597.1">
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.2598.1">// LocalAddr returns the local network address.</span></span><span class="koboSpan" id="kobo.2599.1">
    LocalAddr() Addr
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.2600.1">// RemoteAddr returns the remote network address.</span></span><span class="koboSpan" id="kobo.2601.1">
    RemoteAddr() Addr
    SetDeadline(t time.Time) </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2602.1">error</span></span><span class="koboSpan" id="kobo.2603.1">
    SetReadDeadline(t time.Time) </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2604.1">error</span></span><span class="koboSpan" id="kobo.2605.1">
    SetWriteDeadline(t time.Time) </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2606.1">error</span></span><span class="koboSpan" id="kobo.2607.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.2608.1">The </span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.2609.1">standard library includes several implementations of this </span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.2610.1">interface. </span><span class="koboSpan" id="kobo.2610.2">One of them is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2611.1">crypto/ssh</span></strong><span class="koboSpan" id="kobo.2612.1"> library, through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2613.1">chanConn</span></strong><span class="koboSpan" id="kobo.2614.1"> concrete type. </span><span class="koboSpan" id="kobo.2614.2">A concrete type is any non-interface type that stores its own data and, in this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.2615.1">chanConn</span></strong><span class="koboSpan" id="kobo.2616.1"> stores values for local (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2617.1">laddr</span></strong><span class="koboSpan" id="kobo.2618.1">) and remote (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2619.1">raddr</span></strong><span class="koboSpan" id="kobo.2620.1">) addresses of </span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.2621.1">a </span><strong class="bold"><span class="koboSpan" id="kobo.2622.1">Secure Shell Protocol</span></strong><span class="koboSpan" id="kobo.2623.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.2624.1">SSH</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2625.1">) connection.</span></span></p>
<p><span class="koboSpan" id="kobo.2626.1">This type also defines methods, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.2627.1">LocalAddr() net.Addr</span></strong><span class="koboSpan" id="kobo.2628.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2629.1">SetReadDeadline(deadline time.Time) error</span></strong><span class="koboSpan" id="kobo.2630.1">. </span><span class="koboSpan" id="kobo.2630.2">In fact, it has all methods of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2631.1">net.Conn</span></strong><span class="koboSpan" id="kobo.2632.1"> interface, hence it satisfies </span><span class="No-Break"><span class="koboSpan" id="kobo.2633.1">the interface:</span></span></p>
<pre class="source-code"><span class="Code_Brown"><span class="koboSpan" id="kobo.2634.1">// ssh/tcpip.go</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.2635.1">// chanConn fulfills the net.Conn interface without</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.2636.1">// the tcpChan having to hold laddr or raddr directly.</span></span>
<span class="Code_Purple"><span class="koboSpan" id="kobo.2637.1">type</span></span><span class="koboSpan" id="kobo.2638.1"> chanConn </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2639.1">struct</span></span><span class="koboSpan" id="kobo.2640.1"> {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.2641.1">/* ... </span><span class="koboSpan" id="kobo.2641.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.2641.3">*/</span></span><span class="koboSpan" id="kobo.2642.1">
    laddr, raddr net.Addr
}
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.2643.1">// LocalAddr returns the local network address.</span></span>
<span class="Code_Purple"><span class="koboSpan" id="kobo.2644.1">func</span></span><span class="koboSpan" id="kobo.2645.1"> (t </span><span class="Code_Red"><span class="koboSpan" id="kobo.2646.1">*</span></span><span class="koboSpan" id="kobo.2647.1">chanConn) LocalAddr() net.Addr {
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2648.1">return</span></span><span class="koboSpan" id="kobo.2649.1"> t.laddr
}
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.2650.1">// RemoteAddr returns the remote network address.</span></span>
<span class="Code_Purple"><span class="koboSpan" id="kobo.2651.1">func</span></span><span class="koboSpan" id="kobo.2652.1"> (t </span><span class="Code_Red"><span class="koboSpan" id="kobo.2653.1">*</span></span><span class="koboSpan" id="kobo.2654.1">chanConn) RemoteAddr() net.Addr {
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2655.1">return</span></span><span class="koboSpan" id="kobo.2656.1"> t.raddr
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2657.1">func</span></span><span class="koboSpan" id="kobo.2658.1"> (t </span><span class="Code_Red"><span class="koboSpan" id="kobo.2659.1">*</span></span><span class="koboSpan" id="kobo.2660.1">chanConn) SetDeadline(deadline time.Time) </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2661.1">error</span></span><span class="koboSpan" id="kobo.2662.1"> {
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2663.1">if</span></span><span class="koboSpan" id="kobo.2664.1"> err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.2665.1">=</span></span><span class="koboSpan" id="kobo.2666.1"> t.SetReadDeadline(deadline); err </span><span class="Code_Red"><span class="koboSpan" id="kobo.2667.1">!=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.2668.1">nil</span></span><span class="koboSpan" id="kobo.2669.1"> {
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2670.1">return</span></span><span class="koboSpan" id="kobo.2671.1"> err
    }
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2672.1">return</span></span><span class="koboSpan" id="kobo.2673.1"> t.SetWriteDeadline(deadline)
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2674.1">func</span></span><span class="koboSpan" id="kobo.2675.1"> (t </span><span class="Code_Red"><span class="koboSpan" id="kobo.2676.1">*</span></span><span class="koboSpan" id="kobo.2677.1">chanConn) SetReadDeadline(deadline time.Time) </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2678.1">error</span></span><span class="koboSpan" id="kobo.2679.1"> {
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2680.1">return</span></span><span class="koboSpan" id="kobo.2681.1"> errors.New(</span><span class="Code_Red"><span class="koboSpan" id="kobo.2682.1">"ssh: tcpChan: deadline not supported"</span></span><span class="koboSpan" id="kobo.2683.1">)
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2684.1">func</span></span><span class="koboSpan" id="kobo.2685.1"> (t </span><span class="Code_Red"><span class="koboSpan" id="kobo.2686.1">*</span></span><span class="koboSpan" id="kobo.2687.1">chanConn) SetWriteDeadline(deadline time.Time) </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2688.1">error</span></span><span class="koboSpan" id="kobo.2689.1"> {
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2690.1">return</span></span><span class="koboSpan" id="kobo.2691.1"> errors.New(</span><span class="Code_Red"><span class="koboSpan" id="kobo.2692.1">"ssh: tcpChan: deadline not supported"</span></span><span class="koboSpan" id="kobo.2693.1">)
}</span></pre>
<p><span class="koboSpan" id="kobo.2694.1">Now, any</span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.2695.1"> function that accepts </span><strong class="source-inline"><span class="koboSpan" id="kobo.2696.1">net.Conn</span></strong><span class="koboSpan" id="kobo.2697.1"> as input can </span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.2698.1">take </span><strong class="source-inline"><span class="koboSpan" id="kobo.2699.1">chanConn</span></strong><span class="koboSpan" id="kobo.2700.1"> as well. </span><span class="koboSpan" id="kobo.2700.2">Or vice versa, if a function returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.2701.1">net.Conn</span></strong><span class="koboSpan" id="kobo.2702.1">, it can also return </span><strong class="source-inline"><span class="koboSpan" id="kobo.2703.1">chanConn</span></strong><span class="koboSpan" id="kobo.2704.1">, as in the next example from the same source </span><span class="No-Break"><span class="koboSpan" id="kobo.2705.1">code file:</span></span></p>
<pre class="source-code"><span class="Code_Brown"><span class="koboSpan" id="kobo.2706.1">// ssh/tcpip.go</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.2707.1">// Dial initiates a conn to the addr from remote host.</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.2708.1">// Resulting conn has a zero LocalAddr() and RemoteAddr().</span></span>
<span class="Code_Purple"><span class="koboSpan" id="kobo.2709.1">func</span></span><span class="koboSpan" id="kobo.2710.1"> (c *Client) Dial(n, addr </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2711.1">string</span></span><span class="koboSpan" id="kobo.2712.1">) (net.Conn, </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2713.1">error</span></span><span class="koboSpan" id="kobo.2714.1">) {
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2715.1">var</span></span><span class="koboSpan" id="kobo.2716.1"> ch Channel
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2717.1">switch</span></span><span class="koboSpan" id="kobo.2718.1"> n {
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2719.1">case</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.2720.1">"tcp"</span></span><span class="koboSpan" id="kobo.2721.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.2722.1">"tcp4"</span></span><span class="koboSpan" id="kobo.2723.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.2724.1">"tcp6"</span></span><span class="koboSpan" id="kobo.2725.1">:
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.2726.1">// Parse the address into host and numeric port.</span></span><span class="koboSpan" id="kobo.2727.1">
    host, portString, err := net.SplitHostPort(addr)
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2728.1">if</span></span><span class="koboSpan" id="kobo.2729.1"> err </span><span class="Code_Red"><span class="koboSpan" id="kobo.2730.1">!=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.2731.1">nil</span></span><span class="koboSpan" id="kobo.2732.1"> {
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2733.1">return</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.2734.1">nil</span></span><span class="koboSpan" id="kobo.2735.1">, err
    }
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.2736.1">/* ... </span><span class="koboSpan" id="kobo.2736.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.2736.3">*/</span></span><span class="koboSpan" id="kobo.2737.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2738.1">return</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.2739.1">&amp;</span></span><span class="koboSpan" id="kobo.2740.1">chanConn{
        Channel: ch,
        laddr:   zeroAddr,
        raddr:   zeroAddr,
    }, </span><span class="Code_Blue"><span class="koboSpan" id="kobo.2741.1">nil</span></span><span class="koboSpan" id="kobo.2742.1">
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.2743.1">/* ... </span><span class="koboSpan" id="kobo.2743.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.2743.3">*/</span></span><span class="koboSpan" id="kobo.2744.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.2745.1">Don’t worry if </span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.2746.1">these code snippets look daunting to you. </span><span class="koboSpan" id="kobo.2746.2">These</span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.2747.1"> come from the actual SSH package of the Go standard library, so this is as complex as </span><span class="No-Break"><span class="koboSpan" id="kobo.2748.1">it gets.</span></span></p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.2749.1">Interfaces as contracts</span></h2>
<p><span class="koboSpan" id="kobo.2750.1">Interfaces </span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.2751.1">are a valueless type; they only define method signatures. </span><span class="koboSpan" id="kobo.2751.2">You can define a variable of an interface type, but you can only assign a concrete implementation of this interface as the value of </span><span class="No-Break"><span class="koboSpan" id="kobo.2752.1">this variable.</span></span></p>
<p><span class="koboSpan" id="kobo.2753.1">In the next code example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2754.1">r</span></strong><span class="koboSpan" id="kobo.2755.1"> variable is of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2756.1">io.Reader</span></strong><span class="koboSpan" id="kobo.2757.1"> type, which is an interface. </span><span class="koboSpan" id="kobo.2757.2">At that point, we know nothing about this variable but we do know that whatever value we assign to this variable must satisfy the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2758.1">io.Reader</span></strong><span class="koboSpan" id="kobo.2759.1"> interface in order for the compiler to </span><span class="No-Break"><span class="koboSpan" id="kobo.2760.1">accept it.</span></span></p>
<p><span class="koboSpan" id="kobo.2761.1">In this case, we’re using </span><strong class="source-inline"><span class="koboSpan" id="kobo.2762.1">strings.NewReader("text")</span></strong><span class="koboSpan" id="kobo.2763.1">, which implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2764.1">io.Reader</span></strong><span class="koboSpan" id="kobo.2765.1"> interface to read from a </span><strong class="source-inline"><span class="koboSpan" id="kobo.2766.1">string</span></strong><span class="koboSpan" id="kobo.2767.1"> value that gets passed as </span><span class="No-Break"><span class="koboSpan" id="kobo.2768.1">an argument:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.2769.1">func</span></span><span class="koboSpan" id="kobo.2770.1"> main() {
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2771.1">var</span></span><span class="koboSpan" id="kobo.2772.1"> r io.Reader
    r </span><span class="Code_Red"><span class="koboSpan" id="kobo.2773.1">=</span></span><span class="koboSpan" id="kobo.2774.1"> strings.NewReader(</span><span class="Code_Red"><span class="koboSpan" id="kobo.2775.1">"a random text"</span></span><span class="koboSpan" id="kobo.2776.1">)
    io.Copy(os.Stdout, r)
}</span></pre>
<p><span class="koboSpan" id="kobo.2777.1">The last line of code copies what we read to standard output (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2778.1">Stdout</span></strong><span class="koboSpan" id="kobo.2779.1">) or the user’s screen. </span><span class="koboSpan" id="kobo.2779.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2780.1">io.Copy</span></strong><span class="koboSpan" id="kobo.2781.1"> function copies from </span><strong class="source-inline"><span class="koboSpan" id="kobo.2782.1">io.Reader</span></strong><span class="koboSpan" id="kobo.2783.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2784.1">r</span></strong><span class="koboSpan" id="kobo.2785.1">) to </span><strong class="source-inline"><span class="koboSpan" id="kobo.2786.1">io.Writer</span></strong><span class="koboSpan" id="kobo.2787.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2788.1">os.Stdout</span></strong><span class="koboSpan" id="kobo.2789.1"> satisfies this interface), so we can copy from the string to </span><span class="No-Break"><span class="koboSpan" id="kobo.2790.1">the terminal.</span></span></p>
<p><span class="koboSpan" id="kobo.2791.1">While this looks a bit more complicated than just printing the string with </span><strong class="source-inline"><span class="koboSpan" id="kobo.2792.1">fmt.Println</span></strong><span class="koboSpan" id="kobo.2793.1">, interfaces make our code more versatile, allowing you to replace either the source or destination of the data in the example without too much effort. </span><span class="koboSpan" id="kobo.2793.2">This is possible</span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.2794.1"> because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2795.1">io.Reader</span></strong><span class="koboSpan" id="kobo.2796.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2797.1">io.Writer</span></strong><span class="koboSpan" id="kobo.2798.1"> interfaces serve as a contract between both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2799.1">io.Copy()</span></strong><span class="koboSpan" id="kobo.2800.1"> consumer and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2801.1">strings.NewReader</span></strong><span class="koboSpan" id="kobo.2802.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2803.1">os.Stdout</span></strong><span class="koboSpan" id="kobo.2804.1"> providers, ensuring they both conform to the rules defined by </span><span class="No-Break"><span class="koboSpan" id="kobo.2805.1">this interface.</span></span></p>
<p><span class="koboSpan" id="kobo.2806.1">Interfaces allow you to define a clear division between different modules of a program and offer an API where users can define the implementation details. </span><span class="koboSpan" id="kobo.2806.2">In the next section, we examine in detail the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2807.1">io.Reader</span></strong><span class="koboSpan" id="kobo.2808.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2809.1">io.Writer</span></strong><span class="koboSpan" id="kobo.2810.1"> interfaces and their role in </span><strong class="bold"><span class="koboSpan" id="kobo.2811.1">input/output</span></strong><span class="koboSpan" id="kobo.2812.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.2813.1">I/O</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2814.1">) operations.</span></span></p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.2815.1">Input and output operations</span></h1>
<p><span class="koboSpan" id="kobo.2816.1">A common operation</span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.2817.1"> in a program is to move data around and reformat it. </span><span class="koboSpan" id="kobo.2817.2">For example, you can open a file, load its content in memory, encode it to a different format, maybe </span><strong class="source-inline"><span class="koboSpan" id="kobo.2818.1">jpeg</span></strong><span class="koboSpan" id="kobo.2819.1">, and then write it to a file on the disk. </span><span class="koboSpan" id="kobo.2819.2">This is where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2820.1">io.Reader</span></strong><span class="koboSpan" id="kobo.2821.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2822.1">io.Writer</span></strong><span class="koboSpan" id="kobo.2823.1"> interfaces play a key role in Go’s I/O model, as they allow you to stream data from a source to a destination via a transfer buffer. </span><span class="koboSpan" id="kobo.2823.2">This means you don’t need to load the entire file in memory to encode it and write it to the destination, making the process </span><span class="No-Break"><span class="koboSpan" id="kobo.2824.1">more efficient.</span></span></p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.2825.1">The io.Reader interface</span></h2>
<p><span class="koboSpan" id="kobo.2826.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2827.1">io</span></strong><span class="koboSpan" id="kobo.2828.1"> package in</span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.2829.1"> the standard library defines one of the most popular interfaces in Go, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2830.1">io.Reader</span></strong><span class="koboSpan" id="kobo.2831.1"> interface, which can read a stream of bytes (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2832.1">p</span></strong><span class="koboSpan" id="kobo.2833.1">). </span><span class="koboSpan" id="kobo.2833.2">It returns the number of bytes read (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2834.1">n</span></strong><span class="koboSpan" id="kobo.2835.1">) and any error </span><span class="No-Break"><span class="koboSpan" id="kobo.2836.1">encountered (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2837.1">err</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2838.1">):</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.2839.1">type</span></span><span class="koboSpan" id="kobo.2840.1"> Reader </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2841.1">interface</span></span><span class="koboSpan" id="kobo.2842.1"> {
    Read(p []</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2843.1">byte</span></span><span class="koboSpan" id="kobo.2844.1">) (n </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2845.1">int</span></span><span class="koboSpan" id="kobo.2846.1">, err </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2847.1">error</span></span><span class="koboSpan" id="kobo.2848.1">)
}</span></pre>
<p><span class="koboSpan" id="kobo.2849.1">Any concrete type that has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.2850.1">Read</span></strong><span class="koboSpan" id="kobo.2851.1"> with this signature implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2852.1">io.Reader</span></strong><span class="koboSpan" id="kobo.2853.1"> interface. </span><span class="koboSpan" id="kobo.2853.2">You don’t need to do </span><span class="No-Break"><span class="koboSpan" id="kobo.2854.1">anything else:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<span class="koboSpan" id="kobo.2855.1"><img alt="Figure 3.9 – The io.Reader interface" src="image/Figure_3.9.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2856.1">Figure 3.9 – The io.Reader interface</span></p>
<p><span class="koboSpan" id="kobo.2857.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2858.1">strings.Reader</span></strong><span class="koboSpan" id="kobo.2859.1"> type (in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2860.1">strings</span></strong><span class="koboSpan" id="kobo.2861.1"> package of the standard library) has a method with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2862.1">Read(p []byte) (n int, err error)</span></strong><span class="koboSpan" id="kobo.2863.1"> signature, hence it satisfies the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2864.1">io.Reader</span></strong><span class="koboSpan" id="kobo.2865.1"> interface. </span><span class="koboSpan" id="kobo.2865.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2866.1">strings</span></strong><span class="koboSpan" id="kobo.2867.1"> package also provides a convenient </span><strong class="source-inline"><span class="koboSpan" id="kobo.2868.1">NewReader</span></strong><span class="koboSpan" id="kobo.2869.1"> function that </span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.2870.1">returns a pointer to a new instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2871.1">strings.Reader</span></strong><span class="koboSpan" id="kobo.2872.1"> type. </span><span class="koboSpan" id="kobo.2872.2">The following is an actual snippet from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2873.1">strings</span></strong><span class="koboSpan" id="kobo.2874.1"> package </span><span class="No-Break"><span class="koboSpan" id="kobo.2875.1">source code:</span></span></p>
<pre class="source-code"><span class="Code_Brown"><span class="koboSpan" id="kobo.2876.1">// src/strings/reader.go</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.2877.1">// A Reader implements the io.Reader, ...</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.2878.1">// from a string.</span></span>
<span class="Code_Purple"><span class="koboSpan" id="kobo.2879.1">type</span></span><span class="koboSpan" id="kobo.2880.1"> Reader </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2881.1">struct</span></span><span class="koboSpan" id="kobo.2882.1"> {
    s        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2883.1">string</span></span><span class="koboSpan" id="kobo.2884.1">
    i        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2885.1">int64</span></span> <span class="Code_Brown"><span class="koboSpan" id="kobo.2886.1">// current reading index</span></span><span class="koboSpan" id="kobo.2887.1">
    prevRune </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2888.1">int</span></span><span class="koboSpan" id="kobo.2889.1">   </span><span class="Code_Brown"><span class="koboSpan" id="kobo.2890.1">// index of previous rune; or &lt; 0</span></span><span class="koboSpan" id="kobo.2891.1">
}
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.2892.1">// Read implements the io.Reader interface.</span></span>
<span class="Code_Purple"><span class="koboSpan" id="kobo.2893.1">func</span></span><span class="koboSpan" id="kobo.2894.1"> (r *Reader) Read(b []</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2895.1">byte</span></span><span class="koboSpan" id="kobo.2896.1">) (n </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2897.1">int</span></span><span class="koboSpan" id="kobo.2898.1">, err </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2899.1">error</span></span><span class="koboSpan" id="kobo.2900.1">) {
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2901.1">if</span></span><span class="koboSpan" id="kobo.2902.1"> r.i </span><span class="Code_Red"><span class="koboSpan" id="kobo.2903.1">&gt;=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.2904.1">int64</span></span><span class="koboSpan" id="kobo.2905.1">(</span><span class="Code_Blue"><span class="koboSpan" id="kobo.2906.1">len</span></span><span class="koboSpan" id="kobo.2907.1">(r.s)) {
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2908.1">return</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.2909.1">0</span></span><span class="koboSpan" id="kobo.2910.1">, io.EOF
    }
    r.prevRune </span><span class="Code_Red"><span class="koboSpan" id="kobo.2911.1">= -</span></span><span class="Code_Green"><span class="koboSpan" id="kobo.2912.1">1</span></span><span class="koboSpan" id="kobo.2913.1">
    n </span><span class="Code_Red"><span class="koboSpan" id="kobo.2914.1">=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.2915.1">copy</span></span><span class="koboSpan" id="kobo.2916.1">(b, r.s[r.i:])
    r.i </span><span class="Code_Red"><span class="koboSpan" id="kobo.2917.1">+=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.2918.1">int64</span></span><span class="koboSpan" id="kobo.2919.1">(n)
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2920.1">return</span></span><span class="koboSpan" id="kobo.2921.1">
}
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.2922.1">// NewReader returns a new Reader reading from s.</span></span>
<span class="Code_Purple"><span class="koboSpan" id="kobo.2923.1">func</span></span><span class="koboSpan" id="kobo.2924.1"> NewReader(s </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2925.1">string</span></span><span class="koboSpan" id="kobo.2926.1">) </span><span class="Code_Red"><span class="koboSpan" id="kobo.2927.1">*</span></span><span class="koboSpan" id="kobo.2928.1">Reader { </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2929.1">return</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.2930.1">&amp;</span></span><span class="koboSpan" id="kobo.2931.1">Reader{s, </span><span class="Code_Green"><span class="koboSpan" id="kobo.2932.1">0</span></span><span class="koboSpan" id="kobo.2933.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.2934.1">-</span></span><span class="Code_Green"><span class="koboSpan" id="kobo.2935.1">1</span></span><span class="koboSpan" id="kobo.2936.1">} }</span></pre>
<p><span class="koboSpan" id="kobo.2937.1">The preceding </span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.2938.1">code also shows a concrete </span><strong class="source-inline"><span class="koboSpan" id="kobo.2939.1">Reader</span></strong><span class="koboSpan" id="kobo.2940.1"> implementation (with data fields) that has a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2941.1">Read</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2942.1"> method.</span></span></p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.2943.1">The io.Writer interface</span></h2>
<p><span class="koboSpan" id="kobo.2944.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2945.1">io</span></strong><span class="koboSpan" id="kobo.2946.1"> package </span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.2947.1">also specifies the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2948.1">io.Reader</span></strong><span class="koboSpan" id="kobo.2949.1"> interface, which can write </span><strong class="source-inline"><span class="koboSpan" id="kobo.2950.1">len(p)</span></strong><span class="koboSpan" id="kobo.2951.1"> bytes to the underlying data stream. </span><span class="koboSpan" id="kobo.2951.2">It returns the number of bytes written (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2952.1">n</span></strong><span class="koboSpan" id="kobo.2953.1">) and any error encountered that caused the write to stop </span><span class="No-Break"><span class="koboSpan" id="kobo.2954.1">early (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2955.1">err</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2956.1">):</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.2957.1">type</span></span><span class="koboSpan" id="kobo.2958.1"> Writer </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2959.1">interface</span></span><span class="koboSpan" id="kobo.2960.1"> {
    Write(p []</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2961.1">byte</span></span><span class="koboSpan" id="kobo.2962.1">) (n </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2963.1">int</span></span><span class="koboSpan" id="kobo.2964.1">, err </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2965.1">error</span></span><span class="koboSpan" id="kobo.2966.1">)
}</span></pre>
<p><span class="koboSpan" id="kobo.2967.1">Any concrete type that has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.2968.1">Write</span></strong><span class="koboSpan" id="kobo.2969.1"> method with this signature implements the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2970.1">io.Writer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2971.1"> interface:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer041">
<span class="koboSpan" id="kobo.2972.1"><img alt="Figure 3.10 – The io.Writer interface" src="image/Figure_3.10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2973.1">Figure 3.10 – The io.Writer interface</span></p>
<p><span class="koboSpan" id="kobo.2974.1">One example is </span><strong class="source-inline"><span class="koboSpan" id="kobo.2975.1">os.File</span></strong><span class="koboSpan" id="kobo.2976.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2977.1">os</span></strong><span class="koboSpan" id="kobo.2978.1"> package of the standard library. </span><span class="koboSpan" id="kobo.2978.2">It has a method with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2979.1">Write(p []byte) (n int, err error)</span></strong><span class="koboSpan" id="kobo.2980.1"> signature, hence</span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.2981.1"> it satisfies the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2982.1">io.Writer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2983.1"> interface:</span></span></p>
<pre class="source-code"><span class="Code_Brown"><span class="koboSpan" id="kobo.2984.1">// src/os/types.go</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.2985.1">// File represents an open file descriptor.</span></span>
<span class="Code_Purple"><span class="koboSpan" id="kobo.2986.1">type</span></span><span class="koboSpan" id="kobo.2987.1"> File </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2988.1">struct</span></span><span class="koboSpan" id="kobo.2989.1"> {
    </span><span class="Code_Red"><span class="koboSpan" id="kobo.2990.1">*</span></span><span class="koboSpan" id="kobo.2991.1">file </span><span class="Code_Brown"><span class="koboSpan" id="kobo.2992.1">// os specific</span></span><span class="koboSpan" id="kobo.2993.1">
}
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.2994.1">// Read reads up to len(b) bytes from the File.</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.2995.1">// It returns the number of bytes read and any error.</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.2996.1">// At end of file, Read returns 0, io.EOF.</span></span>
<span class="Code_Purple"><span class="koboSpan" id="kobo.2997.1">func</span></span><span class="koboSpan" id="kobo.2998.1"> (f </span><span class="Code_Red"><span class="koboSpan" id="kobo.2999.1">*</span></span><span class="koboSpan" id="kobo.3000.1">File) Read(b []</span><span class="Code_Purple"><span class="koboSpan" id="kobo.3001.1">byte</span></span><span class="koboSpan" id="kobo.3002.1">) (n </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3003.1">int</span></span><span class="koboSpan" id="kobo.3004.1">, err </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3005.1">error</span></span><span class="koboSpan" id="kobo.3006.1">) {
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3007.1">if</span></span><span class="koboSpan" id="kobo.3008.1"> err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.3009.1">=</span></span><span class="koboSpan" id="kobo.3010.1"> f.checkValid(</span><span class="Code_Red"><span class="koboSpan" id="kobo.3011.1">"read"</span></span><span class="koboSpan" id="kobo.3012.1">); err </span><span class="Code_Red"><span class="koboSpan" id="kobo.3013.1">!=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.3014.1">nil</span></span><span class="koboSpan" id="kobo.3015.1"> {
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3016.1">return</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.3017.1">0</span></span><span class="koboSpan" id="kobo.3018.1">, err
    }
    n, e :</span><span class="Code_Red"><span class="koboSpan" id="kobo.3019.1">=</span></span><span class="koboSpan" id="kobo.3020.1"> f.read(b)
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3021.1">return</span></span><span class="koboSpan" id="kobo.3022.1"> n, f.wrapErr(</span><span class="Code_Red"><span class="koboSpan" id="kobo.3023.1">"read"</span></span><span class="koboSpan" id="kobo.3024.1">, e)
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.3025.1">func</span></span><span class="koboSpan" id="kobo.3026.1"> Create(name </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3027.1">string</span></span><span class="koboSpan" id="kobo.3028.1">) (</span><span class="Code_Red"><span class="koboSpan" id="kobo.3029.1">*</span></span><span class="koboSpan" id="kobo.3030.1">File, </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3031.1">error</span></span><span class="koboSpan" id="kobo.3032.1">) {
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3033.1">return</span></span><span class="koboSpan" id="kobo.3034.1"> OpenFile(name, O_RDWR</span><span class="Code_Red"><span class="koboSpan" id="kobo.3035.1">|</span></span><span class="koboSpan" id="kobo.3036.1">O_CREATE</span><span class="Code_Red"><span class="koboSpan" id="kobo.3037.1">|</span></span><span class="koboSpan" id="kobo.3038.1">O_TRUNC, </span><span class="Code_Green"><span class="koboSpan" id="kobo.3039.1">0666</span></span><span class="koboSpan" id="kobo.3040.1">)
}</span></pre>
<p><span class="koboSpan" id="kobo.3041.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.3042.1">os</span></strong><span class="koboSpan" id="kobo.3043.1"> package also offers a convenient </span><strong class="source-inline"><span class="koboSpan" id="kobo.3044.1">Create</span></strong><span class="koboSpan" id="kobo.3045.1"> function that returns a pointer to an </span><strong class="source-inline"><span class="koboSpan" id="kobo.3046.1">os.File</span></strong><span class="koboSpan" id="kobo.3047.1"> from a file location. </span><span class="koboSpan" id="kobo.3047.2">The preceding is an actual snippet from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3048.1">os</span></strong><span class="koboSpan" id="kobo.3049.1"> package </span><span class="No-Break"><span class="koboSpan" id="kobo.3050.1">source code.</span></span></p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.3051.1">The io.Copy function</span></h2>
<p><span class="koboSpan" id="kobo.3052.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.3053.1">io.Copy</span></strong><span class="koboSpan" id="kobo.3054.1"> function </span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.3055.1">allows you to copy data from a source to a destination, as we discussed at the end of the </span><em class="italic"><span class="koboSpan" id="kobo.3056.1">Interfaces</span></em><span class="koboSpan" id="kobo.3057.1"> section. </span><span class="koboSpan" id="kobo.3057.2">Even though you pass concrete type data to this function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.3058.1">io.Copy</span></strong><span class="koboSpan" id="kobo.3059.1"> actually doesn’t care what the data is, as it takes interface types as an argument, so it’s interested in what the data can do instead. </span><span class="koboSpan" id="kobo.3059.2">It needs a readable source and a </span><span class="No-Break"><span class="koboSpan" id="kobo.3060.1">writable destination:</span></span></p>
<pre class="source-code"><span class="Code_Brown"><span class="koboSpan" id="kobo.3061.1">// src/io/io.go</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.3062.1">// Copy copies from src to dst until either EOF is reached</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.3063.1">// on src or an error occurs.</span></span>
<span class="Code_Purple"><span class="koboSpan" id="kobo.3064.1">func</span></span><span class="koboSpan" id="kobo.3065.1"> Copy(dst Writer, src Reader) (written </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3066.1">int64</span></span><span class="koboSpan" id="kobo.3067.1">, err </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3068.1">error</span></span><span class="koboSpan" id="kobo.3069.1">) {
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3070.1">return</span></span><span class="koboSpan" id="kobo.3071.1"> copyBuffer(dst, src, </span><span class="Code_Blue"><span class="koboSpan" id="kobo.3072.1">nil</span></span><span class="koboSpan" id="kobo.3073.1">)
}</span></pre>
<p><span class="koboSpan" id="kobo.3074.1">As </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.3075.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.3076.1">.11</span></em><span class="koboSpan" id="kobo.3077.1"> shows, </span><strong class="source-inline"><span class="koboSpan" id="kobo.3078.1">io.Copy</span></strong><span class="koboSpan" id="kobo.3079.1"> uses a 32 KB transfer buffer to stream the data from the source to </span><span class="No-Break"><span class="koboSpan" id="kobo.3080.1">the destination:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer042">
<span class="koboSpan" id="kobo.3081.1"><img alt="Figure 3.11 – The io.Copy function" src="image/Figure_3.111.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.3082.1">Figure 3.11 – The io.Copy function</span></p>
<p><span class="koboSpan" id="kobo.3083.1">Let’s test this. </span><span class="koboSpan" id="kobo.3083.2">We can get an </span><strong class="source-inline"><span class="koboSpan" id="kobo.3084.1">io.Reader</span></strong><span class="koboSpan" id="kobo.3085.1"> from a string built with </span><strong class="source-inline"><span class="koboSpan" id="kobo.3086.1">strings.NewReader</span></strong><span class="koboSpan" id="kobo.3087.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.3088.1">os.Create</span></strong><span class="koboSpan" id="kobo.3089.1"> gives us an </span><strong class="source-inline"><span class="koboSpan" id="kobo.3090.1">io.Writer</span></strong><span class="koboSpan" id="kobo.3091.1">, which writes to a file on the disk. </span><span class="koboSpan" id="kobo.3091.2">You can follow along with the code at </span><strong class="source-inline"><span class="koboSpan" id="kobo.3092.1">ch03/io-interface1/main.go</span></strong><span class="koboSpan" id="kobo.3093.1"> (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.3094.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.3095.1">):</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.3096.1">func</span></span><span class="koboSpan" id="kobo.3097.1"> main() {
    src :</span><span class="Code_Red"><span class="koboSpan" id="kobo.3098.1">=</span></span><span class="koboSpan" id="kobo.3099.1"> strings.NewReader(</span><span class="Code_Red"><span class="koboSpan" id="kobo.3100.1">"The text"</span></span><span class="koboSpan" id="kobo.3101.1">)
    dst, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.3102.1">=</span></span><span class="koboSpan" id="kobo.3103.1"> os.Create(</span><span class="Code_Red"><span class="koboSpan" id="kobo.3104.1">"./file.txt"</span></span><span class="koboSpan" id="kobo.3105.1">)
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3106.1">if</span></span><span class="koboSpan" id="kobo.3107.1"> err </span><span class="Code_Red"><span class="koboSpan" id="kobo.3108.1">!=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.3109.1">nil</span></span><span class="koboSpan" id="kobo.3110.1"> {
        </span><span class="Code_Blue"><span class="koboSpan" id="kobo.3111.1">panic</span></span><span class="koboSpan" id="kobo.3112.1">(err)
    }
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3113.1">defer</span></span><span class="koboSpan" id="kobo.3114.1"> dst.Close()
    io.Copy(dst, src)
}</span></pre>
<p><span class="koboSpan" id="kobo.3115.1">While, in this case, we </span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.3116.1">select a string and a file combination, you can use the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.3117.1">io.Copy</span></strong><span class="koboSpan" id="kobo.3118.1"> function to read from the network and print to the terminal, for example. </span><span class="koboSpan" id="kobo.3118.2">For now, let’s inspect the file we </span><span class="No-Break"><span class="koboSpan" id="kobo.3119.1">just produced:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.3120.1">ch03/io-interface1</span><span class="Code_Blue"><span class="koboSpan" id="kobo.3121.1">$ </span></span><span class="koboSpan" id="kobo.3122.1">go run main.go
ch03/io-interface1</span><span class="Code_Blue"><span class="koboSpan" id="kobo.3123.1">$ </span></span><span class="koboSpan" id="kobo.3124.1">cat file.txt
The text</span></pre>
<p><span class="koboSpan" id="kobo.3125.1">Let’s examine a network-related example. </span><span class="koboSpan" id="kobo.3125.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.3126.1">net/http</span></strong><span class="koboSpan" id="kobo.3127.1"> package has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3128.1">Get</span></strong><span class="koboSpan" id="kobo.3129.1"> function that takes a URL (</span><strong class="source-inline"><span class="koboSpan" id="kobo.3130.1">string</span></strong><span class="koboSpan" id="kobo.3131.1">) and returns a pointer to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.3132.1">http.Response</span></strong><span class="koboSpan" id="kobo.3133.1">, which has a field (</span><strong class="source-inline"><span class="koboSpan" id="kobo.3134.1">Body</span></strong><span class="koboSpan" id="kobo.3135.1">) that satisfies the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3136.1">io.Reader</span></strong><span class="koboSpan" id="kobo.3137.1"> interface, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3138.1">os.Stdout</span></strong><span class="koboSpan" id="kobo.3139.1"> terminal satisfies the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3140.1">io.Writer</span></strong><span class="koboSpan" id="kobo.3141.1"> interface. </span><span class="koboSpan" id="kobo.3141.2">This gives us another combination to try out. </span><span class="koboSpan" id="kobo.3141.3">Let’s see it in action. </span><span class="koboSpan" id="kobo.3141.4">The code is very close to what we ran before, and is available at </span><strong class="source-inline"><span class="koboSpan" id="kobo.3142.1">ch03/io-interface2/main.go</span></strong><span class="koboSpan" id="kobo.3143.1"> (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.3144.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.3145.1">):</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.3146.1">func</span></span><span class="koboSpan" id="kobo.3147.1"> main() {
    res, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.3148.1">=</span></span><span class="koboSpan" id="kobo.3149.1"> http.Get(</span><span class="Code_Red"><span class="koboSpan" id="kobo.3150.1">"https://www.tkng.io/"</span></span><span class="koboSpan" id="kobo.3151.1">)
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3152.1">if</span></span><span class="koboSpan" id="kobo.3153.1"> err </span><span class="Code_Red"><span class="koboSpan" id="kobo.3154.1">!=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.3155.1">nil</span></span><span class="koboSpan" id="kobo.3156.1"> {
        </span><span class="Code_Blue"><span class="koboSpan" id="kobo.3157.1">panic</span></span><span class="koboSpan" id="kobo.3158.1">(err)
    }
    src :</span><span class="Code_Red"><span class="koboSpan" id="kobo.3159.1">=</span></span><span class="koboSpan" id="kobo.3160.1"> res.Body
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3161.1">defer</span></span><span class="koboSpan" id="kobo.3162.1"> src.Close()
    dst :</span><span class="Code_Red"><span class="koboSpan" id="kobo.3163.1">=</span></span><span class="koboSpan" id="kobo.3164.1"> os.Stdout
    io.Copy(dst, src)
}</span></pre>
<p><span class="koboSpan" id="kobo.3165.1">The </span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.3166.1">same </span><strong class="source-inline"><span class="koboSpan" id="kobo.3167.1">io.Copy</span></strong><span class="koboSpan" id="kobo.3168.1"> function now allows us to take the content from a URL and print it to </span><span class="No-Break"><span class="koboSpan" id="kobo.3169.1">the terminal:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.3170.1">ch03/io-interface2$ go run main.go
&lt;!doctype html&gt;</span><span class="Code_Green"><span class="koboSpan" id="kobo.3171.1">&lt;html</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.3172.1">lang</span></span><span class="koboSpan" id="kobo.3173.1">=</span><span class="Code_Blue"><span class="koboSpan" id="kobo.3174.1">en</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.3175.1">class</span></span><span class="koboSpan" id="kobo.3176.1">=</span><span class="Code_Red"><span class="koboSpan" id="kobo.3177.1">"js csstransforms3d"&gt;&lt;head&gt;&lt;meta</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.3178.1">charset</span></span><span class="koboSpan" id="kobo.3179.1">=</span><span class="Code_Blue"><span class="koboSpan" id="kobo.3180.1">utf-8</span></span><span class="Code_Green"><span class="koboSpan" id="kobo.3181.1">&gt;&lt;meta</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.3182.1">name</span></span><span class="koboSpan" id="kobo.3183.1">=</span><span class="Code_Blue"><span class="koboSpan" id="kobo.3184.1">viewport content</span></span><span class="koboSpan" id="kobo.3185.1">=</span><span class="Code_Red"><span class="koboSpan" id="kobo.3186.1">"width=device-width,initial-scale=1"</span></span><span class="Code_Green"><span class="koboSpan" id="kobo.3187.1">&gt;&lt;meta</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.3188.1">name</span></span><span class="koboSpan" id="kobo.3189.1">=</span><span class="Code_Blue"><span class="koboSpan" id="kobo.3190.1">generator content</span></span><span class="koboSpan" id="kobo.3191.1">=</span><span class="Code_Red"><span class="koboSpan" id="kobo.3192.1">"Hugo 0.74.3"</span></span><span class="Code_Green"><span class="koboSpan" id="kobo.3193.1">&gt;&lt;meta</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.3194.1">name</span></span><span class="koboSpan" id="kobo.3195.1">=</span><span class="Code_Blue"><span class="koboSpan" id="kobo.3196.1">description content</span></span><span class="koboSpan" id="kobo.3197.1">=</span><span class="Code_Red"><span class="koboSpan" id="kobo.3198.1">"The Kubernetes Networking Guide"</span></span><span class="Code_Green"><span class="koboSpan" id="kobo.3199.1">&gt;</span></span><span class="koboSpan" id="kobo.3200.1">...</span></pre>
<p><span class="koboSpan" id="kobo.3201.1">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.3202.1">io.Copy</span></strong><span class="koboSpan" id="kobo.3203.1">, we move data from one point to another. </span><span class="koboSpan" id="kobo.3203.2">Now, we need to add another piece to the puzzle to transform the data as we </span><span class="No-Break"><span class="koboSpan" id="kobo.3204.1">stream it.</span></span></p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.3205.1">Composition</span></h2>
<p><span class="koboSpan" id="kobo.3206.1">One way to transform</span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.3207.1"> the data as we stream it is by embedding one struct type into another, which we know as </span><strong class="bold"><span class="koboSpan" id="kobo.3208.1">composition</span></strong><span class="koboSpan" id="kobo.3209.1">. </span><span class="koboSpan" id="kobo.3209.2">This way, we can chain together several </span><strong class="source-inline"><span class="koboSpan" id="kobo.3210.1">io.Reader</span></strong><span class="koboSpan" id="kobo.3211.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.3212.1">io.Writer</span></strong><span class="koboSpan" id="kobo.3213.1"> interfaces to perform one or more operations and not just copy the data from source </span><span class="No-Break"><span class="koboSpan" id="kobo.3214.1">to destination.</span></span></p>
<p><span class="koboSpan" id="kobo.3215.1">The benefit of following this pattern is to write reusable segments of code, which you can use for any </span><strong class="source-inline"><span class="koboSpan" id="kobo.3216.1">io.Reader</span></strong><span class="koboSpan" id="kobo.3217.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.3218.1">io.Writer</span></strong><span class="koboSpan" id="kobo.3219.1"> interface in this case. </span><span class="koboSpan" id="kobo.3219.2">Let’s look at the example at </span><strong class="source-inline"><span class="koboSpan" id="kobo.3220.1">ch03/reader/main.go</span></strong><span class="koboSpan" id="kobo.3221.1"> (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.3222.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.3223.1">):</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.3224.1">type</span></span><span class="koboSpan" id="kobo.3225.1"> myReader </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3226.1">struct</span></span><span class="koboSpan" id="kobo.3227.1"> {
    src io.Reader
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.3228.1">func</span></span><span class="koboSpan" id="kobo.3229.1"> (r </span><span class="Code_Red"><span class="koboSpan" id="kobo.3230.1">*</span></span><span class="koboSpan" id="kobo.3231.1">myReader) Read(buf []</span><span class="Code_Purple"><span class="koboSpan" id="kobo.3232.1">byte</span></span><span class="koboSpan" id="kobo.3233.1">) (</span><span class="Code_Purple"><span class="koboSpan" id="kobo.3234.1">int</span></span><span class="koboSpan" id="kobo.3235.1">, </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3236.1">error</span></span><span class="koboSpan" id="kobo.3237.1">) {
    tmp :</span><span class="Code_Red"><span class="koboSpan" id="kobo.3238.1">=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.3239.1">make</span></span><span class="koboSpan" id="kobo.3240.1">([]</span><span class="Code_Purple"><span class="koboSpan" id="kobo.3241.1">byte</span></span><span class="koboSpan" id="kobo.3242.1">, len(buf))
    n, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.3243.1">=</span></span><span class="koboSpan" id="kobo.3244.1"> r.src.Read(tmp)
    </span><span class="Code_Blue"><span class="koboSpan" id="kobo.3245.1">copy</span></span><span class="koboSpan" id="kobo.3246.1">(buf[:n], bytes.Title(tmp[:n]))
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3247.1">return</span></span><span class="koboSpan" id="kobo.3248.1"> n, err
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.3249.1">func</span></span><span class="koboSpan" id="kobo.3250.1"> NewMyReader(r io.Reader) io.Reader {
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3251.1">return</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.3252.1">&amp;</span></span><span class="koboSpan" id="kobo.3253.1">myReader{src: r}
}</span></pre>
<p><span class="koboSpan" id="kobo.3254.1">We define</span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.3255.1"> a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.3256.1">myReader</span></strong><span class="koboSpan" id="kobo.3257.1"> type with a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.3258.1">src</span></strong><span class="koboSpan" id="kobo.3259.1"> field of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3260.1">io.Reader</span></strong><span class="koboSpan" id="kobo.3261.1"> type. </span><span class="koboSpan" id="kobo.3261.2">In Go, when we embed a type, the methods of that type become methods of the outer type, so </span><strong class="source-inline"><span class="koboSpan" id="kobo.3262.1">myReader</span></strong><span class="koboSpan" id="kobo.3263.1"> has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.3264.1">Read</span></strong><span class="koboSpan" id="kobo.3265.1"> method from </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.3266.1">src</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.3267.1"> now.</span></span></p>
<p><span class="koboSpan" id="kobo.3268.1">But, we want to change the behavior and do something with the data. </span><span class="koboSpan" id="kobo.3268.2">Hence, we define a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.3269.1">Read</span></strong><span class="koboSpan" id="kobo.3270.1"> method that takes precedence over any other more deeply nested method part of </span><span class="No-Break"><span class="koboSpan" id="kobo.3271.1">the type.</span></span></p>
<p><span class="koboSpan" id="kobo.3272.1">In this </span><strong class="source-inline"><span class="koboSpan" id="kobo.3273.1">Read</span></strong><span class="koboSpan" id="kobo.3274.1"> method, we read from the buffer and convert it to title case with </span><strong class="source-inline"><span class="koboSpan" id="kobo.3275.1">bytes.Title</span></strong><span class="koboSpan" id="kobo.3276.1">, assuming we are working with strings. </span><span class="koboSpan" id="kobo.3276.2">Last but not least, </span><strong class="source-inline"><span class="koboSpan" id="kobo.3277.1">NewMyReader</span></strong><span class="koboSpan" id="kobo.3278.1"> is what glues together an existing reader with this new one, connecting the dots between two pieces of code. </span><span class="koboSpan" id="kobo.3278.2">Let’s see it </span><span class="No-Break"><span class="koboSpan" id="kobo.3279.1">in action:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.3280.1">func</span></span><span class="koboSpan" id="kobo.3281.1"> main() {
    r1 :</span><span class="Code_Red"><span class="koboSpan" id="kobo.3282.1">=</span></span><span class="koboSpan" id="kobo.3283.1"> strings.NewReader(</span><span class="Code_Red"><span class="koboSpan" id="kobo.3284.1">"network automation with go"</span></span><span class="koboSpan" id="kobo.3285.1">)
    r2 :</span><span class="Code_Red"><span class="koboSpan" id="kobo.3286.1">=</span></span><span class="koboSpan" id="kobo.3287.1"> NewMyReader(r1)
    io.Copy(os.Stdout, r2)
}</span></pre>
<p><span class="koboSpan" id="kobo.3288.1">We create a reader from a string in </span><strong class="source-inline"><span class="koboSpan" id="kobo.3289.1">r1</span></strong><span class="koboSpan" id="kobo.3290.1"> and then use that as the input for </span><strong class="source-inline"><span class="koboSpan" id="kobo.3291.1">myReader</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.3292.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.3293.1">r2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.3294.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.3295.1">ch03/reader</span><span class="Code_Blue"><span class="koboSpan" id="kobo.3296.1">$ </span></span><span class="koboSpan" id="kobo.3297.1">go run main.go
Network Automation With Go</span></pre>
<p><span class="koboSpan" id="kobo.3298.1">When we</span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.3299.1"> now copy from </span><strong class="source-inline"><span class="koboSpan" id="kobo.3300.1">r2</span></strong><span class="koboSpan" id="kobo.3301.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.3302.1">os.Stdout</span></strong><span class="koboSpan" id="kobo.3303.1">, we read from the string and also change the content to title case before writing it to </span><span class="No-Break"><span class="koboSpan" id="kobo.3304.1">the terminal.</span></span></p>
<p><span class="koboSpan" id="kobo.3305.1">Input and output primitives are present in almost every Go library. </span><span class="koboSpan" id="kobo.3305.2">The next section is no exception. </span><span class="koboSpan" id="kobo.3305.3">Encoding and decoding in Go take full advantage of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3306.1">io.Reader</span></strong><span class="koboSpan" id="kobo.3307.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.3308.1">io.Writer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.3309.1"> interfaces.</span></span></p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.3310.1">Decoding and encoding</span></h1>
<p><span class="koboSpan" id="kobo.3311.1">One of the most common network automation tasks is the ingesting and processing of structured data. </span><span class="koboSpan" id="kobo.3311.2">You can retrieve data from or send it to a remote location or even store it on a local disk. </span><span class="koboSpan" id="kobo.3311.3">Regardless of its location, you have to convert this data into an appropriate format. </span><span class="koboSpan" id="kobo.3311.4">Encoding, or marshaling, is the process of transforming bytes from a Go data structure into a structured textual representation. </span><span class="koboSpan" id="kobo.3311.5">Decoding, or unmarshalling, is the reverse process of populating Go values with externally </span><span class="No-Break"><span class="koboSpan" id="kobo.3312.1">sourced data.</span></span></p>
<p><span class="koboSpan" id="kobo.3313.1">Some examples of structured data encoding schemes are YAML, JSON, XML, and Protocol Buffers. </span><span class="koboSpan" id="kobo.3313.2">Go’s standard library includes packages that implement encoding and decoding for most of these popular formats, and they all leverage the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3314.1">io.Reader</span></strong><span class="koboSpan" id="kobo.3315.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.3316.1">io.Writer</span></strong><span class="koboSpan" id="kobo.3317.1"> interface primitives that we learned about in the </span><span class="No-Break"><span class="koboSpan" id="kobo.3318.1">last section.</span></span></p>
<p><span class="koboSpan" id="kobo.3319.1">In this section, we go through how Go deals with the </span><span class="No-Break"><span class="koboSpan" id="kobo.3320.1">following tasks:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.3321.1">Using tags to annotate Go structs to help libraries encode and decode </span><span class="No-Break"><span class="koboSpan" id="kobo.3322.1">structured data</span></span></li>
<li><span class="koboSpan" id="kobo.3323.1">Parsing of structured data using the </span><span class="No-Break"><span class="koboSpan" id="kobo.3324.1">empty interface</span></span></li>
<li><span class="koboSpan" id="kobo.3325.1">Performing deeply nested set and lookup operations using </span><span class="No-Break"><span class="koboSpan" id="kobo.3326.1">third-party libraries</span></span></li>
</ul>
<h2 id="_idParaDest-100"><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.3327.1">Decoding</span></h2>
<p><span class="koboSpan" id="kobo.3328.1">We start </span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.3329.1">our overview with decoding, as this is usually one of the first steps in a network automation pipeline. </span><span class="koboSpan" id="kobo.3329.2">Let’s assume that we’re building a program that needs to interact with various remote network devices. </span><span class="koboSpan" id="kobo.3329.3">We store the information of these devices in an inventory file we save on a </span><span class="No-Break"><span class="koboSpan" id="kobo.3330.1">local disk.</span></span></p>
<h3><span class="koboSpan" id="kobo.3331.1">Decoding JSON</span></h3>
<p><span class="koboSpan" id="kobo.3332.1">In the</span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.3333.1"> first example, we</span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.3334.1"> see how to deal with a JSON inventory (</span><strong class="source-inline"><span class="koboSpan" id="kobo.3335.1">input.json</span></strong><span class="koboSpan" id="kobo.3336.1">). </span><span class="koboSpan" id="kobo.3336.2">All outputs of this part are available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3337.1">ch03/json</span></strong><span class="koboSpan" id="kobo.3338.1"> folder of the book’s repository (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.3339.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.3340.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.3341.1">{
  "router": [
    {
      "hostname": </span><span class="Code_Red"><span class="koboSpan" id="kobo.3342.1">"router1.example.com"</span></span><span class="koboSpan" id="kobo.3343.1">,
      "ip": </span><span class="Code_Red"><span class="koboSpan" id="kobo.3344.1">"192.0.2.1"</span></span><span class="koboSpan" id="kobo.3345.1">,
      "asn": </span><span class="Code_Green"><span class="koboSpan" id="kobo.3346.1">64512</span></span><span class="koboSpan" id="kobo.3347.1">
    },
    {
      "hostname": </span><span class="Code_Red"><span class="koboSpan" id="kobo.3348.1">"router2.example.com"</span></span><span class="koboSpan" id="kobo.3349.1">,
      "ip": </span><span class="Code_Red"><span class="koboSpan" id="kobo.3350.1">"198.51.100.1"</span></span><span class="koboSpan" id="kobo.3351.1">,
      "asn": </span><span class="Code_Green"><span class="koboSpan" id="kobo.3352.1">65535</span></span><span class="koboSpan" id="kobo.3353.1">
    }
  ]
}</span></pre>
<p><span class="koboSpan" id="kobo.3354.1">In the first code example in </span><strong class="source-inline"><span class="koboSpan" id="kobo.3355.1">ch03/json/main.go</span></strong><span class="koboSpan" id="kobo.3356.1"> (see </span><em class="italic"><span class="koboSpan" id="kobo.3357.1">Further reading</span></em><span class="koboSpan" id="kobo.3358.1">), we define a couple of Go structs that can hold the JSON input data from the preceding output in memory. </span><span class="koboSpan" id="kobo.3358.2">We call the first type </span><strong class="source-inline"><span class="koboSpan" id="kobo.3359.1">Router</span></strong><span class="koboSpan" id="kobo.3360.1">, which has </span><strong class="source-inline"><span class="koboSpan" id="kobo.3361.1">Hostname</span></strong><span class="koboSpan" id="kobo.3362.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.3363.1">IP</span></strong><span class="koboSpan" id="kobo.3364.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.3365.1">ASN</span></strong><span class="koboSpan" id="kobo.3366.1"> fields. </span><span class="koboSpan" id="kobo.3366.2">The other type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.3367.1">Inventory</span></strong><span class="koboSpan" id="kobo.3368.1">, which stores a list of routers. </span><span class="koboSpan" id="kobo.3368.2">The fields in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3369.1">Router</span></strong><span class="koboSpan" id="kobo.3370.1"> type have optional tags such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.3371.1">json:"key"</span></strong><span class="koboSpan" id="kobo.3372.1"> to denote alternative key names in the original </span><span class="No-Break"><span class="koboSpan" id="kobo.3373.1">JSON </span></span><span class="No-Break"><a id="_idIndexMarker297"/></span><span class="No-Break"><span class="koboSpan" id="kobo.3374.1">structure:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.3375.1">type</span></span><span class="koboSpan" id="kobo.3376.1"> Router </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3377.1">struct</span></span><span class="koboSpan" id="kobo.3378.1"> {
    Hostname </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3379.1">string</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.3380.1">`json:"hostname"`</span></span><span class="koboSpan" id="kobo.3381.1">
    IP       </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3382.1">string</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.3383.1">`json:"ip"`</span></span><span class="koboSpan" id="kobo.3384.1">
    ASN      </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3385.1">uint16</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.3386.1">`json:"asn"`</span></span><span class="koboSpan" id="kobo.3387.1">
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.3388.1">type</span></span><span class="koboSpan" id="kobo.3389.1"> Inventory </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3390.1">struct</span></span><span class="koboSpan" id="kobo.3391.1"> {
    Routers []Router </span><span class="Code_Red"><span class="koboSpan" id="kobo.3392.1">`json:"router"`</span></span><span class="koboSpan" id="kobo.3393.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.3394.1">To read from a file, we</span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.3395.1"> create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.3396.1">io.Reader</span></strong><span class="koboSpan" id="kobo.3397.1"> type (</span><strong class="source-inline"><span class="koboSpan" id="kobo.3398.1">file</span></strong><span class="koboSpan" id="kobo.3399.1">) from the input file </span><span class="No-Break"><span class="koboSpan" id="kobo.3400.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.3401.1">os.Open</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.3402.1">:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.3403.1">func</span></span><span class="koboSpan" id="kobo.3404.1"> main() {
    file, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.3405.1">=</span></span><span class="koboSpan" id="kobo.3406.1"> os.Open(</span><span class="Code_Red"><span class="koboSpan" id="kobo.3407.1">"input.json"</span></span><span class="koboSpan" id="kobo.3408.1">)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.3409.1">// process error</span></span><span class="koboSpan" id="kobo.3410.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3411.1">defer</span></span><span class="koboSpan" id="kobo.3412.1"> file.Close()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.3413.1">/* ... </span><span class="koboSpan" id="kobo.3413.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.3413.3">*/</span></span><span class="koboSpan" id="kobo.3414.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.3415.1">Now, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3416.1">json</span></strong><span class="koboSpan" id="kobo.3417.1"> library, as well as any other encoding library, has a function that allows you to pass an </span><strong class="source-inline"><span class="koboSpan" id="kobo.3418.1">io.Reader</span></strong><span class="koboSpan" id="kobo.3419.1"> type as an argument to extract data from it. </span><span class="koboSpan" id="kobo.3419.2">This means it can decode from a file, a string, a network connection, or anything else that implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3420.1">io.Reader</span></strong><span class="koboSpan" id="kobo.3421.1"> interface with the same </span><span class="No-Break"><span class="koboSpan" id="kobo.3422.1">function call:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.3423.1">func</span></span><span class="koboSpan" id="kobo.3424.1"> main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.3425.1">/* ... </span><span class="koboSpan" id="kobo.3425.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.3425.3">*/</span></span><span class="koboSpan" id="kobo.3426.1">
    d :</span><span class="Code_Red"><span class="koboSpan" id="kobo.3427.1">=</span></span><span class="koboSpan" id="kobo.3428.1"> json.NewDecoder(file)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.3429.1">/* ... </span><span class="koboSpan" id="kobo.3429.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.3429.3">*/</span></span><span class="koboSpan" id="kobo.3430.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.3431.1">Once you’ve created a decoder, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3432.1">Decode</span></strong><span class="koboSpan" id="kobo.3433.1"> method to read and parse the contents of the </span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.3434.1">JSON file into a variable (</span><strong class="source-inline"><span class="koboSpan" id="kobo.3435.1">inv</span></strong><span class="koboSpan" id="kobo.3436.1">) of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3437.1">Inventory</span></strong><span class="koboSpan" id="kobo.3438.1"> type. </span><span class="koboSpan" id="kobo.3438.2">Remember, to</span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.3439.1"> mutate the data struct, you need to pass it as </span><span class="No-Break"><span class="koboSpan" id="kobo.3440.1">a pointer:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.3441.1">func</span></span> <strong class="bold"><span class="koboSpan" id="kobo.3442.1">main</span></strong><span class="koboSpan" id="kobo.3443.1">() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.3444.1">/* ... </span><span class="koboSpan" id="kobo.3444.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.3444.3">*/</span></span><span class="koboSpan" id="kobo.3445.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3446.1">var</span></span><span class="koboSpan" id="kobo.3447.1"> inv Inventory
    err </span><span class="Code_Red"><span class="koboSpan" id="kobo.3448.1">=</span></span><span class="koboSpan" id="kobo.3449.1"> d.Decode(</span><span class="Code_Red"><span class="koboSpan" id="kobo.3450.1">&amp;</span></span><span class="koboSpan" id="kobo.3451.1">inv)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.3452.1">// process error</span></span><span class="koboSpan" id="kobo.3453.1">
    fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.3454.1">"%+v\n"</span></span><span class="koboSpan" id="kobo.3455.1">, inv)
}</span></pre>
<p><span class="koboSpan" id="kobo.3456.1">If you print the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3457.1">inv</span></strong><span class="koboSpan" id="kobo.3458.1"> variable now, you would see it populate with data from the inventory </span><span class="No-Break"><span class="koboSpan" id="kobo.3459.1">JSON file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.3460.1">ch03/json</span><span class="Code_Blue"><span class="koboSpan" id="kobo.3461.1">$ </span></span><span class="koboSpan" id="kobo.3462.1">go run main.go
{Routers:[{Hostname:router1.example.com IP:192.0.2.1 ASN:64512} {Hostname:router2.example.com IP:198.51.100.1 ASN:65535}]}</span></pre>
<h3><span class="koboSpan" id="kobo.3463.1">Decoding into an empty interface</span></h3>
<p><span class="koboSpan" id="kobo.3464.1">The </span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.3465.1">field tags we’ve just seen are a very convenient way to map data during encoding and decoding. </span><span class="koboSpan" id="kobo.3465.2">The condition to have all Go types predefined ahead of time offers type safety, but at the same time, you can see it as a major detractor if you are coming from another language where the decoding process does not </span><span class="No-Break"><span class="koboSpan" id="kobo.3466.1">need this.</span></span></p>
<p><span class="koboSpan" id="kobo.3467.1">But, you can also skip this in Go, with a few caveats that we discuss later. </span><span class="koboSpan" id="kobo.3467.2">To show you how it works, we use a slightly different version of an earlier example. </span><span class="koboSpan" id="kobo.3467.3">This new version is available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3468.1">ch03/json-interface</span></strong><span class="koboSpan" id="kobo.3469.1"> folder (see </span><em class="italic"><span class="koboSpan" id="kobo.3470.1">Further reading</span></em><span class="koboSpan" id="kobo.3471.1">). </span><span class="koboSpan" id="kobo.3471.2">Instead of defining all Go structs, we use a special variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3472.1">map[string]interface{}</span></strong><span class="koboSpan" id="kobo.3473.1"> type and</span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.3474.1"> pass it as an argument to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3475.1">Decode</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.3476.1">method call:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.3477.1">func</span></span><span class="koboSpan" id="kobo.3478.1"> main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.3479.1">/* ... </span><span class="koboSpan" id="kobo.3479.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.3479.3">*/</span></span><span class="koboSpan" id="kobo.3480.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3481.1">var</span></span><span class="koboSpan" id="kobo.3482.1"> empty </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3483.1">map</span></span><span class="koboSpan" id="kobo.3484.1">[</span><span class="Code_Purple"><span class="koboSpan" id="kobo.3485.1">string</span></span><span class="koboSpan" id="kobo.3486.1">]</span><span class="Code_Purple"><span class="koboSpan" id="kobo.3487.1">interface</span></span><span class="koboSpan" id="kobo.3488.1">{}
    err </span><span class="Code_Blue"><span class="koboSpan" id="kobo.3489.1">=</span></span><span class="koboSpan" id="kobo.3490.1"> d.Decode(</span><span class="Code_Red"><span class="koboSpan" id="kobo.3491.1">&amp;</span></span><span class="koboSpan" id="kobo.3492.1">empty)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.3493.1">// process error</span></span><span class="koboSpan" id="kobo.3494.1">
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.3495.1">// prints map[router:[map[asn:64512 hostname:router1.example.com</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.3496.1">    // ip:192.0.2.1] map[asn:65535 hostname:router2.example.com</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.3497.1">    // ip:198.51.100.1]]]</span></span><span class="koboSpan" id="kobo.3498.1">
    fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.3499.1">"%v\n"</span></span><span class="koboSpan" id="kobo.3500.1">, empty)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.3501.1">/* ... </span><span class="koboSpan" id="kobo.3501.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.3501.3">*/</span></span><span class="koboSpan" id="kobo.3502.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.3503.1">An </span><em class="italic"><span class="koboSpan" id="kobo.3504.1">empty interface</span></em><span class="koboSpan" id="kobo.3505.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.3506.1">interface{}</span></strong><span class="koboSpan" id="kobo.3507.1">, doesn’t define any methods, which means it can hold any value — </span><strong class="source-inline"><span class="koboSpan" id="kobo.3508.1">integer</span></strong><span class="koboSpan" id="kobo.3509.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.3510.1">string</span></strong><span class="koboSpan" id="kobo.3511.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.3512.1">float</span></strong><span class="koboSpan" id="kobo.3513.1">, or user-defined. </span><span class="koboSpan" id="kobo.3513.2">The only caveat is that, since Go is a statically typed language, those values remain an empty interface until we do an explicit type conversion, that is, until we tell Go what type we expect </span><span class="No-Break"><span class="koboSpan" id="kobo.3514.1">to see.</span></span></p>
<p><span class="koboSpan" id="kobo.3515.1">From the output of the empty variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3516.1">map[string]interface{}</span></strong><span class="koboSpan" id="kobo.3517.1"> type, where we decoded the JSON content in the preceding example, we see that the value of the map we print is an array. </span><span class="koboSpan" id="kobo.3517.2">To parse these values and print them individually, we’d have to tell Go to treat them as a slice of unknown values, which you can express </span><span class="No-Break"><span class="koboSpan" id="kobo.3518.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.3519.1">[]interface{}</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.3520.1">:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.3521.1">func</span></span><span class="koboSpan" id="kobo.3522.1"> main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.3523.1">/* ... </span><span class="koboSpan" id="kobo.3523.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.3523.3">*/</span></span><span class="koboSpan" id="kobo.3524.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3525.1">for</span></span><span class="koboSpan" id="kobo.3526.1"> _, r :</span><span class="Code_Red"><span class="koboSpan" id="kobo.3527.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.3528.1">range</span></span><span class="koboSpan" id="kobo.3529.1"> empty[</span><span class="Code_Red"><span class="koboSpan" id="kobo.3530.1">"router"</span></span><span class="koboSpan" id="kobo.3531.1">].([]</span><span class="Code_Purple"><span class="koboSpan" id="kobo.3532.1">interface</span></span><span class="koboSpan" id="kobo.3533.1">{}) {
        fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.3534.1">"%v\n"</span></span><span class="koboSpan" id="kobo.3535.1">, r)
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.3536.1">The</span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.3537.1"> output of these print statements is the string representation of two </span><strong class="source-inline"><span class="koboSpan" id="kobo.3538.1">map[string]interface{}</span></strong><span class="koboSpan" id="kobo.3539.1"> maps, which means we’ve only parsed the keys (as strings), but the values are </span><span class="No-Break"><span class="koboSpan" id="kobo.3540.1">still undefined:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.3541.1">ch03/json-interface </span><span class="Code_Blue"><span class="koboSpan" id="kobo.3542.1">$ </span></span><span class="koboSpan" id="kobo.3543.1">go run main.go
...
</span><span class="koboSpan" id="kobo.3543.2">map[asn:64512 hostname:router1.example.com ip:192.0.2.1]
map[asn:65535 hostname:router2.example.com ip:198.51.100.1]</span></pre>
<p><span class="koboSpan" id="kobo.3544.1">We could continue this process until we find the right type for all values of this object, but this process is obviously quite tedious. </span><span class="koboSpan" id="kobo.3544.2">This is why we mainly see this approach in encoding libraries or as a troubleshooting step to take a quick glance at the structure of the potentially unknown </span><span class="No-Break"><span class="koboSpan" id="kobo.3545.1">input data.</span></span></p>
<p><span class="koboSpan" id="kobo.3546.1">Another option for quick operations with JSON data is external Go packages, which you can use to perform deep</span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.3547.1"> JSON lookup (</span><strong class="bold"><span class="koboSpan" id="kobo.3548.1">GJSON</span></strong><span class="koboSpan" id="kobo.3549.1">) and set (</span><strong class="bold"><span class="koboSpan" id="kobo.3550.1">SJSON</span></strong><span class="koboSpan" id="kobo.3551.1">) operations without having to </span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.3552.1">build structs for the entire object. </span><span class="koboSpan" id="kobo.3552.2">In both cases, the parsing still happens behind the scenes, but the user is only presented with their data or an error if the key doesn’t exist. </span><span class="koboSpan" id="kobo.3552.3">We use GJSON (see </span><em class="italic"><span class="koboSpan" id="kobo.3553.1">Further reading</span></em><span class="koboSpan" id="kobo.3554.1">) in a gRPC example in </span><a href="B16971_08.xhtml#_idTextAnchor182"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.3555.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.3556.1">, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.3557.1">Network APIs</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.3558.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.3559.1">Decoding XML</span></h3>
<p><span class="koboSpan" id="kobo.3560.1">While the</span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.3561.1"> XML input file looks different, the data is the same and the Go program </span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.3562.1">doesn’t change much. </span><span class="koboSpan" id="kobo.3562.2">The next example is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3563.1">ch03/xml</span></strong><span class="koboSpan" id="kobo.3564.1"> folder of the book’s repository (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.3565.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.3566.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.3567.1">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
</span><span class="Code_Green"><span class="koboSpan" id="kobo.3568.1">&lt;routers&gt;</span></span><span class="koboSpan" id="kobo.3569.1">
  </span><span class="Code_Red"><span class="koboSpan" id="kobo.3570.1">&lt;router&gt;</span></span><span class="koboSpan" id="kobo.3571.1">
    </span><span class="Code_Green"><span class="koboSpan" id="kobo.3572.1">&lt;hostname&gt;</span></span><span class="koboSpan" id="kobo.3573.1">router1.example.com</span><span class="Code_Green"><span class="koboSpan" id="kobo.3574.1">&lt;/hostname&gt;</span></span><span class="koboSpan" id="kobo.3575.1">
    </span><span class="Code_Green"><span class="koboSpan" id="kobo.3576.1">&lt;ip&gt;</span></span><span class="koboSpan" id="kobo.3577.1">192.0.2.1</span><span class="Code_Green"><span class="koboSpan" id="kobo.3578.1">&lt;/ip&gt;</span></span><span class="koboSpan" id="kobo.3579.1">
    </span><span class="Code_Green"><span class="koboSpan" id="kobo.3580.1">&lt;asn&gt;</span></span><span class="koboSpan" id="kobo.3581.1">64512</span><span class="Code_Green"><span class="koboSpan" id="kobo.3582.1">&lt;/asn&gt;</span></span><span class="koboSpan" id="kobo.3583.1">
  </span><span class="Code_Green"><span class="koboSpan" id="kobo.3584.1">&lt;/router&gt;</span></span><span class="koboSpan" id="kobo.3585.1">
  </span><span class="Code_Green"><span class="koboSpan" id="kobo.3586.1">&lt;router&gt;</span></span><span class="koboSpan" id="kobo.3587.1">
    </span><span class="Code_Green"><span class="koboSpan" id="kobo.3588.1">&lt;hostname&gt;</span></span><span class="koboSpan" id="kobo.3589.1">router2.example.com</span><span class="Code_Green"><span class="koboSpan" id="kobo.3590.1">&lt;/hostname&gt;</span></span><span class="koboSpan" id="kobo.3591.1">
    </span><span class="Code_Green"><span class="koboSpan" id="kobo.3592.1">&lt;ip&gt;</span></span><span class="koboSpan" id="kobo.3593.1">198.51.100.1</span><span class="Code_Green"><span class="koboSpan" id="kobo.3594.1">&lt;/ip&gt;</span></span><span class="koboSpan" id="kobo.3595.1">
    </span><span class="Code_Green"><span class="koboSpan" id="kobo.3596.1">&lt;asn&gt;</span></span><span class="koboSpan" id="kobo.3597.1">65535</span><span class="Code_Green"><span class="koboSpan" id="kobo.3598.1">&lt;/asn&gt;</span></span><span class="koboSpan" id="kobo.3599.1">
  </span><span class="Code_Green"><span class="koboSpan" id="kobo.3600.1">&lt;/router&gt;</span></span>
<span class="Code_Green"><span class="koboSpan" id="kobo.3601.1">&lt;/routers&gt;</span></span></pre>
<p><span class="koboSpan" id="kobo.3602.1">If we</span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.3603.1"> compared </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.3604.1">the final program with the one we did for JSON, we would notice </span><span class="No-Break"><span class="koboSpan" id="kobo.3605.1">four changes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.3606.1">We import </span><strong class="source-inline"><span class="koboSpan" id="kobo.3607.1">encoding/xml</span></strong><span class="koboSpan" id="kobo.3608.1"> instead </span><span class="No-Break"><span class="koboSpan" id="kobo.3609.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.3610.1">encoding/json</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.3611.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.3612.1">We use XML tags </span><strong class="source-inline"><span class="koboSpan" id="kobo.3613.1">xml:"hostname"</span></strong><span class="koboSpan" id="kobo.3614.1"> instead of the JSON equivalents for </span><span class="No-Break"><span class="koboSpan" id="kobo.3615.1">struct fields.</span></span></li>
<li><span class="koboSpan" id="kobo.3616.1">The input file is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.3617.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.3618.1">xml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.3619.1"> file.</span></span></li>
<li><span class="koboSpan" id="kobo.3620.1">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3621.1">NewDecoder</span></strong><span class="koboSpan" id="kobo.3622.1"> function from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3623.1">xml</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.3624.1">library instead.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.3625.1">The rest of the code remains exactly the same. </span><span class="koboSpan" id="kobo.3625.2">The next code output highlights the actual lines that change; we omitted the rest of the lines as they are the same as in the </span><span class="No-Break"><span class="koboSpan" id="kobo.3626.1">JSON example:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.3627.1">package</span></span><span class="koboSpan" id="kobo.3628.1"> main
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.3629.1">import</span></span><span class="koboSpan" id="kobo.3630.1"> (
    </span><span class="Code_Red"><span class="koboSpan" id="kobo.3631.1">"os"</span></span><span class="koboSpan" id="kobo.3632.1">
    </span><span class="Code_Red"><span class="koboSpan" id="kobo.3633.1">"encoding/xml"</span></span><span class="koboSpan" id="kobo.3634.1">
)
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.3635.1">type</span></span><span class="koboSpan" id="kobo.3636.1"> Router </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3637.1">struct</span></span><span class="koboSpan" id="kobo.3638.1"> {
    Hostname </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3639.1">string</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.3640.1">`xml:"hostname"`</span></span><span class="koboSpan" id="kobo.3641.1">
    IP       </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3642.1">string</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.3643.1">`xml:"ip"`</span></span><span class="koboSpan" id="kobo.3644.1">
    ASN      </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3645.1">uint16</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.3646.1">`xml:"asn"`</span></span><span class="koboSpan" id="kobo.3647.1">
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.3648.1">type</span></span><span class="koboSpan" id="kobo.3649.1"> Inventory </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3650.1">struct</span></span><span class="koboSpan" id="kobo.3651.1"> {
    Routers []Router </span><span class="Code_Red"><span class="koboSpan" id="kobo.3652.1">`xml:"router"`</span></span><span class="koboSpan" id="kobo.3653.1">
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.3654.1">func</span></span><span class="koboSpan" id="kobo.3655.1"> main() {
    file, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.3656.1">=</span></span><span class="koboSpan" id="kobo.3657.1"> os.Open(</span><span class="Code_Red"><span class="koboSpan" id="kobo.3658.1">"input.xml"</span></span><span class="koboSpan" id="kobo.3659.1">)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.3660.1">/* ... </span><span class="koboSpan" id="kobo.3660.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.3660.3">*/</span></span><span class="koboSpan" id="kobo.3661.1">
    d :</span><span class="Code_Red"><span class="koboSpan" id="kobo.3662.1">=</span></span><span class="koboSpan" id="kobo.3663.1"> xml.NewDecoder(file)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.3664.1">/* ... </span><span class="koboSpan" id="kobo.3664.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.3664.3">*/</span></span><span class="koboSpan" id="kobo.3665.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.3666.1">Just like </span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.3667.1">JSON, XML </span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.3668.1">has its own external libraries that can help you deal with complex input data without having to build the hierarchy of Go types. </span><span class="koboSpan" id="kobo.3668.2">One of them is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3669.1">xmlquery</span></strong><span class="koboSpan" id="kobo.3670.1"> package (see </span><em class="italic"><span class="koboSpan" id="kobo.3671.1">Further reading</span></em><span class="koboSpan" id="kobo.3672.1">), which lets you make XML Path Language (XPath) queries </span><span class="No-Break"><span class="koboSpan" id="kobo.3673.1">from Go.</span></span></p>
<h3><span class="koboSpan" id="kobo.3674.1">YAML</span></h3>
<p><span class="koboSpan" id="kobo.3675.1">Now, let’s look </span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.3676.1">at how we would parse a YAML inventory. </span><span class="koboSpan" id="kobo.3676.2">You can find this</span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.3677.1"> example in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3678.1">ch03/yaml</span></strong><span class="koboSpan" id="kobo.3679.1"> directory of the book’s repository (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.3680.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.3681.1">):</span></span></p>
<pre class="source-code"><span class="Code_Blue"><span class="koboSpan" id="kobo.3682.1">router</span></span><span class="koboSpan" id="kobo.3683.1">:
  - </span><span class="Code_Blue"><span class="koboSpan" id="kobo.3684.1">hostname</span></span><span class="koboSpan" id="kobo.3685.1">: </span><span class="Code_Red"><span class="koboSpan" id="kobo.3686.1">"router1.example.com"</span></span><span class="koboSpan" id="kobo.3687.1">
    </span><span class="Code_Blue"><span class="koboSpan" id="kobo.3688.1">ip</span></span><span class="koboSpan" id="kobo.3689.1">: </span><span class="Code_Red"><span class="koboSpan" id="kobo.3690.1">"192.0.2.1"</span></span><span class="koboSpan" id="kobo.3691.1">
    </span><span class="Code_Blue"><span class="koboSpan" id="kobo.3692.1">asn</span></span><span class="koboSpan" id="kobo.3693.1">: </span><span class="Code_Green"><span class="koboSpan" id="kobo.3694.1">64512</span></span><span class="koboSpan" id="kobo.3695.1">
  - </span><span class="Code_Blue"><span class="koboSpan" id="kobo.3696.1">hostname</span></span><span class="koboSpan" id="kobo.3697.1">: </span><span class="Code_Red"><span class="koboSpan" id="kobo.3698.1">"router2.example.com"</span></span><span class="koboSpan" id="kobo.3699.1">
    </span><span class="Code_Blue"><span class="koboSpan" id="kobo.3700.1">ip</span></span><span class="koboSpan" id="kobo.3701.1">: </span><span class="Code_Red"><span class="koboSpan" id="kobo.3702.1">"198.51.100.1"</span></span><span class="koboSpan" id="kobo.3703.1">
    </span><span class="Code_Blue"><span class="koboSpan" id="kobo.3704.1">asn</span></span><span class="koboSpan" id="kobo.3705.1">: </span><span class="Code_Green"><span class="koboSpan" id="kobo.3706.1">65535</span></span></pre>
<p><span class="koboSpan" id="kobo.3707.1">By now, you would probably already have guessed that the number and nature of things that change from the JSON example are the same as for XML, which is to say, not much. </span><span class="koboSpan" id="kobo.3707.2">The following code snippet highlights only the changed lines of code, and you can find the full code example at </span><strong class="source-inline"><span class="koboSpan" id="kobo.3708.1">ch03/yaml/main.go</span></strong><span class="koboSpan" id="kobo.3709.1"> (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.3710.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.3711.1">):</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.3712.1">package</span></span><span class="koboSpan" id="kobo.3713.1"> main
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.3714.1">import</span></span><span class="koboSpan" id="kobo.3715.1"> (
    </span><span class="Code_Red"><span class="koboSpan" id="kobo.3716.1">"os"</span></span><span class="koboSpan" id="kobo.3717.1">
    </span><span class="Code_Red"><span class="koboSpan" id="kobo.3718.1">"gopkg.in/yaml.v2"</span></span><span class="koboSpan" id="kobo.3719.1">
)
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.3720.1">type</span></span><span class="koboSpan" id="kobo.3721.1"> Router </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3722.1">struct</span></span><span class="koboSpan" id="kobo.3723.1"> {
    Hostname </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3724.1">string</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.3725.1">`yaml:"hostname"`</span></span><span class="koboSpan" id="kobo.3726.1">
    IP       </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3727.1">string</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.3728.1">`yaml:"ip"`</span></span><span class="koboSpan" id="kobo.3729.1">
    ASN      </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3730.1">uint16</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.3731.1">`yaml:"asn"`</span></span><span class="koboSpan" id="kobo.3732.1">
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.3733.1">type</span></span><span class="koboSpan" id="kobo.3734.1"> Inventory </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3735.1">struct</span></span><span class="koboSpan" id="kobo.3736.1"> {
    Routers []Router </span><span class="Code_Red"><span class="koboSpan" id="kobo.3737.1">`yaml:"router"`</span></span><span class="koboSpan" id="kobo.3738.1">
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.3739.1">func</span></span><span class="koboSpan" id="kobo.3740.1"> main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.3741.1">/* ... </span><span class="koboSpan" id="kobo.3741.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.3741.3">*/</span></span><span class="koboSpan" id="kobo.3742.1">
    d :</span><span class="Code_Red"><span class="koboSpan" id="kobo.3743.1">=</span></span><span class="koboSpan" id="kobo.3744.1"> yaml.NewDecoder(file)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.3745.1">/* ... </span><span class="koboSpan" id="kobo.3745.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.3745.3">*/</span></span><span class="koboSpan" id="kobo.3746.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.3747.1">This </span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.3748.1">Go program </span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.3749.1">produces the same result as both the JSON and XML examples, but before we can run it, we need to go get the external YAML library dependency </span><span class="No-Break"><span class="koboSpan" id="kobo.3750.1">first (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.3751.1">gopkg.in/yaml.v2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.3752.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.3753.1">ch03/yaml</span><span class="Code_Blue"><span class="koboSpan" id="kobo.3754.1">$ </span></span><span class="koboSpan" id="kobo.3755.1">go get gopkg.in/yaml.v2
go </span><span class="Code_Blue"><span class="koboSpan" id="kobo.3756.1">get</span></span><span class="koboSpan" id="kobo.3757.1">: added gopkg.in/yaml.v2 v2.4.0
ch03/yaml</span><span class="Code_Blue"><span class="koboSpan" id="kobo.3758.1">$ </span></span><span class="koboSpan" id="kobo.3759.1">go run main.go
{Routers:[{Hostname:router1.example.com IP:192.0.2.1 ASN:64512} {Hostname:router2.example.com IP:198.51.100.1 ASN:65535}]}</span></pre>
<p><span class="koboSpan" id="kobo.3760.1">It’s also possible to parse and query YAML documents without having to predefine data structures. </span><span class="koboSpan" id="kobo.3760.2">One tool that does that is </span><strong class="source-inline"><span class="koboSpan" id="kobo.3761.1">yq</span></strong><span class="koboSpan" id="kobo.3762.1"> (see </span><em class="italic"><span class="koboSpan" id="kobo.3763.1">Further reading</span></em><span class="koboSpan" id="kobo.3764.1">), which implements a shell CLI tool in Go in the style of </span><strong class="source-inline"><span class="koboSpan" id="kobo.3765.1">jq</span></strong><span class="koboSpan" id="kobo.3766.1"> (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3767.1">sed</span></strong><span class="koboSpan" id="kobo.3768.1"> for JSON data). </span><span class="koboSpan" id="kobo.3768.2">You can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.3769.1">yq</span></strong><span class="koboSpan" id="kobo.3770.1"> in your Go program via its built-in </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.3771.1">yqlib</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.3772.1"> package.</span></span></p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.3773.1">Encoding</span></h2>
<p><span class="koboSpan" id="kobo.3774.1">Just as </span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.3775.1">important as being able to decode data from a source is processing the data in the opposite direction, producing a structured data document based on an in-memory data model. </span><span class="koboSpan" id="kobo.3775.2">In the next example, we pick up where we left off in the </span><em class="italic"><span class="koboSpan" id="kobo.3776.1">Decoding</span></em><span class="koboSpan" id="kobo.3777.1"> section and take the in-memory data we got from a JSON input file to output a corresponding </span><span class="No-Break"><span class="koboSpan" id="kobo.3778.1">XML document.</span></span></p>
<p><span class="koboSpan" id="kobo.3779.1">One of the first things we have to do in the code is to update the struct tags with an extra key-value pair for XML. </span><span class="koboSpan" id="kobo.3779.2">Although this is not strictly necessary, as the XML library can fall back to using field names instead, it’s generally considered a best practice to annotate explicitly all relevant fields that </span><span class="No-Break"><span class="koboSpan" id="kobo.3780.1">you encode:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.3781.1">type</span></span><span class="koboSpan" id="kobo.3782.1"> Router </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3783.1">struct</span></span><span class="koboSpan" id="kobo.3784.1"> {
    Hostname </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3785.1">string</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.3786.1">`json:"hostname" xml:"hostname"`</span></span><span class="koboSpan" id="kobo.3787.1">
    IP       </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3788.1">string</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.3789.1">`json:"ip" xml:"ip"`</span></span><span class="koboSpan" id="kobo.3790.1">
    ASN      </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3791.1">uint16</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.3792.1">`json:"asn" xml:"asn"`</span></span><span class="koboSpan" id="kobo.3793.1">
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.3794.1">type</span></span><span class="koboSpan" id="kobo.3795.1"> Inventory </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3796.1">struct</span></span><span class="koboSpan" id="kobo.3797.1"> {
    Routers []Router `json:"router" xml:"router"`
}</span></pre>
<p><span class="koboSpan" id="kobo.3798.1">The full code of this example is available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3799.1">ch03/json-xml</span></strong><span class="koboSpan" id="kobo.3800.1"> directory (see </span><em class="italic"><span class="koboSpan" id="kobo.3801.1">Further reading</span></em><span class="koboSpan" id="kobo.3802.1">) of the book’s repository, so for the sake of brevity, we only include the extra code that we add to encode the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3803.1">inv</span></strong><span class="koboSpan" id="kobo.3804.1"> variable into an </span><span class="No-Break"><span class="koboSpan" id="kobo.3805.1">XML document:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.3806.1">func</span></span><span class="koboSpan" id="kobo.3807.1"> main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.3808.1">/* ... </span><span class="koboSpan" id="kobo.3808.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.3808.3">*/</span></span><span class="koboSpan" id="kobo.3809.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3810.1">var</span></span><span class="koboSpan" id="kobo.3811.1"> dest strings.Builder
    e :</span><span class="Code_Red"><span class="koboSpan" id="kobo.3812.1">=</span></span><span class="koboSpan" id="kobo.3813.1"> xml.NewEncoder(</span><span class="Code_Red"><span class="koboSpan" id="kobo.3814.1">&amp;</span></span><span class="koboSpan" id="kobo.3815.1">dest)
    err </span><span class="Code_Red"><span class="koboSpan" id="kobo.3816.1">=</span></span><span class="koboSpan" id="kobo.3817.1"> e.Encode(</span><span class="Code_Red"><span class="koboSpan" id="kobo.3818.1">&amp;</span></span><span class="koboSpan" id="kobo.3819.1">inv)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.3820.1">// process error</span></span><span class="koboSpan" id="kobo.3821.1">
    fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.3822.1">"%+v\n"</span></span><span class="koboSpan" id="kobo.3823.1">, dest.String())
}</span></pre>
<p><span class="koboSpan" id="kobo.3824.1">To </span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.3825.1">produce a string output, we’re using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3826.1">strings.Builder</span></strong><span class="koboSpan" id="kobo.3827.1"> type, which implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3828.1">io.Writer</span></strong><span class="koboSpan" id="kobo.3829.1"> interface required by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3830.1">Encode</span></strong><span class="koboSpan" id="kobo.3831.1"> method. </span><span class="koboSpan" id="kobo.3831.2">This highlights the power of interfaces, as we could have passed in a network connection and sent the XML data to a remote host instead, with almost the same program. </span><span class="koboSpan" id="kobo.3831.3">The next snippet shows the output of </span><span class="No-Break"><span class="koboSpan" id="kobo.3832.1">the program:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.3833.1">ch03/json-xml$ go run main.go
</span><span class="Code_Green"><span class="koboSpan" id="kobo.3834.1">&lt;Inventory&gt;&lt;router&gt;&lt;hostname&gt;</span></span><span class="koboSpan" id="kobo.3835.1">router1.example.com</span><span class="Code_Green"><span class="koboSpan" id="kobo.3836.1">&lt;/hostname&gt;&lt;ip&gt;</span></span><span class="koboSpan" id="kobo.3837.1">192.0.2.1</span><span class="Code_Green"><span class="koboSpan" id="kobo.3838.1">&lt;/ip&gt;&lt;asn&gt;</span></span><span class="koboSpan" id="kobo.3839.1">64512</span><span class="Code_Green"><span class="koboSpan" id="kobo.3840.1">&lt;/asn&gt;&lt;/router&gt;&lt;router&gt;&lt;hostname&gt;</span></span><span class="koboSpan" id="kobo.3841.1">router2.example.com</span><span class="Code_Green"><span class="koboSpan" id="kobo.3842.1">&lt;/hostname&gt;&lt;ip&gt;</span></span><span class="koboSpan" id="kobo.3843.1">198.51.100.1</span><span class="Code_Green"><span class="koboSpan" id="kobo.3844.1">&lt;/ip&gt;&lt;asn&gt;</span></span><span class="koboSpan" id="kobo.3845.1">65535</span><span class="Code_Green"><span class="koboSpan" id="kobo.3846.1">&lt;/asn&gt;&lt;/router&gt;&lt;/Inventory&gt;</span></span></pre>
<p><span class="koboSpan" id="kobo.3847.1">One encoding format we haven’t covered yet is Protocol Buffers, which is part of the gRPC section of </span><a href="B16971_08.xhtml#_idTextAnchor182"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.3848.1">Chapter 8</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.3849.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.3850.1">At this point, we’ve covered enough Go language theory to write effective programs to interact with and automate a network device. </span><span class="koboSpan" id="kobo.3850.2">The only bit that we have left, which is also one of the most salient features of the language, </span><span class="No-Break"><span class="koboSpan" id="kobo.3851.1">is concurrency.</span></span></p>
<h1 id="_idParaDest-102"><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.3852.1">Concurrency</span></h1>
<p><span class="koboSpan" id="kobo.3853.1">If there</span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.3854.1"> was one feature that would characterize Go amongst other popular programming languages, it would be concurrency. </span><span class="koboSpan" id="kobo.3854.2">Go’s built-in concurrency primitives (goroutines and channels) are one of the best abstractions we know for writing efficient code that can run more than one </span><span class="No-Break"><span class="koboSpan" id="kobo.3855.1">task simultaneously.</span></span></p>
<p><span class="koboSpan" id="kobo.3856.1">Your program starts in the main goroutine, but at any point, you can spawn other concurrent goroutines and create communication channels between them. </span><span class="koboSpan" id="kobo.3856.2">You can do this with considerably less effort and less code compared to other programming languages, which improves the developing experience and your </span><span class="No-Break"><span class="koboSpan" id="kobo.3857.1">code’s support:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer043">
<span class="koboSpan" id="kobo.3858.1"><img alt="Figure 3.12 – Go’s concurrency" src="image/Figure_3.121.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.3859.1">Figure 3.12 – Go’s concurrency</span></p>
<p><span class="koboSpan" id="kobo.3860.1">In this section, we </span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.3861.1">cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.3862.1">concurrency primitives:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.3863.1">Goroutines and the use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3864.1">sync</span></strong><span class="koboSpan" id="kobo.3865.1"> package for </span><span class="No-Break"><span class="koboSpan" id="kobo.3866.1">their coordination</span></span></li>
<li><span class="koboSpan" id="kobo.3867.1">How we use channels to send and receive data </span><span class="No-Break"><span class="koboSpan" id="kobo.3868.1">between goroutines</span></span></li>
<li><span class="koboSpan" id="kobo.3869.1">The use of mutexes with data shared between </span><span class="No-Break"><span class="koboSpan" id="kobo.3870.1">different goroutines</span></span></li>
</ul>
<h2 id="_idParaDest-103"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.3871.1">Goroutines</span></h2>
<p><span class="koboSpan" id="kobo.3872.1">One way</span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.3873.1"> to </span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.3874.1">think of Goroutines is as user-space threads that the Go runtime manages. </span><span class="koboSpan" id="kobo.3874.2">They are computationally cheap to spawn and manage, so they can scale to hundreds of thousands, even on an average machine, with memory being the primary </span><span class="No-Break"><span class="koboSpan" id="kobo.3875.1">limiting factor.</span></span></p>
<p><span class="koboSpan" id="kobo.3876.1">It’s typical to create goroutines for tasks that may block the execution of the main function. </span><span class="koboSpan" id="kobo.3876.2">You can imagine why this would be particularly helpful in a network automation context, where we have to deal with remote network calls and wait for network devices to execute </span><span class="No-Break"><span class="koboSpan" id="kobo.3877.1">the commands.</span></span></p>
<p><span class="koboSpan" id="kobo.3878.1">We introduce the basic goroutine theory by building another network automation example. </span><span class="koboSpan" id="kobo.3878.2">In the preceding section, we learned how to load and parse a device inventory. </span><span class="koboSpan" id="kobo.3878.3">In this</span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.3879.1"> section, we pick up where we left off and see how to interact with these </span><span class="No-Break"><span class="koboSpan" id="kobo.3880.1">network devices.</span></span></p>
<p><span class="koboSpan" id="kobo.3881.1">To start off, we</span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.3882.1"> use an inventory file (</span><strong class="source-inline"><span class="koboSpan" id="kobo.3883.1">input.yml</span></strong><span class="koboSpan" id="kobo.3884.1">) with a single device. </span><span class="koboSpan" id="kobo.3884.2">This file is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3885.1">ch03/single</span></strong><span class="koboSpan" id="kobo.3886.1"> folder (see </span><em class="italic"><span class="koboSpan" id="kobo.3887.1">Further reading</span></em><span class="koboSpan" id="kobo.3888.1">) of the </span><span class="No-Break"><span class="koboSpan" id="kobo.3889.1">book’s repository:</span></span></p>
<pre class="source-code"><span class="Code_Blue"><span class="koboSpan" id="kobo.3890.1">router</span></span><span class="koboSpan" id="kobo.3891.1">:
- </span><span class="Code_Blue"><span class="koboSpan" id="kobo.3892.1">hostname</span></span><span class="koboSpan" id="kobo.3893.1">: sandbox-iosxe-latest-1.cisco.com
  </span><span class="Code_Blue"><span class="koboSpan" id="kobo.3894.1">platform</span></span><span class="koboSpan" id="kobo.3895.1">: cisco_iosxe
  </span><span class="Code_Blue"><span class="koboSpan" id="kobo.3896.1">strictkey</span></span><span class="koboSpan" id="kobo.3897.1">: </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3898.1">false</span></span><span class="koboSpan" id="kobo.3899.1">
  </span><span class="Code_Blue"><span class="koboSpan" id="kobo.3900.1">username</span></span><span class="koboSpan" id="kobo.3901.1">: developer
  </span><span class="Code_Blue"><span class="koboSpan" id="kobo.3902.1">password</span></span><span class="koboSpan" id="kobo.3903.1">: C1sco12345</span></pre>
<p><span class="koboSpan" id="kobo.3904.1">To store this inventory, we define a type hierarchy like the one we had in the encoding/decoding section. </span><span class="koboSpan" id="kobo.3904.2">The code example output only shows some fields </span><span class="No-Break"><span class="koboSpan" id="kobo.3905.1">for brevity:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.3906.1">type</span></span><span class="koboSpan" id="kobo.3907.1"> Router </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3908.1">struct</span></span><span class="koboSpan" id="kobo.3909.1"> {
    Hostname  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3910.1">string</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.3911.1">`yaml:"hostname"`</span></span><span class="koboSpan" id="kobo.3912.1">
    /* ... </span><span class="koboSpan" id="kobo.3912.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.3912.3">*/
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.3913.1">type</span></span><span class="koboSpan" id="kobo.3914.1"> Inventory </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3915.1">struct</span></span><span class="koboSpan" id="kobo.3916.1"> {
    Routers []Router </span><span class="Code_Red"><span class="koboSpan" id="kobo.3917.1">`yaml:"router"`</span></span><span class="koboSpan" id="kobo.3918.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.3919.1">We define another function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.3920.1">getVersion</span></strong><span class="koboSpan" id="kobo.3921.1"> that accepts an argument of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3922.1">Router</span></strong><span class="koboSpan" id="kobo.3923.1"> type, connects and retrieves the software and hardware version information, and prints it on a screen. </span><span class="koboSpan" id="kobo.3923.2">The exact implementation of this function is not important and we don’t focus on it in this chapter yet, but you can see the full code example at </span><strong class="source-inline"><span class="koboSpan" id="kobo.3924.1">ch03/single/main.go</span></strong><span class="koboSpan" id="kobo.3925.1"> (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.3926.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.3927.1">):</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.3928.1">func</span></span><span class="koboSpan" id="kobo.3929.1"> getVersion(r Router) {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.3930.1">/* ... </span><span class="koboSpan" id="kobo.3930.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.3930.3">*/</span></span><span class="koboSpan" id="kobo.3931.1">
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.3932.1">func</span></span><span class="koboSpan" id="kobo.3933.1"> main() {
    src, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.3934.1">=</span></span><span class="koboSpan" id="kobo.3935.1"> os.Open(</span><span class="Code_Red"><span class="koboSpan" id="kobo.3936.1">"input.yml"</span></span><span class="koboSpan" id="kobo.3937.1">)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.3938.1">//process error</span></span><span class="koboSpan" id="kobo.3939.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3940.1">defer</span></span><span class="koboSpan" id="kobo.3941.1"> src.Close()
    d :</span><span class="Code_Red"><span class="koboSpan" id="kobo.3942.1">=</span></span><span class="koboSpan" id="kobo.3943.1"> yaml.NewDecoder(src)
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.3944.1">var</span></span><span class="koboSpan" id="kobo.3945.1"> inv Inventory
    err </span><span class="Code_Red"><span class="koboSpan" id="kobo.3946.1">=</span></span><span class="koboSpan" id="kobo.3947.1"> d.Decode(&amp;inv)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.3948.1">// process error</span></span><span class="koboSpan" id="kobo.3949.1">
    getVersion(inv.Routers[</span><span class="Code_Green"><span class="koboSpan" id="kobo.3950.1">0</span></span><span class="koboSpan" id="kobo.3951.1">])
}</span></pre>
<p><span class="koboSpan" id="kobo.3952.1">Since </span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.3953.1">we only </span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.3954.1">have one device in the inventory, we can access it directly using a slice index. </span><span class="koboSpan" id="kobo.3954.2">The execution of this program takes a little under </span><span class="No-Break"><span class="koboSpan" id="kobo.3955.1">2 seconds:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.3956.1">ch03/single$ go run main.go
Hostname: sandbox-iosxe-latest-1.cisco.com
Hardware: [CSR1000V]
SW Version: </span><span class="Code_Green"><span class="koboSpan" id="kobo.3957.1">17</span></span><span class="koboSpan" id="kobo.3958.1">.3.1a
Uptime: </span><span class="Code_Green"><span class="koboSpan" id="kobo.3959.1">5</span></span><span class="koboSpan" id="kobo.3960.1"> hours, </span><span class="Code_Green"><span class="koboSpan" id="kobo.3961.1">1</span></span><span class="koboSpan" id="kobo.3962.1"> minute
This process took </span><span class="Code_Green"><span class="koboSpan" id="kobo.3963.1">1</span></span><span class="koboSpan" id="kobo.3964.1">.779684183s</span></pre>
<p><span class="koboSpan" id="kobo.3965.1">Now, let’s look at a </span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.3966.1">similar example, stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3967.1">ch03/sequential</span></strong><span class="koboSpan" id="kobo.3968.1"> directory (see </span><em class="italic"><span class="koboSpan" id="kobo.3969.1">Further reading</span></em><span class="koboSpan" id="kobo.3970.1">), where we’ve added two extra devices to</span><a id="_idIndexMarker327"/> <span class="No-Break"><span class="koboSpan" id="kobo.3971.1">the inventory:</span></span></p>
<pre class="source-code"><span class="Code_Blue"><span class="koboSpan" id="kobo.3972.1">router</span></span><span class="koboSpan" id="kobo.3973.1">:
- </span><span class="Code_Blue"><span class="koboSpan" id="kobo.3974.1">hostname</span></span><span class="koboSpan" id="kobo.3975.1">: sandbox-iosxe-latest-1.cisco.com
  </span><span class="Code_Blue"><span class="koboSpan" id="kobo.3976.1">platform</span></span><span class="koboSpan" id="kobo.3977.1">: cisco_iosxe
  ...
</span><span class="koboSpan" id="kobo.3977.2">- </span><span class="Code_Blue"><span class="koboSpan" id="kobo.3978.1">hostname</span></span><span class="koboSpan" id="kobo.3979.1">: sandbox-nxos-1.cisco.com
  </span><span class="Code_Blue"><span class="koboSpan" id="kobo.3980.1">platform</span></span><span class="koboSpan" id="kobo.3981.1">: cisco_nxos
  ...
</span><span class="koboSpan" id="kobo.3981.2">- </span><span class="Code_Blue"><span class="koboSpan" id="kobo.3982.1">hostname</span></span><span class="koboSpan" id="kobo.3983.1">: sandbox-iosxr-1.cisco.com
  </span><span class="Code_Blue"><span class="koboSpan" id="kobo.3984.1">platform</span></span><span class="koboSpan" id="kobo.3985.1">: cisco_iosxr
  ...</span></pre>
<p><span class="koboSpan" id="kobo.3986.1">As we discussed in the </span><em class="italic"><span class="koboSpan" id="kobo.3987.1">Control flow</span></em><span class="koboSpan" id="kobo.3988.1"> section, we can iterate over arrays and slices with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3989.1">range</span></strong><span class="koboSpan" id="kobo.3990.1"> form of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.3991.1">for</span></strong><span class="koboSpan" id="kobo.3992.1"> loop. </span><span class="koboSpan" id="kobo.3992.2">Here, we iterate over each </span><strong class="source-inline"><span class="koboSpan" id="kobo.3993.1">Router</span></strong><span class="koboSpan" id="kobo.3994.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.3995.1">inv.Routers</span></strong><span class="koboSpan" id="kobo.3996.1">, assigning it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.3997.1">v</span></strong><span class="koboSpan" id="kobo.3998.1"> variable in each iteration. </span><span class="koboSpan" id="kobo.3998.2">We ignore the value of the index by assigning it to the blank identifier written as </span><strong class="source-inline"><span class="koboSpan" id="kobo.3999.1">_</span></strong><span class="koboSpan" id="kobo.4000.1"> (underscore). </span><span class="koboSpan" id="kobo.4000.2">Finally, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4001.1">getVersion</span></strong><span class="koboSpan" id="kobo.4002.1"> function for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4003.1">v</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4004.1"> router:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.4005.1">func</span></span><span class="koboSpan" id="kobo.4006.1"> main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.4007.1">/* ... </span><span class="koboSpan" id="kobo.4007.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.4007.3">*/</span></span><span class="koboSpan" id="kobo.4008.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4009.1">for</span></span><span class="koboSpan" id="kobo.4010.1"> _, r :</span><span class="Code_Red"><span class="koboSpan" id="kobo.4011.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.4012.1">range</span></span><span class="koboSpan" id="kobo.4013.1"> inv.Routers {
        getVersion(v)
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.4014.1">It takes around 7 seconds to execute as it connects to one device </span><span class="No-Break"><span class="koboSpan" id="kobo.4015.1">after another:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.4016.1">ch03/sequential$ go run main.go
Hostname: sandbox-iosxe-latest-1.cisco.com
Hardware: [CSR1000V]
SW Version: </span><span class="Code_Green"><span class="koboSpan" id="kobo.4017.1">17</span></span><span class="koboSpan" id="kobo.4018.1">.3.1a
Uptime: </span><span class="Code_Green"><span class="koboSpan" id="kobo.4019.1">5</span></span><span class="koboSpan" id="kobo.4020.1"> hours, </span><span class="Code_Green"><span class="koboSpan" id="kobo.4021.1">25</span></span><span class="koboSpan" id="kobo.4022.1"> minutes
Hostname: sandbox-nxos-1.cisco.com
Hardware: C9300v
SW Version: </span><span class="Code_Green"><span class="koboSpan" id="kobo.4023.1">9</span></span><span class="koboSpan" id="kobo.4024.1">.3(3)
Uptime: </span><span class="Code_Green"><span class="koboSpan" id="kobo.4025.1">0</span></span><span class="koboSpan" id="kobo.4026.1"> day(s), </span><span class="Code_Green"><span class="koboSpan" id="kobo.4027.1">3</span></span><span class="koboSpan" id="kobo.4028.1"> hour(s), </span><span class="Code_Green"><span class="koboSpan" id="kobo.4029.1">2</span></span><span class="koboSpan" id="kobo.4030.1"> minute(s), </span><span class="Code_Green"><span class="koboSpan" id="kobo.4031.1">18</span></span><span class="koboSpan" id="kobo.4032.1"> second(s)
Hostname: sandbox-iosxr-1.cisco.com
Hardware: IOS-XRv 9000
SW Version: </span><span class="Code_Green"><span class="koboSpan" id="kobo.4033.1">6</span></span><span class="koboSpan" id="kobo.4034.1">.5.3
Uptime: </span><span class="Code_Green"><span class="koboSpan" id="kobo.4035.1">2</span></span><span class="koboSpan" id="kobo.4036.1"> weeks </span><span class="Code_Green"><span class="koboSpan" id="kobo.4037.1">8</span></span><span class="koboSpan" id="kobo.4038.1"> hours </span><span class="Code_Green"><span class="koboSpan" id="kobo.4039.1">23</span></span><span class="koboSpan" id="kobo.4040.1"> minutes
This process took </span><span class="Code_Green"><span class="koboSpan" id="kobo.4041.1">6</span></span><span class="koboSpan" id="kobo.4042.1">.984502353s</span></pre>
<p><span class="koboSpan" id="kobo.4043.1">This is a </span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.4044.1">prime</span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.4045.1"> example of code that we could optimize through the use of goroutines. </span><span class="koboSpan" id="kobo.4045.2">All we need to do initially is to add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.4046.1">go</span></strong><span class="koboSpan" id="kobo.4047.1"> keyword before the statement that we need to run in </span><span class="No-Break"><span class="koboSpan" id="kobo.4048.1">a goroutine:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.4049.1">func</span></span><span class="koboSpan" id="kobo.4050.1"> main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.4051.1">/* ... </span><span class="koboSpan" id="kobo.4051.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.4051.3">*/</span></span><span class="koboSpan" id="kobo.4052.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4053.1">for</span></span><span class="koboSpan" id="kobo.4054.1"> _, r :</span><span class="Code_Red"><span class="koboSpan" id="kobo.4055.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.4056.1">range</span></span><span class="koboSpan" id="kobo.4057.1"> inv.Routers {
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4058.1">go</span></span><span class="koboSpan" id="kobo.4059.1"> getVersion(v)
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.4060.1">In the code example, we spawn a separate goroutine for each invocation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4061.1">getVersion</span></strong><span class="koboSpan" id="kobo.4062.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.4063.1">v</span></strong><span class="koboSpan" id="kobo.4064.1">) statement. </span><span class="koboSpan" id="kobo.4064.2">Everything happens in the background; any blocking statement inside a spawned goroutine does not affect the other goroutines, so all three function calls, plus the main goroutine, now </span><span class="No-Break"><span class="koboSpan" id="kobo.4065.1">run concurrently.</span></span></p>
<p><span class="koboSpan" id="kobo.4066.1">The default</span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.4067.1"> behavior of these spawned goroutines is to release </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.4068.1">control immediately, so in this example, the code iterates over all three devices and then returns. </span><span class="koboSpan" id="kobo.4068.2">It doesn’t actually wait for the spawned goroutines </span><span class="No-Break"><span class="koboSpan" id="kobo.4069.1">to complete.</span></span></p>
<p><span class="koboSpan" id="kobo.4070.1">But, in our case, we’d like to see the result of all three function calls before we exit the program. </span><span class="koboSpan" id="kobo.4070.2">This is where we can use a special </span><strong class="source-inline"><span class="koboSpan" id="kobo.4071.1">sync.WaitGroup</span></strong><span class="koboSpan" id="kobo.4072.1"> type, which blocks the main goroutine until all spawned goroutines complete. </span><span class="koboSpan" id="kobo.4072.2">It does this by keeping a counter that tracks all currently active goroutines and blocks until that counter goes down </span><span class="No-Break"><span class="koboSpan" id="kobo.4073.1">to zero.</span></span></p>
<p><span class="koboSpan" id="kobo.4074.1">This is what we do to introduce this idea in the code example we are </span><span class="No-Break"><span class="koboSpan" id="kobo.4075.1">working with:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.4076.1">We create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.4077.1">wg</span></strong><span class="koboSpan" id="kobo.4078.1"> variable of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4079.1">sync.WaitGroup</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4080.1"> type.</span></span></li>
<li><span class="koboSpan" id="kobo.4081.1">While iterating through our inventory, we increase the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4082.1">WaitGroup</span></strong><span class="koboSpan" id="kobo.4083.1"> counter by one </span><span class="No-Break"><span class="koboSpan" id="kobo.4084.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4085.1">wg.Add(1)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4086.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.4087.1">Each spawned goroutine consists of an anonymous function that runs </span><strong class="source-inline"><span class="koboSpan" id="kobo.4088.1">getVersion</span></strong><span class="koboSpan" id="kobo.4089.1">, but also calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.4090.1">wg.Done</span></strong><span class="koboSpan" id="kobo.4091.1"> at the very end to decrement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4092.1">WaitGroup</span></strong><span class="koboSpan" id="kobo.4093.1"> counter by one with a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4094.1">defer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4095.1"> statement.</span></span></li>
<li><span class="koboSpan" id="kobo.4096.1">The main goroutine blocks on </span><strong class="source-inline"><span class="koboSpan" id="kobo.4097.1">wg.Wait</span></strong><span class="koboSpan" id="kobo.4098.1"> until the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4099.1">WaitGroup</span></strong><span class="koboSpan" id="kobo.4100.1"> counter becomes zero. </span><span class="koboSpan" id="kobo.4100.2">This happens after all the spawned instances of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4101.1">getVersion</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.4102.1">functions return.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.4103.1">You can find the full code of this example at </span><strong class="source-inline"><span class="koboSpan" id="kobo.4104.1">ch03/concurrency/main.go</span></strong><span class="koboSpan" id="kobo.4105.1"> (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4106.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.4107.1">):</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.4108.1">func</span></span><span class="koboSpan" id="kobo.4109.1"> main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.4110.1">/* ... </span><span class="koboSpan" id="kobo.4110.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.4110.3">*/</span></span><span class="koboSpan" id="kobo.4111.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4112.1">var</span></span><span class="koboSpan" id="kobo.4113.1"> wg sync.WaitGroup
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4114.1">for</span></span><span class="koboSpan" id="kobo.4115.1"> _, v :</span><span class="Code_Red"><span class="koboSpan" id="kobo.4116.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.4117.1">range</span></span><span class="koboSpan" id="kobo.4118.1"> inv.Routers {
        wg.Add(1)
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4119.1">go func</span></span><span class="koboSpan" id="kobo.4120.1">(r Router) {
            </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4121.1">defer</span></span><span class="koboSpan" id="kobo.4122.1"> wg.Done()
            getVersion(r)
        }(v)
    }
    wg.Wait()
}</span></pre>
<p><span class="koboSpan" id="kobo.4123.1">Now, let’s </span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.4124.1">see what effect these changes have on the execution time</span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.4125.1"> of </span><span class="No-Break"><span class="koboSpan" id="kobo.4126.1">the program:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.4127.1">ch03/concurrency</span><span class="Code_Blue"><span class="koboSpan" id="kobo.4128.1">$ </span></span><span class="Code_Blue"><span class="koboSpan" id="kobo.4129.1">go</span></span><span class="koboSpan" id="kobo.4130.1"> run main.go
Hostname: sandbox-iosxe-latest-1.cisco.com
Hardware: [CSR1000V]
SW Version: </span><span class="Code_Green"><span class="koboSpan" id="kobo.4131.1">17</span></span><span class="koboSpan" id="kobo.4132.1">.3.1a
Uptime: </span><span class="Code_Green"><span class="koboSpan" id="kobo.4133.1">5</span></span><span class="koboSpan" id="kobo.4134.1"> hours, </span><span class="Code_Green"><span class="koboSpan" id="kobo.4135.1">26</span></span><span class="koboSpan" id="kobo.4136.1"> minutes
Hostname: sandbox-iosxr-1.cisco.com
Hardware: IOS-XRv </span><span class="Code_Green"><span class="koboSpan" id="kobo.4137.1">9000</span></span><span class="koboSpan" id="kobo.4138.1">
SW Version: </span><span class="Code_Green"><span class="koboSpan" id="kobo.4139.1">6</span></span><span class="koboSpan" id="kobo.4140.1">.5.3
Uptime: </span><span class="Code_Green"><span class="koboSpan" id="kobo.4141.1">2</span></span><span class="koboSpan" id="kobo.4142.1"> weeks </span><span class="Code_Green"><span class="koboSpan" id="kobo.4143.1">8</span></span><span class="koboSpan" id="kobo.4144.1"> hours </span><span class="Code_Green"><span class="koboSpan" id="kobo.4145.1">25</span></span><span class="koboSpan" id="kobo.4146.1"> minutes
Hostname: sandbox-nxos-1.cisco.com
Hardware: C9300v
SW Version: </span><span class="Code_Green"><span class="koboSpan" id="kobo.4147.1">9</span></span><span class="koboSpan" id="kobo.4148.1">.3(3)
Uptime: </span><span class="Code_Green"><span class="koboSpan" id="kobo.4149.1">0</span></span><span class="koboSpan" id="kobo.4150.1"> day(s), </span><span class="Code_Green"><span class="koboSpan" id="kobo.4151.1">3</span></span><span class="koboSpan" id="kobo.4152.1"> hour(s), </span><span class="Code_Green"><span class="koboSpan" id="kobo.4153.1">4</span></span><span class="koboSpan" id="kobo.4154.1"> minute(s), </span><span class="Code_Green"><span class="koboSpan" id="kobo.4155.1">11</span></span><span class="koboSpan" id="kobo.4156.1"> second(s)
This process took </span><span class="Code_Green"><span class="koboSpan" id="kobo.4157.1">2</span></span><span class="koboSpan" id="kobo.4158.1">.746996304s</span></pre>
<p><span class="koboSpan" id="kobo.4159.1">We’ve gone </span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.4160.1">down to roughly 3 seconds, which is how long it took to </span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.4161.1">communicate with the slowest device in the inventory. </span><span class="koboSpan" id="kobo.4161.2">This is a pretty significant win, considering we didn’t have to change any of the </span><em class="italic"><span class="koboSpan" id="kobo.4162.1">worker</span></em><span class="koboSpan" id="kobo.4163.1"> functions (</span><strong class="source-inline"><span class="koboSpan" id="kobo.4164.1">getVersion</span></strong><span class="koboSpan" id="kobo.4165.1"> in this case). </span><span class="koboSpan" id="kobo.4165.2">You might apply the same refactoring to many other similar programs with minimal changes to their existing </span><span class="No-Break"><span class="koboSpan" id="kobo.4166.1">code bases.</span></span></p>
<p><span class="koboSpan" id="kobo.4167.1">This approach works well with natively synchronous functions that you can run with or without a goroutine. </span><span class="koboSpan" id="kobo.4167.2">But, if we know that a certain function always runs in a goroutine, it’s totally possible to make it goroutine-aware from the very beginning. </span><span class="koboSpan" id="kobo.4167.3">For example, this is how we could have refactored the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4168.1">getVersion</span></strong><span class="koboSpan" id="kobo.4169.1"> function to accept an extra </span><strong class="source-inline"><span class="koboSpan" id="kobo.4170.1">WaitGroup</span></strong><span class="koboSpan" id="kobo.4171.1"> argument and make the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4172.1">wg.Done</span></strong><span class="koboSpan" id="kobo.4173.1"> call part of </span><span class="No-Break"><span class="koboSpan" id="kobo.4174.1">the function:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.4175.1">func</span></span><span class="koboSpan" id="kobo.4176.1"> getVersion(r Router, wg </span><span class="Code_Red"><span class="koboSpan" id="kobo.4177.1">*</span></span><span class="koboSpan" id="kobo.4178.1">sync.WaitGroup) {
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4179.1">defer</span></span><span class="koboSpan" id="kobo.4180.1"> wg.Done()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.4181.1">/* ... </span><span class="koboSpan" id="kobo.4181.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.4181.3">*/</span></span><span class="koboSpan" id="kobo.4182.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.4183.1">Having a function like that would simplify the code of the main function since we no longer need to wrap everything in an anonymous function just to make the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4184.1">wg.Done</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4185.1"> call:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.4186.1">func</span></span><span class="koboSpan" id="kobo.4187.1"> main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.4188.1">/* ... </span><span class="koboSpan" id="kobo.4188.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.4188.3">*/</span></span><span class="koboSpan" id="kobo.4189.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4190.1">for</span></span><span class="koboSpan" id="kobo.4191.1"> _, v :</span><span class="Code_Red"><span class="koboSpan" id="kobo.4192.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.4193.1">range</span></span><span class="koboSpan" id="kobo.4194.1"> inv.Routers {
        wg.Add(1)
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4195.1">go</span></span><span class="koboSpan" id="kobo.4196.1"> getVersion(v, </span><span class="Code_Red"><span class="koboSpan" id="kobo.4197.1">&amp;</span></span><span class="koboSpan" id="kobo.4198.1">wg)
    }
    wg.Wait()
}</span></pre>
<p><span class="koboSpan" id="kobo.4199.1">The complete code for this example is available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4200.1">ch03/concurrency2</span></strong><span class="koboSpan" id="kobo.4201.1"> directory (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4202.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.4203.1">).</span></span></p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.4204.1">Channels</span></h2>
<p><span class="koboSpan" id="kobo.4205.1">As soon</span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.4206.1"> as anyone becomes familiar with goroutines, the next thing they </span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.4207.1">normally want to do is exchange data between them. </span><span class="koboSpan" id="kobo.4207.2">Go channels allow goroutines to communicate with each other. </span><span class="koboSpan" id="kobo.4207.3">A real-world analogy to describe Go channels are first-in-first-out pipes – they have fixed throughput and allow you to send data in </span><span class="No-Break"><span class="koboSpan" id="kobo.4208.1">both directions.</span></span></p>
<p><span class="koboSpan" id="kobo.4209.1">You can </span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.4210.1">use channels for both goroutine synchronization (a form of signaling used for work coordination) and general-purpose </span><span class="No-Break"><span class="koboSpan" id="kobo.4211.1">data exchange.</span></span></p>
<p><span class="koboSpan" id="kobo.4212.1">We create channels with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4213.1">make</span></strong><span class="koboSpan" id="kobo.4214.1"> keyword, which initializes them and makes them ready to use. </span><span class="koboSpan" id="kobo.4214.2">The two arguments that </span><strong class="source-inline"><span class="koboSpan" id="kobo.4215.1">make</span></strong><span class="koboSpan" id="kobo.4216.1"> accepts are the channel type, which defines the data type you can exchange over the channel, and an optional capacity. </span><span class="koboSpan" id="kobo.4216.2">The channel capacity determines how many unreceived values it can store before it starts blocking a sender, acting then as </span><span class="No-Break"><span class="koboSpan" id="kobo.4217.1">a buffer.</span></span></p>
<p><span class="koboSpan" id="kobo.4218.1">The following code snippet shows how we send and receive an integer over a channel. </span><span class="koboSpan" id="kobo.4218.2">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.4219.1">send</span></strong><span class="koboSpan" id="kobo.4220.1"> is the value we want to send to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4221.1">ch</span></strong><span class="koboSpan" id="kobo.4222.1"> channel we created. </span><span class="koboSpan" id="kobo.4222.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.4223.1">&lt;-</span></strong><span class="koboSpan" id="kobo.4224.1"> operator lets us send data to a channel. </span><span class="koboSpan" id="kobo.4224.2">Next, we declare a </span><strong class="source-inline"><span class="koboSpan" id="kobo.4225.1">receive</span></strong><span class="koboSpan" id="kobo.4226.1"> variable, whose value comes from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4227.1">ch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4228.1"> channel:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.4229.1">func</span></span><span class="koboSpan" id="kobo.4230.1"> main() {
    ch :</span><span class="Code_Red"><span class="koboSpan" id="kobo.4231.1">=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.4232.1">make</span></span><span class="koboSpan" id="kobo.4233.1">(</span><span class="Code_Purple"><span class="koboSpan" id="kobo.4234.1">chan int</span></span><span class="koboSpan" id="kobo.4235.1">, 1)
    send :</span><span class="Code_Red"><span class="koboSpan" id="kobo.4236.1">=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.4237.1">1</span></span><span class="koboSpan" id="kobo.4238.1">
    ch </span><span class="Code_Red"><span class="koboSpan" id="kobo.4239.1">&lt;-</span></span><span class="koboSpan" id="kobo.4240.1"> send
    receive :</span><span class="Code_Red"><span class="koboSpan" id="kobo.4241.1">= &lt;-</span></span><span class="koboSpan" id="kobo.4242.1">ch
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.4243.1">// prints 1</span></span><span class="koboSpan" id="kobo.4244.1">
    fmt.Println(receive)
}</span></pre>
<p><span class="koboSpan" id="kobo.4245.1">But, sending </span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.4246.1">and receiving data in a single goroutine is not the goal here. </span><span class="koboSpan" id="kobo.4246.2">Let’s</span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.4247.1"> examine another example of using channels for communication between different goroutines. </span><span class="koboSpan" id="kobo.4247.2">We pick up the example we’ve used in this section so far and introduce another </span><em class="italic"><span class="koboSpan" id="kobo.4248.1">worker</span></em><span class="koboSpan" id="kobo.4249.1"> function whose job is to print the results produced by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4250.1">getVersion</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4251.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.4252.1">The new </span><strong class="source-inline"><span class="koboSpan" id="kobo.4253.1">printer</span></strong><span class="koboSpan" id="kobo.4254.1"> function uses a </span><strong class="source-inline"><span class="koboSpan" id="kobo.4255.1">for</span></strong><span class="koboSpan" id="kobo.4256.1"> loop to receive values from an </span><strong class="source-inline"><span class="koboSpan" id="kobo.4257.1">in</span></strong><span class="koboSpan" id="kobo.4258.1"> channel and it prints them on </span><span class="No-Break"><span class="koboSpan" id="kobo.4259.1">the terminal:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.4260.1">func</span></span><span class="koboSpan" id="kobo.4261.1"> printer(in </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4262.1">chan</span></span><span class="koboSpan" id="kobo.4263.1"> data {
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4264.1">for</span></span><span class="koboSpan" id="kobo.4265.1"> out :</span><span class="Code_Purple"><span class="koboSpan" id="kobo.4266.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.4267.1">range</span></span><span class="koboSpan" id="kobo.4268.1"> in {
        fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.4269.1">"Hostname: %s\nHW: %s\nSW Version: %s\nUptime: %s\n\n"</span></span><span class="koboSpan" id="kobo.4270.1">, out.host, out.hw, out.version, out.uptime)
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.4271.1">We create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4272.1">ch</span></strong><span class="koboSpan" id="kobo.4273.1"> channel in the main goroutine before we spawn any of the goroutines. </span><span class="koboSpan" id="kobo.4273.2">We pass it as an argument to both </span><strong class="source-inline"><span class="koboSpan" id="kobo.4274.1">getVersion</span></strong><span class="koboSpan" id="kobo.4275.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.4276.1">printer</span></strong><span class="koboSpan" id="kobo.4277.1"> functions. </span><span class="koboSpan" id="kobo.4277.2">The first extra goroutine we start is an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4278.1">printer</span></strong><span class="koboSpan" id="kobo.4279.1"> function that listens for messages coming from the device over the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4280.1">ch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4281.1"> channel:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.4282.1">func</span></span><strong class="bold"> </strong><span class="koboSpan" id="kobo.4283.1">main() {
    /* ... </span><span class="koboSpan" id="kobo.4283.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.4283.3">*/
    ch :</span><span class="Code_Red"><span class="koboSpan" id="kobo.4284.1">=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.4285.1">make</span></span><span class="koboSpan" id="kobo.4286.1">(</span><span class="Code_Purple"><span class="koboSpan" id="kobo.4287.1">chan</span></span><span class="koboSpan" id="kobo.4288.1"> data)
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4289.1">go</span></span><span class="koboSpan" id="kobo.4290.1"> printer(ch)
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4291.1">var</span></span><span class="koboSpan" id="kobo.4292.1"> wg sync.WaitGroup
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4293.1">for</span></span><span class="koboSpan" id="kobo.4294.1"> _, v :</span><span class="Code_Red"><span class="koboSpan" id="kobo.4295.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.4296.1">range</span></span><span class="koboSpan" id="kobo.4297.1"> inv.Routers {
        wg.Add(</span><span class="Code_Green"><span class="koboSpan" id="kobo.4298.1">1</span></span><span class="koboSpan" id="kobo.4299.1">)
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4300.1">go</span></span><span class="koboSpan" id="kobo.4301.1"> getVersion(v, ch, </span><span class="Code_Red"><span class="koboSpan" id="kobo.4302.1">&amp;</span></span><span class="koboSpan" id="kobo.4303.1">wg)
    }
    wg.Wait()
    </span><span class="Code_Blue"><span class="koboSpan" id="kobo.4304.1">close</span></span><span class="koboSpan" id="kobo.4305.1">(ch)
}</span></pre>
<p><span class="koboSpan" id="kobo.4306.1">The</span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.4307.1"> next step</span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.4308.1"> is to start a goroutine for each network device in the inventory to capture the output we need and send it over the channel with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4309.1">getVersion</span></strong><span class="koboSpan" id="kobo.4310.1"> function. </span><span class="koboSpan" id="kobo.4310.2">After we collect and print the data, we close the channel and end </span><span class="No-Break"><span class="koboSpan" id="kobo.4311.1">the program:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.4312.1">ch03/concurrency3</span><span class="Code_Blue"><span class="koboSpan" id="kobo.4313.1">$ go</span></span><strong class="bold"> </strong><span class="koboSpan" id="kobo.4314.1">run main.go
Hostname: sandbox-iosxe-latest-1.cisco.com
HW: [CSR1000V]
SW Version: </span><span class="Code_Green"><span class="koboSpan" id="kobo.4315.1">17</span></span><span class="koboSpan" id="kobo.4316.1">.3.1a
Uptime: </span><span class="Code_Green"><span class="koboSpan" id="kobo.4317.1">1</span></span><span class="koboSpan" id="kobo.4318.1"> day, </span><span class="Code_Green"><span class="koboSpan" id="kobo.4319.1">12</span></span><span class="koboSpan" id="kobo.4320.1"> hours, </span><span class="Code_Green"><span class="koboSpan" id="kobo.4321.1">42</span></span><span class="koboSpan" id="kobo.4322.1"> minutes
Hostname: sandbox-iosxr-1.cisco.com
HW: IOS-XRv </span><span class="Code_Green"><span class="koboSpan" id="kobo.4323.1">9000</span></span><span class="koboSpan" id="kobo.4324.1">
SW Version: </span><span class="Code_Green"><span class="koboSpan" id="kobo.4325.1">7</span></span><span class="koboSpan" id="kobo.4326.1">.3.2
Uptime: </span><span class="Code_Green"><span class="koboSpan" id="kobo.4327.1">1</span></span><span class="koboSpan" id="kobo.4328.1"> day </span><span class="Code_Green"><span class="koboSpan" id="kobo.4329.1">2</span></span><span class="koboSpan" id="kobo.4330.1"> hours </span><span class="Code_Green"><span class="koboSpan" id="kobo.4331.1">57</span></span><span class="koboSpan" id="kobo.4332.1"> minutes
Hostname: sandbox-nxos-1.cisco.com
HW: C9300v
SW Version: </span><span class="Code_Green"><span class="koboSpan" id="kobo.4333.1">9</span></span><span class="koboSpan" id="kobo.4334.1">.3(3)
Uptime: </span><span class="Code_Green"><span class="koboSpan" id="kobo.4335.1">5</span></span><span class="koboSpan" id="kobo.4336.1"> day(s), </span><span class="Code_Green"><span class="koboSpan" id="kobo.4337.1">6</span></span><span class="koboSpan" id="kobo.4338.1"> hour(s), </span><span class="Code_Green"><span class="koboSpan" id="kobo.4339.1">25</span></span><span class="koboSpan" id="kobo.4340.1"> minute(s), </span><span class="Code_Green"><span class="koboSpan" id="kobo.4341.1">44</span></span><span class="koboSpan" id="kobo.4342.1"> second(s)</span></pre>
<p><span class="koboSpan" id="kobo.4343.1">The complete code for this example is available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4344.1">ch03/concurrency3</span></strong><span class="koboSpan" id="kobo.4345.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.4346.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4347.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.4348.1">) directory.</span></span></p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.4349.1">Channels and Timers</span></h2>
<p><span class="koboSpan" id="kobo.4350.1">One thing we didn’t consider in the last couple of examples was the scenario where a network device is not reachable, or the connection to it hangs, or maybe a device takes forever to return the output we need. </span><span class="koboSpan" id="kobo.4350.2">In these cases, we need to set up a timeout so we don’t wait forever and we can end the </span><span class="No-Break"><span class="koboSpan" id="kobo.4351.1">program gracefully.</span></span></p>
<p><span class="koboSpan" id="kobo.4352.1">You can handle this at the connection level, but also, channels offer you a couple of resources to keep track of time via these </span><span class="No-Break"><span class="koboSpan" id="kobo.4353.1">timer types:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.4354.1">Timer</span></strong><span class="koboSpan" id="kobo.4355.1"> — To wait for a certain amount </span><span class="No-Break"><span class="koboSpan" id="kobo.4356.1">of time</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.4357.1">Ticker</span></strong><span class="koboSpan" id="kobo.4358.1"> — To perform an action repeatedly at </span><span class="No-Break"><span class="koboSpan" id="kobo.4359.1">some interval</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.4360.1">Timer</span></h3>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.4361.1">Timer</span></strong><span class="koboSpan" id="kobo.4362.1"> can </span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.4363.1">help </span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.4364.1">you define a timeout for your program. </span><span class="koboSpan" id="kobo.4364.2">To illustrate this, we can rewrite the example we have been working with to print all the messages from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4365.1">ch</span></strong><span class="koboSpan" id="kobo.4366.1"> channel in the main function, instead of calling a separate </span><span class="No-Break"><span class="koboSpan" id="kobo.4367.1">function (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4368.1">printer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4369.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.4370.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.4371.1">select</span></strong><span class="koboSpan" id="kobo.4372.1"> statement inside an infinite loop handles this as follows. </span><span class="koboSpan" id="kobo.4372.2">Unlike a </span><strong class="source-inline"><span class="koboSpan" id="kobo.4373.1">switch</span></strong><span class="koboSpan" id="kobo.4374.1"> statement, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.4375.1">select</span></strong><span class="koboSpan" id="kobo.4376.1"> with channels when we don’t have to choose an option in order. </span><span class="koboSpan" id="kobo.4376.2">For each iteration, we either wait for a message from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4377.1">ch</span></strong><span class="koboSpan" id="kobo.4378.1"> channel or if 5 seconds have elapsed (</span><strong class="source-inline"><span class="koboSpan" id="kobo.4379.1">time.After(5 * time.Second)</span></strong><span class="koboSpan" id="kobo.4380.1">), we close the channel and exit </span><span class="No-Break"><span class="koboSpan" id="kobo.4381.1">the program:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.4382.1">func</span></span><span class="koboSpan" id="kobo.4383.1"> main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.4384.1">/* ... </span><span class="koboSpan" id="kobo.4384.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.4384.3">*/</span></span><span class="koboSpan" id="kobo.4385.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4386.1">for</span></span><span class="koboSpan" id="kobo.4387.1"> {
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4388.1">select</span></span><span class="koboSpan" id="kobo.4389.1"> {
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4390.1">case</span></span><span class="koboSpan" id="kobo.4391.1"> out :</span><span class="Code_Red"><span class="koboSpan" id="kobo.4392.1">= &lt;-</span></span><span class="koboSpan" id="kobo.4393.1">ch:
            fmt.Printf(
    </span><span class="Code_Red"><span class="koboSpan" id="kobo.4394.1">"Hostname: %s\nHW: %s\nSW Version: %s\nUptime:%s\n\n"</span></span><span class="koboSpan" id="kobo.4395.1">,
            out.host, out.hw, out.version, out.uptime)
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4396.1">case</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.4397.1">&lt;-</span></span><span class="koboSpan" id="kobo.4398.1">time.After(5 </span><span class="Code_Red"><span class="koboSpan" id="kobo.4399.1">*</span></span><span class="koboSpan" id="kobo.4400.1"> time.Second):
            </span><span class="Code_Blue"><span class="koboSpan" id="kobo.4401.1">close</span></span><span class="koboSpan" id="kobo.4402.1">(ch)
            fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.4403.1">"Timeout: 5 seconds"</span></span><span class="koboSpan" id="kobo.4404.1">)
            </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4405.1">return</span></span><span class="koboSpan" id="kobo.4406.1">
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.4407.1">This </span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.4408.1">forces </span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.4409.1">the runtime to always be 5 seconds, even if not all the tasks have been completed. </span><span class="koboSpan" id="kobo.4409.2">This is not the most efficient way to solve this problem, but it shows how to timeout without introducing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4410.1">context</span></strong><span class="koboSpan" id="kobo.4411.1"> package from the standard library that you could also use in </span><span class="No-Break"><span class="koboSpan" id="kobo.4412.1">this scenario.</span></span></p>
<p><span class="koboSpan" id="kobo.4413.1">The complete code for this example is available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4414.1">ch03/concurrency5</span></strong><span class="koboSpan" id="kobo.4415.1"> directory of the book’s repository (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4416.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.4417.1">).</span></span></p>
<h3><span class="koboSpan" id="kobo.4418.1">Ticker</span></h3>
<p><span class="koboSpan" id="kobo.4419.1">A</span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.4420.1"> common</span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.4421.1"> use for a ticker is in cases where you want to execute periodic tasks. </span><span class="koboSpan" id="kobo.4421.2">In the next code example, we create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.4422.1">ticker</span></strong><span class="koboSpan" id="kobo.4423.1"> that runs every half second, which we use as a trigger to print out a message to the terminal. </span><span class="koboSpan" id="kobo.4423.2">We also create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.4424.1">done</span></strong><span class="koboSpan" id="kobo.4425.1"> channel, just to signal that we want to stop the execution of the program after 2 seconds and </span><span class="No-Break"><span class="koboSpan" id="kobo.4426.1">100 milliseconds:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.4427.1">func</span></span><span class="koboSpan" id="kobo.4428.1"> main() {
    ticker :</span><span class="Code_Red"><span class="koboSpan" id="kobo.4429.1">=</span></span><span class="koboSpan" id="kobo.4430.1"> time.NewTicker(</span><span class="Code_Green"><span class="koboSpan" id="kobo.4431.1">500</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.4432.1">*</span></span><span class="koboSpan" id="kobo.4433.1"> time.Millisecond)
    done :</span><span class="Code_Red"><span class="koboSpan" id="kobo.4434.1">=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.4435.1">make</span></span><span class="koboSpan" id="kobo.4436.1">(</span><span class="Code_Purple"><span class="koboSpan" id="kobo.4437.1">chan bool</span></span><span class="koboSpan" id="kobo.4438.1">)
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4439.1">go</span></span><span class="koboSpan" id="kobo.4440.1"> repeat(done, ticker.C)
    time.Sleep(</span><span class="Code_Green"><span class="koboSpan" id="kobo.4441.1">2100</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.4442.1">*</span></span><span class="koboSpan" id="kobo.4443.1"> time.Millisecond)
    ticker.Stop()
    done </span><span class="Code_Red"><span class="koboSpan" id="kobo.4444.1">&lt;-</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.4445.1">true</span></span><span class="koboSpan" id="kobo.4446.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.4447.1">Tickers</span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.4448.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4449.1">time</span></strong><span class="koboSpan" id="kobo.4450.1"> package have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.4451.1">C</span></strong><span class="koboSpan" id="kobo.4452.1"> channel that they use to </span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.4453.1">signal every interval. </span><span class="koboSpan" id="kobo.4453.2">We pass this channel and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4454.1">done</span></strong><span class="koboSpan" id="kobo.4455.1"> channel to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4456.1">repeat</span></strong><span class="koboSpan" id="kobo.4457.1"> function that we execute in </span><span class="No-Break"><span class="koboSpan" id="kobo.4458.1">a goroutine:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.4459.1">func</span></span><span class="koboSpan" id="kobo.4460.1"> repeat(d </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4461.1">chan bool</span></span><span class="koboSpan" id="kobo.4462.1">, c </span><span class="Code_Red"><span class="koboSpan" id="kobo.4463.1">&lt;-</span></span><span class="Code_Purple"><span class="koboSpan" id="kobo.4464.1">chan</span></span><span class="koboSpan" id="kobo.4465.1"> time.Time) {
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4466.1">for</span></span><span class="koboSpan" id="kobo.4467.1"> {
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4468.1">select</span></span><span class="koboSpan" id="kobo.4469.1"> {
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4470.1">case</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.4471.1">&lt;-</span></span><span class="koboSpan" id="kobo.4472.1">d:
            </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4473.1">return</span></span><span class="koboSpan" id="kobo.4474.1">
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4475.1">case</span></span><span class="koboSpan" id="kobo.4476.1"> t :</span><span class="Code_Red"><span class="koboSpan" id="kobo.4477.1">= &lt;-</span></span><span class="koboSpan" id="kobo.4478.1">c:
            fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.4479.1">"Run at"</span></span><span class="koboSpan" id="kobo.4480.1">, t.Local())
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.4481.1">This function runs an infinite loop that waits for a signal from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4482.1">ticker</span></strong><span class="koboSpan" id="kobo.4483.1"> or the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4484.1">done</span></strong><span class="koboSpan" id="kobo.4485.1"> channel to end the execution. </span><span class="koboSpan" id="kobo.4485.2">This is what the output </span><span class="No-Break"><span class="koboSpan" id="kobo.4486.1">looks like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.4487.1">ch03/ticker</span><span class="Code_Blue"><span class="koboSpan" id="kobo.4488.1">$ go</span></span><strong class="bold"> </strong><span class="koboSpan" id="kobo.4489.1">run main.go
Tick at </span><span class="Code_Green"><span class="koboSpan" id="kobo.4490.1">2021</span></span><span class="Code_Blue"><span class="koboSpan" id="kobo.4491.1">-11-17</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.4492.1">23</span></span><span class="koboSpan" id="kobo.4493.1">:19:33.914906389 </span><span class="Code_Blue"><span class="koboSpan" id="kobo.4494.1">-0500</span></span><span class="koboSpan" id="kobo.4495.1"> EST
Tick at </span><span class="Code_Green"><span class="koboSpan" id="kobo.4496.1">2021</span></span><span class="Code_Blue"><span class="koboSpan" id="kobo.4497.1">-11-17</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.4498.1">23</span></span><span class="koboSpan" id="kobo.4499.1">:19:34.414279709 </span><span class="Code_Blue"><span class="koboSpan" id="kobo.4500.1">-0500</span></span><span class="koboSpan" id="kobo.4501.1"> EST
Tick at </span><span class="Code_Green"><span class="koboSpan" id="kobo.4502.1">2021</span></span><span class="Code_Blue"><span class="koboSpan" id="kobo.4503.1">-11-17</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.4504.1">23</span></span><span class="koboSpan" id="kobo.4505.1">:19:34.915058301 </span><span class="Code_Blue"><span class="koboSpan" id="kobo.4506.1">-0500</span></span><span class="koboSpan" id="kobo.4507.1"> EST</span></pre>
<p><span class="koboSpan" id="kobo.4508.1">The complete code for this example is available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4509.1">ch03/ticker</span></strong><span class="koboSpan" id="kobo.4510.1"> directory (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4511.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.4512.1">).</span></span></p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.4513.1">Shared data access</span></h2>
<p><span class="koboSpan" id="kobo.4514.1">Channels</span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.4515.1"> are thread-safe, so it’s always a good idea to </span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.4516.1">use them as the default option for data communication between goroutines. </span><span class="koboSpan" id="kobo.4516.2">But sometimes, you may still need to access and change data that more than just one goroutine has </span><span class="No-Break"><span class="koboSpan" id="kobo.4517.1">access to.</span></span></p>
<p><span class="koboSpan" id="kobo.4518.1">The problem with concurrent data access is that it may cause data corruption when many goroutines try to change the same field or read from a field that someone else might be changing. </span><span class="koboSpan" id="kobo.4518.2">Go’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.4519.1">sync</span></strong><span class="koboSpan" id="kobo.4520.1"> package includes three helper types you can use to serialize these kinds </span><span class="No-Break"><span class="koboSpan" id="kobo.4521.1">of operations:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.4522.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.4523.1">sync.Mutex</span></strong><span class="koboSpan" id="kobo.4524.1"> type is a </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.4525.1">general-purpose mutual exclusion lock that has two states — locked </span><span class="No-Break"><span class="koboSpan" id="kobo.4526.1">and unlocked.</span></span></li>
<li><span class="koboSpan" id="kobo.4527.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.4528.1">sync.RWMutex</span></strong><span class="koboSpan" id="kobo.4529.1"> type is</span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.4530.1"> a special mutex for read-write operations where only write operations are mutually exclusive but simultaneous read operations </span><span class="No-Break"><span class="koboSpan" id="kobo.4531.1">are safe.</span></span></li>
<li><span class="koboSpan" id="kobo.4532.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.4533.1">sync.Map</span></strong><span class="koboSpan" id="kobo.4534.1"> mutex covers</span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.4535.1"> a couple of map corner case scenarios</span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.4536.1"> that we don’t delve into in this book. </span><span class="koboSpan" id="kobo.4536.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.4537.1">sync.Map documentation</span></strong><span class="koboSpan" id="kobo.4538.1"> talks about them (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4539.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.4540.1">).</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.4541.1">Now, let’s see an example of how you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.4542.1">sync.RWMutexto</span></strong><span class="koboSpan" id="kobo.4543.1"> to safeguard concurrent map access. </span><span class="koboSpan" id="kobo.4543.2">Using the example theme we have used through this section as the baseline, let’s add another variable that records whether we are able to connect successfully to a remote device. </span><span class="koboSpan" id="kobo.4543.3">We call this variable </span><strong class="source-inline"><span class="koboSpan" id="kobo.4544.1">isAlive</span></strong><span class="koboSpan" id="kobo.4545.1"> and pass it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4546.1">getVersion</span></strong><span class="koboSpan" id="kobo.4547.1"> function as </span><span class="No-Break"><span class="koboSpan" id="kobo.4548.1">an argument:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.4549.1">func</span></span><span class="koboSpan" id="kobo.4550.1"> main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.4551.1">/* ... </span><span class="koboSpan" id="kobo.4551.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.4551.3">*/</span></span><span class="koboSpan" id="kobo.4552.1">
    isAlive :</span><span class="Code_Red"><span class="koboSpan" id="kobo.4553.1">=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.4554.1">make</span></span><span class="koboSpan" id="kobo.4555.1">(</span><span class="Code_Purple"><span class="koboSpan" id="kobo.4556.1">map</span></span><span class="koboSpan" id="kobo.4557.1">[</span><span class="Code_Purple"><span class="koboSpan" id="kobo.4558.1">string</span></span><span class="koboSpan" id="kobo.4559.1">]</span><span class="Code_Purple"><span class="koboSpan" id="kobo.4560.1">bool</span></span><span class="koboSpan" id="kobo.4561.1">)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.4562.1">/* ... </span><span class="koboSpan" id="kobo.4562.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.4562.3">*/</span></span><span class="koboSpan" id="kobo.4563.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4564.1">for</span></span><span class="koboSpan" id="kobo.4565.1"> _, v :</span><span class="Code_Red"><span class="koboSpan" id="kobo.4566.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.4567.1">range</span></span><span class="koboSpan" id="kobo.4568.1"> inv.Routers {
        wg.Add(</span><span class="Code_Green"><span class="koboSpan" id="kobo.4569.1">1</span></span><span class="koboSpan" id="kobo.4570.1">)
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4571.1">go</span></span><span class="koboSpan" id="kobo.4572.1"> getVersion(v, ch, </span><span class="Code_Red"><span class="koboSpan" id="kobo.4573.1">&amp;</span></span><span class="koboSpan" id="kobo.4574.1">wg, isAlive)
    }
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.4575.1">/* ... </span><span class="koboSpan" id="kobo.4575.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.4575.3">*/</span></span><span class="koboSpan" id="kobo.4576.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.4577.1">We </span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.4578.1">define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4579.1">m</span></strong><span class="koboSpan" id="kobo.4580.1"> mutex as a package-level global variable to </span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.4581.1">make sure all functions are using the same mutex for synchronization. </span><span class="koboSpan" id="kobo.4581.2">We lock this mutex just before we change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4582.1">isAlive</span></strong><span class="koboSpan" id="kobo.4583.1"> map and unlock it right after we make the change in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4584.1">getVersion</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4585.1"> function:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.4586.1">var</span></span><span class="koboSpan" id="kobo.4587.1"> m sync.RWMutex </span><span class="Code_Red"><span class="koboSpan" id="kobo.4588.1">=</span></span><span class="koboSpan" id="kobo.4589.1"> sync.RWMutex{}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.4590.1">func</span></span><span class="koboSpan" id="kobo.4591.1"> getVersion(r Router, out </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4592.1">chan</span></span><span class="koboSpan" id="kobo.4593.1"> data, wg </span><span class="Code_Red"><span class="koboSpan" id="kobo.4594.1">*</span></span><span class="koboSpan" id="kobo.4595.1">sync.WaitGroup, isAlive </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4596.1">map</span></span><span class="koboSpan" id="kobo.4597.1">[</span><span class="Code_Purple"><span class="koboSpan" id="kobo.4598.1">string</span></span><span class="koboSpan" id="kobo.4599.1">]</span><span class="Code_Purple"><span class="koboSpan" id="kobo.4600.1">bool</span></span><span class="koboSpan" id="kobo.4601.1">) {
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4602.1">defer</span></span><span class="koboSpan" id="kobo.4603.1"> wg.Done()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.4604.1">/* ... </span><span class="koboSpan" id="kobo.4604.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.4604.3">*/</span></span><span class="koboSpan" id="kobo.4605.1">
    rs, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.4606.1">=</span></span><span class="koboSpan" id="kobo.4607.1"> d.SendCommand(</span><span class="Code_Red"><span class="koboSpan" id="kobo.4608.1">"show version"</span></span><span class="koboSpan" id="kobo.4609.1">)
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4610.1">if</span></span><span class="koboSpan" id="kobo.4611.1"> err </span><span class="Code_Red"><span class="koboSpan" id="kobo.4612.1">!=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.4613.1">nil</span></span><span class="koboSpan" id="kobo.4614.1"> {
        fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.4615.1">"fail to send cmd for %s: %+v\n"</span></span><span class="koboSpan" id="kobo.4616.1">,
                    r.Hostname, err)
        m.Lock()
        isAlive[r.Hostname] </span><span class="Code_Red"><span class="koboSpan" id="kobo.4617.1">=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.4618.1">false</span></span><span class="koboSpan" id="kobo.4619.1">
        m.Unlock()
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4620.1">return</span></span><span class="koboSpan" id="kobo.4621.1">
    }
    m.Lock()
    isAlive[r.Hostname] </span><span class="Code_Red"><span class="koboSpan" id="kobo.4622.1">=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.4623.1">true</span></span><span class="koboSpan" id="kobo.4624.1">
    m.Unlock()
}</span></pre>
<p><span class="koboSpan" id="kobo.4625.1">Finally, we </span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.4626.1">add another mutex for a loop in the main</span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.4627.1"> function that uses a read-specific lock while iterating over a map to prevent it from being accidentally modified in </span><span class="No-Break"><span class="koboSpan" id="kobo.4628.1">the process:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.4629.1">func</span></span><span class="koboSpan" id="kobo.4630.1"> main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.4631.1">/* ... </span><span class="koboSpan" id="kobo.4631.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.4631.3">*/</span></span><span class="koboSpan" id="kobo.4632.1">
    m.RLock()
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4633.1">for</span></span><span class="koboSpan" id="kobo.4634.1"> name, v :</span><span class="Code_Red"><span class="koboSpan" id="kobo.4635.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.4636.1">range</span></span><span class="koboSpan" id="kobo.4637.1"> isAlive {
        fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.4638.1">"Router %s is alive: %t\n"</span></span><span class="koboSpan" id="kobo.4639.1">, name, v)
    }
    m.RUnlock()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.4640.1">/* ... </span><span class="koboSpan" id="kobo.4640.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.4640.3">*/</span></span><span class="koboSpan" id="kobo.4641.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.4642.1">You can check the full code in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4643.1">ch03/concurrency4</span></strong><span class="koboSpan" id="kobo.4644.1"> directory (see </span><em class="italic"><span class="koboSpan" id="kobo.4645.1">Further reading</span></em><span class="koboSpan" id="kobo.4646.1">). </span><span class="koboSpan" id="kobo.4646.2">The next output shows what this </span><span class="No-Break"><span class="koboSpan" id="kobo.4647.1">program produces:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.4648.1">ch03/concurrency4</span><span class="Code_Blue"><span class="koboSpan" id="kobo.4649.1">$ go</span></span><span class="koboSpan" id="kobo.4650.1"> run main.go
Hostname: sandbox-iosxe-latest-1.cisco.com
Hardware: [CSR1000V]
SW Version: </span><span class="Code_Green"><span class="koboSpan" id="kobo.4651.1">17</span></span><span class="koboSpan" id="kobo.4652.1">.3.1a
Uptime: </span><span class="Code_Green"><span class="koboSpan" id="kobo.4653.1">8</span></span><span class="koboSpan" id="kobo.4654.1"> hours, </span><span class="Code_Green"><span class="koboSpan" id="kobo.4655.1">27</span></span><span class="koboSpan" id="kobo.4656.1"> minutes
Hostname: sandbox-iosxr-1.cisco.com
Hardware: IOS-XRv </span><span class="Code_Green"><span class="koboSpan" id="kobo.4657.1">9000</span></span><span class="koboSpan" id="kobo.4658.1">
SW Version: </span><span class="Code_Green"><span class="koboSpan" id="kobo.4659.1">7</span></span><span class="koboSpan" id="kobo.4660.1">.3.2
Uptime: </span><span class="Code_Green"><span class="koboSpan" id="kobo.4661.1">1</span></span><span class="koboSpan" id="kobo.4662.1"> day </span><span class="Code_Green"><span class="koboSpan" id="kobo.4663.1">11</span></span><span class="koboSpan" id="kobo.4664.1"> hours </span><span class="Code_Green"><span class="koboSpan" id="kobo.4665.1">43</span></span><span class="koboSpan" id="kobo.4666.1"> minutes
Hostname: sandbox-nxos-1.cisco.com
Hardware: C9300v
SW Version: </span><span class="Code_Green"><span class="koboSpan" id="kobo.4667.1">9</span></span><span class="koboSpan" id="kobo.4668.1">.3(3)
Uptime: </span><span class="Code_Green"><span class="koboSpan" id="kobo.4669.1">5</span></span><span class="koboSpan" id="kobo.4670.1"> day(s), </span><span class="Code_Green"><span class="koboSpan" id="kobo.4671.1">15</span></span><span class="koboSpan" id="kobo.4672.1"> hour(s), </span><span class="Code_Green"><span class="koboSpan" id="kobo.4673.1">11</span></span><span class="koboSpan" id="kobo.4674.1"> minute(s), </span><span class="Code_Green"><span class="koboSpan" id="kobo.4675.1">42</span></span><span class="koboSpan" id="kobo.4676.1"> second(s)
Router sandbox-iosxe-latest-1.cisco.com is alive: </span><span class="Code_Blue"><span class="koboSpan" id="kobo.4677.1">true</span></span><span class="koboSpan" id="kobo.4678.1">
Router sandbox-iosxr-1.cisco.com is alive: </span><span class="Code_Blue"><span class="koboSpan" id="kobo.4679.1">true</span></span><span class="koboSpan" id="kobo.4680.1">
Router sandbox-nxos-1.cisco.com is alive: </span><span class="Code_Blue"><span class="koboSpan" id="kobo.4681.1">true</span></span><span class="koboSpan" id="kobo.4682.1">
This process took </span><span class="Code_Green"><span class="koboSpan" id="kobo.4683.1">3</span></span><span class="koboSpan" id="kobo.4684.1">.129440011s</span></pre>
<p><span class="koboSpan" id="kobo.4685.1">Sometimes, you </span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.4686.1">might forget to use mutexes, especially for </span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.4687.1">non-trivial user-defined data types, or when you accidentally leak a variable between goroutines. </span><span class="koboSpan" id="kobo.4687.2">In these cases, you can use the data race detector built into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4688.1">go</span></strong><span class="koboSpan" id="kobo.4689.1"> tool. </span><span class="koboSpan" id="kobo.4689.2">Add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4690.1">-race</span></strong><span class="koboSpan" id="kobo.4691.1"> flag to any of the go </span><strong class="source-inline"><span class="koboSpan" id="kobo.4692.1">test</span></strong><span class="koboSpan" id="kobo.4693.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.4694.1">run</span></strong><span class="koboSpan" id="kobo.4695.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.4696.1">build</span></strong><span class="koboSpan" id="kobo.4697.1"> commands to check and get a report of any unprotected access requests to </span><span class="No-Break"><span class="koboSpan" id="kobo.4698.1">shared memory.</span></span></p>
<p><span class="koboSpan" id="kobo.4699.1">To see how it works, let’s focus on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4700.1">isAlive</span></strong><span class="koboSpan" id="kobo.4701.1"> map we manipulate concurrently on different instances of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4702.1">getVersion</span></strong><span class="koboSpan" id="kobo.4703.1"> function. </span><span class="koboSpan" id="kobo.4703.2">Earlier, we surrounded this with a mutex, which we now remove in </span><strong class="source-inline"><span class="koboSpan" id="kobo.4704.1">ch03/race/main.go</span></strong><span class="koboSpan" id="kobo.4705.1"> (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4706.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.4707.1">):</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.4708.1">func</span></span><span class="koboSpan" id="kobo.4709.1"> getVersion(r Router, out </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4710.1">chan map</span></span><span class="koboSpan" id="kobo.4711.1">[</span><span class="Code_Purple"><span class="koboSpan" id="kobo.4712.1">string</span></span><span class="koboSpan" id="kobo.4713.1">]</span><span class="Code_Purple"><span class="koboSpan" id="kobo.4714.1">interface</span></span><span class="koboSpan" id="kobo.4715.1">{}, wg </span><span class="Code_Red"><span class="koboSpan" id="kobo.4716.1">*</span></span><span class="koboSpan" id="kobo.4717.1">sync.WaitGroup, isAlive </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4718.1">map</span></span><span class="koboSpan" id="kobo.4719.1">[</span><span class="Code_Purple"><span class="koboSpan" id="kobo.4720.1">string</span></span><span class="koboSpan" id="kobo.4721.1">]</span><span class="Code_Purple"><span class="koboSpan" id="kobo.4722.1">bool</span></span><span class="koboSpan" id="kobo.4723.1">) {
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.4724.1">defer</span></span><span class="koboSpan" id="kobo.4725.1"> wg.Done()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.4726.1">/* ... </span><span class="koboSpan" id="kobo.4726.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.4726.3">*/</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.4727.1">    // m.Lock()</span></span><span class="koboSpan" id="kobo.4728.1">
    isAlive[r.Hostname] </span><span class="Code_Red"><span class="koboSpan" id="kobo.4729.1">=</span></span><span class="koboSpan" id="kobo.4730.1"> true
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.4731.1">// m.Unlock()</span></span><span class="koboSpan" id="kobo.4732.1">
    out </span><span class="Code_Brown"><span class="koboSpan" id="kobo.4733.1">&lt;-</span></span><span class="koboSpan" id="kobo.4734.1"> "test"
}</span></pre>
<p><span class="koboSpan" id="kobo.4735.1">When you</span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.4736.1"> run the program with the extra </span><strong class="source-inline"><span class="koboSpan" id="kobo.4737.1">-race</span></strong><span class="koboSpan" id="kobo.4738.1"> flag, Go</span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.4739.1"> highlights the data race condition </span><span class="No-Break"><span class="koboSpan" id="kobo.4740.1">it detects:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.4741.1">ch03/race</span><span class="Code_Blue"><span class="koboSpan" id="kobo.4742.1">$ go</span></span><strong class="bold"> </strong><span class="koboSpan" id="kobo.4743.1">run -race main.go
MESSAGE: test
MESSAGE: test
==================
WARNING: DATA RACE
Write at 0x00c00011c6f0 by goroutine </span><span class="Code_Green"><span class="koboSpan" id="kobo.4744.1">9</span></span><span class="koboSpan" id="kobo.4745.1">:
  runtime.mapassign_faststr()
      /usr/local/go/src/runtime/map_faststr.go:202 +0x0
  main.getVersion()
      ~/Network-Automation-with-Go/ch03/race/main.go:35 +0xeb
  main.main·dwrap·5()
      ~/Network-Automation-with-Go/ch03/race/main.go:74 +0x110
...
</span><span class="koboSpan" id="kobo.4745.2">==================
MESSAGE: test
Router sandbox-iosxe-latest-1.cisco.com is alive: </span><span class="Code_Blue"><span class="koboSpan" id="kobo.4746.1">true</span></span><span class="koboSpan" id="kobo.4747.1">
Router sandbox-iosxr-1.cisco.com is alive: </span><span class="Code_Blue"><span class="koboSpan" id="kobo.4748.1">true</span></span><span class="koboSpan" id="kobo.4749.1">
Router sandbox-nxos-1.cisco.com is alive: </span><span class="Code_Blue"><span class="koboSpan" id="kobo.4750.1">true</span></span><span class="koboSpan" id="kobo.4751.1">
This process took </span><span class="Code_Green"><span class="koboSpan" id="kobo.4752.1">1</span></span><span class="koboSpan" id="kobo.4753.1">.918348ms
Found 1 data race(s)
exit status 66</span></pre>
<p><span class="koboSpan" id="kobo.4754.1">Go’s built-in </span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.4755.1">data race detector alleviates the task of debugging</span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.4756.1"> data races, which are among the hardest bugs to debug in </span><span class="No-Break"><span class="koboSpan" id="kobo.4757.1">concurrent systems.</span></span></p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.4758.1">Concurrency caveats</span></h2>
<p><span class="koboSpan" id="kobo.4759.1">Concurrency is a </span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.4760.1">powerful tool. </span><span class="koboSpan" id="kobo.4760.2">You could even envision using goroutines everywhere in your code and following design patterns such as worker pools to split up your work between different goroutines to get the initial speed gains for a relatively small price of </span><span class="No-Break"><span class="koboSpan" id="kobo.4761.1">increased complexity.</span></span></p>
<p><span class="koboSpan" id="kobo.4762.1">But, it’s important to consider that </span><em class="italic"><span class="koboSpan" id="kobo.4763.1">concurrency is not parallelism</span></em><span class="koboSpan" id="kobo.4764.1"> (see </span><em class="italic"><span class="koboSpan" id="kobo.4765.1">Further reading</span></em><span class="koboSpan" id="kobo.4766.1">) and there is always some overhead involved in the coordination of goroutines and mapping them to OS threads. </span><span class="koboSpan" id="kobo.4766.2">We also shouldn’t forget that the underlying hardware resources are finite and so are the concurrency performance gains, as they inevitably flatten out at a certain point (see </span><em class="italic"><span class="koboSpan" id="kobo.4767.1">Simulating a real-world system in Go</span></em><span class="koboSpan" id="kobo.4768.1"> in the </span><em class="italic"><span class="koboSpan" id="kobo.4769.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4770.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.4771.1"> section).</span></span></p>
<p><span class="koboSpan" id="kobo.4772.1">Finally, concurrent programming is hard; it’s hard to write code that’s safe, and hard to reason about and debug when it breaks. </span><span class="koboSpan" id="kobo.4772.2">It’s important not to over-engineer your code with goroutines and use them when and where you truly need them, measure your gains and detect race conditions, avoid memory sharing if possible, and opt for communicating </span><span class="No-Break"><span class="koboSpan" id="kobo.4773.1">via channels.</span></span></p>
<h1 id="_idParaDest-108"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.4774.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.4775.1">This chapter concludes the theoretical introduction to Go as a programming language. </span><span class="koboSpan" id="kobo.4775.2">We went from Go variable types and performing operations with them, to reviewing the key building blocks of Go programs, and how to take advantage of some of Go’s most notable packages from its standard library to help you build </span><span class="No-Break"><span class="koboSpan" id="kobo.4776.1">scalable applications.</span></span></p>
<p><span class="koboSpan" id="kobo.4777.1">Starting from the next chapter, we turn our attention to network-specific tasks that are more applicable to real-world scenarios. </span><span class="koboSpan" id="kobo.4777.2">We still continue introducing some theoretical concepts throughout the book, but most content is on concrete use cases rather than </span><span class="No-Break"><span class="koboSpan" id="kobo.4778.1">abstract theory.</span></span></p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.4779.1">Further reading</span></h1>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4780.1">ch03/type-definition/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4781.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/type-definition/main.go "><span class="No-Break"><span class="koboSpan" id="kobo.4782.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/type-definition/main.go</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4783.1">ch03/string-literals/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4784.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/string-literals/main.go "><span class="No-Break"><span class="koboSpan" id="kobo.4785.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/string-literals/main.go</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4786.1">ch03/string-concatenate/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4787.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/string-concatenate/main.go "><span class="No-Break"><span class="koboSpan" id="kobo.4788.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/string-concatenate/main.go</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4789.1">ch03/string-memory/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4790.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/string-memory/main.go "><span class="No-Break"><span class="koboSpan" id="kobo.4791.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/string-memory/main.go</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4792.1">ch03/boolean/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4793.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/boolean/main.go "><span class="No-Break"><span class="koboSpan" id="kobo.4794.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/boolean/main.go</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4795.1">ch03/arrays/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4796.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/arrays/main.go"><span class="No-Break"><span class="koboSpan" id="kobo.4797.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/arrays/main.go</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4798.1">ch03/slices/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4799.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/slices/main.go"><span class="No-Break"><span class="koboSpan" id="kobo.4800.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/slices/main.go</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4801.1">ch03/maps/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4802.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/maps/main.go "><span class="No-Break"><span class="koboSpan" id="kobo.4803.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/maps/main.go</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4804.1">ch03/structs/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4805.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/structs/main.go"><span class="No-Break"><span class="koboSpan" id="kobo.4806.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/structs/main.go</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4807.1">ch03/tcp-header/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4808.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/tcp-header/main.go"><span class="No-Break"><span class="koboSpan" id="kobo.4809.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/tcp-header/main.go</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.4810.1">Comparison </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4811.1">operators</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.4812.1">: </span></span><a href="https://golang.org/ref/spec#Comparison_operators"><span class="No-Break"><span class="koboSpan" id="kobo.4813.1">https://golang.org/ref/spec#Comparison_operators</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4814.1">ch03/switch/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4815.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/switch/main.go"><span class="No-Break"><span class="koboSpan" id="kobo.4816.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/switch/main.go</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4817.1">ch03/goto/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4818.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/goto/main.go"><span class="No-Break"><span class="koboSpan" id="kobo.4819.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/goto/main.go</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4820.1">ch03/functions1/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4821.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/functions1/main.go"><span class="No-Break"><span class="koboSpan" id="kobo.4822.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/functions1/main.go</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4823.1">ch03/functions2/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4824.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/functions2/main.go"><span class="No-Break"><span class="koboSpan" id="kobo.4825.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/functions2/main.go</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4826.1">ch03/mutate-slice/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4827.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/mutate-slice/main.go"><span class="No-Break"><span class="koboSpan" id="kobo.4828.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/mutate-slice/main.go</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4829.1">ch03/methods/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4830.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/methods/main.go"><span class="No-Break"><span class="koboSpan" id="kobo.4831.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/methods/main.go</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4832.1">ch03/variadic/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4833.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/variadic/main.go"><span class="No-Break"><span class="koboSpan" id="kobo.4834.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/variadic/main.go</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4835.1">ch03/defer/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4836.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/defer/main.go"><span class="No-Break"><span class="koboSpan" id="kobo.4837.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/defer/main.go</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.4838.1">Sample </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4839.1">program</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.4840.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/interfaces-sample/main.go "><span class="No-Break"><span class="koboSpan" id="kobo.4841.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/interfaces-sample/main.go</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4842.1">ch03/io-interface1/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4843.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/io-interface1/main.go "><span class="No-Break"><span class="koboSpan" id="kobo.4844.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/io-interface1/main.go</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4845.1">ch03/io-interface2/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4846.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/io-interface2/main.go "><span class="No-Break"><span class="koboSpan" id="kobo.4847.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/io-interface2/main.go</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4848.1">ch03/reader/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4849.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/reader/main.go "><span class="No-Break"><span class="koboSpan" id="kobo.4850.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/reader/main.go</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4851.1">ch03/json</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4852.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/json "><span class="No-Break"><span class="koboSpan" id="kobo.4853.1">https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/json</span></span></a></li>
<li><span class="koboSpan" id="kobo.4854.1">Book’s GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.4855.1">repository: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go "><span class="No-Break"><span class="koboSpan" id="kobo.4856.1">https://github.com/PacktPublishing/Network-Automation-with-Go</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4857.1">ch03/json/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4858.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/json/main.go"><span class="No-Break"><span class="koboSpan" id="kobo.4859.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/json/main.go</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4860.1">ch03/json-interface</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4861.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/json-interface "><span class="No-Break"><span class="koboSpan" id="kobo.4862.1">https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/json-interface</span></span></a></li>
<li><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4863.1">GJSON</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.4864.1">: </span></span><a href="https://github.com/tidwall/gjson "><span class="No-Break"><span class="koboSpan" id="kobo.4865.1">https://github.com/tidwall/gjson</span></span></a></li>
<li><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4866.1">SJSON</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.4867.1">: </span></span><a href="https://github.com/tidwall/sjson "><span class="No-Break"><span class="koboSpan" id="kobo.4868.1">https://github.com/tidwall/sjson</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4869.1">ch03/xml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4870.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/xml "><span class="No-Break"><span class="koboSpan" id="kobo.4871.1">https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/xml</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4872.1">xmlquery</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4873.1">: </span></span><a href="https://github.com/antchfx/xmlquery "><span class="No-Break"><span class="koboSpan" id="kobo.4874.1">https://github.com/antchfx/xmlquery</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4875.1">ch03/yaml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4876.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/yaml "><span class="No-Break"><span class="koboSpan" id="kobo.4877.1">https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/yaml</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4878.1">ch03/yaml/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4879.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/yaml/main.go"><span class="No-Break"><span class="koboSpan" id="kobo.4880.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/yaml/main.go</span></span></a></li>
<li><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4881.1">yq</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.4882.1">: </span></span><a href="https://github.com/mikefarah/yq"><span class="No-Break"><span class="koboSpan" id="kobo.4883.1">https://github.com/mikefarah/yq</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4884.1">ch03/json-xml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4885.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/json-xml "><span class="No-Break"><span class="koboSpan" id="kobo.4886.1">https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/json-xml</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4887.1">ch03/single</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4888.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/single "><span class="No-Break"><span class="koboSpan" id="kobo.4889.1">https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/single</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4890.1">ch03/single/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4891.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/single/main.go "><span class="No-Break"><span class="koboSpan" id="kobo.4892.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/single/main.go</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4893.1">ch03/sequential</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4894.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/sequentia "><span class="No-Break"><span class="koboSpan" id="kobo.4895.1">https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/sequentia</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4896.1">ch03/concurrency/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4897.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/concurrency/main.go "><span class="No-Break"><span class="koboSpan" id="kobo.4898.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/concurrency/main.go</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4899.1">ch03/concurrency2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4900.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency2 "><span class="No-Break"><span class="koboSpan" id="kobo.4901.1">https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency2</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4902.1">ch03/concurrency3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4903.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency3 "><span class="No-Break"><span class="koboSpan" id="kobo.4904.1">https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency3</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4905.1">ch03/concurrency5</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4906.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency5 "><span class="No-Break"><span class="koboSpan" id="kobo.4907.1">https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency5</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4908.1">ch03/ticker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4909.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/ticker "><span class="No-Break"><span class="koboSpan" id="kobo.4910.1">https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/ticker</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.4911.1">sync.Map </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4912.1">documentation</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.4913.1">: </span></span><a href="https://pkg.go.dev/sync#Map "><span class="No-Break"><span class="koboSpan" id="kobo.4914.1">https://pkg.go.dev/sync#Map</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4915.1">ch03/concurrency4</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4916.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency4 "><span class="No-Break"><span class="koboSpan" id="kobo.4917.1">https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency4</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.4918.1">ch03/race/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.4919.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/race/main.go "><span class="No-Break"><span class="koboSpan" id="kobo.4920.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/race/main.go</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.4921.1">Simulating a real-world system in </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4922.1">Go</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.4923.1">: </span></span><a href="https://www.youtube.com/watch?v=_YK0viplIl4 "><span class="No-Break"><span class="koboSpan" id="kobo.4924.1">https://www.youtube.com/watch?v=_YK0viplIl4</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.4925.1">Concurrency is not </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4926.1">parallelism</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.4927.1">: </span></span><a href="https://blog.golang.org/waza-talk"><span class="No-Break"><span class="koboSpan" id="kobo.4928.1">https://blog.golang.org/waza-talk</span></span></a></li>
</ul>
</div>
</body></html>