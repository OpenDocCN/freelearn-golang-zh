["```go\n    cd Network-Automation-with-Go/ch03/json.\n    ```", "```go\nfunc main() {\n    var n int\n    n = 42\n}\n```", "```go\nfunc main() {\n    n := 42\n}\n```", "```go\nconst Book = \"Network Automation with Go\"\n```", "```go\nfunc main() {\n    a := -1\n    var b uint32\n    b = 4294967295\n    var c float32 = 42.1\n}\n```", "```go\nfunc main() {\n    a := 4294967295\n    b := uint32(a)\n    c := float32(b)\n}\n```", "```go\nfunc main() {\n    d := \"interpreted\\nliteral\"\n    e := `raw\nliteral`\n    fmt.Println(d)\n    fmt.Println(e)\n}\n```", "```go\nch03/string-literals$ go run main.go\ninterpreted\nliteral\nraw\nliteral\n```", "```go\nfunc main() {\n    s1 := \"Net\"\n    s2 := `work`\n    if s1 != s2 {\n        fmt.Println(s1 + s2 + \" Automation\")\n    }\n}\n```", "```go\nfunc main() {\n    n := \"Network Automation\"\n    fmt.Println(len(n))\n    w := n[3:7]\n    fmt.Println(w)\n}\n```", "```go\nch03/string-memory$ go run main.go\n18\nwork\n```", "```go\nfunc main() {\n    condition := true\n    if condition {\n        fmt.Printf(\"Type: %T, Value: %t \\n\",\n                    condition, condition)\n    }\n}\n```", "```go\nch03/boolean$ go run main.go\nType: bool, Value: true\n```", "```go\nfunc main() {\n    // Creates a variable of 'error' type\n    err1 := errors.New(\"This is a new error\")\n    // string formatting when building an error message\n    msg := \"another error message\"\n    err2 := fmt.Errorf(\"This is %s\", msg)\n}\n```", "```go\nfunc main() {\n    result, err := myFunction()\n    if err != nil {\n        fmt.Printf(\"Received an error: %s\", err)\n        return err\n    }\n}\n```", "```go\nfunc main() {\n    hostnames := [2]string{\"router1.example.com\",\n                        \"router2.example.com\"}\n    ips := [3]string{\n        \"192.0.2.1/32\",\n        \"198.51.100.1/32\",\n        \"203.0.113.1/32\",\n    }\n    // Prints router2.example.com\n    fmt.Println(hostnames[1])\n    // Prints 203.0.113.1/32\n    fmt.Println(ips[2])\n}\n```", "```go\nfunc main() {\n    // ipv4 is [0000 0000, 0000 0000, 0000 0000, 0000 0000]\n    var ipAddr [4]byte\n    // ipv4 is [1111 1111, 0000 0000, 0000 0000, 0000 0001]\n    var localhost = [4]byte{127, 0, 0, 1}\n    // prints 4\n    fmt.Println(len(localhost))\n    // prints [1111111 0 0 1]\n    fmt.Printf(\"%b\\n\", localhost)\n    // prints false\n    fmt.Println(ipAddr == localhost)\n}\n```", "```go\nfunc main() {\n    empty := []string{}\n    words := []string{\"zero\", \"one\", \"two\", \"three\",\n                    \"four\", \"five\", \"six\"}\n    three := make([]string, 3)\n    fmt.Printf(\"empty: length: %d, capacity: %d, %v\\n\",\n                     len(empty), cap(empty), empty)\n    fmt.Printf(\"words: length: %d, capacity: %d, %v\\n\",\n                    len(words), cap(words), words)\n    fmt.Printf(\"three: length: %d, capacity: %d, %v\\n\",\n                    len(three), cap(three), three)\n    /* ... <continues next > ... */\n}\n```", "```go\nch03/slices$ go run main.go\nempty: length: 0, capacity: 0, []\nwords: length: 7, capacity: 7, [zero one two three four five six]\nthree: length: 3, capacity: 3, [  ]\n```", "```go\nfunc main() {\n    /* ... <continues from before > ... */\n    mySlice := words[1:3]\n    fmt.Printf(\" mySlice: length: %d, capacity: %d, %v\\n\",\n            len(mySlice), cap(mySlice), mySlice)\n    mySlice = append(mySlice, \"seven\")\n    fmt.Printf(\" mySlice: length: %d, capacity: %d, %v\\n\",\n            len(mySlice), cap(mySlice), mySlice)\n    mySlice = append(mySlice, \"eight\", \"nine\", \"ten\",\n                    \"eleven\")\n    fmt.Printf(\" mySlice: length: %d, capacity: %d, %v\\n\",\n            len(mySlice), cap(mySlice), mySlice)\n}\n```", "```go\nch03/slices$ go run main.go\n...\n mySlice: length: 2, capacity: 6, [one two]\n mySlice: length: 3, capacity: 6, [one two seven]\n mySlice: length: 7, capacity: 12, [one two seven eight nine ten eleven]\n```", "```go\nfunc main() {\n    dc := make(map[string]string)\n    dc[\"spine\"] = \"192.168.100.1\"\n    ip := dc[\"spine\"]\n    ip, exists := dc[\"spine\"]\n    if exists {\n        fmt.Println(ip)\n    }\n}\n```", "```go\nfunc main() {\n    inv := map[string]string{\n        \"router1.example.com\": \"192.0.2.1/32\",\n        \"router2.example.com\": \"198.51.100.1/32\",\n    }\n    fmt.Printf(\"inventory: length: %d, %v\\n\", len(inv),\n                inv)\n    delete(inv, \"router1.example.com\")\n    fmt.Printf(\"inventory: length: %d, %v\\n\", len(inv),\n                inv)\n}\n```", "```go\nch03/maps$ go run main.go\ninventory: length: 2, map[router1.example.com:192.0.2.1/32 router2.example.com:198.51.100.1/32]\ninventory: length: 1, map[router2.example.com:198.51.100.1/32]\n```", "```go\ntype Router struct {\n    Hostname  string\n    Platform  string\n    Username  string\n    Password  string\n    StrictKey bool\n}\n```", "```go\ntype Inventory struct {\n    Routers []Router\n}\n```", "```go\nfunc main() {\n    var r1 Router\n    r1.Hostname = \"router1.example.com\"\n    r2 := new(Router)\n    r2.Hostname = \"router2.example.com\"\n    r3 := Router{\n        Hostname:  \"router3.example.com\",\n        Platform:  \"cisco_iosxr\",\n        Username:  \"user\",\n        Password:  \"secret\",\n        StrictKey: false,\n    }\n    /* ... <continues next > ... */\n}\n```", "```go\nfunc main() {\n    /* ... <continues from before > ... */\n    inv := Inventory{\n        Routers: []Router{r1, *r2, r3},\n    }\n    fmt.Printf(\"Inventory: %+v\\n\", inv)\n}\n```", "```go\nch03/structs$ go run main.go\nInventory: {Routers:[{Hostname:router1.example.com Platform: Username: Password: StrictKey:false} {Hostname:router2.example.com Platform: Username: Password: StrictKey:false} {Hostname:router3.example.com Platform:cisco_iosxr Username:user Password:secret StrictKey:false}]}\n```", "```go\nfunc main() {\n    // sum s == 42\n    s := 40 + 2\n    // difference d == 0.14\n    d := 3.14 - 3\n    // product p == 9.42\n    p := 3 * 3.14\n    // quotient q == 0\n    q := 3.0 / 5\n    // remainder r == 2\n    r :=  5 % 3\n}\n```", "```go\nfunc main() {\n    // s == \"Hello, World\"\n    s := \"Hello\" + \", \" + \"World\"\n}\n```", "```go\nfunc main() {\n    // Header length (measured in 32-bit words) is 5\n    var headerWords uint8 = 5\n    // Header length in bytes is 20\n    headerLen := headerWords * 32 / 8\n    // Build a slice of 20 bytes to store the TCP header\n    b := make([]byte, headerLen)\n    // Shift header words bits to the left to fit\n    // the Header Length field of the TCP header\n    s := headerWords << 4\n    // OR operation on byte 13 and the store new value\n    b[13] = b[13] | s\n    // Print the 13 byte of the TCP header -> [01010000]\n    fmt.Printf(\"%08b\\n\", b[13])\n    /* ... <continues next > ... */\n}\n```", "```go\nfunc main() {\n    /* ... <continues from before > ... */\n    // assume that this is the initial TCP SYN message\n    var tcpSyn uint8 = 1\n    // SYN flag is the second bit from the right so\n    // we shift it by 1 position\n    f := tcpSyn << 1\n    // OR operation on byte 14 and store the new value\n    b[14] = b[14] | f\n    // Print the 14 byte of the TCP header -> [00000010]\n    fmt.Printf(\"%08b\\n\", b[14])\n    /* ... <continues next > ... */\n}\n```", "```go\nfunc main() {\n    /* ... <continues from before > ... */\n    // only interested if a TCP SYN flag has been set\n    tcpSynFlag := (b[14] & 0x02) != 0\n    // Shift header length right, drop any low-order bits\n    parsedHeaderWords := b[13] >> 4\n    // prints \"TCP Flag is set: true\"\n    fmt.Printf(\"TCP Flag is set: %t\\n\", tcpSynFlag)\n    // prints \"TCP header words: 5\"\n    fmt.Printf(\"TCP header words: %d\\n\", parsedHeaderWords)\n}\n```", "```go\nfunc main() {\n    // all strings are comparable\n    fmt.Println(\"hello\" == \"hello\")\n    // strings are ordered alphabetically\n    fmt.Println(\"hello\" < \"world\")\n    // integers are comparable and ordered\n    fmt.Println(1 < 10)\n    // floating point numbers are also comparable\n    fmt.Println(10.0 >= 1.1)\n}\n```", "```go\nfunc main() {\n    for i := 0; i < 5; i++ {\n        fmt.Println(i)\n    }\n}\n```", "```go\n    func main() {\n    ```", "```go\n        slice := []string{\"r1\", \"r2\", \"r3\"}\n    ```", "```go\n        for i, v := range slice {\n    ```", "```go\n            fmt.Printf(\"index %d: value: %s\\n\", i, v)\n    ```", "```go\n        }\n    ```", "```go\n    }\n    ```", "```go\n    func main() {\n    ```", "```go\n        hashMap := map[int]string{\n    ```", "```go\n            1: \"r1\",\n    ```", "```go\n            2: \"r2\",\n    ```", "```go\n            3: \"r3\",\n    ```", "```go\n        }\n    ```", "```go\n        for i, v := range hashMap {\n    ```", "```go\n            fmt.Printf(\"key %d: value: %s\\n\", i, v)\n    ```", "```go\n        }\n    ```", "```go\n    }\n    ```", "```go\nfunc main() {\n    for {\n        time.Sleep(time.Second)\n        break\n    }\n}\n```", "```go\nfunc main() {\n    i := 0\n    for i < 5 {\n        fmt.Println(i)\n        i++\n    }\n}\n```", "```go\nfuncmain() {\n    // prints 0 2 4\n    for i := 0; i < 5; i++ {\n        if i % 2 != 0 {\n            continue\n        }\n        fmt.Println(i)\n    }\n}\n```", "```go\nfunc main() {\n    resp, err := http.Get(\"https://www.tkng.io/\")\n    if err != nil {\n            log.Fatalf(\"Could not connect: %v\", err)\n    } else {\n            fmt.Printf(\"Received response: %v\",\n                        resp.Status)\n    }\n}\n```", "```go\nfunc main() {\n    resp, err := http.Get(\"https://www.tkng.io/\")\n    if err != nil {\n            log.Fatalf(\"Could not connect: %v\", err)\n    }\n    fmt.Printf(\"Received response: %v\", resp.Status)\n}\n```", "```go\nfunc main() {\n    resp, err := http.Get(\"http://httpstat.us/304\")\n    if err != nil {\n        log.Fatalf(\"Could not connect: %v\", err)\n    }\n    switch {\n    case resp.StatusCode >= 600:\n        fmt.Println(\"Unknown\")\n    case resp.StatusCode >= 500:\n        fmt.Println(\"Server Error\")\n    case resp.StatusCode >= 400:\n        fmt.Println(\"Client Error\")\n    case resp.StatusCode >= 300:\n        fmt.Println(\"Redirect\")\n    case resp.StatusCode >= 200:\n        fmt.Println(\"Success\")\n    case resp.StatusCode >= 100:\n        fmt.Println(\"Informational\")\n    default:\n        fmt.Println(\"Incorrect\")\n    }\n}\n```", "```go\nfunc main() {\n    resp, err := http.Get(\"http://httpstat.us/304\")\n    if err != nil {\n        log.Fatalf(\"Could not connect: %v\", err)\n    }\n    switch {\n    case resp.StatusCode >= 600:\n        fmt.Println(\"Unknown\")\n        goto exception\n    case resp.StatusCode >= 500:\n        fmt.Println(\"Server Error\")\n        goto failure\n    case resp.StatusCode >= 400:\n        fmt.Println(\"Client Error\")\n        goto failure\n    case resp.StatusCode >= 300:\n        fmt.Println(\"Redirect\")\n        goto exit\n    case resp.StatusCode >= 200:\n        fmt.Println(\"Success\")\n        goto exit\n    case resp.StatusCode >= 100:\n        fmt.Println(\"Informational\")\n        goto exit\n    default:\n        fmt.Println(\"Incorrect\")\n        goto exception\n    }\n   exception:\n    panic(\"Unexpected response\")\n   failure:\n    log.Fatalf(\"Failed to connect: %v\", err)\n   exit:\n    fmt.Println(\"Connection successful\")\n}\n```", "```go\nfunc generateName(base string, suffix string) string {\n    parts := []string{base, suffix}\n    return strings.Join(parts, \"-\")\n}\nfunc main() {\n    s := generateName(\"device\", \"01\")\n    // prints \"device-01\"\n    fmt.Println(s)\n}\n```", "```go\nfunc processDevice(getName func (string, string) string, ip string) {\n    base := \"device\"\n    name := getName(base, ip)\n    fmt.Println(name)\n}\n```", "```go\nfunc main() {\n    // prints \"device-192.0.2.1\"\n    processDevice(generateName, \"192.0.2.1\")\n}\n```", "```go\ntype Device struct {\n    name string\n}\nfunc mutate(input Device) {\n    input.name += \"-suffix\"\n}\nfunc main() {\n    d := Device{name: \"myname\"}\n    mutate(d)\n    // prints \"myname\"\n    fmt.Println(d.name)\n}\n```", "```go\ntype Device struct {\n    name string\n}\nfunc mutate(input *Device) {\n    input.name += \"-suffix\"\n}\nfunc main() {\n    d := Device{name: \"myname\"}\n    mutate(&d)\n    // prints \"myname-suffix\"\n    fmt.Println(d.name)\n}\n```", "```go\nfunc fn(m map[int]int) {\n    m[1] = 11\n}\nfunc main() {\n    m := make(map[int]int)\n    fn(m)\n    // prints 11\n    fmt.Println(m[1])\n}\n```", "```go\nfunc mutateV(input []string) {\n    input [0] = \"r03\"\n    input  = append(input , \"r04\")\n}\nfunc main() {\n    d1 := []string{\"r01\", \"r02\"}\n    mutateV(d1)\n    // prints \"[r03 r02]\"\n    fmt.Printf(\"%v\\n\", d1)\n}\n```", "```go\nfunc mutateP(input *[]string) {\n    (*input)[0] = \"r03\"\n    *input = append(*input, \"r04\")\n}\nfunc main() {\n    d2 := []string{\"r01\", \"r02\"}\n    mutateP(&d2)\n    // prints \"[r03 r02 r04]\"\n    fmt.Printf(\"%v\\n\", d2)\n}\n```", "```go\nfunc makeCall(url string) (*http.Response, error) {\n    resp, err := http.Get(\"example.com\")\n    if err != nil {\n        return nil, fmt.Errorf(\"error in makeCall: %w\",\n                                err)\n    }\n    return resp, nil\n}\n```", "```go\ntype Device struct {\n    name string\n}\nfunc (d Device) GetFullName() string {\n    return d.name\n}\nfunc main() {\n    d1 := Device{name: \"r1\"}\n    // prints \"r1\"\n    fmt.Println(d1.GetFullName())\n}\n```", "```go\ntype Device struct {\n    name string\n}\nfunc (d *Device) GenerateName() {\n    d.name = \"device-\" + d.name\n}\nfunc (d Device) GetFullName() string {\n    return d.name\n}\nfunc main() {\n    d2 := Device{name: \"r2\"}\n    d2.GenerateName()\n    // prints \"device-r2\"\n    fmt.Println(d2.GetFullName())\n}\n```", "```go\nfunc printOctets(octets ...string) {\n    fmt.Println(strings.Join(octets, \".\"))\n}\nfunc main() {\n    // prints \"127.1\"\n    printOctets(\"127\", \"1\")\n    ip := []string{\"192\", \"0\", \"2\", \"1\"}\n    // prints \"192.0.2.1\"\n    printOctets(ip...)\n}\n```", "```go\nfunc suffixGenerator() func() string {\n    i := 0\n    return func() string {\n        i++\n        return fmt.Sprintf(\"%02d\", i)\n    }\n}\nfunc main() {\n    generator1 := suffixGenerator()\n    // prints \"device-01\"\n    fmt.Printf(\"%s-%s\\n\", \"device\", generator1())\n    // prints \"device-02\"\n    fmt.Printf(\"%s-%s\\n\", \"device\", generator1())\n    generator2 := suffixGenerator()\n    // prints \"device-01\"\n    fmt.Printf(\"%s-%s\\n\", \"device\", generator2())\n}\n```", "```go\nfunc main() {\n    resp, err := http.Get(\"http://example.com\")\n    if err != nil {\n        panic(err)\n    }\n    defer resp.Body.Close()\n    defer fmt.Println(\"Deferred cleanup\")\n    fmt.Println(\"Response status:\", resp.Status)\n}\n```", "```go\nch03/defer$ go run main.go\nResponse status: 200 OK\nDeferred cleanup\n```", "```go\ntype CiscoIOS struct {\n    Hostname string\n    Platform string\n}\nfunc (r CiscoIOS) getUptime() int {\n    /* ... <omitted for brevity > ... */\n}\nfunc LastToReboot(r1, r2 CiscoIOS) bool {\n    return r1.getUptime() < r2.getUptime()\n}\n```", "```go\ntype CiscoNXOS struct {\n    Hostname string\n    Platform string\n    ACI      bool\n}\nfunc (s CiscoNXOS) getUptime() int {\n    /* ... <omitted for brevity > ... */\n}\n```", "```go\ntype NetworkDevice interface {\n    getUptime() int\n}\n```", "```go\nfunc LastToReboot(r1, r2 NetworkDevice) bool {\n    return r1.getUptime() < r2.getUptime()\n}\n```", "```go\nfunc main() {\n    ios := CiscoIOS{}\n    nexus := CiscoNXOS{}\n    if LastToReboot(ios, nexus) {\n        fmt.Println(\"IOS-XE has been running for less time, so it was the last to be rebooted\")\n        os.Exit(0)\n    }\n    fmt.Println(\"NXOS was the last one to reboot\")\n}\n```", "```go\n// src/net/net.go\n// Conn is a generic stream-oriented network connection.\ntype Conn interface {\n    /* ... <omitted for brevity > ... */\n    // LocalAddr returns the local network address.\n    LocalAddr() Addr\n    // RemoteAddr returns the remote network address.\n    RemoteAddr() Addr\n    SetDeadline(t time.Time) error\n    SetReadDeadline(t time.Time) error\n    SetWriteDeadline(t time.Time) error\n}\n```", "```go\n// ssh/tcpip.go\n// chanConn fulfills the net.Conn interface without\n// the tcpChan having to hold laddr or raddr directly.\ntype chanConn struct {\n    /* ... <omitted for brevity > ... */\n    laddr, raddr net.Addr\n}\n// LocalAddr returns the local network address.\nfunc (t *chanConn) LocalAddr() net.Addr {\n    return t.laddr\n}\n// RemoteAddr returns the remote network address.\nfunc (t *chanConn) RemoteAddr() net.Addr {\n    return t.raddr\n}\nfunc (t *chanConn) SetDeadline(deadline time.Time) error {\n    if err := t.SetReadDeadline(deadline); err != nil {\n        return err\n    }\n    return t.SetWriteDeadline(deadline)\n}\nfunc (t *chanConn) SetReadDeadline(deadline time.Time) error {\n    return errors.New(\"ssh: tcpChan: deadline not supported\")\n}\nfunc (t *chanConn) SetWriteDeadline(deadline time.Time) error {\n    return errors.New(\"ssh: tcpChan: deadline not supported\")\n}\n```", "```go\n// ssh/tcpip.go\n// Dial initiates a conn to the addr from remote host.\n// Resulting conn has a zero LocalAddr() and RemoteAddr().\nfunc (c *Client) Dial(n, addr string) (net.Conn, error) {\n    var ch Channel\n    switch n {\n    case \"tcp\", \"tcp4\", \"tcp6\":\n    // Parse the address into host and numeric port.\n    host, portString, err := net.SplitHostPort(addr)\n    if err != nil {\n        return nil, err\n    }\n    /* ... <omitted for brevity > ... */\n    return &chanConn{\n        Channel: ch,\n        laddr:   zeroAddr,\n        raddr:   zeroAddr,\n    }, nil\n    /* ... <omitted for brevity > ... */\n}\n```", "```go\nfunc main() {\n    var r io.Reader\n    r = strings.NewReader(\"a random text\")\n    io.Copy(os.Stdout, r)\n}\n```", "```go\ntype Reader interface {\n    Read(p []byte) (n int, err error)\n}\n```", "```go\n// src/strings/reader.go\n// A Reader implements the io.Reader, ...\n// from a string.\ntype Reader struct {\n    s        string\n    i        int64 // current reading index\n    prevRune int   // index of previous rune; or < 0\n}\n// Read implements the io.Reader interface.\nfunc (r *Reader) Read(b []byte) (n int, err error) {\n    if r.i >= int64(len(r.s)) {\n        return 0, io.EOF\n    }\n    r.prevRune = -1\n    n = copy(b, r.s[r.i:])\n    r.i += int64(n)\n    return\n}\n// NewReader returns a new Reader reading from s.\nfunc NewReader(s string) *Reader { return &Reader{s, 0, -1} }\n```", "```go\ntype Writer interface {\n    Write(p []byte) (n int, err error)\n}\n```", "```go\n// src/os/types.go\n// File represents an open file descriptor.\ntype File struct {\n    *file // os specific\n}\n// Read reads up to len(b) bytes from the File.\n// It returns the number of bytes read and any error.\n// At end of file, Read returns 0, io.EOF.\nfunc (f *File) Read(b []byte) (n int, err error) {\n    if err := f.checkValid(\"read\"); err != nil {\n        return 0, err\n    }\n    n, e := f.read(b)\n    return n, f.wrapErr(\"read\", e)\n}\nfunc Create(name string) (*File, error) {\n    return OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666)\n}\n```", "```go\n// src/io/io.go\n// Copy copies from src to dst until either EOF is reached\n// on src or an error occurs.\nfunc Copy(dst Writer, src Reader) (written int64, err error) {\n    return copyBuffer(dst, src, nil)\n}\n```", "```go\nfunc main() {\n    src := strings.NewReader(\"The text\")\n    dst, err := os.Create(\"./file.txt\")\n    if err != nil {\n        panic(err)\n    }\n    defer dst.Close()\n    io.Copy(dst, src)\n}\n```", "```go\nch03/io-interface1$ go run main.go\nch03/io-interface1$ cat file.txt\nThe text\n```", "```go\nfunc main() {\n    res, err := http.Get(\"https://www.tkng.io/\")\n    if err != nil {\n        panic(err)\n    }\n    src := res.Body\n    defer src.Close()\n    dst := os.Stdout\n    io.Copy(dst, src)\n}\n```", "```go\nch03/io-interface2$ go run main.go\n<!doctype html><html lang=en class=\"js csstransforms3d\"><head><meta charset=utf-8><meta name=viewport content=\"width=device-width,initial-scale=1\"><meta name=generator content=\"Hugo 0.74.3\"><meta name=description content=\"The Kubernetes Networking Guide\">...\n```", "```go\ntype myReader struct {\n    src io.Reader\n}\nfunc (r *myReader) Read(buf []byte) (int, error) {\n    tmp := make([]byte, len(buf))\n    n, err := r.src.Read(tmp)\n    copy(buf[:n], bytes.Title(tmp[:n]))\n    return n, err\n}\nfunc NewMyReader(r io.Reader) io.Reader {\n    return &myReader{src: r}\n}\n```", "```go\nfunc main() {\n    r1 := strings.NewReader(\"network automation with go\")\n    r2 := NewMyReader(r1)\n    io.Copy(os.Stdout, r2)\n}\n```", "```go\nch03/reader$ go run main.go\nNetwork Automation With Go\n```", "```go\n{\n  \"router\": [\n    {\n      \"hostname\": \"router1.example.com\",\n      \"ip\": \"192.0.2.1\",\n      \"asn\": 64512\n    },\n    {\n      \"hostname\": \"router2.example.com\",\n      \"ip\": \"198.51.100.1\",\n      \"asn\": 65535\n    }\n  ]\n}\n```", "```go\ntype Router struct {\n    Hostname string `json:\"hostname\"`\n    IP       string `json:\"ip\"`\n    ASN      uint16 `json:\"asn\"`\n}\ntype Inventory struct {\n    Routers []Router `json:\"router\"`\n}\n```", "```go\nfunc main() {\n    file, err := os.Open(\"input.json\")\n    // process error\n    defer file.Close()\n    /* ... <continues next > ... */\n}\n```", "```go\nfunc main() {\n    /* ... <continues from before > ... */\n    d := json.NewDecoder(file)\n    /* ... <continues next > ... */\n}\n```", "```go\nfunc main() {\n    /* ... <continues from before > ... */\n    var inv Inventory\n    err = d.Decode(&inv)\n    // process error\n    fmt.Printf(\"%+v\\n\", inv)\n}\n```", "```go\nch03/json$ go run main.go\n{Routers:[{Hostname:router1.example.com IP:192.0.2.1 ASN:64512} {Hostname:router2.example.com IP:198.51.100.1 ASN:65535}]}\n```", "```go\nfunc main() {\n    /* ... <omitted for brevity > ... */\n    var empty map[string]interface{}\n    err = d.Decode(&empty)\n    // process error\n    // prints map[router:[map[asn:64512 hostname:router1.example.com\n    // ip:192.0.2.1] map[asn:65535 hostname:router2.example.com\n    // ip:198.51.100.1]]]\n    fmt.Printf(\"%v\\n\", empty)\n    /* ... <continues next > ... */\n}\n```", "```go\nfunc main() {\n    /* ... <continues from before > ... */\n    for _, r := range empty[\"router\"].([]interface{}) {\n        fmt.Printf(\"%v\\n\", r)\n    }\n}\n```", "```go\nch03/json-interface $ go run main.go\n...\nmap[asn:64512 hostname:router1.example.com ip:192.0.2.1]\nmap[asn:65535 hostname:router2.example.com ip:198.51.100.1]\n```", "```go\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<routers>\n  <router>\n    <hostname>router1.example.com</hostname>\n    <ip>192.0.2.1</ip>\n    <asn>64512</asn>\n  </router>\n  <router>\n    <hostname>router2.example.com</hostname>\n    <ip>198.51.100.1</ip>\n    <asn>65535</asn>\n  </router>\n</routers>\n```", "```go\npackage main\nimport (\n    \"os\"\n    \"encoding/xml\"\n)\ntype Router struct {\n    Hostname string `xml:\"hostname\"`\n    IP       string `xml:\"ip\"`\n    ASN      uint16 `xml:\"asn\"`\n}\ntype Inventory struct {\n    Routers []Router `xml:\"router\"`\n}\nfunc main() {\n    file, err := os.Open(\"input.xml\")\n    /* ... <omitted for brevity > ... */\n    d := xml.NewDecoder(file)\n    /* ... <omitted for brevity > ... */\n}\n```", "```go\nrouter:\n  - hostname: \"router1.example.com\"\n    ip: \"192.0.2.1\"\n    asn: 64512\n  - hostname: \"router2.example.com\"\n    ip: \"198.51.100.1\"\n    asn: 65535\n```", "```go\npackage main\nimport (\n    \"os\"\n    \"gopkg.in/yaml.v2\"\n)\ntype Router struct {\n    Hostname string `yaml:\"hostname\"`\n    IP       string `yaml:\"ip\"`\n    ASN      uint16 `yaml:\"asn\"`\n}\ntype Inventory struct {\n    Routers []Router `yaml:\"router\"`\n}\nfunc main() {\n    /* ... <omitted for brevity > ... */\n    d := yaml.NewDecoder(file)\n    /* ... <omitted for brevity > ... */\n}\n```", "```go\nch03/yaml$ go get gopkg.in/yaml.v2\ngo get: added gopkg.in/yaml.v2 v2.4.0\nch03/yaml$ go run main.go\n{Routers:[{Hostname:router1.example.com IP:192.0.2.1 ASN:64512} {Hostname:router2.example.com IP:198.51.100.1 ASN:65535}]}\n```", "```go\ntype Router struct {\n    Hostname string `json:\"hostname\" xml:\"hostname\"`\n    IP       string `json:\"ip\" xml:\"ip\"`\n    ASN      uint16 `json:\"asn\" xml:\"asn\"`\n}\ntype Inventory struct {\n    Routers []Router `json:\"router\" xml:\"router\"`\n}\n```", "```go\nfunc main() {\n    /* ... <omitted for brevity > ... */\n    var dest strings.Builder\n    e := xml.NewEncoder(&dest)\n    err = e.Encode(&inv)\n    // process error\n    fmt.Printf(\"%+v\\n\", dest.String())\n}\n```", "```go\nch03/json-xml$ go run main.go\n<Inventory><router><hostname>router1.example.com</hostname><ip>192.0.2.1</ip><asn>64512</asn></router><router><hostname>router2.example.com</hostname><ip>198.51.100.1</ip><asn>65535</asn></router></Inventory>\n```", "```go\nrouter:\n- hostname: sandbox-iosxe-latest-1.cisco.com\n  platform: cisco_iosxe\n  strictkey: false\n  username: developer\n  password: C1sco12345\n```", "```go\ntype Router struct {\n    Hostname  string `yaml:\"hostname\"`\n    /* ... <omitted for brevity > ... */\n}\ntype Inventory struct {\n    Routers []Router `yaml:\"router\"`\n}\n```", "```go\nfunc getVersion(r Router) {\n    /* ... <omitted for brevity > ... */\n}\nfunc main() {\n    src, err := os.Open(\"input.yml\")\n    //process error\n    defer src.Close()\n    d := yaml.NewDecoder(src)\n    var inv Inventory\n    err = d.Decode(&inv)\n    // process error\n    getVersion(inv.Routers[0])\n}\n```", "```go\nch03/single$ go run main.go\nHostname: sandbox-iosxe-latest-1.cisco.com\nHardware: [CSR1000V]\nSW Version: 17.3.1a\nUptime: 5 hours, 1 minute\nThis process took 1.779684183s\n```", "```go\nrouter:\n- hostname: sandbox-iosxe-latest-1.cisco.com\n  platform: cisco_iosxe\n  ...\n- hostname: sandbox-nxos-1.cisco.com\n  platform: cisco_nxos\n  ...\n- hostname: sandbox-iosxr-1.cisco.com\n  platform: cisco_iosxr\n  ...\n```", "```go\nfunc main() {\n    /* ... <omitted for brevity > ... */\n    for _, r := range inv.Routers {\n        getVersion(v)\n    }\n}\n```", "```go\nch03/sequential$ go run main.go\nHostname: sandbox-iosxe-latest-1.cisco.com\nHardware: [CSR1000V]\nSW Version: 17.3.1a\nUptime: 5 hours, 25 minutes\nHostname: sandbox-nxos-1.cisco.com\nHardware: C9300v\nSW Version: 9.3(3)\nUptime: 0 day(s), 3 hour(s), 2 minute(s), 18 second(s)\nHostname: sandbox-iosxr-1.cisco.com\nHardware: IOS-XRv 9000\nSW Version: 6.5.3\nUptime: 2 weeks 8 hours 23 minutes\nThis process took 6.984502353s\n```", "```go\nfunc main() {\n    /* ... <omitted for brevity > ... */\n    for _, r := range inv.Routers {\n        go getVersion(v)\n    }\n}\n```", "```go\nfunc main() {\n    /* ... <omitted for brevity > ... */\n    var wg sync.WaitGroup\n    for _, v := range inv.Routers {\n        wg.Add(1)\n        go func(r Router) {\n            defer wg.Done()\n            getVersion(r)\n        }(v)\n    }\n    wg.Wait()\n}\n```", "```go\nch03/concurrency$ go run main.go\nHostname: sandbox-iosxe-latest-1.cisco.com\nHardware: [CSR1000V]\nSW Version: 17.3.1a\nUptime: 5 hours, 26 minutes\nHostname: sandbox-iosxr-1.cisco.com\nHardware: IOS-XRv 9000\nSW Version: 6.5.3\nUptime: 2 weeks 8 hours 25 minutes\nHostname: sandbox-nxos-1.cisco.com\nHardware: C9300v\nSW Version: 9.3(3)\nUptime: 0 day(s), 3 hour(s), 4 minute(s), 11 second(s)\nThis process took 2.746996304s\n```", "```go\nfunc getVersion(r Router, wg *sync.WaitGroup) {\n    defer wg.Done()\n    /* ... <omitted for brevity > ... */\n}\n```", "```go\nfunc main() {\n    /* ... <omitted for brevity > ... */\n    for _, v := range inv.Routers {\n        wg.Add(1)\n        go getVersion(v, &wg)\n    }\n    wg.Wait()\n}\n```", "```go\nfunc main() {\n    ch := make(chan int, 1)\n    send := 1\n    ch <- send\n    receive := <-ch\n    // prints 1\n    fmt.Println(receive)\n}\n```", "```go\nfunc printer(in chan data {\n    for out := range in {\n        fmt.Printf(\"Hostname: %s\\nHW: %s\\nSW Version: %s\\nUptime: %s\\n\\n\", out.host, out.hw, out.version, out.uptime)\n    }\n}\n```", "```go\nfuncmain() {\n    /* ... <omitted for brevity > ... */\n    ch := make(chan data)\n    go printer(ch)\n    var wg sync.WaitGroup\n    for _, v := range inv.Routers {\n        wg.Add(1)\n        go getVersion(v, ch, &wg)\n    }\n    wg.Wait()\n    close(ch)\n}\n```", "```go\nch03/concurrency3$ gorun main.go\nHostname: sandbox-iosxe-latest-1.cisco.com\nHW: [CSR1000V]\nSW Version: 17.3.1a\nUptime: 1 day, 12 hours, 42 minutes\nHostname: sandbox-iosxr-1.cisco.com\nHW: IOS-XRv 9000\nSW Version: 7.3.2\nUptime: 1 day 2 hours 57 minutes\nHostname: sandbox-nxos-1.cisco.com\nHW: C9300v\nSW Version: 9.3(3)\nUptime: 5 day(s), 6 hour(s), 25 minute(s), 44 second(s)\n```", "```go\nfunc main() {\n    /* ... <omitted for brevity > ... */\n    for {\n        select {\n        case out := <-ch:\n            fmt.Printf(\n    \"Hostname: %s\\nHW: %s\\nSW Version: %s\\nUptime:%s\\n\\n\",\n            out.host, out.hw, out.version, out.uptime)\n        case <-time.After(5 * time.Second):\n            close(ch)\n            fmt.Println(\"Timeout: 5 seconds\")\n            return\n        }\n    }\n}\n```", "```go\nfunc main() {\n    ticker := time.NewTicker(500 * time.Millisecond)\n    done := make(chan bool)\n    go repeat(done, ticker.C)\n    time.Sleep(2100 * time.Millisecond)\n    ticker.Stop()\n    done <- true\n}\n```", "```go\nfunc repeat(d chan bool, c <-chan time.Time) {\n    for {\n        select {\n        case <-d:\n            return\n        case t := <-c:\n            fmt.Println(\"Run at\", t.Local())\n        }\n    }\n}\n```", "```go\nch03/ticker$ gorun main.go\nTick at 2021-11-17 23:19:33.914906389 -0500 EST\nTick at 2021-11-17 23:19:34.414279709 -0500 EST\nTick at 2021-11-17 23:19:34.915058301 -0500 EST\n```", "```go\nfunc main() {\n    /* ... <omitted for brevity > ... */\n    isAlive := make(map[string]bool)\n    /* ... <omitted for brevity > ... */\n    for _, v := range inv.Routers {\n        wg.Add(1)\n        go getVersion(v, ch, &wg, isAlive)\n    }\n    /* ... <omitted for brevity > ... */\n}\n```", "```go\nvar m sync.RWMutex = sync.RWMutex{}\nfunc getVersion(r Router, out chan data, wg *sync.WaitGroup, isAlive map[string]bool) {\n    defer wg.Done()\n    /* ... <omitted for brevity > ... */\n    rs, err := d.SendCommand(\"show version\")\n    if err != nil {\n        fmt.Printf(\"fail to send cmd for %s: %+v\\n\",\n                    r.Hostname, err)\n        m.Lock()\n        isAlive[r.Hostname] = false\n        m.Unlock()\n        return\n    }\n    m.Lock()\n    isAlive[r.Hostname] = true\n    m.Unlock()\n}\n```", "```go\nfunc main() {\n    /* ... <omitted for brevity > ... */\n    m.RLock()\n    for name, v := range isAlive {\n        fmt.Printf(\"Router %s is alive: %t\\n\", name, v)\n    }\n    m.RUnlock()\n    /* ... <omitted for brevity > ... */\n}\n```", "```go\nch03/concurrency4$ go run main.go\nHostname: sandbox-iosxe-latest-1.cisco.com\nHardware: [CSR1000V]\nSW Version: 17.3.1a\nUptime: 8 hours, 27 minutes\nHostname: sandbox-iosxr-1.cisco.com\nHardware: IOS-XRv 9000\nSW Version: 7.3.2\nUptime: 1 day 11 hours 43 minutes\nHostname: sandbox-nxos-1.cisco.com\nHardware: C9300v\nSW Version: 9.3(3)\nUptime: 5 day(s), 15 hour(s), 11 minute(s), 42 second(s)\nRouter sandbox-iosxe-latest-1.cisco.com is alive: true\nRouter sandbox-iosxr-1.cisco.com is alive: true\nRouter sandbox-nxos-1.cisco.com is alive: true\nThis process took 3.129440011s\n```", "```go\nfunc getVersion(r Router, out chan map[string]interface{}, wg *sync.WaitGroup, isAlive map[string]bool) {\n    defer wg.Done()\n    /* ... <omitted for brevity > ... */\n    // m.Lock()\n    isAlive[r.Hostname] = true\n    // m.Unlock()\n    out <- \"test\"\n}\n```", "```go\nch03/race$ gorun -race main.go\nMESSAGE: test\nMESSAGE: test\n==================\nWARNING: DATA RACE\nWrite at 0x00c00011c6f0 by goroutine 9:\n  runtime.mapassign_faststr()\n      /usr/local/go/src/runtime/map_faststr.go:202 +0x0\n  main.getVersion()\n      ~/Network-Automation-with-Go/ch03/race/main.go:35 +0xeb\n  main.main·dwrap·5()\n      ~/Network-Automation-with-Go/ch03/race/main.go:74 +0x110\n...\n==================\nMESSAGE: test\nRouter sandbox-iosxe-latest-1.cisco.com is alive: true\nRouter sandbox-iosxr-1.cisco.com is alive: true\nRouter sandbox-nxos-1.cisco.com is alive: true\nThis process took 1.918348ms\nFound 1 data race(s)\nexit status 66\n```"]