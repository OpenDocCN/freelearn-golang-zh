- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting Started with Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we dive into the Go basics and the characteristics that make
    it comparable to a dynamically typed language, but with the efficiency and safety
    of a statically typed, compiled language.
  prefs: []
  type: TYPE_NORMAL
- en: We also explore different Go packages to manipulate data in different formats
    and how to scale programs with Go’s concurrency model. Being able to manipulate
    data effectively and take advantage of all the resources of systems running multi-core
    processors are key elements to keep in mind when automating networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'During this chapter, we cover the following key topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Go variable types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go’s arithmetic, comparison, and logical operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input and output operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoding and encoding with Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We assume basic familiarity with the command line, Git, and GitHub. You can
    find the code examples for this chapter in the book’s GitHub repository at [https://github.com/PacktPublishing/Network-Automation-with-Go](https://github.com/PacktPublishing/Network-Automation-with-Go),
    under the `ch03` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the examples, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Install Go 1.17 or later for your operating system. You can follow the instructions
    in [*Chapter 1*](B16971_01.xhtml#_idTextAnchor015), *Introduction*, in the *Installing
    Go* section, or go to [https://go.dev/doc/install](https://go.dev/doc/install).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clone the book’s GitHub repository with `git` `clone` [https://github.com/PacktPublishing/Network-Automation-with-Go.git](https://github.com/PacktPublishing/Network-Automation-with-Go.git).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the directory to an example folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Execute `go` `run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go’s type system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go is a statically typed language, which means the compiler must know the types
    of all variables to build a program. The compiler looks for a special variable
    declaration signature and allocates enough memory to store its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, Go initializes the memory with the zero value corresponding to
    its type. In the preceding example, we declare `n`, which has an initial value
    of `0`. We later assign a new value of `42`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 3.1 – Zero values](img/Figure_3.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 3.1 – Zero values
  prefs: []
  type: TYPE_NORMAL
- en: As its name suggests, a variable can change its value, but only as long as its
    type remains the same. If you try to assign a value with a different type or redeclare
    a variable, the compiler complains with an appropriate error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we append a line with `n = "Hello"` to the last code example, the program
    wouldn’t compile, and it would return the following error message: `cannot use
    "Hello" (type untyped string) as type int` `in assignment`.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use type inference as a shortcut for variable declarations. In that
    case, you omit an explicit type argument in your declaration. Just keep in mind
    that Go has limited support for type inference inside of a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of explicitly defining a type for each variable, you can use a special
    short assignment symbol, `:=`, and let the compiler guess the variable type based
    on its value, as in the next example, where the compiler assumes the variable
    `n` is of type `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like with variables, the compiler can also infer a constant type. The
    value of constants cannot change throughout the program and we generally use them
    to represent real-world values such as the number *π* (**Pi**), static names of
    objects or places, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s have a closer look at the different types available in Go and their
    common use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Basic types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'According to Go’s language specification, there are four groups of basic or
    primitive types predeclared globally and available to all Go programs by default:'
  prefs: []
  type: TYPE_NORMAL
- en: Numeric
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numeric
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Go defines several numeric types to store integers and real numbers of different
    sizes. Type names normally contain information about their sign and the size of
    the value (in bits). The only notable exceptions are `int` and `uint` types, whose
    values depend on the machine and normally default to 32 bits for 32-bit CPUs,
    or 64 bits for 64-bit CPU architectures:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 3.2 – Numeric type variables](img/Figure_3.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 3.2 – Numeric type variables
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of how to instantiate variables of numeric types. These
    are all valid options, and you can use whichever is most appropriate for the range
    of values you need to store or produce. You can test this code from `ch03/type-definition/main.go`
    (in the *Further reading* section). Notice we use type inference for `a`, so its
    type is `int` and its size is 8 bytes on a 64-bit machine. The second variable
    (`b`) is an unsigned 32-bit integer (4 bytes). The last variable (`c`) is a floating-point
    number (4 bytes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also convert a `v` value to the `T` type with the expression `T(v)`,
    as in the next example. Here, `b` results from converting `a`, an integer, to
    an unsigned 32-bit integer, and finally, `c` is a floating-point number from converting
    `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Once you have defined a type for a variable, any new operation has to match
    this type on both sides of the assignment operator (`=`). You could not append
    `b = int64(c)` at the end of the preceding example, as `b` would be of the `uint32`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Type conversion is always explicit in Go, unlike other programming languages
    that may do this implicitly and sometimes call this type casting.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Go supports two styles of string literals: you can enclose the characters with
    double-quotes to make it an interpreted literal, or use back-quotes for raw string
    literals, as in the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the escape sequence in `d`. Go interprets this to generate a new line
    character within the string. The following is the output of this program, which
    you can find at `ch03/string-literals/main.go` (in the *Further* *reading* section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can compare strings with the `==` and `!=` operators. You can concatenate
    strings with the `+` and `+=` operators. The example at `ch03/string-concatenate/main.go`
    (in the *Further reading* section) shows these operators in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Until this point, nothing seems to be too different from other programing languages.
    But in Go, a string is actually a slice of bytes, or to be more precise, a sequence
    of UTF-8 Unicode points. In memory, Go represents this as a two-word structure
    containing a pointer to the string data and its length.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define a new string, `n`, with the `Network Automation` string literal
    in `ch03/string-memory/main.go` (in the *Further reading* section). We can store
    each character as one or more bytes using the variable-width character encoding
    UTF-8\. For English, we use one byte per character, so the string literal in this
    case is 18 bytes long:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define another string as a subset of another. For this, we specify the
    lower bound in the original string and the upper bound. The index count starts
    at zero and the resulting string doesn’t include the character in the upper bound
    index. For `n[3:7]`, we set the boundaries at characters “`w`” and ““. The program
    prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'While the `n` and `w` variables reference strings of different lengths, the
    variable size of both is the same, just like for any other string variable. A
    string variable is a two-word structure. A word is usually 32 or 64 bits depending
    on the CPU architecture. Two 64-bit words are 16 bytes (2 x 8-byte), so for 64-bit
    platforms, a string is a 16-byte data structure. Out of those 16 bytes, 8 bytes
    are a pointer to the actual string data (a slice), and the remaining 8 bytes are
    to store the length of the string slice. *Figure 3**.1* shows what this looks
    like in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – What a string looks like in memory](img/Figure_3.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – What a string looks like in memory
  prefs: []
  type: TYPE_NORMAL
- en: It’s OK that more than one string references the same underlying slice, as this
    slice is immutable, meaning that you can’t change its contents. While the slice
    stores the string data, you can’t change a character of the string by referencing
    an index of the slice, because it’s immutable.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, if you want to change the value of a string variable, let’s say
    you need to assign a different text to it, Go points the string data structure
    to a new underlying slice with the new string content you supply. All this happens
    behind the scenes, so you don’t need to worry about this.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `bool` data type uses one byte of memory, and it stores a value of either
    `true` or `false`. As in other programming languages, you can use variables of
    the `bool` type in conditional statements to change the control flow of a program.
    The `if` conditional explicitly requires a `bool` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this program at `ch03/boolean/main.go` (in the *Further reading*
    section), you get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Because the condition is `true`, we print the `condition` variable type and
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Error
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Go has a unique approach to error handling and defines a special `error` type
    to represent a failure condition. You can generate errors, change them, print
    them on a screen, or use them to change the control flow of a program. The next
    code sample shows the two most common ways of generating a new variable of the
    `Error` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can make any user-defined type an error, as long as it implements a special
    `Error()` method that returns a `string`. We talk more about implementing methods
    in the *Interfaces* section later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'One common way of error handling is to allow it to bubble up until a point
    in a program where you can decide how to react to it — whether to fail and stop
    the execution or log and retry. Regardless of that, the use of errors is pervasive
    in Go, and all functions that can fail return an error as their last argument,
    so the following pattern is very common in Go programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `myFunction` function returns two values. In the outer function in the preceding
    example, we store the first return value of `myFunction` in a variable named `result`,
    and the second return value in the `err` variable, to store the value of any potential
    error inside `myFunction`, which now surfaces to the calling function.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the logic of the program, you need to decide how to handle the
    error. Here, if the error isn’t null (`nil`), we print the error message and finish
    the execution of the function (`return`). We could also have just logged it and
    allowed the program to continue.
  prefs: []
  type: TYPE_NORMAL
- en: Container types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next level up from the primitive types is a container type. These are still
    standard types that are available to any Go program without any explicit import
    statement. But, they represent more than just a single value. We use container
    types in Go to store different values of the same type; these include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we discuss the use cases and implementation details
    of these three types.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the first things any programmer needs, after they’ve gained the ability
    to deal with primitive types, is the ability to store collections of values of
    these types. For example, a network inventory may store a list of device hostnames
    or IP addresses. The most common solution for this problem is a data structure
    called an `array`. Go’s `array` types have the `[n]T` signature, where `n` is
    the length of the array and `T` is the value type you store in the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how you can use arrays in Go with strings. We purposely
    mix different semantic ways you can define an array, so you can choose the style
    you prefer. We first define the `hostnames` array on a single line and then the
    `ips` array on a multiline statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This gets even more interesting for network engineers when working with arrays
    of bytes. Look at the next example of how Go reads the input decimal number (`127`
    for example), and the binary data is at your fingertips. Both array examples are
    available at `ch03/arrays/main.go` (see the *Further* *reading* section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Go arrays have many benefits. They are very memory efficient, as they store
    values sequentially and don’t have any extra metadata overhead. They are also
    comparable, meaning you can check whether two arrays are equal, assuming their
    values have comparable types.
  prefs: []
  type: TYPE_NORMAL
- en: But, because of their fixed size, we rarely use arrays directly in Go. The only
    exception is when you know the size of your dataset ahead of time. With that in
    mind, in networking, we deal with a lot of fixed-sized datasets; they make up
    most of the network protocol headers, so arrays can be convenient for that and
    things such as IP and MAC addresses, port or sequence numbers, and various VPN
    labels.
  prefs: []
  type: TYPE_NORMAL
- en: Slices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Arrays have an immutable structure by definition (fixed-size). While you can
    alter the value within an array, they cannot grow and shrink as the size of the
    stored data changes. But, implementation-wise, this has never been a problem.
    Many languages implement arrays as dynamic data structures that change their size
    behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there is some performance penalty involved when growing an array,
    but with some clever algorithms, it’s possible to reduce the number of changes
    and make the end user experience as frictionless as possible. Slices play this
    role in Go; they are the most widely used array-like data structure in Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Providing the length of the slice when creating it is optional. Behind the
    scenes, Go creates a backing array that defines the upper bound to what size the
    slice can grow to. That upper bound is what we know as the **capacity** of the
    slice. In general, the capacity is equal to the length of the slice, but that
    is not always the case. If the slice needs to grow beyond its capacity, Go creates
    a new larger backing array and copies over the contents of the original array.
    The next example shows three ways to create a slice and the values for capacity
    and length for each slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This program, which you can find at `ch03/slices/main.go` (see the *Further
    reading* section), prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like with strings, you can slice a slice, which creates a new reference
    to a section of the same backing array. For example, if you create a new slice
    based on the slice words from the preceding example with `words[1:3]`, you end
    up with a slice that has `one` and `two` elements, so the length of this slice
    is two. Its capacity is six, though. Why six? The backing array is the same, but
    the new slice starts at index one, and the last index of the backing array is
    seven. *Figure 3**.2* shows what this looks like in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – What slices look like in memory](img/Figure_3.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – What slices look like in memory
  prefs: []
  type: TYPE_NORMAL
- en: 'To add elements to the end of slice, you can use the built-in `append` function.
    Let’s start from the slice we were just referencing and call it `mySlice`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this program from `ch03/slices/main.go` (see the *Further reading*
    section), we can see how Go allocates a new backing array when it needs extra
    capacity. When it had three elements already, and we asked to add another four
    to a slice with a capacity of six, Go automatically allocated a new backing array
    with a capacity of 12 to support the extra elements and future growth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The bottom line is that while this might sound hard to grasp, it all happens
    behind the scenes. What we want to leave you with about slices is that they are
    a three-word data structure, and are 24 bytes on most computers nowadays.
  prefs: []
  type: TYPE_NORMAL
- en: Maps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Maps are a container type that makes it possible to store a mapping between
    one type, for example, a string or an integer, as the key to another type stored
    as the value. A map is of the `map[KeyType]ValueType` form, where `KeyType` is
    any type that is comparable and `ValueType` may be any type at all. One example
    would be `map[int]string`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to initialize a map is with the built-in `make` function as in the
    next example, where we create a map of `string` as key and also with `string`
    as value. You can add new values to the map, referencing the key you want to associate
    that value with. In the example, we map `spine` to `192.168.100.1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: To retrieve a value and assign it to a variable, you can reference the key just
    like when adding values, but this time, on the right side of the equals sign,
    as in the preceding example, where we assigned the value of `dc["spine"]` to the
    `ip` variable.
  prefs: []
  type: TYPE_NORMAL
- en: You can also do membership testing, to check whether a certain key is on the
    map. A two-value assignment tests for the existence of a key, as in `ip, exists
    := dc["spine"]`, where `exists` is a Boolean value that is only `true` if `dc["spine"]`
    exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to initialize a map is with data, as in the next example. To delete
    elements, you can use the built-in `delete` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This program prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The full code for this section is available at `ch03/maps/main.go` (see the
    *Further* *reading* section).
  prefs: []
  type: TYPE_NORMAL
- en: User-defined types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike the types we discussed before, user-defined types, as the name suggests,
    are types that you define. In this category we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Structs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces are the only abstract type in Go and define a contract for concrete
    types, such as structs. They describe behavior, not implementation details, which
    helps us break the business logic of our programs into building blocks with interfaces
    between them. We cover them in detail in a dedicated section for interfaces later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Structs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A struct is a data structure that represents a collection of fields with their
    data types. Structs look a bit like mappings, except the keys in this case are
    fixed. They become an extension of the variable name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define a router (`Router`) that has four `string` fields and one `bool`
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this new type can also be part of another user-defined type, as in the
    following `Inventory` type, which has a slice of these routers we just defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are a few examples of how to create an instance of a struct and assign
    values to its fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The caveat is that `r2` is now actually a pointer to `Router` (that’s how `new`
    works), but it’s not something we need to worry about right now. Let’s put all
    the routers in an `Inventory` type variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have all our routers conveniently in a variable we can use. All the
    fields we haven’t assigned a value yet are zero value (`""`, or empty for strings):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The code in this example is available at `ch03/structs/main.go` (see the *Further*
    *reading* section).
  prefs: []
  type: TYPE_NORMAL
- en: Until this point, we have not talked about other variable types such as pointers,
    channels, and functions. We cover these in other sections of this chapter. Please
    bear with us. In the next section, we introduce some math and logical operators
    that allow us to execute different actions in our programs.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic, comparison, and logical operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Operators are special symbols that perform specific mathematical, logical,
    or relational computations on variables of different types. We cover the following
    three types of operators in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparison operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While we don’t cover all corner cases and permutations of types, we’d like to
    focus on a few operators that might be interesting in the network automation context.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These operators perform mathematical calculations with numeric values. The
    resulting value depends on the order and type of the operands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 3.3 – Arithmetic operators ](img/Figure_3.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 3.3 – Arithmetic operators
  prefs: []
  type: TYPE_NORMAL
- en: 'They follow the standard mathematical logic implemented in most programming
    languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Strings are the only non-numeric type that can make use of an arithmetic operator.
    You can use `+` for string concatenation, to link together two or more text strings
    into one string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: One of the most interesting applications of arithmetic operations is interacting
    with binary data, something that many network engineers are familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: Network protocols have deterministic structures expressed in a set of headers
    that contain forwarding information and facts of the encapsulated payload.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the arithmetic operators bit shift and bitwise (`OR`, `AND`, and
    `XOR`) to create or extract data from network headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, let’s work with a 20-byte long **Transmission Control
    Protocol** (**TCP**) header that has the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: Source port address – 2 bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destination port address – 2 bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequence number – 4 bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acknowledgment number – 4 bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Header length and reserved – 1 byte
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Control flags – 1 byte:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CWR`: **Congestion Window** **Reduced** flag'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ECE`: **Explicit Congestion Notification** (**ECN**)-echo flag'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`URG`: Urgent pointer'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ACK`: Acknowledgment number is valid'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PSH`: Request for push'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RST`: Reset the connection'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SYN`: Synchronize sequence numbers'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FIN`: Terminate the connection'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Window size – 2 bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checksum – 2 bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Urgent pointer – 2 bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 3**.3* shows the TCP header structure including all the mandatory fields
    we just listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – TCP header structure](img/Figure_3.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – TCP header structure
  prefs: []
  type: TYPE_NORMAL
- en: In the next code example, we build a TCP header from an empty slice of bytes.
    We write its length in the first four bits of byte 13 and then set the `SYN` flag
    in byte 14 of the TCP header.
  prefs: []
  type: TYPE_NORMAL
- en: The header length field of the TCP header represents the number of 32-bit words
    the TCP header has. You can see it as the number of rows in it, as *Figure 3**.3*
    shows. Here, the length is five words.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet (the full version is at `ch03/tcp-header/main.go`
    (see the *Further reading* section)) shows how to set this length on a TCP header
    using arithmetic operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 3**.4* shows how the `headerWords` 8-bit unsigned integer variable,
    which is compatible with the size of a single byte, got bit-shifted left to fit
    into its appropriate positions in the header’s field.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The left shift operation moves the original bits, dropping the overflowing
    bits on the right and replacing the bits on the left with zeros. The bitwise `OR`
    operator combines the resulting value with the existing byte. This is a common
    pattern to make sure that none of the bits you configured before get lost since
    the bitwise `OR` operator always keeps the `1` bits if they are present in any
    of the operands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Building a TCP header, part one](img/Figure_3.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Building a TCP header, part one
  prefs: []
  type: TYPE_NORMAL
- en: 'To set a flag, we can do something similar, where we set one bit and shift
    it to the left to leave it in the second position to signal `SYN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 3**.5* depicts the bit operations in the preceding code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Building a TCP header, part two](img/Figure_3.5_NEW.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Building a TCP header, part two
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s see how the reverse process of parsing those two bytes on the receiving
    side can look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we’re using the opposite set of bit operations. The right shift
    moves all bits from left to right, dropping the bits on the right and adding zeros
    to the left:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Parsing a TCP header, part one](img/Figure_3.61.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Parsing a TCP header, part one
  prefs: []
  type: TYPE_NORMAL
- en: 'The bitwise `AND` operator has the same behavior as a network mask. It keeps
    the bits that are set to `1` and resets everything else to zero, effectively hiding
    the non-important bits. In our case, we’re using the `0x02` mask value or `0000
    0010` in binary, which hides everything else and only leaves us with the second
    bit from the right. We can then shift that bit to the right and check its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Parsing a TCP header, part two](img/Figure_3.71.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Parsing a TCP header, part two
  prefs: []
  type: TYPE_NORMAL
- en: Being able to work at the bit and byte level is a powerful programming capability.
  prefs: []
  type: TYPE_NORMAL
- en: Logical operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Logical operators are a basic set of Boolean operations that follow the rules
    of Boolean algebra — conjunction, disjunction, and negation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 3.4 – Logical operators ](img/Figure_3.11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 3.4 – Logical operators
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing surprising in Go’s implementation of these logical operators,
    the only thing worth remembering is that there is no syntactic sugar for them,
    so the only acceptable values are `&&` for `AND` , `||` for `OR`, and `!` for
    `NOT`.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the equal and not equal (`==` and `!=` ) operators to compare a pair
    of comparable values and return a Boolean (`true`|`false`). You can apply greater
    than and less than operators (`<`, `<=`, `>`, and `>=`) to ordered values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 3.5 – Comparison operators ](img/Figure_3.12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 3.5 – Comparison operators
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a brief example of comparison operators in action, with their most common
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, all statements evaluate and print `true`. You can
    find the complete list of comparable and ordered properties of other Go types,
    such as pointers, channels, and arrays, in the *Comparison operators* section
    of the Go language specification (see *Further reading*).
  prefs: []
  type: TYPE_NORMAL
- en: This concludes this introduction to the Go data types and different operators
    used to perform day-to-day operations. Now, it’s time to put together the first
    building blocks of our programs as we dive into Go’s control flow and functions.
  prefs: []
  type: TYPE_NORMAL
- en: Control flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Control flow constructs are a key building block of any computer program, as
    they allow you to express complex behaviors with conditions and iteration. Go’s
    support for control flow reflects its minimalistic design, which is why you’d
    mostly see a couple of variations of conditional statements and one version of
    loop in the entire language specification. It may seem surprising, but this makes
    Go easier to read, as it forces the same design patterns on all programs. Let’s
    start with the simplest and the most common control flow blocks.
  prefs: []
  type: TYPE_NORMAL
- en: for loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In its simplest form, the `for` loop allows you to iterate over a range of
    integers while doing some work in each iteration. For example, this is how you
    would print all numbers from `0` to `4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The first line has the `init` statement, `i := 0`, the condition statement,
    `i < 5`, and the `post` (each iteration) statement, `i++`, separated by semicolons
    (`;`). The code continues to evaluate the condition statement and the post statement
    of the `for` loop until the condition is no longer `true`, that is, until `i >=`
    `5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This loop type (`for`) has many variations and one of the most common ones
    is the iteration over a container type. Here are two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of iterating over a slice:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is an example of iterating over a map:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The special `range` keyword loops through all values of a slice or a map, creating
    a copy of the current item on a new pair of key/value variables for each iteration
    (`i` and `v` in the examples). You can also use `range` to iterate over arrays
    and strings. This keyword has special behavior for channels, which we cover later
    in the *Concurrency* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common variation of this loop construct is the infinite loop. You can
    use this when you don’t know the number of iterations ahead of time, but you know
    when to stop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The key distinction here is the absence of any conditions in the loop definition,
    which is a shorthand for `true`; that is, the condition statement always evaluates
    to `true` and the loop iterates infinitely. The only way to stop this kind of
    loop is to use the `break` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go doesn’t have a `while` keyword for loops, which you can find in many other
    programming languages. But, you can make Go’s `for` loop act in the same way as
    `while`, by dropping the `init` and `post` statements as the next code example
    shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Another special keyword worth mentioning in this context is `continue`, which
    skips the remainder of the current iteration of a loop. The following example
    prints all numbers from `0` to `4`, but only if they are even:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we skip numbers that have a non-zero remainder when divided
    by two with the `if i % 2 != 0` clause. This is a conditional statement, which
    is the topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Control structures help you define the behavior or direction to follow when
    a program can follow different execution paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with a two-way conditional statement. We try to connect to a website
    ([https://www.tkng.io/](https://www.tkng.io/)) and then print the response we
    receive if the connection is successful, or we return the error message if the
    `HTTP GET` operation fails. If the error is not null (`err != nil`), we return.
    Otherwise (`else`), we print the information (`fmt.Printf`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'One way to improve the readability of the preceding example is to left-align
    the successful execution path of the program, meaning that if one of the branches
    of the `if` condition ends in a terminating statement, as in our case with `return`,
    you can drop the entire `else` clause and rewrite the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Like any typical `if`-`then`-`else` construct, Go’s conditional statements can
    encode multi-way conditions with many `if`-`else` statements. But, Go developers
    usually prefer to use a `switch` statement in this scenario, because it’s a more
    concise and readable form of the multi-stage `if`-`then`-`else`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example, which sends an `HTTP GET` request and prints
    a message based on the returned status code. The full code is at `ch03/switch/main.go`
    (see *Further reading*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: You can write this example as a chain of `if`-`then`-`else` statements as well,
    but using `switch` makes your code cleaner, and many Go developers consider it
    good practice for these situations.
  prefs: []
  type: TYPE_NORMAL
- en: goto statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way you can transfer the control from one part of a program to another
    is by using a `goto` statement.
  prefs: []
  type: TYPE_NORMAL
- en: You can use `goto` statements to break out of a nested or infinite loop or to
    implement logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building upon the preceding code example, let’s see how we can use `goto` statements
    to implement various exit points from a function. You can find the full code of
    the example at `ch03/goto/main.go` (see *Further reading*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `goto` statements have a somewhat evil reputation in most programming languages
    because of their power to break the flow of a program, often making it harder
    to read, with many prominent computer scientists warning against their inconsiderate
    use. Still, these statements do have their place and you can find them in many
    projects and even in the Go standard library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loops, conditional statements, and things like `goto` help you define the control
    flow of your Go programs. We still haven’t covered some extra control flow constructs
    and corner cases used together with channel types. We cover them later in the
    *Concurrency* section of this chapter, but before we get there, we first need
    to talk about another important area of code organization: functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the surface, a Go function is exactly the same as in any other programming
    language: a section of code designed to perform a certain task grouped into a
    reusable container. Thanks to the static nature of the language, all functions
    have a signature that defines the number and types of acceptable input arguments
    and output values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following function (`generateName`), which generates a new name
    based on a pair of input strings (`base` and `suffix`). You can find the full
    code of the next example at `ch03/functions1/main.go` (see *Further reading*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This function’s signature is `func (string, string) string`, meaning that it
    accepts two arguments of the `string` type and returns another string. You can
    assign the returned value to a variable or pass it as an argument directly to
    another function.
  prefs: []
  type: TYPE_NORMAL
- en: Go’s functions are values, which means you can pass them as an input argument
    and even return them as the output from another function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, we define a new function named `processDevice`, which takes
    two parameters, a function with a `func (string, string) string` signature, and
    a `string`. In the body of this function, two relevant strings are in play: `base`,
    which is statically set to `device`, and `ip`, which is the string the function
    receives as the second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The most interesting part of this function is on the second line of its body,
    where it calls the `getName` function. This function is what `processDevice` received
    as an argument, which could be any function as long as it takes two strings as
    arguments and returns just one string. That’s the case with the `generateName`
    function we defined for an earlier example, which means we can pass `generateName`
    as an argument to `processDevice` to build a unique device name. Let’s see what
    this would look like. The code of this example is available at `ch03/functions1/main.go`
    (see *Further reading*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The benefit of this approach is the pluggable nature of the first argument.
    If we decide at any point that another function (for example, `generateName2`)
    is a better fit because it uses a different format to join the strings or something
    else, or maybe you want to make a change to create the device names differently
    but don’t want to alter the `generateName` function in case you need to roll back
    your changes quickly, then you can use a temporary `clone` function with a different
    name where you make the adjustments.
  prefs: []
  type: TYPE_NORMAL
- en: Function arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Go, we pass the function arguments by value, meaning that Go creates a copy
    of every input variable and passes that copy to the called function. Go saves
    the new function-scoped variables in the stack memory, as long as the compiler
    knows their lifetime and memory footprint at compile time. The stack is a very
    efficient region in memory designed to store variables that don’t need to be garbage
    collected, as it allocates or de-allocates memory automatically when the function
    returns. Memory that needs to be garbage collected goes to another location in
    memory known as the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example of a function attempting to mutate an input
    string. You can access the code for the next example at `ch03/functions2/main.go`
    (see *Further reading*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Since Go creates a copy of the input `Device` when passing it as a value to
    the `mutate` function, any changes that happen to that `Device` inside the body
    of this function are not visible outside of it, hence it doesn’t affect the original
    variable, `d`. That is why `d.name` prints `myname` and not `myname-suffix`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Go, we have two types of data we can work with: values and the memory addresses
    of those values (pointers). With this in mind, there are two ways to implement
    the desired (mutating) behavior when passing values to a function:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the function to return the mutated value and assign it to a variable.
    Still, this does not really mutate the original value but actually generates a
    new one instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Change the function to accept a pointer to a variable that stores a `Device`.
    This is what our program would look like in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Pointers are a common way of sharing data across program boundaries in Go,
    such as function calls. In this case, we still pass the input argument by value
    (`&d`), but this time, the value we copy and pass is a pointer to a memory address,
    instead of the actual content of the `d` variable. Now, when you change what that
    memory address is pointing to, you are mutating the value of the original `d`
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Values and pointers](img/Figure_3.8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Values and pointers
  prefs: []
  type: TYPE_NORMAL
- en: 'Go pointers are a powerful idea. The key operations you need to be aware of
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Taking an address of a variable using the `&` operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dereferencing a pointer, that is, getting the address of the referenced value
    using the `*` operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever you need to change the value of a variable, or when a variable is big
    enough to make copying it inefficient, you need to make sure that you pass it
    by a pointer. This rule applies to all the primitive types — `integer`, `string`,
    `boolean`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: A couple of types in Go do not hold the actual value but point to its memory
    address instead. While these are internal implementation details, it’s something
    worth keeping in mind. For example, channels and maps are two types that are actually
    pointers to internal data structures (runtime types). This means that even if
    you pass them around by value, you end up mutating the contents of the channel
    or map. The same, by the way, applies to functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following example where we pass a map (`m`) by value to a function
    (`fn`). This function adds a new key-value pair to the map, a value that the outer
    function (`main`) can access as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In the *Go’s type system* section in this chapter, we learned that a slice is
    a type in Go that stores metadata about the underlying data along with a pointer
    to it. It may be tempting to assume that you can pass around this data type as
    a value and be able to mutate it. But, while this data structure has a pointer
    in it, you also create a copy of the rest of the metadata values (length and capacity),
    creating a disconnection between the slice in the called and calling functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, mutations in slices may have an unpredictable result. In-place
    changes may be visible but appends may not. This is why they always recommend
    passing them as pointers to avoid subtle bugs such as the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'You can avoid this bug if you use a pointer instead, in which case, all changes
    to the underlying slice are reflected in the outer context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The full code for both of these examples is at `ch03/mutate-slice/main.go` (see
    *Further reading*).
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Go, errors are not exceptions that you have to handle somewhere else in the
    code. We handle them as they come along. An error might require you to immediately
    stop the execution of a program, or maybe you could continue to run the program
    and propagate the error to another part of the program or the user so they can
    make an informed decision about what to do with this error. Remember, *don’t just
    check errors, handle* *them gracefully*.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to writing functions, the rule of thumb is that if a function
    is likely to run into an error, it must return it to the caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The error message should be meaningful and offer enough context to the user
    to be able to identify the cause of the error and the place in the code where
    it happened. It’s up to the caller of this function to decide what to do with
    this error from the following possible actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Log it and continue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignore it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interrupt execution and panic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass it up to the outer function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Methods are a way of adding behavior to user-defined types, which, by default,
    can only store values. If you want those types to act, you can add a special function
    that would contain the name of the associated data type (method receiver) between
    the `func` keyword and the function name, such as `GetFullName` in the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: In all aspects, methods are just like functions — they accept zero or more arguments
    and return zero or more values. The biggest difference is that methods also have
    access to their receiver and can at the very least read its fields, as you’ve
    seen in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also possible to create a method that mutates the receiving type by defining
    it on a pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we define the `GenerateName` method on a pointer receiver and,
    thus, can safely set, delete or change its values — all these changes are visible
    in the outer scope.
  prefs: []
  type: TYPE_NORMAL
- en: The full code for the method code examples is available at `ch03/methods/main.go`
    (see *Further reading*).
  prefs: []
  type: TYPE_NORMAL
- en: Variadic functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we’ve only seen examples with functions that take a strictly pre-defined
    number of arguments. But, that’s not the only option in Go; you can actually pass
    an arbitrary number of arguments to a function as long as you meet the following
    conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: All extra arguments are of the same type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are always the last arguments to a function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The function signature looks slightly different. All extra arguments are automatically
    grouped into a slice and you denote them with three dots (`...`) before their
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: One benefit of variadic arguments, compared to declaring them as a slice argument
    instead, is the flexibility; you don’t have to create a slice before calling a
    function, and you can completely omit any trailing arguments if they are not needed
    and still satisfy the function’s signature.
  prefs: []
  type: TYPE_NORMAL
- en: The full code for the variadic code example is available at `ch03/variadic/main.go`
    (see *Further reading*).
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions in Go have different properties. They are values, so a function can
    accept another one as its argument.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting property is that when one function (outer) returns another
    function (inner), the inner function remembers and it has complete access to all
    variables that you defined in the scope of the outer function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what’s called a `func() string` signature mutates the `i` variable
    defined in the `suffixGenerator` outer function every time it’s called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Every time we call `suffixGenerator`, we assign a new instance of the anonymous
    function it returns to a variable. `generator1` and `generator2` are now functions
    that keep track of the number of times we call each one.
  prefs: []
  type: TYPE_NORMAL
- en: Closures are a popular technique to create a surrounding context (environment).
    For example, API call functions in middleware software use closures to perform
    logging and telemetry data collection on every call, without the API caller needing
    to care about those details.
  prefs: []
  type: TYPE_NORMAL
- en: Defer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When writing a program that opens remote network connections or local files,
    it’s important to promptly close these as soon as you no longer need them to prevent
    resource leaks — all operating systems have limitations on the number of open
    files or connections.
  prefs: []
  type: TYPE_NORMAL
- en: Go’s idiomatic way of dealing with this class of problems is to address them
    as early in the code as possible with the help of the `defer` statement. You should
    place this statement right next to the `open`/`connect` function call. Go only
    evaluates this statement when the function returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the two `defer` statements run only *after* the final
    statement of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'You can stack together many `defer` statements to perform staged cleanup. They
    execute in last-in-first-out order – `Println("Deferred cleanup")` runs before
    `resp.Body.Close()`. This is what you see when you run this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The full code for this code example is available at `ch03/defer/main.go` (see
    *Further reading*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve covered the Go functions fundamentals, it’s time to move onto
    the next level of abstraction that describes object behaviors through a unique
    set of methods: interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interfaces are one of the most powerful constructs in Go, so it’s very important
    to understand what they do and when you can use them. From a purely theoretical
    point of view, interfaces are an abstract type. They do not contain implementation
    details but define a set of behaviors through method signatures.
  prefs: []
  type: TYPE_NORMAL
- en: If a Go type defines all method signatures declared by an interface, this Go
    type *implements* that interface implicitly, with no explicit declaration. This
    is how Go deals with common behaviors exhibited by more than one type, and what
    other languages often express through object inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Network automation example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To introduce the idea, we use a contrived network automation example. Let’s
    say we are developing a Go package to deal with common tasks across different
    network devices. We model a Cisco IOS XE device as a `CiscoIOS` type with two
    fields — one that identifies the hostname of a device (`Hostname`) and another
    that identifies the underlying hardware platform (`Platform`). For this `CiscoIOS`
    type, we define a method that gets us the uptime of a device (`getUptime`) as
    an integer. Finally, we define a function to compare two devices and find out
    which one has been running longer without a reboot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything works fine until we add another platform to the mix. Let’s say we
    now also have a `CiscoNXOS` type and it has `Hostname` and `Platform` fields,
    but it also has a Boolean `ACI` field to show whether this switch is ACI-enabled.
    As with the `CiscoIOS` type, we define a method that returns the uptime of a `CiscoNXOS`
    device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The challenge now is to compare the uptime of a `CiscoNXOS` device type with
    the uptime of a `CiscoIOS` device type. The `LastToReboot` function signature
    tells us it only accepts variables of a `CiscoIOS` type as an argument, so we
    cannot pass an element of a `CiscoNXOS` type to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can fix this by creating an interface. By doing this, you abstract away
    the implementation details of the device and only focus on the need to present
    the device uptime as an integer via the `getUptime` function. Let’s call this
    interface `NetworkDevice`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to change the `LastToReboot` function to accept a `NetworkDevice`
    type instead of `CiscoIOS`, as in the next code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Because both `CiscoIOS` and `CiscoNXOS` have a `getUptime() int` method, they
    implicitly satisfy the `NetworkDevice` interface, hence you can pass either one
    of them as a parameter to the `LastToReboot` function. A **sample program** (see
    *Further reading*) that uses these definitions to compare the uptime of these
    two device types would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Interfaces can help you scale your programs. The interface `NetworkDevice` enables
    us to add any number of device types. It’s not only a great resource for good
    code design but also to set clear expectations of what the data should do in an
    API, regardless of what the data is. In the example, we don’t care what operating
    system the device is running, only that we have a method available to get its
    uptime as an integer.
  prefs: []
  type: TYPE_NORMAL
- en: Standard library example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For a more real-world example, let’s turn our attention to the `net` package
    in the standard library, which has an interface that represents a network connection
    (`Conn`). Interface fields are often verbs that describe behavior and not state
    (for example, `SetDeadline` for the `Conn` interface). By contrast, a more descriptive
    name for the `RemoteAddr` method might have been `getRemoteAddr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The standard library includes several implementations of this interface. One
    of them is in the `crypto/ssh` library, through the `chanConn` concrete type.
    A concrete type is any non-interface type that stores its own data and, in this
    case, `chanConn` stores values for local (`laddr`) and remote (`raddr`) addresses
    of a **Secure Shell Protocol** (**SSH**) connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'This type also defines methods, such as `LocalAddr() net.Addr` and `SetReadDeadline(deadline
    time.Time) error`. In fact, it has all methods of the `net.Conn` interface, hence
    it satisfies the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, any function that accepts `net.Conn` as input can take `chanConn` as well.
    Or vice versa, if a function returns `net.Conn`, it can also return `chanConn`,
    as in the next example from the same source code file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Don’t worry if these code snippets look daunting to you. These come from the
    actual SSH package of the Go standard library, so this is as complex as it gets.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces as contracts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Interfaces are a valueless type; they only define method signatures. You can
    define a variable of an interface type, but you can only assign a concrete implementation
    of this interface as the value of this variable.
  prefs: []
  type: TYPE_NORMAL
- en: In the next code example, the `r` variable is of the `io.Reader` type, which
    is an interface. At that point, we know nothing about this variable but we do
    know that whatever value we assign to this variable must satisfy the `io.Reader`
    interface in order for the compiler to accept it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we’re using `strings.NewReader("text")`, which implements the
    `io.Reader` interface to read from a `string` value that gets passed as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The last line of code copies what we read to standard output (`Stdout`) or the
    user’s screen. The `io.Copy` function copies from `io.Reader` (`r`) to `io.Writer`
    (`os.Stdout` satisfies this interface), so we can copy from the string to the
    terminal.
  prefs: []
  type: TYPE_NORMAL
- en: While this looks a bit more complicated than just printing the string with `fmt.Println`,
    interfaces make our code more versatile, allowing you to replace either the source
    or destination of the data in the example without too much effort. This is possible
    because the `io.Reader` and `io.Writer` interfaces serve as a contract between
    both the `io.Copy()` consumer and the `strings.NewReader` and `os.Stdout` providers,
    ensuring they both conform to the rules defined by this interface.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces allow you to define a clear division between different modules of
    a program and offer an API where users can define the implementation details.
    In the next section, we examine in detail the `io.Reader` and `io.Writer` interfaces
    and their role in **input/output** (**I/O**) operations.
  prefs: []
  type: TYPE_NORMAL
- en: Input and output operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common operation in a program is to move data around and reformat it. For
    example, you can open a file, load its content in memory, encode it to a different
    format, maybe `jpeg`, and then write it to a file on the disk. This is where the
    `io.Reader` and `io.Writer` interfaces play a key role in Go’s I/O model, as they
    allow you to stream data from a source to a destination via a transfer buffer.
    This means you don’t need to load the entire file in memory to encode it and write
    it to the destination, making the process more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: The io.Reader interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `io` package in the standard library defines one of the most popular interfaces
    in Go, the `io.Reader` interface, which can read a stream of bytes (`p`). It returns
    the number of bytes read (`n`) and any error encountered (`err`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Any concrete type that has a `Read` with this signature implements the `io.Reader`
    interface. You don’t need to do anything else:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – The io.Reader interface](img/Figure_3.9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – The io.Reader interface
  prefs: []
  type: TYPE_NORMAL
- en: 'The `strings.Reader` type (in the `strings` package of the standard library)
    has a method with the `Read(p []byte) (n int, err error)` signature, hence it
    satisfies the `io.Reader` interface. The `strings` package also provides a convenient
    `NewReader` function that returns a pointer to a new instance of the `strings.Reader`
    type. The following is an actual snippet from the `strings` package source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code also shows a concrete `Reader` implementation (with data
    fields) that has a `Read` method.
  prefs: []
  type: TYPE_NORMAL
- en: The io.Writer interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `io` package also specifies the `io.Reader` interface, which can write
    `len(p)` bytes to the underlying data stream. It returns the number of bytes written
    (`n`) and any error encountered that caused the write to stop early (`err`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Any concrete type that has a `Write` method with this signature implements
    the `io.Writer` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – The io.Writer interface](img/Figure_3.10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – The io.Writer interface
  prefs: []
  type: TYPE_NORMAL
- en: 'One example is `os.File` in the `os` package of the standard library. It has
    a method with the `Write(p []byte) (n int, err error)` signature, hence it satisfies
    the `io.Writer` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The `os` package also offers a convenient `Create` function that returns a pointer
    to an `os.File` from a file location. The preceding is an actual snippet from
    the `os` package source code.
  prefs: []
  type: TYPE_NORMAL
- en: The io.Copy function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `io.Copy` function allows you to copy data from a source to a destination,
    as we discussed at the end of the *Interfaces* section. Even though you pass concrete
    type data to this function, `io.Copy` actually doesn’t care what the data is,
    as it takes interface types as an argument, so it’s interested in what the data
    can do instead. It needs a readable source and a writable destination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'As *Figure 3**.11* shows, `io.Copy` uses a 32 KB transfer buffer to stream
    the data from the source to the destination:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – The io.Copy function](img/Figure_3.111.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – The io.Copy function
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test this. We can get an `io.Reader` from a string built with `strings.NewReader`,
    and `os.Create` gives us an `io.Writer`, which writes to a file on the disk. You
    can follow along with the code at `ch03/io-interface1/main.go` (see *Further reading*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'While, in this case, we select a string and a file combination, you can use
    the same `io.Copy` function to read from the network and print to the terminal,
    for example. For now, let’s inspect the file we just produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s examine a network-related example. The `net/http` package has the `Get`
    function that takes a URL (`string`) and returns a pointer to a `http.Response`,
    which has a field (`Body`) that satisfies the `io.Reader` interface, and the `os.Stdout`
    terminal satisfies the `io.Writer` interface. This gives us another combination
    to try out. Let’s see it in action. The code is very close to what we ran before,
    and is available at `ch03/io-interface2/main.go` (see *Further reading*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The same `io.Copy` function now allows us to take the content from a URL and
    print it to the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: With `io.Copy`, we move data from one point to another. Now, we need to add
    another piece to the puzzle to transform the data as we stream it.
  prefs: []
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way to transform the data as we stream it is by embedding one struct type
    into another, which we know as `io.Reader` or `io.Writer` interfaces to perform
    one or more operations and not just copy the data from source to destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefit of following this pattern is to write reusable segments of code,
    which you can use for any `io.Reader` or `io.Writer` interface in this case. Let’s
    look at the example at `ch03/reader/main.go` (see *Further reading*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: We define a new `myReader` type with a single `src` field of the `io.Reader`
    type. In Go, when we embed a type, the methods of that type become methods of
    the outer type, so `myReader` has a `Read` method from `src` now.
  prefs: []
  type: TYPE_NORMAL
- en: But, we want to change the behavior and do something with the data. Hence, we
    define a new `Read` method that takes precedence over any other more deeply nested
    method part of the type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this `Read` method, we read from the buffer and convert it to title case
    with `bytes.Title`, assuming we are working with strings. Last but not least,
    `NewMyReader` is what glues together an existing reader with this new one, connecting
    the dots between two pieces of code. Let’s see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a reader from a string in `r1` and then use that as the input for
    `myReader` in `r2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: When we now copy from `r2` to `os.Stdout`, we read from the string and also
    change the content to title case before writing it to the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Input and output primitives are present in almost every Go library. The next
    section is no exception. Encoding and decoding in Go take full advantage of the
    `io.Reader` and `io.Writer` interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding and encoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common network automation tasks is the ingesting and processing
    of structured data. You can retrieve data from or send it to a remote location
    or even store it on a local disk. Regardless of its location, you have to convert
    this data into an appropriate format. Encoding, or marshaling, is the process
    of transforming bytes from a Go data structure into a structured textual representation.
    Decoding, or unmarshalling, is the reverse process of populating Go values with
    externally sourced data.
  prefs: []
  type: TYPE_NORMAL
- en: Some examples of structured data encoding schemes are YAML, JSON, XML, and Protocol
    Buffers. Go’s standard library includes packages that implement encoding and decoding
    for most of these popular formats, and they all leverage the `io.Reader` and `io.Writer`
    interface primitives that we learned about in the last section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we go through how Go deals with the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Using tags to annotate Go structs to help libraries encode and decode structured
    data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing of structured data using the empty interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing deeply nested set and lookup operations using third-party libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start our overview with decoding, as this is usually one of the first steps
    in a network automation pipeline. Let’s assume that we’re building a program that
    needs to interact with various remote network devices. We store the information
    of these devices in an inventory file we save on a local disk.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding JSON
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the first example, we see how to deal with a JSON inventory (`input.json`).
    All outputs of this part are available in the `ch03/json` folder of the book’s
    repository (see *Further reading*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first code example in `ch03/json/main.go` (see *Further reading*), we
    define a couple of Go structs that can hold the JSON input data from the preceding
    output in memory. We call the first type `Router`, which has `Hostname`, `IP`,
    and `ASN` fields. The other type is `Inventory`, which stores a list of routers.
    The fields in the `Router` type have optional tags such as `json:"key"` to denote
    alternative key names in the original JSON structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'To read from a file, we create an `io.Reader` type (`file`) from the input
    file with `os.Open`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `json` library, as well as any other encoding library, has a function
    that allows you to pass an `io.Reader` type as an argument to extract data from
    it. This means it can decode from a file, a string, a network connection, or anything
    else that implements the `io.Reader` interface with the same function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you’ve created a decoder, you can use the `Decode` method to read and
    parse the contents of the JSON file into a variable (`inv`) of the `Inventory`
    type. Remember, to mutate the data struct, you need to pass it as a pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'If you print the `inv` variable now, you would see it populate with data from
    the inventory JSON file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Decoding into an empty interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The field tags we’ve just seen are a very convenient way to map data during
    encoding and decoding. The condition to have all Go types predefined ahead of
    time offers type safety, but at the same time, you can see it as a major detractor
    if you are coming from another language where the decoding process does not need
    this.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, you can also skip this in Go, with a few caveats that we discuss later.
    To show you how it works, we use a slightly different version of an earlier example.
    This new version is available in the `ch03/json-interface` folder (see *Further
    reading*). Instead of defining all Go structs, we use a special variable of the
    `map[string]interface{}` type and pass it as an argument to the `Decode` method
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: An *empty interface*, or `interface{}`, doesn’t define any methods, which means
    it can hold any value — `integer`, `string`, `float`, or user-defined. The only
    caveat is that, since Go is a statically typed language, those values remain an
    empty interface until we do an explicit type conversion, that is, until we tell
    Go what type we expect to see.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the output of the empty variable of the `map[string]interface{}` type,
    where we decoded the JSON content in the preceding example, we see that the value
    of the map we print is an array. To parse these values and print them individually,
    we’d have to tell Go to treat them as a slice of unknown values, which you can
    express as `[]interface{}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of these print statements is the string representation of two `map[string]interface{}`
    maps, which means we’ve only parsed the keys (as strings), but the values are
    still undefined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: We could continue this process until we find the right type for all values of
    this object, but this process is obviously quite tedious. This is why we mainly
    see this approach in encoding libraries or as a troubleshooting step to take a
    quick glance at the structure of the potentially unknown input data.
  prefs: []
  type: TYPE_NORMAL
- en: Another option for quick operations with JSON data is external Go packages,
    which you can use to perform deep JSON lookup (**GJSON**) and set (**SJSON**)
    operations without having to build structs for the entire object. In both cases,
    the parsing still happens behind the scenes, but the user is only presented with
    their data or an error if the key doesn’t exist. We use GJSON (see *Further reading*)
    in a gRPC example in [*Chapter 8*](B16971_08.xhtml#_idTextAnchor182), *Network
    APIs*.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding XML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While the XML input file looks different, the data is the same and the Go program
    doesn’t change much. The next example is in the `ch03/xml` folder of the book’s
    repository (see *Further reading*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compared the final program with the one we did for JSON, we would notice
    four changes:'
  prefs: []
  type: TYPE_NORMAL
- en: We import `encoding/xml` instead of `encoding/json`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use XML tags `xml:"hostname"` instead of the JSON equivalents for struct
    fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The input file is a `.``xml` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the `NewDecoder` function from the `xml` library instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The rest of the code remains exactly the same. The next code output highlights
    the actual lines that change; we omitted the rest of the lines as they are the
    same as in the JSON example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Just like JSON, XML has its own external libraries that can help you deal with
    complex input data without having to build the hierarchy of Go types. One of them
    is the `xmlquery` package (see *Further reading*), which lets you make XML Path
    Language (XPath) queries from Go.
  prefs: []
  type: TYPE_NORMAL
- en: YAML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let’s look at how we would parse a YAML inventory. You can find this example
    in the `ch03/yaml` directory of the book’s repository (see *Further reading*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'By now, you would probably already have guessed that the number and nature
    of things that change from the JSON example are the same as for XML, which is
    to say, not much. The following code snippet highlights only the changed lines
    of code, and you can find the full code example at `ch03/yaml/main.go` (see *Further
    reading*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'This Go program produces the same result as both the JSON and XML examples,
    but before we can run it, we need to go get the external YAML library dependency
    first (`gopkg.in/yaml.v2`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: It’s also possible to parse and query YAML documents without having to predefine
    data structures. One tool that does that is `yq` (see *Further reading*), which
    implements a shell CLI tool in Go in the style of `jq` (the `sed` for JSON data).
    You can use `yq` in your Go program via its built-in `yqlib` package.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as important as being able to decode data from a source is processing the
    data in the opposite direction, producing a structured data document based on
    an in-memory data model. In the next example, we pick up where we left off in
    the *Decoding* section and take the in-memory data we got from a JSON input file
    to output a corresponding XML document.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the first things we have to do in the code is to update the struct tags
    with an extra key-value pair for XML. Although this is not strictly necessary,
    as the XML library can fall back to using field names instead, it’s generally
    considered a best practice to annotate explicitly all relevant fields that you
    encode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'The full code of this example is available in the `ch03/json-xml` directory
    (see *Further reading*) of the book’s repository, so for the sake of brevity,
    we only include the extra code that we add to encode the `inv` variable into an
    XML document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'To produce a string output, we’re using the `strings.Builder` type, which implements
    the `io.Writer` interface required by the `Encode` method. This highlights the
    power of interfaces, as we could have passed in a network connection and sent
    the XML data to a remote host instead, with almost the same program. The next
    snippet shows the output of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: One encoding format we haven’t covered yet is Protocol Buffers, which is part
    of the gRPC section of [*Chapter 8*](B16971_08.xhtml#_idTextAnchor182).
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we’ve covered enough Go language theory to write effective programs
    to interact with and automate a network device. The only bit that we have left,
    which is also one of the most salient features of the language, is concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If there was one feature that would characterize Go amongst other popular programming
    languages, it would be concurrency. Go’s built-in concurrency primitives (goroutines
    and channels) are one of the best abstractions we know for writing efficient code
    that can run more than one task simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your program starts in the main goroutine, but at any point, you can spawn
    other concurrent goroutines and create communication channels between them. You
    can do this with considerably less effort and less code compared to other programming
    languages, which improves the developing experience and your code’s support:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Go’s concurrency](img/Figure_3.121.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – Go’s concurrency
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we cover the following concurrency primitives:'
  prefs: []
  type: TYPE_NORMAL
- en: Goroutines and the use of the `sync` package for their coordination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How we use channels to send and receive data between goroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of mutexes with data shared between different goroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Goroutines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way to think of Goroutines is as user-space threads that the Go runtime
    manages. They are computationally cheap to spawn and manage, so they can scale
    to hundreds of thousands, even on an average machine, with memory being the primary
    limiting factor.
  prefs: []
  type: TYPE_NORMAL
- en: It’s typical to create goroutines for tasks that may block the execution of
    the main function. You can imagine why this would be particularly helpful in a
    network automation context, where we have to deal with remote network calls and
    wait for network devices to execute the commands.
  prefs: []
  type: TYPE_NORMAL
- en: We introduce the basic goroutine theory by building another network automation
    example. In the preceding section, we learned how to load and parse a device inventory.
    In this section, we pick up where we left off and see how to interact with these
    network devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start off, we use an inventory file (`input.yml`) with a single device.
    This file is in the `ch03/single` folder (see *Further reading*) of the book’s
    repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'To store this inventory, we define a type hierarchy like the one we had in
    the encoding/decoding section. The code example output only shows some fields
    for brevity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'We define another function called `getVersion` that accepts an argument of
    the `Router` type, connects and retrieves the software and hardware version information,
    and prints it on a screen. The exact implementation of this function is not important
    and we don’t focus on it in this chapter yet, but you can see the full code example
    at `ch03/single/main.go` (see *Further reading*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we only have one device in the inventory, we can access it directly using
    a slice index. The execution of this program takes a little under 2 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s look at a similar example, stored in the `ch03/sequential` directory
    (see *Further reading*), where we’ve added two extra devices to the inventory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'As we discussed in the *Control flow* section, we can iterate over arrays and
    slices with the `range` form of a `for` loop. Here, we iterate over each `Router`
    in `inv.Routers`, assigning it to the `v` variable in each iteration. We ignore
    the value of the index by assigning it to the blank identifier written as `_`
    (underscore). Finally, we call the `getVersion` function for the `v` router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'It takes around 7 seconds to execute as it connects to one device after another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a prime example of code that we could optimize through the use of goroutines.
    All we need to do initially is to add a `go` keyword before the statement that
    we need to run in a goroutine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: In the code example, we spawn a separate goroutine for each invocation of the
    `getVersion` (`v`) statement. Everything happens in the background; any blocking
    statement inside a spawned goroutine does not affect the other goroutines, so
    all three function calls, plus the main goroutine, now run concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: The default behavior of these spawned goroutines is to release control immediately,
    so in this example, the code iterates over all three devices and then returns.
    It doesn’t actually wait for the spawned goroutines to complete.
  prefs: []
  type: TYPE_NORMAL
- en: But, in our case, we’d like to see the result of all three function calls before
    we exit the program. This is where we can use a special `sync.WaitGroup` type,
    which blocks the main goroutine until all spawned goroutines complete. It does
    this by keeping a counter that tracks all currently active goroutines and blocks
    until that counter goes down to zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what we do to introduce this idea in the code example we are working
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a new `wg` variable of the `sync.WaitGroup` type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While iterating through our inventory, we increase the `WaitGroup` counter by
    one with `wg.Add(1)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each spawned goroutine consists of an anonymous function that runs `getVersion`,
    but also calls `wg.Done` at the very end to decrement the `WaitGroup` counter
    by one with a `defer` statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main goroutine blocks on `wg.Wait` until the `WaitGroup` counter becomes
    zero. This happens after all the spawned instances of the `getVersion` functions
    return.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the full code of this example at `ch03/concurrency/main.go` (see
    *Further reading*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s see what effect these changes have on the execution time of the
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: We’ve gone down to roughly 3 seconds, which is how long it took to communicate
    with the slowest device in the inventory. This is a pretty significant win, considering
    we didn’t have to change any of the *worker* functions (`getVersion` in this case).
    You might apply the same refactoring to many other similar programs with minimal
    changes to their existing code bases.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach works well with natively synchronous functions that you can run
    with or without a goroutine. But, if we know that a certain function always runs
    in a goroutine, it’s totally possible to make it goroutine-aware from the very
    beginning. For example, this is how we could have refactored the `getVersion`
    function to accept an extra `WaitGroup` argument and make the `wg.Done` call part
    of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Having a function like that would simplify the code of the main function since
    we no longer need to wrap everything in an anonymous function just to make the
    `wg.Done` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: The complete code for this example is available in the `ch03/concurrency2` directory
    (see *Further reading*).
  prefs: []
  type: TYPE_NORMAL
- en: Channels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As soon as anyone becomes familiar with goroutines, the next thing they normally
    want to do is exchange data between them. Go channels allow goroutines to communicate
    with each other. A real-world analogy to describe Go channels are first-in-first-out
    pipes – they have fixed throughput and allow you to send data in both directions.
  prefs: []
  type: TYPE_NORMAL
- en: You can use channels for both goroutine synchronization (a form of signaling
    used for work coordination) and general-purpose data exchange.
  prefs: []
  type: TYPE_NORMAL
- en: We create channels with the `make` keyword, which initializes them and makes
    them ready to use. The two arguments that `make` accepts are the channel type,
    which defines the data type you can exchange over the channel, and an optional
    capacity. The channel capacity determines how many unreceived values it can store
    before it starts blocking a sender, acting then as a buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how we send and receive an integer over a
    channel. Here, `send` is the value we want to send to the `ch` channel we created.
    The `<-` operator lets us send data to a channel. Next, we declare a `receive`
    variable, whose value comes from the `ch` channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: But, sending and receiving data in a single goroutine is not the goal here.
    Let’s examine another example of using channels for communication between different
    goroutines. We pick up the example we’ve used in this section so far and introduce
    another *worker* function whose job is to print the results produced by the `getVersion`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new `printer` function uses a `for` loop to receive values from an `in`
    channel and it prints them on the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'We create the `ch` channel in the main goroutine before we spawn any of the
    goroutines. We pass it as an argument to both `getVersion` and `printer` functions.
    The first extra goroutine we start is an instance of the `printer` function that
    listens for messages coming from the device over the `ch` channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to start a goroutine for each network device in the inventory
    to capture the output we need and send it over the channel with the `getVersion`
    function. After we collect and print the data, we close the channel and end the
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: The complete code for this example is available in the `ch03/concurrency3` (*Further*
    *reading*) directory.
  prefs: []
  type: TYPE_NORMAL
- en: Channels and Timers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One thing we didn’t consider in the last couple of examples was the scenario
    where a network device is not reachable, or the connection to it hangs, or maybe
    a device takes forever to return the output we need. In these cases, we need to
    set up a timeout so we don’t wait forever and we can end the program gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can handle this at the connection level, but also, channels offer you a
    couple of resources to keep track of time via these timer types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Timer** — To wait for a certain amount of time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ticker** — To perform an action repeatedly at some interval'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Timer` can help you define a timeout for your program. To illustrate this,
    we can rewrite the example we have been working with to print all the messages
    from the `ch` channel in the main function, instead of calling a separate function
    (`printer`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `select` statement inside an infinite loop handles this as follows. Unlike
    a `switch` statement, we use `select` with channels when we don’t have to choose
    an option in order. For each iteration, we either wait for a message from the
    `ch` channel or if 5 seconds have elapsed (`time.After(5 * time.Second)`), we
    close the channel and exit the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: This forces the runtime to always be 5 seconds, even if not all the tasks have
    been completed. This is not the most efficient way to solve this problem, but
    it shows how to timeout without introducing the `context` package from the standard
    library that you could also use in this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: The complete code for this example is available in the `ch03/concurrency5` directory
    of the book’s repository (see *Further reading*).
  prefs: []
  type: TYPE_NORMAL
- en: Ticker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common use for a ticker is in cases where you want to execute periodic tasks.
    In the next code example, we create a `ticker` that runs every half second, which
    we use as a trigger to print out a message to the terminal. We also create a `done`
    channel, just to signal that we want to stop the execution of the program after
    2 seconds and 100 milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Tickers from the `time` package have a `C` channel that they use to signal
    every interval. We pass this channel and the `done` channel to the `repeat` function
    that we execute in a goroutine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'This function runs an infinite loop that waits for a signal from the `ticker`
    or the `done` channel to end the execution. This is what the output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: The complete code for this example is available in the `ch03/ticker` directory
    (see *Further reading*).
  prefs: []
  type: TYPE_NORMAL
- en: Shared data access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Channels are thread-safe, so it’s always a good idea to use them as the default
    option for data communication between goroutines. But sometimes, you may still
    need to access and change data that more than just one goroutine has access to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with concurrent data access is that it may cause data corruption
    when many goroutines try to change the same field or read from a field that someone
    else might be changing. Go’s `sync` package includes three helper types you can
    use to serialize these kinds of operations:'
  prefs: []
  type: TYPE_NORMAL
- en: The `sync.Mutex` type is a general-purpose mutual exclusion lock that has two
    states — locked and unlocked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sync.RWMutex` type is a special mutex for read-write operations where only
    write operations are mutually exclusive but simultaneous read operations are safe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sync.Map` mutex covers a couple of map corner case scenarios that we don’t
    delve into in this book. The **sync.Map documentation** talks about them (see
    *Further reading*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s see an example of how you can use `sync.RWMutexto` to safeguard
    concurrent map access. Using the example theme we have used through this section
    as the baseline, let’s add another variable that records whether we are able to
    connect successfully to a remote device. We call this variable `isAlive` and pass
    it to the `getVersion` function as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the `m` mutex as a package-level global variable to make sure all
    functions are using the same mutex for synchronization. We lock this mutex just
    before we change the `isAlive` map and unlock it right after we make the change
    in the `getVersion` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add another mutex for a loop in the main function that uses a read-specific
    lock while iterating over a map to prevent it from being accidentally modified
    in the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check the full code in the `ch03/concurrency4` directory (see *Further
    reading*). The next output shows what this program produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, you might forget to use mutexes, especially for non-trivial user-defined
    data types, or when you accidentally leak a variable between goroutines. In these
    cases, you can use the data race detector built into the `go` tool. Add the `-race`
    flag to any of the go `test`/`run`/`build` commands to check and get a report
    of any unprotected access requests to shared memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how it works, let’s focus on the `isAlive` map we manipulate concurrently
    on different instances of the `getVersion` function. Earlier, we surrounded this
    with a mutex, which we now remove in `ch03/race/main.go` (see *Further reading*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the program with the extra `-race` flag, Go highlights the data
    race condition it detects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Go’s built-in data race detector alleviates the task of debugging data races,
    which are among the hardest bugs to debug in concurrent systems.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency caveats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Concurrency is a powerful tool. You could even envision using goroutines everywhere
    in your code and following design patterns such as worker pools to split up your
    work between different goroutines to get the initial speed gains for a relatively
    small price of increased complexity.
  prefs: []
  type: TYPE_NORMAL
- en: But, it’s important to consider that *concurrency is not parallelism* (see *Further
    reading*) and there is always some overhead involved in the coordination of goroutines
    and mapping them to OS threads. We also shouldn’t forget that the underlying hardware
    resources are finite and so are the concurrency performance gains, as they inevitably
    flatten out at a certain point (see *Simulating a real-world system in Go* in
    the *Further* *reading* section).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, concurrent programming is hard; it’s hard to write code that’s safe,
    and hard to reason about and debug when it breaks. It’s important not to over-engineer
    your code with goroutines and use them when and where you truly need them, measure
    your gains and detect race conditions, avoid memory sharing if possible, and opt
    for communicating via channels.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter concludes the theoretical introduction to Go as a programming language.
    We went from Go variable types and performing operations with them, to reviewing
    the key building blocks of Go programs, and how to take advantage of some of Go’s
    most notable packages from its standard library to help you build scalable applications.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from the next chapter, we turn our attention to network-specific tasks
    that are more applicable to real-world scenarios. We still continue introducing
    some theoretical concepts throughout the book, but most content is on concrete
    use cases rather than abstract theory.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ch03/type-definition/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/type-definition/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/type-definition/main.go
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/string-literals/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/string-literals/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/string-literals/main.go
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/string-concatenate/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/string-concatenate/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/string-concatenate/main.go
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/string-memory/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/string-memory/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/string-memory/main.go
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/boolean/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/boolean/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/boolean/main.go
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/arrays/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/arrays/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/arrays/main.go)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/slices/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/slices/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/slices/main.go)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/maps/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/maps/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/maps/main.go
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/structs/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/structs/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/structs/main.go)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/tcp-header/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/tcp-header/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/tcp-header/main.go)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Comparison* *operators*: [https://golang.org/ref/spec#Comparison_operators](https://golang.org/ref/spec#Comparison_operators)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/switch/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/switch/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/switch/main.go)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/goto/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/goto/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/goto/main.go)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/functions1/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/functions1/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/functions1/main.go)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/functions2/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/functions2/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/functions2/main.go)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/mutate-slice/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/mutate-slice/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/mutate-slice/main.go)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/methods/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/methods/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/methods/main.go)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/variadic/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/variadic/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/variadic/main.go)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/defer/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/defer/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/defer/main.go)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Sample* *program*: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/interfaces-sample/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/interfaces-sample/main.go
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/io-interface1/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/io-interface1/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/io-interface1/main.go
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/io-interface2/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/io-interface2/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/io-interface2/main.go
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/reader/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/reader/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/reader/main.go
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/json`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/json](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/json
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Book’s GitHub repository: [https://github.com/PacktPublishing/Network-Automation-with-Go](https://github.com/PacktPublishing/Network-Automation-with-Go
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/json/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/json/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/json/main.go)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/json-interface`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/json-interface](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/json-interface
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*GJSON*: [https://github.com/tidwall/gjson](https://github.com/tidwall/gjson
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*SJSON*: [https://github.com/tidwall/sjson](https://github.com/tidwall/sjson
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/xml`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/xml](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/xml
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xmlquery`: [https://github.com/antchfx/xmlquery](https://github.com/antchfx/xmlquery
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/yaml`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/yaml](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/yaml
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/yaml/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/yaml/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/yaml/main.go)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*yq*: [https://github.com/mikefarah/yq](https://github.com/mikefarah/yq)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/json-xml`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/json-xml](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/json-xml
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/single`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/single](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/single
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/single/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/single/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/single/main.go
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/sequential`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/sequentia](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/sequentia
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/concurrency/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/concurrency/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/concurrency/main.go
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/concurrency2`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency2](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency2
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/concurrency3`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency3](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency3
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/concurrency5`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency5](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency5
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/ticker`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/ticker](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/ticker
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*sync.Map* *documentation*: [https://pkg.go.dev/sync#Map](https://pkg.go.dev/sync#Map
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/concurrency4`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency4](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency4
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch03/race/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/race/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/race/main.go
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Simulating a real-world system in* *Go*: [https://www.youtube.com/watch?v=_YK0viplIl4](https://www.youtube.com/watch?v=_YK0viplIl4
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Concurrency is not* *parallelism*: [https://blog.golang.org/waza-talk](https://blog.golang.org/waza-talk)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
