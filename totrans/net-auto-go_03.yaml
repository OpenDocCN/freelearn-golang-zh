- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Getting Started with Go
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Go
- en: In this chapter, we dive into the Go basics and the characteristics that make
    it comparable to a dynamically typed language, but with the efficiency and safety
    of a statically typed, compiled language.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入了解 Go 的基础知识及其与动态类型语言可比的特性，但具有静态类型、编译语言的效率和安全性。
- en: We also explore different Go packages to manipulate data in different formats
    and how to scale programs with Go’s concurrency model. Being able to manipulate
    data effectively and take advantage of all the resources of systems running multi-core
    processors are key elements to keep in mind when automating networks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了不同的 Go 包，用于以不同格式处理数据，以及如何使用 Go 的并发模型来扩展程序。在自动化网络时，能够有效地处理数据并充分利用运行多核处理器的系统的所有资源是关键要素。
- en: 'During this chapter, we cover the following key topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下关键主题：
- en: Go variable types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 变量类型
- en: Go’s arithmetic, comparison, and logical operators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 的算术、比较和逻辑运算符
- en: Control flow
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制流程
- en: Functions in Go
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 中的函数
- en: Interfaces in Go
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 中的接口
- en: Input and output operations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入和输出操作
- en: Decoding and encoding with Go
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Go 进行解码和编码
- en: Concurrency
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We assume basic familiarity with the command line, Git, and GitHub. You can
    find the code examples for this chapter in the book’s GitHub repository at [https://github.com/PacktPublishing/Network-Automation-with-Go](https://github.com/PacktPublishing/Network-Automation-with-Go),
    under the `ch03` folder.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设您对命令行、Git 和 GitHub 有基本的了解。您可以在本书的 GitHub 仓库中找到本章的代码示例，网址为 [https://github.com/PacktPublishing/Network-Automation-with-Go](https://github.com/PacktPublishing/Network-Automation-with-Go)，在
    `ch03` 文件夹下。
- en: 'To run the examples, perform the following steps:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行示例，请执行以下步骤：
- en: Install Go 1.17 or later for your operating system. You can follow the instructions
    in [*Chapter 1*](B16971_01.xhtml#_idTextAnchor015), *Introduction*, in the *Installing
    Go* section, or go to [https://go.dev/doc/install](https://go.dev/doc/install).
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的操作系统安装 Go 1.17 或更高版本。您可以在 *安装 Go* 部分的 *第 1 章* 中找到说明，或访问 [https://go.dev/doc/install](https://go.dev/doc/install)。
- en: Clone the book’s GitHub repository with `git` `clone` [https://github.com/PacktPublishing/Network-Automation-with-Go.git](https://github.com/PacktPublishing/Network-Automation-with-Go.git).
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `git clone [https://github.com/PacktPublishing/Network-Automation-with-Go.git](https://github.com/PacktPublishing/Network-Automation-with-Go.git)`
    克隆本书的 GitHub 仓库。
- en: 'Change the directory to an example folder:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目录更改为示例文件夹：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Execute `go` `run main.go`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `go run main.go`。
- en: Go’s type system
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 的类型系统
- en: 'Go is a statically typed language, which means the compiler must know the types
    of all variables to build a program. The compiler looks for a special variable
    declaration signature and allocates enough memory to store its value:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Go 是一种静态类型语言，这意味着编译器必须知道所有变量的类型才能构建程序。编译器寻找特殊的变量声明签名，并分配足够的内存来存储其值：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'By default, Go initializes the memory with the zero value corresponding to
    its type. In the preceding example, we declare `n`, which has an initial value
    of `0`. We later assign a new value of `42`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Go 使用与其类型对应的零值初始化内存。在上面的示例中，我们声明了 `n`，其初始值为 `0`。后来我们将其赋值为 `42`：
- en: '![Table 3.1 – Zero values](img/Figure_3.1.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![表 3.1 – 零值](img/Figure_3.1.jpg)'
- en: Table 3.1 – Zero values
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1 – 零值
- en: As its name suggests, a variable can change its value, but only as long as its
    type remains the same. If you try to assign a value with a different type or redeclare
    a variable, the compiler complains with an appropriate error message.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，变量可以改变其值，但前提是它的类型保持不变。如果您尝试分配不同类型的值或重新声明变量，编译器会显示适当的错误信息。
- en: 'If we append a line with `n = "Hello"` to the last code example, the program
    wouldn’t compile, and it would return the following error message: `cannot use
    "Hello" (type untyped string) as type int` `in assignment`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在最后一个代码示例中添加一行 `n = "Hello"`，程序将无法编译，并返回以下错误信息：`cannot use "Hello" (type
    untyped string) as type int in assignment`。
- en: You can use type inference as a shortcut for variable declarations. In that
    case, you omit an explicit type argument in your declaration. Just keep in mind
    that Go has limited support for type inference inside of a function.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用类型推断作为变量声明的快捷方式。在这种情况下，您在声明中省略了显式的类型参数。只需记住，Go 在函数内部对类型推断的支持有限。
- en: 'Instead of explicitly defining a type for each variable, you can use a special
    short assignment symbol, `:=`, and let the compiler guess the variable type based
    on its value, as in the next example, where the compiler assumes the variable
    `n` is of type `int`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以不显式为每个变量定义类型，而是使用一个特殊的短赋值符号`:=`，让编译器根据其值猜测变量类型，如下一个示例所示，编译器假设变量`n`的类型是`int`：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Just like with variables, the compiler can also infer a constant type. The
    value of constants cannot change throughout the program and we generally use them
    to represent real-world values such as the number *π* (**Pi**), static names of
    objects or places, and so on:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 就像变量一样，编译器也可以推断常量的类型。常量的值在整个程序中不能改变，我们通常使用它们来表示现实世界的值，例如数字*π*（**π**）、对象的静态名称或地点等：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, let’s have a closer look at the different types available in Go and their
    common use cases.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地看看Go中可用的不同类型及其常见用例。
- en: Basic types
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本类型
- en: 'According to Go’s language specification, there are four groups of basic or
    primitive types predeclared globally and available to all Go programs by default:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Go的语言规范，有四组基本或原始类型在全局范围内预声明，并且默认对所有Go程序可用：
- en: Numeric
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值
- en: Strings
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Boolean
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔
- en: Error
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: Numeric
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数值
- en: 'Go defines several numeric types to store integers and real numbers of different
    sizes. Type names normally contain information about their sign and the size of
    the value (in bits). The only notable exceptions are `int` and `uint` types, whose
    values depend on the machine and normally default to 32 bits for 32-bit CPUs,
    or 64 bits for 64-bit CPU architectures:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Go定义了几个数值类型来存储不同大小的整数和实数。类型名称通常包含有关它们的符号和值大小（以位为单位）的信息。唯一的例外是`int`和`uint`类型，它们的值取决于机器，通常对于32位CPU默认为32位，对于64位CPU架构默认为64位：
- en: '![Table 3.2 – Numeric type variables](img/Figure_3.2.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![表3.2 – 数值类型变量](img/Figure_3.2.jpg)'
- en: Table 3.2 – Numeric type variables
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.2 – 数值类型变量
- en: 'Here are some examples of how to instantiate variables of numeric types. These
    are all valid options, and you can use whichever is most appropriate for the range
    of values you need to store or produce. You can test this code from `ch03/type-definition/main.go`
    (in the *Further reading* section). Notice we use type inference for `a`, so its
    type is `int` and its size is 8 bytes on a 64-bit machine. The second variable
    (`b`) is an unsigned 32-bit integer (4 bytes). The last variable (`c`) is a floating-point
    number (4 bytes):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些如何实例化数值类型变量的示例。这些都是有效选项，你可以根据需要存储或生成的值范围选择最合适的选项。你可以从`ch03/type-definition/main.go`（在*进一步阅读*部分）测试这段代码。注意我们为`a`使用了类型推断，因此它的类型是`int`，在64位机器上大小为8字节。第二个变量（`b`）是一个无符号32位整数（4字节）。最后一个变量（`c`）是一个浮点数（4字节）：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can also convert a `v` value to the `T` type with the expression `T(v)`,
    as in the next example. Here, `b` results from converting `a`, an integer, to
    an unsigned 32-bit integer, and finally, `c` is a floating-point number from converting
    `b`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用表达式`T(v)`将`v`值转换为`T`类型，如下一个示例所示。在这里，`b`是通过将整数`a`转换为无符号32位整数得到的，最后`c`是通过将`b`转换为浮点数得到的：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once you have defined a type for a variable, any new operation has to match
    this type on both sides of the assignment operator (`=`). You could not append
    `b = int64(c)` at the end of the preceding example, as `b` would be of the `uint32`
    type.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦为变量定义了类型，任何新的操作都必须在赋值运算符（`=`）的两侧匹配此类型。你无法在前面示例的末尾添加`b = int64(c)`，因为`b`将是`uint32`类型。
- en: Type conversion is always explicit in Go, unlike other programming languages
    that may do this implicitly and sometimes call this type casting.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，类型转换总是显式的，与其他可能隐式执行此操作并有时称为类型转换的编程语言不同。
- en: Strings
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串
- en: 'Go supports two styles of string literals: you can enclose the characters with
    double-quotes to make it an interpreted literal, or use back-quotes for raw string
    literals, as in the next example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Go支持两种字符串字面量风格：你可以用双引号括起来使其成为一个解释字面量，或者使用反引号用于原始字符串字面量，如下一个示例所示：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Notice the escape sequence in `d`. Go interprets this to generate a new line
    character within the string. The following is the output of this program, which
    you can find at `ch03/string-literals/main.go` (in the *Further* *reading* section):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`d`中的转义序列。Go将其解释为在字符串中生成一个新行字符。以下是这个程序的输出，你可以在`ch03/string-literals/main.go`（在*进一步阅读*部分）找到它：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can compare strings with the `==` and `!=` operators. You can concatenate
    strings with the `+` and `+=` operators. The example at `ch03/string-concatenate/main.go`
    (in the *Further reading* section) shows these operators in action:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `==` 和 `!=` 操作符来比较字符串。你可以使用 `+` 和 `+=` 操作符来连接字符串。`ch03/string-concatenate/main.go`
    中的示例（在 *进一步阅读* 部分）展示了这些操作符的使用：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Until this point, nothing seems to be too different from other programing languages.
    But in Go, a string is actually a slice of bytes, or to be more precise, a sequence
    of UTF-8 Unicode points. In memory, Go represents this as a two-word structure
    containing a pointer to the string data and its length.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这似乎与其他编程语言没有太大区别。但在 Go 语言中，字符串实际上是一个字节数组的切片，或者更准确地说，是一个 UTF-8 Unicode
    点的序列。在内存中，Go 语言将其表示为一个包含指向字符串数据和其长度的指针的两个字的结构。
- en: 'Let’s define a new string, `n`, with the `Network Automation` string literal
    in `ch03/string-memory/main.go` (in the *Further reading* section). We can store
    each character as one or more bytes using the variable-width character encoding
    UTF-8\. For English, we use one byte per character, so the string literal in this
    case is 18 bytes long:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `ch03/string-memory/main.go`（在 *进一步阅读* 部分）中定义一个新的字符串 `n`，使用 `Network Automation`
    字面量。我们可以使用 UTF-8 可变宽度字符编码将每个字符存储为一个或多个字节。对于英语，我们每个字符使用一个字节，所以在这种情况下，字符串字面量是 18
    字节长：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can define another string as a subset of another. For this, we specify the
    lower bound in the original string and the upper bound. The index count starts
    at zero and the resulting string doesn’t include the character in the upper bound
    index. For `n[3:7]`, we set the boundaries at characters “`w`” and ““. The program
    prints the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将另一个字符串定义为另一个字符串的子集。为此，我们指定原始字符串中的下界和上界。索引计数从零开始，生成的字符串不包括上界索引中的字符。对于 `n[3:7]`，我们将边界设置为字符
    “`w`” 和 ““. 程序打印以下内容：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'While the `n` and `w` variables reference strings of different lengths, the
    variable size of both is the same, just like for any other string variable. A
    string variable is a two-word structure. A word is usually 32 or 64 bits depending
    on the CPU architecture. Two 64-bit words are 16 bytes (2 x 8-byte), so for 64-bit
    platforms, a string is a 16-byte data structure. Out of those 16 bytes, 8 bytes
    are a pointer to the actual string data (a slice), and the remaining 8 bytes are
    to store the length of the string slice. *Figure 3**.1* shows what this looks
    like in memory:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `n` 和 `w` 变量引用的字符串长度不同，但它们的大小变量是相同的，就像任何其他字符串变量一样。字符串变量是一个两个字的结构。一个字通常是 32
    或 64 位，这取决于 CPU 架构。两个 64 位字是 16 字节（2 x 8 字节），所以对于 64 位平台，字符串是一个 16 字节的数据结构。在这
    16 字节中，8 字节是指向实际字符串数据（切片）的指针，剩下的 8 字节用于存储字符串切片的长度。*图 3.1* 展示了它在内存中的样子：
- en: '![Figure 3.1 – What a string looks like in memory](img/Figure_3.3.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 字符串在内存中的样子](img/Figure_3.3.jpg)'
- en: Figure 3.1 – What a string looks like in memory
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 字符串在内存中的样子
- en: It’s OK that more than one string references the same underlying slice, as this
    slice is immutable, meaning that you can’t change its contents. While the slice
    stores the string data, you can’t change a character of the string by referencing
    an index of the slice, because it’s immutable.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个字符串引用相同的底层切片，这是可以的，因为这个切片是不可变的，意味着你不能改变其内容。虽然切片存储字符串数据，但你不能通过引用切片的索引来改变字符串中的字符，因为它是不可变的。
- en: By contrast, if you want to change the value of a string variable, let’s say
    you need to assign a different text to it, Go points the string data structure
    to a new underlying slice with the new string content you supply. All this happens
    behind the scenes, so you don’t need to worry about this.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，如果你想改变字符串变量的值，比如说你需要给它分配不同的文本，Go 语言会将字符串数据结构指向一个新的底层切片，该切片包含你提供的新的字符串内容。所有这些都在幕后发生，所以你不需要担心这个问题。
- en: Boolean
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'The `bool` data type uses one byte of memory, and it stores a value of either
    `true` or `false`. As in other programming languages, you can use variables of
    the `bool` type in conditional statements to change the control flow of a program.
    The `if` conditional explicitly requires a `bool` type:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`bool` 数据类型使用一个字节的内存，并存储 `true` 或 `false` 的值。与其他编程语言一样，你可以在条件语句中使用 `bool` 类型的变量来改变程序的流程控制。`if`
    条件语句明确要求 `bool` 类型：'
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you run this program at `ch03/boolean/main.go` (in the *Further reading*
    section), you get the following output:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个程序 `ch03/boolean/main.go`（在 *进一步阅读* 部分）中运行，你会得到以下输出：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Because the condition is `true`, we print the `condition` variable type and
    value.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因为条件是 `true`，我们打印 `condition` 变量的类型和值。
- en: Error
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误
- en: 'Go has a unique approach to error handling and defines a special `error` type
    to represent a failure condition. You can generate errors, change them, print
    them on a screen, or use them to change the control flow of a program. The next
    code sample shows the two most common ways of generating a new variable of the
    `Error` type:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Go 对错误处理有独特的方法，并定义了一个特殊的 `error` 类型来表示失败条件。你可以生成错误、更改它们、在屏幕上打印它们，或使用它们来改变程序的流程控制。下面的代码示例显示了生成
    `Error` 类型新变量的两种最常见方式：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can make any user-defined type an error, as long as it implements a special
    `Error()` method that returns a `string`. We talk more about implementing methods
    in the *Interfaces* section later in this chapter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将任何用户定义的类型变成错误，只要它实现了一个特殊的 `Error()` 方法，该方法返回一个 `string`。我们将在本章后面的 *接口* 部分更详细地讨论实现方法。
- en: 'One common way of error handling is to allow it to bubble up until a point
    in a program where you can decide how to react to it — whether to fail and stop
    the execution or log and retry. Regardless of that, the use of errors is pervasive
    in Go, and all functions that can fail return an error as their last argument,
    so the following pattern is very common in Go programs:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理的一种常见方式是允许它冒泡到程序中的某个点，在那里你可以决定如何响应它——是失败并停止执行，还是记录并重试。无论如何，错误在 Go 中无处不在，所有可能失败的功能都将错误作为它们的最后一个参数返回，因此以下模式在
    Go 程序中非常常见：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `myFunction` function returns two values. In the outer function in the preceding
    example, we store the first return value of `myFunction` in a variable named `result`,
    and the second return value in the `err` variable, to store the value of any potential
    error inside `myFunction`, which now surfaces to the calling function.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`myFunction` 函数返回两个值。在前面示例的外部函数中，我们将 `myFunction` 的第一个返回值存储在一个名为 `result` 的变量中，第二个返回值存储在
    `err` 变量中，以存储 `myFunction` 内部可能出现的任何错误值，现在这些错误值会暴露给调用函数。'
- en: Depending on the logic of the program, you need to decide how to handle the
    error. Here, if the error isn’t null (`nil`), we print the error message and finish
    the execution of the function (`return`). We could also have just logged it and
    allowed the program to continue.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 根据程序的逻辑，你需要决定如何处理错误。在这里，如果错误不为空（`nil`），我们打印错误信息并结束函数的执行（`return`）。我们也可以只是记录它，并允许程序继续运行。
- en: Container types
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器类型
- en: 'The next level up from the primitive types is a container type. These are still
    standard types that are available to any Go program without any explicit import
    statement. But, they represent more than just a single value. We use container
    types in Go to store different values of the same type; these include the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从原始类型向上提升一级的是容器类型。这些仍然是任何 Go 程序都可以使用的标准类型，无需任何显式的导入语句。但是，它们代表的不仅仅是单个值。我们在 Go
    中使用容器类型来存储相同类型的多个值；以下是一些包括的类型：
- en: Arrays
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Slices
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切片
- en: Maps
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射
- en: In the following sections, we discuss the use cases and implementation details
    of these three types.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将讨论这些三种类型的用例和实现细节。
- en: Arrays
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组
- en: One of the first things any programmer needs, after they’ve gained the ability
    to deal with primitive types, is the ability to store collections of values of
    these types. For example, a network inventory may store a list of device hostnames
    or IP addresses. The most common solution for this problem is a data structure
    called an `array`. Go’s `array` types have the `[n]T` signature, where `n` is
    the length of the array and `T` is the value type you store in the array.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 任何程序员在掌握了处理原始类型的能力之后，首先需要的是存储这些类型值集合的能力。例如，网络库存可能存储设备主机名或 IP 地址的列表。解决这个问题的最常见方法是使用一种称为
    `array` 的数据结构。Go 的 `array` 类型具有 `[n]T` 的签名，其中 `n` 是数组的长度，`T` 是你存储在数组中的值类型。
- en: 'Here is an example of how you can use arrays in Go with strings. We purposely
    mix different semantic ways you can define an array, so you can choose the style
    you prefer. We first define the `hostnames` array on a single line and then the
    `ips` array on a multiline statement:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，说明你如何在 Go 中使用字符串数组。我们故意混合不同的语义方式来定义数组，这样你可以选择你喜欢的风格。我们首先在单行上定义 `hostnames`
    数组，然后在多行语句中定义 `ips` 数组：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This gets even more interesting for network engineers when working with arrays
    of bytes. Look at the next example of how Go reads the input decimal number (`127`
    for example), and the binary data is at your fingertips. Both array examples are
    available at `ch03/arrays/main.go` (see the *Further* *reading* section):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网络工程师来说，当处理字节数组时，这会变得更加有趣。看看下一个示例，Go 如何读取输入的十进制数字（例如 `127`），二进制数据就在你的指尖。这两个数组示例都可以在
    `ch03/arrays/main.go`（见 *进一步阅读* 部分）中找到：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Go arrays have many benefits. They are very memory efficient, as they store
    values sequentially and don’t have any extra metadata overhead. They are also
    comparable, meaning you can check whether two arrays are equal, assuming their
    values have comparable types.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Go 数组有许多优点。它们非常节省内存，因为它们按顺序存储值，并且没有额外的元数据开销。它们也是可比较的，这意味着你可以检查两个数组是否相等，前提是它们的值具有可比较的类型。
- en: But, because of their fixed size, we rarely use arrays directly in Go. The only
    exception is when you know the size of your dataset ahead of time. With that in
    mind, in networking, we deal with a lot of fixed-sized datasets; they make up
    most of the network protocol headers, so arrays can be convenient for that and
    things such as IP and MAC addresses, port or sequence numbers, and various VPN
    labels.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，由于它们的固定大小，我们很少在 Go 中直接使用数组。唯一的例外是当你事先知道数据集的大小。考虑到这一点，在网络中，我们处理大量的固定大小数据集；它们构成了大多数网络协议头，因此数组对于这些以及诸如
    IP 和 MAC 地址、端口号或序列号以及各种 VPN 标签等都是方便的。
- en: Slices
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 切片
- en: Arrays have an immutable structure by definition (fixed-size). While you can
    alter the value within an array, they cannot grow and shrink as the size of the
    stored data changes. But, implementation-wise, this has never been a problem.
    Many languages implement arrays as dynamic data structures that change their size
    behind the scenes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，数组具有不可变的结构（固定大小）。虽然你可以改变数组中的值，但它们不能随着存储数据的尺寸变化而增长或缩小。但是，在实现上，这从来不是问题。许多语言将数组实现为在幕后改变大小的动态数据结构。
- en: Of course, there is some performance penalty involved when growing an array,
    but with some clever algorithms, it’s possible to reduce the number of changes
    and make the end user experience as frictionless as possible. Slices play this
    role in Go; they are the most widely used array-like data structure in Go.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在增长数组时会有一些性能损失，但通过一些巧妙的算法，可以减少更改次数，并尽可能使最终用户的使用体验无摩擦。在 Go 中，切片扮演着这个角色；它们是
    Go 中最广泛使用的类似数组的结构。
- en: 'Providing the length of the slice when creating it is optional. Behind the
    scenes, Go creates a backing array that defines the upper bound to what size the
    slice can grow to. That upper bound is what we know as the **capacity** of the
    slice. In general, the capacity is equal to the length of the slice, but that
    is not always the case. If the slice needs to grow beyond its capacity, Go creates
    a new larger backing array and copies over the contents of the original array.
    The next example shows three ways to create a slice and the values for capacity
    and length for each slice:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建切片时提供长度是可选的。在幕后，Go 创建一个后备数组，该数组定义了切片可以增长到的上限。这个上限就是我们所说的切片的**容量**。一般来说，容量等于切片的长度，但并不总是这样。如果切片需要超出其容量，Go
    会创建一个新的更大的后备数组，并将原始数组的内容复制过来。下一个示例展示了创建切片的三种方法以及每个切片的容量和长度：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This program, which you can find at `ch03/slices/main.go` (see the *Further
    reading* section), prints the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序，你可以在 `ch03/slices/main.go`（见 *进一步阅读* 部分）中找到，打印以下内容：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Just like with strings, you can slice a slice, which creates a new reference
    to a section of the same backing array. For example, if you create a new slice
    based on the slice words from the preceding example with `words[1:3]`, you end
    up with a slice that has `one` and `two` elements, so the length of this slice
    is two. Its capacity is six, though. Why six? The backing array is the same, but
    the new slice starts at index one, and the last index of the backing array is
    seven. *Figure 3**.2* shows what this looks like in memory:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 就像字符串一样，你可以对切片进行切片，这会创建对相同后备数组中某个部分的新的引用。例如，如果你根据前面的示例中的切片 `words` 使用 `words[1:3]`
    创建一个新的切片，你最终会得到一个包含 `one` 和 `two` 元素的切片，因此这个切片的长度是两个。然而，它的容量是六。为什么是六？后备数组是相同的，但新的切片从索引一开始，后备数组的最后一个索引是七。*图
    3**.2* 展示了它在内存中的样子：
- en: '![Figure 3.2 – What slices look like in memory](img/Figure_3.4.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 切片在内存中的样子](img/Figure_3.4.jpg)'
- en: Figure 3.2 – What slices look like in memory
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 切片在内存中的样子
- en: 'To add elements to the end of slice, you can use the built-in `append` function.
    Let’s start from the slice we were just referencing and call it `mySlice`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要向切片的末尾添加元素，你可以使用内置的 `append` 函数。让我们从我们刚才引用的切片开始，称它为 `mySlice`：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we run this program from `ch03/slices/main.go` (see the *Further reading*
    section), we can see how Go allocates a new backing array when it needs extra
    capacity. When it had three elements already, and we asked to add another four
    to a slice with a capacity of six, Go automatically allocated a new backing array
    with a capacity of 12 to support the extra elements and future growth:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从 `ch03/slices/main.go` 运行这个程序（参见 *进一步阅读* 部分），我们可以看到当 Go 需要额外的容量时，它是如何分配一个新的后备数组的。当它已经有了三个元素，并且我们要求向一个容量为六的切片中添加另外四个元素时，Go
    自动分配了一个容量为 12 的新后备数组来支持额外的元素和未来的增长：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The bottom line is that while this might sound hard to grasp, it all happens
    behind the scenes. What we want to leave you with about slices is that they are
    a three-word data structure, and are 24 bytes on most computers nowadays.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，虽然这听起来可能难以理解，但所有这些都在幕后发生。我们想要留给你的关于切片的是，它们是一种三词数据结构，在大多数计算机上现在通常是 24 字节。
- en: Maps
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射
- en: Maps are a container type that makes it possible to store a mapping between
    one type, for example, a string or an integer, as the key to another type stored
    as the value. A map is of the `map[KeyType]ValueType` form, where `KeyType` is
    any type that is comparable and `ValueType` may be any type at all. One example
    would be `map[int]string`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 映射是一种容器类型，它使得将一种类型（例如，字符串或整数）作为键存储为另一个类型（作为值）的映射成为可能。映射的形式为 `map[KeyType]ValueType`，其中
    `KeyType` 是任何可比较的类型，`ValueType` 可以是任何类型。一个例子是 `map[int]string`。
- en: 'One way to initialize a map is with the built-in `make` function as in the
    next example, where we create a map of `string` as key and also with `string`
    as value. You can add new values to the map, referencing the key you want to associate
    that value with. In the example, we map `spine` to `192.168.100.1`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化映射的一种方法是在下一个示例中使用内置的 `make` 函数，其中我们创建了一个以 `string` 为键和值的映射。你可以向映射中添加新的值，通过引用你想要关联该值的键。在示例中，我们将
    `spine` 映射到 `192.168.100.1`：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To retrieve a value and assign it to a variable, you can reference the key just
    like when adding values, but this time, on the right side of the equals sign,
    as in the preceding example, where we assigned the value of `dc["spine"]` to the
    `ip` variable.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索一个值并将其分配给一个变量，你可以像添加值时一样引用键，但这次在等号右侧，就像前面的示例中我们分配 `dc["spine"]` 的值到 `ip`
    变量一样。
- en: You can also do membership testing, to check whether a certain key is on the
    map. A two-value assignment tests for the existence of a key, as in `ip, exists
    := dc["spine"]`, where `exists` is a Boolean value that is only `true` if `dc["spine"]`
    exists.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以进行成员测试，以检查某个键是否在映射中。一个双值赋值用于测试键的存在，例如在 `ip, exists := dc["spine"]` 中，其中
    `exists` 是一个布尔值，只有当 `dc["spine"]` 存在时才为 `true`。
- en: 'Another way to initialize a map is with data, as in the next example. To delete
    elements, you can use the built-in `delete` function:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化映射的另一种方法是使用数据，如下一个示例所示。要删除元素，你可以使用内置的 `delete` 函数：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This program prints the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序打印以下内容：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The full code for this section is available at `ch03/maps/main.go` (see the
    *Further* *reading* section).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的完整代码可在 `ch03/maps/main.go` 中找到（参见 *进一步* *阅读* 部分）。
- en: User-defined types
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户定义的类型
- en: 'Unlike the types we discussed before, user-defined types, as the name suggests,
    are types that you define. In this category we have the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前讨论的类型不同，用户定义的类型，正如其名所示，是你定义的类型。在这个类别中，我们有以下几种：
- en: Structs
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体
- en: Interfaces
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: Interfaces are the only abstract type in Go and define a contract for concrete
    types, such as structs. They describe behavior, not implementation details, which
    helps us break the business logic of our programs into building blocks with interfaces
    between them. We cover them in detail in a dedicated section for interfaces later
    in this chapter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是 Go 中唯一的抽象类型，并为具体类型（如结构体）定义了一个合同。它们描述行为，而不是实现细节，这有助于我们将程序的商务逻辑分解成带有接口的构建块。我们将在本章后面的接口专用部分详细讨论它们。
- en: Structs
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构体
- en: A struct is a data structure that represents a collection of fields with their
    data types. Structs look a bit like mappings, except the keys in this case are
    fixed. They become an extension of the variable name.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体是一种表示一组字段及其数据类型的复杂数据结构。结构体看起来有点像映射，但这里的键是固定的。它们成为变量名的扩展。
- en: 'Let’s define a router (`Router`) that has four `string` fields and one `bool`
    field:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个具有四个`string`字段和一个`bool`字段的`Router`：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, this new type can also be part of another user-defined type, as in the
    following `Inventory` type, which has a slice of these routers we just defined:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个新类型也可以是另一个用户定义类型的一部分，如下面的`Inventory`类型，它包含我们刚才定义的这些路由器的切片：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here are a few examples of how to create an instance of a struct and assign
    values to its fields:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些创建结构体实例并为其字段赋值的示例：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The caveat is that `r2` is now actually a pointer to `Router` (that’s how `new`
    works), but it’s not something we need to worry about right now. Let’s put all
    the routers in an `Inventory` type variable:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意的是，`r2`现在实际上是指向`Router`的指针（这就是`new`的工作方式），但这不是我们现在需要担心的事情。让我们将所有路由器放入一个`Inventory`类型的变量中：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we have all our routers conveniently in a variable we can use. All the
    fields we haven’t assigned a value yet are zero value (`""`, or empty for strings):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经在变量中方便地放置了所有路由器。我们尚未分配值的所有字段都是零值（`""`，或字符串的空值）：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The code in this example is available at `ch03/structs/main.go` (see the *Further*
    *reading* section).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中的代码可在`ch03/structs/main.go`中找到（见*进一步* *阅读*部分）。
- en: Until this point, we have not talked about other variable types such as pointers,
    channels, and functions. We cover these in other sections of this chapter. Please
    bear with us. In the next section, we introduce some math and logical operators
    that allow us to execute different actions in our programs.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有讨论其他变量类型，如指针、通道和函数。我们将在本章的其他部分介绍这些内容。请耐心等待。在下一节中，我们将介绍一些数学和逻辑运算符，这些运算符允许我们在程序中执行不同的操作。
- en: Arithmetic, comparison, and logical operators
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算术、比较和逻辑运算符
- en: 'Operators are special symbols that perform specific mathematical, logical,
    or relational computations on variables of different types. We cover the following
    three types of operators in this section:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符是执行特定数学、逻辑或关系计算的特定符号。在本节中，我们涵盖了以下三种类型的运算符：
- en: Arithmetic operators
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术运算符
- en: Logical operators
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: Comparison operators
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较运算符
- en: While we don’t cover all corner cases and permutations of types, we’d like to
    focus on a few operators that might be interesting in the network automation context.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们没有涵盖所有角落案例和类型的排列组合，但我们想关注一些在网络自动化环境中可能有趣的运算符。
- en: Arithmetic operators
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术运算符
- en: 'These operators perform mathematical calculations with numeric values. The
    resulting value depends on the order and type of the operands:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符使用数值执行数学计算。结果值取决于操作数的顺序和类型：
- en: '![Table 3.3 – Arithmetic operators ](img/Figure_3.5.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![表3.3 – 算术运算符](img/Figure_3.5.jpg)'
- en: Table 3.3 – Arithmetic operators
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.3 – 算术运算符
- en: 'They follow the standard mathematical logic implemented in most programming
    languages:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 它们遵循大多数编程语言中实现的标准化数学逻辑：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Strings are the only non-numeric type that can make use of an arithmetic operator.
    You can use `+` for string concatenation, to link together two or more text strings
    into one string:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是唯一可以使用的算术运算符的非数值类型。您可以使用`+`进行字符串连接，将两个或多个文本字符串链接成一个字符串：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: One of the most interesting applications of arithmetic operations is interacting
    with binary data, something that many network engineers are familiar with.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算的一个最有趣的应用是与二进制数据交互，这是许多网络工程师所熟悉的。
- en: Network protocols have deterministic structures expressed in a set of headers
    that contain forwarding information and facts of the encapsulated payload.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 网络协议具有确定的结构，这些结构以一组头部形式表达，包含转发信息和封装有效载荷的事实。
- en: You can use the arithmetic operators bit shift and bitwise (`OR`, `AND`, and
    `XOR`) to create or extract data from network headers.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用算术运算符位移和位运算（`OR`、`AND`和`XOR`）从网络头部创建或提取数据。
- en: 'To see this in action, let’s work with a 20-byte long **Transmission Control
    Protocol** (**TCP**) header that has the following information:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这个功能在实际中的应用，让我们处理一个20字节长的**传输控制协议**（**TCP**）头部，它包含以下信息：
- en: Source port address – 2 bytes
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源端口地址 – 2字节
- en: Destination port address – 2 bytes
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标端口地址 – 2字节
- en: Sequence number – 4 bytes
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列号 – 4字节
- en: Acknowledgment number – 4 bytes
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认号 – 4字节
- en: Header length and reserved – 1 byte
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头部长度和保留位 – 1字节
- en: 'Control flags – 1 byte:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制标志 – 1字节：
- en: '`CWR`: **Congestion Window** **Reduced** flag'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CWR`：**拥塞窗口** **减少**标志'
- en: '`ECE`: **Explicit Congestion Notification** (**ECN**)-echo flag'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ECE`：**显式拥塞通知**（**ECN**）-回声标志'
- en: '`URG`: Urgent pointer'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URG`：紧急指针'
- en: '`ACK`: Acknowledgment number is valid'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACK`: 确认号有效'
- en: '`PSH`: Request for push'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PSH`: 请求推送'
- en: '`RST`: Reset the connection'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RST`: 重置连接'
- en: '`SYN`: Synchronize sequence numbers'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SYN`: 同步序列号'
- en: '`FIN`: Terminate the connection'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FIN`: 终止连接'
- en: Window size – 2 bytes
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗口大小 – 2 字节
- en: Checksum – 2 bytes
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 校验和 – 2 字节
- en: Urgent pointer – 2 bytes
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧急指针 – 2 字节
- en: '*Figure 3**.3* shows the TCP header structure including all the mandatory fields
    we just listed:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3**.3*展示了包括我们刚刚列出的所有必填字段的 TCP 头结构：'
- en: '![Figure 3.3 – TCP header structure](img/Figure_3.6.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – TCP 头结构](img/Figure_3.6.jpg)'
- en: Figure 3.3 – TCP header structure
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – TCP 头结构
- en: In the next code example, we build a TCP header from an empty slice of bytes.
    We write its length in the first four bits of byte 13 and then set the `SYN` flag
    in byte 14 of the TCP header.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个代码示例中，我们从空的字节切片构建一个 TCP 头。我们在字节 13 的前四个位中写入其长度，然后在 TCP 头的字节 14 中设置`SYN`标志。
- en: The header length field of the TCP header represents the number of 32-bit words
    the TCP header has. You can see it as the number of rows in it, as *Figure 3**.3*
    shows. Here, the length is five words.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 头中的头部长度字段表示 TCP 头包含的 32 位字的数量。你可以将其视为其中的行数，如*图 3**.3*所示。在这里，长度是五个字。
- en: 'The following code snippet (the full version is at `ch03/tcp-header/main.go`
    (see the *Further reading* section)) shows how to set this length on a TCP header
    using arithmetic operations:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段（完整版本在`ch03/tcp-header/main.go`中，见*进一步阅读*部分）展示了如何使用算术运算在 TCP 头上设置此长度：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Figure 3**.4* shows how the `headerWords` 8-bit unsigned integer variable,
    which is compatible with the size of a single byte, got bit-shifted left to fit
    into its appropriate positions in the header’s field.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3**.4*展示了如何将与单个字节大小兼容的`headerWords` 8位无符号整数变量左移位，以适应头字段中适当的位置。'
- en: 'The left shift operation moves the original bits, dropping the overflowing
    bits on the right and replacing the bits on the left with zeros. The bitwise `OR`
    operator combines the resulting value with the existing byte. This is a common
    pattern to make sure that none of the bits you configured before get lost since
    the bitwise `OR` operator always keeps the `1` bits if they are present in any
    of the operands:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 左移操作将原始位移动，丢弃右边的溢出位，并用零替换左边的位。按位`OR`运算符将结果值与现有字节组合。这是一个常见的模式，以确保你之前配置的任何位都不会丢失，因为按位`OR`运算符始终保留操作数中存在的`1`位：
- en: '![Figure 3.4 – Building a TCP header, part one](img/Figure_3.7.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 构建 TCP 头，第一部分](img/Figure_3.7.jpg)'
- en: Figure 3.4 – Building a TCP header, part one
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 构建 TCP 头，第一部分
- en: 'To set a flag, we can do something similar, where we set one bit and shift
    it to the left to leave it in the second position to signal `SYN`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置一个标志，我们可以做类似的事情，其中我们设置一个位并将其左移，使其位于第二个位置以表示`SYN`：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Figure 3**.5* depicts the bit operations in the preceding code example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3**.5*展示了前一个代码示例中的位操作：'
- en: '![Figure 3.5 – Building a TCP header, part two](img/Figure_3.5_NEW.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 构建 TCP 头，第二部分](img/Figure_3.5_NEW.jpg)'
- en: Figure 3.5 – Building a TCP header, part two
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 构建 TCP 头，第二部分
- en: 'Now, let’s see how the reverse process of parsing those two bytes on the receiving
    side can look:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看接收端解析这两个字节的反向过程可能是什么样的：
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This time, we’re using the opposite set of bit operations. The right shift
    moves all bits from left to right, dropping the bits on the right and adding zeros
    to the left:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们使用相反的位操作集。右移将所有位从左向右移动，丢弃右边的位，并在左边添加零：
- en: '![Figure 3.6 – Parsing a TCP header, part one](img/Figure_3.61.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 解析 TCP 头，第一部分](img/Figure_3.61.jpg)'
- en: Figure 3.6 – Parsing a TCP header, part one
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 解析 TCP 头，第一部分
- en: 'The bitwise `AND` operator has the same behavior as a network mask. It keeps
    the bits that are set to `1` and resets everything else to zero, effectively hiding
    the non-important bits. In our case, we’re using the `0x02` mask value or `0000
    0010` in binary, which hides everything else and only leaves us with the second
    bit from the right. We can then shift that bit to the right and check its value:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 按位`AND`运算符的行为与网络掩码相同。它保留设置为`1`的位，并将其他所有位重置为零，有效地隐藏了非重要位。在我们的例子中，我们使用`0x02`掩码值或二进制的`0000
    0010`，隐藏了其他所有位，只留下了从右数第二个位。然后我们可以将这个位向右移动并检查其值：
- en: '![Figure 3.7 – Parsing a TCP header, part two](img/Figure_3.71.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 解析 TCP 头，第二部分](img/Figure_3.71.jpg)'
- en: Figure 3.7 – Parsing a TCP header, part two
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 解析 TCP 头，第二部分
- en: Being able to work at the bit and byte level is a powerful programming capability.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在位和字节级别上进行工作是一种强大的编程能力。
- en: Logical operators
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: 'Logical operators are a basic set of Boolean operations that follow the rules
    of Boolean algebra — conjunction, disjunction, and negation:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符是一组基本的布尔运算，遵循布尔代数的规则——合取、析取和否定：
- en: '![Table 3.4 – Logical operators ](img/Figure_3.11.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![表3.4 – 逻辑运算符](img/Figure_3.11.jpg)'
- en: Table 3.4 – Logical operators
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.4 – 逻辑运算符
- en: There is nothing surprising in Go’s implementation of these logical operators,
    the only thing worth remembering is that there is no syntactic sugar for them,
    so the only acceptable values are `&&` for `AND` , `||` for `OR`, and `!` for
    `NOT`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go语言中实现这些逻辑运算符并没有什么令人惊讶的，唯一值得记住的是，它们没有语法糖，所以唯一可接受的是`&&`用于`AND`，`||`用于`OR`，以及`!`用于`NOT`。
- en: Comparison operators
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较运算符
- en: 'We use the equal and not equal (`==` and `!=` ) operators to compare a pair
    of comparable values and return a Boolean (`true`|`false`). You can apply greater
    than and less than operators (`<`, `<=`, `>`, and `>=`) to ordered values:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用等于和不等于（`==`和`!=`）运算符来比较一对可比较的值，并返回布尔值（`true`|`false`）。你可以将大于和小于运算符（`<`，`<=`，`>`，和`>=`）应用于有序值：
- en: '![Table 3.5 – Comparison operators ](img/Figure_3.12.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![表3.5 – 比较运算符](img/Figure_3.12.jpg)'
- en: Table 3.5 – Comparison operators
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.5 – 比较运算符
- en: 'Here’s a brief example of comparison operators in action, with their most common
    types:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个比较运算符在行动中的简要示例，以及它们最常见类型：
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding example, all statements evaluate and print `true`. You can
    find the complete list of comparable and ordered properties of other Go types,
    such as pointers, channels, and arrays, in the *Comparison operators* section
    of the Go language specification (see *Further reading*).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，所有语句都会评估并打印`true`。你可以在Go语言规范的*比较运算符*部分找到其他Go类型（如指针、通道和数组）的完整可比较和有序属性列表（见*进一步阅读*）。
- en: This concludes this introduction to the Go data types and different operators
    used to perform day-to-day operations. Now, it’s time to put together the first
    building blocks of our programs as we dive into Go’s control flow and functions.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对Go数据类型和用于执行日常操作的不同运算符的介绍。现在，随着我们深入Go的控制流和函数，是时候将我们程序的第一个构建块组合起来。
- en: Control flow
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流
- en: Control flow constructs are a key building block of any computer program, as
    they allow you to express complex behaviors with conditions and iteration. Go’s
    support for control flow reflects its minimalistic design, which is why you’d
    mostly see a couple of variations of conditional statements and one version of
    loop in the entire language specification. It may seem surprising, but this makes
    Go easier to read, as it forces the same design patterns on all programs. Let’s
    start with the simplest and the most common control flow blocks.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 控制流结构是任何计算机程序的关键构建块，因为它们允许你通过条件和迭代表达复杂的行为。Go对控制流的支持反映了其简约设计，这也是为什么在整个语言规范中你会看到条件语句的几种变体和一种循环版本。这可能会让人感到惊讶，但这也使得Go更容易阅读，因为它强制所有程序采用相同的设计模式。让我们从最简单和最常见的数据流块开始。
- en: for loops
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`for`循环'
- en: 'In its simplest form, the `for` loop allows you to iterate over a range of
    integers while doing some work in each iteration. For example, this is how you
    would print all numbers from `0` to `4`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单形式中，`for`循环允许你在每次迭代中执行一些工作的同时遍历一系列整数。例如，这是打印从`0`到`4`的所有数字的方法：
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The first line has the `init` statement, `i := 0`, the condition statement,
    `i < 5`, and the `post` (each iteration) statement, `i++`, separated by semicolons
    (`;`). The code continues to evaluate the condition statement and the post statement
    of the `for` loop until the condition is no longer `true`, that is, until `i >=`
    `5`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行包含`init`语句，`i := 0`，条件语句，`i < 5`，以及`post`（每次迭代）语句，`i++`，由分号（`;`）分隔。代码会继续评估条件语句和`for`循环的`post`语句，直到条件不再为`true`，即直到`i
    >= 5`。
- en: 'This loop type (`for`) has many variations and one of the most common ones
    is the iteration over a container type. Here are two examples:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这种循环类型（`for`）有许多变体，其中最常见的一种是遍历容器类型。以下有两个示例：
- en: 'This is an example of iterating over a slice:'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个遍历切片的示例：
- en: '[PRE36]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This is an example of iterating over a map:'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个遍历map的示例：
- en: '[PRE42]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The special `range` keyword loops through all values of a slice or a map, creating
    a copy of the current item on a new pair of key/value variables for each iteration
    (`i` and `v` in the examples). You can also use `range` to iterate over arrays
    and strings. This keyword has special behavior for channels, which we cover later
    in the *Concurrency* section.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊的`range`关键字遍历切片或映射的所有值，为每次迭代创建当前项的新键/值变量副本（在示例中为`i`和`v`）。你还可以使用`range`遍历数组和字符串。对于通道，这个关键字有特殊的行为，我们将在后面的*并发*部分介绍。
- en: 'Another common variation of this loop construct is the infinite loop. You can
    use this when you don’t know the number of iterations ahead of time, but you know
    when to stop:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这种循环结构的另一种常见变体是无限循环。当你不知道迭代次数时，可以使用它，但你知道何时停止：
- en: '[PRE52]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The key distinction here is the absence of any conditions in the loop definition,
    which is a shorthand for `true`; that is, the condition statement always evaluates
    to `true` and the loop iterates infinitely. The only way to stop this kind of
    loop is to use the `break` keyword.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键区别在于循环定义中没有任何条件，这相当于`true`的缩写；也就是说，条件语句始终评估为`true`，循环无限迭代。停止这种循环的唯一方法是使用`break`关键字。
- en: 'Go doesn’t have a `while` keyword for loops, which you can find in many other
    programming languages. But, you can make Go’s `for` loop act in the same way as
    `while`, by dropping the `init` and `post` statements as the next code example
    shows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Go没有循环的`while`关键字，这在许多其他编程语言中都可以找到。但是，你可以通过像下一个代码示例那样省略`init`和`post`语句，使Go的`for`循环表现得像`while`一样：
- en: '[PRE53]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Another special keyword worth mentioning in this context is `continue`, which
    skips the remainder of the current iteration of a loop. The following example
    prints all numbers from `0` to `4`, but only if they are even:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，另一个值得提到的特殊关键字是`continue`，它跳过循环当前迭代的剩余部分。以下示例打印从`0`到`4`的所有数字，但只有当它们是偶数时：
- en: '[PRE54]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In this example, we skip numbers that have a non-zero remainder when divided
    by two with the `if i % 2 != 0` clause. This is a conditional statement, which
    is the topic of the next section.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`if i % 2 != 0`子句跳过了除以二后余数非零的数字。这是一个条件语句，这是下一节的主题。
- en: Conditional statements
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件语句
- en: Control structures help you define the behavior or direction to follow when
    a program can follow different execution paths.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 控制结构帮助你定义程序可以遵循的不同执行路径时的行为或方向。
- en: 'Let’s start with a two-way conditional statement. We try to connect to a website
    ([https://www.tkng.io/](https://www.tkng.io/)) and then print the response we
    receive if the connection is successful, or we return the error message if the
    `HTTP GET` operation fails. If the error is not null (`err != nil`), we return.
    Otherwise (`else`), we print the information (`fmt.Printf`):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从双向条件语句开始。我们尝试连接到一个网站([https://www.tkng.io/](https://www.tkng.io/))，然后打印如果连接成功我们收到的响应，或者在`HTTP
    GET`操作失败时返回错误信息。如果错误不为空（`err != nil`），则返回。否则（`else`），我们打印信息（`fmt.Printf`）：
- en: '[PRE55]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'One way to improve the readability of the preceding example is to left-align
    the successful execution path of the program, meaning that if one of the branches
    of the `if` condition ends in a terminating statement, as in our case with `return`,
    you can drop the entire `else` clause and rewrite the code as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 提高前面示例的可读性的方法之一是将程序成功执行路径左对齐，这意味着如果`if`条件的某个分支以终止语句结束，就像我们这里的`return`一样，你可以删除整个`else`子句，并将代码重写如下：
- en: '[PRE56]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Like any typical `if`-`then`-`else` construct, Go’s conditional statements can
    encode multi-way conditions with many `if`-`else` statements. But, Go developers
    usually prefer to use a `switch` statement in this scenario, because it’s a more
    concise and readable form of the multi-stage `if`-`then`-`else`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何典型的`if`-`then`-`else`结构一样，Go的条件语句可以使用多个`if`-`else`语句编码多路条件。但是，Go开发者通常更喜欢在这种情况下使用`switch`语句，因为它是一种更简洁、更易读的多阶段`if`-`then`-`else`的形式。
- en: 'Consider the following example, which sends an `HTTP GET` request and prints
    a message based on the returned status code. The full code is at `ch03/switch/main.go`
    (see *Further reading*):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例，它发送一个`HTTP GET`请求并根据返回的状态码打印一条消息。完整的代码在`ch03/switch/main.go`中（见*进一步阅读*）：
- en: '[PRE57]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You can write this example as a chain of `if`-`then`-`else` statements as well,
    but using `switch` makes your code cleaner, and many Go developers consider it
    good practice for these situations.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将这个例子写成一系列的`if`-`then`-`else`语句，但使用`switch`可以使你的代码更简洁，许多Go开发者认为在这种情况下这是一种良好的实践。
- en: goto statements
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`goto`语句'
- en: Another way you can transfer the control from one part of a program to another
    is by using a `goto` statement.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种将控制权从程序的一个部分转移到另一个部分的方法是使用`goto`语句。
- en: You can use `goto` statements to break out of a nested or infinite loop or to
    implement logic.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`goto`语句跳出嵌套或无限循环，或者实现逻辑。
- en: 'Building upon the preceding code example, let’s see how we can use `goto` statements
    to implement various exit points from a function. You can find the full code of
    the example at `ch03/goto/main.go` (see *Further reading*):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例的基础上，让我们看看如何使用`goto`语句实现从函数中退出的各种出口点。你可以在这个示例的完整代码在`ch03/goto/main.go`中找到（见*进一步阅读*）：
- en: '[PRE58]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `goto` statements have a somewhat evil reputation in most programming languages
    because of their power to break the flow of a program, often making it harder
    to read, with many prominent computer scientists warning against their inconsiderate
    use. Still, these statements do have their place and you can find them in many
    projects and even in the Go standard library.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`goto`语句能够打破程序的流程，在大多数编程语言中，它们都有一种有点邪恶的名声，这通常会使代码更难阅读，许多著名的计算机科学家都警告不要随意使用它们。尽管如此，这些语句确实有其位置，你可以在许多项目中找到它们，甚至在Go标准库中也能找到。
- en: 'Loops, conditional statements, and things like `goto` help you define the control
    flow of your Go programs. We still haven’t covered some extra control flow constructs
    and corner cases used together with channel types. We cover them later in the
    *Concurrency* section of this chapter, but before we get there, we first need
    to talk about another important area of code organization: functions.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 循环、条件语句以及类似`goto`的东西可以帮助你定义Go程序的控制流程。我们还没有涵盖一些与通道类型一起使用的额外控制流程结构和边缘情况。我们将在本章的*并发*部分中稍后讨论它们，但在到达那里之前，我们首先需要讨论代码组织的另一个重要领域：函数。
- en: Functions
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'On the surface, a Go function is exactly the same as in any other programming
    language: a section of code designed to perform a certain task grouped into a
    reusable container. Thanks to the static nature of the language, all functions
    have a signature that defines the number and types of acceptable input arguments
    and output values.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上，Go函数与任何其他编程语言中的函数完全相同：一段代码，设计用来执行特定任务，并分组到一个可重用的容器中。由于语言的静态特性，所有函数都有一个签名，它定义了可接受输入参数的数量和类型以及输出值。
- en: 'Consider the following function (`generateName`), which generates a new name
    based on a pair of input strings (`base` and `suffix`). You can find the full
    code of the next example at `ch03/functions1/main.go` (see *Further reading*):'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下函数（`generateName`），它根据一对输入字符串（`base`和`suffix`）生成一个新名称。你可以在这个示例的完整代码在`ch03/functions1/main.go`中找到（见*进一步阅读*）：
- en: '[PRE59]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This function’s signature is `func (string, string) string`, meaning that it
    accepts two arguments of the `string` type and returns another string. You can
    assign the returned value to a variable or pass it as an argument directly to
    another function.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的签名是`func (string, string) string`，这意味着它接受两个字符串类型的参数，并返回另一个字符串。你可以将返回值赋给一个变量，或者直接将其作为参数传递给另一个函数。
- en: Go’s functions are values, which means you can pass them as an input argument
    and even return them as the output from another function.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Go的函数是值，这意味着你可以将它们作为输入参数传递，甚至可以从另一个函数中返回它们。
- en: 'To illustrate this, we define a new function named `processDevice`, which takes
    two parameters, a function with a `func (string, string) string` signature, and
    a `string`. In the body of this function, two relevant strings are in play: `base`,
    which is statically set to `device`, and `ip`, which is the string the function
    receives as the second argument:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们定义了一个名为`processDevice`的新函数，它接受两个参数，一个具有`func (string, string) string`签名的函数和一个`string`。在这个函数的主体中，有两个相关的字符串：`base`，它被静态设置为`device`，以及`ip`，它是函数接收的第二个参数：
- en: '[PRE60]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The most interesting part of this function is on the second line of its body,
    where it calls the `getName` function. This function is what `processDevice` received
    as an argument, which could be any function as long as it takes two strings as
    arguments and returns just one string. That’s the case with the `generateName`
    function we defined for an earlier example, which means we can pass `generateName`
    as an argument to `processDevice` to build a unique device name. Let’s see what
    this would look like. The code of this example is available at `ch03/functions1/main.go`
    (see *Further reading*):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数最有趣的部分是其主体中的第二行，它调用了`getName`函数。这个函数是`processDevice`接收到的参数，它可以是一个任何函数，只要它接受两个字符串作为参数并返回一个字符串。这正是我们为早期示例定义的`generateName`函数的情况，这意味着我们可以将`generateName`作为参数传递给`processDevice`来构建一个唯一的设备名称。让我们看看这将是什么样子。此示例的代码可在`ch03/functions1/main.go`中找到（参见*进一步阅读*）：
- en: '[PRE61]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The benefit of this approach is the pluggable nature of the first argument.
    If we decide at any point that another function (for example, `generateName2`)
    is a better fit because it uses a different format to join the strings or something
    else, or maybe you want to make a change to create the device names differently
    but don’t want to alter the `generateName` function in case you need to roll back
    your changes quickly, then you can use a temporary `clone` function with a different
    name where you make the adjustments.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是第一个参数的可插拔性。如果我们决定在某个时刻，另一个函数（例如`generateName2`）更适合，因为它使用不同的格式来连接字符串或其他原因，或者你可能想以不同的方式创建设备名称，但又不想修改`generateName`函数以防你需要快速回滚更改，那么你可以使用一个具有不同名称的临时`clone`函数来进行调整。
- en: Function arguments
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数参数
- en: In Go, we pass the function arguments by value, meaning that Go creates a copy
    of every input variable and passes that copy to the called function. Go saves
    the new function-scoped variables in the stack memory, as long as the compiler
    knows their lifetime and memory footprint at compile time. The stack is a very
    efficient region in memory designed to store variables that don’t need to be garbage
    collected, as it allocates or de-allocates memory automatically when the function
    returns. Memory that needs to be garbage collected goes to another location in
    memory known as the heap.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，我们通过值传递函数参数，这意味着Go会为每个输入变量创建一个副本，并将该副本传递给被调用的函数。Go将新的函数作用域变量存储在栈内存中，只要编译器在编译时知道它们的生命周期和内存占用。栈是内存中一个非常高效的区域，用于存储不需要垃圾回收的变量，因为它在函数返回时自动分配或释放内存。需要垃圾回收的内存会移动到内存中的另一个位置，称为堆。
- en: 'Consider the following example of a function attempting to mutate an input
    string. You can access the code for the next example at `ch03/functions2/main.go`
    (see *Further reading*):'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下一个尝试修改输入字符串的函数的例子。你可以在此处找到下一个示例的代码`ch03/functions2/main.go`（参见*进一步阅读*）：
- en: '[PRE62]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Since Go creates a copy of the input `Device` when passing it as a value to
    the `mutate` function, any changes that happen to that `Device` inside the body
    of this function are not visible outside of it, hence it doesn’t affect the original
    variable, `d`. That is why `d.name` prints `myname` and not `myname-suffix`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Go在将`Device`作为值传递给`mutate`函数时创建了一个副本，因此在函数体内对该`Device`所做的任何更改都不会在函数外部可见，因此它不会影响原始变量`d`。这就是为什么`d.name`打印的是`myname`而不是`myname-suffix`。
- en: 'In Go, we have two types of data we can work with: values and the memory addresses
    of those values (pointers). With this in mind, there are two ways to implement
    the desired (mutating) behavior when passing values to a function:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，我们可以使用两种类型的数据：值和这些值的内存地址（指针）。考虑到这一点，在将值传递给函数时，有两种方法可以实现所需的（修改）行为：
- en: Change the function to return the mutated value and assign it to a variable.
    Still, this does not really mutate the original value but actually generates a
    new one instead.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数修改为返回修改后的值并将其分配给一个变量。然而，这实际上并没有修改原始值，而是生成了一个新的值。
- en: 'Change the function to accept a pointer to a variable that stores a `Device`.
    This is what our program would look like in this case:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数修改为接受一个存储`Device`变量的指针。在这种情况下，我们的程序将如下所示：
- en: '[PRE63]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Pointers are a common way of sharing data across program boundaries in Go,
    such as function calls. In this case, we still pass the input argument by value
    (`&d`), but this time, the value we copy and pass is a pointer to a memory address,
    instead of the actual content of the `d` variable. Now, when you change what that
    memory address is pointing to, you are mutating the value of the original `d`
    variable:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，指针是跨程序边界共享数据的一种常见方式，例如函数调用。在这种情况下，我们仍然通过值传递输入参数（`&d`），但这次，我们复制并传递的是指向内存地址的指针，而不是
    `d` 变量的实际内容。现在，当你改变这个内存地址所指向的内容时，你正在修改原始 `d` 变量的值：
- en: '![Figure 3.8 – Values and pointers](img/Figure_3.8.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – 值和指针](img/Figure_3.8.jpg)'
- en: Figure 3.8 – Values and pointers
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 值和指针
- en: 'Go pointers are a powerful idea. The key operations you need to be aware of
    are as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的指针是一个强大的概念。你需要了解的关键操作如下：
- en: Taking an address of a variable using the `&` operator
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `&` 操作符获取变量的地址
- en: Dereferencing a pointer, that is, getting the address of the referenced value
    using the `*` operator
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解引用指针，即使用 `*` 操作符获取引用值的地址
- en: Whenever you need to change the value of a variable, or when a variable is big
    enough to make copying it inefficient, you need to make sure that you pass it
    by a pointer. This rule applies to all the primitive types — `integer`, `string`,
    `boolean`, and so on.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你需要改变一个变量的值，或者当变量足够大以至于复制它变得低效时，你需要确保通过指针传递它。这个规则适用于所有原始类型——`整数`、`字符串`、`布尔值`等等。
- en: A couple of types in Go do not hold the actual value but point to its memory
    address instead. While these are internal implementation details, it’s something
    worth keeping in mind. For example, channels and maps are two types that are actually
    pointers to internal data structures (runtime types). This means that even if
    you pass them around by value, you end up mutating the contents of the channel
    or map. The same, by the way, applies to functions.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中有一些类型并不持有实际值，而是指向它的内存地址。虽然这些都是内部实现细节，但这是值得记住的。例如，通道和映射是两种实际上是指向内部数据结构（运行时类型）的指针类型。这意味着即使你通过值传递它们，你最终也会修改通道或映射的内容。顺便说一句，这也适用于函数。
- en: 'See the following example where we pass a map (`m`) by value to a function
    (`fn`). This function adds a new key-value pair to the map, a value that the outer
    function (`main`) can access as well:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下示例，其中我们将映射（`m`）作为值传递给函数（`fn`）。这个函数向映射中添加一个新的键值对，这个值外部的函数（`main`）也可以访问：
- en: '[PRE64]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the *Go’s type system* section in this chapter, we learned that a slice is
    a type in Go that stores metadata about the underlying data along with a pointer
    to it. It may be tempting to assume that you can pass around this data type as
    a value and be able to mutate it. But, while this data structure has a pointer
    in it, you also create a copy of the rest of the metadata values (length and capacity),
    creating a disconnection between the slice in the called and calling functions.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的 *Go 的类型系统* 部分，我们了解到切片是 Go 中的一种类型，它存储有关底层数据的元数据以及指向它的指针。你可能想当然地认为你可以作为值传递这种数据类型并能够修改它。但是，尽管这个数据结构中有一个指针，你也会创建其余元数据值（长度和容量）的副本，从而在调用函数和被调用函数之间的切片之间造成断开。
- en: 'For this reason, mutations in slices may have an unpredictable result. In-place
    changes may be visible but appends may not. This is why they always recommend
    passing them as pointers to avoid subtle bugs such as the following one:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，切片中的修改可能产生不可预测的结果。就地更改可能是可见的，但追加可能不可见。这就是为什么他们总是建议传递指针以避免像以下这样的微妙错误：
- en: '[PRE65]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You can avoid this bug if you use a pointer instead, in which case, all changes
    to the underlying slice are reflected in the outer context:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用指针，就可以避免这个错误，在这种情况下，所有对底层切片的更改都会在外部上下文中反映出来：
- en: '[PRE66]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The full code for both of these examples is at `ch03/mutate-slice/main.go` (see
    *Further reading*).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个示例的完整代码在 `ch03/mutate-slice/main.go` 中（见 *进一步阅读*）。
- en: Error handling
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理
- en: In Go, errors are not exceptions that you have to handle somewhere else in the
    code. We handle them as they come along. An error might require you to immediately
    stop the execution of a program, or maybe you could continue to run the program
    and propagate the error to another part of the program or the user so they can
    make an informed decision about what to do with this error. Remember, *don’t just
    check errors, handle* *them gracefully*.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，错误不是你必须在其他代码部分处理的异常。我们按顺序处理它们。错误可能要求你立即停止程序的执行，或者你可能可以继续运行程序并将错误传播到程序的另一部分或用户，以便他们可以就如何处理此错误做出明智的决定。记住，*不要只是检查错误，要优雅地处理*
    *它们*。
- en: 'When it comes to writing functions, the rule of thumb is that if a function
    is likely to run into an error, it must return it to the caller:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到编写函数时，一个经验法则是，如果一个函数可能会遇到错误，它必须将错误返回给调用者：
- en: '[PRE67]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The error message should be meaningful and offer enough context to the user
    to be able to identify the cause of the error and the place in the code where
    it happened. It’s up to the caller of this function to decide what to do with
    this error from the following possible actions:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息应该是有意义的，并且提供足够的信息给用户，以便他们能够识别错误的起因以及它在代码中发生的位置。决定如何处理此错误的责任在于调用此函数的人，以下是一些可能的操作：
- en: Log it and continue.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录错误并继续。
- en: Ignore it.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略它。
- en: Interrupt execution and panic.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断执行并引发恐慌。
- en: Pass it up to the outer function.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其传递给外部函数。
- en: Methods
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法
- en: 'Methods are a way of adding behavior to user-defined types, which, by default,
    can only store values. If you want those types to act, you can add a special function
    that would contain the name of the associated data type (method receiver) between
    the `func` keyword and the function name, such as `GetFullName` in the next example:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是向用户定义的类型添加行为的一种方式，默认情况下，这些类型只能存储值。如果你想这些类型能够执行操作，你可以添加一个特殊函数，该函数将包含关联数据类型的名称（方法接收器），位于`func`关键字和函数名称之间，例如下一个示例中的`GetFullName`：
- en: '[PRE68]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In all aspects, methods are just like functions — they accept zero or more arguments
    and return zero or more values. The biggest difference is that methods also have
    access to their receiver and can at the very least read its fields, as you’ve
    seen in the preceding example.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有方面，方法就像函数一样——它们接受零个或多个参数，并返回零个或多个值。最大的区别是方法还可以访问它们的接收器，至少可以读取其字段，就像你在前面的示例中看到的那样。
- en: 'It’s also possible to create a method that mutates the receiving type by defining
    it on a pointer:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过在指针上定义来创建一个会修改接收类型的函数：
- en: '[PRE69]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In this case, we define the `GenerateName` method on a pointer receiver and,
    thus, can safely set, delete or change its values — all these changes are visible
    in the outer scope.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在指针接收器上定义了`GenerateName`方法，因此可以安全地设置、删除或更改其值——所有这些更改都在外部作用域中可见。
- en: The full code for the method code examples is available at `ch03/methods/main.go`
    (see *Further reading*).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 方法代码示例的完整代码可在`ch03/methods/main.go`中找到（参见*进一步阅读*）。
- en: Variadic functions
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变函数
- en: 'So far, we’ve only seen examples with functions that take a strictly pre-defined
    number of arguments. But, that’s not the only option in Go; you can actually pass
    an arbitrary number of arguments to a function as long as you meet the following
    conditions:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了使用严格预定义数量参数的函数示例。但在Go中，这并非唯一的选择；只要满足以下条件，你实际上可以向函数传递任意数量的参数：
- en: All extra arguments are of the same type.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有额外的参数都是同一类型。
- en: They are always the last arguments to a function.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们总是函数的最后一个参数。
- en: 'The function signature looks slightly different. All extra arguments are automatically
    grouped into a slice and you denote them with three dots (`...`) before their
    type:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 函数签名看起来略有不同。所有额外的参数都会自动组合成一个切片，你可以在它们类型之前用三个点（`...`）来表示：
- en: '[PRE70]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: One benefit of variadic arguments, compared to declaring them as a slice argument
    instead, is the flexibility; you don’t have to create a slice before calling a
    function, and you can completely omit any trailing arguments if they are not needed
    and still satisfy the function’s signature.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 与将它们声明为切片参数相比，可变参数的一个优点是灵活性；在调用函数之前，你不需要创建一个切片，如果不需要任何尾随参数，你也可以完全省略它们，同时仍然满足函数的签名。
- en: The full code for the variadic code example is available at `ch03/variadic/main.go`
    (see *Further reading*).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 变量参数代码示例的完整代码可在`ch03/variadic/main.go`中找到（参见*进一步阅读*）。
- en: Closures
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包
- en: Functions in Go have different properties. They are values, so a function can
    accept another one as its argument.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的函数具有不同的属性。它们是值，因此一个函数可以接受另一个函数作为其参数。
- en: Another interesting property is that when one function (outer) returns another
    function (inner), the inner function remembers and it has complete access to all
    variables that you defined in the scope of the outer function.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的属性是，当一个函数（外部）返回另一个函数（内部）时，内部函数会记住，并且它可以完全访问外部函数作用域内定义的所有变量。
- en: 'This is what’s called a `func() string` signature mutates the `i` variable
    defined in the `suffixGenerator` outer function every time it’s called:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所谓的 `func() string` 签名每次调用都会修改 `suffixGenerator` 外部函数中定义的 `i` 变量：
- en: '[PRE71]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Every time we call `suffixGenerator`, we assign a new instance of the anonymous
    function it returns to a variable. `generator1` and `generator2` are now functions
    that keep track of the number of times we call each one.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们调用 `suffixGenerator` 时，都会将外部函数返回的匿名函数的新实例分配给一个变量。`generator1` 和 `generator2`
    现在是跟踪我们调用每个函数次数的函数。
- en: Closures are a popular technique to create a surrounding context (environment).
    For example, API call functions in middleware software use closures to perform
    logging and telemetry data collection on every call, without the API caller needing
    to care about those details.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是一种流行的技术，用于创建周围的环境（环境）。例如，中间件软件中的 API 调用函数使用闭包在每次调用时执行日志记录和遥测数据收集，而无需 API
    调用者关心这些细节。
- en: Defer
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延迟
- en: When writing a program that opens remote network connections or local files,
    it’s important to promptly close these as soon as you no longer need them to prevent
    resource leaks — all operating systems have limitations on the number of open
    files or connections.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写一个打开远程网络连接或本地文件的程序时，重要的是要尽快关闭它们，以防止资源泄露 - 所有操作系统都对打开的文件或连接的数量有限制。
- en: Go’s idiomatic way of dealing with this class of problems is to address them
    as early in the code as possible with the help of the `defer` statement. You should
    place this statement right next to the `open`/`connect` function call. Go only
    evaluates this statement when the function returns.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Go 处理这类问题的惯用方法是尽可能早地使用 `defer` 语句来处理。你应该将这个语句放在 `open`/`connect` 函数调用旁边。Go 只有在函数返回时才会评估这个语句。
- en: 'In the following example, the two `defer` statements run only *after* the final
    statement of the function:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，两个 `defer` 语句仅在函数的最终语句之后运行：
- en: '[PRE72]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'You can stack together many `defer` statements to perform staged cleanup. They
    execute in last-in-first-out order – `Println("Deferred cleanup")` runs before
    `resp.Body.Close()`. This is what you see when you run this program:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将多个 `defer` 语句堆叠起来以执行分阶段的清理。它们按照后进先出的顺序执行 - `Println("Deferred cleanup")`
    在 `resp.Body.Close()` 之前运行。当你运行这个程序时，你会看到以下内容：
- en: '[PRE73]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The full code for this code example is available at `ch03/defer/main.go` (see
    *Further reading*).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码示例的完整代码可在 `ch03/defer/main.go` 中找到（参见 *进一步阅读*）。
- en: 'Now that we’ve covered the Go functions fundamentals, it’s time to move onto
    the next level of abstraction that describes object behaviors through a unique
    set of methods: interfaces.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了 Go 函数的基础知识，是时候进入下一层抽象了，它通过一组独特的方法描述对象行为：接口。
- en: Interfaces
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: Interfaces are one of the most powerful constructs in Go, so it’s very important
    to understand what they do and when you can use them. From a purely theoretical
    point of view, interfaces are an abstract type. They do not contain implementation
    details but define a set of behaviors through method signatures.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是 Go 中最强大的构造之一，因此理解它们的作用以及何时可以使用它们非常重要。从纯粹理论的角度来看，接口是一种抽象类型。它们不包含实现细节，但通过方法签名定义了一组行为。
- en: If a Go type defines all method signatures declared by an interface, this Go
    type *implements* that interface implicitly, with no explicit declaration. This
    is how Go deals with common behaviors exhibited by more than one type, and what
    other languages often express through object inheritance.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个 Go 类型定义了一个接口中声明的所有方法签名，那么这个 Go 类型就隐式地实现了该接口，而不需要显式声明。这是 Go 处理多个类型所表现出的常见行为的方式，而其他语言通常通过对象继承来表达这一点。
- en: Network automation example
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络自动化示例
- en: 'To introduce the idea, we use a contrived network automation example. Let’s
    say we are developing a Go package to deal with common tasks across different
    network devices. We model a Cisco IOS XE device as a `CiscoIOS` type with two
    fields — one that identifies the hostname of a device (`Hostname`) and another
    that identifies the underlying hardware platform (`Platform`). For this `CiscoIOS`
    type, we define a method that gets us the uptime of a device (`getUptime`) as
    an integer. Finally, we define a function to compare two devices and find out
    which one has been running longer without a reboot:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 为了引入这个想法，我们使用了一个虚构的网络自动化示例。假设我们正在开发一个 Go 包来处理不同网络设备的常见任务。我们将 Cisco IOS XE 设备建模为一个
    `CiscoIOS` 类型，它有两个字段——一个用于标识设备的主机名（`Hostname`），另一个用于标识底层硬件平台（`Platform`）。对于这个
    `CiscoIOS` 类型，我们定义了一个方法来获取设备的运行时间（`getUptime`）作为整数。最后，我们定义了一个函数来比较两个设备，找出哪个设备在没有重启的情况下运行时间更长：
- en: '[PRE74]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Everything works fine until we add another platform to the mix. Let’s say we
    now also have a `CiscoNXOS` type and it has `Hostname` and `Platform` fields,
    but it also has a Boolean `ACI` field to show whether this switch is ACI-enabled.
    As with the `CiscoIOS` type, we define a method that returns the uptime of a `CiscoNXOS`
    device:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都运行得很好，直到我们添加了另一个平台。假设我们现在还有一个 `CiscoNXOS` 类型，它有 `Hostname` 和 `Platform` 字段，但它还有一个布尔值
    `ACI` 字段来显示这个交换机是否启用了 ACI。与 `CiscoIOS` 类型一样，我们定义了一个返回 `CiscoNXOS` 设备运行时间的方法：
- en: '[PRE75]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The challenge now is to compare the uptime of a `CiscoNXOS` device type with
    the uptime of a `CiscoIOS` device type. The `LastToReboot` function signature
    tells us it only accepts variables of a `CiscoIOS` type as an argument, so we
    cannot pass an element of a `CiscoNXOS` type to it.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的挑战是比较 `CiscoNXOS` 设备类型和 `CiscoIOS` 设备类型的运行时间。`LastToReboot` 函数签名告诉我们它只接受
    `CiscoIOS` 类型的变量作为参数，因此我们不能将 `CiscoNXOS` 类型的元素传递给它。
- en: 'You can fix this by creating an interface. By doing this, you abstract away
    the implementation details of the device and only focus on the need to present
    the device uptime as an integer via the `getUptime` function. Let’s call this
    interface `NetworkDevice`:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过创建一个接口来解决这个问题。通过这样做，你抽象出了设备的实现细节，只关注通过 `getUptime` 函数将设备运行时间作为整数呈现的需求。让我们称这个接口为
    `NetworkDevice`：
- en: '[PRE76]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The next step is to change the `LastToReboot` function to accept a `NetworkDevice`
    type instead of `CiscoIOS`, as in the next code snippet:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将 `LastToReboot` 函数更改为接受 `NetworkDevice` 类型而不是 `CiscoIOS`，如下代码片段所示：
- en: '[PRE77]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Because both `CiscoIOS` and `CiscoNXOS` have a `getUptime() int` method, they
    implicitly satisfy the `NetworkDevice` interface, hence you can pass either one
    of them as a parameter to the `LastToReboot` function. A **sample program** (see
    *Further reading*) that uses these definitions to compare the uptime of these
    two device types would look as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `CiscoIOS` 和 `CiscoNXOS` 都有一个 `getUptime() int` 方法，它们隐式地满足 `NetworkDevice`
    接口，因此你可以将它们中的任何一个作为参数传递给 `LastToReboot` 函数。一个使用这些定义来比较这两种设备类型运行时间的**示例程序**（见*进一步阅读*）如下所示：
- en: '[PRE78]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Interfaces can help you scale your programs. The interface `NetworkDevice` enables
    us to add any number of device types. It’s not only a great resource for good
    code design but also to set clear expectations of what the data should do in an
    API, regardless of what the data is. In the example, we don’t care what operating
    system the device is running, only that we have a method available to get its
    uptime as an integer.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 接口可以帮助你扩展你的程序。`NetworkDevice` 接口使我们能够添加任何数量的设备类型。它不仅是一个优秀的代码设计资源，而且可以明确地设定在
    API 中数据应该做什么，无论数据是什么。在示例中，我们不在乎设备运行的是哪种操作系统，只关心我们有一个方法可以获取其作为整数的运行时间。
- en: Standard library example
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准库示例
- en: 'For a more real-world example, let’s turn our attention to the `net` package
    in the standard library, which has an interface that represents a network connection
    (`Conn`). Interface fields are often verbs that describe behavior and not state
    (for example, `SetDeadline` for the `Conn` interface). By contrast, a more descriptive
    name for the `RemoteAddr` method might have been `getRemoteAddr`:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更贴近现实世界的例子，让我们将注意力转向标准库中的 `net` 包，它有一个表示网络连接（`Conn`）的接口。接口字段通常是描述行为的动词，而不是状态（例如，`Conn`
    接口的 `SetDeadline`）。相比之下，`RemoteAddr` 方法的更具描述性的名称可能是 `getRemoteAddr`：
- en: '[PRE79]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The standard library includes several implementations of this interface. One
    of them is in the `crypto/ssh` library, through the `chanConn` concrete type.
    A concrete type is any non-interface type that stores its own data and, in this
    case, `chanConn` stores values for local (`laddr`) and remote (`raddr`) addresses
    of a **Secure Shell Protocol** (**SSH**) connection.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库包括此接口的几个实现。其中之一是在 `crypto/ssh` 库中，通过 `chanConn` 具体类型。具体类型是任何非接口类型，它存储自己的数据，在这种情况下，`chanConn`
    存储了 **Secure Shell Protocol** （**SSH**）连接的本地（`laddr`）和远程（`raddr`）地址。
- en: 'This type also defines methods, such as `LocalAddr() net.Addr` and `SetReadDeadline(deadline
    time.Time) error`. In fact, it has all methods of the `net.Conn` interface, hence
    it satisfies the interface:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 此类型还定义了方法，例如 `LocalAddr() net.Addr` 和 `SetReadDeadline(deadline time.Time) error`。实际上，它具有
    `net.Conn` 接口的所有方法，因此它满足接口：
- en: '[PRE80]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, any function that accepts `net.Conn` as input can take `chanConn` as well.
    Or vice versa, if a function returns `net.Conn`, it can also return `chanConn`,
    as in the next example from the same source code file:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何接受 `net.Conn` 作为输入的函数也可以接受 `chanConn`。反之亦然，如果一个函数返回 `net.Conn`，它也可以返回 `chanConn`，就像下面这个来自同一源代码文件的例子：
- en: '[PRE81]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Don’t worry if these code snippets look daunting to you. These come from the
    actual SSH package of the Go standard library, so this is as complex as it gets.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些代码片段看起来令你感到困惑，请不要担心。这些来自 Go 标准库的实际 SSH 包，所以这是最复杂的部分。
- en: Interfaces as contracts
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口作为合同
- en: Interfaces are a valueless type; they only define method signatures. You can
    define a variable of an interface type, but you can only assign a concrete implementation
    of this interface as the value of this variable.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是一种无值的类型；它们只定义方法签名。你可以定义一个接口类型的变量，但你只能将这个接口的具体实现作为这个变量的值赋值。
- en: In the next code example, the `r` variable is of the `io.Reader` type, which
    is an interface. At that point, we know nothing about this variable but we do
    know that whatever value we assign to this variable must satisfy the `io.Reader`
    interface in order for the compiler to accept it.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个代码示例中，`r` 变量是 `io.Reader` 类型，这是一个接口。在那个时刻，我们对此变量一无所知，但我们知道，无论我们给这个变量赋什么值，都必须满足
    `io.Reader` 接口，以便编译器接受它。
- en: 'In this case, we’re using `strings.NewReader("text")`, which implements the
    `io.Reader` interface to read from a `string` value that gets passed as an argument:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用 `strings.NewReader("text")`，它实现了 `io.Reader` 接口，用于从作为参数传递的 `string`
    值中读取：
- en: '[PRE82]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The last line of code copies what we read to standard output (`Stdout`) or the
    user’s screen. The `io.Copy` function copies from `io.Reader` (`r`) to `io.Writer`
    (`os.Stdout` satisfies this interface), so we can copy from the string to the
    terminal.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后一行将读取的内容复制到标准输出（`Stdout`）或用户的屏幕上。`io.Copy` 函数从 `io.Reader` （`r`）复制到 `io.Writer`
    （`os.Stdout` 满足此接口），因此我们可以从字符串复制到终端。
- en: While this looks a bit more complicated than just printing the string with `fmt.Println`,
    interfaces make our code more versatile, allowing you to replace either the source
    or destination of the data in the example without too much effort. This is possible
    because the `io.Reader` and `io.Writer` interfaces serve as a contract between
    both the `io.Copy()` consumer and the `strings.NewReader` and `os.Stdout` providers,
    ensuring they both conform to the rules defined by this interface.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来比只用 `fmt.Println` 打印字符串要复杂一些，但接口使我们的代码更加灵活，允许你在不费太多力气的情况下替换示例中的数据源或目的地。这是因为
    `io.Reader` 和 `io.Writer` 接口作为 `io.Copy()` 消费者和 `strings.NewReader` 以及 `os.Stdout`
    提供者之间的合同，确保它们都符合此接口定义的规则。
- en: Interfaces allow you to define a clear division between different modules of
    a program and offer an API where users can define the implementation details.
    In the next section, we examine in detail the `io.Reader` and `io.Writer` interfaces
    and their role in **input/output** (**I/O**) operations.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 接口允许你定义程序不同模块之间的清晰划分，并提供一个用户可以定义实现细节的 API。在下一节中，我们将详细探讨 `io.Reader` 和 `io.Writer`
    接口及其在 **输入/输出** （**I/O**）操作中的作用。
- en: Input and output operations
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入和输出操作
- en: A common operation in a program is to move data around and reformat it. For
    example, you can open a file, load its content in memory, encode it to a different
    format, maybe `jpeg`, and then write it to a file on the disk. This is where the
    `io.Reader` and `io.Writer` interfaces play a key role in Go’s I/O model, as they
    allow you to stream data from a source to a destination via a transfer buffer.
    This means you don’t need to load the entire file in memory to encode it and write
    it to the destination, making the process more efficient.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中，移动数据并重新格式化数据是一个常见的操作。例如，您可以打开一个文件，将其内容加载到内存中，将其编码为不同的格式，比如`jpeg`，然后将其写入磁盘上的文件。这就是`io.Reader`和`io.Writer`接口在Go的I/O模型中扮演关键角色的地方，因为它们允许您通过传输缓冲区将数据从源流式传输到目的地。这意味着您不需要将整个文件加载到内存中，以便对其进行编码并将其写入目的地，这使得整个过程更高效。
- en: The io.Reader interface
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: io.Reader接口
- en: 'The `io` package in the standard library defines one of the most popular interfaces
    in Go, the `io.Reader` interface, which can read a stream of bytes (`p`). It returns
    the number of bytes read (`n`) and any error encountered (`err`):'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的`io`包定义了Go中最受欢迎的接口之一，即`io.Reader`接口，它可以读取一个字节流（`p`）。它返回读取的字节数（`n`）和遇到的任何错误（`err`）：
- en: '[PRE83]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Any concrete type that has a `Read` with this signature implements the `io.Reader`
    interface. You don’t need to do anything else:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有此签名的`Read`方法的具体类型都实现了`io.Reader`接口。您不需要做任何事情：
- en: '![Figure 3.9 – The io.Reader interface](img/Figure_3.9.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![图3.9 – io.Reader接口](img/Figure_3.9.jpg)'
- en: Figure 3.9 – The io.Reader interface
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – io.Reader接口
- en: 'The `strings.Reader` type (in the `strings` package of the standard library)
    has a method with the `Read(p []byte) (n int, err error)` signature, hence it
    satisfies the `io.Reader` interface. The `strings` package also provides a convenient
    `NewReader` function that returns a pointer to a new instance of the `strings.Reader`
    type. The following is an actual snippet from the `strings` package source code:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`strings.Reader`类型（在标准库的`strings`包中）有一个具有`Read(p []byte) (n int, err error)`签名的`Read`方法，因此它满足`io.Reader`接口。`strings`包还提供了一个方便的`NewReader`函数，返回指向新`strings.Reader`实例的指针。以下是从`strings`包源代码的实际代码片段：'
- en: '[PRE84]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The preceding code also shows a concrete `Reader` implementation (with data
    fields) that has a `Read` method.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码还显示了一个具有`Read`方法的实际`Reader`实现（具有数据字段）。
- en: The io.Writer interface
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: io.Writer接口
- en: 'The `io` package also specifies the `io.Reader` interface, which can write
    `len(p)` bytes to the underlying data stream. It returns the number of bytes written
    (`n`) and any error encountered that caused the write to stop early (`err`):'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`io`包还指定了`io.Reader`接口，可以将`len(p)`个字节写入底层数据流。它返回写入的字节数（`n`）以及任何导致写入提前停止的错误（`err`）：'
- en: '[PRE85]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Any concrete type that has a `Write` method with this signature implements
    the `io.Writer` interface:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有此签名的`Write`方法的具体类型都实现了`io.Writer`接口：
- en: '![Figure 3.10 – The io.Writer interface](img/Figure_3.10.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![图3.10 – io.Writer接口](img/Figure_3.10.jpg)'
- en: Figure 3.10 – The io.Writer interface
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – io.Writer接口
- en: 'One example is `os.File` in the `os` package of the standard library. It has
    a method with the `Write(p []byte) (n int, err error)` signature, hence it satisfies
    the `io.Writer` interface:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是标准库`os`包中的`os.File`。它有一个具有`Write(p []byte) (n int, err error)`签名的`Write`方法，因此它满足`io.Writer`接口：
- en: '[PRE86]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The `os` package also offers a convenient `Create` function that returns a pointer
    to an `os.File` from a file location. The preceding is an actual snippet from
    the `os` package source code.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`os`包还提供了一个方便的`Create`函数，可以从文件位置返回一个指向`os.File`的指针。前面的代码片段来自`os`包的源代码。'
- en: The io.Copy function
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: io.Copy函数
- en: 'The `io.Copy` function allows you to copy data from a source to a destination,
    as we discussed at the end of the *Interfaces* section. Even though you pass concrete
    type data to this function, `io.Copy` actually doesn’t care what the data is,
    as it takes interface types as an argument, so it’s interested in what the data
    can do instead. It needs a readable source and a writable destination:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.Copy`函数允许您从源复制数据到目的地，正如我们在*接口*部分结束时讨论的那样。尽管您向此函数传递具体类型的数据，但`io.Copy`实际上并不关心数据是什么，因为它接受接口类型作为参数，因此它对数据能做什么更感兴趣。它需要一个可读的源和一个可写的目的地：'
- en: '[PRE87]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'As *Figure 3**.11* shows, `io.Copy` uses a 32 KB transfer buffer to stream
    the data from the source to the destination:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图3**.11*所示，`io.Copy`使用32 KB传输缓冲区从源流式传输数据到目的地：
- en: '![Figure 3.11 – The io.Copy function](img/Figure_3.111.jpg)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11 – io.Copy函数](img/Figure_3.111.jpg)'
- en: Figure 3.11 – The io.Copy function
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – io.Copy 函数
- en: 'Let’s test this. We can get an `io.Reader` from a string built with `strings.NewReader`,
    and `os.Create` gives us an `io.Writer`, which writes to a file on the disk. You
    can follow along with the code at `ch03/io-interface1/main.go` (see *Further reading*):'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下。我们可以从使用 `strings.NewReader` 构建的字符串中获取一个 `io.Reader`，而 `os.Create` 给我们一个
    `io.Writer`，它将数据写入磁盘上的文件。你可以通过查看 `ch03/io-interface1/main.go`（见 *进一步阅读*）中的代码来跟进：
- en: '[PRE88]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'While, in this case, we select a string and a file combination, you can use
    the same `io.Copy` function to read from the network and print to the terminal,
    for example. For now, let’s inspect the file we just produced:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 而在这个例子中，我们选择了一个字符串和一个文件组合，你可以使用相同的 `io.Copy` 函数从网络读取并打印到终端，例如。现在，让我们检查我们刚刚生成的文件：
- en: '[PRE89]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Let’s examine a network-related example. The `net/http` package has the `Get`
    function that takes a URL (`string`) and returns a pointer to a `http.Response`,
    which has a field (`Body`) that satisfies the `io.Reader` interface, and the `os.Stdout`
    terminal satisfies the `io.Writer` interface. This gives us another combination
    to try out. Let’s see it in action. The code is very close to what we ran before,
    and is available at `ch03/io-interface2/main.go` (see *Further reading*):'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察一个与网络相关的例子。`net/http` 包中的 `Get` 函数接受一个 URL（`string`）并返回一个指向 `http.Response`
    的指针，该指针有一个满足 `io.Reader` 接口的字段（`Body`），而 `os.Stdout` 终端满足 `io.Writer` 接口。这为我们提供了另一个尝试的组合。让我们看看它的实际效果。代码与我们之前运行的很相似，可以在
    `ch03/io-interface2/main.go`（见 *进一步阅读*）中找到：
- en: '[PRE90]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The same `io.Copy` function now allows us to take the content from a URL and
    print it to the terminal:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 现在相同的 `io.Copy` 函数允许我们从 URL 中获取内容并将其打印到终端：
- en: '[PRE91]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: With `io.Copy`, we move data from one point to another. Now, we need to add
    another piece to the puzzle to transform the data as we stream it.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `io.Copy`，我们将数据从一个点移动到另一个点。现在，我们需要添加另一个拼图块来在流式传输数据时转换数据。
- en: Composition
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合
- en: One way to transform the data as we stream it is by embedding one struct type
    into another, which we know as `io.Reader` or `io.Writer` interfaces to perform
    one or more operations and not just copy the data from source to destination.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在流式传输数据时转换数据的一种方法是将一个结构体类型嵌入到另一个结构体类型中，我们称之为 `io.Reader` 或 `io.Writer` 接口，以执行一个或多个操作，而不仅仅是将数据从源复制到目的地。
- en: 'The benefit of following this pattern is to write reusable segments of code,
    which you can use for any `io.Reader` or `io.Writer` interface in this case. Let’s
    look at the example at `ch03/reader/main.go` (see *Further reading*):'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随这种模式的优点是编写可重用的代码段，在这种情况下，你可以将其用于任何 `io.Reader` 或 `io.Writer` 接口。让我们看看 `ch03/reader/main.go`（见
    *进一步阅读*）中的示例：
- en: '[PRE92]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: We define a new `myReader` type with a single `src` field of the `io.Reader`
    type. In Go, when we embed a type, the methods of that type become methods of
    the outer type, so `myReader` has a `Read` method from `src` now.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个新的 `myReader` 类型，它有一个 `io.Reader` 类型的单个 `src` 字段。在 Go 中，当我们嵌入一个类型时，该类型的所有方法都成为外部类型的方法，因此
    `myReader` 现在有一个来自 `src` 的 `Read` 方法。
- en: But, we want to change the behavior and do something with the data. Hence, we
    define a new `Read` method that takes precedence over any other more deeply nested
    method part of the type.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们想要改变行为并对数据进行一些操作。因此，我们定义了一个新的 `Read` 方法，它优先于类型中任何更深嵌套的其他方法。
- en: 'In this `Read` method, we read from the buffer and convert it to title case
    with `bytes.Title`, assuming we are working with strings. Last but not least,
    `NewMyReader` is what glues together an existing reader with this new one, connecting
    the dots between two pieces of code. Let’s see it in action:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `Read` 方法中，我们从缓冲区读取并使用 `bytes.Title` 将其转换为标题大小写，假设我们正在处理字符串。最后但同样重要的是，`NewMyReader`
    是将现有读取器与这个新读取器粘合在一起的东西，连接了两段代码之间的点。让我们看看它的实际效果：
- en: '[PRE93]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We create a reader from a string in `r1` and then use that as the input for
    `myReader` in `r2`:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从字符串创建一个读取器 `r1`，然后将其用作 `r2` 中 `myReader` 的输入：
- en: '[PRE94]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: When we now copy from `r2` to `os.Stdout`, we read from the string and also
    change the content to title case before writing it to the terminal.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在从 `r2` 复制到 `os.Stdout` 时，我们不仅从字符串中读取，还在将其写入终端之前将内容转换为标题大小写。
- en: Input and output primitives are present in almost every Go library. The next
    section is no exception. Encoding and decoding in Go take full advantage of the
    `io.Reader` and `io.Writer` interfaces.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个 Go 库都包含输入和输出原语。下一节也不例外。在 Go 中，编码和解码充分利用了 `io.Reader` 和 `io.Writer` 接口。
- en: Decoding and encoding
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码和编码
- en: One of the most common network automation tasks is the ingesting and processing
    of structured data. You can retrieve data from or send it to a remote location
    or even store it on a local disk. Regardless of its location, you have to convert
    this data into an appropriate format. Encoding, or marshaling, is the process
    of transforming bytes from a Go data structure into a structured textual representation.
    Decoding, or unmarshalling, is the reverse process of populating Go values with
    externally sourced data.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 网络自动化中最常见的任务之一是结构化数据的摄取和处理。您可以从中检索数据或发送到远程位置，甚至将其存储在本地磁盘上。无论其位置如何，您都必须将其转换为适当的格式。编码，或称为序列化，是将Go数据结构中的字节转换为结构化文本表示的过程。解码，或称为反序列化，是从外部数据源填充Go值的过程的反向操作。
- en: Some examples of structured data encoding schemes are YAML, JSON, XML, and Protocol
    Buffers. Go’s standard library includes packages that implement encoding and decoding
    for most of these popular formats, and they all leverage the `io.Reader` and `io.Writer`
    interface primitives that we learned about in the last section.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 一些结构化数据编码方案的示例包括YAML、JSON、XML和Protocol Buffers。Go的标准库包括实现这些流行格式编码和解码的包，并且它们都利用了我们上节中了解到的`io.Reader`和`io.Writer`接口原语。
- en: 'In this section, we go through how Go deals with the following tasks:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍Go如何处理以下任务：
- en: Using tags to annotate Go structs to help libraries encode and decode structured
    data
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标签注释Go结构体以帮助库编码和解码结构化数据
- en: Parsing of structured data using the empty interface
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用空接口解析结构化数据
- en: Performing deeply nested set and lookup operations using third-party libraries
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用第三方库执行深度嵌套的集合和查找操作
- en: Decoding
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解码
- en: We start our overview with decoding, as this is usually one of the first steps
    in a network automation pipeline. Let’s assume that we’re building a program that
    needs to interact with various remote network devices. We store the information
    of these devices in an inventory file we save on a local disk.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从解码开始概述，因为这在网络自动化流程中通常是第一步之一。假设我们正在构建一个需要与各种远程网络设备交互的程序。我们将这些设备的信息存储在一个本地磁盘上保存的清单文件中。
- en: Decoding JSON
  id: totrans-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解码JSON
- en: 'In the first example, we see how to deal with a JSON inventory (`input.json`).
    All outputs of this part are available in the `ch03/json` folder of the book’s
    repository (see *Further reading*):'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，我们看到如何处理JSON清单（`input.json`）。本部分的全部输出都可在本书仓库的`ch03/json`文件夹中找到（见*进一步阅读*）：
- en: '[PRE95]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'In the first code example in `ch03/json/main.go` (see *Further reading*), we
    define a couple of Go structs that can hold the JSON input data from the preceding
    output in memory. We call the first type `Router`, which has `Hostname`, `IP`,
    and `ASN` fields. The other type is `Inventory`, which stores a list of routers.
    The fields in the `Router` type have optional tags such as `json:"key"` to denote
    alternative key names in the original JSON structure:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ch03/json/main.go`的第一个代码示例中（见*进一步阅读*），我们定义了几个Go结构体，可以在内存中保存前面输出中的JSON输入数据。我们称第一个类型为`Router`，它具有`Hostname`、`IP`和`ASN`字段。另一个类型是`Inventory`，它存储了一组路由器。`Router`类型中的字段具有可选的标签，如`json:"key"`，以表示原始JSON结构中的替代键名：
- en: '[PRE96]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'To read from a file, we create an `io.Reader` type (`file`) from the input
    file with `os.Open`:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 要从文件中读取，我们使用`os.Open`从输入文件创建一个`io.Reader`类型（`file`）：
- en: '[PRE97]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Now, the `json` library, as well as any other encoding library, has a function
    that allows you to pass an `io.Reader` type as an argument to extract data from
    it. This means it can decode from a file, a string, a network connection, or anything
    else that implements the `io.Reader` interface with the same function call:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`json`库以及任何其他编码库都有一个函数，允许您将`io.Reader`类型作为参数传递以从中提取数据。这意味着它可以从文件、字符串、网络连接或任何其他实现`io.Reader`接口的东西中解码。
- en: '[PRE98]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Once you’ve created a decoder, you can use the `Decode` method to read and
    parse the contents of the JSON file into a variable (`inv`) of the `Inventory`
    type. Remember, to mutate the data struct, you need to pass it as a pointer:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了解码器，您就可以使用`Decode`方法将JSON文件的内容读取并解析到`Inventory`类型的变量（`inv`）中。记住，要修改数据结构，您需要将其作为指针传递：
- en: '[PRE99]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'If you print the `inv` variable now, you would see it populate with data from
    the inventory JSON file:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在打印`inv`变量，您会看到它填充了来自清单JSON文件的数据：
- en: '[PRE100]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Decoding into an empty interface
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解码到空接口
- en: The field tags we’ve just seen are a very convenient way to map data during
    encoding and decoding. The condition to have all Go types predefined ahead of
    time offers type safety, but at the same time, you can see it as a major detractor
    if you are coming from another language where the decoding process does not need
    this.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才看到的字段标签是在编码和解码过程中映射数据的一种非常方便的方式。在编码前预先定义所有 Go 类型的条件提供了类型安全，但与此同时，如果你来自另一种语言，其中解码过程不需要这种类型安全，那么这也可以看作是一个主要的缺点。
- en: 'But, you can also skip this in Go, with a few caveats that we discuss later.
    To show you how it works, we use a slightly different version of an earlier example.
    This new version is available in the `ch03/json-interface` folder (see *Further
    reading*). Instead of defining all Go structs, we use a special variable of the
    `map[string]interface{}` type and pass it as an argument to the `Decode` method
    call:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在 Go 中，你也可以跳过这一步，但有一些我们在后面会讨论的注意事项。为了展示它是如何工作的，我们使用一个稍早的例子的一个不同版本。这个新版本可以在
    `ch03/json-interface` 文件夹中找到（见 *进一步阅读*）。我们不是定义所有的 Go 结构体，而是使用一个特殊的 `map[string]interface{}`
    类型的变量，并将其作为参数传递给 `Decode` 方法调用：
- en: '[PRE101]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: An *empty interface*, or `interface{}`, doesn’t define any methods, which means
    it can hold any value — `integer`, `string`, `float`, or user-defined. The only
    caveat is that, since Go is a statically typed language, those values remain an
    empty interface until we do an explicit type conversion, that is, until we tell
    Go what type we expect to see.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *空接口*，或 `interface{}`，没有定义任何方法，这意味着它可以持有任何值——`整数`、`字符串`、`浮点`或用户定义的。唯一的缺点是，由于
    Go 是一种静态类型语言，这些值在执行显式类型转换之前仍然是空接口，也就是说，直到我们告诉 Go 我们期望看到什么类型。
- en: 'From the output of the empty variable of the `map[string]interface{}` type,
    where we decoded the JSON content in the preceding example, we see that the value
    of the map we print is an array. To parse these values and print them individually,
    we’d have to tell Go to treat them as a slice of unknown values, which you can
    express as `[]interface{}`:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们之前示例中解码的 JSON 内容的 `map[string]interface{}` 类型的空变量的输出中，我们看到我们打印的映射值是一个数组。为了解析这些值并单独打印它们，我们必须告诉
    Go 将它们视为未知值的切片，这可以表示为 `[]interface{}`：
- en: '[PRE102]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The output of these print statements is the string representation of two `map[string]interface{}`
    maps, which means we’ve only parsed the keys (as strings), but the values are
    still undefined:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 这些打印语句的输出是两个 `map[string]interface{}` 映射的字符串表示形式，这意味着我们只解析了键（作为字符串），但值仍然是未定义的：
- en: '[PRE103]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: We could continue this process until we find the right type for all values of
    this object, but this process is obviously quite tedious. This is why we mainly
    see this approach in encoding libraries or as a troubleshooting step to take a
    quick glance at the structure of the potentially unknown input data.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以继续这个过程，直到我们找到这个对象所有值的正确类型，但这个过程显然相当繁琐。这就是为什么我们主要在编码库中看到这种方法，或者作为快速检查潜在未知输入数据结构的故障排除步骤。 '
- en: Another option for quick operations with JSON data is external Go packages,
    which you can use to perform deep JSON lookup (**GJSON**) and set (**SJSON**)
    operations without having to build structs for the entire object. In both cases,
    the parsing still happens behind the scenes, but the user is only presented with
    their data or an error if the key doesn’t exist. We use GJSON (see *Further reading*)
    in a gRPC example in [*Chapter 8*](B16971_08.xhtml#_idTextAnchor182), *Network
    APIs*.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 JSON 数据的快速操作，另一个选项是外部 Go 包，你可以使用这些包来执行深度 JSON 查找（**GJSON**）和设置（**SJSON**）操作，而无需为整个对象构建结构体。在两种情况下，解析仍然在幕后进行，但用户只看到他们的数据或错误，如果键不存在。我们在
    *第 8 章* 的 gRPC 示例中使用了 GJSON（见 *进一步阅读*），*网络 API*。
- en: Decoding XML
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解码 XML
- en: 'While the XML input file looks different, the data is the same and the Go program
    doesn’t change much. The next example is in the `ch03/xml` folder of the book’s
    repository (see *Further reading*):'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 XML 输入文件看起来不同，但数据是相同的，Go 程序变化不大。下一个例子在书的存储库的 `ch03/xml` 文件夹中（见 *进一步阅读*）：
- en: '[PRE104]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'If we compared the final program with the one we did for JSON, we would notice
    four changes:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将最终的程序与我们为 JSON 所做的程序进行比较，我们会注意到四个变化：
- en: We import `encoding/xml` instead of `encoding/json`.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们导入 `encoding/xml` 而不是 `encoding/json`。
- en: We use XML tags `xml:"hostname"` instead of the JSON equivalents for struct
    fields.
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 XML 标签 `xml:"hostname"` 而不是结构体字段的 JSON 等效项。
- en: The input file is a `.``xml` file.
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入文件是一个 `.xml` 文件。
- en: We use the `NewDecoder` function from the `xml` library instead.
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用来自 `xml` 库的 `NewDecoder` 函数。
- en: 'The rest of the code remains exactly the same. The next code output highlights
    the actual lines that change; we omitted the rest of the lines as they are the
    same as in the JSON example:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其他部分保持完全不变。接下来的代码输出突出显示实际改变的行；我们省略了其他行，因为它们与 JSON 示例中的相同：
- en: '[PRE105]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Just like JSON, XML has its own external libraries that can help you deal with
    complex input data without having to build the hierarchy of Go types. One of them
    is the `xmlquery` package (see *Further reading*), which lets you make XML Path
    Language (XPath) queries from Go.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 JSON 一样，XML 也有自己的外部库，可以帮助你处理复杂输入数据，而无需构建 Go 类型的层次结构。其中之一是 `xmlquery` 包（见
    *进一步阅读*），它允许你从 Go 中执行 XML Path Language（XPath）查询。
- en: YAML
  id: totrans-466
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: YAML
- en: 'Now, let’s look at how we would parse a YAML inventory. You can find this example
    in the `ch03/yaml` directory of the book’s repository (see *Further reading*):'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何解析 YAML 库存。你可以在书籍仓库的 `ch03/yaml` 目录中找到这个示例（见 *进一步阅读*）：
- en: '[PRE106]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'By now, you would probably already have guessed that the number and nature
    of things that change from the JSON example are the same as for XML, which is
    to say, not much. The following code snippet highlights only the changed lines
    of code, and you can find the full code example at `ch03/yaml/main.go` (see *Further
    reading*):'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能已经猜到了，从 JSON 示例中改变的数量和性质的事物与 XML 相同，也就是说，并不多。下面的代码片段仅突出显示改变的代码行，你可以在
    `ch03/yaml/main.go`（见 *进一步阅读*）中找到完整的代码示例：
- en: '[PRE107]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'This Go program produces the same result as both the JSON and XML examples,
    but before we can run it, we need to go get the external YAML library dependency
    first (`gopkg.in/yaml.v2`):'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Go 程序产生的结果与 JSON 和 XML 示例相同，但在我们运行它之前，我们需要先获取外部 YAML 库依赖项（`gopkg.in/yaml.v2`）：
- en: '[PRE108]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: It’s also possible to parse and query YAML documents without having to predefine
    data structures. One tool that does that is `yq` (see *Further reading*), which
    implements a shell CLI tool in Go in the style of `jq` (the `sed` for JSON data).
    You can use `yq` in your Go program via its built-in `yqlib` package.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 也有可能在不预先定义数据结构的情况下解析和查询 YAML 文档。一个能够做到这一点的工具是 `yq`（见 *进一步阅读*），它以 `jq`（JSON 数据的
    `sed`）的风格在 Go 中实现了一个 shell CLI 工具。你可以在你的 Go 程序中通过其内置的 `yqlib` 包使用 `yq`。
- en: Encoding
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码
- en: Just as important as being able to decode data from a source is processing the
    data in the opposite direction, producing a structured data document based on
    an in-memory data model. In the next example, we pick up where we left off in
    the *Decoding* section and take the in-memory data we got from a JSON input file
    to output a corresponding XML document.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 能够从源解码数据同样重要的是，在相反的方向处理数据，基于内存中的数据模型生成结构化数据文档。在下一个示例中，我们继续在 *解码* 部分留下的地方，并使用从
    JSON 输入文件中获取的内存数据输出相应的 XML 文档。
- en: 'One of the first things we have to do in the code is to update the struct tags
    with an extra key-value pair for XML. Although this is not strictly necessary,
    as the XML library can fall back to using field names instead, it’s generally
    considered a best practice to annotate explicitly all relevant fields that you
    encode:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中必须做的第一件事是更新结构体标签，添加一个额外的键值对用于 XML。尽管这并非绝对必要，因为 XML 库可以回退到使用字段名，但通常认为显式注释所有相关的编码字段是一种最佳实践：
- en: '[PRE109]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The full code of this example is available in the `ch03/json-xml` directory
    (see *Further reading*) of the book’s repository, so for the sake of brevity,
    we only include the extra code that we add to encode the `inv` variable into an
    XML document:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例的完整代码可在书籍仓库的 `ch03/json-xml` 目录中找到（见 *进一步阅读*），因此为了简洁起见，我们只包括我们添加的额外代码，用于将
    `inv` 变量编码成 XML 文档：
- en: '[PRE110]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'To produce a string output, we’re using the `strings.Builder` type, which implements
    the `io.Writer` interface required by the `Encode` method. This highlights the
    power of interfaces, as we could have passed in a network connection and sent
    the XML data to a remote host instead, with almost the same program. The next
    snippet shows the output of the program:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成字符串输出，我们使用了 `strings.Builder` 类型，它实现了 `Encode` 方法所需的 `io.Writer` 接口。这突出了接口的力量，因为我们本可以将网络连接传递进去，并将
    XML 数据发送到远程主机，几乎不需要相同的程序。下一个片段显示了程序的输出：
- en: '[PRE111]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: One encoding format we haven’t covered yet is Protocol Buffers, which is part
    of the gRPC section of [*Chapter 8*](B16971_08.xhtml#_idTextAnchor182).
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有介绍的一种编码格式是 Protocol Buffers，它是 *第 8 章*（B16971_08.xhtml#_idTextAnchor182）中
    gRPC 部分的一部分。
- en: At this point, we’ve covered enough Go language theory to write effective programs
    to interact with and automate a network device. The only bit that we have left,
    which is also one of the most salient features of the language, is concurrency.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了足够的Go语言理论，可以编写有效的程序来交互和自动化网络设备。我们剩下的唯一一点，也是语言最显著的特征之一，就是并发性。
- en: Concurrency
  id: totrans-484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发
- en: If there was one feature that would characterize Go amongst other popular programming
    languages, it would be concurrency. Go’s built-in concurrency primitives (goroutines
    and channels) are one of the best abstractions we know for writing efficient code
    that can run more than one task simultaneously.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个特性可以用来在其它流行编程语言中区分Go，那将是并发性。Go内置的并发原语（goroutines和channels）是我们所知的编写高效代码的最佳抽象之一，可以同时运行多个任务。
- en: 'Your program starts in the main goroutine, but at any point, you can spawn
    other concurrent goroutines and create communication channels between them. You
    can do this with considerably less effort and less code compared to other programming
    languages, which improves the developing experience and your code’s support:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 您的程序从主goroutine开始，但任何时候，您都可以启动其他并发goroutine并在它们之间创建通信通道。与其它编程语言相比，这需要付出更少的努力和更少的代码，从而提高了开发体验和代码的支持性：
- en: '![Figure 3.12 – Go’s concurrency](img/Figure_3.121.jpg)'
  id: totrans-487
  prefs: []
  type: TYPE_IMG
  zh: '![图3.12 – Go的并发](img/Figure_3.121.jpg)'
- en: Figure 3.12 – Go’s concurrency
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 – Go的并发
- en: 'In this section, we cover the following concurrency primitives:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍以下并发原语：
- en: Goroutines and the use of the `sync` package for their coordination
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Goroutines和用于它们协调的`sync`包的使用
- en: How we use channels to send and receive data between goroutines
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何使用channels在goroutines之间发送和接收数据
- en: The use of mutexes with data shared between different goroutines
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同goroutines之间共享数据时使用互斥锁
- en: Goroutines
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Goroutines
- en: One way to think of Goroutines is as user-space threads that the Go runtime
    manages. They are computationally cheap to spawn and manage, so they can scale
    to hundreds of thousands, even on an average machine, with memory being the primary
    limiting factor.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 将Goroutines视为Go运行时管理的用户空间线程是一种思考方式。它们在创建和管理上计算成本低廉，因此可以在普通机器上扩展到数十万，内存是主要的限制因素。
- en: It’s typical to create goroutines for tasks that may block the execution of
    the main function. You can imagine why this would be particularly helpful in a
    network automation context, where we have to deal with remote network calls and
    wait for network devices to execute the commands.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会为可能阻塞主函数执行的任务创建goroutines。您可以想象这为什么在网络自动化环境中特别有帮助，在那里我们必须处理远程网络调用并等待网络设备执行命令。
- en: We introduce the basic goroutine theory by building another network automation
    example. In the preceding section, we learned how to load and parse a device inventory.
    In this section, we pick up where we left off and see how to interact with these
    network devices.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过构建另一个网络自动化示例来介绍基本的goroutine理论。在前一节中，我们学习了如何加载和解析设备清单。在本节中，我们继续之前的讨论，看看如何与这些网络设备交互。
- en: 'To start off, we use an inventory file (`input.yml`) with a single device.
    This file is in the `ch03/single` folder (see *Further reading*) of the book’s
    repository:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用一个包含单个设备的清单文件（`input.yml`）。这个文件位于书的存储库的`ch03/single`文件夹中（见*进一步阅读*）：
- en: '[PRE112]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'To store this inventory, we define a type hierarchy like the one we had in
    the encoding/decoding section. The code example output only shows some fields
    for brevity:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储这个清单，我们定义了一个类似于我们在编码/解码部分中使用的类型层次结构。代码示例输出仅显示了一些字段以节省篇幅：
- en: '[PRE113]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'We define another function called `getVersion` that accepts an argument of
    the `Router` type, connects and retrieves the software and hardware version information,
    and prints it on a screen. The exact implementation of this function is not important
    and we don’t focus on it in this chapter yet, but you can see the full code example
    at `ch03/single/main.go` (see *Further reading*):'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了另一个名为`getVersion`的函数，它接受`Router`类型的参数，连接并检索软件和硬件版本信息，并在屏幕上打印出来。这个函数的确切实现并不重要，我们在这个章节中还没有关注它，但您可以在`ch03/single/main.go`（见*进一步阅读*）中看到完整的代码示例：
- en: '[PRE114]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Since we only have one device in the inventory, we can access it directly using
    a slice index. The execution of this program takes a little under 2 seconds:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只有一个设备在清单中，我们可以直接使用切片索引来访问它。这个程序的执行时间略少于2秒：
- en: '[PRE115]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Now, let’s look at a similar example, stored in the `ch03/sequential` directory
    (see *Further reading*), where we’ve added two extra devices to the inventory:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个类似的例子，它存储在`ch03/sequential`目录中（见*进一步阅读*），我们在库存中添加了两个额外的设备：
- en: '[PRE116]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'As we discussed in the *Control flow* section, we can iterate over arrays and
    slices with the `range` form of a `for` loop. Here, we iterate over each `Router`
    in `inv.Routers`, assigning it to the `v` variable in each iteration. We ignore
    the value of the index by assigning it to the blank identifier written as `_`
    (underscore). Finally, we call the `getVersion` function for the `v` router:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在*控制流*部分讨论的那样，我们可以使用`for`循环的`range`形式遍历数组和切片。在这里，我们遍历`inv.Routers`中的每个`Router`，将其分配给每次迭代的`v`变量。我们通过将其分配给空白标识符（写作`_`，下划线）来忽略索引的值。最后，我们为`v`路由器调用`getVersion`函数：
- en: '[PRE117]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'It takes around 7 seconds to execute as it connects to one device after another:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 它大约需要7秒来执行，因为它会依次连接到每个设备：
- en: '[PRE118]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'This is a prime example of code that we could optimize through the use of goroutines.
    All we need to do initially is to add a `go` keyword before the statement that
    we need to run in a goroutine:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以通过使用goroutines来优化的代码的一个典型例子。我们最初需要做的只是在我们需要在goroutine中运行的语句之前添加一个`go`关键字：
- en: '[PRE119]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: In the code example, we spawn a separate goroutine for each invocation of the
    `getVersion` (`v`) statement. Everything happens in the background; any blocking
    statement inside a spawned goroutine does not affect the other goroutines, so
    all three function calls, plus the main goroutine, now run concurrently.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码示例中，我们为每个`getVersion`（`v`）语句的调用生成一个单独的goroutine。所有事情都在后台发生；在生成的goroutine中的任何阻塞语句都不会影响其他goroutine，所以现在所有三个函数调用，加上主goroutine，都是并发运行的。
- en: The default behavior of these spawned goroutines is to release control immediately,
    so in this example, the code iterates over all three devices and then returns.
    It doesn’t actually wait for the spawned goroutines to complete.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 这些生成的goroutines的默认行为是立即释放控制权，所以在这个例子中，代码遍历所有三个设备然后返回。它实际上并没有等待生成的goroutines完成。
- en: But, in our case, we’d like to see the result of all three function calls before
    we exit the program. This is where we can use a special `sync.WaitGroup` type,
    which blocks the main goroutine until all spawned goroutines complete. It does
    this by keeping a counter that tracks all currently active goroutines and blocks
    until that counter goes down to zero.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在我们的情况下，我们希望在退出程序之前看到所有三个函数调用的结果。这就是我们可以使用一个特殊的`sync.WaitGroup`类型的地方，它会阻塞主goroutine，直到所有生成的goroutines完成。它是通过保持一个跟踪所有当前活动goroutines的计数器来做到这一点的，并且会阻塞直到该计数器降到零。
- en: 'This is what we do to introduce this idea in the code example we are working
    with:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何在我们的代码示例中引入这个想法的方法：
- en: We create a new `wg` variable of the `sync.WaitGroup` type.
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个新的`wg`变量，其类型为`sync.WaitGroup`。
- en: While iterating through our inventory, we increase the `WaitGroup` counter by
    one with `wg.Add(1)`.
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当遍历我们的库存时，我们通过`wg.Add(1)`将`WaitGroup`计数器增加一。
- en: Each spawned goroutine consists of an anonymous function that runs `getVersion`,
    but also calls `wg.Done` at the very end to decrement the `WaitGroup` counter
    by one with a `defer` statement.
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个生成的goroutine都包含一个运行`getVersion`的匿名函数，但在最后也通过`defer`语句调用`wg.Done`，以将`WaitGroup`计数器减一。
- en: The main goroutine blocks on `wg.Wait` until the `WaitGroup` counter becomes
    zero. This happens after all the spawned instances of the `getVersion` functions
    return.
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主goroutine在`wg.Wait`上阻塞，直到`WaitGroup`计数器变为零。这发生在所有`getVersion`函数的生成实例返回之后。
- en: 'You can find the full code of this example at `ch03/concurrency/main.go` (see
    *Further reading*):'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`ch03/concurrency/main.go`（见*进一步阅读*）中找到这个示例的完整代码：
- en: '[PRE120]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Now, let’s see what effect these changes have on the execution time of the
    program:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这些更改对程序执行时间的影响：
- en: '[PRE121]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: We’ve gone down to roughly 3 seconds, which is how long it took to communicate
    with the slowest device in the inventory. This is a pretty significant win, considering
    we didn’t have to change any of the *worker* functions (`getVersion` in this case).
    You might apply the same refactoring to many other similar programs with minimal
    changes to their existing code bases.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将时间缩短到大约3秒，这是与库存中最慢的设备通信所需的时间。考虑到我们不需要更改任何*工作*函数（在这种情况下是`getVersion`），这是一个相当大的胜利。你可能可以将相同的重构应用到许多其他类似的程序上，只需对它们的现有代码库进行最小改动。
- en: 'This approach works well with natively synchronous functions that you can run
    with or without a goroutine. But, if we know that a certain function always runs
    in a goroutine, it’s totally possible to make it goroutine-aware from the very
    beginning. For example, this is how we could have refactored the `getVersion`
    function to accept an extra `WaitGroup` argument and make the `wg.Done` call part
    of the function:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与原生同步函数配合得很好，你可以运行它，无论是否有goroutine。但是，如果我们知道某个函数始终在goroutine中运行，那么从一开始就让它具有goroutine意识是完全可能的。例如，这就是我们如何重构`getVersion`函数以接受额外的`WaitGroup`参数，并将`wg.Done`调用作为函数的一部分：
- en: '[PRE122]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Having a function like that would simplify the code of the main function since
    we no longer need to wrap everything in an anonymous function just to make the
    `wg.Done` call:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 有这样一个函数将简化主函数的代码，因为我们不再需要将所有内容包裹在一个匿名函数中，只是为了调用`wg.Done`：
- en: '[PRE123]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The complete code for this example is available in the `ch03/concurrency2` directory
    (see *Further reading*).
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的完整代码位于`ch03/concurrency2`目录中（见*进一步阅读*）。
- en: Channels
  id: totrans-531
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Channels
- en: As soon as anyone becomes familiar with goroutines, the next thing they normally
    want to do is exchange data between them. Go channels allow goroutines to communicate
    with each other. A real-world analogy to describe Go channels are first-in-first-out
    pipes – they have fixed throughput and allow you to send data in both directions.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦任何人熟悉了goroutines，他们通常想要做的下一件事就是在它们之间交换数据。Go channels允许goroutines相互通信。用现实世界的类比来描述Go
    channels，它们就像先进先出（first-in-first-out）的管道——它们有固定的吞吐量，并允许你在两个方向上发送数据。
- en: You can use channels for both goroutine synchronization (a form of signaling
    used for work coordination) and general-purpose data exchange.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用channels进行goroutine同步（一种用于工作协调的信号形式）和通用数据交换。
- en: We create channels with the `make` keyword, which initializes them and makes
    them ready to use. The two arguments that `make` accepts are the channel type,
    which defines the data type you can exchange over the channel, and an optional
    capacity. The channel capacity determines how many unreceived values it can store
    before it starts blocking a sender, acting then as a buffer.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`make`关键字创建channels，它初始化它们并使它们准备好使用。`make`接受的两个参数是channel类型，它定义了你可以通过channel交换的数据类型，以及一个可选的容量。channel容量决定了在它开始阻塞发送者之前可以存储多少未接收到的值，此时它充当一个缓冲区。
- en: 'The following code snippet shows how we send and receive an integer over a
    channel. Here, `send` is the value we want to send to the `ch` channel we created.
    The `<-` operator lets us send data to a channel. Next, we declare a `receive`
    variable, whose value comes from the `ch` channel:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了我们如何在channel上发送和接收一个整数。在这里，`send`是我们想要发送到我们创建的`ch`channel的值。`<-`操作符允许我们向channel发送数据。接下来，我们声明一个`receive`变量，其值来自`ch`channel：
- en: '[PRE124]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: But, sending and receiving data in a single goroutine is not the goal here.
    Let’s examine another example of using channels for communication between different
    goroutines. We pick up the example we’ve used in this section so far and introduce
    another *worker* function whose job is to print the results produced by the `getVersion`
    function.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在单个goroutine中发送和接收数据不是这里的最终目标。让我们检查另一个使用channels在不同goroutines之间进行通信的例子。我们拾取本节中使用的例子，并引入另一个*worker*函数，其任务是打印`getVersion`函数产生的结果。
- en: 'The new `printer` function uses a `for` loop to receive values from an `in`
    channel and it prints them on the terminal:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`printer`函数使用`for`循环从`in`channel接收值，并在终端上打印它们：
- en: '[PRE125]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'We create the `ch` channel in the main goroutine before we spawn any of the
    goroutines. We pass it as an argument to both `getVersion` and `printer` functions.
    The first extra goroutine we start is an instance of the `printer` function that
    listens for messages coming from the device over the `ch` channel:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们启动任何goroutine之前，我们在主goroutine中创建`ch`channel，并将其作为参数传递给`getVersion`和`printer`函数。我们首先启动的额外goroutine是`printer`函数的一个实例，它监听来自设备的消息，通过`ch`channel：
- en: '[PRE126]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The next step is to start a goroutine for each network device in the inventory
    to capture the output we need and send it over the channel with the `getVersion`
    function. After we collect and print the data, we close the channel and end the
    program:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是启动一个goroutine来处理清单中的每个网络设备，捕获我们需要的输出，并使用`getVersion`函数将其通过channel发送。在收集并打印数据后，我们关闭channel并结束程序：
- en: '[PRE127]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The complete code for this example is available in the `ch03/concurrency3` (*Further*
    *reading*) directory.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的完整代码位于`ch03/concurrency3` (*Further* *reading*) 目录中。
- en: Channels and Timers
  id: totrans-545
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Channels and Timers
- en: One thing we didn’t consider in the last couple of examples was the scenario
    where a network device is not reachable, or the connection to it hangs, or maybe
    a device takes forever to return the output we need. In these cases, we need to
    set up a timeout so we don’t wait forever and we can end the program gracefully.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几个例子中，我们没有考虑到的场景是网络设备不可达，或者与它的连接中断，或者设备可能永远无法返回我们需要的输出。在这些情况下，我们需要设置超时，这样我们就不必永远等待，并且可以优雅地结束程序。
- en: 'You can handle this at the connection level, but also, channels offer you a
    couple of resources to keep track of time via these timer types:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在连接级别处理此问题，但通道还提供了一些资源，通过这些计时器类型来跟踪时间：
- en: '**Timer** — To wait for a certain amount of time'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定时器** — 等待一定时间'
- en: '**Ticker** — To perform an action repeatedly at some interval'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计时器** — 在某个间隔内重复执行操作'
- en: Timer
  id: totrans-550
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定时器
- en: '`Timer` can help you define a timeout for your program. To illustrate this,
    we can rewrite the example we have been working with to print all the messages
    from the `ch` channel in the main function, instead of calling a separate function
    (`printer`).'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '`Timer`可以帮助您为程序定义超时。为了说明这一点，我们可以重写我们一直在工作的示例，在主函数中打印来自`ch`通道的所有消息，而不是调用一个单独的函数（`printer`）。'
- en: 'A `select` statement inside an infinite loop handles this as follows. Unlike
    a `switch` statement, we use `select` with channels when we don’t have to choose
    an option in order. For each iteration, we either wait for a message from the
    `ch` channel or if 5 seconds have elapsed (`time.After(5 * time.Second)`), we
    close the channel and exit the program:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 在无限循环中的`select`语句是这样处理的。与`switch`语句不同，当我们不需要选择选项时，我们使用`select`与通道一起使用。对于每次迭代，我们要么等待来自`ch`通道的消息，要么如果5秒已过（`time.After(5
    * time.Second)`），我们关闭通道并退出程序：
- en: '[PRE128]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: This forces the runtime to always be 5 seconds, even if not all the tasks have
    been completed. This is not the most efficient way to solve this problem, but
    it shows how to timeout without introducing the `context` package from the standard
    library that you could also use in this scenario.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 这迫使运行时始终为5秒，即使不是所有任务都已完成。这不是解决这个问题的最有效方法，但它展示了如何超时而不引入标准库中的`context`包，您也可以在这个场景中使用该包。
- en: The complete code for this example is available in the `ch03/concurrency5` directory
    of the book’s repository (see *Further reading*).
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的完整代码位于书籍仓库的`ch03/concurrency5`目录中（参见*进一步阅读*）。
- en: Ticker
  id: totrans-556
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计时器
- en: 'A common use for a ticker is in cases where you want to execute periodic tasks.
    In the next code example, we create a `ticker` that runs every half second, which
    we use as a trigger to print out a message to the terminal. We also create a `done`
    channel, just to signal that we want to stop the execution of the program after
    2 seconds and 100 milliseconds:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器的一个常见用途是在需要执行周期性任务的情况下。在下一个代码示例中，我们创建了一个每半秒运行`ticker`，我们将其用作触发器，向终端打印消息。我们还创建了一个`done`通道，仅用于在2秒和100毫秒后停止程序的执行：
- en: '[PRE129]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Tickers from the `time` package have a `C` channel that they use to signal
    every interval. We pass this channel and the `done` channel to the `repeat` function
    that we execute in a goroutine:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '`time`包中的计时器有一个`C`通道，它们使用该通道在每个间隔内发出信号。我们将此通道和`done`通道传递给我们在goroutine中执行的`repeat`函数：'
- en: '[PRE130]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'This function runs an infinite loop that waits for a signal from the `ticker`
    or the `done` channel to end the execution. This is what the output looks like:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数运行一个无限循环，等待来自`ticker`或`done`通道的信号以结束执行。输出如下：
- en: '[PRE131]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The complete code for this example is available in the `ch03/ticker` directory
    (see *Further reading*).
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的完整代码位于`ch03/ticker`目录中（参见*进一步阅读*）。
- en: Shared data access
  id: totrans-564
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享数据访问
- en: Channels are thread-safe, so it’s always a good idea to use them as the default
    option for data communication between goroutines. But sometimes, you may still
    need to access and change data that more than just one goroutine has access to.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: Channels是线程安全的，因此始终使用它们作为goroutines之间数据通信的默认选项是个好主意。但有时，您可能仍然需要访问和更改多个goroutine都可以访问的数据。
- en: 'The problem with concurrent data access is that it may cause data corruption
    when many goroutines try to change the same field or read from a field that someone
    else might be changing. Go’s `sync` package includes three helper types you can
    use to serialize these kinds of operations:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 并发数据访问的问题在于，当许多goroutine尝试更改相同的字段或从其他人可能正在更改的字段中读取时，可能会导致数据损坏。Go的`sync`包包括三种辅助类型，您可以使用它们来序列化这些类型的操作：
- en: The `sync.Mutex` type is a general-purpose mutual exclusion lock that has two
    states — locked and unlocked.
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync.Mutex`类型是一种通用互斥锁，有两个状态——锁定和解锁。'
- en: The `sync.RWMutex` type is a special mutex for read-write operations where only
    write operations are mutually exclusive but simultaneous read operations are safe.
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync.RWMutex`类型是专门用于读写操作的互斥锁，其中只有写操作是互斥的，但同时的读操作是安全的。'
- en: The `sync.Map` mutex covers a couple of map corner case scenarios that we don’t
    delve into in this book. The **sync.Map documentation** talks about them (see
    *Further reading*).
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync.Map`互斥锁覆盖了几个映射边缘情况，我们在这本书中没有深入探讨。**sync.Map文档**中提到了它们（参见*进一步阅读*）。'
- en: 'Now, let’s see an example of how you can use `sync.RWMutexto` to safeguard
    concurrent map access. Using the example theme we have used through this section
    as the baseline, let’s add another variable that records whether we are able to
    connect successfully to a remote device. We call this variable `isAlive` and pass
    it to the `getVersion` function as an argument:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用`sync.RWMutexto`来保护并发映射访问的示例。以本节中使用的示例主题为基准，让我们添加另一个变量来记录我们是否能够成功连接到远程设备。我们称这个变量为`isAlive`，并将其作为参数传递给`getVersion`函数：
- en: '[PRE132]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'We define the `m` mutex as a package-level global variable to make sure all
    functions are using the same mutex for synchronization. We lock this mutex just
    before we change the `isAlive` map and unlock it right after we make the change
    in the `getVersion` function:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`m`互斥锁定义为包级全局变量，以确保所有函数都使用相同的互斥锁进行同步。我们在更改`isAlive`映射之前锁定这个互斥锁，并在`getVersion`函数中更改后立即解锁：
- en: '[PRE133]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Finally, we add another mutex for a loop in the main function that uses a read-specific
    lock while iterating over a map to prevent it from being accidentally modified
    in the process:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在主函数中的循环中添加了另一个互斥锁，该锁在迭代映射时使用只读锁，以防止在过程中意外修改：
- en: '[PRE134]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'You can check the full code in the `ch03/concurrency4` directory (see *Further
    reading*). The next output shows what this program produces:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`ch03/concurrency4`目录中查看完整的代码（参见*进一步阅读*）。下一个输出显示了该程序产生的结果：
- en: '[PRE135]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Sometimes, you might forget to use mutexes, especially for non-trivial user-defined
    data types, or when you accidentally leak a variable between goroutines. In these
    cases, you can use the data race detector built into the `go` tool. Add the `-race`
    flag to any of the go `test`/`run`/`build` commands to check and get a report
    of any unprotected access requests to shared memory.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能会忘记使用互斥锁，特别是对于非平凡的用户定义数据类型，或者当你意外地在goroutines之间泄漏变量时。在这些情况下，你可以使用`go`工具内置的数据竞争检测器。将`-race`标志添加到任何go
    `test`/`run`/`build`命令中，以检查并获取对共享内存的任何未受保护访问请求的报告。
- en: 'To see how it works, let’s focus on the `isAlive` map we manipulate concurrently
    on different instances of the `getVersion` function. Earlier, we surrounded this
    with a mutex, which we now remove in `ch03/race/main.go` (see *Further reading*):'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解它是如何工作的，让我们关注我们在`getVersion`函数的不同实例上并发操作的`isAlive`映射。之前，我们用互斥锁包围了它，现在我们在`ch03/race/main.go`中移除了它（参见*进一步阅读*）：
- en: '[PRE136]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'When you run the program with the extra `-race` flag, Go highlights the data
    race condition it detects:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用额外的`-race`标志运行程序时，Go会突出显示它检测到的数据竞争条件：
- en: '[PRE137]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Go’s built-in data race detector alleviates the task of debugging data races,
    which are among the hardest bugs to debug in concurrent systems.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: Go的内置数据竞争检测器减轻了调试数据竞争的任务，数据竞争是并发系统中最难调试的bug之一。
- en: Concurrency caveats
  id: totrans-584
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发注意事项
- en: Concurrency is a powerful tool. You could even envision using goroutines everywhere
    in your code and following design patterns such as worker pools to split up your
    work between different goroutines to get the initial speed gains for a relatively
    small price of increased complexity.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 并发是一个强大的工具。你甚至可以在代码的每个地方使用goroutines，并遵循如工作池等设计模式，将工作分配给不同的goroutines，以获得相对较小的复杂性增加的初始速度提升。
- en: But, it’s important to consider that *concurrency is not parallelism* (see *Further
    reading*) and there is always some overhead involved in the coordination of goroutines
    and mapping them to OS threads. We also shouldn’t forget that the underlying hardware
    resources are finite and so are the concurrency performance gains, as they inevitably
    flatten out at a certain point (see *Simulating a real-world system in Go* in
    the *Further* *reading* section).
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，重要的是要考虑*并发不是并行*（见*进一步阅读*），在协调goroutines并将它们映射到操作系统线程的过程中，始终存在一些开销。我们也不应该忘记，底层硬件资源是有限的，因此并发性能的提升也是有限的，因为它们不可避免地会在某个点上趋于平稳（见*进一步阅读*部分的*在Go中模拟真实世界系统*）。
- en: Finally, concurrent programming is hard; it’s hard to write code that’s safe,
    and hard to reason about and debug when it breaks. It’s important not to over-engineer
    your code with goroutines and use them when and where you truly need them, measure
    your gains and detect race conditions, avoid memory sharing if possible, and opt
    for communicating via channels.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，并发编程很难；编写安全的代码很难，当它出错时，推理和调试也很困难。不要过度使用goroutines来设计你的代码，只在真正需要时使用它们，衡量你的收益并检测竞争条件，尽可能避免内存共享，并通过通道进行通信。
- en: Summary
  id: totrans-588
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter concludes the theoretical introduction to Go as a programming language.
    We went from Go variable types and performing operations with them, to reviewing
    the key building blocks of Go programs, and how to take advantage of some of Go’s
    most notable packages from its standard library to help you build scalable applications.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 本章总结了Go作为编程语言的理论介绍。我们从Go变量类型及其操作开始，到回顾Go程序的关键构建块，以及如何利用Go标准库中最著名的包来帮助你构建可扩展的应用程序。
- en: Starting from the next chapter, we turn our attention to network-specific tasks
    that are more applicable to real-world scenarios. We still continue introducing
    some theoretical concepts throughout the book, but most content is on concrete
    use cases rather than abstract theory.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 从下一章开始，我们将注意力转向更适用于现实场景的网络特定任务。我们仍然在整本书中介绍一些理论概念，但大部分内容都是关于具体用例，而不是抽象理论。
- en: Further reading
  id: totrans-591
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '`ch03/type-definition/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/type-definition/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/type-definition/main.go
    )'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/type-definition/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/type-definition/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/type-definition/main.go)'
- en: '`ch03/string-literals/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/string-literals/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/string-literals/main.go
    )'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/string-literals/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/string-literals/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/string-literals/main.go)'
- en: '`ch03/string-concatenate/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/string-concatenate/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/string-concatenate/main.go
    )'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/string-concatenate/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/string-concatenate/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/string-concatenate/main.go)'
- en: '`ch03/string-memory/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/string-memory/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/string-memory/main.go
    )'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/string-memory/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/string-memory/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/string-memory/main.go)'
- en: '`ch03/boolean/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/boolean/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/boolean/main.go
    )'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/boolean/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/boolean/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/boolean/main.go)'
- en: '`ch03/arrays/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/arrays/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/arrays/main.go)'
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/arrays/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/arrays/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/arrays/main.go)'
- en: '`ch03/slices/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/slices/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/slices/main.go)'
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/slices/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/slices/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/slices/main.go)'
- en: '`ch03/maps/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/maps/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/maps/main.go
    )'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/maps/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/maps/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/maps/main.go)'
- en: '`ch03/structs/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/structs/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/structs/main.go)'
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/structs/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/structs/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/structs/main.go)'
- en: '`ch03/tcp-header/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/tcp-header/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/tcp-header/main.go)'
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/tcp-header/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/tcp-header/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/tcp-header/main.go)'
- en: '*Comparison* *operators*: [https://golang.org/ref/spec#Comparison_operators](https://golang.org/ref/spec#Comparison_operators)'
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*比较运算符*: [https://golang.org/ref/spec#Comparison_operators](https://golang.org/ref/spec#Comparison_operators)'
- en: '`ch03/switch/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/switch/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/switch/main.go)'
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/switch/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/switch/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/switch/main.go)'
- en: '`ch03/goto/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/goto/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/goto/main.go)'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/goto/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/goto/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/goto/main.go)'
- en: '`ch03/functions1/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/functions1/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/functions1/main.go)'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/functions1/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/functions1/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/functions1/main.go)'
- en: '`ch03/functions2/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/functions2/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/functions2/main.go)'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/functions2/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/functions2/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/functions2/main.go)'
- en: '`ch03/mutate-slice/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/mutate-slice/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/mutate-slice/main.go)'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/mutate-slice/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/mutate-slice/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/mutate-slice/main.go)'
- en: '`ch03/methods/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/methods/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/methods/main.go)'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/methods/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/methods/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/methods/main.go)'
- en: '`ch03/variadic/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/variadic/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/variadic/main.go)'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/variadic/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/variadic/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/variadic/main.go)'
- en: '`ch03/defer/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/defer/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/defer/main.go)'
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/defer/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/defer/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/defer/main.go)'
- en: '*Sample* *program*: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/interfaces-sample/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/interfaces-sample/main.go
    )'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*示例程序*: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/interfaces-sample/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/interfaces-sample/main.go)'
- en: '`ch03/io-interface1/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/io-interface1/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/io-interface1/main.go
    )'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/io-interface1/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/io-interface1/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/io-interface1/main.go)'
- en: '`ch03/io-interface2/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/io-interface2/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/io-interface2/main.go
    )'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/io-interface2/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/io-interface2/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/io-interface2/main.go)'
- en: '`ch03/reader/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/reader/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/reader/main.go
    )'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/reader/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/reader/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/reader/main.go)'
- en: '`ch03/json`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/json](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/json
    )'
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/json`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/json](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/json)'
- en: 'Book’s GitHub repository: [https://github.com/PacktPublishing/Network-Automation-with-Go](https://github.com/PacktPublishing/Network-Automation-with-Go
    )'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '书籍的GitHub仓库: [https://github.com/PacktPublishing/Network-Automation-with-Go](https://github.com/PacktPublishing/Network-Automation-with-Go)'
- en: '`ch03/json/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/json/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/json/main.go)'
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/json/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/json/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/json/main.go)'
- en: '`ch03/json-interface`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/json-interface](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/json-interface
    )'
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/json-interface`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/json-interface](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/json-interface)'
- en: '*GJSON*: [https://github.com/tidwall/gjson](https://github.com/tidwall/gjson
    )'
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GJSON*: [https://github.com/tidwall/gjson](https://github.com/tidwall/gjson)'
- en: '*SJSON*: [https://github.com/tidwall/sjson](https://github.com/tidwall/sjson
    )'
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SJSON*: [https://github.com/tidwall/sjson](https://github.com/tidwall/sjson)'
- en: '`ch03/xml`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/xml](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/xml
    )'
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/xml`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/xml](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/xml)'
- en: '`xmlquery`: [https://github.com/antchfx/xmlquery](https://github.com/antchfx/xmlquery
    )'
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xmlquery`: [https://github.com/antchfx/xmlquery](https://github.com/antchfx/xmlquery)'
- en: '`ch03/yaml`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/yaml](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/yaml
    )'
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/yaml`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/yaml](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/yaml)'
- en: '`ch03/yaml/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/yaml/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/yaml/main.go)'
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/yaml/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/yaml/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/yaml/main.go)'
- en: '*yq*: [https://github.com/mikefarah/yq](https://github.com/mikefarah/yq)'
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*yq*: [https://github.com/mikefarah/yq](https://github.com/mikefarah/yq)'
- en: '`ch03/json-xml`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/json-xml](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/json-xml
    )'
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/json-xml`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/json-xml](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/json-xml)'
- en: '`ch03/single`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/single](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/single
    )'
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/single`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/single](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/single)'
- en: '`ch03/single/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/single/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/single/main.go
    )'
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/single/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/single/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/single/main.go)'
- en: '`ch03/sequential`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/sequentia](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/sequentia
    )'
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/sequential`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/sequentia](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/sequentia)'
- en: '`ch03/concurrency/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/concurrency/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/concurrency/main.go
    )'
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/concurrency/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/concurrency/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/concurrency/main.go)'
- en: '`ch03/concurrency2`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency2](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency2
    )'
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/concurrency2`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency2](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency2)'
- en: '`ch03/concurrency3`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency3](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency3
    )'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/concurrency3`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency3](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency3)'
- en: '`ch03/concurrency5`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency5](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency5
    )'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/concurrency5`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency5](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency5)'
- en: '`ch03/ticker`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/ticker](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/ticker
    )'
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/ticker`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/ticker](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/ticker)'
- en: '*sync.Map* *documentation*: [https://pkg.go.dev/sync#Map](https://pkg.go.dev/sync#Map
    )'
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*sync.Map* 文档: [https://pkg.go.dev/sync#Map](https://pkg.go.dev/sync#Map)'
- en: '`ch03/concurrency4`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency4](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency4
    )'
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/concurrency4`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency4](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch03/concurrency4)'
- en: '`ch03/race/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/race/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/race/main.go
    )'
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch03/race/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/race/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch03/race/main.go)'
- en: '*Simulating a real-world system in* *Go*: [https://www.youtube.com/watch?v=_YK0viplIl4](https://www.youtube.com/watch?v=_YK0viplIl4
    )'
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在 *Go* 中 *模拟真实世界系统*: [https://www.youtube.com/watch?v=_YK0viplIl4](https://www.youtube.com/watch?v=_YK0viplIl4)'
- en: '*Concurrency is not* *parallelism*: [https://blog.golang.org/waza-talk](https://blog.golang.org/waza-talk)'
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*并发不是* *并行*: [https://blog.golang.org/waza-talk](https://blog.golang.org/waza-talk)'
