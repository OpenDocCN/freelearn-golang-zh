<html><head></head><body>
<div id="_idContainer051">
<h1 class="chapter-number" id="_idParaDest-110"><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-111"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.2.1">Networking (TCP/IP) with Go</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Every network engineer has at some point learned about the seven layers of the </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">Open Systems Interconnection</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">OSI</span></strong><span class="koboSpan" id="kobo.7.1">) model. </span><span class="koboSpan" id="kobo.7.2">A more concise version of it, with only four layers, is </span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.8.1">the TCP/IP model, which is the architectural model that governs communications over </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">the internet.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">Each layer defines a function, which one data communication protocol per layer performs. </span><span class="koboSpan" id="kobo.10.2">These layers pile one upon another, so we often call this collection of protocols a protocol stack. </span><span class="koboSpan" id="kobo.10.3">A data packet has to go through each of the four layers of the protocol stack before it gets to the </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">destination host.</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">Go has several packages to work with protocols at each layer of the TCP/IP model. </span><span class="koboSpan" id="kobo.12.2">This enables us to build solutions for an array of use cases – from IP address management to running application transactions through the network or even implementing </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">network protocols:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer045">
<span class="koboSpan" id="kobo.14.1"><img alt="Figure 4.1 – TCP/IP model" src="image/B16971_04_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.15.1">Figure 4.1 – TCP/IP model</span></p>
<p><span class="koboSpan" id="kobo.16.1">In this chapter, we focus on use cases for each of the layers of the </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">TCP/IP model:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.18.1">Link</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.19.1">Internet</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.20.1">Transport</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.21.1">Application</span></span></li>
</ul>
<h1 id="_idParaDest-112"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.22.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.23.1">We assume basic familiarity with the command line, Git, and GitHub. </span><span class="koboSpan" id="kobo.23.2">You can find the code examples for this chapter in the book’s GitHub repository: </span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go"><span class="koboSpan" id="kobo.24.1">https://github.com/PacktPublishing/Network-Automation-with-Go</span></a><span class="koboSpan" id="kobo.25.1">, under the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.26.1">ch04</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.27.1"> folder.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">To run the examples, you’ll need to do </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">the following:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.30.1">Install Go 1.17 or later for your operating system. </span><span class="koboSpan" id="kobo.30.2">You can follow the instructions in </span><a href="B16971_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.31.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.32.1">, </span><em class="italic"><span class="koboSpan" id="kobo.33.1">Introduction</span></em><span class="koboSpan" id="kobo.34.1">, in the section </span><em class="italic"><span class="koboSpan" id="kobo.35.1">Installing Go</span></em><span class="koboSpan" id="kobo.36.1">, or go to </span><a href="https://go.dev/doc/install"><span class="koboSpan" id="kobo.37.1">https://go.dev/doc/install</span></a><span class="koboSpan" id="kobo.38.1">. </span><span class="koboSpan" id="kobo.38.2">Two examples in this chapter, specifically those for the net/netip package, require Go 1.18 </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">or later.</span></span></li>
<li><span class="koboSpan" id="kobo.40.1">Clone the book’s GitHub repository with </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">git </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">clone https://github.com/PacktPublishing/Network-Automation-with-Go.git</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.44.1">Change the directory to an example folder: </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">cd Network-Automation-with-Go/ch04/trie</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.47.1">Execute </span><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">go </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">run main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">.</span></span></li>
</ol>
<h1 id="_idParaDest-113"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.51.1">The link layer</span></h1>
<p><span class="koboSpan" id="kobo.52.1">We start with </span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.53.1">the bottom layer of the TCP/IP model that sends and receives link layer data frames. </span><span class="koboSpan" id="kobo.53.2">In this section, we cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.55.1">Management of </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">network interfaces</span></span></li>
<li><span class="koboSpan" id="kobo.57.1">Basic operations </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">with Ethernet</span></span></li>
</ul>
<h2 id="_idParaDest-114"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.59.1">Network interfaces</span></h2>
<p><span class="koboSpan" id="kobo.60.1">As we see more and more network operating systems based on Linux, it makes sense to understand </span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.61.1">how Go can help us interact with network </span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.62.1">interfaces in </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">this context.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">Linux exposes its networking internals through a kernel </span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.65.1">interface called Netlink. </span><span class="koboSpan" id="kobo.65.2">This interface allows user-space applications such as Go to communicate with the kernel over a standard socket API. </span><span class="koboSpan" id="kobo.65.3">Most commonly, TCP/UDP libraries use Netlink sockets to send and receive data, but they can also work with most Linux networking constructs, from interfaces to routes </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">and nftables.</span></span></p>
<p><span class="koboSpan" id="kobo.67.1">Thankfully, you don’t need to learn about or understand the low-level Netlink API, as there are many Go packages that deliver high-level abstractions, making it much easier to work with. </span><span class="koboSpan" id="kobo.67.2">Some </span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.68.1">notable Netlink packages include </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.70.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">syscall</span></strong><span class="koboSpan" id="kobo.72.1"> package (</span><em class="italic"><span class="koboSpan" id="kobo.73.1">Further reading</span></em><span class="koboSpan" id="kobo.74.1">) of the Go standard library, which includes several low-level primitives typically used by </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">high-level packages.</span></span></li>
<li><span class="koboSpan" id="kobo.76.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">vishvananda/netlink</span></strong><span class="koboSpan" id="kobo.78.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.79.1">Further reading</span></em><span class="koboSpan" id="kobo.80.1">) third-party Go package is one of the earlier implementations of a high-level Netlink package, widely used by various open source projects such as Docker, Istio, and Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">CNI plugins.</span></span></li>
<li><span class="koboSpan" id="kobo.82.1">The ecosystem of plugins based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">mdlayher/netlink</span></strong><span class="koboSpan" id="kobo.84.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.85.1">Further reading</span></em><span class="koboSpan" id="kobo.86.1">) package is a set of relatively recent projects implemented on a common foundation in a more idiomatic and </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">maintainable way.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.88.1">These Netlink packages have varying levels of feature coverage and the one you choose normally depends on your application requirements. </span><span class="koboSpan" id="kobo.88.2">For a demonstration, we show how to toggle the administrative state of an interface, and to do that, we pick one of the rtnetlink packages from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">mdlayher/netlink</span></strong><span class="koboSpan" id="kobo.90.1"> ecosystem (</span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.91.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.93.1">Let’s break down and review this example in three stages. </span><span class="koboSpan" id="kobo.93.2">First, we import the Netlink package </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">rtnetlink/rtnl</span></strong><span class="koboSpan" id="kobo.95.1">, which is one of the loosely related packages developed around the </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">mdlayher/netlink</span></strong><span class="koboSpan" id="kobo.97.1"> package, to establish a connection with a Netlink socket with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">Dial</span></strong><span class="koboSpan" id="kobo.99.1"> method and then retrieve the list of all local interfaces with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">Links</span></strong><span class="koboSpan" id="kobo.101.1"> method over </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">the connection:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.103.1">func</span></span><span class="koboSpan" id="kobo.104.1"> main() {
    conn, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.105.1">=</span></span><span class="koboSpan" id="kobo.106.1"> rtnl.Dial</span><span class="Code_Blue"><span class="koboSpan" id="kobo.107.1">(nil)</span></span><span class="koboSpan" id="kobo.108.1">
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.109.1">// process error</span></span><span class="koboSpan" id="kobo.110.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.111.1">defer</span></span><span class="koboSpan" id="kobo.112.1"> conn.Close()
    links, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.113.1">=</span></span><span class="koboSpan" id="kobo.114.1"> conn.Links()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.115.1">/* ... </span><span class="koboSpan" id="kobo.115.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.115.3">*/</span></span><span class="koboSpan" id="kobo.116.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.117.1">This preceding code resembles what we do for all remote connections in Go, which is why Go developers consider this package more idiomatic. </span><span class="koboSpan" id="kobo.117.2">Once we have the list of all the interfaces in the variable links, we can iterate over them to find any interface </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">of interest.</span></span></p>
<p><span class="koboSpan" id="kobo.119.1">Let’s say we </span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.120.1">want to toggle the </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">lo</span></strong><span class="koboSpan" id="kobo.122.1"> interface if it’s present in </span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.123.1">the system. </span><span class="koboSpan" id="kobo.123.2">We loop over all the interfaces in the variable links, and we print out the data of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">lo</span></strong><span class="koboSpan" id="kobo.125.1"> interface if we find it and store the interface value in a variable we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">loopback</span></strong><span class="koboSpan" id="kobo.127.1">, so we can bring this link down with </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">LinkDown</span></strong><span class="koboSpan" id="kobo.129.1"> and bring it back up with </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">LinkUp</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.131.1"> later:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.132.1">func</span></span><span class="koboSpan" id="kobo.133.1"> main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.134.1">/* ... </span><span class="koboSpan" id="kobo.134.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.134.3">*/</span></span><span class="koboSpan" id="kobo.135.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.136.1">var</span></span><span class="koboSpan" id="kobo.137.1"> loopback </span><span class="Code_Red"><span class="koboSpan" id="kobo.138.1">*</span></span><span class="koboSpan" id="kobo.139.1">net.Interface
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.140.1">for</span></span><span class="koboSpan" id="kobo.141.1"> _, l :</span><span class="Code_Red"><span class="koboSpan" id="kobo.142.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.143.1">range</span></span><span class="koboSpan" id="kobo.144.1"> links {
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.145.1">if</span></span><span class="koboSpan" id="kobo.146.1"> l.Name </span><span class="Code_Red"><span class="koboSpan" id="kobo.147.1">== "lo"</span></span><span class="koboSpan" id="kobo.148.1"> {
            loopback </span><span class="Code_Red"><span class="koboSpan" id="kobo.149.1">=</span></span><span class="koboSpan" id="kobo.150.1"> l
            log.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.151.1">"Name: %s, Flags:%s\n",</span></span><span class="koboSpan" id="kobo.152.1"> 
                        l.Name, l.Flags)
        }
    }
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.153.1">/* ... </span><span class="koboSpan" id="kobo.153.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.153.3">*/</span></span><span class="koboSpan" id="kobo.154.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.155.1">After running </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">LinkDown</span></strong><span class="koboSpan" id="kobo.157.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">LinkUp</span></strong><span class="koboSpan" id="kobo.159.1">, you can verify that the change had the desired effect by </span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.160.1">retrieving the interface settings from Netlink after </span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.161.1">each change. </span><span class="koboSpan" id="kobo.161.2">We update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">loopback</span></strong><span class="koboSpan" id="kobo.163.1"> variable for a uniform </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">printed statement:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.165.1">func</span></span><span class="koboSpan" id="kobo.166.1"> main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.167.1">/* ... </span><span class="koboSpan" id="kobo.167.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.167.3">*/</span></span><span class="koboSpan" id="kobo.168.1">
    conn.LinkDown(loopback)
    loopback, _ </span><span class="Code_Red"><span class="koboSpan" id="kobo.169.1">=</span></span><span class="koboSpan" id="kobo.170.1"> conn.LinkByIndex(loopback.Index)
    log.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.171.1">"Name: %s, Flags:%s\n", </span></span><span class="koboSpan" id="kobo.172.1">
                loopback.Name, loopback.Flags)
    conn.LinkUp(loopback)
    loopback, _ </span><span class="Code_Red"><span class="koboSpan" id="kobo.173.1">=</span></span><span class="koboSpan" id="kobo.174.1"> conn.LinkByIndex(loopback.Index)
    log.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.175.1">"Name: %s, Flags:%s\n", </span></span><span class="koboSpan" id="kobo.176.1">
                loopback.Name, loopback.Flags)
}</span></pre>
<p><span class="koboSpan" id="kobo.177.1">You can find this example in full in </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">ch04/netlink</span></strong><span class="koboSpan" id="kobo.179.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.180.1">Further reading</span></em><span class="koboSpan" id="kobo.181.1">) and you must run it with </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">CAP_NET_ADMIN</span></strong><span class="koboSpan" id="kobo.183.1"> capabilities (</span><em class="italic"><span class="koboSpan" id="kobo.184.1">Further reading</span></em><span class="koboSpan" id="kobo.185.1">) or </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">as root:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.187.1">ch04/netlink </span><span class="Code_Blue"><span class="koboSpan" id="kobo.188.1">$ sudo</span></span><span class="koboSpan" id="kobo.189.1"> go run main.go
</span><span class="Code_Green"><span class="koboSpan" id="kobo.190.1">2021</span></span><span class="koboSpan" id="kobo.191.1">/11/</span><span class="Code_Green"><span class="koboSpan" id="kobo.192.1">24</span></span><span class="koboSpan" id="kobo.193.1"> 20:55:29 Name: lo, Flags:up|loopback
</span><span class="Code_Green"><span class="koboSpan" id="kobo.194.1">2021</span></span><span class="koboSpan" id="kobo.195.1">/11/</span><span class="Code_Green"><span class="koboSpan" id="kobo.196.1">24</span></span><span class="koboSpan" id="kobo.197.1"> 20:55:29 Name: lo, Flags:loopback
</span><span class="Code_Green"><span class="koboSpan" id="kobo.198.1">2021</span></span><span class="koboSpan" id="kobo.199.1">/11/</span><span class="Code_Green"><span class="koboSpan" id="kobo.200.1">24</span></span><span class="koboSpan" id="kobo.201.1"> 20:55:29 Name: lo, Flags:up|loopback</span></pre>
<p><span class="koboSpan" id="kobo.202.1">We’ve only just scratched the surface of the Netlink API as its abilities extend far beyond the scope of this book. </span><span class="koboSpan" id="kobo.202.2">Today, you can use Netlink for everything from IP route management </span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.203.1">to access lists and from </span><strong class="bold"><span class="koboSpan" id="kobo.204.1">Quality of Service</span></strong><span class="koboSpan" id="kobo.205.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.206.1">QoS</span></strong><span class="koboSpan" id="kobo.207.1">) policies </span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.208.1">to </span><strong class="bold"><span class="koboSpan" id="kobo.209.1">extended Berkeley Packet Filter</span></strong><span class="koboSpan" id="kobo.210.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.211.1">eBPF</span></strong><span class="koboSpan" id="kobo.212.1">) program attachments. </span><span class="koboSpan" id="kobo.212.2">Hopefully, this section provides enough information to give you an idea of what’s involved in Netlink API interactions, as now we have to move on to the next topic and explore how Go deals with the most widely used link layer protocol </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">today: Ethernet.</span></span></p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.214.1">Ethernet</span></h2>
<p><span class="koboSpan" id="kobo.215.1">Working with </span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.216.1">Ethernet may involve a wide range of activities, from low-level protocol decoding, manipulating, and encoding to interactions with device APIs to </span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.217.1">collect Ethernet hardware information. </span><span class="koboSpan" id="kobo.217.2">Go has a broad spectrum of packages to help you deal with various </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">Ethernet-related tasks:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.219.1">One of the most widely used packet processing packages is </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">google/gopacket</span></strong><span class="koboSpan" id="kobo.221.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.222.1">Further reading</span></em><span class="koboSpan" id="kobo.223.1">), which you can use for both packet capturing and protocol decoding. </span><span class="koboSpan" id="kobo.223.2">It goes beyond just Ethernet, and we cover it in more detail in </span><a href="B16971_10.xhtml#_idTextAnchor225"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.224.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.225.1">, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.226.1">Network Monitoring</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.228.1">The Netlink API packages we just covered can query link-layer hardware information for Linux-based </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">operating systems.</span></span></li>
<li><span class="koboSpan" id="kobo.230.1">Another Ethernet encoding and decoding package </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">mdlayher/ethernet</span></strong><span class="koboSpan" id="kobo.232.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.233.1">Further reading</span></em><span class="koboSpan" id="kobo.234.1">) allows you to convert frames between binary wire format and a static Go </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">type representation.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.236.1">In the next example, we cover a basic implementation of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">virtual IP</span></strong><span class="koboSpan" id="kobo.238.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">VIP</span></strong><span class="koboSpan" id="kobo.240.1">) capability. </span><span class="koboSpan" id="kobo.240.2">We loosely based this implementation on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">kube-vip</span></strong><span class="koboSpan" id="kobo.242.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.243.1">Further reading</span></em><span class="koboSpan" id="kobo.244.1">) package – a Kubernetes control plane VIP controller. </span><span class="koboSpan" id="kobo.244.2">The way it works is a </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">two-step process:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.246.1">It allocates </span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.247.1">a new </span><strong class="bold"><span class="koboSpan" id="kobo.248.1">VIP</span></strong><span class="koboSpan" id="kobo.249.1"> to one of the local </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">network interfaces.</span></span></li>
<li><span class="koboSpan" id="kobo.251.1">It periodically </span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.252.1">sends out gratuitous </span><strong class="bold"><span class="koboSpan" id="kobo.253.1">Address Resolution Protocol</span></strong><span class="koboSpan" id="kobo.254.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.255.1">ARP</span></strong><span class="koboSpan" id="kobo.256.1">) packets to let everyone in the local broadcast domain know about </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">this VIP.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.258.1">Let’s review this from the first step and see how we assign a VIP to an interface. </span><span class="koboSpan" id="kobo.258.2">We’ll use the same package to interact with Netlink as we used in the </span><em class="italic"><span class="koboSpan" id="kobo.259.1">Network interfaces</span></em><span class="koboSpan" id="kobo.260.1"> section (</span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">rtnetlink/rtnl</span></strong><span class="koboSpan" id="kobo.262.1">), only this time we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">AddrAdd</span></strong><span class="koboSpan" id="kobo.264.1"> method to assign an IP prefix to the interface </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">we specify.</span></span></p>
<p><span class="koboSpan" id="kobo.266.1">In the </span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.267.1">program, we pass the name of the interface we want to assign to this </span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.268.1">VIP address via the CLI using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">flag</span></strong><span class="koboSpan" id="kobo.270.1"> package and we store this value in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">intfStr </span></strong><span class="koboSpan" id="kobo.272.1">variable. </span><span class="koboSpan" id="kobo.272.2">With this info, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">mdlayher/packet</span></strong><span class="koboSpan" id="kobo.274.1"> package to send and receive ARP packets over this interface with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">Listen</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.276.1"> function:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.277.1">func</span></span><span class="koboSpan" id="kobo.278.1"> main() {
    intfStr :</span><span class="Code_Red"><span class="koboSpan" id="kobo.279.1">=</span></span><span class="koboSpan" id="kobo.280.1"> flag.String(</span><span class="Code_Red"><span class="koboSpan" id="kobo.281.1">"intf"</span></span><span class="koboSpan" id="kobo.282.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.283.1">""</span></span><span class="koboSpan" id="kobo.284.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.285.1">"VIP interface"</span></span><span class="koboSpan" id="kobo.286.1">)
    flag.Parse()
    conn, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.287.1">=</span></span><span class="koboSpan" id="kobo.288.1"> rtnl.Dial(</span><span class="Code_Blue"><span class="koboSpan" id="kobo.289.1">nil</span></span><span class="koboSpan" id="kobo.290.1">)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.291.1">// process error</span></span><span class="koboSpan" id="kobo.292.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.293.1">defer</span></span><span class="koboSpan" id="kobo.294.1"> conn.Close()
    netIntf, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.295.1">=</span></span><span class="koboSpan" id="kobo.296.1"> net.InterfaceByName(</span><span class="Code_Red"><span class="koboSpan" id="kobo.297.1">*</span></span><span class="koboSpan" id="kobo.298.1">intfStr)
    ethSocket, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.299.1">=</span></span><span class="koboSpan" id="kobo.300.1"> packet.Listen(netIntf,
                                packet.Raw, 0, </span><span class="Code_Blue"><span class="koboSpan" id="kobo.301.1">nil</span></span><span class="koboSpan" id="kobo.302.1">)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.303.1">// process error</span></span><span class="koboSpan" id="kobo.304.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.305.1">defer</span></span><span class="koboSpan" id="kobo.306.1"> ethSocket.Close()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.307.1">/* ... </span><span class="koboSpan" id="kobo.307.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.307.3">*/</span></span><span class="koboSpan" id="kobo.308.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.309.1">To actually assign the VIP address to the interface, we create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">vip</span></strong><span class="koboSpan" id="kobo.311.1"> struct type that lets us hold all the information we need to pass to </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">AddrAdd</span></strong><span class="koboSpan" id="kobo.313.1"> to make this happen, as the next </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">output shows:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.315.1">const</span></span><span class="koboSpan" id="kobo.316.1"> VIP1 </span><span class="Code_Red"><span class="koboSpan" id="kobo.317.1">= "198.51.100.1/32"</span></span>
<span class="Code_Purple"><span class="koboSpan" id="kobo.318.1">type</span></span><span class="koboSpan" id="kobo.319.1"> vip </span><span class="Code_Purple"><span class="koboSpan" id="kobo.320.1">struct</span></span><span class="koboSpan" id="kobo.321.1"> {
    IP      </span><span class="Code_Purple"><span class="koboSpan" id="kobo.322.1">string</span></span><span class="koboSpan" id="kobo.323.1">
    netlink </span><span class="Code_Red"><span class="koboSpan" id="kobo.324.1">*</span></span><span class="koboSpan" id="kobo.325.1">rtnl.Conn
    intf    </span><span class="Code_Red"><span class="koboSpan" id="kobo.326.1">*</span></span><span class="koboSpan" id="kobo.327.1">net.Interface
    l2Sock  </span><span class="Code_Red"><span class="koboSpan" id="kobo.328.1">*</span></span><span class="koboSpan" id="kobo.329.1">raw.Conn
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.330.1">func</span></span><span class="koboSpan" id="kobo.331.1"> (c </span><span class="Code_Red"><span class="koboSpan" id="kobo.332.1">*</span></span><span class="koboSpan" id="kobo.333.1">vip) addVIP() </span><span class="Code_Purple"><span class="koboSpan" id="kobo.334.1">error</span></span><span class="koboSpan" id="kobo.335.1"> {
    err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.336.1">=</span></span><span class="koboSpan" id="kobo.337.1"> c.netlink.AddrAdd(c.intf,
                        rtnl.MustParseAddr(c.IP))
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.338.1">// process error</span></span><span class="koboSpan" id="kobo.339.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.340.1">return</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.341.1">nil</span></span><span class="koboSpan" id="kobo.342.1">
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.343.1">func</span></span> <span class="No-Break"><span class="koboSpan" id="kobo.344.1">main</span></span><span class="koboSpan" id="kobo.345.1">() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.346.1">/* ... </span><span class="koboSpan" id="kobo.346.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.346.3">*/</span></span><span class="koboSpan" id="kobo.347.1">
    v :</span><span class="Code_Red"><span class="koboSpan" id="kobo.348.1">= &amp;</span></span><span class="koboSpan" id="kobo.349.1">vip{
        IP:      VIP1,
        intf:    netIntf,
        netlink: rtnl,
        l2Sock:  *packet.Conn,
    }
    err </span><span class="Code_Red"><span class="koboSpan" id="kobo.350.1">=</span></span><span class="koboSpan" id="kobo.351.1"> v.addVIP()
     </span><span class="Code_Brown"><span class="koboSpan" id="kobo.352.1">/* ... </span><span class="koboSpan" id="kobo.352.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.352.3">*/</span></span><span class="koboSpan" id="kobo.353.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.354.1">Once we have </span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.355.1">the new VIP assigned, we can start sending out the </span><strong class="bold"><span class="koboSpan" id="kobo.356.1">Gratuitous ARP</span></strong><span class="koboSpan" id="kobo.357.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.358.1">GARP</span></strong><span class="koboSpan" id="kobo.359.1">) packets. </span><span class="koboSpan" id="kobo.359.2">We do </span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.360.1">that in a constant </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">for</span></strong><span class="koboSpan" id="kobo.362.1"> loop, which </span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.363.1">sleeps for 3 seconds and runs again. </span><span class="koboSpan" id="kobo.363.2">In this loop, we include an </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">if</span></strong><span class="koboSpan" id="kobo.365.1"> with initialization (</span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">err := v.sendGARP()</span></strong><span class="koboSpan" id="kobo.367.1">) and conditional (</span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">err != nil</span></strong><span class="koboSpan" id="kobo.369.1">) statements. </span><span class="koboSpan" id="kobo.369.2">Go executes the  initialization statement before evaluating the </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">conditional expression:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.371.1">func</span></span><span class="koboSpan" id="kobo.372.1"> main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.373.1">/* ... </span><span class="koboSpan" id="kobo.373.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.373.3">*/</span></span><span class="koboSpan" id="kobo.374.1">
    for {
        select {
        </span><span class="Code_Brown"><span class="koboSpan" id="kobo.375.1">/* ... </span><span class="koboSpan" id="kobo.375.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.375.3">*/</span></span><span class="koboSpan" id="kobo.376.1">
        case &lt;-timer.C:
            </span><span class="Code_Purple"><span class="koboSpan" id="kobo.377.1">if</span></span><span class="koboSpan" id="kobo.378.1"> err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.379.1">=</span></span><span class="koboSpan" id="kobo.380.1"> v.sendGARP(); err </span><span class="Code_Red"><span class="koboSpan" id="kobo.381.1">!=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.382.1">nil</span></span><span class="koboSpan" id="kobo.383.1"> {
                log.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.384.1">"fail send GARP %s",</span></span><span class="koboSpan" id="kobo.385.1">
                                err)
                cancel()
            }
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.386.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">sendGARP</span></strong><span class="koboSpan" id="kobo.388.1"> method is where we can find most of the Ethernet-related code. </span><span class="koboSpan" id="kobo.388.2">Here, we use two packages to help us build </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">the </span></span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">GARP</span></span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.392.1">We first need to build the GARP payload and populate it with the MAC address of the local interface and the IP address of the VIP. </span><span class="koboSpan" id="kobo.392.2">For this, we take advantage of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">mdlayher/arp</span></strong><span class="koboSpan" id="kobo.394.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.395.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.396.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">) package:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.398.1">func</span></span><span class="koboSpan" id="kobo.399.1"> (c *vip) sendGARP() </span><span class="Code_Purple"><span class="koboSpan" id="kobo.400.1">error</span></span><span class="koboSpan" id="kobo.401.1"> {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.402.1">/* ... </span><span class="koboSpan" id="kobo.402.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.402.3">*/</span></span><span class="koboSpan" id="kobo.403.1">
    arpPayload, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.404.1">=</span></span><span class="koboSpan" id="kobo.405.1"> arp.NewPacket(
        arp.OperationReply,  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.406.1">// op</span></span><span class="koboSpan" id="kobo.407.1">
        c.intf.HardwareAddr, </span><span class="Code_Brown"><span class="koboSpan" id="kobo.408.1">// srcHW</span></span><span class="koboSpan" id="kobo.409.1">
        ip,                  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.410.1">// srcIP</span></span><span class="koboSpan" id="kobo.411.1">
        c.intf.HardwareAddr, </span><span class="Code_Brown"><span class="koboSpan" id="kobo.412.1">// dstHW</span></span><span class="koboSpan" id="kobo.413.1">
        ip,                  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.414.1">// dstIP</span></span><span class="koboSpan" id="kobo.415.1">
    )
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.416.1">// process error</span></span><span class="koboSpan" id="kobo.417.1">
 
    arpBinary, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.418.1">=</span></span><span class="koboSpan" id="kobo.419.1"> arpPayload.MarshalBinary()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.420.1">/* ... </span><span class="koboSpan" id="kobo.420.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.420.3">*/</span></span><span class="koboSpan" id="kobo.421.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.422.1">Then we </span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.423.1">need to wrap the GARP payload inside an Ethernet frame </span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.424.1">and set the right Ethernet headers using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">mdlayher/ethernet</span></strong><span class="koboSpan" id="kobo.426.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.427.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.428.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">) package:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.430.1">func</span></span><span class="koboSpan" id="kobo.431.1"> (c *vip) sendGARP() </span><span class="Code_Purple"><span class="koboSpan" id="kobo.432.1">error</span></span><span class="koboSpan" id="kobo.433.1"> {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.434.1">/* ... </span><span class="koboSpan" id="kobo.434.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.434.3">*/</span></span><span class="koboSpan" id="kobo.435.1">
    ethFrame :</span><span class="Code_Red"><span class="koboSpan" id="kobo.436.1">= &amp;</span></span><span class="koboSpan" id="kobo.437.1">ethernet.Frame{
        Destination: ethernet.Broadcast,
        Source:      c.intf.HardwareAddr,
        EtherType:   ethernet.EtherTypeARP,
        Payload:     arpBinary,
    }
 
    return c.emitFrame(ethFrame)
}</span></pre>
<p><span class="koboSpan" id="kobo.438.1">The last step is to send a binary frame and to do that, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">mdlayher/packet</span></strong><span class="koboSpan" id="kobo.440.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.441.1">Further reading</span></em><span class="koboSpan" id="kobo.442.1">) package that implements the Linux packet socket interface that lets us send and </span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.443.1">receive packets at the device driver (link-layer) level. </span><span class="koboSpan" id="kobo.443.2">We have </span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.444.1">already opened a raw socket, </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">ethSocket</span></strong><span class="koboSpan" id="kobo.446.1">, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">Listen</span></strong><span class="koboSpan" id="kobo.448.1"> as shown earlier, so now we can write our binary frame into it (</span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">field l2Sock</span></strong><span class="koboSpan" id="kobo.450.1"> of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">vip</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.452.1"> struct):</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.453.1">func</span></span><span class="koboSpan" id="kobo.454.1"> (c *vip) emitFrame(frame *ethernet.Frame) </span><span class="Code_Purple"><span class="koboSpan" id="kobo.455.1">error</span></span><span class="koboSpan" id="kobo.456.1"> {
    b, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.457.1">=</span></span><span class="koboSpan" id="kobo.458.1"> frame.MarshalBinary()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.459.1">// process error</span></span><span class="koboSpan" id="kobo.460.1">
 
    addr :</span><span class="Code_Red"><span class="koboSpan" id="kobo.461.1">= &amp;</span></span><span class="koboSpan" id="kobo.462.1">packet.Addr{
                HardwareAddr:ethernet.Broadcast}
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.463.1">if</span></span><span class="koboSpan" id="kobo.464.1"> _, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.465.1">=</span></span><span class="koboSpan" id="kobo.466.1"> c.l2Sock.WriteTo(b, addr); err </span><span class="Code_Red"><span class="koboSpan" id="kobo.467.1">!=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.468.1">nil</span></span><span class="koboSpan" id="kobo.469.1"> {
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.470.1">return</span></span><span class="koboSpan" id="kobo.471.1"> fmt.Errorf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.472.1">"emitFrame failed: %s"</span></span><span class="koboSpan" id="kobo.473.1">, err)
    }
 
    log.Println("GARP sent")
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.474.1">return</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.475.1">nil</span></span><span class="koboSpan" id="kobo.476.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.477.1">You can find the full example at </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">ch04/vip</span></strong><span class="koboSpan" id="kobo.479.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.480.1">Further reading</span></em><span class="koboSpan" id="kobo.481.1">). </span><span class="koboSpan" id="kobo.481.2">You need to run it with elevated privileges to be able to make changes to network interfaces. </span><span class="koboSpan" id="kobo.481.3">The resulting output would look </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.483.1">ch04/vip </span><span class="Code_Blue"><span class="koboSpan" id="kobo.484.1">$ sudo</span></span><span class="koboSpan" id="kobo.485.1"> go run main.go </span><span class="Code_Blue"><span class="koboSpan" id="kobo.486.1">-intf</span></span><span class="koboSpan" id="kobo.487.1"> eth0
</span><span class="Code_Green"><span class="koboSpan" id="kobo.488.1">2021</span></span><span class="koboSpan" id="kobo.489.1">/11/25 </span><span class="Code_Green"><span class="koboSpan" id="kobo.490.1">18</span></span><span class="koboSpan" id="kobo.491.1">:47:51 GARP sent
</span><span class="Code_Green"><span class="koboSpan" id="kobo.492.1">2021</span></span><span class="koboSpan" id="kobo.493.1">/11/25 </span><span class="Code_Green"><span class="koboSpan" id="kobo.494.1">18</span></span><span class="koboSpan" id="kobo.495.1">:47:54 GARP sent
^C2021/11/25 </span><span class="Code_Green"><span class="koboSpan" id="kobo.496.1">18</span></span><span class="koboSpan" id="kobo.497.1">:47:56 Received syscall: interrupt
</span><span class="Code_Green"><span class="koboSpan" id="kobo.498.1">2021</span></span><span class="koboSpan" id="kobo.499.1">/11/25 </span><span class="Code_Green"><span class="koboSpan" id="kobo.500.1">18</span></span><span class="koboSpan" id="kobo.501.1">:47:57 Cleanup complete</span></pre>
<p><span class="koboSpan" id="kobo.502.1">At this point, any host with an overlapping IP subnet on the local network segment should be able to ping the </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">198.51.100.1</span></strong><span class="koboSpan" id="kobo.504.1"> address (if they accept GARPs). </span><span class="koboSpan" id="kobo.504.2">To end the program, you can press </span><em class="italic"><span class="koboSpan" id="kobo.505.1">Ctrl</span></em><span class="koboSpan" id="kobo.506.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.507.1">C</span></em><span class="koboSpan" id="kobo.508.1"> and the program cleans up the VIP from </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">the interface.</span></span></p>
<p><span class="koboSpan" id="kobo.510.1">It’s rare for </span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.511.1">a network engineer or a developer to interact with Ethernet </span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.512.1">directly, but it’s still worth knowing what it feels like to </span><em class="italic"><span class="koboSpan" id="kobo.513.1">talk Ethernet</span></em><span class="koboSpan" id="kobo.514.1"> using Go. </span><span class="koboSpan" id="kobo.514.2">In the next section, we move one layer up and cover the internet layer packages </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">and examples.</span></span></p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.516.1">The internet layer</span></h1>
<p><span class="koboSpan" id="kobo.517.1">The internet layer </span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.518.1">or network layer in the OSI model is in charge of transferring variable-length network packets and routing data from a source to a destination through one or </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">more networks.</span></span></p>
<p><span class="koboSpan" id="kobo.520.1">The predominant </span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.521.1">protocol in this layer today is the </span><strong class="bold"><span class="koboSpan" id="kobo.522.1">Internet Protocol</span></strong><span class="koboSpan" id="kobo.523.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.524.1">IP</span></strong><span class="koboSpan" id="kobo.525.1">) on either of its two versions: version 4 (IPv4) or version 6 (IPv6). </span><span class="koboSpan" id="kobo.525.2">The internet </span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.526.1">layer also includes diagnostic protocols such as </span><strong class="bold"><span class="koboSpan" id="kobo.527.1">Internet Control Message Protocol</span></strong><span class="koboSpan" id="kobo.528.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.529.1">ICMP</span></strong><span class="koboSpan" id="kobo.530.1">), a secure network </span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.531.1">protocol suite such as </span><strong class="bold"><span class="koboSpan" id="kobo.532.1">Internet Protocol Security</span></strong><span class="koboSpan" id="kobo.533.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.534.1">IPsec</span></strong><span class="koboSpan" id="kobo.535.1">), and </span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.536.1">routing protocols including </span><strong class="bold"><span class="koboSpan" id="kobo.537.1">Open Shortest Path </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.538.1">First</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.539.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.540.1">OSPF</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.542.1">The IP exchanges information via IP datagrams built from a header and a payload, which the link layer then transmits as frames over specific network hardware such as Ethernet. </span><span class="koboSpan" id="kobo.542.2">The IP header carries the IP source and destination addresses of a packet used to route it through </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">the internet.</span></span></p>
<p><span class="koboSpan" id="kobo.544.1">In this section, we review </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.546.1">How to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">net</span></strong><span class="koboSpan" id="kobo.548.1"> package to parse and perform common tasks with </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">IP addresses</span></span></li>
<li><span class="koboSpan" id="kobo.550.1">The new </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">net/netip</span></strong><span class="koboSpan" id="kobo.552.1"> package and what features it brings to the Go </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">standard library</span></span></li>
<li><span class="koboSpan" id="kobo.554.1">Examples of real-life Go projects that work with </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">IP addresses</span></span></li>
</ul>
<h2 id="_idParaDest-117"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.556.1">The net package</span></h2>
<p><span class="koboSpan" id="kobo.557.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">net</span></strong><span class="koboSpan" id="kobo.559.1"> package (</span><em class="italic"><span class="koboSpan" id="kobo.560.1">Further reading</span></em><span class="koboSpan" id="kobo.561.1">) from the standard library includes a wide range of tools and resources for network connectivity and, most importantly for this section, defines </span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.562.1">types and interfaces to work with IP addresses. </span><span class="koboSpan" id="kobo.562.2">One of </span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.563.1">these types is </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">IP</span></strong><span class="koboSpan" id="kobo.565.1">, represented as a slice of bytes. </span><span class="koboSpan" id="kobo.565.2">This type is valid for 4-byte (IPv4) or 16-byte (</span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">IPv6) slices:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.567.1">type</span></span><span class="koboSpan" id="kobo.568.1"> IP []</span><span class="Code_Purple"><span class="koboSpan" id="kobo.569.1">byte</span></span></pre>
<p><span class="koboSpan" id="kobo.570.1">Let’s first explore how we can create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">IP</span></strong><span class="koboSpan" id="kobo.572.1"> type variable, from the decimal representation of the IPv4 </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">address </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">192.0.2.1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer046">
<span class="koboSpan" id="kobo.576.1"><img alt="Figure 4.2 – An IPv4 address" src="image/B16971_04_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.577.1">Figure 4.2 – An IPv4 address</span></p>
<p><span class="koboSpan" id="kobo.578.1">One way to turn an IPv4 address into an IP type is by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">ParseIP</span></strong><span class="koboSpan" id="kobo.580.1"> function from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">net</span></strong><span class="koboSpan" id="kobo.582.1"> package, which takes a string as an argument and returns an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">IP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.584.1"> value:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.585.1">func</span></span><span class="koboSpan" id="kobo.586.1"> main() {
    ipv4 :</span><span class="Code_Red"><span class="koboSpan" id="kobo.587.1">=</span></span><span class="koboSpan" id="kobo.588.1"> net.ParseIP(</span><span class="Code_Red"><span class="koboSpan" id="kobo.589.1">"192.0.2.1"</span></span><span class="koboSpan" id="kobo.590.1">)
    fmt.Println(ipv4)
}</span></pre>
<p><span class="koboSpan" id="kobo.591.1">IPv6 addresses are a bit harder for our eyes to process, but to Go they are yet another slice of bits just </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">like IPv4:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer047">
<span class="koboSpan" id="kobo.593.1"><img alt="Figure 4.3 – An IPv6 address" src="image/B16971_04_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.594.1">Figure 4.3 – An IPv6 address</span></p>
<p><span class="koboSpan" id="kobo.595.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">ParseIP</span></strong><span class="koboSpan" id="kobo.597.1"> function can also parse a string representation of an IPv6 to return the variable of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">IP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.599.1"> type:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.600.1">func</span></span><span class="koboSpan" id="kobo.601.1"> main() {
    ipv6 :</span><span class="Code_Red"><span class="koboSpan" id="kobo.602.1">=</span></span><span class="koboSpan" id="kobo.603.1"> net.ParseIP(</span><span class="Code_Red"><span class="koboSpan" id="kobo.604.1">"FC02:F00D::1"</span></span><span class="koboSpan" id="kobo.605.1">)
    fmt.Println(ipv6)
}</span></pre>
<p><span class="koboSpan" id="kobo.606.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">IP</span></strong><span class="koboSpan" id="kobo.608.1"> type represents an IP address, so you can use the same IP methods for either IPv4 or IPv6 </span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.609.1">addresses. </span><span class="koboSpan" id="kobo.609.2">Let’s say you want to check whether </span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.610.1">an IP address is within a private address range. </span></p>
<p><span class="koboSpan" id="kobo.611.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">IsPrivate</span></strong><span class="koboSpan" id="kobo.613.1"> method from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">net</span></strong><span class="koboSpan" id="kobo.615.1"> package gives you that answer based on RFC 1918 (Address Allocation for Private Internets) and RFC 4193 (Unique Local IPv6 Unicast Addresses) for both IPv4 and </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">IPv6 automatically:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.617.1">func</span></span><span class="koboSpan" id="kobo.618.1"> main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.619.1">// prints false</span></span><span class="koboSpan" id="kobo.620.1">
    fmt.Println(ipv4.IsPrivate())
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.621.1">// prints true</span></span><span class="koboSpan" id="kobo.622.1">
    fmt.Println(ipv6.IsPrivate())
}</span></pre>
<p><span class="koboSpan" id="kobo.623.1">Another interesting type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">IPNet</span></strong><span class="koboSpan" id="kobo.625.1">, which describes an IP prefix or an IP network, so it adds </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">IPMask</span></strong><span class="koboSpan" id="kobo.627.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">IP</span></strong><span class="koboSpan" id="kobo.629.1"> to represent </span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">its mask:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.631.1">type</span></span><span class="koboSpan" id="kobo.632.1"> IPNet </span><span class="Code_Purple"><span class="koboSpan" id="kobo.633.1">struct</span></span><span class="koboSpan" id="kobo.634.1"> {
    IP   IP     </span><span class="Code_Brown"><span class="koboSpan" id="kobo.635.1">// network number</span></span><span class="koboSpan" id="kobo.636.1">
    Mask IPMask </span><span class="Code_Brown"><span class="koboSpan" id="kobo.637.1">// network mask</span></span><span class="koboSpan" id="kobo.638.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.639.1">A mask in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">net</span></strong><span class="koboSpan" id="kobo.641.1"> package is also a slice of bytes, which is better explained with the following </span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.642.1">example using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">CIDRMask</span></strong><span class="koboSpan" id="kobo.644.1"> function. </span><span class="koboSpan" id="kobo.644.2">Both </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">ones</span></strong><span class="koboSpan" id="kobo.646.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">bits</span></strong><span class="koboSpan" id="kobo.648.1"> arguments </span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.649.1">are integers as the function signature indicates. </span><span class="koboSpan" id="kobo.649.2">The first argument, </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">ones</span></strong><span class="koboSpan" id="kobo.651.1">, is the number of ones in </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">IPMask</span></strong><span class="koboSpan" id="kobo.653.1"> and the remaining bits are all set to zero. </span><span class="koboSpan" id="kobo.653.2">The total length of the mask is measured </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">bits</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.657.1">type</span></span><span class="koboSpan" id="kobo.658.1"> IPMask []</span><span class="Code_Purple"><span class="koboSpan" id="kobo.659.1">byte</span></span>
<span class="Code_Purple"><span class="koboSpan" id="kobo.660.1">func</span></span><span class="koboSpan" id="kobo.661.1"> CIDRMask(ones, bits </span><span class="Code_Purple"><span class="koboSpan" id="kobo.662.1">int</span></span><span class="koboSpan" id="kobo.663.1">) IPMask</span></pre>
<p><span class="koboSpan" id="kobo.664.1">Let’s see an example for IPv4, with a </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">32-bit mask:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.666.1">func</span></span><span class="koboSpan" id="kobo.667.1"> main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.668.1">// This mask corresponds to a /31 subnet for IPv4.</span></span><span class="koboSpan" id="kobo.669.1">
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.670.1">// prints [11111111 11111111 11111111 11111110]</span></span><span class="koboSpan" id="kobo.671.1">
    fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.672.1">"%b\n"</span></span><span class="koboSpan" id="kobo.673.1">,net.CIDRMask(</span><span class="Code_Green"><span class="koboSpan" id="kobo.674.1">31</span></span><span class="koboSpan" id="kobo.675.1">, </span><span class="Code_Green"><span class="koboSpan" id="kobo.676.1">32</span></span><span class="koboSpan" id="kobo.677.1">))
}</span></pre>
<p><span class="koboSpan" id="kobo.678.1">IPv6 works similarly but expects a mask length </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">of 128:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.680.1">func</span></span><span class="koboSpan" id="kobo.681.1"> main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.682.1">// This mask corresponds to a /64 subnet for IPv6.</span></span><span class="koboSpan" id="kobo.683.1">
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.684.1">// prints ffffffffffffffff0000000000000000</span></span><span class="koboSpan" id="kobo.685.1">
    fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.686.1">"%s\n"</span></span><span class="koboSpan" id="kobo.687.1">,net.CIDRMask(</span><span class="Code_Green"><span class="koboSpan" id="kobo.688.1">64</span></span><span class="koboSpan" id="kobo.689.1">, </span><span class="Code_Green"><span class="koboSpan" id="kobo.690.1">128</span></span><span class="koboSpan" id="kobo.691.1">))
}</span></pre>
<p><span class="koboSpan" id="kobo.692.1">To parse a prefix or network from a string, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">ParseCIDR</span></strong><span class="koboSpan" id="kobo.694.1"> function from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">net</span></strong><span class="koboSpan" id="kobo.696.1"> package. </span><span class="koboSpan" id="kobo.696.2">You get three values – a network address of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">IP</span></strong><span class="koboSpan" id="kobo.698.1"> type, an IP prefix of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">IPnet</span></strong><span class="koboSpan" id="kobo.700.1"> type, and </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">an error:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.702.1">func</span></span><span class="koboSpan" id="kobo.703.1"> main() {
    ipv4Addr, ipv4Net, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.704.1">=</span></span><span class="koboSpan" id="kobo.705.1"> net.ParseCIDR(</span><span class="Code_Red"><span class="koboSpan" id="kobo.706.1">"192.0.2.1/24"</span></span><span class="koboSpan" id="kobo.707.1">)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.708.1">// process error</span></span><span class="koboSpan" id="kobo.709.1">
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.710.1">// prints 192.0.2.1</span></span><span class="koboSpan" id="kobo.711.1">
    fmt.Println(ipv4Addr)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.712.1">// prints 192.0.2.0/24</span></span><span class="koboSpan" id="kobo.713.1">
    fmt.Println(ipv4Net)
}</span></pre>
<p><span class="koboSpan" id="kobo.714.1">The next </span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.715.1">example </span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.716.1">shows </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">ParseCIDR</span></strong><span class="koboSpan" id="kobo.718.1"> for IPv6 using the same functions as </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">with IPv4:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.720.1">func</span></span><span class="koboSpan" id="kobo.721.1"> main() {
    ipv6Addr, ipv6Net, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.722.1">=</span></span><span class="koboSpan" id="kobo.723.1">  net.ParseCIDR(
                                </span><span class="Code_Red"><span class="koboSpan" id="kobo.724.1">"2001:db8:a0b:12f0::1/32"</span></span><span class="koboSpan" id="kobo.725.1">)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.726.1">// process error</span></span><span class="koboSpan" id="kobo.727.1">
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.728.1">// prints 2001:db8:a0b:12f0::1</span></span><span class="koboSpan" id="kobo.729.1">
    fmt.Println(ipv6Addr)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.730.1">// prints 2001:db8::/32</span></span><span class="koboSpan" id="kobo.731.1">
    fmt.Println(ipv6Net)
}</span></pre>
<p><span class="koboSpan" id="kobo.732.1">The code for these examples is available at </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">ch04/net/main.go</span></strong><span class="koboSpan" id="kobo.734.1"> (</span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.735.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.737.1">This is the standard way of doing basic operations with IP addresses in Go. </span><span class="koboSpan" id="kobo.737.2">Yet not long ago there was an effort to add a new IP address type to the standard library, via a package that we </span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">review next.</span></span></p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.739.1">The New netip package</span></h2>
<p><span class="koboSpan" id="kobo.740.1">With the goal </span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.741.1">of improving some things that weren’t great about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">net.IP</span></strong><span class="koboSpan" id="kobo.743.1"> data structure </span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.744.1">for IP addresses in Go, a group of Go developers came up with a new IP address type. </span><span class="koboSpan" id="kobo.744.2">This was an iterative process that they documented in the blog post </span><em class="italic"><span class="koboSpan" id="kobo.745.1">netaddr.IP: a new IP address type for Go</span></em><span class="koboSpan" id="kobo.746.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.747.1">Further reading</span></em><span class="koboSpan" id="kobo.748.1">). </span><span class="koboSpan" id="kobo.748.2">This package is now available in Go 1.18 </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">net/netip</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.751.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.752.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">net/netip</span></strong><span class="koboSpan" id="kobo.754.1"> package defines a new type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">Addr</span></strong><span class="koboSpan" id="kobo.756.1">, that stores both IPv4 and IPv6 addresses as a big-endian 128-bit number. </span><span class="koboSpan" id="kobo.756.2">This type also has a special sentinel field </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">z</span></strong><span class="koboSpan" id="kobo.758.1">, which can have any of </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">these values:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">nil</span></strong><span class="koboSpan" id="kobo.761.1"> means an invalid IP address (for a </span><span class="No-Break"><span class="koboSpan" id="kobo.762.1">zero </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">Addr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">).</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">z4</span></strong><span class="koboSpan" id="kobo.766.1"> means an </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">IPv4 address.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">z6noz</span></strong><span class="koboSpan" id="kobo.769.1"> means an IPv6 address without </span><span class="No-Break"><span class="koboSpan" id="kobo.770.1">a zone.</span></span></li>
<li><span class="koboSpan" id="kobo.771.1">Otherwise, it’s the IPv6 zone </span><span class="No-Break"><span class="koboSpan" id="kobo.772.1">name string.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.773.1">The data structure in Go looks </span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">as follows:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.775.1">type</span></span><span class="koboSpan" id="kobo.776.1"> Addr </span><span class="Code_Purple"><span class="koboSpan" id="kobo.777.1">struct</span></span><span class="koboSpan" id="kobo.778.1"> {
    addr uint128
    z </span><span class="Code_Red"><span class="koboSpan" id="kobo.779.1">*</span></span><span class="koboSpan" id="kobo.780.1">intern.Value
}</span></pre>
<p><span class="koboSpan" id="kobo.781.1">This new </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">Addr</span></strong><span class="koboSpan" id="kobo.783.1"> type has the following major benefits compared to the </span><span class="No-Break"><span class="koboSpan" id="kobo.784.1">legacy </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">net.IP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.787.1">It takes up less memory. </span></li>
<li><span class="koboSpan" id="kobo.788.1">It’s immutable and, hence, safe to pass around. </span></li>
<li><span class="koboSpan" id="kobo.789.1">It supports </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">==</span></strong><span class="koboSpan" id="kobo.791.1"> operations and, hence, you can use it as a </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">map key.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.793.1">Let’s see some examples of how to parse an IP address from a string to get an </span><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">Addr</span></strong><span class="koboSpan" id="kobo.795.1"> type and use it with some methods available in the package. </span><span class="koboSpan" id="kobo.795.2">In the first example, we parse an IPv4 address and check whether it’s within the RFC 1112 </span><strong class="source-inline"><span class="koboSpan" id="kobo.796.1">224.0.0.0/4</span></strong><span class="koboSpan" id="kobo.797.1"> multicast range with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">IsMulticast  </span></strong><span class="koboSpan" id="kobo.799.1">method. </span><span class="koboSpan" id="kobo.799.2">A second example for IPv6 shows how to parse an IP address from a string with the same function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.800.1">ParseAddr</span></strong><span class="koboSpan" id="kobo.801.1">, and checks whether </span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.802.1">the IPv6 is a Link-Local address or part of the network </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">FE80::/10</span></strong><span class="koboSpan" id="kobo.804.1"> according to </span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.805.1">the RFC 4291 with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">IsLinkLocalUnicast</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.807.1"> method:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.808.1">func</span></span><span class="koboSpan" id="kobo.809.1"> main() {
    IPv4, err := netip.ParseAddr(</span><span class="Code_Red"><span class="koboSpan" id="kobo.810.1">"224.0.0.1"</span></span><span class="koboSpan" id="kobo.811.1">)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.812.1">// process error</span></span><span class="koboSpan" id="kobo.813.1">
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.814.1">// prints IPv4 address is Multicast</span></span><span class="koboSpan" id="kobo.815.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.816.1">if</span></span><span class="koboSpan" id="kobo.817.1"> IPv4.IsMulticast() {
        fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.818.1">"IPv4 address is Multicast"</span></span><span class="koboSpan" id="kobo.819.1">)
    }
    IPv6, err := netip.ParseAddr(</span><span class="Code_Red"><span class="koboSpan" id="kobo.820.1">"FE80:F00D::1"</span></span><span class="koboSpan" id="kobo.821.1">)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.822.1">// process error</span></span><span class="koboSpan" id="kobo.823.1">
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.824.1">// prints IPv6 address is Link Local Unicast</span></span><span class="koboSpan" id="kobo.825.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.826.1">if</span></span><span class="koboSpan" id="kobo.827.1"> IPv6.IsLinkLocalUnicast() {
        fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.828.1">"IPv6 address is Link Local Unicast"</span></span><span class="koboSpan" id="kobo.829.1">)
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.830.1">Now, if you have an existing program that uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">net.IP</span></strong><span class="koboSpan" id="kobo.832.1">, you can use that type as input for </span><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">netip</span></strong><span class="koboSpan" id="kobo.834.1"> as well. </span><span class="koboSpan" id="kobo.834.2">For both IPv4 and IPv6, it parses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">net.IP</span></strong><span class="koboSpan" id="kobo.836.1"> type with the function </span><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">AddrFromSlice</span></strong><span class="koboSpan" id="kobo.838.1">. </span><span class="koboSpan" id="kobo.838.2">The method </span><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">IsX</span></strong><span class="koboSpan" id="kobo.840.1"> tells us whether this is an IPv4 or </span><span class="No-Break"><span class="koboSpan" id="kobo.841.1">IPv6 address:</span></span></p>
<pre class="source-code"><span class="Code_Red"><span class="koboSpan" id="kobo.842.1">func</span></span><span class="koboSpan" id="kobo.843.1"> main() {
    ipv4 :</span><span class="Code_Red"><span class="koboSpan" id="kobo.844.1">=</span></span><span class="koboSpan" id="kobo.845.1"> net.ParseIP(</span><span class="Code_Red"><span class="koboSpan" id="kobo.846.1">"192.0.2.1"</span></span><span class="koboSpan" id="kobo.847.1">)
    IPv4s, _ :</span><span class="Code_Red"><span class="koboSpan" id="kobo.848.1">=</span></span><span class="koboSpan" id="kobo.849.1"> netip.AddrFromSlice(ipv4)
    fmt.Println(IPv4s.String())
    fmt.Println(IPv4s.Unmap().Is4())
}</span></pre>
<p><span class="koboSpan" id="kobo.850.1">The code </span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.851.1">for this example is available at </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">ch04/parseip</span></strong><span class="koboSpan" id="kobo.853.1"> (</span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.854.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.855.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.856.1">ch04/parseip$ go run main.go
::ffff:192.0.2.1
true</span></pre>
<p><span class="koboSpan" id="kobo.857.1">To represent </span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.858.1">an IP prefix (CIDR), </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">net/netip</span></strong><span class="koboSpan" id="kobo.860.1"> defines a type called </span><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">Prefix</span></strong><span class="koboSpan" id="kobo.862.1"> that has an </span><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">Addr</span></strong><span class="koboSpan" id="kobo.864.1"> and an integer to specify the prefix length (from 0 to 128) in the </span><span class="No-Break"><span class="koboSpan" id="kobo.865.1">field </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">bits</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.867.1">:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.868.1">type</span></span><span class="koboSpan" id="kobo.869.1"> Prefix </span><span class="Code_Purple"><span class="koboSpan" id="kobo.870.1">struct</span></span><span class="koboSpan" id="kobo.871.1"> {
    ip Addr
    bits </span><span class="Code_Purple"><span class="koboSpan" id="kobo.872.1">int16</span></span><span class="koboSpan" id="kobo.873.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.874.1">To parse a prefix from a string, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">ParsePrefix</span></strong><span class="koboSpan" id="kobo.876.1"> function or </span><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">MustParsePrefix</span></strong><span class="koboSpan" id="kobo.878.1">, which calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">ParsePrefix</span></strong><span class="koboSpan" id="kobo.880.1"> and panics on error, which means you don’t have to check the returned error in your code. </span><span class="koboSpan" id="kobo.880.2">Let’s look at a program that uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">MustParsePrefix</span></strong><span class="koboSpan" id="kobo.882.1"> to generate a prefix, and then checks whether some IP addresses are in the address range of </span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">that prefix:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.884.1">func</span></span><span class="koboSpan" id="kobo.885.1"> main() {
    addr1 :</span><span class="Code_Red"><span class="koboSpan" id="kobo.886.1">= "192.0.2.18"</span></span><span class="koboSpan" id="kobo.887.1">
    addr2 :</span><span class="Code_Red"><span class="koboSpan" id="kobo.888.1">= "198.51.100.3"</span></span><span class="koboSpan" id="kobo.889.1">
    network4 :</span><span class="Code_Red"><span class="koboSpan" id="kobo.890.1">= "192.0.2.0/24"</span></span><span class="koboSpan" id="kobo.891.1">
    pf :</span><span class="Code_Red"><span class="koboSpan" id="kobo.892.1">=</span></span><span class="koboSpan" id="kobo.893.1"> netip.MustParsePrefix(network4)
    fmt.Printf(
        </span><span class="Code_Red"><span class="koboSpan" id="kobo.894.1">"Prefix address: %v, length: %v\n",</span></span><span class="koboSpan" id="kobo.895.1"> 
        pf.Addr(), pf.Bits())
    ip1 :</span><span class="Code_Red"><span class="koboSpan" id="kobo.896.1">=</span></span><span class="koboSpan" id="kobo.897.1"> netip.MustParseAddr(addr1)
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.898.1">if</span></span><span class="koboSpan" id="kobo.899.1"> pf.Contains(ip1) {
        fmt.Println(addr1, </span><span class="Code_Red"><span class="koboSpan" id="kobo.900.1">" is in "</span></span><span class="koboSpan" id="kobo.901.1">, network4)
    }
    ip2 :</span><span class="Code_Red"><span class="koboSpan" id="kobo.902.1">=</span></span><span class="koboSpan" id="kobo.903.1"> netip.MustParseAddr(addr2)
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.904.1">if</span></span><span class="koboSpan" id="kobo.905.1"> pf.Contains(ip2) {
        fmt.Println(addr2, </span><span class="Code_Red"><span class="koboSpan" id="kobo.906.1">" is in "</span></span><span class="koboSpan" id="kobo.907.1">, network4)
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.908.1">We define </span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.909.1">the prefix </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">pf</span></strong><span class="koboSpan" id="kobo.911.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">network4</span></strong><span class="koboSpan" id="kobo.913.1"> string </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">192.0.2.0/24</span></strong><span class="koboSpan" id="kobo.915.1">. </span><span class="koboSpan" id="kobo.915.2">Then, we </span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.916.1">check whether addresses </span><strong class="source-inline"><span class="koboSpan" id="kobo.917.1">192.0.2.18</span></strong><span class="koboSpan" id="kobo.918.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.919.1">198.51.100.3</span></strong><span class="koboSpan" id="kobo.920.1"> are in this network by printing a message if they are. </span><span class="koboSpan" id="kobo.920.2">This program prints </span><span class="No-Break"><span class="koboSpan" id="kobo.921.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.922.1">ch04/parseprefix$ go run main.go</span><strong class="bold"> </strong><span class="koboSpan" id="kobo.923.1">
Prefix address: </span><span class="Code_Green"><span class="koboSpan" id="kobo.924.1">192</span></span><span class="koboSpan" id="kobo.925.1">.0.2.0, length: </span><span class="Code_Green"><span class="koboSpan" id="kobo.926.1">24</span></span>
<span class="Code_Green"><span class="koboSpan" id="kobo.927.1">192</span></span><span class="koboSpan" id="kobo.928.1">.0.2.18  is in  </span><span class="Code_Green"><span class="koboSpan" id="kobo.929.1">192</span></span><span class="koboSpan" id="kobo.930.1">.0.2.0/24</span></pre>
<p><span class="koboSpan" id="kobo.931.1">The code for this example is available at </span><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">ch04/parseprefix</span></strong><span class="koboSpan" id="kobo.933.1"> (</span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.934.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.935.1">).</span></span></p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.936.1">Working with IP addresses</span></h2>
<p><span class="koboSpan" id="kobo.937.1">After </span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.938.1">parsing IP addresses, you are only one step from several real-world </span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.939.1">applications you can put into practice. </span><span class="koboSpan" id="kobo.939.2">We cover just a few </span><span class="No-Break"><span class="koboSpan" id="kobo.940.1">examples here:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.941.1">Route lookups</span></span></li>
<li><span class="koboSpan" id="kobo.942.1">Geo </span><span class="No-Break"><span class="koboSpan" id="kobo.943.1">IP data</span></span></li>
<li><span class="koboSpan" id="kobo.944.1">Extra IP </span><span class="No-Break"><span class="koboSpan" id="kobo.945.1">address functions</span></span></li>
</ul>
<h2 id="_idParaDest-120"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.946.1">Route lookups</span></h2>
<p><span class="koboSpan" id="kobo.947.1">One way to do a route lookup or find the longest prefix match for an IP address is by using a trie </span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.948.1">data structure (prefix tree). </span><span class="koboSpan" id="kobo.948.2">Tries are very efficient in both memory </span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.949.1">and speed, which is why we use them for IP prefix lookups. </span><span class="koboSpan" id="kobo.949.2">To do this in Go, you can use one of the available packages. </span><span class="koboSpan" id="kobo.949.3">In this case, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.950.1">cidranger</span></strong><span class="koboSpan" id="kobo.951.1"> (</span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.952.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.953.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.954.1">We start by defining a new path-compressed prefix trie and add a list of parsed IP addresses from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.955.1">IPs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.956.1"> variable:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.957.1">func</span></span><span class="koboSpan" id="kobo.958.1"> main() {
    ranger :</span><span class="Code_Red"><span class="koboSpan" id="kobo.959.1">=</span></span><span class="koboSpan" id="kobo.960.1"> cidranger.NewPCTrieRanger()
    IPs := []</span><span class="Code_Purple"><span class="koboSpan" id="kobo.961.1">string</span></span><span class="koboSpan" id="kobo.962.1">{
        </span><span class="Code_Red"><span class="koboSpan" id="kobo.963.1">"100.64.0.0/16",</span></span>
<span class="Code_Red"><span class="koboSpan" id="kobo.964.1">        "127.0.0.0/8",</span></span>
<span class="Code_Red"><span class="koboSpan" id="kobo.965.1">        "172.16.0.0/16",</span></span>
<span class="Code_Red"><span class="koboSpan" id="kobo.966.1">        "192.0.2.0/24",</span></span>
<span class="Code_Red"><span class="koboSpan" id="kobo.967.1">        "192.0.2.0/24",</span></span>
<span class="Code_Red"><span class="koboSpan" id="kobo.968.1">        "192.0.2.0/25",</span></span>
<span class="Code_Red"><span class="koboSpan" id="kobo.969.1">        "192.0.2.127/25",</span></span><span class="koboSpan" id="kobo.970.1">
    }
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.971.1">for</span></span><span class="koboSpan" id="kobo.972.1"> _, prefix :</span><span class="Code_Red"><span class="koboSpan" id="kobo.973.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.974.1">range</span></span><span class="koboSpan" id="kobo.975.1"> IPs {
        ipv4Addr, ipv4Net, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.976.1">=</span></span><span class="koboSpan" id="kobo.977.1"> net.ParseCIDR(prefix)
       </span><span class="Code_Brown"><span class="koboSpan" id="kobo.978.1"> // process error</span></span><span class="koboSpan" id="kobo.979.1">
        ranger.Insert(
                cidranger.NewBasicRangerEntry(</span><span class="Code_Red"><span class="koboSpan" id="kobo.980.1">*</span></span><span class="koboSpan" id="kobo.981.1">ipv4Net))
    }
   </span><span class="Code_Brown"><span class="koboSpan" id="kobo.982.1"> /* ... </span><span class="koboSpan" id="kobo.982.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.982.3">*/</span></span><span class="koboSpan" id="kobo.983.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.984.1">Now we </span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.985.1">can check whether any IP is within the defined list </span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.986.1">of IP address ranges. </span><span class="koboSpan" id="kobo.986.2">Here, we find that </span><strong class="source-inline"><span class="koboSpan" id="kobo.987.1">127.0.0.1</span></strong><span class="koboSpan" id="kobo.988.1"> is in at least one IP prefix on </span><span class="No-Break"><span class="koboSpan" id="kobo.989.1">the list:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.990.1">func</span></span><span class="koboSpan" id="kobo.991.1"> main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.992.1">/* ... </span><span class="koboSpan" id="kobo.992.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.992.3">*/</span></span><span class="koboSpan" id="kobo.993.1">
    checkIP :</span><span class="Code_Red"><span class="koboSpan" id="kobo.994.1">= "127.0.0.1"</span></span><span class="koboSpan" id="kobo.995.1">
    ok, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.996.1">=</span></span><span class="koboSpan" id="kobo.997.1"> ranger.Contains(net.ParseIP(checkIP))
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.998.1">    // process error</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.999.1">    // prints Does the range contain 127.0.0.1?: true</span></span><span class="koboSpan" id="kobo.1000.1">
    fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1001.1">"Does the range contain %s?: %v\n",</span></span><span class="koboSpan" id="kobo.1002.1">
                    checkIP, ok)
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1003.1">    /* ... </span><span class="koboSpan" id="kobo.1003.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.1003.3">*/</span></span><span class="koboSpan" id="kobo.1004.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.1005.1">One other </span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.1006.1">thing you could do is to request a list of networks </span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.1007.1">that contain an IP address, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1008.1">192.0.2.18</span></strong><span class="koboSpan" id="kobo.1009.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.1010.1">this case:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1011.1">func</span></span><span class="koboSpan" id="kobo.1012.1"> main() {
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1013.1">    /* ... </span><span class="koboSpan" id="kobo.1013.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.1013.3">*/</span></span><span class="koboSpan" id="kobo.1014.1">
    netIP :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1015.1">= "192.0.2.18"</span></span><span class="koboSpan" id="kobo.1016.1">
    nets, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1017.1">=</span></span><span class="koboSpan" id="kobo.1018.1"> ranger.ContainingNetworks(
                            net.ParseIP(netIP))
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1019.1">// process error</span></span><span class="koboSpan" id="kobo.1020.1">
    fmt.Printf(
    </span><span class="Code_Red"><span class="koboSpan" id="kobo.1021.1">"\nNetworks that contain IP address %s -&gt;\n",</span></span><span class="koboSpan" id="kobo.1022.1"> netIP)
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1023.1">for</span></span><span class="koboSpan" id="kobo.1024.1"> _, e :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1025.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.1026.1">range</span></span><span class="koboSpan" id="kobo.1027.1"> nets {
        n :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1028.1">=</span></span><span class="koboSpan" id="kobo.1029.1"> e.Network()
        fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1030.1">"\t"</span></span><span class="koboSpan" id="kobo.1031.1">, n.String())
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.1032.1">This returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.1033.1">192.0.2.0/24</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1034.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1035.1">192.0.2.0/25</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1036.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1037.1">ch04/trie</span><span class="Code_Blue"><span class="koboSpan" id="kobo.1038.1">$ go</span></span><span class="koboSpan" id="kobo.1039.1"> run main.go
Networks that contain IP address </span><span class="Code_Green"><span class="koboSpan" id="kobo.1040.1">192</span></span><span class="koboSpan" id="kobo.1041.1">.0.2.18 -&gt;
     </span><span class="Code_Green"><span class="koboSpan" id="kobo.1042.1">192</span></span><span class="koboSpan" id="kobo.1043.1">.0.2.0/24
     </span><span class="Code_Green"><span class="koboSpan" id="kobo.1044.1">192</span></span><span class="koboSpan" id="kobo.1045.1">.0.2.0/25</span></pre>
<p><span class="koboSpan" id="kobo.1046.1">The code of this example is available at </span><strong class="source-inline"><span class="koboSpan" id="kobo.1047.1">ch04/trie/main.go</span></strong><span class="koboSpan" id="kobo.1048.1"> (</span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1049.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1050.1">).</span></span></p>
<h3><span class="koboSpan" id="kobo.1051.1">Geo IP data</span></h3>
<p><span class="koboSpan" id="kobo.1052.1">Another interesting use case is to get the geographical location associated with a public IP address. </span><span class="koboSpan" id="kobo.1052.2">To make this query, you need access to a database that you can download for free </span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.1053.1">from GeoLite2 Free Geolocation Data (</span><em class="italic"><span class="koboSpan" id="kobo.1054.1">Further reading</span></em><span class="koboSpan" id="kobo.1055.1">) or you can </span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.1056.1">just use the sample file we included in the book’s repo, which has support for a limited number of IP addresses, but enough to run </span><span class="No-Break"><span class="koboSpan" id="kobo.1057.1">the examples.</span></span></p>
<p><span class="koboSpan" id="kobo.1058.1">We open the database file, and for each IP address in a slice, we query for any available information, which we then print to </span><span class="No-Break"><span class="koboSpan" id="kobo.1059.1">the terminal:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1060.1">func</span></span><span class="koboSpan" id="kobo.1061.1"> main() {
    db, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1062.1">=</span></span><span class="koboSpan" id="kobo.1063.1"> geoip2.Open(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1064.1">"GeoIP2-City-Test.mmdb"</span></span><span class="koboSpan" id="kobo.1065.1">)
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1066.1">    // process error </span></span><span class="koboSpan" id="kobo.1067.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1068.1">defer</span></span><span class="koboSpan" id="kobo.1069.1"> db.Close()
    IPs :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1070.1">=</span></span><span class="koboSpan" id="kobo.1071.1"> []</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1072.1">string</span></span><span class="koboSpan" id="kobo.1073.1">{
</span><span class="Code_Red"><span class="koboSpan" id="kobo.1074.1">        "81.2.69.143",</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.1075.1">        /* ... </span><span class="koboSpan" id="kobo.1075.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.1075.3">*/</span></span><span class="koboSpan" id="kobo.1076.1">
    }
    fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1077.1">"Find information for each prefix:"</span></span><span class="koboSpan" id="kobo.1078.1">)
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1079.1">for</span></span><span class="koboSpan" id="kobo.1080.1"> _, prefix :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1081.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.1082.1">range</span></span><span class="koboSpan" id="kobo.1083.1"> IPs {
        ip :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1084.1">=</span></span><span class="koboSpan" id="kobo.1085.1"> net.ParseIP(prefix)
        record, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1086.1">=</span></span><span class="koboSpan" id="kobo.1087.1"> db.City(ip)
        </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1088.1">// process error</span></span><span class="koboSpan" id="kobo.1089.1">
    
        fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1090.1">"\nAddress: %v\n"</span></span><span class="koboSpan" id="kobo.1091.1">, prefix)
        fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1092.1">"City name: %v\n"</span></span><span class="koboSpan" id="kobo.1093.1">,
                        record.City.Names[</span><span class="Code_Red"><span class="koboSpan" id="kobo.1094.1">"en"</span></span><span class="koboSpan" id="kobo.1095.1">])
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1096.1">        /* ... </span><span class="koboSpan" id="kobo.1096.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.1096.3">*/</span></span><span class="koboSpan" id="kobo.1097.1">
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.1098.1">One </span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.1099.1">output </span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.1100.1">example is </span><span class="No-Break"><span class="koboSpan" id="kobo.1101.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1102.1">ch04/geo$ go run main.go
Find information for each prefix:
...
</span><span class="koboSpan" id="kobo.1102.2">Address: </span><span class="Code_Green"><span class="koboSpan" id="kobo.1103.1">81</span></span><span class="koboSpan" id="kobo.1104.1">.2.69.143
City name: Norwich
Country name: United Kingdom
ISO country code: GB
Time zone: Europe/London
Coordinates: </span><span class="Code_Green"><span class="koboSpan" id="kobo.1105.1">52</span></span><span class="koboSpan" id="kobo.1106.1">.6259, </span><span class="Code_Green"><span class="koboSpan" id="kobo.1107.1">1</span></span><span class="koboSpan" id="kobo.1108.1">.3032</span></pre>
<p><span class="koboSpan" id="kobo.1109.1">The code for this example is available at </span><strong class="source-inline"><span class="koboSpan" id="kobo.1110.1">ch04/geo/main.go</span></strong><span class="koboSpan" id="kobo.1111.1"> (</span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1112.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1113.1">).</span></span></p>
<h3><span class="koboSpan" id="kobo.1114.1">Extra IP address functions</span></h3>
<p><span class="koboSpan" id="kobo.1115.1">If you come </span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.1116.1">from another programming language </span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.1117.1">such as Python, you might be familiar with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1118.1">ipaddress</span></strong><span class="koboSpan" id="kobo.1119.1"> library to manipulate IP addresses and networks. </span><span class="koboSpan" id="kobo.1119.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1120.1">iplib</span></strong><span class="koboSpan" id="kobo.1121.1"> package (</span><em class="italic"><span class="koboSpan" id="kobo.1122.1">Further reading</span></em><span class="koboSpan" id="kobo.1123.1">) is an effort to bring those features </span><span class="No-Break"><span class="koboSpan" id="kobo.1124.1">to Go.</span></span></p>
<p><span class="koboSpan" id="kobo.1125.1">In the next example, we see a function to increment an IP address by one (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1126.1">NextIP</span></strong><span class="koboSpan" id="kobo.1127.1">) and another function to increase an IP address by any number (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1128.1">IncrementIPBy</span></strong><span class="koboSpan" id="kobo.1129.1">). </span><span class="koboSpan" id="kobo.1129.2">We then compute the difference between the original IP address and the result after these two increments with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1130.1">DeltaIP</span></strong><span class="koboSpan" id="kobo.1131.1"> function to find out the number of IP addresses </span><span class="No-Break"><span class="koboSpan" id="kobo.1132.1">in between.</span></span></p>
<p><span class="koboSpan" id="kobo.1133.1">The last line of the example compares two IP addresses with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1134.1">CompareIPs</span></strong><span class="koboSpan" id="kobo.1135.1"> function. </span><span class="koboSpan" id="kobo.1135.2">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.1136.1">a</span></strong><span class="koboSpan" id="kobo.1137.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1138.1">b</span></strong><span class="koboSpan" id="kobo.1139.1"> are the inputs, it returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.1140.1">0</span></strong><span class="koboSpan" id="kobo.1141.1"> if </span><strong class="source-inline"><span class="koboSpan" id="kobo.1142.1">a == b</span></strong><span class="koboSpan" id="kobo.1143.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1144.1">-1</span></strong><span class="koboSpan" id="kobo.1145.1"> if </span><strong class="source-inline"><span class="koboSpan" id="kobo.1146.1">a &lt; b</span></strong><span class="koboSpan" id="kobo.1147.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1148.1">1</span></strong><span class="koboSpan" id="kobo.1149.1"> if </span><strong class="source-inline"><span class="koboSpan" id="kobo.1150.1">a &gt; </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1151.1">b</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1152.1">:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1153.1">func</span></span><span class="koboSpan" id="kobo.1154.1"> main() {
    IP :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1155.1">=</span></span><span class="koboSpan" id="kobo.1156.1"> net.ParseIP(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1157.1">"192.0.2.1"</span></span><span class="koboSpan" id="kobo.1158.1">)
    nextIP :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1159.1">=</span></span><span class="koboSpan" id="kobo.1160.1"> iplib.NextIP(IP)
    incrIP :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1161.1">=</span></span><span class="koboSpan" id="kobo.1162.1"> iplib.IncrementIPBy(nextIP, </span><span class="Code_Green"><span class="koboSpan" id="kobo.1163.1">19</span></span><span class="koboSpan" id="kobo.1164.1">)
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1165.1">    // prints 20</span></span><span class="koboSpan" id="kobo.1166.1">
    fmt.Println(iplib.DeltaIP(IP, incrIP))
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1167.1">    // prints -1</span></span><span class="koboSpan" id="kobo.1168.1">
    fmt.Println(iplib.CompareIPs(IP, incrIP))
}</span></pre>
<p><span class="koboSpan" id="kobo.1169.1">Because </span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.1170.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1171.1">iplib</span></strong><span class="koboSpan" id="kobo.1172.1"> package allows you to compare IP addresses, it means </span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.1173.1">you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1174.1">sort</span></strong><span class="koboSpan" id="kobo.1175.1"> package to sort a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1176.1">net.IP</span></strong><span class="koboSpan" id="kobo.1177.1"> addresses as the next example shows, using the addresses we </span><span class="No-Break"><span class="koboSpan" id="kobo.1178.1">just created:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1179.1">func</span></span><span class="koboSpan" id="kobo.1180.1"> main() {
    iplist :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1181.1">=</span></span><span class="koboSpan" id="kobo.1182.1"> []net.IP{incrIP, nextIP, IP}
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1183.1">    // prints [192.0.2.21 192.0.2.2 192.0.2.1]</span></span><span class="koboSpan" id="kobo.1184.1">
    fmt.Println(iplist)
    sort.Sort(iplib.ByIP(iplist))
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1185.1">    // prints [192.0.2.1 192.0.2.2 192.0.2.21]</span></span><span class="koboSpan" id="kobo.1186.1">
    fmt.Println(iplist) 
}</span></pre>
<p><span class="koboSpan" id="kobo.1187.1">You can also generate an array of IP addresses from a network, starting at any IP address with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1188.1">Enumerate</span></strong><span class="koboSpan" id="kobo.1189.1"> method. </span><span class="koboSpan" id="kobo.1189.2">In the next example, we take the network </span><strong class="source-inline"><span class="koboSpan" id="kobo.1190.1">198.51.100.0/24</span></strong><span class="koboSpan" id="kobo.1191.1">, count the total available addresses in it with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1192.1">Count</span></strong><span class="koboSpan" id="kobo.1193.1">, to then generate an array of size 3 with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1194.1">Enumerate</span></strong><span class="koboSpan" id="kobo.1195.1">, starting from the first available IP address of the network (</span><span class="No-Break"><span class="koboSpan" id="kobo.1196.1">index 0):</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1197.1">func</span></span><span class="koboSpan" id="kobo.1198.1"> main() {
    n4 :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1199.1">=</span></span><span class="koboSpan" id="kobo.1200.1"> iplib.NewNet4(net.ParseIP(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1201.1">"198.51.100.0"</span></span><span class="koboSpan" id="kobo.1202.1">), </span><span class="Code_Green"><span class="koboSpan" id="kobo.1203.1">24</span></span><span class="koboSpan" id="kobo.1204.1">)
    fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1205.1">"Total IP addresses: "</span></span><span class="koboSpan" id="kobo.1206.1">, n4.Count())
    fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1207.1">"First three IPs: "</span></span><span class="koboSpan" id="kobo.1208.1">, n4.Enumerate(</span><span class="Code_Green"><span class="koboSpan" id="kobo.1209.1">3</span></span><span class="koboSpan" id="kobo.1210.1">, </span><span class="Code_Green"><span class="koboSpan" id="kobo.1211.1">0</span></span><span class="koboSpan" id="kobo.1212.1">))
    fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1213.1">"First IP: "</span></span><span class="koboSpan" id="kobo.1214.1">, n4.FirstAddress())
    fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1215.1">"Last IP: "</span></span><span class="koboSpan" id="kobo.1216.1">, n4.LastAddress())
}</span></pre>
<p><span class="koboSpan" id="kobo.1217.1">This </span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.1218.1">program produces the </span><span class="No-Break"><span class="koboSpan" id="kobo.1219.1">following output:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1220.1">ch04/ipaddr$ go run main.go
...
</span><span class="koboSpan" id="kobo.1220.2">Total IP addresses:  </span><span class="Code_Green"><span class="koboSpan" id="kobo.1221.1">254</span></span><span class="koboSpan" id="kobo.1222.1">
First three IPs:  [198.51.100.1 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1223.1">198</span></span><span class="koboSpan" id="kobo.1224.1">.51.100.2 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1225.1">198</span></span><span class="koboSpan" id="kobo.1226.1">.51.100.3]
First IP:  </span><span class="Code_Green"><span class="koboSpan" id="kobo.1227.1">198</span></span><span class="koboSpan" id="kobo.1228.1">.51.100.1
Last IP:  </span><span class="Code_Green"><span class="koboSpan" id="kobo.1229.1">198</span></span><span class="koboSpan" id="kobo.1230.1">.51.100.254</span></pre>
<p><span class="koboSpan" id="kobo.1231.1">The code </span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.1232.1">for this example is available at </span><strong class="source-inline"><span class="koboSpan" id="kobo.1233.1">ch04/ipaddr/main.go</span></strong><span class="koboSpan" id="kobo.1234.1"> (</span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1235.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1236.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.1237.1">IP is the fundamental protocol on the internet, which has continued to support its evolution over the last 40 years without major changes, despite the fast pace of technological development in the last few decades. </span><span class="koboSpan" id="kobo.1237.2">Along with protocols from the transport layer, IP has allowed the decoupling of applications from hardware technologies such as coax cable, fiber optics, and Wi-Fi. </span><span class="koboSpan" id="kobo.1237.3">Speaking of the transport layer, in the next section, we explore how Go can help you navigate this layer of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1238.1">TCP/IP model.</span></span></p>
<h1 id="_idParaDest-121"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.1239.1">The transport layer</span></h1>
<p><span class="koboSpan" id="kobo.1240.1">The transport layer </span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.1241.1">protocols are the next OSI layer on top of IP and offer a communication channel abstraction. </span><span class="koboSpan" id="kobo.1241.2">The two most common protocols today are TCP, which offers a connection-oriented communication channel, and UDP, a </span><span class="No-Break"><span class="koboSpan" id="kobo.1242.1">connectionless protocol.</span></span></p>
<p><span class="koboSpan" id="kobo.1243.1">In Go, the way you interact with both protocols is similar, even though the underlying packet exchange may be completely different. </span><span class="koboSpan" id="kobo.1243.2">At a high level, there are only a few things that you need to keep in mind when dealing with TCP </span><span class="No-Break"><span class="koboSpan" id="kobo.1244.1">or UDP:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1245.1">Each TCP or UDP application works with a corresponding connection represented by a concrete </span><strong class="source-inline"><span class="koboSpan" id="kobo.1246.1">TCPConn</span></strong><span class="koboSpan" id="kobo.1247.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1248.1">UDPConn</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1249.1">type, respectively.</span></span></li>
<li><span class="koboSpan" id="kobo.1250.1">Go has other connection types with overlapping features such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1251.1">PacketConn</span></strong><span class="koboSpan" id="kobo.1252.1">, which deals with connectionless protocols (UDP and IP); </span><strong class="source-inline"><span class="koboSpan" id="kobo.1253.1">Conn</span></strong><span class="koboSpan" id="kobo.1254.1">, which covers IP, TCP, and UDP; and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1255.1">UnixConn</span></strong><span class="koboSpan" id="kobo.1256.1"> for connections to Unix domain sockets. </span><span class="koboSpan" id="kobo.1256.2">We only focus on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1257.1">TCPConn</span></strong><span class="koboSpan" id="kobo.1258.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1259.1">UDPConn</span></strong><span class="koboSpan" id="kobo.1260.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.1261.1">this section.</span></span></li>
<li><span class="koboSpan" id="kobo.1262.1">Clients use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1263.1">net.DialTCP</span></strong><span class="koboSpan" id="kobo.1264.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1265.1">net.DialUDP</span></strong><span class="koboSpan" id="kobo.1266.1"> to open a socket to a </span><span class="No-Break"><span class="koboSpan" id="kobo.1267.1">remote address.</span></span></li>
<li><span class="koboSpan" id="kobo.1268.1">Servers use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1269.1">net.ListenUDP</span></strong><span class="koboSpan" id="kobo.1270.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1271.1">net.ListenTCP</span></strong><span class="koboSpan" id="kobo.1272.1"> to open a listening socket that accepts connections from </span><span class="No-Break"><span class="koboSpan" id="kobo.1273.1">different clients.</span></span></li>
<li><span class="koboSpan" id="kobo.1274.1">Clients and servers can </span><strong class="source-inline"><span class="koboSpan" id="kobo.1275.1">Read</span></strong><span class="koboSpan" id="kobo.1276.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1277.1">Write</span></strong><span class="koboSpan" id="kobo.1278.1"> bytes from and to their </span><span class="No-Break"><span class="koboSpan" id="kobo.1279.1">respective connections.</span></span></li>
<li><span class="koboSpan" id="kobo.1280.1">When finished, both clients and servers need to close their connections to clean up the underlying </span><span class="No-Break"><span class="koboSpan" id="kobo.1281.1">file descriptor.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1282.1">The following figure illustrates the interactions between different types involved in a typical UDP </span><span class="No-Break"><span class="koboSpan" id="kobo.1283.1">client-server communication:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer048">
<span class="koboSpan" id="kobo.1284.1"><img alt="Figure 4.4 – UDP communication in Go" src="image/B16971_04_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1285.1">Figure 4.4 – UDP communication in Go</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1286.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1287.1">.4</span></em><span class="koboSpan" id="kobo.1288.1"> shows a UDP client sending one byte at a time, although in reality, the payload can </span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.1289.1">have more bytes. </span><span class="koboSpan" id="kobo.1289.2">This could be a DNS request or an RTP packet. </span><span class="koboSpan" id="kobo.1289.3">All network connection types implement </span><strong class="source-inline"><span class="koboSpan" id="kobo.1290.1">io.Reader</span></strong><span class="koboSpan" id="kobo.1291.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1292.1">io.Writer</span></strong><span class="koboSpan" id="kobo.1293.1"> interfaces, so reading and writing are similar no matter what protocol you </span><span class="No-Break"><span class="koboSpan" id="kobo.1294.1">use underneath.</span></span></p>
<p><span class="koboSpan" id="kobo.1295.1">The UDP client creates a UDP connection with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1296.1">net.DialUDP</span></strong><span class="koboSpan" id="kobo.1297.1"> and then writes (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1298.1">Write</span></strong><span class="koboSpan" id="kobo.1299.1">) a byte to it, just like when you make a request to the network. </span><span class="koboSpan" id="kobo.1299.2">On the server side, you read (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1300.1">Read</span></strong><span class="koboSpan" id="kobo.1301.1">) from the connection you would have created earlier </span><span class="No-Break"><span class="koboSpan" id="kobo.1302.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1303.1">net.ListenUDP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1304.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1305.1">Now, let’s move on to something a bit more concrete and see what a real UDP application may </span><span class="No-Break"><span class="koboSpan" id="kobo.1306.1">look like.</span></span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.1307.1">UDP ping application</span></h2>
<p><span class="koboSpan" id="kobo.1308.1">Ping is one of the most conventional ways of checking remote connectivity and end-to-end latency. </span><span class="koboSpan" id="kobo.1308.2">Just like the traditional ping, UDP ping uses echo replies to calculate latency and packet </span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.1309.1">loss but encapsulates them in a UDP packet instead of ICMP/NDP. </span><span class="koboSpan" id="kobo.1309.2">Many monitoring applications use this approach as it allows them </span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.1310.1">to discover and monitor various equal-cost paths in networks with devices that perform 5-tuple hashing. </span><span class="koboSpan" id="kobo.1310.2">One such application is Cloudprober (</span><em class="italic"><span class="koboSpan" id="kobo.1311.1">Further reading</span></em><span class="koboSpan" id="kobo.1312.1">), which is the source of inspiration for the next example, as the authors wrote it </span><span class="No-Break"><span class="koboSpan" id="kobo.1313.1">in Go.</span></span></p>
<p><span class="koboSpan" id="kobo.1314.1">Let’s walk through the code of a UDP ping application, focusing on connection establishment and data exchange. </span><span class="koboSpan" id="kobo.1314.2">You can find the full code in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1315.1">ch04/udp-ping</span></strong><span class="koboSpan" id="kobo.1316.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.1317.1">Further reading</span></em><span class="koboSpan" id="kobo.1318.1">) folder of the book’s repository (</span><em class="italic"><span class="koboSpan" id="kobo.1319.1">Further reading</span></em><span class="koboSpan" id="kobo.1320.1">). </span><span class="koboSpan" id="kobo.1320.2">At a high level, our UDP ping application consists of </span><span class="No-Break"><span class="koboSpan" id="kobo.1321.1">two parts:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1322.1">The server side listens on a UDP port and mirrors back any packets received from </span><span class="No-Break"><span class="koboSpan" id="kobo.1323.1">its clients.</span></span></li>
<li><span class="koboSpan" id="kobo.1324.1">The client that is sending UDP probes to a server receives a stream of mirrored packets coming back to compute the packet loss and </span><span class="No-Break"><span class="koboSpan" id="kobo.1325.1">end-to-end latency:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer049">
<span class="koboSpan" id="kobo.1326.1"><img alt="Figure 4.5 – UDP ping application" src="image/B16971_04_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1327.1">Figure 4.5 – UDP ping application</span></p>
<p><span class="koboSpan" id="kobo.1328.1">Let’s start </span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.1329.1">the overview of this application with the server side. </span><span class="koboSpan" id="kobo.1329.2">The program begins by building a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1330.1">UDPAddr</span></strong><span class="koboSpan" id="kobo.1331.1"> variable that describes a UDP socket. </span><span class="koboSpan" id="kobo.1331.2">We then </span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.1332.1">pass this variable to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1333.1">net.ListenUDP</span></strong><span class="koboSpan" id="kobo.1334.1"> to create a UDP socket and start listening for incoming packets. </span><span class="koboSpan" id="kobo.1334.2">The first argument in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1335.1">ListenUDP</span></strong><span class="koboSpan" id="kobo.1336.1"> function is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1337.1">udp</span></strong><span class="koboSpan" id="kobo.1338.1">, which specifies the dual-stack behavior (RFC6724 and RFC6555). </span><span class="koboSpan" id="kobo.1338.2">You could also use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1339.1">udp4</span></strong><span class="koboSpan" id="kobo.1340.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1341.1">udp6</span></strong><span class="koboSpan" id="kobo.1342.1"> to pin the program to either IPv4 or </span><span class="No-Break"><span class="koboSpan" id="kobo.1343.1">IPv6 respectively:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1344.1">func</span></span><span class="koboSpan" id="kobo.1345.1"> main() {
    listenAddr     </span><span class="Code_Red"><span class="koboSpan" id="kobo.1346.1">= "0.0.0.0"</span></span><span class="koboSpan" id="kobo.1347.1">
    listenPort     </span><span class="Code_Red"><span class="koboSpan" id="kobo.1348.1">=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1349.1">32767</span></span><span class="koboSpan" id="kobo.1350.1">
    listenSoc :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1351.1">= &amp;</span></span><span class="koboSpan" id="kobo.1352.1">net.UDPAddr{
        IP:   net.ParseIP(listenAddr),
        Port: listenPort,
    }
    udpConn, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1353.1">=</span></span><span class="koboSpan" id="kobo.1354.1"> net.ListenUDP(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1355.1">"udp"</span></span><span class="koboSpan" id="kobo.1356.1">, listenSoc)
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1357.1">    // process error</span></span><span class="koboSpan" id="kobo.1358.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1359.1">defer</span></span><span class="koboSpan" id="kobo.1360.1"> udpConn.Close()
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1361.1">    /* ... </span><span class="koboSpan" id="kobo.1361.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.1361.3">*/</span></span><span class="koboSpan" id="kobo.1362.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.1363.1">Once we have a listening UDP socket, we can start the main processing loop, which reads an </span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.1364.1">incoming packet into a byte slice with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1365.1">ReadFromUDP</span></strong><span class="koboSpan" id="kobo.1366.1"> and writes </span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.1367.1">the entire packet back to the sender </span><span class="No-Break"><span class="koboSpan" id="kobo.1368.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1369.1">WriteToUDP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1370.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1371.1">Since </span><strong class="source-inline"><span class="koboSpan" id="kobo.1372.1">ReadFromUDP</span></strong><span class="koboSpan" id="kobo.1373.1"> is a blocking function, most server implementations add an extra </span><strong class="source-inline"><span class="koboSpan" id="kobo.1374.1">SetReadDeadline</span></strong><span class="koboSpan" id="kobo.1375.1"> timeout to make sure the program can be gracefully terminated if needed. </span><span class="koboSpan" id="kobo.1375.2">In this case, it leads directly to the next loop iteration thanks to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1376.1">continue</span></strong><span class="koboSpan" id="kobo.1377.1"> statement </span><span class="No-Break"><span class="koboSpan" id="kobo.1378.1">after </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1379.1">ReadFromUDP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1380.1">:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1381.1">func</span></span><span class="koboSpan" id="kobo.1382.1"> main() {
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1383.1">    /* ... </span><span class="koboSpan" id="kobo.1383.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.1383.3">*/</span></span><span class="koboSpan" id="kobo.1384.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1385.1">for</span></span><span class="koboSpan" id="kobo.1386.1"> {
        maxReadBuffer  </span><span class="Code_Red"><span class="koboSpan" id="kobo.1387.1">=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1388.1">425984</span></span><span class="koboSpan" id="kobo.1389.1">
        bytes :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1390.1">=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.1391.1">make</span></span><span class="koboSpan" id="kobo.1392.1">([]</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1393.1">byte</span></span><span class="koboSpan" id="kobo.1394.1">, maxReadBuffer)
    
        retryTimeout   </span><span class="Code_Red"><span class="koboSpan" id="kobo.1395.1">=</span></span><span class="koboSpan" id="kobo.1396.1"> time.Second </span><span class="Code_Red"><span class="koboSpan" id="kobo.1397.1">*</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1398.1">5</span></span><span class="koboSpan" id="kobo.1399.1">
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1400.1">if</span></span><span class="koboSpan" id="kobo.1401.1"> err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1402.1">=</span></span><span class="koboSpan" id="kobo.1403.1"> udpConn.SetReadDeadline(
                        time.Now().Add(retryTimeout))
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1404.1">        // process error</span></span><span class="koboSpan" id="kobo.1405.1">
        </span><span class="Code_Blue"><span class="koboSpan" id="kobo.1406.1">len</span></span><span class="koboSpan" id="kobo.1407.1">, raddr, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1408.1">=</span></span><span class="koboSpan" id="kobo.1409.1"> udpConn.ReadFromUDP(bytes)
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1410.1">if</span></span><span class="koboSpan" id="kobo.1411.1"> err </span><span class="Code_Red"><span class="koboSpan" id="kobo.1412.1">!=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.1413.1">nil</span></span><span class="koboSpan" id="kobo.1414.1"> {
            log.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1415.1">"failed to ReadFromUDP: %s"</span></span><span class="koboSpan" id="kobo.1416.1">, err)
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1417.1">            continue</span></span><span class="koboSpan" id="kobo.1418.1">
        }
        log.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1419.1">"Received a probe from %s:%d",</span></span><span class="koboSpan" id="kobo.1420.1">
                        raddr.IP.String(), raddr.Port)
        n, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1421.1">=</span></span><span class="koboSpan" id="kobo.1422.1"> udpConn.WriteToUDP(bytes[:</span><span class="Code_Blue"><span class="koboSpan" id="kobo.1423.1">len</span></span><span class="koboSpan" id="kobo.1424.1">], raddr)
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1425.1">        // process error</span></span><span class="koboSpan" id="kobo.1426.1">
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.1427.1">The client-side implementation starts similarly, by </span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.1428.1">building a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1429.1">UDPAddr</span></strong><span class="koboSpan" id="kobo.1430.1"> variable and passing it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1431.1">net.DialUDP</span></strong><span class="koboSpan" id="kobo.1432.1"> function. </span><span class="koboSpan" id="kobo.1432.2">In the case of TCP, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1433.1">net.DialTCP</span></strong><span class="koboSpan" id="kobo.1434.1"> function would trigger a TCP three-way handshake, but in the case of UDP, the underlying OS opens a network socket without exchanging </span><span class="No-Break"><span class="koboSpan" id="kobo.1435.1">any packets:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1436.1">func</span></span><span class="koboSpan" id="kobo.1437.1"> main() {
    rAddr :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1438.1">= &amp;</span></span><span class="koboSpan" id="kobo.1439.1">net.UDPAddr{
        IP:   net.ParseIP(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1440.1">"127.0.0.1"</span></span><span class="koboSpan" id="kobo.1441.1">),
        Port: </span><span class="Code_Red"><span class="koboSpan" id="kobo.1442.1">"32767"</span></span><span class="koboSpan" id="kobo.1443.1">,
    }
    udpConn, err := net.DialUDP(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1444.1">"udp"</span></span><span class="koboSpan" id="kobo.1445.1">, </span><span class="Code_Blue"><span class="koboSpan" id="kobo.1446.1">nil</span></span><span class="koboSpan" id="kobo.1447.1">, rAddr)
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1448.1">    // process error</span></span><span class="koboSpan" id="kobo.1449.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1450.1">defer</span></span><span class="koboSpan" id="kobo.1451.1"> udpConn.Close()
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1452.1">    /* ... </span><span class="koboSpan" id="kobo.1452.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.1452.3">*/</span></span><span class="koboSpan" id="kobo.1453.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.1454.1">At this point, the program branches out in two directions. </span><span class="koboSpan" id="kobo.1454.2">The logical first step is the packet sending routine, which in this case runs inside the main goroutine of the program. </span><span class="koboSpan" id="kobo.1454.3">In the background, we also fire off a goroutine that runs the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1455.1">receive</span></strong><span class="koboSpan" id="kobo.1456.1"> function, which we discuss a few </span><span class="No-Break"><span class="koboSpan" id="kobo.1457.1">paragraphs later.</span></span></p>
<p><span class="koboSpan" id="kobo.1458.1">Inside each </span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.1459.1">probe packet we send, we embed a </span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.1460.1">monotonically increasing sequence number and the value of a current timestamp. </span><span class="koboSpan" id="kobo.1460.2">We serialize the probe packets into a binary slice, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1461.1">p</span></strong><span class="koboSpan" id="kobo.1462.1">, and write them into the UDP connection, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1463.1">udpConn</span></strong><span class="koboSpan" id="kobo.1464.1">, with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1465.1">binary.Write</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1466.1"> function:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1467.1">func</span></span><span class="koboSpan" id="kobo.1468.1"> main() {
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1469.1">    /* ... </span><span class="koboSpan" id="kobo.1469.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.1469.3">*/</span></span><span class="koboSpan" id="kobo.1470.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1471.1">go</span></span><span class="koboSpan" id="kobo.1472.1"> receive(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1473.1">*</span></span><span class="koboSpan" id="kobo.1474.1">udpConn)
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1475.1">var</span></span><span class="koboSpan" id="kobo.1476.1"> seq </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1477.1">uint8</span></span><span class="koboSpan" id="kobo.1478.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1479.1">for</span></span><span class="koboSpan" id="kobo.1480.1"> {
        log.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1481.1">"Sending probe %d"</span></span><span class="koboSpan" id="kobo.1482.1">, seq)
        p :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1483.1">= &amp;</span></span><span class="koboSpan" id="kobo.1484.1">probe{
            SeqNum: seq,
            SendTS: time.Now().UnixMilli(),
        }
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1485.1">if</span></span><span class="koboSpan" id="kobo.1486.1"> err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1487.1">=</span></span><span class="koboSpan" id="kobo.1488.1"> binary.Write(udpConn,
                        binary.BigEndian, p)
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1489.1">        // process error</span></span><span class="koboSpan" id="kobo.1490.1">
        seq</span><span class="Code_Red"><span class="koboSpan" id="kobo.1491.1">++</span></span><span class="koboSpan" id="kobo.1492.1">
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.1493.1">Now let’s have a closer look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1494.1">receive</span></strong><span class="koboSpan" id="kobo.1495.1"> function, which we kickstarted just before the sending </span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.1496.1">loop in the last code snippet. </span><span class="koboSpan" id="kobo.1496.2">Inside </span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.1497.1">this function, we have another loop that performs the following sequence </span><span class="No-Break"><span class="koboSpan" id="kobo.1498.1">of actions:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1499.1">It receives a mirrored packet and deserializes it into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1500.1">p</span></strong><span class="koboSpan" id="kobo.1501.1"> variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1502.1">probe</span></strong><span class="koboSpan" id="kobo.1503.1"> type using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1504.1">binary.Read</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1505.1"> function.</span></span></li>
<li><span class="koboSpan" id="kobo.1506.1">It checks the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1507.1">SeqNum</span></strong><span class="koboSpan" id="kobo.1508.1"> sequence number of a received packet to find out whether it’s out </span><span class="No-Break"><span class="koboSpan" id="kobo.1509.1">of order.</span></span></li>
<li><span class="koboSpan" id="kobo.1510.1">It calculates the latency by subtracting the current time, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1511.1">time.Now</span></strong><span class="koboSpan" id="kobo.1512.1">, from the time received in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1513.1">SendTS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1514.1"> probe.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1515.1">In Go code, it looks </span><span class="No-Break"><span class="koboSpan" id="kobo.1516.1">like this:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1517.1">func</span></span><span class="koboSpan" id="kobo.1518.1"> receive(udpConn net.UDPConn) {
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1519.1">var</span></span><span class="koboSpan" id="kobo.1520.1"> nextSeq </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1521.1">uint8</span></span><span class="koboSpan" id="kobo.1522.1">
  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1523.1">  var</span></span><span class="koboSpan" id="kobo.1524.1"> lost </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1525.1">int</span></span><span class="koboSpan" id="kobo.1526.1">
   </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1527.1"> for</span></span><span class="koboSpan" id="kobo.1528.1"> {
        p :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1529.1">= &amp;</span></span><span class="koboSpan" id="kobo.1530.1">probe{}
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1531.1">if</span></span><span class="koboSpan" id="kobo.1532.1"> err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1533.1">=</span></span><span class="koboSpan" id="kobo.1534.1"> binary.Read(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1535.1">&amp;</span></span><span class="koboSpan" id="kobo.1536.1">udpConn,
                                binary.BigEndian, p)
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1537.1">        // process error</span></span><span class="koboSpan" id="kobo.1538.1">
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1539.1">if</span></span><span class="koboSpan" id="kobo.1540.1"> p.SeqNum </span><span class="Code_Red"><span class="koboSpan" id="kobo.1541.1">&lt;</span></span><span class="koboSpan" id="kobo.1542.1"> nextSeq {
            log.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1543.1">"Out of order packet seq: %d/%d"</span></span><span class="koboSpan" id="kobo.1544.1">,
                                p.SeqNum, nextSeq)
            lost </span><span class="Code_Red"><span class="koboSpan" id="kobo.1545.1">-=</span></span><span class="koboSpan" id="kobo.1546.1"> 1
        } </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1547.1">else if</span></span><span class="koboSpan" id="kobo.1548.1"> p.SeqNum </span><span class="Code_Red"><span class="koboSpan" id="kobo.1549.1">&gt;</span></span><span class="koboSpan" id="kobo.1550.1"> nextSeq {
            log.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1551.1">"Out of order packet seq: %d/%d"</span></span><span class="koboSpan" id="kobo.1552.1">,
                                p.SeqNum, nextSeq)
            lost </span><span class="Code_Red"><span class="koboSpan" id="kobo.1553.1">+=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.1554.1">int</span></span><span class="koboSpan" id="kobo.1555.1">(p.SeqNum </span><span class="Code_Red"><span class="koboSpan" id="kobo.1556.1">-</span></span><span class="koboSpan" id="kobo.1557.1"> nextSeq)
            nextSeq </span><span class="Code_Red"><span class="koboSpan" id="kobo.1558.1">=</span></span><span class="koboSpan" id="kobo.1559.1"> p.SeqNum
        }
        latency :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1560.1">=</span></span><span class="koboSpan" id="kobo.1561.1"> time.Now().UnixMilli() </span><span class="Code_Red"><span class="koboSpan" id="kobo.1562.1">-</span></span><span class="koboSpan" id="kobo.1563.1"> p.SendTS
        log.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1564.1">"E2E latency: %d ms"</span></span><span class="koboSpan" id="kobo.1565.1">, latency)
        log.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1566.1">"Lost packets: %d"</span></span><span class="koboSpan" id="kobo.1567.1">, lost)
        nextSeq</span><span class="Code_Red"><span class="koboSpan" id="kobo.1568.1">++</span></span><span class="koboSpan" id="kobo.1569.1">
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.1570.1">We’ve used </span><strong class="source-inline"><span class="koboSpan" id="kobo.1571.1">binary.Read</span></strong><span class="koboSpan" id="kobo.1572.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1573.1">binary.Write</span></strong><span class="koboSpan" id="kobo.1574.1"> in this example to convert between the in-memory data types and binary slices. </span><span class="koboSpan" id="kobo.1574.2">This is possible thanks to the fixed size of the probe packets. </span><span class="koboSpan" id="kobo.1574.3">But, if the probes had been of variable size, we could’ve only used the same functions </span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.1575.1">to pre-parse the fixed-sized part of the </span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.1576.1">header and would’ve had to read and parse the variable-sized </span><span class="No-Break"><span class="koboSpan" id="kobo.1577.1">payload manually.</span></span></p>
<p><span class="koboSpan" id="kobo.1578.1">The actual UDP ping application in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1579.1">ch04/udp-ping</span></strong><span class="koboSpan" id="kobo.1580.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.1581.1">Further reading</span></em><span class="koboSpan" id="kobo.1582.1">) has a bit more code to account for further error conditions and graceful program termination. </span><span class="koboSpan" id="kobo.1582.2">Let’s see an example of running the client-side code against a remote UDP ping server, where for each iteration, we can see the total number of lost packets and the latest </span><span class="No-Break"><span class="koboSpan" id="kobo.1583.1">calculated latency:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1584.1">ch04/udp-ping/client</span><span class="Code_Blue"><span class="koboSpan" id="kobo.1585.1">$ sudo</span></span><span class="koboSpan" id="kobo.1586.1"> go run main.go
</span><span class="Code_Green"><span class="koboSpan" id="kobo.1587.1">2021</span></span><span class="koboSpan" id="kobo.1588.1">/12/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1589.1">15</span></span><span class="koboSpan" id="kobo.1590.1">:10:31 Starting UDP </span><span class="Code_Blue"><span class="koboSpan" id="kobo.1591.1">ping</span></span><span class="koboSpan" id="kobo.1592.1"> client
</span><span class="Code_Green"><span class="koboSpan" id="kobo.1593.1">2021</span></span><span class="koboSpan" id="kobo.1594.1">/12/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1595.1">15</span></span><span class="koboSpan" id="kobo.1596.1">:10:31 Starting UDP </span><span class="Code_Blue"><span class="koboSpan" id="kobo.1597.1">ping</span></span><span class="koboSpan" id="kobo.1598.1"> receive loop
</span><span class="Code_Green"><span class="koboSpan" id="kobo.1599.1">2021</span></span><span class="koboSpan" id="kobo.1600.1">/12/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1601.1">15</span></span><span class="koboSpan" id="kobo.1602.1">:10:32 Sending probe </span><span class="Code_Green"><span class="koboSpan" id="kobo.1603.1">0</span></span>
<span class="Code_Green"><span class="koboSpan" id="kobo.1604.1">2021</span></span><span class="koboSpan" id="kobo.1605.1">/12/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1606.1">15</span></span><span class="koboSpan" id="kobo.1607.1">:10:32 Received probe </span><span class="Code_Green"><span class="koboSpan" id="kobo.1608.1">0</span></span>
<span class="Code_Green"><span class="koboSpan" id="kobo.1609.1">2021</span></span><span class="koboSpan" id="kobo.1610.1">/12/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1611.1">15</span></span><span class="koboSpan" id="kobo.1612.1">:10:32 E2E latency: </span><span class="Code_Green"><span class="koboSpan" id="kobo.1613.1">9</span></span><span class="koboSpan" id="kobo.1614.1"> ms
</span><span class="Code_Green"><span class="koboSpan" id="kobo.1615.1">2021</span></span><span class="koboSpan" id="kobo.1616.1">/12/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1617.1">15</span></span><span class="koboSpan" id="kobo.1618.1">:10:32 Lost packets: </span><span class="Code_Green"><span class="koboSpan" id="kobo.1619.1">0</span></span>
<span class="Code_Green"><span class="koboSpan" id="kobo.1620.1">2021</span></span><span class="koboSpan" id="kobo.1621.1">/12/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1622.1">15</span></span><span class="koboSpan" id="kobo.1623.1">:10:33 Sending probe </span><span class="Code_Green"><span class="koboSpan" id="kobo.1624.1">1</span></span>
<span class="Code_Green"><span class="koboSpan" id="kobo.1625.1">2021</span></span><span class="koboSpan" id="kobo.1626.1">/12/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1627.1">15</span></span><span class="koboSpan" id="kobo.1628.1">:10:33 Received probe </span><span class="Code_Green"><span class="koboSpan" id="kobo.1629.1">1</span></span>
<span class="Code_Green"><span class="koboSpan" id="kobo.1630.1">2021</span></span><span class="koboSpan" id="kobo.1631.1">/12/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1632.1">15</span></span><span class="koboSpan" id="kobo.1633.1">:10:33 E2E latency: </span><span class="Code_Green"><span class="koboSpan" id="kobo.1634.1">8</span></span><span class="koboSpan" id="kobo.1635.1"> ms
</span><span class="Code_Green"><span class="koboSpan" id="kobo.1636.1">2021</span></span><span class="koboSpan" id="kobo.1637.1">/12/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1638.1">15</span></span><span class="koboSpan" id="kobo.1639.1">:10:33 Lost packets: </span><span class="Code_Green"><span class="koboSpan" id="kobo.1640.1">0</span></span>
<span class="Code_Green"><span class="koboSpan" id="kobo.1641.1">2021</span></span><span class="koboSpan" id="kobo.1642.1">/12/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1643.1">15</span></span><span class="koboSpan" id="kobo.1644.1">:10:34 Sending probe </span><span class="Code_Green"><span class="koboSpan" id="kobo.1645.1">2</span></span>
<span class="Code_Green"><span class="koboSpan" id="kobo.1646.1">2021</span></span><span class="koboSpan" id="kobo.1647.1">/12/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1648.1">15</span></span><span class="koboSpan" id="kobo.1649.1">:10:34 Received probe </span><span class="Code_Green"><span class="koboSpan" id="kobo.1650.1">2</span></span>
<span class="Code_Green"><span class="koboSpan" id="kobo.1651.1">2021</span></span><span class="koboSpan" id="kobo.1652.1">/12/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1653.1">15</span></span><span class="koboSpan" id="kobo.1654.1">:10:34 E2E latency: </span><span class="Code_Green"><span class="koboSpan" id="kobo.1655.1">9</span></span><span class="koboSpan" id="kobo.1656.1"> ms
</span><span class="Code_Green"><span class="koboSpan" id="kobo.1657.1">2021</span></span><span class="koboSpan" id="kobo.1658.1">/12/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1659.1">15</span></span><span class="koboSpan" id="kobo.1660.1">:10:34 Lost packets: </span><span class="Code_Green"><span class="koboSpan" id="kobo.1661.1">0</span></span><span class="koboSpan" id="kobo.1662.1">
...</span></pre>
<p><span class="koboSpan" id="kobo.1663.1">The server </span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.1664.1">side does not make any measurements </span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.1665.1">and only logs a client IP address for each received </span><span class="No-Break"><span class="koboSpan" id="kobo.1666.1">UDP probe:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1667.1">ch04/udp-ping/server</span><span class="Code_Blue"><span class="koboSpan" id="kobo.1668.1">$ sudo</span></span><span class="koboSpan" id="kobo.1669.1"> go run main.go
</span><span class="Code_Green"><span class="koboSpan" id="kobo.1670.1">2021</span></span><span class="koboSpan" id="kobo.1671.1">/12/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1672.1">15</span></span><span class="koboSpan" id="kobo.1673.1">:10:28 Starting the UDP </span><span class="Code_Blue"><span class="koboSpan" id="kobo.1674.1">ping</span></span><span class="koboSpan" id="kobo.1675.1"> server
</span><span class="Code_Green"><span class="koboSpan" id="kobo.1676.1">2021</span></span><span class="koboSpan" id="kobo.1677.1">/12/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1678.1">15</span></span><span class="koboSpan" id="kobo.1679.1">:10:32 Received a probe from </span><span class="Code_Green"><span class="koboSpan" id="kobo.1680.1">198</span></span><span class="koboSpan" id="kobo.1681.1">.51.100.173:59761
</span><span class="Code_Green"><span class="koboSpan" id="kobo.1682.1">2021</span></span><span class="koboSpan" id="kobo.1683.1">/12/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1684.1">15</span></span><span class="koboSpan" id="kobo.1685.1">:10:33 Received a probe from </span><span class="Code_Green"><span class="koboSpan" id="kobo.1686.1">198</span></span><span class="koboSpan" id="kobo.1687.1">.51.100.173:59761
</span><span class="Code_Green"><span class="koboSpan" id="kobo.1688.1">2021</span></span><span class="koboSpan" id="kobo.1689.1">/12/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1690.1">15</span></span><span class="koboSpan" id="kobo.1691.1">:10:34 Received a probe from </span><span class="Code_Green"><span class="koboSpan" id="kobo.1692.1">198</span></span><span class="koboSpan" id="kobo.1693.1">.51.100.173:59761
...</span></pre>
<p><span class="koboSpan" id="kobo.1694.1">You’ve just seen an example of a binary UDP-based protocol that uses a single message to exchange information and calculate network metrics. </span><span class="koboSpan" id="kobo.1694.2">Although we think it’s important to understand how to work with transport-layer protocols in Go, it’s not very common to </span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.1695.1">implement your own application directly on top of TCP or UDP; the only notable exceptions include high-performance </span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.1696.1">messaging protocols such as Kafka, NATS, and AMQP. </span><span class="koboSpan" id="kobo.1696.2">Most communications these days happen over a higher-level protocol, HTTP. </span><span class="koboSpan" id="kobo.1696.3">With it, we get wide support for packages and SDKs, a vast ecosystem of communication standards with REST, GRPC, and GraphQL, and standard support from network middleware such as proxies and intrusion detection systems. </span><span class="koboSpan" id="kobo.1696.4">In the following section, we show how to write a sample HTTP client-server application </span><span class="No-Break"><span class="koboSpan" id="kobo.1697.1">in Go.</span></span></p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.1698.1">The application layer</span></h1>
<p><span class="koboSpan" id="kobo.1699.1">In the last section, we explored how to establish a TCP or UDP connection between two nodes to </span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.1700.1">transfer bytes over the network using the Go low-level network primitives we have learned about so far. </span><span class="koboSpan" id="kobo.1700.2">Now we focus on the top layer of the TCP/IP model and go into the application-level constructs that Go includes in the standard library to implement HTTP clients </span><span class="No-Break"><span class="koboSpan" id="kobo.1701.1">and servers.</span></span></p>
<p><span class="koboSpan" id="kobo.1702.1">To illustrate this, we go through the steps to build a client-server application that returns the MAC address vendor, IP address owner, or detailed domain information to the requester. </span><span class="koboSpan" id="kobo.1702.2">On the client side, we need to craft an HTTP request that encapsulates the query to the server address. </span><span class="koboSpan" id="kobo.1702.3">On the server side, we need to listen for requests and implement the logic to serve them and reply with the information for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1703.1">argument received.</span></span></p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.1704.1">Working with an HTTP client</span></h2>
<p><span class="koboSpan" id="kobo.1705.1">On the </span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.1706.1">client side, we first need to put together </span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.1707.1">the URL we send the request to. </span><span class="koboSpan" id="kobo.1707.2">The URL, for our example, has </span><span class="No-Break"><span class="koboSpan" id="kobo.1708.1">three components:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1709.1">The server address (IP address </span><span class="No-Break"><span class="koboSpan" id="kobo.1710.1">and port)</span></span></li>
<li><span class="koboSpan" id="kobo.1711.1">The lookup type to perform (MAC, IP, </span><span class="No-Break"><span class="koboSpan" id="kobo.1712.1">or domain)</span></span></li>
<li><span class="koboSpan" id="kobo.1713.1">An argument, which is the value we want to </span><span class="No-Break"><span class="koboSpan" id="kobo.1714.1">query for</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1715.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1716.1">net/url</span></strong><span class="koboSpan" id="kobo.1717.1"> package helps us in this case, to parse the inputs into a URL structure. </span><span class="koboSpan" id="kobo.1717.2">We hardcode values for the example in the book, but you can input any values you want via flags when you run the code in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1718.1">ch04/http/client/main.go</span></strong><span class="koboSpan" id="kobo.1719.1"> (</span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1720.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1721.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.1722.1">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1723.1">Parse</span></strong><span class="koboSpan" id="kobo.1724.1"> method from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1725.1">net/url</span></strong><span class="koboSpan" id="kobo.1726.1"> to form the first part of the URL: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1727.1">http://localhost:8080/lookup</span></strong><span class="koboSpan" id="kobo.1728.1">. </span><span class="koboSpan" id="kobo.1728.2">The second part of the example adds the query. </span><span class="koboSpan" id="kobo.1728.3">We leverage the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1729.1">Add</span></strong><span class="koboSpan" id="kobo.1730.1"> method for this, which takes a key-value pair as an argument. </span><span class="koboSpan" id="kobo.1730.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1731.1">lookup</span></strong> <a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.1732.1">variable is the key in this case and the </span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.1733.1">value comes from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1734.1">argument</span></strong><span class="koboSpan" id="kobo.1735.1"> variable. </span><span class="koboSpan" id="kobo.1735.2">The full URL looks like </span><span class="No-Break"><span class="koboSpan" id="kobo.1736.1">this: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1737.1">http://localhost:8080/lookup?domain=tkng.io</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1738.1">.</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1739.1">func</span></span><span class="koboSpan" id="kobo.1740.1"> main() {
    server :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1741.1">= "localhost:8080"</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.1742.1">    // One of: mac, ip, domain</span></span><span class="koboSpan" id="kobo.1743.1">
    lookup :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1744.1">= "domain"</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.1745.1">    // Examples: 68b5.99fc.d1df, 1.1.1.1, tkng.io</span></span><span class="koboSpan" id="kobo.1746.1">
    argument :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1747.1">= "tkng.io"</span></span><span class="koboSpan" id="kobo.1748.1">
    path :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1749.1">= "/lookup"</span></span><span class="koboSpan" id="kobo.1750.1">
    addr, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1751.1">=</span></span><span class="koboSpan" id="kobo.1752.1"> url.Parse(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1753.1">"http://" +</span></span><span class="koboSpan" id="kobo.1754.1"> server </span><span class="Code_Red"><span class="koboSpan" id="kobo.1755.1">+</span></span><span class="koboSpan" id="kobo.1756.1"> path)
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1757.1">    // process error</span></span><span class="koboSpan" id="kobo.1758.1">
    params :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1759.1">=</span></span><span class="koboSpan" id="kobo.1760.1"> url.Values{}
    params.Add(lookup, argument)
    addr.RawQuery = params.Encode()
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1761.1">    /* ... </span><span class="koboSpan" id="kobo.1761.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.1761.3">*/</span></span><span class="koboSpan" id="kobo.1762.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.1763.1">To make the actual request to the server, we leverage the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1764.1">net/http</span></strong><span class="koboSpan" id="kobo.1765.1"> package. </span><span class="koboSpan" id="kobo.1765.2">This package has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1766.1">Client</span></strong><span class="koboSpan" id="kobo.1767.1"> type that specifies the mechanism to make an HTTP request. </span><span class="koboSpan" id="kobo.1767.2">We don’t need to stipulate any client details for this example, so we show the type just </span><span class="No-Break"><span class="koboSpan" id="kobo.1768.1">for reference:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1769.1">type</span></span><span class="koboSpan" id="kobo.1770.1"> Client </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1771.1">struct</span></span><span class="koboSpan" id="kobo.1772.1"> {
    Transport RoundTripper
    CheckRedirect </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1773.1">func</span></span><span class="koboSpan" id="kobo.1774.1">(req </span><span class="Code_Red"><span class="koboSpan" id="kobo.1775.1">*</span></span><span class="koboSpan" id="kobo.1776.1">Request, via []</span><span class="Code_Red"><span class="koboSpan" id="kobo.1777.1">*</span></span><span class="koboSpan" id="kobo.1778.1">Request) </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1779.1">error</span></span><span class="koboSpan" id="kobo.1780.1">
    Jar CookieJar
    Timeout time.Duration
}</span></pre>
<p><span class="koboSpan" id="kobo.1781.1">If you don’t have any preference, you can select a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1782.1">DefaultClient</span></strong><span class="koboSpan" id="kobo.1783.1"> that uses a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1784.1">DefaultTransport</span></strong><span class="koboSpan" id="kobo.1785.1">. </span><span class="koboSpan" id="kobo.1785.2">This client has pre-defined timeouts and proxy settings, which are safe for </span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.1786.1">concurrent use by different goroutines, so we don’t need to adjust any of the parameters that the following </span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.1787.1">code snippet from the Go standard library shows, which also depicts the client HTTP transport settings that are available in case you want to fine-tune the behavior of </span><span class="No-Break"><span class="koboSpan" id="kobo.1788.1">the connection:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1789.1">var</span></span><span class="koboSpan" id="kobo.1790.1"> DefaultTransport RoundTripper </span><span class="Code_Red"><span class="koboSpan" id="kobo.1791.1">= &amp;</span></span><span class="koboSpan" id="kobo.1792.1">Transport{
    Proxy: ProxyFromEnvironment,
    DialContext: (</span><span class="Code_Red"><span class="koboSpan" id="kobo.1793.1">&amp;</span></span><span class="koboSpan" id="kobo.1794.1">net.Dialer{
        Timeout:   </span><span class="Code_Green"><span class="koboSpan" id="kobo.1795.1">30</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.1796.1">*</span></span><span class="koboSpan" id="kobo.1797.1"> time.Second,
        KeepAlive: </span><span class="Code_Green"><span class="koboSpan" id="kobo.1798.1">30</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.1799.1">*</span></span><span class="koboSpan" id="kobo.1800.1"> time.Second,
    }).DialContext,
    ForceAttemptHTTP2:     </span><span class="Code_Blue"><span class="koboSpan" id="kobo.1801.1">true</span></span><span class="koboSpan" id="kobo.1802.1">,
    MaxIdleConns:          </span><span class="Code_Green"><span class="koboSpan" id="kobo.1803.1">100</span></span><span class="koboSpan" id="kobo.1804.1">,
    IdleConnTimeout:       </span><span class="Code_Green"><span class="koboSpan" id="kobo.1805.1">90</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.1806.1">*</span></span><span class="koboSpan" id="kobo.1807.1"> time.Second,
    TLSHandshakeTimeout:   </span><span class="Code_Green"><span class="koboSpan" id="kobo.1808.1">10</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.1809.1">*</span></span><span class="koboSpan" id="kobo.1810.1"> time.Second,
    ExpectContinueTimeout: </span><span class="Code_Green"><span class="koboSpan" id="kobo.1811.1">1</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.1812.1">*</span></span><span class="koboSpan" id="kobo.1813.1"> time.Second,
}</span></pre>
<p><span class="koboSpan" id="kobo.1814.1">Continuing with the example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1815.1">DefaultClient</span></strong><span class="koboSpan" id="kobo.1816.1"> allows us to use HTTP GET, HEAD, and POST methods. </span><span class="koboSpan" id="kobo.1816.2">Here, we use HTTP GET with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1817.1">Get</span></strong><span class="koboSpan" id="kobo.1818.1"> method from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1819.1">net/http</span></strong><span class="koboSpan" id="kobo.1820.1"> package to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1821.1">addr</span></strong><span class="koboSpan" id="kobo.1822.1"> address we parsed earlier </span><span class="No-Break"><span class="koboSpan" id="kobo.1823.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1824.1">Parse</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1825.1">:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1826.1">func</span></span><span class="koboSpan" id="kobo.1827.1"> main() {
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1828.1">    /* ... </span><span class="koboSpan" id="kobo.1828.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.1828.3">*/</span></span><span class="koboSpan" id="kobo.1829.1">
    res, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1830.1">=</span></span><span class="koboSpan" id="kobo.1831.1"> http.DefaultClient.Get(addr.String())
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1832.1">if</span></span><span class="koboSpan" id="kobo.1833.1"> err </span><span class="Code_Red"><span class="koboSpan" id="kobo.1834.1">!=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.1835.1">nil</span></span><span class="koboSpan" id="kobo.1836.1"> {
        log.Fatal(err)
    }
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1837.1">defer</span></span><span class="koboSpan" id="kobo.1838.1"> res.Body.Close()
    io.Copy(os.Stdout, res.Body)
}</span></pre>
<p><span class="koboSpan" id="kobo.1839.1">The last </span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.1840.1">step is to print out the response we </span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.1841.1">get from the server to the terminal. </span><span class="koboSpan" id="kobo.1841.2">You can use flags from the CLI to submit different queries when running the client application to do </span><span class="No-Break"><span class="koboSpan" id="kobo.1842.1">these operations:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1843.1">A </span><span class="No-Break"><span class="koboSpan" id="kobo.1844.1">health check:</span></span><pre class="console"><span class="koboSpan" id="kobo.1845.1">ch04/http/client</span><span class="Code_Blue"><span class="koboSpan" id="kobo.1846.1">$ go</span></span><span class="koboSpan" id="kobo.1847.1"> run main.go </span><span class="Code_Blue"><span class="koboSpan" id="kobo.1848.1">-check</span></span></pre><pre class="console"><span class="koboSpan" id="kobo.1849.1">OK</span></pre></li>
<li><span class="koboSpan" id="kobo.1850.1">A MAC address </span><span class="No-Break"><span class="koboSpan" id="kobo.1851.1">vendor lookup:</span></span><pre class="console"><span class="koboSpan" id="kobo.1852.1">ch04/http/client</span><span class="Code_Blue"><span class="koboSpan" id="kobo.1853.1">$ go </span></span><span class="koboSpan" id="kobo.1854.1">run main.go </span><span class="Code_Blue"><span class="koboSpan" id="kobo.1855.1">-lookup</span></span><span class="koboSpan" id="kobo.1856.1"> mac 68b5.99fc.d1df</span></pre><pre class="console"><span class="koboSpan" id="kobo.1857.1">Hewlett Packard</span></pre></li>
<li><span class="koboSpan" id="kobo.1858.1">A </span><span class="No-Break"><span class="koboSpan" id="kobo.1859.1">domain lookup:</span></span><pre class="console"><span class="koboSpan" id="kobo.1860.1">ch04/http/client</span><span class="Code_Blue"><span class="koboSpan" id="kobo.1861.1">$ go</span></span><span class="koboSpan" id="kobo.1862.1"> run main.go </span><span class="Code_Blue"><span class="koboSpan" id="kobo.1863.1">-lookup</span></span><span class="koboSpan" id="kobo.1864.1"> domain tkng.io</span></pre><pre class="console"><span class="koboSpan" id="kobo.1865.1">Domain Name: tkng.io</span></pre><pre class="console"><span class="koboSpan" id="kobo.1866.1">Registry Domain ID: 5cdbf549b56144f5afe00b62ccd8d6e9-DONUTS</span></pre><pre class="console"><span class="koboSpan" id="kobo.1867.1">Registrar WHOIS Server: whois.namecheap.com</span></pre><pre class="console"><span class="koboSpan" id="kobo.1868.1">Registrar URL: https://www.namecheap.com/</span></pre><pre class="console"><span class="koboSpan" id="kobo.1869.1">Updated Date: </span><span class="Code_Green"><span class="koboSpan" id="kobo.1870.1">2021</span></span><span class="Code_Blue"><span class="koboSpan" id="kobo.1871.1">-09-24T20</span></span><span class="koboSpan" id="kobo.1872.1">:39:04Z</span></pre><pre class="console"><span class="koboSpan" id="kobo.1873.1">Creation Date: </span><span class="Code_Green"><span class="koboSpan" id="kobo.1874.1">2021</span></span><span class="Code_Blue"><span class="koboSpan" id="kobo.1875.1">-07-26T19</span></span><span class="koboSpan" id="kobo.1876.1">:08:34Z</span></pre><pre class="console"><span class="koboSpan" id="kobo.1877.1">Registry Expiry Date: </span><span class="Code_Green"><span class="koboSpan" id="kobo.1878.1">2022</span></span><span class="Code_Blue"><span class="koboSpan" id="kobo.1879.1">-07-26T19</span></span><span class="koboSpan" id="kobo.1880.1">:08:34Z</span></pre><pre class="console"><span class="koboSpan" id="kobo.1881.1">Registrar: NameCheap, Inc.</span></pre><pre class="console"><span class="koboSpan" id="kobo.1882.1">Registrar IANA ID: </span><span class="Code_Green"><span class="koboSpan" id="kobo.1883.1">1068</span></span></pre></li>
<li><span class="koboSpan" id="kobo.1884.1">An </span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.1885.1">IP </span><span class="No-Break"><span class="koboSpan" id="kobo.1886.1">address </span></span><span class="No-Break"><a id="_idIndexMarker463"/></span><span class="No-Break"><span class="koboSpan" id="kobo.1887.1">lookup:</span></span><pre class="console"><span class="koboSpan" id="kobo.1888.1">ch04/http/client</span><span class="Code_Blue"><span class="koboSpan" id="kobo.1889.1">$ go</span></span><span class="koboSpan" id="kobo.1890.1"> run main.go </span><span class="Code_Blue"><span class="koboSpan" id="kobo.1891.1">-lookup</span></span><span class="koboSpan" id="kobo.1892.1"> ip </span><span class="Code_Green"><span class="koboSpan" id="kobo.1893.1">1.1.1.1</span></span></pre><pre class="console"><span class="koboSpan" id="kobo.1894.1">...</span></pre><pre class="console"><span class="koboSpan" id="kobo.1895.1">inetnum:        </span><span class="Code_Green"><span class="koboSpan" id="kobo.1896.1">1</span></span><span class="koboSpan" id="kobo.1897.1">.1.1.0 </span><span class="Code_Blue"><span class="koboSpan" id="kobo.1898.1">-</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1899.1">1</span></span><span class="koboSpan" id="kobo.1900.1">.1.1.255</span></pre><pre class="console"><span class="koboSpan" id="kobo.1901.1">netname:        APNIC-LABS</span></pre><pre class="console"><span class="koboSpan" id="kobo.1902.1">descr:          APNIC and Cloudflare DNS Resolver project</span></pre><pre class="console"><span class="koboSpan" id="kobo.1903.1">descr:          Routed globally by AS13335/Cloudflare</span></pre><pre class="console"><span class="koboSpan" id="kobo.1904.1">descr:          Research prefix </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1905.1">for</span></span><span class="koboSpan" id="kobo.1906.1"> APNIC Labs</span></pre><pre class="console"><span class="koboSpan" id="kobo.1907.1">country:        AU</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.1908.1">To get these responses, we need to have a running server first that processes the requests. </span><span class="koboSpan" id="kobo.1908.2">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.1909.1">build it.</span></span></p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.1910.1">Working with an HTTP (server)</span></h2>
<p><span class="koboSpan" id="kobo.1911.1">To handle </span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.1912.1">the requests and responses, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1913.1">net/http</span></strong><span class="koboSpan" id="kobo.1914.1"> package </span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.1915.1">exposes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1916.1">Server</span></strong><span class="koboSpan" id="kobo.1917.1"> type and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1918.1">Handler</span></strong><span class="koboSpan" id="kobo.1919.1"> interface. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1920.1">Server</span></strong><span class="koboSpan" id="kobo.1921.1"> is the data structure for the parameters to run an </span><span class="No-Break"><span class="koboSpan" id="kobo.1922.1">HTTP server:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1923.1">type</span></span><span class="koboSpan" id="kobo.1924.1"> Server </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1925.1">struct</span></span><span class="koboSpan" id="kobo.1926.1"> {
    Addr </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1927.1">string</span></span><span class="koboSpan" id="kobo.1928.1">
    Handler Handler
    TLSConfig </span><span class="Code_Red"><span class="koboSpan" id="kobo.1929.1">*</span></span><span class="koboSpan" id="kobo.1930.1">tls.Config
    ReadTimeout time.Duration
    ReadHeaderTimeout time.Duration
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1931.1">    /* ... </span><span class="koboSpan" id="kobo.1931.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.1931.3">*/</span></span><span class="koboSpan" id="kobo.1932.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.1933.1">Let’s </span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.1934.1">define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1935.1">srv</span></strong><span class="koboSpan" id="kobo.1936.1"> variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1937.1">Server</span></strong><span class="koboSpan" id="kobo.1938.1"> type. </span><span class="koboSpan" id="kobo.1938.2">The zero value for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1939.1">Server</span></strong><span class="koboSpan" id="kobo.1940.1"> is a </span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.1941.1">valid configuration, but in this case, we denote </span><strong class="source-inline"><span class="koboSpan" id="kobo.1942.1">Addr</span></strong><span class="koboSpan" id="kobo.1943.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1944.1">0.0.0.0:8080</span></strong><span class="koboSpan" id="kobo.1945.1"> to listen on any interface and port </span><strong class="source-inline"><span class="koboSpan" id="kobo.1946.1">8080</span></strong><span class="koboSpan" id="kobo.1947.1"> specifically. </span></p>
<p><span class="koboSpan" id="kobo.1948.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1949.1">Server</span></strong><span class="koboSpan" id="kobo.1950.1"> type has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1951.1">ListenAndServe</span></strong><span class="koboSpan" id="kobo.1952.1"> method to listen on the TCP network address, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1953.1">Addr</span></strong><span class="koboSpan" id="kobo.1954.1">, of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1955.1">Server</span></strong><span class="koboSpan" id="kobo.1956.1"> instance (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1957.1">srv.Addr</span></strong><span class="koboSpan" id="kobo.1958.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1959.1">0.0.0.0:8080</span></strong><span class="koboSpan" id="kobo.1960.1"> in the example). </span><span class="koboSpan" id="kobo.1960.2">It then calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1961.1">Serve</span></strong><span class="koboSpan" id="kobo.1962.1"> method to accept incoming connections and handle the requests. </span><span class="koboSpan" id="kobo.1962.2">For each request, it creates a new service goroutine that reads the request and then calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1963.1">Server</span></strong><span class="koboSpan" id="kobo.1964.1"> instance, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1965.1">Handler</span></strong><span class="koboSpan" id="kobo.1966.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1967.1">srv.Handler</span></strong><span class="koboSpan" id="kobo.1968.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1969.1">nil</span></strong><span class="koboSpan" id="kobo.1970.1"> in the example), to reply </span><span class="No-Break"><span class="koboSpan" id="kobo.1971.1">to them:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1972.1">func</span></span><span class="koboSpan" id="kobo.1973.1"> main() {
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1974.1">    /* ... </span><span class="koboSpan" id="kobo.1974.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.1974.3">*/</span></span><span class="koboSpan" id="kobo.1975.1">
    log.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1976.1">"Starting web server at 0.0.0.0:8080"</span></span><span class="koboSpan" id="kobo.1977.1">)
    srv :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1978.1">=</span></span><span class="koboSpan" id="kobo.1979.1"> http.Server{Addr: </span><span class="Code_Red"><span class="koboSpan" id="kobo.1980.1">"0.0.0.0:8080"</span></span><span class="koboSpan" id="kobo.1981.1">}
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1982.1">    // ListenAndServe always returns a non-nil error.</span></span><span class="koboSpan" id="kobo.1983.1">
    log.Fatal(srv.ListenAndServe())
}</span></pre>
<p><span class="koboSpan" id="kobo.1984.1">This brings </span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.1985.1">us to the second type in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1986.1">net/http</span></strong><span class="koboSpan" id="kobo.1987.1"> package </span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.1988.1">we mentioned initially, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1989.1">Handler</span></strong><span class="koboSpan" id="kobo.1990.1"> interface. </span><span class="koboSpan" id="kobo.1990.2">The role of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1991.1">Handler</span></strong><span class="koboSpan" id="kobo.1992.1"> is to respond to an </span><span class="No-Break"><span class="koboSpan" id="kobo.1993.1">HTTP request:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1994.1">type</span></span><span class="koboSpan" id="kobo.1995.1"> Handler </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1996.1">interface</span></span><span class="koboSpan" id="kobo.1997.1"> {
    ServeHTTP(ResponseWriter, </span><span class="Code_Red"><span class="koboSpan" id="kobo.1998.1">*</span></span><span class="koboSpan" id="kobo.1999.1">Request)
}</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.2000.1">Handler</span></strong><span class="koboSpan" id="kobo.2001.1"> responds to HTTP requests via its </span><strong class="source-inline"><span class="koboSpan" id="kobo.2002.1">ServeHTTP</span></strong><span class="koboSpan" id="kobo.2003.1"> method, which takes </span><span class="No-Break"><span class="koboSpan" id="kobo.2004.1">two arguments:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.2005.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.2006.1">ResponseWriter</span></strong><span class="koboSpan" id="kobo.2007.1"> interface, which </span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.2008.1">you can use to craft an HTTP header and payload to reply to the request and </span><span class="No-Break"><span class="koboSpan" id="kobo.2009.1">then return:</span></span><pre class="console"><span class="Code_Purple"><span class="koboSpan" id="kobo.2010.1">type</span></span><span class="koboSpan" id="kobo.2011.1"> ResponseWriter </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2012.1">interface</span></span><span class="koboSpan" id="kobo.2013.1"> {</span></pre><pre class="console"><span class="koboSpan" id="kobo.2014.1">    Header() Header</span></pre><pre class="console"><span class="Code_Brown"><span class="koboSpan" id="kobo.2015.1">    // Write writes the data to the connection </span></span></pre><pre class="console"><span class="Code_Brown"><span class="koboSpan" id="kobo.2016.1">    // as part of an HTTP reply.</span></span></pre><pre class="console"><span class="koboSpan" id="kobo.2017.1">    Write([]</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2018.1">byte</span></span><span class="koboSpan" id="kobo.2019.1">) (</span><span class="Code_Purple"><span class="koboSpan" id="kobo.2020.1">int</span></span><span class="koboSpan" id="kobo.2021.1">, </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2022.1">error</span></span><span class="koboSpan" id="kobo.2023.1">)</span></pre><pre class="console"><span class="Code_Brown"><span class="koboSpan" id="kobo.2024.1">    // WriteHeader sends an HTTP response header</span></span></pre><pre class="console"><span class="Code_Brown"><span class="koboSpan" id="kobo.2025.1">    // with the provided status code.</span></span></pre><pre class="console"><span class="koboSpan" id="kobo.2026.1">    WriteHeader(statusCode </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2027.1">int</span></span><span class="koboSpan" id="kobo.2028.1">)</span></pre><pre class="console"><span class="koboSpan" id="kobo.2029.1">}</span></pre></li>
<li><span class="koboSpan" id="kobo.2030.1">An HTTP </span><strong class="source-inline"><span class="koboSpan" id="kobo.2031.1">Request</span></strong><span class="koboSpan" id="kobo.2032.1">, which </span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.2033.1">holds the HTTP request received by the server in this case. </span><span class="koboSpan" id="kobo.2033.2">It could also be a request you want to send from </span><span class="No-Break"><span class="koboSpan" id="kobo.2034.1">a client:</span></span><pre class="console"><span class="Code_Purple"><span class="koboSpan" id="kobo.2035.1">type</span></span><span class="koboSpan" id="kobo.2036.1"> Request </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2037.1">struct</span></span><span class="koboSpan" id="kobo.2038.1"> {</span></pre><pre class="console"><span class="Code_Brown"><span class="koboSpan" id="kobo.2039.1">    // Method specifies the HTTP method</span></span></pre><pre class="console"><span class="Code_Brown"><span class="koboSpan" id="kobo.2040.1">    // (GET, POST, PUT, etc.).</span></span></pre><pre class="console"><span class="koboSpan" id="kobo.2041.1">    Method </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2042.1">string</span></span></pre><pre class="console"><span class="Code_Brown"><span class="koboSpan" id="kobo.2043.1">    // URL specifies either the URI being requested</span></span></pre><pre class="console"><span class="Code_Brown"><span class="koboSpan" id="kobo.2044.1">    // (for server requests) or the URL to access </span></span></pre><pre class="console"><span class="Code_Brown"><span class="koboSpan" id="kobo.2045.1">    // (for client requests).</span></span></pre><pre class="console"><span class="koboSpan" id="kobo.2046.1">    URL </span><span class="Code_Red"><span class="koboSpan" id="kobo.2047.1">*</span></span><span class="koboSpan" id="kobo.2048.1">url.URL</span></pre><pre class="console"><span class="koboSpan" id="kobo.2049.1">    Header Header</span></pre><pre class="console"><span class="koboSpan" id="kobo.2050.1">    Body io.ReadCloser</span></pre><pre class="console"><span class="Code_Brown"><span class="koboSpan" id="kobo.2051.1">    /* ... </span><span class="koboSpan" id="kobo.2051.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.2051.3">*/</span></span></pre><pre class="console"><span class="koboSpan" id="kobo.2052.1">}</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.2053.1">Now, if we look </span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.2054.1">back at our example, we didn’t specify our </span><strong class="source-inline"><span class="koboSpan" id="kobo.2055.1">Handler</span></strong><span class="koboSpan" id="kobo.2056.1">, so when we called </span><strong class="source-inline"><span class="koboSpan" id="kobo.2057.1">ListenAndServe</span></strong><span class="koboSpan" id="kobo.2058.1">, our handler was actually null (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2059.1">nil</span></strong><span class="koboSpan" id="kobo.2060.1">). </span><span class="koboSpan" id="kobo.2060.2">In this scenario, </span><strong class="source-inline"><span class="koboSpan" id="kobo.2061.1">ListenAndServe</span></strong><span class="koboSpan" id="kobo.2062.1"> defaults a </span><strong class="source-inline"><span class="koboSpan" id="kobo.2063.1">DefaultServeMux</span></strong><span class="koboSpan" id="kobo.2064.1"> to handle the </span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.2065.1">requests that come in. </span><strong class="source-inline"><span class="koboSpan" id="kobo.2066.1">DefaultServeMux</span></strong><span class="koboSpan" id="kobo.2067.1"> is an HTTP request multiplexer that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2068.1">net/http</span></strong><span class="koboSpan" id="kobo.2069.1"> package includes. </span><span class="koboSpan" id="kobo.2069.2">It routes requests to the most appropriate handler based on a list of registered </span><span class="No-Break"><span class="koboSpan" id="kobo.2070.1">URL patterns.</span></span></p>
<p><span class="koboSpan" id="kobo.2071.1">The next step in the example is to register a handler function for a given pattern. </span><span class="koboSpan" id="kobo.2071.2">We do this with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2072.1">HandleFunc</span></strong><span class="koboSpan" id="kobo.2073.1"> function, which takes a string pattern and a handler function with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2074.1">func(ResponseWriter, *Request)</span></strong><span class="koboSpan" id="kobo.2075.1"> signature as arguments. </span><span class="koboSpan" id="kobo.2075.2">Now, when we get an incoming request that has a URL that matches this pattern, the specified handler generates </span><span class="No-Break"><span class="koboSpan" id="kobo.2076.1">the response.</span></span></p>
<p><span class="koboSpan" id="kobo.2077.1">Going back to the example, in the first code snippet we showed of the main function, we purposely omitted the initial two lines of code, which actually register two URL patterns to match, </span><strong class="source-inline"><span class="koboSpan" id="kobo.2078.1">/lookup</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.2079.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2080.1">/check</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2081.1">:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.2082.1">func</span></span><span class="koboSpan" id="kobo.2083.1"> main() {
    http.HandleFunc(</span><span class="Code_Red"><span class="koboSpan" id="kobo.2084.1">"/lookup"</span></span><span class="koboSpan" id="kobo.2085.1">, lookup)
    http.HandleFunc(</span><span class="Code_Red"><span class="koboSpan" id="kobo.2086.1">"/check"</span></span><span class="koboSpan" id="kobo.2087.1">, check)
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.2088.1">    /* ... </span><span class="koboSpan" id="kobo.2088.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.2088.3">*/</span></span><span class="koboSpan" id="kobo.2089.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.2090.1">Normal queries follow the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2091.1">/lookup</span></strong><span class="koboSpan" id="kobo.2092.1"> route, but we also included a </span><strong class="source-inline"><span class="koboSpan" id="kobo.2093.1">/check</span></strong><span class="koboSpan" id="kobo.2094.1"> option to let us to </span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.2095.1">run a quick health check and verify the server is responding </span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.2096.1">to requests. </span><span class="koboSpan" id="kobo.2096.2">Each pattern has a corresponding handler function with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2097.1">func(ResponseWriter, *Request)</span></strong><span class="koboSpan" id="kobo.2098.1"> signature as an argument. </span><span class="koboSpan" id="kobo.2098.2">We conveniently named these functions </span><strong class="source-inline"><span class="koboSpan" id="kobo.2099.1">lookup</span></strong><span class="koboSpan" id="kobo.2100.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2101.1">check</span></strong><span class="koboSpan" id="kobo.2102.1">. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.2103.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.2104.1">.6</span></em><span class="koboSpan" id="kobo.2105.1"> shows how </span><strong class="source-inline"><span class="koboSpan" id="kobo.2106.1">DefaultServeMux</span></strong><span class="koboSpan" id="kobo.2107.1"> logically determines the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2108.1">Handler</span></strong><span class="koboSpan" id="kobo.2109.1"> that handles the </span><span class="No-Break"><span class="koboSpan" id="kobo.2110.1">user request:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<span class="koboSpan" id="kobo.2111.1"><img alt="Figure 4.6 – Handling HTTP requests" src="image/B16971_04_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2112.1">Figure 4.6 – Handling HTTP requests</span></p>
<p><span class="koboSpan" id="kobo.2113.1">Now, let’s examine </span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.2114.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2115.1">lookup</span></strong><span class="koboSpan" id="kobo.2116.1"> handler function. </span><span class="koboSpan" id="kobo.2116.2">A couple of things </span><span class="No-Break"><span class="koboSpan" id="kobo.2117.1">stand out:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.2118.1">We write the response to the request via the first argument, </span><strong class="source-inline"><span class="koboSpan" id="kobo.2119.1">w</span></strong><span class="koboSpan" id="kobo.2120.1">, an </span><strong class="source-inline"><span class="koboSpan" id="kobo.2121.1">http.ResponseWriter</span></strong><span class="koboSpan" id="kobo.2122.1"> that satisfies the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2123.1">io.Writer</span></strong><span class="koboSpan" id="kobo.2124.1"> interface. </span><span class="koboSpan" id="kobo.2124.2">This means you can use any mechanism that accepts an </span><strong class="source-inline"><span class="koboSpan" id="kobo.2125.1">io.Writer</span></strong><span class="koboSpan" id="kobo.2126.1"> interface to write to it. </span><span class="koboSpan" id="kobo.2126.2">Here, we </span><span class="No-Break"><span class="koboSpan" id="kobo.2127.1">use </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2128.1">fmt.Sprintf</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2129.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.2130.1">We access the user’s request via the second argument, </span><strong class="source-inline"><span class="koboSpan" id="kobo.2131.1">req</span></strong><span class="koboSpan" id="kobo.2132.1">. </span><span class="koboSpan" id="kobo.2132.2">Here, we extract the target URL from the request to print it out in the example with </span><strong class="source-inline"><span class="koboSpan" id="kobo.2133.1">req.URL.Query</span></strong><span class="koboSpan" id="kobo.2134.1">. </span><span class="koboSpan" id="kobo.2134.2">Also, we get the value of the query to further process the request based on its type, whether this is for a MAC address, IP address, or </span><span class="No-Break"><span class="koboSpan" id="kobo.2135.1">a domain:</span></span><pre class="console"><span class="Code_Purple"><span class="koboSpan" id="kobo.2136.1">func</span></span><span class="koboSpan" id="kobo.2137.1"> lookup(w http.ResponseWriter, req </span><span class="Code_Red"><span class="koboSpan" id="kobo.2138.1">*</span></span><span class="koboSpan" id="kobo.2139.1">http.Request) {</span></pre><pre class="console"><span class="koboSpan" id="kobo.2140.1">    log.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.2141.1">"Incoming %+v"</span></span><span class="koboSpan" id="kobo.2142.1">, req.URL.Query())</span></pre><pre class="console"><span class="koboSpan" id="kobo.2143.1">    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2144.1">var</span></span><span class="koboSpan" id="kobo.2145.1"> response </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2146.1">string</span></span></pre><pre class="console"><span class="koboSpan" id="kobo.2147.1">    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2148.1">for</span></span><span class="koboSpan" id="kobo.2149.1"> k, v :</span><span class="Code_Red"><span class="koboSpan" id="kobo.2150.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.2151.1">range</span></span><span class="koboSpan" id="kobo.2152.1"> req.URL.Query() {</span></pre><pre class="console"><span class="koboSpan" id="kobo.2153.1">        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2154.1">switch</span></span><span class="koboSpan" id="kobo.2155.1"> k {</span></pre><pre class="console"><span class="koboSpan" id="kobo.2156.1">        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2157.1">case</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.2158.1">"ip"</span></span><span class="koboSpan" id="kobo.2159.1">:</span></pre><pre class="console"><span class="koboSpan" id="kobo.2160.1">            response </span><span class="Code_Red"><span class="koboSpan" id="kobo.2161.1">=</span></span><span class="koboSpan" id="kobo.2162.1"> getWhois(v)</span></pre><pre class="console"><span class="koboSpan" id="kobo.2163.1">        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2164.1">case</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.2165.1">"mac"</span></span><span class="koboSpan" id="kobo.2166.1">:</span></pre><pre class="console"><span class="koboSpan" id="kobo.2167.1">            response </span><span class="Code_Red"><span class="koboSpan" id="kobo.2168.1">=</span></span><span class="koboSpan" id="kobo.2169.1"> getMAC(v)</span></pre><pre class="console"><span class="koboSpan" id="kobo.2170.1">        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2171.1">case</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.2172.1">"domain"</span></span><span class="koboSpan" id="kobo.2173.1">:</span></pre><pre class="console"><span class="koboSpan" id="kobo.2174.1">            response </span><span class="Code_Red"><span class="koboSpan" id="kobo.2175.1">=</span></span><span class="koboSpan" id="kobo.2176.1"> getWhois(v)</span></pre><pre class="console"><span class="koboSpan" id="kobo.2177.1">        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2178.1">default</span></span><span class="koboSpan" id="kobo.2179.1">:</span></pre><pre class="console"><span class="koboSpan" id="kobo.2180.1">            response </span><span class="Code_Red"><span class="koboSpan" id="kobo.2181.1">=</span></span><span class="koboSpan" id="kobo.2182.1"> fmt.Sprintf(</span></pre><pre class="console"><span class="koboSpan" id="kobo.2183.1">                        </span><span class="Code_Red"><span class="koboSpan" id="kobo.2184.1">"query %q not recognized"</span></span><span class="koboSpan" id="kobo.2185.1">, k)</span></pre><pre class="console"><span class="koboSpan" id="kobo.2186.1">        }</span></pre><pre class="console"><span class="koboSpan" id="kobo.2187.1">    }</span></pre><pre class="console"><span class="koboSpan" id="kobo.2188.1">    fmt.Fprintf(w, response)</span></pre><pre class="console"><span class="koboSpan" id="kobo.2189.1">}</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.2190.1">When </span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.2191.1">running this on the server side, we need to include </span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.2192.1">all the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2193.1">.go</span></strong><span class="koboSpan" id="kobo.2194.1"> files in the folder, not only </span><strong class="source-inline"><span class="koboSpan" id="kobo.2195.1">main.go</span></strong><span class="koboSpan" id="kobo.2196.1">, so you want to run </span><strong class="source-inline"><span class="koboSpan" id="kobo.2197.1">go run *.go</span></strong><span class="koboSpan" id="kobo.2198.1"> to get an output like the one in the </span><span class="No-Break"><span class="koboSpan" id="kobo.2199.1">next snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.2200.1">ch04/http/server</span><span class="Code_Blue"><span class="koboSpan" id="kobo.2201.1">$ go</span></span><span class="koboSpan" id="kobo.2202.1"> run *.go
</span><span class="Code_Green"><span class="koboSpan" id="kobo.2203.1">2021</span></span><span class="koboSpan" id="kobo.2204.1">/12/13 </span><span class="Code_Green"><span class="koboSpan" id="kobo.2205.1">02</span></span><span class="koboSpan" id="kobo.2206.1">:02:39 macDB initialized
</span><span class="Code_Green"><span class="koboSpan" id="kobo.2207.1">2021</span></span><span class="koboSpan" id="kobo.2208.1">/12/13 </span><span class="Code_Green"><span class="koboSpan" id="kobo.2209.1">02</span></span><span class="koboSpan" id="kobo.2210.1">:02:39 Starting web server at </span><span class="Code_Green"><span class="koboSpan" id="kobo.2211.1">0</span></span><span class="koboSpan" id="kobo.2212.1">.0.0.0:8080
</span><span class="Code_Green"><span class="koboSpan" id="kobo.2213.1">2021</span></span><span class="koboSpan" id="kobo.2214.1">/12/13 </span><span class="Code_Green"><span class="koboSpan" id="kobo.2215.1">02</span></span><span class="koboSpan" id="kobo.2216.1">:02:56 Incoming map[mac:[68b5.99fc.d1df]]
</span><span class="Code_Green"><span class="koboSpan" id="kobo.2217.1">2021</span></span><span class="koboSpan" id="kobo.2218.1">/12/13 </span><span class="Code_Green"><span class="koboSpan" id="kobo.2219.1">02</span></span><span class="koboSpan" id="kobo.2220.1">:03:19 Incoming map[domain:[tkng.io]]
</span><span class="Code_Green"><span class="koboSpan" id="kobo.2221.1">2021</span></span><span class="koboSpan" id="kobo.2222.1">/12/13 </span><span class="Code_Green"><span class="koboSpan" id="kobo.2223.1">02</span></span><span class="koboSpan" id="kobo.2224.1">:03:19 whoisLookup tkng.io@whois.iana.org
</span><span class="Code_Green"><span class="koboSpan" id="kobo.2225.1">2021</span></span><span class="koboSpan" id="kobo.2226.1">/12/13 </span><span class="Code_Green"><span class="koboSpan" id="kobo.2227.1">02</span></span><span class="koboSpan" id="kobo.2228.1">:03:19 whoisLookup tkng.io@whois.nic.io
</span><span class="Code_Green"><span class="koboSpan" id="kobo.2229.1">2021</span></span><span class="koboSpan" id="kobo.2230.1">/12/13 </span><span class="Code_Green"><span class="koboSpan" id="kobo.2231.1">02</span></span><span class="koboSpan" id="kobo.2232.1">:05:09 Incoming map[ip:[1.1.1.1]]
</span><span class="Code_Green"><span class="koboSpan" id="kobo.2233.1">2021</span></span><span class="koboSpan" id="kobo.2234.1">/12/13 </span><span class="Code_Green"><span class="koboSpan" id="kobo.2235.1">02</span></span><span class="koboSpan" id="kobo.2236.1">:05:09 whoisLookup </span><span class="Code_Green"><span class="koboSpan" id="kobo.2237.1">1</span></span><span class="koboSpan" id="kobo.2238.1">.1.1.1@whois.iana.org
</span><span class="Code_Green"><span class="koboSpan" id="kobo.2239.1">2021</span></span><span class="koboSpan" id="kobo.2240.1">/12/13 </span><span class="Code_Green"><span class="koboSpan" id="kobo.2241.1">02</span></span><span class="koboSpan" id="kobo.2242.1">:05:09 whoisLookup </span><span class="Code_Green"><span class="koboSpan" id="kobo.2243.1">1</span></span><span class="koboSpan" id="kobo.2244.1">.1.1.1@whois.apnic.net</span></pre>
<p><span class="koboSpan" id="kobo.2245.1">To run </span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.2246.1">this example, you need to open two tabs. </span><span class="koboSpan" id="kobo.2246.2">You first </span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.2247.1">run </span><strong class="source-inline"><span class="koboSpan" id="kobo.2248.1">go run *.go</span></strong><span class="koboSpan" id="kobo.2249.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.2250.1">ch04/http/server</span></strong><span class="koboSpan" id="kobo.2251.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.2252.1">Further reading</span></em><span class="koboSpan" id="kobo.2253.1">) and then from another tab, you can make the client queries from </span><strong class="source-inline"><span class="koboSpan" id="kobo.2254.1">ch04/http/client</span></strong><span class="koboSpan" id="kobo.2255.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.2256.1">Further reading</span></em><span class="koboSpan" id="kobo.2257.1">) with flags as in the outputs in the client part of </span><span class="No-Break"><span class="koboSpan" id="kobo.2258.1">this section.</span></span></p>
<h1 id="_idParaDest-126"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.2259.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.2260.1">In this chapter, we reviewed the different layers of the TCP/IP model and the applicability of Go to each one. </span><span class="koboSpan" id="kobo.2260.2">We went from changing the state of network interfaces on Linux systems to working with IP addresses, all the way to building a web </span><span class="No-Break"><span class="koboSpan" id="kobo.2261.1">application prototype.</span></span></p>
<p><span class="koboSpan" id="kobo.2262.1">Now you are ready to embark on the network automation journey and take all these lessons you’ve learned so far and apply them to make networks more efficient, reliable, and consistent. </span><span class="koboSpan" id="kobo.2262.2">This is what we begin to examine in </span><a href="B16971_05.xhtml#_idTextAnchor128"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.2263.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.2264.1">, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.2265.1">Network Automation</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.2266.1">.</span></span></p>
<h1 id="_idParaDest-127"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.2267.1">Further reading</span></h1>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.2268.1">syscall</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.2269.1">package: </span></span><a href="https://pkg.go.dev/syscall "><span class="No-Break"><span class="koboSpan" id="kobo.2270.1">https://pkg.go.dev/syscall</span></span></a></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.2271.1">vishvananda/netlink</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.2272.1">package: </span></span><a href="https://github.com/vishvananda/netlink "><span class="No-Break"><span class="koboSpan" id="kobo.2273.1">https://github.com/vishvananda/netlink</span></span></a></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.2274.1">mdlayher/netlink</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.2275.1">package: </span></span><a href="https://github.com/mdlayher/netlink "><span class="No-Break"><span class="koboSpan" id="kobo.2276.1">https://github.com/mdlayher/netlink</span></span></a></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.2277.1">mdlayher/netlink</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.2278.1">ecosystem: </span></span><a href="https://github.com/mdlayher/netlink#ecosystem "><span class="No-Break"><span class="koboSpan" id="kobo.2279.1">https://github.com/mdlayher/netlink#ecosystem</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2280.1">ch04/netlink</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2281.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch04/netlink "><span class="No-Break"><span class="koboSpan" id="kobo.2282.1">https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch04/netlink</span></span></a></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.2283.1">CAP_NET_ADMIN</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.2284.1">capabilities: </span></span><a href="https://man7.org/linux/man-pages/man7/capabilities.7.html "><span class="No-Break"><span class="koboSpan" id="kobo.2285.1">https://man7.org/linux/man-pages/man7/capabilities.7.html</span></span></a></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.2286.1">google/gopacket</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.2287.1">package: </span></span><a href="https://github.com/google/gopacket "><span class="No-Break"><span class="koboSpan" id="kobo.2288.1">https://github.com/google/gopacket</span></span></a></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.2289.1">mdlayher/ethernet</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.2290.1">package: </span></span><a href="https://github.com/mdlayher/ethernet "><span class="No-Break"><span class="koboSpan" id="kobo.2291.1">https://github.com/mdlayher/ethernet</span></span></a></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.2292.1">kube-vip</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.2293.1">package: </span></span><a href="https://github.com/kube-vip/kube-vip/tree/main/pkg/vip "><span class="No-Break"><span class="koboSpan" id="kobo.2294.1">https://github.com/kube-vip/kube-vip/tree/main/pkg/vip</span></span></a></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.2295.1">mdlayher/arp</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.2296.1">package: </span></span><a href="https://github.com/mdlayher/arp "><span class="No-Break"><span class="koboSpan" id="kobo.2297.1">https://github.com/mdlayher/arp</span></span></a></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.2298.1">mdlayher/packet</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.2299.1">package: </span></span><a href="https://github.com/mdlayher/packet "><span class="No-Break"><span class="koboSpan" id="kobo.2300.1">https://github.com/mdlayher/packet</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2301.1">ch04/vip</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2302.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch04/vip "><span class="No-Break"><span class="koboSpan" id="kobo.2303.1">https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch04/vip</span></span></a></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.2304.1">net</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.2305.1">package: </span></span><a href="https://pkg.go.dev/net "><span class="No-Break"><span class="koboSpan" id="kobo.2306.1">https://pkg.go.dev/net</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2307.1">ch04/net/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2308.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/net/main.go "><span class="No-Break"><span class="koboSpan" id="kobo.2309.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/net/main.go</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.2310.1">netaddr.IP: a new IP address type for </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.2311.1">Go</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.2312.1">: </span></span><a href="https://tailscale.com/blog/netaddr-new-ip-type-for-go/ "><span class="No-Break"><span class="koboSpan" id="kobo.2313.1">https://tailscale.com/blog/netaddr-new-ip-type-for-go/</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2314.1">ch04/parseip</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2315.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch04/parseip "><span class="No-Break"><span class="koboSpan" id="kobo.2316.1">https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch04/parseip</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2317.1">ch04/parseprefix</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2318.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch04/parseprefix "><span class="No-Break"><span class="koboSpan" id="kobo.2319.1">https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch04/parseprefix</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2320.1">cidranger</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2321.1">: </span></span><a href="https://github.com/yl2chen/cidranger "><span class="No-Break"><span class="koboSpan" id="kobo.2322.1">https://github.com/yl2chen/cidranger</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2323.1">ch04/trie/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2324.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/trie/main.go "><span class="No-Break"><span class="koboSpan" id="kobo.2325.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/trie/main.go</span></span></a></li>
<li><span class="koboSpan" id="kobo.2326.1">GeoLite2 Free Geolocation </span><span class="No-Break"><span class="koboSpan" id="kobo.2327.1">Data: </span></span><a href="https://dev.maxmind.com/geoip/geolite2-free-geolocation-data "><span class="No-Break"><span class="koboSpan" id="kobo.2328.1">https://dev.maxmind.com/geoip/geolite2-free-geolocation-data</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2329.1">ch04/geo/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2330.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/geo/main.go "><span class="No-Break"><span class="koboSpan" id="kobo.2331.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/geo/main.go</span></span></a></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.2332.1">iplib</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.2333.1">package: </span></span><a href="https://github.com/c-robinson/iplib "><span class="No-Break"><span class="koboSpan" id="kobo.2334.1">https://github.com/c-robinson/iplib</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2335.1">ch04/ipaddr/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2336.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/ipaddr/main.go "><span class="No-Break"><span class="koboSpan" id="kobo.2337.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/ipaddr/main.go</span></span></a></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.2338.1">cloudprober: </span></span><a href="https://github.com/cloudprober/cloudprober "><span class="No-Break"><span class="koboSpan" id="kobo.2339.1">https://github.com/cloudprober/cloudprober</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2340.1">ch04/udp-ping</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2341.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch04/udp-ping "><span class="No-Break"><span class="koboSpan" id="kobo.2342.1">https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch04/udp-ping</span></span></a></li>
<li><span class="koboSpan" id="kobo.2343.1">The book’s GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.2344.1">repository: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go "><span class="No-Break"><span class="koboSpan" id="kobo.2345.1">https://github.com/PacktPublishing/Network-Automation-with-Go</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2346.1">ch04/http/client/main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2347.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/http/client/main.go "><span class="No-Break"><span class="koboSpan" id="kobo.2348.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/http/client/main.go</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2349.1">ch04/http/server</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2350.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/http/server "><span class="No-Break"><span class="koboSpan" id="kobo.2351.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/http/server</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2352.1">ch04/http/client</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2353.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/http/client"><span class="No-Break"><span class="koboSpan" id="kobo.2354.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/http/client</span></span></a></li>
</ul>
</div>


<div class="Content" id="_idContainer052">
<h1 id="_idParaDest-128"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.1.1">Part 2: Common Tools and Frameworks</span></h1>
<p><span class="koboSpan" id="kobo.2.1">This part describes the existing challenges and objectives of network automation. </span><span class="koboSpan" id="kobo.2.2">You will learn how organizations are approaching this major undertaking and where we </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">are headed.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part of the book comprises the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B16971_05.xhtml#_idTextAnchor128"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 5</span></em></a><em class="italic"><span class="koboSpan" id="kobo.7.1">, Network Automation</span></em></li>
<li><a href="B16971_06.xhtml#_idTextAnchor144"><em class="italic"><span class="koboSpan" id="kobo.8.1">Chapter 6</span></em></a><em class="italic"><span class="koboSpan" id="kobo.9.1">, Configuration Management</span></em></li>
<li><a href="B16971_07.xhtml#_idTextAnchor161"><em class="italic"><span class="koboSpan" id="kobo.10.1">Chapter 7</span></em></a><em class="italic"><span class="koboSpan" id="kobo.11.1">, Automation Frameworks</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer053">
</div>
</div>
</body></html>