["```go\nfunc main() {\n    conn, err := rtnl.Dial(nil)\n    // process error\n    defer conn.Close()\n    links, err := conn.Links()\n    /* ... <continues next > ... */\n}\n```", "```go\nfunc main() {\n    /* ... <continues from before > ... */\n    var loopback *net.Interface\n    for _, l := range links {\n        if l.Name == \"lo\" {\n            loopback = l\n            log.Printf(\"Name: %s, Flags:%s\\n\", \n                        l.Name, l.Flags)\n        }\n    }\n    /* ... <continues next > ... */\n}\n```", "```go\nfunc main() {\n    /* ... <continues from before > ... */\n    conn.LinkDown(loopback)\n    loopback, _ = conn.LinkByIndex(loopback.Index)\n    log.Printf(\"Name: %s, Flags:%s\\n\", \n                loopback.Name, loopback.Flags)\n    conn.LinkUp(loopback)\n    loopback, _ = conn.LinkByIndex(loopback.Index)\n    log.Printf(\"Name: %s, Flags:%s\\n\", \n                loopback.Name, loopback.Flags)\n}\n```", "```go\nch04/netlink $ sudo go run main.go\n2021/11/24 20:55:29 Name: lo, Flags:up|loopback\n2021/11/24 20:55:29 Name: lo, Flags:loopback\n2021/11/24 20:55:29 Name: lo, Flags:up|loopback\n```", "```go\nfunc main() {\n    intfStr := flag.String(\"intf\", \"\", \"VIP interface\")\n    flag.Parse()\n    conn, err := rtnl.Dial(nil)\n    // process error\n    defer conn.Close()\n    netIntf, err := net.InterfaceByName(*intfStr)\n    ethSocket, err := packet.Listen(netIntf,\n                                packet.Raw, 0, nil)\n    // process error\n    defer ethSocket.Close()\n    /* ... <continues next > ... */\n}\n```", "```go\nconst VIP1 = \"198.51.100.1/32\"\ntype vip struct {\n    IP      string\n    netlink *rtnl.Conn\n    intf    *net.Interface\n    l2Sock  *raw.Conn\n}\nfunc (c *vip) addVIP() error {\n    err := c.netlink.AddrAdd(c.intf,\n                        rtnl.MustParseAddr(c.IP))\n    // process error\n    return nil\n}\nfunc main() {\n    /* ... <continues from before > ... */\n    v := &vip{\n        IP:      VIP1,\n        intf:    netIntf,\n        netlink: rtnl,\n        l2Sock:  *packet.Conn,\n    }\n    err = v.addVIP()\n     /* ... <continues next > ... */\n}\n```", "```go\nfunc main() {\n    /* ... <continues from before > ... */\n    for {\n        select {\n        /* ... <omitted for brevity > ... */\n        case <-timer.C:\n            if err := v.sendGARP(); err != nil {\n                log.Printf(\"fail send GARP %s\",\n                                err)\n                cancel()\n            }\n        }\n    }\n}\n```", "```go\nfunc (c *vip) sendGARP() error {\n    /* ... <omitted for brevity > ... */\n    arpPayload, err := arp.NewPacket(\n        arp.OperationReply,  // op\n        c.intf.HardwareAddr, // srcHW\n        ip,                  // srcIP\n        c.intf.HardwareAddr, // dstHW\n        ip,                  // dstIP\n    )\n    // process error\n\n    arpBinary, err := arpPayload.MarshalBinary()\n    /* ... <continues next > ... */\n}\n```", "```go\nfunc (c *vip) sendGARP() error {\n    /* ... <continues from before > ... */\n    ethFrame := &ethernet.Frame{\n        Destination: ethernet.Broadcast,\n        Source:      c.intf.HardwareAddr,\n        EtherType:   ethernet.EtherTypeARP,\n        Payload:     arpBinary,\n    }\n\n    return c.emitFrame(ethFrame)\n}\n```", "```go\nfunc (c *vip) emitFrame(frame *ethernet.Frame) error {\n    b, err := frame.MarshalBinary()\n    // process error\n\n    addr := &packet.Addr{\n                HardwareAddr:ethernet.Broadcast}\n    if _, err := c.l2Sock.WriteTo(b, addr); err != nil {\n        return fmt.Errorf(\"emitFrame failed: %s\", err)\n    }\n\n    log.Println(\"GARP sent\")\n    return nil\n}\n```", "```go\nch04/vip $ sudo go run main.go -intf eth0\n2021/11/25 18:47:51 GARP sent\n2021/11/25 18:47:54 GARP sent\n^C2021/11/25 18:47:56 Received syscall: interrupt\n2021/11/25 18:47:57 Cleanup complete\n```", "```go\ntype IP []byte\n```", "```go\nfunc main() {\n    ipv4 := net.ParseIP(\"192.0.2.1\")\n    fmt.Println(ipv4)\n}\n```", "```go\nfunc main() {\n    ipv6 := net.ParseIP(\"FC02:F00D::1\")\n    fmt.Println(ipv6)\n}\n```", "```go\nfunc main() {\n    // prints false\n    fmt.Println(ipv4.IsPrivate())\n    // prints true\n    fmt.Println(ipv6.IsPrivate())\n}\n```", "```go\ntype IPNet struct {\n    IP   IP     // network number\n    Mask IPMask // network mask\n}\n```", "```go\ntype IPMask []byte\nfunc CIDRMask(ones, bits int) IPMask\n```", "```go\nfunc main() {\n    // This mask corresponds to a /31 subnet for IPv4.\n    // prints [11111111 11111111 11111111 11111110]\n    fmt.Printf(\"%b\\n\",net.CIDRMask(31, 32))\n}\n```", "```go\nfunc main() {\n    // This mask corresponds to a /64 subnet for IPv6.\n    // prints ffffffffffffffff0000000000000000\n    fmt.Printf(\"%s\\n\",net.CIDRMask(64, 128))\n}\n```", "```go\nfunc main() {\n    ipv4Addr, ipv4Net, err := net.ParseCIDR(\"192.0.2.1/24\")\n    // process error\n    // prints 192.0.2.1\n    fmt.Println(ipv4Addr)\n    // prints 192.0.2.0/24\n    fmt.Println(ipv4Net)\n}\n```", "```go\nfunc main() {\n    ipv6Addr, ipv6Net, err :=  net.ParseCIDR(\n                                \"2001:db8:a0b:12f0::1/32\")\n    // process error\n    // prints 2001:db8:a0b:12f0::1\n    fmt.Println(ipv6Addr)\n    // prints 2001:db8::/32\n    fmt.Println(ipv6Net)\n}\n```", "```go\ntype Addr struct {\n    addr uint128\n    z *intern.Value\n}\n```", "```go\nfunc main() {\n    IPv4, err := netip.ParseAddr(\"224.0.0.1\")\n    // process error\n    // prints IPv4 address is Multicast\n    if IPv4.IsMulticast() {\n        fmt.Println(\"IPv4 address is Multicast\")\n    }\n    IPv6, err := netip.ParseAddr(\"FE80:F00D::1\")\n    // process error\n    // prints IPv6 address is Link Local Unicast\n    if IPv6.IsLinkLocalUnicast() {\n        fmt.Println(\"IPv6 address is Link Local Unicast\")\n    }\n}\n```", "```go\nfunc main() {\n    ipv4 := net.ParseIP(\"192.0.2.1\")\n    IPv4s, _ := netip.AddrFromSlice(ipv4)\n    fmt.Println(IPv4s.String())\n    fmt.Println(IPv4s.Unmap().Is4())\n}\n```", "```go\nch04/parseip$ go run main.go\n::ffff:192.0.2.1\ntrue\n```", "```go\ntype Prefix struct {\n    ip Addr\n    bits int16\n}\n```", "```go\nfunc main() {\n    addr1 := \"192.0.2.18\"\n    addr2 := \"198.51.100.3\"\n    network4 := \"192.0.2.0/24\"\n    pf := netip.MustParsePrefix(network4)\n    fmt.Printf(\n        \"Prefix address: %v, length: %v\\n\", \n        pf.Addr(), pf.Bits())\n    ip1 := netip.MustParseAddr(addr1)\n    if pf.Contains(ip1) {\n        fmt.Println(addr1, \" is in \", network4)\n    }\n    ip2 := netip.MustParseAddr(addr2)\n    if pf.Contains(ip2) {\n        fmt.Println(addr2, \" is in \", network4)\n    }\n}\n```", "```go\nch04/parseprefix$ go run main.go\nPrefix address: 192.0.2.0, length: 24\n192.0.2.18  is in  192.0.2.0/24\n```", "```go\nfunc main() {\n    ranger := cidranger.NewPCTrieRanger()\n    IPs := []string{\n        \"100.64.0.0/16\",\n        \"127.0.0.0/8\",\n        \"172.16.0.0/16\",\n        \"192.0.2.0/24\",\n        \"192.0.2.0/24\",\n        \"192.0.2.0/25\",\n        \"192.0.2.127/25\",\n    }\n    for _, prefix := range IPs {\n        ipv4Addr, ipv4Net, err := net.ParseCIDR(prefix)\n        // process error\n        ranger.Insert(\n                cidranger.NewBasicRangerEntry(*ipv4Net))\n    }\n    /* ... <continues next > ... */\n}\n```", "```go\nfunc main() {\n    /* ... <continues from before > ... */\n    checkIP := \"127.0.0.1\"\n    ok, err := ranger.Contains(net.ParseIP(checkIP))\n    // process error\n    // prints Does the range contain 127.0.0.1?: true\n    fmt.Printf(\"Does the range contain %s?: %v\\n\",\n                    checkIP, ok)\n    /* ... <continues next > ... */\n}\n```", "```go\nfunc main() {\n    /* ... <continues from before > ... */\n    netIP := \"192.0.2.18\"\n    nets, err := ranger.ContainingNetworks(\n                            net.ParseIP(netIP))\n    // process error\n    fmt.Printf(\n    \"\\nNetworks that contain IP address %s ->\\n\", netIP)\n    for _, e := range nets {\n        n := e.Network()\n        fmt.Println(\"\\t\", n.String())\n    }\n}\n```", "```go\nch04/trie$ go run main.go\nNetworks that contain IP address 192.0.2.18 ->\n     192.0.2.0/24\n     192.0.2.0/25\n```", "```go\nfunc main() {\n    db, err := geoip2.Open(\"GeoIP2-City-Test.mmdb\")\n    // process error \n    defer db.Close()\n    IPs := []string{\n        \"81.2.69.143\",\n        /* ... <omitted for brevity > ... */\n    }\n    fmt.Println(\"Find information for each prefix:\")\n    for _, prefix := range IPs {\n        ip := net.ParseIP(prefix)\n        record, err := db.City(ip)\n        // process error\n\n        fmt.Printf(\"\\nAddress: %v\\n\", prefix)\n        fmt.Printf(\"City name: %v\\n\",\n                        record.City.Names[\"en\"])\n        /* ... <omitted for brevity > ... */\n    }\n}\n```", "```go\nch04/geo$ go run main.go\nFind information for each prefix:\n...\nAddress: 81.2.69.143\nCity name: Norwich\nCountry name: United Kingdom\nISO country code: GB\nTime zone: Europe/London\nCoordinates: 52.6259, 1.3032\n```", "```go\nfunc main() {\n    IP := net.ParseIP(\"192.0.2.1\")\n    nextIP := iplib.NextIP(IP)\n    incrIP := iplib.IncrementIPBy(nextIP, 19)\n    // prints 20\n    fmt.Println(iplib.DeltaIP(IP, incrIP))\n    // prints -1\n    fmt.Println(iplib.CompareIPs(IP, incrIP))\n}\n```", "```go\nfunc main() {\n    iplist := []net.IP{incrIP, nextIP, IP}\n    // prints [192.0.2.21 192.0.2.2 192.0.2.1]\n    fmt.Println(iplist)\n    sort.Sort(iplib.ByIP(iplist))\n    // prints [192.0.2.1 192.0.2.2 192.0.2.21]\n    fmt.Println(iplist) \n}\n```", "```go\nfunc main() {\n    n4 := iplib.NewNet4(net.ParseIP(\"198.51.100.0\"), 24)\n    fmt.Println(\"Total IP addresses: \", n4.Count())\n    fmt.Println(\"First three IPs: \", n4.Enumerate(3, 0))\n    fmt.Println(\"First IP: \", n4.FirstAddress())\n    fmt.Println(\"Last IP: \", n4.LastAddress())\n}\n```", "```go\nch04/ipaddr$ go run main.go\n...\nTotal IP addresses:  254\nFirst three IPs:  [198.51.100.1 198.51.100.2 198.51.100.3]\nFirst IP:  198.51.100.1\nLast IP:  198.51.100.254\n```", "```go\nfunc main() {\n    listenAddr     = \"0.0.0.0\"\n    listenPort     = 32767\n    listenSoc := &net.UDPAddr{\n        IP:   net.ParseIP(listenAddr),\n        Port: listenPort,\n    }\n    udpConn, err := net.ListenUDP(\"udp\", listenSoc)\n    // process error\n    defer udpConn.Close()\n    /* ... <continues next > ... */\n}\n```", "```go\nfunc main() {\n    /* ... <continues from before > ... */\n    for {\n        maxReadBuffer  = 425984\n        bytes := make([]byte, maxReadBuffer)\n\n        retryTimeout   = time.Second * 5\n        if err := udpConn.SetReadDeadline(\n                        time.Now().Add(retryTimeout))\n        // process error\n        len, raddr, err := udpConn.ReadFromUDP(bytes)\n        if err != nil {\n            log.Printf(\"failed to ReadFromUDP: %s\", err)\n            continue\n        }\n        log.Printf(\"Received a probe from %s:%d\",\n                        raddr.IP.String(), raddr.Port)\n        n, err := udpConn.WriteToUDP(bytes[:len], raddr)\n        // process error\n    }\n}\n```", "```go\nfunc main() {\n    rAddr := &net.UDPAddr{\n        IP:   net.ParseIP(\"127.0.0.1\"),\n        Port: \"32767\",\n    }\n    udpConn, err := net.DialUDP(\"udp\", nil, rAddr)\n    // process error\n    defer udpConn.Close()\n    /* ... <continues next > ... */\n}\n```", "```go\nfunc main() {\n    /* ... <continues from before > ... */\n    go receive(*udpConn)\n    var seq uint8\n    for {\n        log.Printf(\"Sending probe %d\", seq)\n        p := &probe{\n            SeqNum: seq,\n            SendTS: time.Now().UnixMilli(),\n        }\n        if err := binary.Write(udpConn,\n                        binary.BigEndian, p)\n        // process error\n        seq++\n    }\n}\n```", "```go\nfunc receive(udpConn net.UDPConn) {\n    var nextSeq uint8\n    var lost int\n    for {\n        p := &probe{}\n        if err := binary.Read(&udpConn,\n                                binary.BigEndian, p)\n        // process error\n        if p.SeqNum < nextSeq {\n            log.Printf(\"Out of order packet seq: %d/%d\",\n                                p.SeqNum, nextSeq)\n            lost -= 1\n        } else if p.SeqNum > nextSeq {\n            log.Printf(\"Out of order packet seq: %d/%d\",\n                                p.SeqNum, nextSeq)\n            lost += int(p.SeqNum - nextSeq)\n            nextSeq = p.SeqNum\n        }\n        latency := time.Now().UnixMilli() - p.SendTS\n        log.Printf(\"E2E latency: %d ms\", latency)\n        log.Printf(\"Lost packets: %d\", lost)\n        nextSeq++\n    }\n}\n```", "```go\nch04/udp-ping/client$ sudo go run main.go\n2021/12/10 15:10:31 Starting UDP ping client\n2021/12/10 15:10:31 Starting UDP ping receive loop\n2021/12/10 15:10:32 Sending probe 0\n2021/12/10 15:10:32 Received probe 0\n2021/12/10 15:10:32 E2E latency: 9 ms\n2021/12/10 15:10:32 Lost packets: 0\n2021/12/10 15:10:33 Sending probe 1\n2021/12/10 15:10:33 Received probe 1\n2021/12/10 15:10:33 E2E latency: 8 ms\n2021/12/10 15:10:33 Lost packets: 0\n2021/12/10 15:10:34 Sending probe 2\n2021/12/10 15:10:34 Received probe 2\n2021/12/10 15:10:34 E2E latency: 9 ms\n2021/12/10 15:10:34 Lost packets: 0\n...\n```", "```go\nch04/udp-ping/server$ sudo go run main.go\n2021/12/10 15:10:28 Starting the UDP ping server\n2021/12/10 15:10:32 Received a probe from 198.51.100.173:59761\n2021/12/10 15:10:33 Received a probe from 198.51.100.173:59761\n2021/12/10 15:10:34 Received a probe from 198.51.100.173:59761\n...\n```", "```go\nfunc main() {\n    server := \"localhost:8080\"\n    // One of: mac, ip, domain\n    lookup := \"domain\"\n    // Examples: 68b5.99fc.d1df, 1.1.1.1, tkng.io\n    argument := \"tkng.io\"\n    path := \"/lookup\"\n    addr, err := url.Parse(\"http://\" + server + path)\n    // process error\n    params := url.Values{}\n    params.Add(lookup, argument)\n    addr.RawQuery = params.Encode()\n    /* ... <continues next > ... */\n}\n```", "```go\ntype Client struct {\n    Transport RoundTripper\n    CheckRedirect func(req *Request, via []*Request) error\n    Jar CookieJar\n    Timeout time.Duration\n}\n```", "```go\nvar DefaultTransport RoundTripper = &Transport{\n    Proxy: ProxyFromEnvironment,\n    DialContext: (&net.Dialer{\n        Timeout:   30 * time.Second,\n        KeepAlive: 30 * time.Second,\n    }).DialContext,\n    ForceAttemptHTTP2:     true,\n    MaxIdleConns:          100,\n    IdleConnTimeout:       90 * time.Second,\n    TLSHandshakeTimeout:   10 * time.Second,\n    ExpectContinueTimeout: 1 * time.Second,\n}\n```", "```go\nfunc main() {\n    /* ... <continues from before > ... */\n    res, err := http.DefaultClient.Get(addr.String())\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer res.Body.Close()\n    io.Copy(os.Stdout, res.Body)\n}\n```", "```go\n    ch04/http/client$ go run main.go -check\n    ```", "```go\n    OK\n    ```", "```go\n    ch04/http/client$ go run main.go -lookup mac 68b5.99fc.d1df\n    ```", "```go\n    Hewlett Packard\n    ```", "```go\n    ch04/http/client$ go run main.go -lookup domain tkng.io\n    ```", "```go\n    Domain Name: tkng.io\n    ```", "```go\n    Registry Domain ID: 5cdbf549b56144f5afe00b62ccd8d6e9-DONUTS\n    ```", "```go\n    Registrar WHOIS Server: whois.namecheap.com\n    ```", "```go\n    Registrar URL: https://www.namecheap.com/\n    ```", "```go\n    Updated Date: 2021-09-24T20:39:04Z\n    ```", "```go\n    Creation Date: 2021-07-26T19:08:34Z\n    ```", "```go\n    Registry Expiry Date: 2022-07-26T19:08:34Z\n    ```", "```go\n    Registrar: NameCheap, Inc.\n    ```", "```go\n    Registrar IANA ID: 1068\n    ```", "```go\n    ch04/http/client$ go run main.go -lookup ip 1.1.1.1\n    ```", "```go\n    ...\n    ```", "```go\n    inetnum:        1.1.1.0 - 1.1.1.255\n    ```", "```go\n    netname:        APNIC-LABS\n    ```", "```go\n    descr:          APNIC and Cloudflare DNS Resolver project\n    ```", "```go\n    descr:          Routed globally by AS13335/Cloudflare\n    ```", "```go\n    descr:          Research prefix for APNIC Labs\n    ```", "```go\n    country:        AU\n    ```", "```go\ntype Server struct {\n    Addr string\n    Handler Handler\n    TLSConfig *tls.Config\n    ReadTimeout time.Duration\n    ReadHeaderTimeout time.Duration\n    /* ... <omitted for brevity > ... */\n}\n```", "```go\nfunc main() {\n    /* ... <omitted for brevity > ... */\n    log.Println(\"Starting web server at 0.0.0.0:8080\")\n    srv := http.Server{Addr: \"0.0.0.0:8080\"}\n    // ListenAndServe always returns a non-nil error.\n    log.Fatal(srv.ListenAndServe())\n}\n```", "```go\ntype Handler interface {\n    ServeHTTP(ResponseWriter, *Request)\n}\n```", "```go\n    type ResponseWriter interface {\n    ```", "```go\n        Header() Header\n    ```", "```go\n        // Write writes the data to the connection \n    ```", "```go\n        // as part of an HTTP reply.\n    ```", "```go\n        Write([]byte) (int, error)\n    ```", "```go\n        // WriteHeader sends an HTTP response header\n    ```", "```go\n        // with the provided status code.\n    ```", "```go\n        WriteHeader(statusCode int)\n    ```", "```go\n    }\n    ```", "```go\n    type Request struct {\n    ```", "```go\n        // Method specifies the HTTP method\n    ```", "```go\n        // (GET, POST, PUT, etc.).\n    ```", "```go\n        Method string\n    ```", "```go\n        // URL specifies either the URI being requested\n    ```", "```go\n        // (for server requests) or the URL to access \n    ```", "```go\n        // (for client requests).\n    ```", "```go\n        URL *url.URL\n    ```", "```go\n        Header Header\n    ```", "```go\n        Body io.ReadCloser\n    ```", "```go\n        /* ... <omitted for brevity > ... */\n    ```", "```go\n    }\n    ```", "```go\nfunc main() {\n    http.HandleFunc(\"/lookup\", lookup)\n    http.HandleFunc(\"/check\", check)\n    /* ... <omitted for brevity > ... */\n}\n```", "```go\n    func lookup(w http.ResponseWriter, req *http.Request) {\n    ```", "```go\n        log.Printf(\"Incoming %+v\", req.URL.Query())\n    ```", "```go\n        var response string\n    ```", "```go\n        for k, v := range req.URL.Query() {\n    ```", "```go\n            switch k {\n    ```", "```go\n            case \"ip\":\n    ```", "```go\n                response = getWhois(v)\n    ```", "```go\n            case \"mac\":\n    ```", "```go\n                response = getMAC(v)\n    ```", "```go\n            case \"domain\":\n    ```", "```go\n                response = getWhois(v)\n    ```", "```go\n            default:\n    ```", "```go\n                response = fmt.Sprintf(\n    ```", "```go\n                            \"query %q not recognized\", k)\n    ```", "```go\n            }\n    ```", "```go\n        }\n    ```", "```go\n        fmt.Fprintf(w, response)\n    ```", "```go\n    }\n    ```", "```go\nch04/http/server$ go run *.go\n2021/12/13 02:02:39 macDB initialized\n2021/12/13 02:02:39 Starting web server at 0.0.0.0:8080\n2021/12/13 02:02:56 Incoming map[mac:[68b5.99fc.d1df]]\n2021/12/13 02:03:19 Incoming map[domain:[tkng.io]]\n2021/12/13 02:03:19 whoisLookup tkng.io@whois.iana.org\n2021/12/13 02:03:19 whoisLookup tkng.io@whois.nic.io\n2021/12/13 02:05:09 Incoming map[ip:[1.1.1.1]]\n2021/12/13 02:05:09 whoisLookup 1.1.1.1@whois.iana.org\n2021/12/13 02:05:09 whoisLookup 1.1.1.1@whois.apnic.net\n```"]