- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Networking (TCP/IP) with Go
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Go进行网络（TCP/IP）
- en: Every network engineer has at some point learned about the seven layers of the
    **Open Systems Interconnection** (**OSI**) model. A more concise version of it,
    with only four layers, is the TCP/IP model, which is the architectural model that
    governs communications over the internet.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每个网络工程师都曾在某个时候学习过**开放系统互连**（**OSI**）模型的七层。它的一个更简洁的版本，只有四层，就是TCP/IP模型，这是控制互联网通信的架构模型。
- en: Each layer defines a function, which one data communication protocol per layer
    performs. These layers pile one upon another, so we often call this collection
    of protocols a protocol stack. A data packet has to go through each of the four
    layers of the protocol stack before it gets to the destination host.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 每一层定义了一个功能，每一层的数据通信协议执行一个。这些层堆叠在一起，所以我们通常称这个协议集合为协议栈。数据包必须通过协议栈的每一层才能到达目标主机。
- en: 'Go has several packages to work with protocols at each layer of the TCP/IP
    model. This enables us to build solutions for an array of use cases – from IP
    address management to running application transactions through the network or
    even implementing network protocols:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Go有几个包可以用于TCP/IP模型每一层的协议。这使得我们能够为各种用例构建解决方案——从IP地址管理到通过网络运行应用程序事务，甚至实现网络协议：
- en: '![Figure 4.1 – TCP/IP model](img/B16971_04_01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – TCP/IP模型](img/B16971_04_01.jpg)'
- en: Figure 4.1 – TCP/IP model
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – TCP/IP模型
- en: 'In this chapter, we focus on use cases for each of the layers of the TCP/IP
    model:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们关注TCP/IP模型每一层的应用场景：
- en: Link
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接
- en: Internet
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网
- en: Transport
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输
- en: Application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We assume basic familiarity with the command line, Git, and GitHub. You can
    find the code examples for this chapter in the book’s GitHub repository: [https://github.com/PacktPublishing/Network-Automation-with-Go](https://github.com/PacktPublishing/Network-Automation-with-Go),
    under the `ch04` folder.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设你对命令行、Git和GitHub有基本的了解。你可以在此章的GitHub仓库中找到此章的代码示例：[https://github.com/PacktPublishing/Network-Automation-with-Go](https://github.com/PacktPublishing/Network-Automation-with-Go)，在`ch04`文件夹下。
- en: 'To run the examples, you’ll need to do the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行示例，你需要执行以下操作：
- en: Install Go 1.17 or later for your operating system. You can follow the instructions
    in [*Chapter 1*](B16971_01.xhtml#_idTextAnchor015), *Introduction*, in the section
    *Installing Go*, or go to [https://go.dev/doc/install](https://go.dev/doc/install).
    Two examples in this chapter, specifically those for the net/netip package, require
    Go 1.18 or later.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的操作系统安装Go 1.17或更高版本。你可以遵循[*第1章*](B16971_01.xhtml#_idTextAnchor015)中“介绍”部分的*安装Go*部分的说明，或者访问[https://go.dev/doc/install](https://go.dev/doc/install)。本章中的两个示例，特别是针对net/netip包的示例，需要Go
    1.18或更高版本。
- en: Clone the book’s GitHub repository with `git` `clone https://github.com/PacktPublishing/Network-Automation-with-Go.git`.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`git` `clone https://github.com/PacktPublishing/Network-Automation-with-Go.git`克隆本书的GitHub仓库。
- en: 'Change the directory to an example folder: `cd Network-Automation-with-Go/ch04/trie`.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目录更改为示例文件夹：`cd Network-Automation-with-Go/ch04/trie`。
- en: Execute `go` `run main.go`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`go` `run main.go`。
- en: The link layer
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链路层
- en: 'We start with the bottom layer of the TCP/IP model that sends and receives
    link layer data frames. In this section, we cover the following topics:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从TCP/IP模型的底层开始，该层发送和接收链路层数据帧。在本节中，我们将涵盖以下主题：
- en: Management of network interfaces
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络接口管理
- en: Basic operations with Ethernet
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太网的基本操作
- en: Network interfaces
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络接口
- en: As we see more and more network operating systems based on Linux, it makes sense
    to understand how Go can help us interact with network interfaces in this context.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们越来越多地看到基于Linux的网络操作系统，了解Go如何帮助我们在这个环境中与网络接口交互是有意义的。
- en: Linux exposes its networking internals through a kernel interface called Netlink.
    This interface allows user-space applications such as Go to communicate with the
    kernel over a standard socket API. Most commonly, TCP/UDP libraries use Netlink
    sockets to send and receive data, but they can also work with most Linux networking
    constructs, from interfaces to routes and nftables.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Linux通过一个名为Netlink的内核接口暴露其网络内部结构。这个接口允许用户空间的应用程序，如Go，通过标准套接字API与内核通信。最常见的是，TCP/UDP库使用Netlink套接字发送和接收数据，但它们也可以与大多数Linux网络结构一起工作，从接口到路由和nftables。
- en: 'Thankfully, you don’t need to learn about or understand the low-level Netlink
    API, as there are many Go packages that deliver high-level abstractions, making
    it much easier to work with. Some notable Netlink packages include the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你不需要了解或理解低级的Netlink API，因为有许多Go包提供了高级抽象，这使得工作变得更加容易。一些值得注意的Netlink包包括以下内容：
- en: The `syscall` package (*Further reading*) of the Go standard library, which
    includes several low-level primitives typically used by high-level packages.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go标准库中的`syscall`包（*进一步阅读*）包括一些通常由高级包使用的高级原语。
- en: The `vishvananda/netlink` (*Further reading*) third-party Go package is one
    of the earlier implementations of a high-level Netlink package, widely used by
    various open source projects such as Docker, Istio, and Kubernetes CNI plugins.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方Go包`vishvananda/netlink`（*进一步阅读*）是高级Netlink包的早期实现之一，被Docker、Istio和Kubernetes
    CNI插件等众多开源项目广泛使用。
- en: The ecosystem of plugins based on the `mdlayher/netlink` (*Further reading*)
    package is a set of relatively recent projects implemented on a common foundation
    in a more idiomatic and maintainable way.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于`mdlayher/netlink`（*进一步阅读*）包的插件生态系统是一组相对较新的项目，它们在共同的基础上以更符合语言习惯和可维护的方式实现。
- en: These Netlink packages have varying levels of feature coverage and the one you
    choose normally depends on your application requirements. For a demonstration,
    we show how to toggle the administrative state of an interface, and to do that,
    we pick one of the rtnetlink packages from the `mdlayher/netlink` ecosystem (*Further
    reading*).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些Netlink包具有不同的功能覆盖范围，你选择的包通常取决于你的应用程序需求。为了演示，我们展示了如何切换接口的管理状态，为此，我们从`mdlayher/netlink`生态系统（*进一步阅读*）中选择了一个rtnetlink包。
- en: 'Let’s break down and review this example in three stages. First, we import
    the Netlink package `rtnetlink/rtnl`, which is one of the loosely related packages
    developed around the `mdlayher/netlink` package, to establish a connection with
    a Netlink socket with the `Dial` method and then retrieve the list of all local
    interfaces with the `Links` method over the connection:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分三个阶段来分解和回顾这个示例。首先，我们导入Netlink包`rtnetlink/rtnl`，这是围绕`mdlayher/netlink`包开发的松散相关包之一，使用`Dial`方法与Netlink套接字建立连接，然后通过连接使用`Links`方法检索所有本地接口的列表：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This preceding code resembles what we do for all remote connections in Go, which
    is why Go developers consider this package more idiomatic. Once we have the list
    of all the interfaces in the variable links, we can iterate over them to find
    any interface of interest.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们为所有远程连接在Go中执行的操作相似，这也是为什么Go开发者认为这个包更符合语言习惯。一旦我们有了变量`links`中所有接口的列表，我们就可以遍历它们以找到任何感兴趣的接口。
- en: 'Let’s say we want to toggle the `lo` interface if it’s present in the system.
    We loop over all the interfaces in the variable links, and we print out the data
    of the `lo` interface if we find it and store the interface value in a variable
    we call `loopback`, so we can bring this link down with `LinkDown` and bring it
    back up with `LinkUp` later:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要切换系统中存在的`lo`接口。我们遍历变量`links`中的所有接口，如果在其中找到`lo`接口，我们就打印出该接口的数据，并将接口值存储在我们称之为`loopback`的变量中，这样我们就可以使用`LinkDown`将其关闭，稍后使用`LinkUp`将其重新启用：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After running `LinkDown` and `LinkUp`, you can verify that the change had the
    desired effect by retrieving the interface settings from Netlink after each change.
    We update the `loopback` variable for a uniform printed statement:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行`LinkDown`和`LinkUp`之后，你可以通过在每次更改后从Netlink检索接口设置来验证更改是否产生了预期的效果。我们更新`loopback`变量以实现统一的打印语句：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can find this example in full in `ch04/netlink` (*Further reading*) and
    you must run it with `CAP_NET_ADMIN` capabilities (*Further reading*) or as root:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`ch04/netlink`（*进一步阅读*）中找到这个示例的完整内容，你必须使用`CAP_NET_ADMIN`能力（*进一步阅读*）或以root用户身份运行：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We’ve only just scratched the surface of the Netlink API as its abilities extend
    far beyond the scope of this book. Today, you can use Netlink for everything from
    IP route management to access lists and from **Quality of Service** (**QoS**)
    policies to **extended Berkeley Packet Filter** (**eBPF**) program attachments.
    Hopefully, this section provides enough information to give you an idea of what’s
    involved in Netlink API interactions, as now we have to move on to the next topic
    and explore how Go deals with the most widely used link layer protocol today:
    Ethernet.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚触及了Netlink API的表面，因为它的能力远远超出了本书的范围。今天，你可以使用Netlink进行IP路由管理、访问列表、**服务质量**（**QoS**）策略以及**扩展伯克利包过滤器**（**eBPF**）程序附加等操作。希望这一节提供了足够的信息，让你对Netlink
    API交互所涉及的内容有一个大致的了解，因为现在我们必须转到下一个主题，探索Go如何处理今天最广泛使用的链路层协议：以太网。
- en: Ethernet
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以太网
- en: 'Working with Ethernet may involve a wide range of activities, from low-level
    protocol decoding, manipulating, and encoding to interactions with device APIs
    to collect Ethernet hardware information. Go has a broad spectrum of packages
    to help you deal with various Ethernet-related tasks:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与以太网一起工作可能涉及各种活动，从低级协议解码、操作和编码到与设备API交互以收集以太网硬件信息。Go有一系列广泛的包可以帮助你处理各种与以太网相关的任务：
- en: One of the most widely used packet processing packages is `google/gopacket`
    (*Further reading*), which you can use for both packet capturing and protocol
    decoding. It goes beyond just Ethernet, and we cover it in more detail in [*Chapter
    10*](B16971_10.xhtml#_idTextAnchor225), *Network Monitoring*.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最广泛使用的包处理包之一是`google/gopacket`（*进一步阅读*），你可以用它进行数据包捕获和协议解码。它不仅限于以太网，我们将在[*第10章*](B16971_10.xhtml#_idTextAnchor225)
    *网络监控*中更详细地介绍它。
- en: The Netlink API packages we just covered can query link-layer hardware information
    for Linux-based operating systems.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们刚才提到的Netlink API包可以查询基于Linux操作系统的链路层硬件信息。
- en: Another Ethernet encoding and decoding package `mdlayher/ethernet` (*Further
    reading*) allows you to convert frames between binary wire format and a static
    Go type representation.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个广泛使用的以太网编码和解码包`mdlayher/ethernet`（*进一步阅读*）允许你将帧在二进制线格式和静态Go类型表示之间进行转换。
- en: 'In the next example, we cover a basic implementation of a `virtual IP` (`VIP`)
    capability. We loosely based this implementation on the `kube-vip` (*Further reading*)
    package – a Kubernetes control plane VIP controller. The way it works is a two-step
    process:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将介绍一个`虚拟IP`（`VIP`）功能的基本实现。我们这个实现是基于`kube-vip`（*进一步阅读*）包的，这是一个Kubernetes控制平面VIP控制器。它的工作方式是一个两步过程：
- en: It allocates a new **VIP** to one of the local network interfaces.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将一个新的**VIP**分配给本地网络接口之一。
- en: It periodically sends out gratuitous **Address Resolution Protocol** (**ARP**)
    packets to let everyone in the local broadcast domain know about this VIP.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它定期发送无用的**地址解析协议**（**ARP**）数据包，让本地广播域中的每个人都知道这个VIP。
- en: Let’s review this from the first step and see how we assign a VIP to an interface.
    We’ll use the same package to interact with Netlink as we used in the *Network
    interfaces* section (`rtnetlink/rtnl`), only this time we use the `AddrAdd` method
    to assign an IP prefix to the interface we specify.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一步开始回顾，看看我们是如何将一个VIP分配给接口的。我们将使用与*网络接口*部分相同的包来与Netlink交互（`rtnetlink/rtnl`），只是这次我们使用`AddrAdd`方法将IP前缀分配给指定的接口。
- en: 'In the program, we pass the name of the interface we want to assign to this
    VIP address via the CLI using the `flag` package and we store this value in the
    `intfStr` variable. With this info, we use the `mdlayher/packet` package to send
    and receive ARP packets over this interface with the `Listen` function:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中，我们通过`flag`包使用CLI传递我们想要分配给这个VIP地址的接口名称，并将这个值存储在`intfStr`变量中。有了这个信息，我们使用`mdlayher/packet`包通过`Listen`函数在这个接口上发送和接收ARP数据包：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To actually assign the VIP address to the interface, we create the `vip` struct
    type that lets us hold all the information we need to pass to `AddrAdd` to make
    this happen, as the next output shows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际将VIP地址分配给接口，我们创建了一个`vip`结构体类型，它允许我们保存所有需要传递给`AddrAdd`以实现这一功能的信息，如下一个输出所示：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once we have the new VIP assigned, we can start sending out the `for` loop,
    which sleeps for 3 seconds and runs again. In this loop, we include an `if` with
    initialization (`err := v.sendGARP()`) and conditional (`err != nil`) statements.
    Go executes the initialization statement before evaluating the conditional expression:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们分配了新的VIP，我们就可以开始发送`for`循环，该循环暂停3秒钟然后再次运行。在这个循环中，我们包括一个带有初始化（`err := v.sendGARP()`）和条件（`err
    != nil`）语句的`if`语句。Go在评估条件表达式之前执行初始化语句：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Inside the `sendGARP` method is where we can find most of the Ethernet-related
    code. Here, we use two packages to help us build the GARP.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在`sendGARP`方法中，我们可以找到大部分与以太网相关的代码。在这里，我们使用两个包来帮助我们构建GARP。
- en: 'We first need to build the GARP payload and populate it with the MAC address
    of the local interface and the IP address of the VIP. For this, we take advantage
    of the `mdlayher/arp` (*Further* *reading*) package:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要构建GARP有效载荷，并用本地接口的MAC地址和VIP的IP地址填充它。为此，我们利用`mdlayher/arp`（*进一步阅读*）包：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then we need to wrap the GARP payload inside an Ethernet frame and set the
    right Ethernet headers using the `mdlayher/ethernet` (*Further* *reading*) package:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要使用`mdlayher/ethernet`（*进一步阅读*）包将GARP有效载荷包裹在以太网帧中，并设置正确的以太网头部：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The last step is to send a binary frame and to do that, we use the `mdlayher/packet`
    (*Further reading*) package that implements the Linux packet socket interface
    that lets us send and receive packets at the device driver (link-layer) level.
    We have already opened a raw socket, `ethSocket`, using `Listen` as shown earlier,
    so now we can write our binary frame into it (`field l2Sock` of the `vip` struct):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是发送一个二进制帧，为此，我们使用实现Linux数据包套接字接口的`mdlayher/packet`（*进一步阅读*）包，该接口允许我们在设备驱动程序（链路层）级别发送和接收数据包。我们已经使用`Listen`（如前所述）打开了一个原始套接字`ethSocket`，因此现在我们可以将我们的二进制帧写入其中（`vip`结构体的`l2Sock`字段）：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can find the full example at `ch04/vip` (*Further reading*). You need to
    run it with elevated privileges to be able to make changes to network interfaces.
    The resulting output would look like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`ch04/vip`（*进一步阅读*）中找到完整的示例。您需要以提升的权限运行它，才能更改网络接口。生成的输出将类似于以下内容：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At this point, any host with an overlapping IP subnet on the local network segment
    should be able to ping the `198.51.100.1` address (if they accept GARPs). To end
    the program, you can press *Ctrl* + *C* and the program cleans up the VIP from
    the interface.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，任何在本地网络段上有重叠IP子网的主机都应该能够ping `198.51.100.1`地址（如果它们接受GARPs）。要结束程序，您可以按*Ctrl*
    + *C*，程序将清理VIP接口。
- en: It’s rare for a network engineer or a developer to interact with Ethernet directly,
    but it’s still worth knowing what it feels like to *talk Ethernet* using Go. In
    the next section, we move one layer up and cover the internet layer packages and
    examples.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 网络工程师或开发者直接与以太网交互的情况很少见，但了解使用Go进行“谈论以太网”的感觉仍然很有价值。在下一节中，我们将向上移动一层，并介绍网络层包和示例。
- en: The internet layer
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络层
- en: The internet layer or network layer in the OSI model is in charge of transferring
    variable-length network packets and routing data from a source to a destination
    through one or more networks.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在OSI模型中，网络层或互联网层负责传输可变长度的网络数据包，并通过一个或多个网络将数据从源传输到目的。
- en: 'The predominant protocol in this layer today is the **Internet Protocol** (**IP**)
    on either of its two versions: version 4 (IPv4) or version 6 (IPv6). The internet
    layer also includes diagnostic protocols such as **Internet Control Message Protocol**
    (**ICMP**), a secure network protocol suite such as **Internet Protocol Security**
    (**IPsec**), and routing protocols including **Open Shortest Path** **First**
    (**OSPF**).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个层中，目前占主导地位的协议是**互联网协议**（**IP**），它可以是两个版本中的任何一个：版本4（IPv4）或版本6（IPv6）。网络层还包括诊断协议，如**互联网控制消息协议**（**ICMP**），一个安全的网络协议套件，如**互联网协议安全**（**IPsec**），以及包括**开放最短路径优先**（**OSPF**）在内的路由协议。
- en: The IP exchanges information via IP datagrams built from a header and a payload,
    which the link layer then transmits as frames over specific network hardware such
    as Ethernet. The IP header carries the IP source and destination addresses of
    a packet used to route it through the internet.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: IP通过从头部和有效载荷构建的IP数据报交换信息，该数据报由链路层作为帧通过特定的网络硬件（如以太网）传输。IP头部携带数据包的IP源地址和目的地址，用于通过互联网路由该数据包。
- en: 'In this section, we review the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾以下内容：
- en: How to use the `net` package to parse and perform common tasks with IP addresses
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 `net` 包解析和执行与 IP 地址相关的常见任务
- en: The new `net/netip` package and what features it brings to the Go standard library
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的 `net/netip` 包及其为 Go 标准库带来的特性
- en: Examples of real-life Go projects that work with IP addresses
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 IP 地址一起工作的真实 Go 项目的示例
- en: The net package
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: net 包
- en: 'The `net` package (*Further reading*) from the standard library includes a
    wide range of tools and resources for network connectivity and, most importantly
    for this section, defines types and interfaces to work with IP addresses. One
    of these types is `IP`, represented as a slice of bytes. This type is valid for
    4-byte (IPv4) or 16-byte (IPv6) slices:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的 `net` 包（*进一步阅读*）包括了一系列用于网络连接的工具和资源，对于本节来说最重要的是，它定义了与 IP 地址一起工作的类型和接口。其中一种类型是
    `IP`，表示为一个字节的切片。此类型适用于 4 字节（IPv4）或 16 字节（IPv6）的切片：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s first explore how we can create an `IP` type variable, from the decimal
    representation of the IPv4 address `192.0.2.1`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先探索如何从 IPv4 地址的十进制表示 `192.0.2.1` 创建一个 `IP` 类型变量：
- en: '![Figure 4.2 – An IPv4 address](img/B16971_04_02.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 一个 IPv4 地址](img/B16971_04_02.jpg)'
- en: Figure 4.2 – An IPv4 address
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 一个 IPv4 地址
- en: 'One way to turn an IPv4 address into an IP type is by using the `ParseIP` function
    from the `net` package, which takes a string as an argument and returns an `IP`
    value:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将 IPv4 地址转换为 IP 类型的一种方法是通过使用 `net` 包中的 `ParseIP` 函数，该函数接受一个字符串作为参数，并返回一个 `IP`
    值：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'IPv6 addresses are a bit harder for our eyes to process, but to Go they are
    yet another slice of bits just like IPv4:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 地址对我们眼睛来说处理起来稍微困难一些，但对于 Go 来说，它们只是像 IPv4 一样的一块块位：
- en: '![Figure 4.3 – An IPv6 address](img/B16971_04_03.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 一个 IPv6 地址](img/B16971_04_03.jpg)'
- en: Figure 4.3 – An IPv6 address
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 一个 IPv6 地址
- en: 'The `ParseIP` function can also parse a string representation of an IPv6 to
    return the variable of the `IP` type:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParseIP` 函数还可以解析 IPv6 的字符串表示形式，以返回 `IP` 类型的变量：'
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `IP` type represents an IP address, so you can use the same IP methods for
    either IPv4 or IPv6 addresses. Let’s say you want to check whether an IP address
    is within a private address range.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`IP` 类型代表一个 IP 地址，因此您可以使用相同的 IP 方法来处理 IPv4 或 IPv6 地址。假设您想检查一个 IP 地址是否在私有地址范围内。'
- en: 'The `IsPrivate` method from the `net` package gives you that answer based on
    RFC 1918 (Address Allocation for Private Internets) and RFC 4193 (Unique Local
    IPv6 Unicast Addresses) for both IPv4 and IPv6 automatically:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`net` 包中的 `IsPrivate` 方法根据 RFC 1918（私有互联网地址分配）和 RFC 4193（唯一的本地 IPv6 单播地址）自动为
    IPv4 和 IPv6 提供答案：'
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Another interesting type is `IPNet`, which describes an IP prefix or an IP
    network, so it adds `IPMask` to `IP` to represent its mask:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的数据类型是 `IPNet`，它描述了一个 IP 前缀或 IP 网络，因此它将 `IPMask` 添加到 `IP` 中以表示其掩码：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A mask in the `net` package is also a slice of bytes, which is better explained
    with the following example using the `CIDRMask` function. Both `ones` and `bits`
    arguments are integers as the function signature indicates. The first argument,
    `ones`, is the number of ones in `IPMask` and the remaining bits are all set to
    zero. The total length of the mask is measured in `bits`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`net` 包中的掩码也是一个字节的切片，以下使用 `CIDRMask` 函数的示例可以更好地解释。`ones` 和 `bits` 参数都是整数，如函数签名所示。第一个参数
    `ones` 是 `IPMask` 中的 1 的数量，其余位都设置为 0。掩码的总长度以 `bits` 为单位衡量：'
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s see an example for IPv4, with a 32-bit mask:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 IPv4 的一个示例，使用 32 位掩码：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'IPv6 works similarly but expects a mask length of 128:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 的工作方式类似，但期望掩码长度为 128：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To parse a prefix or network from a string, you can use the `ParseCIDR` function
    from the `net` package. You get three values – a network address of the `IP` type,
    an IP prefix of the `IPnet` type, and an error:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字符串中解析前缀或网络，您可以使用 `net` 包中的 `ParseCIDR` 函数。您将获得三个值——一个 `IP` 类型的网络地址，一个 `IPnet`
    类型的 IP 前缀，以及一个错误：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The next example shows `ParseCIDR` for IPv6 using the same functions as with
    IPv4:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例展示了使用与 IPv4 相同的函数来使用 `ParseCIDR` 对 IPv6 进行解析：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The code for these examples is available at `ch04/net/main.go` (*Further reading*).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例的代码可在 `ch04/net/main.go` 中找到（*进一步阅读*）。
- en: This is the standard way of doing basic operations with IP addresses in Go.
    Yet not long ago there was an effort to add a new IP address type to the standard
    library, via a package that we review next.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Go 中进行基本 IP 地址操作的标准方式。然而，不久前，有人试图通过一个我们接下来要审查的包将一个新的 IP 地址类型添加到标准库中。
- en: The New netip package
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的 netip 包
- en: 'With the goal of improving some things that weren’t great about the `net.IP`
    data structure for IP addresses in Go, a group of Go developers came up with a
    new IP address type. This was an iterative process that they documented in the
    blog post *netaddr.IP: a new IP address type for Go* (*Further reading*). This
    package is now available in Go 1.18 as `net/netip`.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '为了改进 Go 中 `net.IP` 数据结构在 IP 地址方面的不足之处，一组 Go 开发者提出了一种新的 IP 地址类型。这是一个迭代过程，他们在博客文章
    *netaddr.IP: Go 的新 IP 地址类型* 中进行了记录（*进一步阅读*）。此包现在在 Go 1.18 中作为 `net/netip` 提供。'
- en: 'The `net/netip` package defines a new type, `Addr`, that stores both IPv4 and
    IPv6 addresses as a big-endian 128-bit number. This type also has a special sentinel
    field `z`, which can have any of these values:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/netip` 包定义了一个新的类型 `Addr`，该类型将 IPv4 和 IPv6 地址存储为一个大端 128 位数字。此类型还有一个特殊的哨兵字段
    `z`，它可以具有以下任何值：'
- en: '`nil` means an invalid IP address (for a zero `Addr`).'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nil` 表示无效的 IP 地址（对于零 `Addr`）。'
- en: '`z4` means an IPv4 address.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`z4` 表示 IPv4 地址。'
- en: '`z6noz` means an IPv6 address without a zone.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`z6noz` 表示没有区域的 IPv6 地址。'
- en: Otherwise, it’s the IPv6 zone name string.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，它是 IPv6 区域名称字符串。
- en: 'The data structure in Go looks as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的数据结构如下所示：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This new `Addr` type has the following major benefits compared to the legacy
    `net.IP`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的 `net.IP` 相比，这种新的 `Addr` 类型有以下主要优点：
- en: It takes up less memory.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它占用的内存更少。
- en: It’s immutable and, hence, safe to pass around.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是不可变的，因此可以安全地传递。
- en: It supports `==` operations and, hence, you can use it as a map key.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持 `==` 操作，因此您可以用作映射键。
- en: 'Let’s see some examples of how to parse an IP address from a string to get
    an `Addr` type and use it with some methods available in the package. In the first
    example, we parse an IPv4 address and check whether it’s within the RFC 1112 `224.0.0.0/4`
    multicast range with the `IsMulticast` method. A second example for IPv6 shows
    how to parse an IP address from a string with the same function, `ParseAddr`,
    and checks whether the IPv6 is a Link-Local address or part of the network `FE80::/10`
    according to the RFC 4291 with the `IsLinkLocalUnicast` method:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何从字符串中解析 IP 地址以获取 `Addr` 类型，并使用该包中的一些方法。在第一个例子中，我们解析一个 IPv4 地址，并使用 `IsMulticast`
    方法检查它是否在 RFC 1112 `224.0.0.0/4` 组播范围内。第二个 IPv6 的例子展示了如何使用相同的函数 `ParseAddr` 从字符串中解析
    IP 地址，并使用 `IsLinkLocalUnicast` 方法根据 RFC 4291 检查 IPv6 是否是链路本地地址或网络 `FE80::/10`
    的一部分：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, if you have an existing program that uses `net.IP`, you can use that type
    as input for `netip` as well. For both IPv4 and IPv6, it parses the `net.IP` type
    with the function `AddrFromSlice`. The method `IsX` tells us whether this is an
    IPv4 or IPv6 address:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您有一个使用 `net.IP` 的现有程序，您也可以将该类型作为 `netip` 的输入。对于 IPv4 和 IPv6，它使用 `AddrFromSlice`
    函数解析 `net.IP` 类型。`IsX` 方法告诉我们这是一个 IPv4 还是 IPv6 地址：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The code for this example is available at `ch04/parseip` (*Further reading*):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的代码可在 `ch04/parseip` 找到（*进一步阅读*）：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To represent an IP prefix (CIDR), `net/netip` defines a type called `Prefix`
    that has an `Addr` and an integer to specify the prefix length (from 0 to 128)
    in the field `bits`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示 IP 前缀（CIDR），`net/netip` 定义了一个名为 `Prefix` 的类型，该类型有一个 `Addr` 和一个整数，用于在 `bits`
    字段中指定前缀长度（从 0 到 128）：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To parse a prefix from a string, you can use the `ParsePrefix` function or
    `MustParsePrefix`, which calls `ParsePrefix` and panics on error, which means
    you don’t have to check the returned error in your code. Let’s look at a program
    that uses `MustParsePrefix` to generate a prefix, and then checks whether some
    IP addresses are in the address range of that prefix:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字符串中解析前缀，您可以使用 `ParsePrefix` 函数或 `MustParsePrefix`，后者调用 `ParsePrefix` 并在出错时引发恐慌，这意味着您不需要在代码中检查返回的错误。让我们看看使用
    `MustParsePrefix` 生成前缀并检查一些 IP 地址是否在该前缀地址范围内的程序：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We define the prefix `pf` from the `network4` string `192.0.2.0/24`. Then,
    we check whether addresses `192.0.2.18` and `198.51.100.3` are in this network
    by printing a message if they are. This program prints the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `network4` 字符串 `192.0.2.0/24` 定义前缀 `pf`。然后，我们检查地址 `192.0.2.18` 和 `198.51.100.3`
    是否在此网络中，如果它们是，则打印一条消息。此程序打印以下内容：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The code for this example is available at `ch04/parseprefix` (*Further reading*).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的代码可在 `ch04/parseprefix` 找到（*进一步阅读*）。
- en: Working with IP addresses
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 IP 地址进行操作
- en: 'After parsing IP addresses, you are only one step from several real-world applications
    you can put into practice. We cover just a few examples here:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 解析 IP 地址后，您只需再走一步就可以将几个实际应用场景付诸实践。我们在这里仅介绍几个示例：
- en: Route lookups
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由查找
- en: Geo IP data
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地理 IP 数据
- en: Extra IP address functions
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外的 IP 地址功能
- en: Route lookups
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由查找
- en: One way to do a route lookup or find the longest prefix match for an IP address
    is by using a trie data structure (prefix tree). Tries are very efficient in both
    memory and speed, which is why we use them for IP prefix lookups. To do this in
    Go, you can use one of the available packages. In this case, we use `cidranger`
    (*Further reading*).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 执行路由查找或找到IP地址的最长前缀匹配的一种方法是使用trie数据结构（前缀树）。Trie在内存和速度上都非常高效，这就是为什么我们使用它们进行IP前缀查找。在Go中，您可以使用可用的包之一来完成此操作。在这种情况下，我们使用`cidranger`（*进一步阅读*）。
- en: 'We start by defining a new path-compressed prefix trie and add a list of parsed
    IP addresses from the `IPs` variable:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个新的路径压缩前缀trie，并添加从`IPs`变量解析的IP地址列表：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now we can check whether any IP is within the defined list of IP address ranges.
    Here, we find that `127.0.0.1` is in at least one IP prefix on the list:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以检查是否有任何IP地址在定义的IP地址范围列表中。在这里，我们发现`127.0.0.1`至少在一个IP前缀列表中：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'One other thing you could do is to request a list of networks that contain
    an IP address, such as `192.0.2.18` in this case:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以请求包含IP地址的网络列表，例如本例中的`192.0.2.18`：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This returns `192.0.2.0/24` and `192.0.2.0/25`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回`192.0.2.0/24`和`192.0.2.0/25`：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The code of this example is available at `ch04/trie/main.go` (*Further reading*).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的代码可在`ch04/trie/main.go`中找到（*进一步阅读*）。
- en: Geo IP data
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 地理IP数据
- en: Another interesting use case is to get the geographical location associated
    with a public IP address. To make this query, you need access to a database that
    you can download for free from GeoLite2 Free Geolocation Data (*Further reading*)
    or you can just use the sample file we included in the book’s repo, which has
    support for a limited number of IP addresses, but enough to run the examples.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的用例是获取与公共IP地址关联的地理位置。为此查询，您需要访问一个数据库，您可以免费从GeoLite2免费地理位置数据下载（*进一步阅读*）或直接使用书中repo中包含的样本文件，该文件支持有限数量的IP地址，但足以运行示例。
- en: 'We open the database file, and for each IP address in a slice, we query for
    any available information, which we then print to the terminal:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打开数据库文件，并对切片中的每个IP地址进行查询，然后将查询到的任何可用信息打印到终端：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'One output example is the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一个输出示例如下：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The code for this example is available at `ch04/geo/main.go` (*Further reading*).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的代码可在`ch04/geo/main.go`中找到（*进一步阅读*）。
- en: Extra IP address functions
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 额外的IP地址函数
- en: If you come from another programming language such as Python, you might be familiar
    with the `ipaddress` library to manipulate IP addresses and networks. The `iplib`
    package (*Further reading*) is an effort to bring those features to Go.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您来自像Python这样的其他编程语言，您可能熟悉用于操作IP地址和网络的`ipaddress`库。`iplib`包（*进一步阅读*）是尝试将这些功能带到Go的努力。
- en: In the next example, we see a function to increment an IP address by one (`NextIP`)
    and another function to increase an IP address by any number (`IncrementIPBy`).
    We then compute the difference between the original IP address and the result
    after these two increments with the `DeltaIP` function to find out the number
    of IP addresses in between.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们看到一个用于将IP地址增加1的函数（`NextIP`）和另一个用于将IP地址增加任意数量的函数（`IncrementIPBy`）。然后我们使用`DeltaIP`函数计算原始IP地址和这两个增量后的结果之间的差异，以找出中间的IP地址数量。
- en: 'The last line of the example compares two IP addresses with the `CompareIPs`
    function. If `a` and `b` are the inputs, it returns `0` if `a == b`, `-1` if `a
    < b`, and `1` if `a >` `b`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 示例的最后一条语句使用`CompareIPs`函数比较两个IP地址。如果`a`和`b`是输入，如果`a == b`则返回`0`，如果`a < b`则返回`-1`，如果`a
    > b`则返回`1`：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Because the `iplib` package allows you to compare IP addresses, it means you
    can use the `sort` package to sort a list of `net.IP` addresses as the next example
    shows, using the addresses we just created:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`iplib`包允许您比较IP地址，这意味着您可以使用`sort`包对`net.IP`地址列表进行排序，如下一个示例所示，使用我们刚刚创建的地址：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can also generate an array of IP addresses from a network, starting at
    any IP address with the `Enumerate` method. In the next example, we take the network
    `198.51.100.0/24`, count the total available addresses in it with `Count`, to
    then generate an array of size 3 with `Enumerate`, starting from the first available
    IP address of the network (index 0):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用`Enumerate`方法从一个网络中生成一个IP地址数组，从任意IP地址开始。在下一个示例中，我们选取网络`198.51.100.0/24`，使用`Count`方法计算其中的总可用地址数，然后使用`Enumerate`方法生成一个大小为3的数组，从网络的第一个可用IP地址（索引0）开始：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This program produces the following output:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序将产生以下输出：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The code for this example is available at `ch04/ipaddr/main.go` (*Further reading*).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的代码可在 `ch04/ipaddr/main.go` 找到（*进一步阅读*）。
- en: IP is the fundamental protocol on the internet, which has continued to support
    its evolution over the last 40 years without major changes, despite the fast pace
    of technological development in the last few decades. Along with protocols from
    the transport layer, IP has allowed the decoupling of applications from hardware
    technologies such as coax cable, fiber optics, and Wi-Fi. Speaking of the transport
    layer, in the next section, we explore how Go can help you navigate this layer
    of the TCP/IP model.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: IP 是互联网的基本协议，在过去 40 年中，尽管过去几十年技术发展迅速，但它仍然没有发生重大变化，继续支持其发展。与传输层协议一起，IP 允许应用程序从同轴电缆、光纤和
    Wi-Fi 等硬件技术中解耦。说到传输层，在下一节中，我们将探讨 Go 如何帮助您导航 TCP/IP 模型的这一层。
- en: The transport layer
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传输层
- en: The transport layer protocols are the next OSI layer on top of IP and offer
    a communication channel abstraction. The two most common protocols today are TCP,
    which offers a connection-oriented communication channel, and UDP, a connectionless
    protocol.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 传输层协议是 IP 之上的下一个 OSI 层，提供通信通道抽象。目前最常用的两种协议是 TCP，它提供面向连接的通信通道，以及 UDP，一种无连接协议。
- en: 'In Go, the way you interact with both protocols is similar, even though the
    underlying packet exchange may be completely different. At a high level, there
    are only a few things that you need to keep in mind when dealing with TCP or UDP:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，您与这两种协议的交互方式相似，尽管底层的包交换可能完全不同。在较高层次上，当处理 TCP 或 UDP 时，您只需要记住以下几点：
- en: Each TCP or UDP application works with a corresponding connection represented
    by a concrete `TCPConn` or `UDPConn` type, respectively.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 TCP 或 UDP 应用程序都与一个相应的连接一起工作，该连接分别由具体的 `TCPConn` 或 `UDPConn` 类型表示。
- en: Go has other connection types with overlapping features such as `PacketConn`,
    which deals with connectionless protocols (UDP and IP); `Conn`, which covers IP,
    TCP, and UDP; and `UnixConn` for connections to Unix domain sockets. We only focus
    on `TCPConn` and `UDPConn` in this section.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 有其他具有重叠功能的连接类型，如 `PacketConn`，它处理无连接协议（UDP 和 IP）；`Conn`，它涵盖 IP、TCP 和 UDP；以及
    `UnixConn` 用于 Unix 域套接字的连接。我们本节只关注 `TCPConn` 和 `UDPConn`。
- en: Clients use `net.DialTCP` and `net.DialUDP` to open a socket to a remote address.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端使用 `net.DialTCP` 和 `net.DialUDP` 打开到远程地址的套接字。
- en: Servers use `net.ListenUDP` and `net.ListenTCP` to open a listening socket that
    accepts connections from different clients.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器使用 `net.ListenUDP` 和 `net.ListenTCP` 打开一个监听套接字，以接受来自不同客户端的连接。
- en: Clients and servers can `Read` and `Write` bytes from and to their respective
    connections.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端和服务器可以从它们各自的连接中读取和写入字节。
- en: When finished, both clients and servers need to close their connections to clean
    up the underlying file descriptor.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成后，客户端和服务器都需要关闭它们的连接以清理底层的文件描述符。
- en: 'The following figure illustrates the interactions between different types involved
    in a typical UDP client-server communication:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了典型 UDP 客户端-服务器通信中不同类型之间的交互：
- en: '![Figure 4.4 – UDP communication in Go](img/B16971_04_04.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – Go 中的 UDP 通信](img/B16971_04_04.jpg)'
- en: Figure 4.4 – UDP communication in Go
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – Go 中的 UDP 通信
- en: '*Figure 4**.4* shows a UDP client sending one byte at a time, although in reality,
    the payload can have more bytes. This could be a DNS request or an RTP packet.
    All network connection types implement `io.Reader` and `io.Writer` interfaces,
    so reading and writing are similar no matter what protocol you use underneath.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4**.4* 展示了一个 UDP 客户端一次发送一个字节，尽管在现实中，有效负载可以有更多字节。这可能是 DNS 请求或 RTP 数据包。所有网络连接类型都实现了
    `io.Reader` 和 `io.Writer` 接口，因此无论底层使用什么协议，读取和写入都是相似的。'
- en: The UDP client creates a UDP connection with `net.DialUDP` and then writes (`Write`)
    a byte to it, just like when you make a request to the network. On the server
    side, you read (`Read`) from the connection you would have created earlier with
    `net.ListenUDP`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: UDP 客户端使用 `net.DialUDP` 创建一个 UDP 连接，然后向它写入（`Write`）一个字节，就像您向网络发出请求一样。在服务器端，您从您之前使用
    `net.ListenUDP` 创建的连接中读取（`Read`）。
- en: Now, let’s move on to something a bit more concrete and see what a real UDP
    application may look like.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向一些更具体的内容，看看一个真实的 UDP 应用程序可能是什么样子。
- en: UDP ping application
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDP ping 应用程序
- en: Ping is one of the most conventional ways of checking remote connectivity and
    end-to-end latency. Just like the traditional ping, UDP ping uses echo replies
    to calculate latency and packet loss but encapsulates them in a UDP packet instead
    of ICMP/NDP. Many monitoring applications use this approach as it allows them
    to discover and monitor various equal-cost paths in networks with devices that
    perform 5-tuple hashing. One such application is Cloudprober (*Further reading*),
    which is the source of inspiration for the next example, as the authors wrote
    it in Go.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Ping是检查远程连接和端到端延迟最传统的方法之一。就像传统的ping一样，UDP ping使用回声响应来计算延迟和丢包率，但它们被封装在UDP数据包中而不是ICMP/NDP中。许多监控应用使用这种方法，因为它允许它们在网络中检测和监控具有5元组哈希功能的设备上的各种等价成本路径。其中一个这样的应用是Cloudprober（*进一步阅读*），它是下一个示例的灵感来源，因为作者是用Go编写的。
- en: 'Let’s walk through the code of a UDP ping application, focusing on connection
    establishment and data exchange. You can find the full code in the `ch04/udp-ping`
    (*Further reading*) folder of the book’s repository (*Further reading*). At a
    high level, our UDP ping application consists of two parts:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们遍历UDP ping应用的代码，重点关注连接建立和数据交换。您可以在书籍仓库的`ch04/udp-ping`（*进一步阅读*）文件夹中找到完整的代码。从高层次来看，我们的UDP
    ping应用由两部分组成：
- en: The server side listens on a UDP port and mirrors back any packets received
    from its clients.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器端监听UDP端口，并将从其客户端接收到的任何数据包镜像回传。
- en: 'The client that is sending UDP probes to a server receives a stream of mirrored
    packets coming back to compute the packet loss and end-to-end latency:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送UDP探测到服务器的客户端接收一串返回的镜像数据包，以计算丢包率和端到端延迟：
- en: '![Figure 4.5 – UDP ping application](img/B16971_04_05.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5 – UDP ping应用](img/B16971_04_05.jpg)'
- en: Figure 4.5 – UDP ping application
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – UDP ping应用
- en: 'Let’s start the overview of this application with the server side. The program
    begins by building a `UDPAddr` variable that describes a UDP socket. We then pass
    this variable to `net.ListenUDP` to create a UDP socket and start listening for
    incoming packets. The first argument in the `ListenUDP` function is `udp`, which
    specifies the dual-stack behavior (RFC6724 and RFC6555). You could also use `udp4`
    or `udp6` to pin the program to either IPv4 or IPv6 respectively:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从应用的服务器端开始概述这个应用。程序首先构建一个`UDPAddr`变量，它描述了一个UDP套接字。然后我们将这个变量传递给`net.ListenUDP`以创建一个UDP套接字并开始监听传入的数据包。`ListenUDP`函数的第一个参数是`udp`，它指定了双栈行为（RFC6724和RFC6555）。您也可以使用`udp4`或`udp6`将程序分别固定在IPv4或IPv6上：
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Once we have a listening UDP socket, we can start the main processing loop,
    which reads an incoming packet into a byte slice with `ReadFromUDP` and writes
    the entire packet back to the sender with `WriteToUDP`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个监听UDP套接字，我们就可以开始主处理循环，它使用`ReadFromUDP`将传入的数据包读取到一个字节切片中，并使用`WriteToUDP`将整个数据包写回发送者。
- en: 'Since `ReadFromUDP` is a blocking function, most server implementations add
    an extra `SetReadDeadline` timeout to make sure the program can be gracefully
    terminated if needed. In this case, it leads directly to the next loop iteration
    thanks to the `continue` statement after `ReadFromUDP`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ReadFromUDP`是一个阻塞函数，大多数服务器实现都会添加一个额外的`SetReadDeadline`超时，以确保在需要时程序可以优雅地终止。在这种情况下，它直接导致下一个循环迭代，多亏了`ReadFromUDP`之后的`continue`语句：
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The client-side implementation starts similarly, by building a `UDPAddr` variable
    and passing it to the `net.DialUDP` function. In the case of TCP, the `net.DialTCP`
    function would trigger a TCP three-way handshake, but in the case of UDP, the
    underlying OS opens a network socket without exchanging any packets:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端实现开始的方式类似，通过构建一个`UDPAddr`变量并将其传递给`net.DialUDP`函数。在TCP的情况下，`net.DialTCP`函数将触发TCP三次握手，但在UDP的情况下，底层操作系统会打开一个网络套接字而无需交换任何数据包：
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: At this point, the program branches out in two directions. The logical first
    step is the packet sending routine, which in this case runs inside the main goroutine
    of the program. In the background, we also fire off a goroutine that runs the
    `receive` function, which we discuss a few paragraphs later.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，程序分为两个方向。逻辑上的第一步是数据包发送例程，在这个例子中，它运行在程序的主goroutine中。在后台，我们还启动了一个goroutine来运行`receive`函数，我们将在接下来的几段中讨论它。
- en: 'Inside each probe packet we send, we embed a monotonically increasing sequence
    number and the value of a current timestamp. We serialize the probe packets into
    a binary slice, `p`, and write them into the UDP connection, `udpConn`, with the
    `binary.Write` function:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们发送的每个探测数据包中，我们嵌入一个单调递增的序列号和当前时间戳的值。我们将探测数据包序列化为一个二进制切片`p`，并使用`binary.Write`函数将它们写入UDP连接`udpConn`：
- en: '[PRE41]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now let’s have a closer look at the `receive` function, which we kickstarted
    just before the sending loop in the last code snippet. Inside this function, we
    have another loop that performs the following sequence of actions:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来更仔细地看看`receive`函数，这个函数在上一个代码片段中的发送循环之前启动。在这个函数内部，我们还有一个循环，它执行以下一系列操作：
- en: It receives a mirrored packet and deserializes it into the `p` variable of the
    `probe` type using the `binary.Read` function.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它接收一个镜像数据包，并使用`binary.Read`函数将其反序列化为`probe`类型的`p`变量。
- en: It checks the `SeqNum` sequence number of a received packet to find out whether
    it’s out of order.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它检查接收到的数据包的`SeqNum`序列号，以确定它是否顺序错误。
- en: It calculates the latency by subtracting the current time, `time.Now`, from
    the time received in the `SendTS` probe.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它通过从`SendTS`探测中接收的时间减去当前时间`time.Now`来计算延迟。
- en: 'In Go code, it looks like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go代码中，它看起来是这样的：
- en: '[PRE42]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We’ve used `binary.Read` and `binary.Write` in this example to convert between
    the in-memory data types and binary slices. This is possible thanks to the fixed
    size of the probe packets. But, if the probes had been of variable size, we could’ve
    only used the same functions to pre-parse the fixed-sized part of the header and
    would’ve had to read and parse the variable-sized payload manually.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`binary.Read`和`binary.Write`来在内存数据类型和二进制切片之间进行转换。这是由于探测数据包固定大小的原因。但是，如果探测数据包是可变大小的，我们只能使用相同的函数来预解析头部固定大小的部分，并且必须手动读取和解析可变大小的有效负载。
- en: 'The actual UDP ping application in `ch04/udp-ping` (*Further reading*) has
    a bit more code to account for further error conditions and graceful program termination.
    Let’s see an example of running the client-side code against a remote UDP ping
    server, where for each iteration, we can see the total number of lost packets
    and the latest calculated latency:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的UDP ping应用程序在`ch04/udp-ping`（*进一步阅读*）中有一点点更多的代码，以处理更多的错误条件和优雅的程序终止。让我们看看运行客户端代码对远程UDP
    ping服务器的示例，其中对于每次迭代，我们可以看到丢失的总数据包数和最新的计算延迟：
- en: '[PRE43]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The server side does not make any measurements and only logs a client IP address
    for each received UDP probe:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端不进行任何测量，只为每个接收到的UDP探测记录客户端IP地址：
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You’ve just seen an example of a binary UDP-based protocol that uses a single
    message to exchange information and calculate network metrics. Although we think
    it’s important to understand how to work with transport-layer protocols in Go,
    it’s not very common to implement your own application directly on top of TCP
    or UDP; the only notable exceptions include high-performance messaging protocols
    such as Kafka, NATS, and AMQP. Most communications these days happen over a higher-level
    protocol, HTTP. With it, we get wide support for packages and SDKs, a vast ecosystem
    of communication standards with REST, GRPC, and GraphQL, and standard support
    from network middleware such as proxies and intrusion detection systems. In the
    following section, we show how to write a sample HTTP client-server application
    in Go.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚看到了一个使用单个消息交换信息和计算网络指标的基于二进制UDP协议的例子。虽然我们认为了解如何在Go中处理传输层协议很重要，但直接在TCP或UDP之上实现自己的应用程序并不常见；唯一值得注意的例外包括像Kafka、NATS和AMQP这样的高性能消息协议。如今，大多数通信都是通过更高级的协议HTTP进行的。有了它，我们得到了广泛的包和SDK支持，一个庞大的通信标准生态系统，包括REST、GRPC和GraphQL，以及来自网络中间件（如代理和入侵检测系统）的标准支持。在下一节中，我们将展示如何使用Go编写一个示例HTTP客户端-服务器应用程序。
- en: The application layer
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用层
- en: In the last section, we explored how to establish a TCP or UDP connection between
    two nodes to transfer bytes over the network using the Go low-level network primitives
    we have learned about so far. Now we focus on the top layer of the TCP/IP model
    and go into the application-level constructs that Go includes in the standard
    library to implement HTTP clients and servers.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们探讨了如何使用我们迄今为止所学的Go低级网络原语在两个节点之间建立TCP或UDP连接，以在网络中传输字节。现在我们关注TCP/IP模型的最顶层，并深入了解Go标准库中包含的应用层构造，以实现HTTP客户端和服务器。
- en: To illustrate this, we go through the steps to build a client-server application
    that returns the MAC address vendor, IP address owner, or detailed domain information
    to the requester. On the client side, we need to craft an HTTP request that encapsulates
    the query to the server address. On the server side, we need to listen for requests
    and implement the logic to serve them and reply with the information for the argument
    received.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们通过构建一个客户端-服务器应用程序的步骤来返回请求者的MAC地址供应商、IP地址所有者或详细的域名信息。在客户端，我们需要构建一个封装了查询服务器地址的HTTP请求。在服务器端，我们需要监听请求并实现处理这些请求的逻辑，并回复接收到的信息。
- en: Working with an HTTP client
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用HTTP客户端
- en: 'On the client side, we first need to put together the URL we send the request
    to. The URL, for our example, has three components:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，我们首先需要组合我们要发送请求的URL。在我们的例子中，URL有三个组成部分：
- en: The server address (IP address and port)
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器地址（IP地址和端口）
- en: The lookup type to perform (MAC, IP, or domain)
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要执行查找的类型（MAC、IP或域名）
- en: An argument, which is the value we want to query for
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个参数，这是我们想要查询的值
- en: The `net/url` package helps us in this case, to parse the inputs into a URL
    structure. We hardcode values for the example in the book, but you can input any
    values you want via flags when you run the code in `ch04/http/client/main.go`
    (*Further reading*).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/url`包帮助我们在这个案例中，将输入解析为URL结构。在书中，我们为示例硬编码了值，但您可以在运行`ch04/http/client/main.go`代码时通过标志输入任何您想要的值（*进一步阅读*）。'
- en: 'We use the `Parse` method from `net/url` to form the first part of the URL:
    `http://localhost:8080/lookup`. The second part of the example adds the query.
    We leverage the `Add` method for this, which takes a key-value pair as an argument.
    The `lookup` variable is the key in this case and the value comes from the `argument`
    variable. The full URL looks like this: `http://localhost:8080/lookup?domain=tkng.io`.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`net/url`包中的`Parse`方法来形成URL的第一部分：`http://localhost:8080/lookup`。示例的第二部分添加了查询。我们利用`Add`方法来实现这一点，它接受一个键值对作为参数。在这个例子中，`lookup`是键，而值来自`argument`变量。完整的URL看起来像这样：`http://localhost:8080/lookup?domain=tkng.io`。
- en: '[PRE45]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To make the actual request to the server, we leverage the `net/http` package.
    This package has a `Client` type that specifies the mechanism to make an HTTP
    request. We don’t need to stipulate any client details for this example, so we
    show the type just for reference:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向服务器发送实际请求，我们利用了`net/http`包。这个包有一个`Client`类型，它指定了发起HTTP请求的机制。在这个例子中，我们不需要指定任何客户端的详细信息，所以我们只展示这个类型以供参考：
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If you don’t have any preference, you can select a `DefaultClient` that uses
    a `DefaultTransport`. This client has pre-defined timeouts and proxy settings,
    which are safe for concurrent use by different goroutines, so we don’t need to
    adjust any of the parameters that the following code snippet from the Go standard
    library shows, which also depicts the client HTTP transport settings that are
    available in case you want to fine-tune the behavior of the connection:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有偏好，您可以选择一个使用`DefaultTransport`的`DefaultClient`。这个客户端有预定义的超时和代理设置，这对于不同goroutine的并发使用是安全的，所以我们不需要调整Go标准库中以下代码片段显示的任何参数，该代码片段还描述了客户端HTTP传输设置，以防您想要微调连接的行为：
- en: '[PRE47]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Continuing with the example, `DefaultClient` allows us to use HTTP GET, HEAD,
    and POST methods. Here, we use HTTP GET with the `Get` method from the `net/http`
    package to the `addr` address we parsed earlier with `Parse`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`DefaultClient`允许我们使用HTTP GET、HEAD和POST方法。这里，我们使用`net/http`包中的`Get`方法通过`addr`地址来执行HTTP
    GET：
- en: '[PRE48]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The last step is to print out the response we get from the server to the terminal.
    You can use flags from the CLI to submit different queries when running the client
    application to do these operations:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将我们从服务器收到的响应打印到终端。您可以使用CLI的标志在运行客户端应用程序时提交不同的查询以执行这些操作：
- en: 'A health check:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 健康检查：
- en: '[PRE49]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'A MAC address vendor lookup:'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MAC地址供应商查找：
- en: '[PRE51]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'A domain lookup:'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 域名查找：
- en: '[PRE53]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'An IP address lookup:'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP地址查找：
- en: '[PRE63]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: To get these responses, we need to have a running server first that processes
    the requests. Let’s build it.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取这些响应，我们首先需要一个正在运行的服务器来处理请求。让我们构建它。
- en: Working with an HTTP (server)
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用HTTP（服务器）
- en: 'To handle the requests and responses, the `net/http` package exposes a `Server`
    type and a `Handler` interface. `Server` is the data structure for the parameters
    to run an HTTP server:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理请求和响应，`net/http`包公开了一个`Server`类型和一个`Handler`接口。`Server`是运行HTTP服务器参数的数据结构：
- en: '[PRE71]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Let’s define a `srv` variable of the `Server` type. The zero value for `Server`
    is a valid configuration, but in this case, we denote `Addr` as `0.0.0.0:8080`
    to listen on any interface and port `8080` specifically.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个 `srv` 变量，其类型为 `Server`。`Server` 的零值是一个有效的配置，但在这个例子中，我们将 `Addr` 定义为 `0.0.0.0:8080`，以便监听任何接口和特定的端口
    `8080`。
- en: 'The `Server` type has a `ListenAndServe` method to listen on the TCP network
    address, `Addr`, of the `Server` instance (`srv.Addr` or `0.0.0.0:8080` in the
    example). It then calls the `Serve` method to accept incoming connections and
    handle the requests. For each request, it creates a new service goroutine that
    reads the request and then calls the `Server` instance, `Handler` (`srv.Handler`
    or `nil` in the example), to reply to them:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`Server` 类型有一个 `ListenAndServe` 方法来监听 `Server` 实例的 TCP 网络地址 `Addr`（例如，示例中的
    `srv.Addr` 或 `0.0.0.0:8080`）。然后它调用 `Serve` 方法来接受传入的连接并处理请求。对于每个请求，它创建一个新的服务 goroutine
    来读取请求，然后调用 `Server` 实例的 `Handler`（示例中的 `srv.Handler` 或 `nil`），以回复它们：'
- en: '[PRE72]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This brings us to the second type in the `net/http` package we mentioned initially,
    the `Handler` interface. The role of `Handler` is to respond to an HTTP request:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这带我们来到了我们最初提到的 `net/http` 包中的第二种类型，即 `Handler` 接口。`Handler` 的作用是对 HTTP 请求做出响应：
- en: '[PRE73]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`Handler` responds to HTTP requests via its `ServeHTTP` method, which takes
    two arguments:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`Handler` 通过其 `ServeHTTP` 方法响应 HTTP 请求，该方法接受两个参数：'
- en: 'A `ResponseWriter` interface, which you can use to craft an HTTP header and
    payload to reply to the request and then return:'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `ResponseWriter` 接口，您可以使用它来构建 HTTP 头部和有效载荷以回复请求，然后返回：
- en: '[PRE74]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'An HTTP `Request`, which holds the HTTP request received by the server in this
    case. It could also be a request you want to send from a client:'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 HTTP `Request`，它包含服务器收到的 HTTP 请求。它也可以是您想从客户端发送的请求：
- en: '[PRE83]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Now, if we look back at our example, we didn’t specify our `Handler`, so when
    we called `ListenAndServe`, our handler was actually null (`nil`). In this scenario,
    `ListenAndServe` defaults a `DefaultServeMux` to handle the requests that come
    in. `DefaultServeMux` is an HTTP request multiplexer that the `net/http` package
    includes. It routes requests to the most appropriate handler based on a list of
    registered URL patterns.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们回顾我们的示例，我们没有指定我们的 `Handler`，所以当我们调用 `ListenAndServe` 时，我们的处理函数实际上是空的（`nil`）。在这种情况下，`ListenAndServe`
    默认使用 `DefaultServeMux` 来处理传入的请求。`DefaultServeMux` 是 `net/http` 包包含的一个 HTTP 请求多路复用器，它根据已注册的
    URL 模式列表将请求路由到最合适的处理函数。
- en: The next step in the example is to register a handler function for a given pattern.
    We do this with the `HandleFunc` function, which takes a string pattern and a
    handler function with the `func(ResponseWriter, *Request)` signature as arguments.
    Now, when we get an incoming request that has a URL that matches this pattern,
    the specified handler generates the response.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的下一步是注册一个给定模式的处理函数。我们使用 `HandleFunc` 函数来做这件事，该函数接受一个字符串模式和一个 `func(ResponseWriter,
    *Request)` 签名的处理函数作为参数。现在，当我们收到一个与该模式匹配的 URL 的传入请求时，指定的处理函数将生成响应。
- en: 'Going back to the example, in the first code snippet we showed of the main
    function, we purposely omitted the initial two lines of code, which actually register
    two URL patterns to match, `/lookup` and `/check`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 回到示例，在我们展示的主函数的第一个代码片段中，我们故意省略了前两行代码，实际上这两行代码注册了两个要匹配的 URL 模式 `/lookup` 和 `/check`：
- en: '[PRE95]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Normal queries follow the `/lookup` route, but we also included a `/check`
    option to let us to run a quick health check and verify the server is responding
    to requests. Each pattern has a corresponding handler function with the `func(ResponseWriter,
    *Request)` signature as an argument. We conveniently named these functions `lookup`
    and `check`. *Figure 4**.6* shows how `DefaultServeMux` logically determines the
    `Handler` that handles the user request:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 正常查询遵循 `/lookup` 路由，但我们还包含了一个 `/check` 选项，以便我们可以运行快速的健康检查并验证服务器是否正在响应用户请求。每个模式都有一个对应的处理函数，该函数以
    `func(ResponseWriter, *Request)` 签名作为参数。我们方便地将这些函数命名为 `lookup` 和 `check`。*图 4**.6*
    展示了 `DefaultServeMux` 如何逻辑上确定处理用户请求的 `Handler`：
- en: '![Figure 4.6 – Handling HTTP requests](img/B16971_04_06.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – 处理 HTTP 请求](img/B16971_04_06.jpg)'
- en: Figure 4.6 – Handling HTTP requests
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 处理 HTTP 请求
- en: 'Now, let’s examine the `lookup` handler function. A couple of things stand
    out:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查 `lookup` 处理函数。有几个亮点：
- en: We write the response to the request via the first argument, `w`, an `http.ResponseWriter`
    that satisfies the `io.Writer` interface. This means you can use any mechanism
    that accepts an `io.Writer` interface to write to it. Here, we use `fmt.Sprintf`.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过第一个参数`w`将响应写入请求，`w`是一个满足`io.Writer`接口的`http.ResponseWriter`。这意味着你可以使用任何接受`io.Writer`接口的机制来写入它。在这里，我们使用`fmt.Sprintf`。
- en: 'We access the user’s request via the second argument, `req`. Here, we extract
    the target URL from the request to print it out in the example with `req.URL.Query`.
    Also, we get the value of the query to further process the request based on its
    type, whether this is for a MAC address, IP address, or a domain:'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过第二个参数`req`访问用户的请求。在这里，我们通过`req.URL.Query`从请求中提取目标URL并在示例中打印出来。同时，我们获取查询值以根据其类型进一步处理请求，无论是MAC地址、IP地址还是域名：
- en: '[PRE96]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'When running this on the server side, we need to include all the `.go` files
    in the folder, not only `main.go`, so you want to run `go run *.go` to get an
    output like the one in the next snippet:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端运行此代码时，我们需要包含文件夹中的所有`.go`文件，而不仅仅是`main.go`，因此你想要运行`go run *.go`以获得下一个片段中的输出：
- en: '[PRE114]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: To run this example, you need to open two tabs. You first run `go run *.go`
    from `ch04/http/server` (*Further reading*) and then from another tab, you can
    make the client queries from `ch04/http/client` (*Further reading*) with flags
    as in the outputs in the client part of this section.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此示例，你需要打开两个标签页。首先，从`ch04/http/server`（*进一步阅读*）运行`go run *.go`，然后从另一个标签页，你可以从`ch04/http/client`（*进一步阅读*）进行客户端查询，使用本节客户端部分的输出中的标志。
- en: Summary
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed the different layers of the TCP/IP model and the
    applicability of Go to each one. We went from changing the state of network interfaces
    on Linux systems to working with IP addresses, all the way to building a web application
    prototype.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了TCP/IP模型的各个层次以及Go在每一层的适用性。我们从改变Linux系统上网络接口的状态到处理IP地址，一直到最后构建一个Web应用程序原型。
- en: Now you are ready to embark on the network automation journey and take all these
    lessons you’ve learned so far and apply them to make networks more efficient,
    reliable, and consistent. This is what we begin to examine in [*Chapter 5*](B16971_05.xhtml#_idTextAnchor128),
    *Network Automation*.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好开始网络自动化之旅，并将迄今为止所学的一切应用到使网络更高效、更可靠和更一致。这是我们开始探讨的内容，[第5章](B16971_05.xhtml#_idTextAnchor128)，*网络自动化*。
- en: Further reading
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '`syscall` package: [https://pkg.go.dev/syscall](https://pkg.go.dev/syscall
    )'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syscall`包：[https://pkg.go.dev/syscall](https://pkg.go.dev/syscall)'
- en: '`vishvananda/netlink` package: [https://github.com/vishvananda/netlink](https://github.com/vishvananda/netlink
    )'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vishvananda/netlink`包：[https://github.com/vishvananda/netlink](https://github.com/vishvananda/netlink)'
- en: '`mdlayher/netlink` package: [https://github.com/mdlayher/netlink](https://github.com/mdlayher/netlink
    )'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mdlayher/netlink`包：[https://github.com/mdlayher/netlink](https://github.com/mdlayher/netlink)'
- en: '`mdlayher/netlink` ecosystem: [https://github.com/mdlayher/netlink#ecosystem](https://github.com/mdlayher/netlink#ecosystem
    )'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mdlayher/netlink`生态系统：[https://github.com/mdlayher/netlink#ecosystem](https://github.com/mdlayher/netlink#ecosystem)'
- en: '`ch04/netlink`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch04/netlink](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch04/netlink
    )'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch04/netlink`：[https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch04/netlink](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch04/netlink)'
- en: '`CAP_NET_ADMIN` capabilities: [https://man7.org/linux/man-pages/man7/capabilities.7.html](https://man7.org/linux/man-pages/man7/capabilities.7.html
    )'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CAP_NET_ADMIN`权限：[https://man7.org/linux/man-pages/man7/capabilities.7.html](https://man7.org/linux/man-pages/man7/capabilities.7.html)'
- en: '`google/gopacket` package: [https://github.com/google/gopacket](https://github.com/google/gopacket
    )'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`google/gopacket`包：[https://github.com/google/gopacket](https://github.com/google/gopacket)'
- en: '`mdlayher/ethernet` package: [https://github.com/mdlayher/ethernet](https://github.com/mdlayher/ethernet
    )'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mdlayher/ethernet`包：[https://github.com/mdlayher/ethernet](https://github.com/mdlayher/ethernet)'
- en: '`kube-vip` package: [https://github.com/kube-vip/kube-vip/tree/main/pkg/vip](https://github.com/kube-vip/kube-vip/tree/main/pkg/vip
    )'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-vip`包：[https://github.com/kube-vip/kube-vip/tree/main/pkg/vip](https://github.com/kube-vip/kube-vip/tree/main/pkg/vip)'
- en: '`mdlayher/arp` package: [https://github.com/mdlayher/arp](https://github.com/mdlayher/arp
    )'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mdlayher/arp`包：[https://github.com/mdlayher/arp](https://github.com/mdlayher/arp)'
- en: '`mdlayher/packet` package: [https://github.com/mdlayher/packet](https://github.com/mdlayher/packet
    )'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mdlayher/packet`包：[https://github.com/mdlayher/packet](https://github.com/mdlayher/packet)'
- en: '`ch04/vip`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch04/vip](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch04/vip
    )'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch04/vip`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch04/vip](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch04/vip)'
- en: '`net` package: [https://pkg.go.dev/net](https://pkg.go.dev/net )'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net` 包: [https://pkg.go.dev/net](https://pkg.go.dev/net)'
- en: '`ch04/net/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/net/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/net/main.go
    )'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch04/net/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/net/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/net/main.go)'
- en: '*netaddr.IP: a new IP address type for* *Go*: [https://tailscale.com/blog/netaddr-new-ip-type-for-go/](https://tailscale.com/blog/netaddr-new-ip-type-for-go/
    )'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*netaddr.IP: 为 *Go* 提供的新 IP 地址类型*: [https://tailscale.com/blog/netaddr-new-ip-type-for-go/](https://tailscale.com/blog/netaddr-new-ip-type-for-go/)'
- en: '`ch04/parseip`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch04/parseip](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch04/parseip
    )'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch04/parseip`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch04/parseip](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch04/parseip)'
- en: '`ch04/parseprefix`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch04/parseprefix](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch04/parseprefix
    )'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch04/parseprefix`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch04/parseprefix](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch04/parseprefix)'
- en: '`cidranger`: [https://github.com/yl2chen/cidranger](https://github.com/yl2chen/cidranger
    )'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cidranger`: [https://github.com/yl2chen/cidranger](https://github.com/yl2chen/cidranger)'
- en: '`ch04/trie/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/trie/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/trie/main.go
    )'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch04/trie/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/trie/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/trie/main.go)'
- en: 'GeoLite2 Free Geolocation Data: [https://dev.maxmind.com/geoip/geolite2-free-geolocation-data](https://dev.maxmind.com/geoip/geolite2-free-geolocation-data
    )'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'GeoLite2 免费地理位置数据: [https://dev.maxmind.com/geoip/geolite2-free-geolocation-data](https://dev.maxmind.com/geoip/geolite2-free-geolocation-data)'
- en: '`ch04/geo/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/geo/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/geo/main.go
    )'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch04/geo/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/geo/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/geo/main.go)'
- en: '`iplib` package: [https://github.com/c-robinson/iplib](https://github.com/c-robinson/iplib
    )'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iplib` 包: [https://github.com/c-robinson/iplib](https://github.com/c-robinson/iplib)'
- en: '`ch04/ipaddr/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/ipaddr/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/ipaddr/main.go
    )'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch04/ipaddr/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/ipaddr/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/ipaddr/main.go)'
- en: 'cloudprober: [https://github.com/cloudprober/cloudprober](https://github.com/cloudprober/cloudprober
    )'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'cloudprober: [https://github.com/cloudprober/cloudprober](https://github.com/cloudprober/cloudprober)'
- en: '`ch04/udp-ping`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch04/udp-ping](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch04/udp-ping
    )'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch04/udp-ping`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch04/udp-ping](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch04/udp-ping)'
- en: 'The book’s GitHub repository: [https://github.com/PacktPublishing/Network-Automation-with-Go](https://github.com/PacktPublishing/Network-Automation-with-Go
    )'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '本书GitHub仓库: [https://github.com/PacktPublishing/Network-Automation-with-Go](https://github.com/PacktPublishing/Network-Automation-with-Go)'
- en: '`ch04/http/client/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/http/client/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/http/client/main.go
    )'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch04/http/client/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/http/client/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/http/client/main.go)'
- en: '`ch04/http/server`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/http/server](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/http/server
    )'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch04/http/server`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/http/server](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/http/server)'
- en: '`ch04/http/client`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/http/client](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/http/client)'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch04/http/client`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/http/client](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch04/http/client)'
- en: 'Part 2: Common Tools and Frameworks'
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：常用工具和框架
- en: This part describes the existing challenges and objectives of network automation.
    You will learn how organizations are approaching this major undertaking and where
    we are headed.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分描述了网络自动化现有的挑战和目标。您将了解组织如何应对这一重大任务以及我们将何去何从。
- en: 'This part of the book comprises the following chapters:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 本书本部分包括以下章节：
- en: '[*Chapter 5*](B16971_05.xhtml#_idTextAnchor128)*, Network Automation*'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B16971_05.xhtml#_idTextAnchor128)*，网络自动化*'
- en: '[*Chapter 6*](B16971_06.xhtml#_idTextAnchor144)*, Configuration Management*'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B16971_06.xhtml#_idTextAnchor144)*，配置管理*'
- en: '[*Chapter 7*](B16971_07.xhtml#_idTextAnchor161)*, Automation Frameworks*'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B16971_07.xhtml#_idTextAnchor161)*，自动化框架*'
