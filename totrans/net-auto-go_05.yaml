- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network Automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Up until this point, we’ve covered some Go fundamentals required to perform
    common network-related activities. Now, it’s time to focus on the principal topic
    of this book — network automation. Before we review the solutions, tools, and
    code libraries, let’s take a step back and look at network automation as a discipline.
    In this chapter, we aim to find an answer to the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is network automation and why is it often considered a dedicated skill
    that’s distinct from, say, network engineering?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is its impact on network operations and its benefits for the business?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are some common automation use cases you can tackle individually?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can you string these individual use cases together into a bigger network
    automation system and why would anyone want that?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter is light on code but heavy on words and may contain arguments that
    not everyone may agree on. We, as authors of this book, are trying to express
    our opinions as objectively as possible, but our views are ultimately based on
    subjective experiences that we’ve had in our careers. Still, we have tried our
    best to steer away from the most controversial topics such as automation reducing
    the need for human operators and, where possible, provided evidence to support
    our arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is network automation?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating network operation tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Systems approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code examples for this chapter in this book’s GitHub repository
    (specified in the *Further reading* section), under the `ch05` folder.
  prefs: []
  type: TYPE_NORMAL
- en: What is network automation?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a relatively new discipline, it’s not uncommon to see a broad spectrum of
    network automation definitions that vary in scope and goals. Network automation
    isn’t about one use case or technology in particular, but rather what can be of
    help in your environment and benefit your business.
  prefs: []
  type: TYPE_NORMAL
- en: Some engineers would argue that routing protocols already automate networks
    and the CLI is the intent-based API, transforming individual network commands
    into a dynamic network state. We don’t try to argue with this point of view, as
    there are some grains of truth in these statements, but it’s certainly not the
    most popular definition in the industry.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, let’s define network automation as a set of processes to automate common
    manual workflows performed by a network operator, such as provisioning services,
    performing software upgrades, or telemetry processing. This includes tasks that
    network engineers would otherwise traditionally have to click their way through,
    combined with running a set of CLI commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'More complex network automation solutions may involve reacting to operational
    events by adjusting network configuration, applying traffic engineering policies,
    or even enforcing some design constraints. One common trait that unites all these
    activities is the ability to describe the desired behavior in a concrete sequence
    of steps that lead to the expected outcome. This may rule out some iterative activities
    such as network troubleshooting or creative activities such as network design,
    although they are making considerable progress in these areas with static configuration
    analysis (Batfish: *Further reading*) and mathematical network modeling (Forward:
    *Further reading*), for example, so we could eventually borrow concepts from the
    software world such as **test-driven development** (**TDD**) to automate the development
    and testing (whole-network **quality assurance** (**QA**) and regression) of configuration
    templates of a network design.'
  prefs: []
  type: TYPE_NORMAL
- en: Why network automation exists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Probably a more interesting question to answer is why network automation exists
    as a discipline unlike, say, systems administration, which has evolved into site
    reliability engineering and now encompasses not only plain infrastructure provisioning
    but also observability, automation, and even systems software development.
  prefs: []
  type: TYPE_NORMAL
- en: The way we run and operate networks has changed very little in the last few
    decades. Network management still mainly focuses on executing CLI commands and
    working with unstructured data, despite the wide acceptance that CLI-driven operations
    are error-prone and not scalable. Often, this leads to a lack of standardization
    that leaves network engineers with manual processes taking up most of their workday
    and making networks difficult to scale, support, and secure.
  prefs: []
  type: TYPE_NORMAL
- en: Network automation has emerged as a response to this to improve efficiency and
    reduce the overhead of mundane tasks. The goal is to produce more reliable and
    repeatable processes, which increases productivity. This also helps make networks
    more consistent and simpler to operate, while at the same time reducing the likelihood
    of an outage, thus minimizing downtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite this, not all network engineers have embarked on the journey of network
    automation. Some reasons we think this could be the case are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Lack of standard and vendor-agnostic APIs for network management that return
    structured data. Network vendors typically offer proprietary configuration syntax
    or CLIs designed primarily for human interaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automation requires a completely new skill set and, since network engineers
    generally don’t come from a computer science background, programming remains a
    big skill gap.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning automation requires time and not every employer is happy to dedicate
    part of their employees’ time to something with no immediate benefit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automation speed can also propagate a failure rapidly, which may not help build
    trust in automation early on. It takes time to create systems that are reliable,
    secure, and offer enough visibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given the large number of network automation tools, libraries, and frameworks
    with overlapping scopes, choosing the right one for a particular task can be challenging
    and introduces the risk of over-investing in something that may end up being a
    wrong choice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shifting from *it’s always been done this way* is hard. Sometimes, we follow
    the path of least resistance and, thus, are reluctant to change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing network automation into your environment brings a different set
    of gains and perils, depending on your point of view. So, let’s try to unpack
    what it means to both engineers operating the network and the upper management
    operating the business for whom a network can be a cost or a profit center.
  prefs: []
  type: TYPE_NORMAL
- en: Bottom-up view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some network operation activities that lend themselves well to automation include
    configuration changes, running audits or compliance checks, software and device
    life cycle management, and more. Several organizations have playbooks or require
    change management forms, documenting every operational step of these processes.
    Many companies already use a form of automation when a senior engineer prepares
    a change that a junior engineer later executes.
  prefs: []
  type: TYPE_NORMAL
- en: These activities usually have a set of very well-defined inputs, such as an
    inventory of devices, a list of commands to execute, a set of well-defined outputs,
    and maybe a filled-out spreadsheet or a new software version running on a device.
    These attributes make these activities suitable candidates for automation.
  prefs: []
  type: TYPE_NORMAL
- en: One of the commonly cited benefits of automation is its ability to scale – the
    relative cost of making a change to one device is the same as making a change
    to thousands of devices or making a hundred changes to hundreds of devices. Although
    scale and speed are important, they may not be the most valuable outcomes of process
    automation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For some networking teams with relatively small-scale networks or low change
    rates, network automation may bring other benefits, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Consistency**: Since computers perform these changes, you can expect them
    to yield the same result every time. Also, you can enforce the same configurations,
    templates, or policies across elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reliability**: Instructions are code, which computers interprets unambiguously.
    You can also add automatic checks to validate inputs or results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visibility**: All future and past changes in the network can be viewed by
    all members of the team, to embrace peer review and ease troubleshooting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ubiquity**: The same tools are used across different teams, which simplifies
    interactions and improves knowledge sharing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When introducing network automation to your peers, it’s important to emphasize
    that this is not a single product or a solution, but rather a journey – a vector
    in a new direction with no fixed destination.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that not all manual processes may be completely automatable, and
    it may take years to develop new practices and update existing procedures. This
    is why it’s also very important to get your organization’s management on board.
  prefs: []
  type: TYPE_NORMAL
- en: Top-down view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Network engineers can understand the preceding technical points and can judge
    for themselves whether a network automation project is worth their time and effort
    to deploy.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, the same arguments may not be enough to convince management if
    you don’t look at the bigger picture (the business). This could be one of the
    primary reasons a network automation initiative may fail. If the business benefits
    are not clear, then management may decide it’s not worth the investment of time.
    But the reverse is also true – a network automation initiative is more likely
    to succeed when it has support within the organization’s management structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of business values that you can use as a starting point in discussions
    with management. Depending on the company, a network can be a cost center or a
    profit center, so adjust or re-prioritize them to fit your circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cost management**: Generate cost savings through resource optimization. You
    reduce the costs of running the network by troubleshooting fewer human errors,
    not having to manually compile audit reports, or having to work on overtime changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speed of delivery**: Increase the speed to configure and validate changes
    in the network, allowing you to deliver customer services faster or even on-demand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Risk management**: Enforce security policies consistently with every operation
    to reduce risk. Reduce the number of incidents that impact services and hence
    your revenue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Business capabilities**: Depending on how your organization defines value,
    network automation can help discover opportunities. Increased visibility could
    help improve capacity planning or spot unused capacity or hot spots. New services
    or business capabilities can be an outcome of streamlined cross-team interactions
    due to the well-defined interfaces, inputs, and outputs of an automated system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Despite the rise of awareness about the benefits of network automation, some
    people are still hesitant to embrace it as an internal organizational practice,
    so getting support from them may require extra effort. Each situation is unique
    and, thus, may require a slightly distinct set of arguments. In the end, network
    automation is becoming an important part of network engineering and its relevance
    in the industry continues to increase.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve defined what network automation is and why we need it, it’s time
    to dig deeper and start looking at concrete use cases and areas where you can
    apply it in the traditional network engineering discipline.
  prefs: []
  type: TYPE_NORMAL
- en: Automating network operation tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section introduces some common network operation tasks and use cases where
    you can introduce automation without causing too much friction with the existing
    tools and processes. We aim to take a series of manual steps normally performed
    by a human operator and explore how you can convert them into code so that a computer
    can execute them for you, all while keeping the original inputs and outputs unchanged.
    We will divide this section into three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network state analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network audits and reporting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the most popular area of the network engineering discipline that spans
    beyond network operations and often includes design and architecture stages. Most
    people see this as the lowest-hanging fruit to test, or where to start using,
    network automation. Let’s look at some common use cases that fall under this category.
  prefs: []
  type: TYPE_NORMAL
- en: Config generation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we can make any changes to a network device, we need to craft the desired
    configuration for that target device. Traditionally, we would do this manually
    in a text editor, which involves a lot of copy/paste and search/replace actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following Go packages to automate this process and generate
    a network device configuration based on a set of inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`text/template`: A package from the standard library that uses a special Go
    templating language to generate an unstructured text document based on the input
    program variables. We will use this package in the *Interacting with network devices
    via SSH* section in [*Chapter 6*](B16971_06.xhtml#_idTextAnchor144), *Configuration
    Management*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flosch/pongo2`: A Django-syntax-like templating language for those that are
    more familiar with Jinja2 (the `gonja` fork).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`encoding`: This package includes encoders and decoders for YAML and JSON to
    parse and generate documents you can use with structured network APIs (for example,
    YANG or OpenAPI). We will use this package in the *Getting config inputs from
    other systems via HTTP* section in [*Chapter 6*](B16971_06.xhtml#_idTextAnchor144),
    *Configuration Management*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regexp`: Another standard library package that implements efficient regular
    expression pattern matching and string manipulation. We will use this package
    in the example at the end of this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you sort out the configuration details, you can send this config to the
    target device, which brings us to the next set of use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration changes, backups, and restore
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Working with device configuration may involve backing up and replacing the entire
    device configuration or making scoped changes to provision new services or update
    existing configuration snippets. Making these changes often involves logging into
    each device individually and executing a set of vendor-specific commands in a
    sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Go packages can help with the transport abstractions that are
    common across different networking vendors to streamline the steps to make changes
    to, back up, or restore your network configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`crypto/ssh`: A standard library package that implements base SSH connectivity.
    We will use this package in the *Interacting with network devices via SSH* section
    in [*Chapter 6*](B16971_06.xhtml#_idTextAnchor144), *Configuration Management*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scrapli/scrapligo`: A third-party package that builds on top of crypto/SSH
    and offers various convenient helper functions to work with different CLI prompts
    and commands from major networking vendors. You can also use this package as a
    NETCONF client. We will use this package in the *Automating routine SSH tasks*
    section in [*Chapter 6*](B16971_06.xhtml#_idTextAnchor144), *Configuration Management*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`net/http`: A standard library package that you can use to talk to HTTP-based
    APIs, such as RESTCONF or OpenAPI. We will use this package in the *Getting config
    inputs from other systems via HTTP* section in [*Chapter 6*](B16971_06.xhtml#_idTextAnchor144),
    *Configuration Management*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding list is by no means exclusive and several more third-party packages
    are available, including some that are specifically designed to work with **RESTCONF**
    (*Further reading*) or **NETCONF** (*Further reading*), but they all vary in their
    levels of activity or openness to outside contributions.
  prefs: []
  type: TYPE_NORMAL
- en: It always helps to look around, especially when choosing an external package,
    to make sure it fits your needs and has a healthy community of contributors.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration diffs and compliance checks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After you have applied the desired configuration, you may need to run periodic
    compliance checks to make sure certain invariants remain unchanged or to detect
    any configuration drift. These use cases rely on string searching, pattern matching,
    and computing differences. You can leverage the following Go packages for this
    purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '`strings`: A package from the standard library that can offer basic string
    comparison and pattern matching with the `Compare` and `Contains` functions. We
    will use this package in the example at the end of this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sergi/go-diff`: A third-party package that can compare, match, or patch plain
    text (a Go port of the `google/diff-match-patch` package).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`homeport/dyff`: Another third-party package and a command-line tool you can
    use to compare structured documents, such as JSON or YAML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While keeping your device configuration in check is crucial, you can’t derive
    everything that happens in the network from them. That’s why we need to complement
    our analysis with the operational data we gather from the network.
  prefs: []
  type: TYPE_NORMAL
- en: Network state analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The operational state that results from an applied configuration is often hard
    to predict. You can spend a significant amount of time fine-tuning monitoring
    and collecting information from the network. But these use cases are often a good
    first step into network automation because of their low-risk profile, so they
    present a very attractive opportunity to start using Go.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting operational state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Depending on the target `?rev=operational` indicates that the returned data
    should come from the operational data store. In contrast, for a human-first NOS,
    this may require extra steps to parse the CLI output you get from it. You can
    do this in Go in a few different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`regexp`: Using regular expressions is the most battle-tested and well-known
    way of parsing unstructured text into variables. Keep in mind that writing robust
    regular expressions and troubleshooting them can be a challenge. We will use this
    package in the example at the end of this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sirikothe/gotextfsm`: This package offers a higher-level abstraction built
    on top of the `regexp` package, designed to parse semi-formatted text, meaning
    text with visual structure, such as tables, but represented as a single string.
    We will use this package indirectly in the *Checking routing information* section
    in [*Chapter 6*](B16971_06.xhtml#_idTextAnchor144), *Configuration Management*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scrapli/scrapligo`: This package embeds the `textfsm` package and allows you
    to parse the responses you get from networking devices using the `TextFsmParse(template
    string)` function. We will use this package in the *Checking routing information*
    section in [*Chapter 6*](B16971_06.xhtml#_idTextAnchor144), *Configuration Management*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can get the operational state of the network and parse it into in-memory
    data structures before and after a maintenance window, for example, to compare
    them and vet the success of the work performed during this time. This is what
    we’ll discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: State snapshots and validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Validating the operational state, to make sure that the values we receive are
    what we expect to see, is something network engineers do when they configure network
    devices, run troubleshooting sessions, provision services, perform software upgrades,
    and carry out other daily activities as part of their job assignments.
  prefs: []
  type: TYPE_NORMAL
- en: As we automate the collection of this data and since we can often pre-calculate
    the intended state, the next step is to check whether the state is as expected
    and then make sure that this state persists over time. For example, BGP neighbors
    should be in an *established* state and all connected interfaces should be *up*.
    As we collect new data from the network, we record it in a structured format to
    compare it with the intended state and to trigger another action if we find a
    difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Comparing arbitrary data normally requires writing some custom code to traverse
    these data structures and look at the values that matter. But there are a few
    packages that can simplify this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '`reflect.DeepEqual`: This package is part of the Go standard library and can
    use runtime reflection to compare values that are of the same type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mitchellh/hashstructure`: A third-party package that can calculate a unique
    hash from arbitrary Go values that you can use to quickly answer the question
    if the operational state matches the one you expect. We will use this package
    in the example at the end of this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r3labs/diff`: Another third-party package that supports several standard Go
    types and relies on runtime reflection to produce a detailed log of all the differences
    between two Go structs or values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can’t classify all operational states as *intended*. Some values are more
    dynamic and their change is not always actionable. An example of this is MAC and
    IP address tables – their values fluctuate over time and long-term churn is normal.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping track of the dynamic state of the network can be helpful during routine
    maintenance, such as in software upgrades, where you make snapshots of the network
    state and can quickly compare the pre - and post-change values to spot any inconsistencies.
    Programmatically, this is just like the generic state validation use case. You
    use the same set of tools and libraries but save these snapshots as a structured
    document on a disk or inside a database over time.
  prefs: []
  type: TYPE_NORMAL
- en: Network audits and reporting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The scope of network audits can vary greatly, from trying to identify obsolete
    hardware or end-of-life software to measuring the quality of the service or the
    rate of control plane updates. Normally, the goal is to collect and process state
    information from a large set of devices and produce some human-readable output.
  prefs: []
  type: TYPE_NORMAL
- en: 'We discussed state collection and validation tasks in the preceding section,
    and you can scale this process to target hundreds or thousands of network devices
    with goroutines, which we covered in [*Chapter 3*](B16971_03.xhtml#_idTextAnchor067),
    *Getting Started with Go*. The missing part that we haven’t discussed yet is report
    generation. Here, Go also offers several resources that you can use to generate
    human-readable outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`text/tabwriter`: This is a package from the standard library you should consider
    if you want to send information to standard output. You can use this package to
    print tabbed data. Other feature-rich options exist outside of the standard library,
    one of which is the `jedib0t/go-pretty/v6` package, which can you can use to colorize
    text or print tables, lists, and progress bars.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unidoc/unioffice`: This package or `qax-os/excelize` are good options if you
    want to produce a spreadsheet. You can also use `unidoc/unioffice` to work with
    Word, Excel, or PowerPoint documents.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`html/template` and `text/template`: These are the two most common templating
    libraries. Hugo, the popular static site generator, uses both the `html` and `text`
    template packages, for example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go:embed`: This is a Go directive that you could use to allow templates to
    be embedded inside a compiled Go binary to simplify code distribution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use cases we’ve introduced in this section are all relatively independent.
    Once you automate them, they can become so-called automation islands, completely
    isolated from one another at first, but once their number grows, they may merge
    into more complex multi-stage workflows or even complete closed-loop systems.
    This is what we’ll explore in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Systems approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you start automating different tasks with an incremental approach, you may
    envision a path where you chain a subset of these automated tasks together to
    orchestrate a workflow.
  prefs: []
  type: TYPE_NORMAL
- en: You can also look at this from a different angle. You initially break down your
    existing manual processes into smaller chunks of work that you can automate independently,
    so you don’t need to wait until you get the full end-to-end process automated
    to start taking advantage of automation, while at the same time you are mindful
    of the bigger picture.
  prefs: []
  type: TYPE_NORMAL
- en: In this context, you take the first steps to interconnect different building
    blocks, which become part of a larger system that delivers a business outcome
    with eventually no human intervention that originally may have involved several
    teams. That’s what we call a systems approach.
  prefs: []
  type: TYPE_NORMAL
- en: One common example is when you mix the processes of configuring network services
    and collecting operational data from the network, which is what we’ll discuss
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Closed-loop automation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the first things every network engineer does after configuring anything
    on a network device is to check the status of that service, protocol, or resource
    configured via a CLI command. If an automated system performs this configuration,
    the network engineer still needs to log into a network device or group of network
    devices to execute commands, or maybe go to a web portal to check the logs or
    graphs that show the statistics for the network devices. This time-consuming,
    repetitive process that is error-prone for humans becomes a natural fit for automation
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you not only push the configuration or instructions down to the network
    but also ingest real-time operational data from the network, which you can process
    to determine whether it matches the intended state of the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we abstract away the network device details, a closed-loop application would
    consume **network intelligence** on one interface, and push intent down to the
    network. We can loosely define these as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Intent**: This would be the declarative definition of the operational state
    or measurable outcome you expect in the context of the network (topology, inventory,
    protocol, and so on) without requiring you to specify an exact procedure to get
    to it (those are implementation details).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network intelligence**: This would be telemetry from the network that is
    actionable after some level of processing to make it useful. Keep in mind that
    events, metrics, stats, or alarms do not necessarily translate into actionable
    intelligence. Network operators get so many alarms that it’s hard to know what’s
    real and what’s noise. Hence, network intelligence results from correlating this
    data, running analytics, or any other process that helps tie this to the desired
    intent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a high-level diagram of a closed-loop application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Closed-loop automation – 10,000 foot view](img/Figure_5.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Closed-loop automation – 10,000 foot view
  prefs: []
  type: TYPE_NORMAL
- en: The intent translates into configuration syntax or programmatic instructions,
    which are specific to the network device. We can adjust these instructions based
    on the feedback we get from the network, enabling us to close the loop and automate
    the life cycle of network services.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of a closed-loop system as a continuous loop that learns from
    the networks and adapts to them. This could replace pre - and post-snapshot checks
    as you would compare the network at arbitrary times and for arbitrary deltas continuously.
    But what we see in networks today is somewhat closer to systems that react to
    the network feedback only during the time window in which they provision a service.
    This is what we will replicate in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: Demo application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the demo application, we could either build a distributed system where
    all the different components communicate and coordinate via messages over the
    network, or run everything on just one node in a single application. Because the
    goal is to illustrate the notion of closed-loop automation and not to show how
    distributed systems work, we will keep the application simple and run all the
    components as functions of a monolith application, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Closed-loop automation sample application](img/Figure_5.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Closed-loop automation sample application
  prefs: []
  type: TYPE_NORMAL
- en: 'The application starts by reading the input data from the user. It reads the
    target device information for this example from a file, `input.yml`, as shown
    in the following code snippet. We hard code the parameters of the service to configure
    a variable (`intent`) in the code. The service we want to configure in this case
    is `57777` with `TLS` enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We encapsulate the service information in a `Service` definition that acts
    as a higher layer of abstraction than what a network device configuration represents,
    which translates into the intent for this example. We also compute a hash of this
    value so that we can compare it later with the operational information we receive
    from the network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Before the application configures the service, we have the chance to perform
    a series of pre-maintenance tasks, such as running a network audit to report whether
    the service is present already, so you may not need to configure it. Another good
    idea is to make a backup of the network device’s configuration in case we need
    to roll back the changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we must make a configuration backup of the target device with
    the `getConfig` method and then save it in a folder with the `save` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'With the pre-work done, the application enters a continuous enforcement loop
    that runs, in this example, every 30 seconds. Inside the loop, the application
    collects the operational state of the service with the `getOper` method. This
    method sends a CLI command to the target device to gather the operational details
    of the service we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we receive the response, we parse the information with regular expressions
    while using the `regexp` package to generate a new `Service` value with it that
    captures whether the service has `TLS` enabled, for example, as well as the rest
    of the `Service` attributes. Then, we calculate a new hash for this `Service`
    type instance, which we compare with the original hash we have to validate whether
    the operational state of the service matches the intent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If these values match, we can proceed to the next iteration (`continue`). Otherwise,
    we need to configure the router to bring the service to the desired state. Then,
    the loop starts over again. We get the service configuration in the target device’s
    syntax by using a template with the `genConfig` method and the `text/template`
    package, which we then send to the target device with the `sendConfig` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to see this example in action, you can run the code from the `ch05/closed-loop`
    folder. While it’s running, open an SSH session to the target Cisco DevNet device
    in a separate terminal window with `sshpass -p "C1sco12345" ssh admin@sandbox-iosxr-1.cisco.com`
    and execute the following to disable `TLS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the program’s output, you will see that it eventually catches this discrepancy,
    so it proceeds to remediate it by re-configuring TLS. The code for this example
    is available at `ch05/closed-loop/main.go` (*Further reading*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The intelligence in this scenario only considers a boolean outcome, without
    a qualitative assessment of the network situation. You can also explore how to
    get a more involved assessment of the data you retrieve from the network to make
    a decision tree that goes beyond just a simple fix network yes or no.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, with intent, we only cover a direct predetermined relationship between
    the intent and the configuration you require to enable it. Real deployments likely
    have more moving parts and decisions on which parts you need.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed what network automation is, its impact on network
    operations, and its benefits for the business. We talked about different use cases,
    from configuration management and network state analysis to running network audits
    and reporting, to finally look at how to put different pieces together to create
    a closed-loop system that can help you enforce the desired intent of the network.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll examine configuration management in detail, one of
    the more recurrent network automation use cases, and navigate through the options
    that Go presents to us to automate it.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information about the topics that were covered in this chapter, take
    a look at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This book’s GitHub repository: [https://github.com/PacktPublishing/Network-Automation-with-Go](https://github.com/PacktPublishing/Network-Automation-with-Go
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Batfish: [https://www.batfish.org/](https://www.batfish.org/ )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Forward: [https://forwardnetworks.com/forward-enterprise/](https://forwardnetworks.com/forward-enterprise/
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RESTCONF: [https://github.com/freeconf/restconf](https://github.com/freeconf/restconf
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NETCONF: [https://github.com/Juniper/go-netconf](https://github.com/Juniper/go-netconf
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch05/closed-loop/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch05/closed-loop/main.go#L1](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch05/closed-loop/main.go#L1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
