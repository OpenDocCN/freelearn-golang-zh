- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Network Automation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络自动化
- en: 'Up until this point, we’ve covered some Go fundamentals required to perform
    common network-related activities. Now, it’s time to focus on the principal topic
    of this book — network automation. Before we review the solutions, tools, and
    code libraries, let’s take a step back and look at network automation as a discipline.
    In this chapter, we aim to find an answer to the following questions:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了一些执行常见网络相关活动所需的Go基础知识。现在，是时候关注本书的主要主题——网络自动化了。在我们回顾解决方案、工具和代码库之前，让我们退一步，将网络自动化作为一个学科来审视。在本章中，我们旨在回答以下问题：
- en: What is network automation and why is it often considered a dedicated skill
    that’s distinct from, say, network engineering?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是网络自动化，为什么它通常被认为是一种与网络工程等不同的专门技能？
- en: What is its impact on network operations and its benefits for the business?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它对网络运营的影响以及对企业的好处是什么？
- en: What are some common automation use cases you can tackle individually?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以单独解决哪些常见的自动化用例？
- en: How can you string these individual use cases together into a bigger network
    automation system and why would anyone want that?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何将这些单独的用例组合成一个更大的网络自动化系统，以及为什么有人会想要那样做？
- en: This chapter is light on code but heavy on words and may contain arguments that
    not everyone may agree on. We, as authors of this book, are trying to express
    our opinions as objectively as possible, but our views are ultimately based on
    subjective experiences that we’ve had in our careers. Still, we have tried our
    best to steer away from the most controversial topics such as automation reducing
    the need for human operators and, where possible, provided evidence to support
    our arguments.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章代码较少，文字较多，可能包含并非所有人都可能同意的论点。作为本书的作者，我们试图尽可能客观地表达我们的观点，但我们的观点最终是基于我们在职业生涯中经历的主观经验。尽管如此，我们已尽力避免最具争议的话题，例如自动化减少对人工操作员的需求，并在可能的情况下提供了支持我们论点的证据。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is network automation?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是网络自动化？
- en: Automating network operation tasks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化网络操作任务
- en: Systems approach
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统方法
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code examples for this chapter in this book’s GitHub repository
    (specified in the *Further reading* section), under the `ch05` folder.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的GitHub仓库（在*进一步阅读*部分指定）的`ch05`文件夹中找到本章的代码示例。
- en: What is network automation?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是网络自动化？
- en: As a relatively new discipline, it’s not uncommon to see a broad spectrum of
    network automation definitions that vary in scope and goals. Network automation
    isn’t about one use case or technology in particular, but rather what can be of
    help in your environment and benefit your business.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一门相对较新的学科，看到范围和目标各不相同的广泛网络自动化定义并不罕见。网络自动化并不是关于特定用例或技术，而是关于在你的环境中能提供帮助并使你的业务受益的东西。
- en: Some engineers would argue that routing protocols already automate networks
    and the CLI is the intent-based API, transforming individual network commands
    into a dynamic network state. We don’t try to argue with this point of view, as
    there are some grains of truth in these statements, but it’s certainly not the
    most popular definition in the industry.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一些工程师可能会争论，路由协议已经自动化了网络，CLI是基于意图的API，将单个网络命令转换为动态网络状态。我们并不试图与这种观点争论，因为这些陈述中确实有一些真理，但它在行业中肯定不是最受欢迎的定义。
- en: Instead, let’s define network automation as a set of processes to automate common
    manual workflows performed by a network operator, such as provisioning services,
    performing software upgrades, or telemetry processing. This includes tasks that
    network engineers would otherwise traditionally have to click their way through,
    combined with running a set of CLI commands.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，让我们将网络自动化定义为一系列过程，用于自动化网络操作员执行的常见手动工作流程，例如提供服务、执行软件升级或遥测处理。这包括网络工程师通常必须通过点击操作的任务，以及运行一系列CLI命令。
- en: 'More complex network automation solutions may involve reacting to operational
    events by adjusting network configuration, applying traffic engineering policies,
    or even enforcing some design constraints. One common trait that unites all these
    activities is the ability to describe the desired behavior in a concrete sequence
    of steps that lead to the expected outcome. This may rule out some iterative activities
    such as network troubleshooting or creative activities such as network design,
    although they are making considerable progress in these areas with static configuration
    analysis (Batfish: *Further reading*) and mathematical network modeling (Forward:
    *Further reading*), for example, so we could eventually borrow concepts from the
    software world such as **test-driven development** (**TDD**) to automate the development
    and testing (whole-network **quality assurance** (**QA**) and regression) of configuration
    templates of a network design.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的网络自动化解决方案可能涉及通过调整网络配置、应用流量工程策略或甚至强制某些设计约束来对操作事件做出反应。所有这些活动的共同特征是能够通过一系列具体的步骤来描述期望的行为，从而实现预期的结果。这可能排除了某些迭代活动，如网络故障排除或创造性活动，如网络设计，尽管它们在这些领域取得了相当大的进展，例如静态配置分析（Batfish：*进一步阅读*）和数学网络建模（Forward：*进一步阅读*），因此我们最终可以借鉴软件世界的概念，如**测试驱动开发**（**TDD**）来自动化网络设计配置模板的开发和测试（整个网络的**质量保证**（**QA**）和回归测试）。
- en: Why network automation exists
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么网络自动化存在
- en: Probably a more interesting question to answer is why network automation exists
    as a discipline unlike, say, systems administration, which has evolved into site
    reliability engineering and now encompasses not only plain infrastructure provisioning
    but also observability, automation, and even systems software development.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 可能一个更有趣的问题是要回答为什么网络自动化作为一个学科存在，而像系统管理这样的领域，已经演变成站点可靠性工程，现在不仅包括基础设施的提供，还包括可观察性、自动化，甚至系统软件开发。
- en: The way we run and operate networks has changed very little in the last few
    decades. Network management still mainly focuses on executing CLI commands and
    working with unstructured data, despite the wide acceptance that CLI-driven operations
    are error-prone and not scalable. Often, this leads to a lack of standardization
    that leaves network engineers with manual processes taking up most of their workday
    and making networks difficult to scale, support, and secure.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几十年中，我们运行和操作网络的方式变化很小。尽管广泛接受CLI驱动的操作容易出错且不可扩展，但网络管理仍然主要关注执行CLI命令和与无结构数据工作。这通常导致缺乏标准化，使得网络工程师大部分工作日都在进行手动流程，使得网络难以扩展、支持和安全。
- en: Network automation has emerged as a response to this to improve efficiency and
    reduce the overhead of mundane tasks. The goal is to produce more reliable and
    repeatable processes, which increases productivity. This also helps make networks
    more consistent and simpler to operate, while at the same time reducing the likelihood
    of an outage, thus minimizing downtime.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 网络自动化作为对此的回应而出现，旨在提高效率并减少日常任务的冗余。目标是产生更可靠和可重复的过程，从而提高生产力。这也帮助使网络更加一致，操作更加简单，同时降低故障的可能性，从而最小化停机时间。
- en: 'Despite this, not all network engineers have embarked on the journey of network
    automation. Some reasons we think this could be the case are as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，并非所有网络工程师都开始了网络自动化的旅程。我们认为这可能是以下原因之一：
- en: Lack of standard and vendor-agnostic APIs for network management that return
    structured data. Network vendors typically offer proprietary configuration syntax
    or CLIs designed primarily for human interaction.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏标准和供应商无关的网络管理API，这些API返回结构化数据。网络供应商通常提供专有的配置语法或CLI，这些主要是为人类交互设计的。
- en: Automation requires a completely new skill set and, since network engineers
    generally don’t come from a computer science background, programming remains a
    big skill gap.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化需要一套全新的技能，由于网络工程师通常没有计算机科学背景，编程仍然是一个很大的技能差距。
- en: Learning automation requires time and not every employer is happy to dedicate
    part of their employees’ time to something with no immediate benefit.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习自动化需要时间，并不是每个雇主都愿意将员工的一部分时间投入到没有立即收益的事情上。
- en: Automation speed can also propagate a failure rapidly, which may not help build
    trust in automation early on. It takes time to create systems that are reliable,
    secure, and offer enough visibility.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化速度也可能迅速传播失败，这可能在早期不会有助于建立对自动化的信任。创建可靠、安全并提供足够可见性的系统需要时间。
- en: Given the large number of network automation tools, libraries, and frameworks
    with overlapping scopes, choosing the right one for a particular task can be challenging
    and introduces the risk of over-investing in something that may end up being a
    wrong choice.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于有大量具有重叠范围的网络自动化工具、库和框架，为特定任务选择正确的一个可能具有挑战性，并引入了过度投资于可能最终是错误选择的风险。
- en: Shifting from *it’s always been done this way* is hard. Sometimes, we follow
    the path of least resistance and, thus, are reluctant to change.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从“一直都是这样做的”转变为困难。有时，我们遵循阻力最小的路径，因此不愿意改变。
- en: Introducing network automation into your environment brings a different set
    of gains and perils, depending on your point of view. So, let’s try to unpack
    what it means to both engineers operating the network and the upper management
    operating the business for whom a network can be a cost or a profit center.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 将网络自动化引入您的环境会带来不同的收益和风险，这取决于您的观点。因此，让我们尝试分析这对操作网络的工程师和运营业务的上级管理层意味着什么，对于他们来说，网络可能是一个成本中心或利润中心。
- en: Bottom-up view
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自下而上的视角
- en: Some network operation activities that lend themselves well to automation include
    configuration changes, running audits or compliance checks, software and device
    life cycle management, and more. Several organizations have playbooks or require
    change management forms, documenting every operational step of these processes.
    Many companies already use a form of automation when a senior engineer prepares
    a change that a junior engineer later executes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一些非常适合自动化的网络操作活动包括配置更改、运行审计或合规性检查、软件和设备生命周期管理等等。一些组织有剧本或要求变更管理表格，记录这些流程的每个操作步骤。许多公司已经在高级工程师准备变更而初级工程师随后执行时使用某种形式的自动化。
- en: These activities usually have a set of very well-defined inputs, such as an
    inventory of devices, a list of commands to execute, a set of well-defined outputs,
    and maybe a filled-out spreadsheet or a new software version running on a device.
    These attributes make these activities suitable candidates for automation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些活动通常有一套非常明确的输入，例如设备清单、要执行的命令列表、一组定义明确的输出，可能还有填写好的电子表格或运行在设备上的新软件版本。这些属性使这些活动成为自动化的理想候选者。
- en: One of the commonly cited benefits of automation is its ability to scale – the
    relative cost of making a change to one device is the same as making a change
    to thousands of devices or making a hundred changes to hundreds of devices. Although
    scale and speed are important, they may not be the most valuable outcomes of process
    automation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化的一个常被引用的好处是其扩展能力——对单个设备进行更改的成本与对数千个设备进行更改的成本相对相同，或者对数百个设备进行数百次更改的成本相同。尽管规模和速度很重要，但它们可能不是流程自动化的最有价值的成果。
- en: 'For some networking teams with relatively small-scale networks or low change
    rates, network automation may bring other benefits, such as the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些具有相对较小规模网络或较低变更率的网络团队，网络自动化可能带来其他好处，例如以下内容：
- en: '**Consistency**: Since computers perform these changes, you can expect them
    to yield the same result every time. Also, you can enforce the same configurations,
    templates, or policies across elements.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：由于计算机执行这些更改，您可以期望它们每次都能产生相同的结果。此外，您可以在各个元素上强制执行相同的配置、模板或策略。'
- en: '**Reliability**: Instructions are code, which computers interprets unambiguously.
    You can also add automatic checks to validate inputs or results.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠性**：指令是代码，计算机可以明确地解释。您还可以添加自动检查来验证输入或结果。'
- en: '**Visibility**: All future and past changes in the network can be viewed by
    all members of the team, to embrace peer review and ease troubleshooting.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可见性**：网络中所有未来和过去的变化都可以由团队的所有成员查看，以接受同行评审并简化故障排除。'
- en: '**Ubiquity**: The same tools are used across different teams, which simplifies
    interactions and improves knowledge sharing.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**普遍性**：相同的工具被不同团队使用，这简化了交互并提高了知识共享。'
- en: When introducing network automation to your peers, it’s important to emphasize
    that this is not a single product or a solution, but rather a journey – a vector
    in a new direction with no fixed destination.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在向您的同事介绍网络自动化时，重要的是强调这不仅仅是一个单一的产品或解决方案，而是一次旅程——一个没有固定目的地的新的方向向量。
- en: Keep in mind that not all manual processes may be completely automatable, and
    it may take years to develop new practices and update existing procedures. This
    is why it’s also very important to get your organization’s management on board.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，并非所有手动流程都可以完全自动化，开发新实践和更新现有程序可能需要数年时间。这就是为什么让您的组织管理层参与进来也非常重要。
- en: Top-down view
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自上而下的视角
- en: Network engineers can understand the preceding technical points and can judge
    for themselves whether a network automation project is worth their time and effort
    to deploy.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 网络工程师可以理解上述技术要点，并可以自行判断网络自动化项目是否值得他们投入时间和精力部署。
- en: By contrast, the same arguments may not be enough to convince management if
    you don’t look at the bigger picture (the business). This could be one of the
    primary reasons a network automation initiative may fail. If the business benefits
    are not clear, then management may decide it’s not worth the investment of time.
    But the reverse is also true – a network automation initiative is more likely
    to succeed when it has support within the organization’s management structure.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，如果您不关注更大的图景（业务），相同的论点可能不足以说服管理层。这可能是网络自动化倡议可能失败的主要原因之一。如果业务收益不明确，管理层可能会决定不值得投入时间。但反过来也是真的——当网络自动化倡议在组织的管理结构中得到支持时，它更有可能成功。
- en: 'Here is a list of business values that you can use as a starting point in discussions
    with management. Depending on the company, a network can be a cost center or a
    profit center, so adjust or re-prioritize them to fit your circumstances:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一份业务价值列表，您可以用作与管理层讨论的起点。根据公司情况，网络可以是成本中心或利润中心，因此请调整或重新排序以适应您的具体情况：
- en: '**Cost management**: Generate cost savings through resource optimization. You
    reduce the costs of running the network by troubleshooting fewer human errors,
    not having to manually compile audit reports, or having to work on overtime changes.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本管理**：通过资源优化产生成本节约。您通过减少人为错误、无需手动编制审计报告或无需加班更改来降低网络的运营成本。'
- en: '**Speed of delivery**: Increase the speed to configure and validate changes
    in the network, allowing you to deliver customer services faster or even on-demand.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交付速度**：提高配置和验证网络更改的速度，使您能够更快地提供客户服务，甚至按需提供。'
- en: '**Risk management**: Enforce security policies consistently with every operation
    to reduce risk. Reduce the number of incidents that impact services and hence
    your revenue.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**风险管理**：在每次操作中始终如一地执行安全策略以降低风险。减少影响服务和因此影响您收入的事故数量。'
- en: '**Business capabilities**: Depending on how your organization defines value,
    network automation can help discover opportunities. Increased visibility could
    help improve capacity planning or spot unused capacity or hot spots. New services
    or business capabilities can be an outcome of streamlined cross-team interactions
    due to the well-defined interfaces, inputs, and outputs of an automated system.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务能力**：根据您的组织如何定义价值，网络自动化可以帮助发现机会。提高可见性可能有助于改善容量规划或发现未使用的容量或热点。由于自动化系统的接口、输入和输出定义良好，新的服务或业务能力可能是跨团队互动简化的结果。'
- en: Despite the rise of awareness about the benefits of network automation, some
    people are still hesitant to embrace it as an internal organizational practice,
    so getting support from them may require extra effort. Each situation is unique
    and, thus, may require a slightly distinct set of arguments. In the end, network
    automation is becoming an important part of network engineering and its relevance
    in the industry continues to increase.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管人们对网络自动化益处的认识有所提高，但有些人仍然犹豫不决，不愿将其作为内部组织实践接受，因此从他们那里获得支持可能需要额外努力。每种情况都是独特的，因此可能需要略微不同的论点集。最终，网络自动化正在成为网络工程的重要组成部分，其在行业中的相关性持续增加。
- en: Now that we’ve defined what network automation is and why we need it, it’s time
    to dig deeper and start looking at concrete use cases and areas where you can
    apply it in the traditional network engineering discipline.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了什么是网络自动化以及为什么我们需要它，是时候深入挖掘并开始查看具体的应用案例和领域，您可以在传统的网络工程学科中应用它。
- en: Automating network operation tasks
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化网络操作任务
- en: 'This section introduces some common network operation tasks and use cases where
    you can introduce automation without causing too much friction with the existing
    tools and processes. We aim to take a series of manual steps normally performed
    by a human operator and explore how you can convert them into code so that a computer
    can execute them for you, all while keeping the original inputs and outputs unchanged.
    We will divide this section into three categories:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了一些常见的网络操作任务和用例，在这些用例中，你可以引入自动化而不会对现有工具和流程造成太多摩擦。我们的目标是采取一系列通常由人工操作员执行的手动步骤，并探讨如何将它们转换为代码，以便计算机可以为您执行它们，同时保持原始输入和输出不变。我们将本节分为三个类别：
- en: Configuration management
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置管理
- en: Network state analysis
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络状态分析
- en: Network audits and reporting
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络审计和报告
- en: Let’s get started.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Configuration management
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置管理
- en: This is the most popular area of the network engineering discipline that spans
    beyond network operations and often includes design and architecture stages. Most
    people see this as the lowest-hanging fruit to test, or where to start using,
    network automation. Let’s look at some common use cases that fall under this category.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是网络工程学科最受欢迎的领域，它超越了网络操作，通常包括设计和架构阶段。大多数人认为这是测试的最低目标，或者开始使用网络自动化的起点。让我们看看一些属于这个类别的常见用例。
- en: Config generation
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置生成
- en: Before we can make any changes to a network device, we need to craft the desired
    configuration for that target device. Traditionally, we would do this manually
    in a text editor, which involves a lot of copy/paste and search/replace actions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以对网络设备进行任何更改之前，我们需要为该目标设备制定所需的配置。传统上，我们会在文本编辑器中手动完成此操作，这涉及到大量的复制/粘贴和搜索/替换操作。
- en: 'You can use the following Go packages to automate this process and generate
    a network device configuration based on a set of inputs:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下Go包来自动化此过程，并根据一组输入生成网络设备配置：
- en: '`text/template`: A package from the standard library that uses a special Go
    templating language to generate an unstructured text document based on the input
    program variables. We will use this package in the *Interacting with network devices
    via SSH* section in [*Chapter 6*](B16971_06.xhtml#_idTextAnchor144), *Configuration
    Management*.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text/template`：标准库中的一个包，使用特殊的Go模板语言根据输入程序变量生成无结构的文本文档。我们将在[*第6章*](B16971_06.xhtml#_idTextAnchor144)的*通过SSH与网络设备交互*部分，*配置管理*中使用此包。'
- en: '`flosch/pongo2`: A Django-syntax-like templating language for those that are
    more familiar with Jinja2 (the `gonja` fork).'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flosch/pongo2`：一个类似于Django语法的模板语言，适用于更熟悉Jinja2（`gonja`分支）的用户。'
- en: '`encoding`: This package includes encoders and decoders for YAML and JSON to
    parse and generate documents you can use with structured network APIs (for example,
    YANG or OpenAPI). We will use this package in the *Getting config inputs from
    other systems via HTTP* section in [*Chapter 6*](B16971_06.xhtml#_idTextAnchor144),
    *Configuration Management*.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encoding`：此包包括YAML和JSON的编码器和解码器，用于解析和生成可以与结构化网络API（例如，YANG或OpenAPI）一起使用的文档。我们将在[*第6章*](B16971_06.xhtml#_idTextAnchor144)的*通过HTTP从其他系统获取配置输入*部分，*配置管理*中使用此包。'
- en: '`regexp`: Another standard library package that implements efficient regular
    expression pattern matching and string manipulation. We will use this package
    in the example at the end of this chapter.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regexp`：另一个标准库包，实现了高效的正则表达式模式匹配和字符串操作。我们将在本章末尾的示例中使用此包。'
- en: Once you sort out the configuration details, you can send this config to the
    target device, which brings us to the next set of use cases.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你整理好配置细节，你就可以将此配置发送到目标设备，这引出了下一组用例。
- en: Configuration changes, backups, and restore
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置更改、备份和恢复
- en: Working with device configuration may involve backing up and replacing the entire
    device configuration or making scoped changes to provision new services or update
    existing configuration snippets. Making these changes often involves logging into
    each device individually and executing a set of vendor-specific commands in a
    sequence.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与设备配置一起工作可能涉及备份和替换整个设备配置，或进行范围更改以提供新服务或更新现有配置片段。进行这些更改通常需要单独登录到每个设备并按顺序执行一系列厂商特定的命令。
- en: 'The following Go packages can help with the transport abstractions that are
    common across different networking vendors to streamline the steps to make changes
    to, back up, or restore your network configurations:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Go包可以帮助处理不同网络供应商之间常见的传输抽象，以简化更改、备份或恢复您的网络配置的步骤：
- en: '`crypto/ssh`: A standard library package that implements base SSH connectivity.
    We will use this package in the *Interacting with network devices via SSH* section
    in [*Chapter 6*](B16971_06.xhtml#_idTextAnchor144), *Configuration Management*.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crypto/ssh`：一个实现基本SSH连接的标准库包。我们将在[*第6章*](B16971_06.xhtml#_idTextAnchor144)的*通过SSH与网络设备交互*部分使用此包，*配置管理*。'
- en: '`scrapli/scrapligo`: A third-party package that builds on top of crypto/SSH
    and offers various convenient helper functions to work with different CLI prompts
    and commands from major networking vendors. You can also use this package as a
    NETCONF client. We will use this package in the *Automating routine SSH tasks*
    section in [*Chapter 6*](B16971_06.xhtml#_idTextAnchor144), *Configuration Management*.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scrapli/scrapligo`：一个基于`crypto/SSH`构建的第三方包，提供了各种方便的辅助函数，用于处理主要网络供应商的不同CLI提示和命令。您还可以将此包用作NETCONF客户端。我们将在[*第6章*](B16971_06.xhtml#_idTextAnchor144)的*自动化常规SSH任务*部分使用此包，*配置管理*。'
- en: '`net/http`: A standard library package that you can use to talk to HTTP-based
    APIs, such as RESTCONF or OpenAPI. We will use this package in the *Getting config
    inputs from other systems via HTTP* section in [*Chapter 6*](B16971_06.xhtml#_idTextAnchor144),
    *Configuration Management*.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net/http`：一个标准库包，您可以使用它来与基于HTTP的API（如RESTCONF或OpenAPI）通信。我们将在[*第6章*](B16971_06.xhtml#_idTextAnchor144)的*通过HTTP从其他系统获取配置输入*部分使用此包，*配置管理*。'
- en: The preceding list is by no means exclusive and several more third-party packages
    are available, including some that are specifically designed to work with **RESTCONF**
    (*Further reading*) or **NETCONF** (*Further reading*), but they all vary in their
    levels of activity or openness to outside contributions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的列表绝不是排他的，还有更多第三方包可供选择，包括一些专门设计用于与**RESTCONF**(*进一步阅读*)或**NETCONF**(*进一步阅读*)一起工作的包，但它们在活动水平或对外部贡献的开放程度方面各不相同。
- en: It always helps to look around, especially when choosing an external package,
    to make sure it fits your needs and has a healthy community of contributors.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 总是环顾四周总会有帮助，尤其是在选择外部包时，以确保它符合您的需求并且拥有一个健康的贡献者社区。
- en: Configuration diffs and compliance checks
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置差异和合规性检查
- en: 'After you have applied the desired configuration, you may need to run periodic
    compliance checks to make sure certain invariants remain unchanged or to detect
    any configuration drift. These use cases rely on string searching, pattern matching,
    and computing differences. You can leverage the following Go packages for this
    purpose:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在您应用了所需的配置之后，您可能需要定期运行合规性检查，以确保某些不变量保持不变，或者检测任何配置漂移。这些用例依赖于字符串搜索、模式匹配和计算差异。您可以使用以下Go包来实现这一目的：
- en: '`strings`: A package from the standard library that can offer basic string
    comparison and pattern matching with the `Compare` and `Contains` functions. We
    will use this package in the example at the end of this chapter.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strings`：一个来自标准库的包，可以使用`Compare`和`Contains`函数提供基本的字符串比较和模式匹配。我们将在本章末尾的示例中使用此包。'
- en: '`sergi/go-diff`: A third-party package that can compare, match, or patch plain
    text (a Go port of the `google/diff-match-patch` package).'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sergi/go-diff`：一个第三方包，可以比较、匹配或修补纯文本（`google/diff-match-patch`包的Go端口）。'
- en: '`homeport/dyff`: Another third-party package and a command-line tool you can
    use to compare structured documents, such as JSON or YAML.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`homeport/dyff`：另一个第三方包和命令行工具，您可以使用它来比较结构化文档，例如JSON或YAML。'
- en: While keeping your device configuration in check is crucial, you can’t derive
    everything that happens in the network from them. That’s why we need to complement
    our analysis with the operational data we gather from the network.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然保持您的设备配置在控制之下至关重要，但您不能从它们中推导出网络中发生的所有事情。这就是为什么我们需要用我们从网络中收集的操作数据来补充我们的分析。
- en: Network state analysis
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络状态分析
- en: The operational state that results from an applied configuration is often hard
    to predict. You can spend a significant amount of time fine-tuning monitoring
    and collecting information from the network. But these use cases are often a good
    first step into network automation because of their low-risk profile, so they
    present a very attractive opportunity to start using Go.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由应用配置产生的操作状态通常难以预测。你可能需要花费大量时间微调监控并从网络收集信息。但由于这些用例风险较低，它们通常是网络自动化的良好起点，因此它们提供了使用Go的非常有吸引力的机会。
- en: Collecting operational state
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 收集操作状态
- en: 'Depending on the target `?rev=operational` indicates that the returned data
    should come from the operational data store. In contrast, for a human-first NOS,
    this may require extra steps to parse the CLI output you get from it. You can
    do this in Go in a few different ways:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`?rev=operational`的目标，表示返回的数据应来自操作数据存储。相比之下，对于以人为首的NOS，这可能需要额外的步骤来解析从它获得的CLI输出。你可以在Go中以几种不同的方式做这件事：
- en: '`regexp`: Using regular expressions is the most battle-tested and well-known
    way of parsing unstructured text into variables. Keep in mind that writing robust
    regular expressions and troubleshooting them can be a challenge. We will use this
    package in the example at the end of this chapter.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regexp`：使用正则表达式是将非结构化文本解析到变量中的最经得起考验和最知名的方法。请记住，编写健壮的正则表达式和调试它们可能是一个挑战。我们将在本章末尾的示例中使用这个软件包。'
- en: '`sirikothe/gotextfsm`: This package offers a higher-level abstraction built
    on top of the `regexp` package, designed to parse semi-formatted text, meaning
    text with visual structure, such as tables, but represented as a single string.
    We will use this package indirectly in the *Checking routing information* section
    in [*Chapter 6*](B16971_06.xhtml#_idTextAnchor144), *Configuration Management*.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sirikothe/gotextfsm`：这个软件包在`regexp`软件包之上提供了一个高级抽象，旨在解析半格式化文本，即具有视觉结构的文本，如表格，但表示为单个字符串。我们将在[*第6章*](B16971_06.xhtml#_idTextAnchor144)的*检查路由信息*部分间接使用这个软件包，*配置管理*。'
- en: '`scrapli/scrapligo`: This package embeds the `textfsm` package and allows you
    to parse the responses you get from networking devices using the `TextFsmParse(template
    string)` function. We will use this package in the *Checking routing information*
    section in [*Chapter 6*](B16971_06.xhtml#_idTextAnchor144), *Configuration Management*.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scrapli/scrapligo`：这个软件包集成了`textfsm`软件包，并允许你使用`TextFsmParse(template string)`函数解析从网络设备获得的响应。我们将在[*第6章*](B16971_06.xhtml#_idTextAnchor144)的*检查路由信息*部分使用这个软件包，*配置管理*。'
- en: You can get the operational state of the network and parse it into in-memory
    data structures before and after a maintenance window, for example, to compare
    them and vet the success of the work performed during this time. This is what
    we’ll discuss next.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在维护窗口前后获取网络的操作状态并将其解析到内存数据结构中，例如，比较它们并审查在此期间完成的工作的成功情况。这就是我们将要讨论的下一个问题。
- en: State snapshots and validation
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 状态快照和验证
- en: Validating the operational state, to make sure that the values we receive are
    what we expect to see, is something network engineers do when they configure network
    devices, run troubleshooting sessions, provision services, perform software upgrades,
    and carry out other daily activities as part of their job assignments.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 验证操作状态，确保我们收到的值是我们预期看到的，这是网络工程师在配置网络设备、运行故障排除会话、提供服务、执行软件升级以及执行其他日常活动作为其工作分配的一部分时所做的事情。
- en: As we automate the collection of this data and since we can often pre-calculate
    the intended state, the next step is to check whether the state is as expected
    and then make sure that this state persists over time. For example, BGP neighbors
    should be in an *established* state and all connected interfaces should be *up*.
    As we collect new data from the network, we record it in a structured format to
    compare it with the intended state and to trigger another action if we find a
    difference.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们自动收集这些数据并且我们通常可以预先计算预期的状态，下一步是检查状态是否符合预期，并确保这种状态随时间持续。例如，BGP邻居应该处于*已建立*状态，所有连接的接口都应该*开启*。当我们从网络收集新的数据时，我们将它记录在结构化格式中，以便与预期状态进行比较，并在发现差异时触发另一个操作。
- en: 'Comparing arbitrary data normally requires writing some custom code to traverse
    these data structures and look at the values that matter. But there are a few
    packages that can simplify this task:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 比较任意数据通常需要编写一些自定义代码来遍历这些数据结构并查看重要的值。但有一些软件包可以简化这项任务：
- en: '`reflect.DeepEqual`: This package is part of the Go standard library and can
    use runtime reflection to compare values that are of the same type.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reflect.DeepEqual`：这个包是Go标准库的一部分，可以使用运行时反射来比较相同类型的值。'
- en: '`mitchellh/hashstructure`: A third-party package that can calculate a unique
    hash from arbitrary Go values that you can use to quickly answer the question
    if the operational state matches the one you expect. We will use this package
    in the example at the end of this chapter.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mitchellh/hashstructure`：一个第三方包，可以从任意Go值计算出一个唯一的哈希值，你可以用它来快速回答操作状态是否与预期的状态匹配。我们将在本章末尾的示例中使用这个包。'
- en: '`r3labs/diff`: Another third-party package that supports several standard Go
    types and relies on runtime reflection to produce a detailed log of all the differences
    between two Go structs or values.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r3labs/diff`：另一个支持多个标准Go类型并依赖于运行时反射来生成两个Go结构体或值之间所有差异的详细日志的第三方包。'
- en: We can’t classify all operational states as *intended*. Some values are more
    dynamic and their change is not always actionable. An example of this is MAC and
    IP address tables – their values fluctuate over time and long-term churn is normal.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能将所有操作状态都归类为*预期的*。一些值更动态，它们的改变并不总是可操作的。一个例子是MAC和IP地址表——它们的值会随时间波动，长期波动是正常的。
- en: Keeping track of the dynamic state of the network can be helpful during routine
    maintenance, such as in software upgrades, where you make snapshots of the network
    state and can quickly compare the pre - and post-change values to spot any inconsistencies.
    Programmatically, this is just like the generic state validation use case. You
    use the same set of tools and libraries but save these snapshots as a structured
    document on a disk or inside a database over time.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常维护期间，如软件升级时跟踪网络的动态状态可能会有所帮助，这时你可以对网络状态进行快照，并可以快速比较变更前后的值以发现任何不一致之处。从程序的角度来看，这就像通用的状态验证用例。你使用相同的一组工具和库，但将这些快照作为结构化文档保存在磁盘或数据库中，随着时间的推移。
- en: Network audits and reporting
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络审计和报告
- en: The scope of network audits can vary greatly, from trying to identify obsolete
    hardware or end-of-life software to measuring the quality of the service or the
    rate of control plane updates. Normally, the goal is to collect and process state
    information from a large set of devices and produce some human-readable output.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 网络审计的范围可能很大，从试图识别过时的硬件或生命终结的软件到衡量服务质量或控制平面更新的速率。通常，目标是收集和处理大量设备的状态信息，并生成一些人类可读的输出。
- en: 'We discussed state collection and validation tasks in the preceding section,
    and you can scale this process to target hundreds or thousands of network devices
    with goroutines, which we covered in [*Chapter 3*](B16971_03.xhtml#_idTextAnchor067),
    *Getting Started with Go*. The missing part that we haven’t discussed yet is report
    generation. Here, Go also offers several resources that you can use to generate
    human-readable outputs:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节讨论了状态收集和验证任务，你可以使用goroutines将此过程扩展到针对数百或数千个网络设备，这在[*第3章*](B16971_03.xhtml#_idTextAnchor067)，“Go入门”，中有介绍。我们尚未讨论的缺失部分是报告生成。在这里，Go也提供了几个你可以用来生成人类可读输出的资源：
- en: '`text/tabwriter`: This is a package from the standard library you should consider
    if you want to send information to standard output. You can use this package to
    print tabbed data. Other feature-rich options exist outside of the standard library,
    one of which is the `jedib0t/go-pretty/v6` package, which can you can use to colorize
    text or print tables, lists, and progress bars.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text/tabwriter`：如果你想要将信息发送到标准输出，这是一个你应该考虑的标准库包。你可以使用这个包来打印制表符数据。标准库之外还有其他功能丰富的选项，其中之一是`jedib0t/go-pretty/v6`包，你可以用它来着色文本或打印表格、列表和进度条。'
- en: '`unidoc/unioffice`: This package or `qax-os/excelize` are good options if you
    want to produce a spreadsheet. You can also use `unidoc/unioffice` to work with
    Word, Excel, or PowerPoint documents.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unidoc/unioffice`：如果你想要生成电子表格，这个包或`qax-os/excelize`是不错的选择。你也可以使用`unidoc/unioffice`来处理Word、Excel或PowerPoint文档。'
- en: '`html/template` and `text/template`: These are the two most common templating
    libraries. Hugo, the popular static site generator, uses both the `html` and `text`
    template packages, for example.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`html/template`和`text/template`：这是两个最常见的模板库。例如，流行的静态站点生成器Hugo使用`html`和`text`模板包。'
- en: '`go:embed`: This is a Go directive that you could use to allow templates to
    be embedded inside a compiled Go binary to simplify code distribution.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go:embed`：这是一个Go指令，你可以用它来允许模板嵌入到编译后的Go二进制文件中，从而简化代码分发。'
- en: The use cases we’ve introduced in this section are all relatively independent.
    Once you automate them, they can become so-called automation islands, completely
    isolated from one another at first, but once their number grows, they may merge
    into more complex multi-stage workflows or even complete closed-loop systems.
    This is what we’ll explore in the next section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中介绍的使用案例都是相对独立的。一旦你自动化它们，它们可以成为所谓的自动化孤岛，最初完全相互隔离，但一旦它们的数量增加，它们可能会合并成更复杂的多阶段工作流程，甚至完整的闭环系统。这就是我们将在下一节中探讨的内容。
- en: Systems approach
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统方法
- en: As you start automating different tasks with an incremental approach, you may
    envision a path where you chain a subset of these automated tasks together to
    orchestrate a workflow.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始以增量方式自动化不同的任务时，你可能想象出一个路径，将这些建自动化任务的一部分串联起来，以编排一个工作流程。
- en: You can also look at this from a different angle. You initially break down your
    existing manual processes into smaller chunks of work that you can automate independently,
    so you don’t need to wait until you get the full end-to-end process automated
    to start taking advantage of automation, while at the same time you are mindful
    of the bigger picture.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从不同的角度看待这个问题。你最初将现有的手动流程分解成可以独立自动化的更小的工作块，这样你就不需要等到整个端到端流程自动化才开始利用自动化，同时你也要关注大局。
- en: In this context, you take the first steps to interconnect different building
    blocks, which become part of a larger system that delivers a business outcome
    with eventually no human intervention that originally may have involved several
    teams. That’s what we call a systems approach.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你开始将不同的构建块相互连接，这些构建块最终成为交付业务成果的更大系统的一部分，而最初可能涉及多个团队的人类干预最终可能不再需要。这就是我们所说的系统方法。
- en: One common example is when you mix the processes of configuring network services
    and collecting operational data from the network, which is what we’ll discuss
    next.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的例子是当你混合配置网络服务和从网络收集操作数据的过程，这就是我们接下来要讨论的。
- en: Closed-loop automation
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭环自动化
- en: One of the first things every network engineer does after configuring anything
    on a network device is to check the status of that service, protocol, or resource
    configured via a CLI command. If an automated system performs this configuration,
    the network engineer still needs to log into a network device or group of network
    devices to execute commands, or maybe go to a web portal to check the logs or
    graphs that show the statistics for the network devices. This time-consuming,
    repetitive process that is error-prone for humans becomes a natural fit for automation
    as well.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 每个网络工程师在配置网络设备上的任何内容后，首先要做的事情就是检查通过CLI命令配置的服务、协议或资源的状态。如果一个自动化系统执行此配置，网络工程师仍然需要登录到网络设备或一组网络设备来执行命令，或者可能去网页门户检查显示网络设备统计信息的日志或图表。这个耗时、重复且容易出错的过程对于人类来说非常适合自动化。
- en: Now, you not only push the configuration or instructions down to the network
    but also ingest real-time operational data from the network, which you can process
    to determine whether it matches the intended state of the network.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你不仅将配置或指令推送到网络，还从网络中摄取实时操作数据，你可以对这些数据进行处理，以确定它是否与网络预期的状态相匹配。
- en: 'If we abstract away the network device details, a closed-loop application would
    consume **network intelligence** on one interface, and push intent down to the
    network. We can loosely define these as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们抽象出网络设备的细节，闭环应用程序将消耗一个接口上的**网络智能**，并将意图推送到网络。我们可以大致定义如下：
- en: '**Intent**: This would be the declarative definition of the operational state
    or measurable outcome you expect in the context of the network (topology, inventory,
    protocol, and so on) without requiring you to specify an exact procedure to get
    to it (those are implementation details).'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**意图**：这将是你在网络（拓扑、库存、协议等）上下文中期望的操作状态或可测量的结果的声明性定义，而不需要你指定达到它的确切步骤（这些是实现细节）。'
- en: '**Network intelligence**: This would be telemetry from the network that is
    actionable after some level of processing to make it useful. Keep in mind that
    events, metrics, stats, or alarms do not necessarily translate into actionable
    intelligence. Network operators get so many alarms that it’s hard to know what’s
    real and what’s noise. Hence, network intelligence results from correlating this
    data, running analytics, or any other process that helps tie this to the desired
    intent.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络智能**：这将是从网络中获取的，经过一定程度的处理后可操作的数据。请记住，事件、指标、统计数据或警报并不一定转化为可操作智能。网络操作员接收到如此多的警报，以至于很难知道什么是真实的，什么是噪音。因此，网络智能是通过关联这些数据、运行分析或任何其他有助于将其与所需意图联系起来的过程产生的。'
- en: 'The following is a high-level diagram of a closed-loop application:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下图是闭环应用程序的高级示意图：
- en: '![Figure 5.1 – Closed-loop automation – 10,000 foot view](img/Figure_5.1.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 闭环自动化 – 10,000 英尺视角](img/Figure_5.1.jpg)'
- en: Figure 5.1 – Closed-loop automation – 10,000 foot view
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 闭环自动化 – 10,000 英尺视角
- en: The intent translates into configuration syntax or programmatic instructions,
    which are specific to the network device. We can adjust these instructions based
    on the feedback we get from the network, enabling us to close the loop and automate
    the life cycle of network services.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 意图转化为配置语法或程序性指令，这些指令针对网络设备是特定的。我们可以根据从网络获得的反馈调整这些指令，使我们能够关闭循环并自动化网络服务的生命周期。
- en: You can think of a closed-loop system as a continuous loop that learns from
    the networks and adapts to them. This could replace pre - and post-snapshot checks
    as you would compare the network at arbitrary times and for arbitrary deltas continuously.
    But what we see in networks today is somewhat closer to systems that react to
    the network feedback only during the time window in which they provision a service.
    This is what we will replicate in the following example.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将闭环系统想象成一个从网络中学习并适应它们的连续循环。这可以替代在任意时间和任意增量下进行的预和后快照检查。但今天我们在网络中看到的是某种更接近仅在它们提供服务的窗口时间内对网络反馈做出反应的系统的系统。这就是我们将在以下示例中复制的。
- en: Demo application
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 演示应用程序
- en: 'For the demo application, we could either build a distributed system where
    all the different components communicate and coordinate via messages over the
    network, or run everything on just one node in a single application. Because the
    goal is to illustrate the notion of closed-loop automation and not to show how
    distributed systems work, we will keep the application simple and run all the
    components as functions of a monolith application, as shown in the following diagram:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于演示应用程序，我们既可以构建一个分布式系统，其中所有不同的组件通过网络消息进行通信和协调，也可以在单个应用程序的一个节点上运行一切。因为目标是说明闭环自动化的概念，而不是展示分布式系统的工作方式，所以我们将保持应用程序简单，并将所有组件作为单体应用程序的功能运行，如下面的图所示：
- en: '![Figure 5.2 – Closed-loop automation sample application](img/Figure_5.2.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 闭环自动化示例应用](img/Figure_5.2.jpg)'
- en: Figure 5.2 – Closed-loop automation sample application
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 闭环自动化示例应用
- en: 'The application starts by reading the input data from the user. It reads the
    target device information for this example from a file, `input.yml`, as shown
    in the following code snippet. We hard code the parameters of the service to configure
    a variable (`intent`) in the code. The service we want to configure in this case
    is `57777` with `TLS` enabled:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序首先从用户那里读取输入数据。本例中，它从文件`input.yml`中读取目标设备信息，如下面的代码片段所示。我们在代码中硬编码服务的参数以配置一个变量（`intent`）。在这种情况下，我们想要配置的服务是`57777`，并启用`TLS`：
- en: '[PRE0]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We encapsulate the service information in a `Service` definition that acts
    as a higher layer of abstraction than what a network device configuration represents,
    which translates into the intent for this example. We also compute a hash of this
    value so that we can compare it later with the operational information we receive
    from the network:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将服务信息封装在一个`Service`定义中，它比网络设备配置所表示的抽象层次更高，这转化为本例中的意图。我们还计算了这个值的哈希值，以便我们可以稍后将其与从网络收到的操作信息进行比较：
- en: '[PRE1]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Before the application configures the service, we have the chance to perform
    a series of pre-maintenance tasks, such as running a network audit to report whether
    the service is present already, so you may not need to configure it. Another good
    idea is to make a backup of the network device’s configuration in case we need
    to roll back the changes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序配置服务之前，我们有机会执行一系列预防性维护任务，例如运行网络审计来报告服务是否已经存在，因此你可能不需要配置它。另一个好主意是备份网络设备的配置，以防我们需要回滚更改。
- en: 'In this example, we must make a configuration backup of the target device with
    the `getConfig` method and then save it in a folder with the `save` method:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们必须使用`getConfig`方法对目标设备进行配置备份，然后使用`save`方法将其保存到一个文件夹中：
- en: '[PRE2]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With the pre-work done, the application enters a continuous enforcement loop
    that runs, in this example, every 30 seconds. Inside the loop, the application
    collects the operational state of the service with the `getOper` method. This
    method sends a CLI command to the target device to gather the operational details
    of the service we need:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成预工作后，应用程序进入一个持续执行的循环，在这个例子中，每30秒运行一次。在循环内部，应用程序使用`getOper`方法收集服务的操作状态。此方法向目标设备发送CLI命令，以收集我们需要的服务的操作细节：
- en: '[PRE3]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once we receive the response, we parse the information with regular expressions
    while using the `regexp` package to generate a new `Service` value with it that
    captures whether the service has `TLS` enabled, for example, as well as the rest
    of the `Service` attributes. Then, we calculate a new hash for this `Service`
    type instance, which we compare with the original hash we have to validate whether
    the operational state of the service matches the intent:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们收到响应，我们使用正则表达式解析信息，同时使用`regexp`包生成一个新的`Service`值，该值捕获服务是否启用了`TLS`，例如，以及`Service`的其他属性。然后，我们为这个`Service`类型实例计算一个新的哈希值，并将其与我们拥有的原始哈希值进行比较，以验证服务的操作状态是否与意图匹配：
- en: '[PRE4]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If these values match, we can proceed to the next iteration (`continue`). Otherwise,
    we need to configure the router to bring the service to the desired state. Then,
    the loop starts over again. We get the service configuration in the target device’s
    syntax by using a template with the `genConfig` method and the `text/template`
    package, which we then send to the target device with the `sendConfig` function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些值匹配，我们可以继续到下一个迭代（`continue`）。否则，我们需要配置路由器，将服务带到所需的状态。然后，循环重新开始。我们通过使用`genConfig`方法和`text/template`包中的模板来获取目标设备上的服务配置，然后使用`sendConfig`函数将其发送到目标设备：
- en: '[PRE5]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you want to see this example in action, you can run the code from the `ch05/closed-loop`
    folder. While it’s running, open an SSH session to the target Cisco DevNet device
    in a separate terminal window with `sshpass -p "C1sco12345" ssh admin@sandbox-iosxr-1.cisco.com`
    and execute the following to disable `TLS`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看到这个例子在实际中的运行，你可以从`ch05/closed-loop`文件夹中运行代码。当它运行时，在另一个终端窗口中打开一个SSH会话到目标Cisco
    DevNet设备，使用`sshpass -p "C1sco12345" ssh admin@sandbox-iosxr-1.cisco.com`，并执行以下命令来禁用`TLS`：
- en: '[PRE6]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the program’s output, you will see that it eventually catches this discrepancy,
    so it proceeds to remediate it by re-configuring TLS. The code for this example
    is available at `ch05/closed-loop/main.go` (*Further reading*):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的输出中，你会看到它最终捕捉到这个差异，因此它将继续通过重新配置TLS来修复它。这个例子的代码可以在`ch05/closed-loop/main.go`中找到（*进一步阅读*）：
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The intelligence in this scenario only considers a boolean outcome, without
    a qualitative assessment of the network situation. You can also explore how to
    get a more involved assessment of the data you retrieve from the network to make
    a decision tree that goes beyond just a simple fix network yes or no.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，智能仅考虑布尔结果，而不对网络情况进行定性评估。你还可以探索如何获取对从网络中检索的数据的更深入评估，以便创建一个超越简单网络修复是或否的决策树。
- en: Likewise, with intent, we only cover a direct predetermined relationship between
    the intent and the configuration you require to enable it. Real deployments likely
    have more moving parts and decisions on which parts you need.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，与意图一样，我们只覆盖意图和所需配置之间的直接预定关系。实际部署可能涉及更多移动部件和关于你需要哪些部件的决策。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed what network automation is, its impact on network
    operations, and its benefits for the business. We talked about different use cases,
    from configuration management and network state analysis to running network audits
    and reporting, to finally look at how to put different pieces together to create
    a closed-loop system that can help you enforce the desired intent of the network.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了网络自动化是什么，它对网络运营的影响，以及它对企业的益处。我们讨论了不同的用例，从配置管理和网络状态分析到运行网络审计和报告，最后探讨如何将不同的部分组合起来，创建一个闭环系统，以帮助您强制执行网络所需意图。
- en: In the next chapter, we’ll examine configuration management in detail, one of
    the more recurrent network automation use cases, and navigate through the options
    that Go presents to us to automate it.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将详细探讨配置管理，这是网络自动化中较为常见的用例之一，并导航Go为我们提供的自动化选项。
- en: Further reading
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information about the topics that were covered in this chapter, take
    a look at the following resources:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章所涉及主题的更多信息，请参阅以下资源：
- en: 'This book’s GitHub repository: [https://github.com/PacktPublishing/Network-Automation-with-Go](https://github.com/PacktPublishing/Network-Automation-with-Go
    )'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书GitHub仓库：[https://github.com/PacktPublishing/Network-Automation-with-Go](https://github.com/PacktPublishing/Network-Automation-with-Go
    )
- en: 'Batfish: [https://www.batfish.org/](https://www.batfish.org/ )'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Batfish: [https://www.batfish.org/](https://www.batfish.org/ )'
- en: 'Forward: [https://forwardnetworks.com/forward-enterprise/](https://forwardnetworks.com/forward-enterprise/
    )'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前瞻：[https://forwardnetworks.com/forward-enterprise/](https://forwardnetworks.com/forward-enterprise/
    )
- en: 'RESTCONF: [https://github.com/freeconf/restconf](https://github.com/freeconf/restconf
    )'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RESTCONF: [https://github.com/freeconf/restconf](https://github.com/freeconf/restconf
    )'
- en: 'NETCONF: [https://github.com/Juniper/go-netconf](https://github.com/Juniper/go-netconf
    )'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'NETCONF: [https://github.com/Juniper/go-netconf](https://github.com/Juniper/go-netconf
    )'
- en: '`ch05/closed-loop/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch05/closed-loop/main.go#L1](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch05/closed-loop/main.go#L1)'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch05/closed-loop/main.go`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch05/closed-loop/main.go#L1](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch05/closed-loop/main.go#L1)'
