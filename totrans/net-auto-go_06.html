<html><head></head><body>
<div id="_idContainer061">
<h1 class="chapter-number" id="_idParaDest-145"><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-146"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.2.1">Configuration Management</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Configuration management is a </span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.4.1">process that helps us enforce the desired configuration state on an IT system. </span><span class="koboSpan" id="kobo.4.2">It’s a way to make sure a network device, in our context, performs as expected as we roll out new settings. </span><span class="koboSpan" id="kobo.4.3">As this becomes a mundane task we perform repeatedly, it’s no surprise network configuration management is the most common network automation use case according to the NetDevOps 2020 Survey (</span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.5.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In the previous chapter, we discussed common configuration management tasks, along with some helpful tools and libraries that can help you write programs to automate those tasks in Go. </span><span class="koboSpan" id="kobo.7.2">In this chapter, we will focus on a few concrete examples, taking a closer look at how Go can help us connect and interact with network devices from different networking vendors using standard protocols. </span><span class="koboSpan" id="kobo.7.3">We will cover four areas in </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Before we introduce any new examples, we will define a three-node multi-vendor virtual network lab to test the code examples in this chapter and later chapters of </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">this book.</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Next, we will explore how we can use Go and SSH to interact with </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">network devices.</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Then, we will repeat the exercise following the same program structure as with SSH but using HTTP to contrast these </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">different options.</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Finally, we will extract and parse the resulting operational state to verify that our configuration changes have </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">been successful.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.17.1">Note that we have deliberately avoided talking about YANG-based APIs here as we will cover them extensively in the last few chapters of </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">following topics:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.21.1">Environment setup</span></span></li>
<li><span class="koboSpan" id="kobo.22.1">Interacting with network devices </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">via SSH</span></span></li>
<li><span class="koboSpan" id="kobo.24.1">Interacting with network devices </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">via HTTP</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.26.1">State validation</span></span></li>
</ul>
<h1 id="_idParaDest-147"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.27.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.28.1">You can find the code examples for this chapter in the book’s GitHub repository: </span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go"><span class="koboSpan" id="kobo.29.1">https://github.com/PacktPublishing/Network-Automation-with-Go</span></a><span class="koboSpan" id="kobo.30.1">, under the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.31.1">ch06</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.32.1"> folder.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.33.1">Important Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.34.1">We recommend that you execute the Go programs in this chapter in a virtual lab environment. </span><span class="koboSpan" id="kobo.34.2">Refer to the </span><em class="italic"><span class="koboSpan" id="kobo.35.1">Appendix</span></em><span class="koboSpan" id="kobo.36.1"> for prerequisites and instructions on how to </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">build it.</span></span></p>
<h1 id="_idParaDest-148"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.38.1">Environment setup</span></h1>
<p><span class="koboSpan" id="kobo.39.1">One of </span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.40.1">the easiest and safest ways to learn and experiment with network automation is to build a lab environment. </span><span class="koboSpan" id="kobo.40.2">Thanks to the progress we’ve had in the last decade, today, we have access to virtualized and containerized network devices from different networking vendors and plenty of tools that can help us build a virtual topology </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">from them.</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">In this book, we will use one of</span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.43.1"> those tools: </span><strong class="bold"><span class="koboSpan" id="kobo.44.1">Containerlab</span></strong><span class="koboSpan" id="kobo.45.1">. </span><span class="koboSpan" id="kobo.45.2">This tool, which is written in Go, allows you to build arbitrary network topologies from container images. </span><span class="koboSpan" id="kobo.45.3">The fact that you can create and run topologies based on a plain YAML file in a matter of seconds makes it a strong choice to run quick tests. </span><span class="koboSpan" id="kobo.45.4">Please refer to the </span><em class="italic"><span class="koboSpan" id="kobo.46.1">Appendix</span></em><span class="koboSpan" id="kobo.47.1"> for installation instructions and recommendations for host </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">operating systems.</span></span></p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.49.1">Creating the topology</span></h2>
<p><span class="koboSpan" id="kobo.50.1">Throughout</span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.51.1"> the rest of this book, we will work with a base network topology consisting of three containerized network devices running </span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.52.1">different </span><strong class="bold"><span class="koboSpan" id="kobo.53.1">network operating </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.54.1">systems</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.55.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.56.1">NOSes</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">):</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">srl</span></strong><span class="koboSpan" id="kobo.59.1">: Running Nokia’s </span><strong class="bold"><span class="koboSpan" id="kobo.60.1">Service Router Linux </span></strong><span class="koboSpan" id="kobo.61.1">(</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.62.1">SR Linux</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">)</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">cvx</span></strong><span class="koboSpan" id="kobo.65.1">: Running NVIDIA’s </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">Cumulus Linux</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">ceos</span></strong><span class="koboSpan" id="kobo.68.1">: Running </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">Arista’s EOS</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.70.1">The</span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.71.1"> following diagram depicts the device interconnections. </span><span class="koboSpan" id="kobo.71.2">They all come up with their default (</span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">blank) configuration:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer057">
<span class="koboSpan" id="kobo.73.1"><img alt="Figure 6.1 – Test topology" src="image/B16971_06_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.74.1">Figure 6.1 – Test topology</span></p>
<p><span class="koboSpan" id="kobo.75.1">We can describe this topology with the following YAML file, which is a representation that </span><strong class="bold"><span class="koboSpan" id="kobo.76.1">Containerlab</span></strong><span class="koboSpan" id="kobo.77.1"> can </span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.78.1">interpret and translate into a </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">running topology:</span></span></p>
<pre class="source-code"><span class="Code_Blue"><span class="koboSpan" id="kobo.80.1">name</span></span><span class="koboSpan" id="kobo.81.1">: netgo
</span><span class="Code_Blue"><span class="koboSpan" id="kobo.82.1">topology</span></span><span class="koboSpan" id="kobo.83.1">:
  </span><span class="Code_Blue"><span class="koboSpan" id="kobo.84.1">nodes</span></span><span class="koboSpan" id="kobo.85.1">:
    </span><span class="Code_Blue"><span class="koboSpan" id="kobo.86.1">srl</span></span><span class="koboSpan" id="kobo.87.1">:
      </span><span class="Code_Blue"><span class="koboSpan" id="kobo.88.1">kind</span></span><span class="koboSpan" id="kobo.89.1">: srl
      </span><span class="Code_Blue"><span class="koboSpan" id="kobo.90.1">image</span></span><span class="koboSpan" id="kobo.91.1">: ghcr.io/nokia/srlinux:21.6.4
    </span><span class="Code_Blue"><span class="koboSpan" id="kobo.92.1">ceos</span></span><span class="koboSpan" id="kobo.93.1">:
      </span><span class="Code_Blue"><span class="koboSpan" id="kobo.94.1">kind</span></span><span class="koboSpan" id="kobo.95.1">: ceos
      </span><span class="Code_Blue"><span class="koboSpan" id="kobo.96.1">image</span></span><span class="koboSpan" id="kobo.97.1">: ceos:4.26.4M
    </span><span class="Code_Blue"><span class="koboSpan" id="kobo.98.1">cvx</span></span><span class="koboSpan" id="kobo.99.1">:
      </span><span class="Code_Blue"><span class="koboSpan" id="kobo.100.1">kind</span></span><span class="koboSpan" id="kobo.101.1">: cvx
      </span><span class="Code_Blue"><span class="koboSpan" id="kobo.102.1">image</span></span><span class="koboSpan" id="kobo.103.1">: networkop/cx:5.0.0
      </span><span class="Code_Blue"><span class="koboSpan" id="kobo.104.1">runtime</span></span><span class="koboSpan" id="kobo.105.1">: docker
  </span><span class="Code_Blue"><span class="koboSpan" id="kobo.106.1">links</span></span><span class="koboSpan" id="kobo.107.1">:
    - </span><span class="Code_Blue"><span class="koboSpan" id="kobo.108.1">endpoints</span></span><span class="koboSpan" id="kobo.109.1">: [</span><span class="Code_Red"><span class="koboSpan" id="kobo.110.1">"srl:e1-1"</span></span><span class="koboSpan" id="kobo.111.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.112.1">"ceos:eth1"</span></span><span class="koboSpan" id="kobo.113.1">]
    - </span><span class="Code_Blue"><span class="koboSpan" id="kobo.114.1">endpoints</span></span><span class="koboSpan" id="kobo.115.1">: [</span><span class="Code_Red"><span class="koboSpan" id="kobo.116.1">"cvx:swp1"</span></span><span class="koboSpan" id="kobo.117.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.118.1">"ceos:eth2"</span></span><span class="koboSpan" id="kobo.119.1">]</span></pre>
<p><span class="koboSpan" id="kobo.120.1">You can</span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.121.1"> find this YAML file, like the rest of the code examples, in this book’s GitHub repository, specifically in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">topo-base</span></strong><span class="koboSpan" id="kobo.123.1"> directory. </span><span class="koboSpan" id="kobo.123.2">If you go through the </span><em class="italic"><span class="koboSpan" id="kobo.124.1">Appendix</span></em><span class="koboSpan" id="kobo.125.1"> to learn more about Containerlab or you have it running already, you can bring up the entire lab with the </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.127.1">topo-base</span><span class="Code_Blue"><span class="koboSpan" id="kobo.128.1">$ sudo</span></span><span class="koboSpan" id="kobo.129.1"> containerlab deploy </span><span class="Code_Blue"><span class="koboSpan" id="kobo.130.1">-t</span></span><span class="koboSpan" id="kobo.131.1"> topo.yml </span><span class="Code_Blue"><span class="koboSpan" id="kobo.132.1">--reconfigure</span></span></pre>
<p><span class="koboSpan" id="kobo.133.1">Once the lab is up, you can access each device by its hostname using the credentials shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">following table:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-1">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.135.1">Device</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.136.1">Username</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.137.1">Password</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.138.1">clab-netgo-srl</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.139.1">admin</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.140.1">admin</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.141.1">clab-netgo-ceos</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.142.1">admin</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.143.1">admin</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.144.1">clab-netgo-cvx</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.145.1">cumulus</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.146.1">cumulus</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.147.1">Table 6.1 – Containerlab access credentials</span></p>
<p><span class="koboSpan" id="kobo.148.1">For example, to access NVIDIA’s device via SSH, you would execute </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">ssh cumulus@clab-netgo-cvx</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.151.1">⇨  </span><span class="Code_Blue"><span class="koboSpan" id="kobo.152.1">ssh </span></span><span class="koboSpan" id="kobo.153.1">cumulus@clab-netgo-cvx
cumulus@clab-netgo-cvx</span><span class="Code_Red"><span class="koboSpan" id="kobo.154.1">'s password: cumulus</span></span><span class="koboSpan" id="kobo.155.1">
Linux cvx 5.14.10-300.fc35.x86_64 </span><span class="Code_Brown"><span class="koboSpan" id="kobo.156.1">#1 SMP Thu Oct 7 20:48:44 UTC 2021 x86_64</span></span><span class="koboSpan" id="kobo.157.1">
Welcome to NVIDIA Cumulus (R) Linux (R)
cumulus@cvx:mgmt:~</span><span class="Code_Blue"><span class="koboSpan" id="kobo.158.1">$ exit</span></span></pre>
<p><span class="koboSpan" id="kobo.159.1">If you </span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.160.1">want to learn more about Containerlab or run this lab setup in the cloud, check out the instructions in the </span><em class="italic"><span class="koboSpan" id="kobo.161.1">Appendix</span></em><span class="koboSpan" id="kobo.162.1"> of </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">this book.</span></span></p>
<h1 id="_idParaDest-150"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.164.1">Interacting with network devices via SSH</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.165.1">Secure Shell</span></strong><span class="koboSpan" id="kobo.166.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.167.1">SSH</span></strong><span class="koboSpan" id="kobo.168.1">) is</span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.169.1"> the </span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.170.1">predominant protocol that network engineers use to securely access and configure network devices via a </span><strong class="bold"><span class="koboSpan" id="kobo.171.1">command-line interface</span></strong><span class="koboSpan" id="kobo.172.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.173.1">CLI</span></strong><span class="koboSpan" id="kobo.174.1">) that</span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.175.1"> transports unstructured data to display to end users. </span><span class="koboSpan" id="kobo.175.2">This interface simulates a computer terminal, so we’ve used it traditionally for </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">human interactions.</span></span></p>
<p><span class="koboSpan" id="kobo.177.1">One of</span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.178.1"> the first steps network engineers take when they embark on the journey of automating mundane tasks is to create scripts that run a set of CLI commands for them in sequence to achieve an outcome. </span><span class="koboSpan" id="kobo.178.2">Otherwise, they would run the commands themselves interactively via an </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">SSH pseudo-terminal.</span></span></p>
<p><span class="koboSpan" id="kobo.180.1">While this gives us speed, this is not the only benefit of network automation. </span><span class="koboSpan" id="kobo.180.2">As we cover different technologies through the rest of this book, other benefits, such as reliability, repeatability, and consistency, to name a few, become a common theme. </span><span class="koboSpan" id="kobo.180.3">For now, we will start by crafting an SSH connection to a network device in Go and send configuration commands line by line, to then take advantage of a higher-level package in Go that abstracts away the connection details of the different networking vendors, making the development experience simpler for </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">network engineers.</span></span></p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.182.1">Describing the network device configurations</span></h2>
<p><span class="koboSpan" id="kobo.183.1">The first</span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.184.1"> task we want to do with Go is to configure each of the devices of the three-node topology we defined in the preceding section. </span><span class="koboSpan" id="kobo.184.2">As a learning exercise, we will create three different Go programs to configure each device independently so that you can contrast the different approaches. </span><span class="koboSpan" id="kobo.184.3">While each program is unique, they all follow the same design structure. </span><span class="koboSpan" id="kobo.184.4">One program uses SSH to connect and configure a device, another one uses Scrapligo, and the last one uses HTTP, as we’ll cover in the </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">next section.</span></span></p>
<p><span class="koboSpan" id="kobo.186.1">To make the code examples meaningful, but at the same time not overly complicated, we have limited the device configurations to apply to the </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">following sections:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.188.1">A unique IPv4 address on each of the </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">transit links</span></span></li>
<li><span class="koboSpan" id="kobo.190.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.191.1">Border Gateway Protocol</span></strong><span class="koboSpan" id="kobo.192.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.193.1">BGP</span></strong><span class="koboSpan" id="kobo.194.1">) peering </span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.195.1">established between </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">those IPs</span></span></li>
<li><span class="koboSpan" id="kobo.197.1">A unique loopback address that is also redistributed </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">into BGP</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.199.1">The goal of these settings is to establish reachability between all three </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">loopback interfaces.</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">In real-life automation systems, developers strive to find a common data model you can use to represent device configurations for any vendor. </span><span class="koboSpan" id="kobo.201.2">The two main examples of this are IETF and OpenConfig YANG models. </span><span class="koboSpan" id="kobo.201.3">We will do the same in this case by defining a standard schema for the input data we will use for all three network devices but using Go directly to define the data structures instead of the YANG modeling language. </span><span class="koboSpan" id="kobo.201.4">This schema has just enough information to meet the goal of establishing </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">end-to-end reachability:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.203.1">type </span></span><span class="koboSpan" id="kobo.204.1">Model </span><span class="Code_Purple"><span class="koboSpan" id="kobo.205.1">struct </span></span><span class="koboSpan" id="kobo.206.1">{
    Uplinks  []Link </span><span class="Code_Red"><span class="koboSpan" id="kobo.207.1">`yaml:"uplinks"`</span></span><span class="koboSpan" id="kobo.208.1">
    Peers    []Peer </span><span class="Code_Red"><span class="koboSpan" id="kobo.209.1">`yaml:"peers"`</span></span><span class="koboSpan" id="kobo.210.1">
    ASN      </span><span class="Code_Purple"><span class="koboSpan" id="kobo.211.1">int</span></span><span class="koboSpan" id="kobo.212.1">    </span><span class="Code_Red"><span class="koboSpan" id="kobo.213.1">`yaml:"asn"`</span></span><span class="koboSpan" id="kobo.214.1">
    Loopback Addr   </span><span class="Code_Red"><span class="koboSpan" id="kobo.215.1">`yaml:"loopback"`</span></span><span class="koboSpan" id="kobo.216.1">
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.217.1">type </span></span><span class="koboSpan" id="kobo.218.1">Link </span><span class="Code_Purple"><span class="koboSpan" id="kobo.219.1">struct </span></span><span class="koboSpan" id="kobo.220.1">{
    Name   </span><span class="Code_Purple"><span class="koboSpan" id="kobo.221.1">string </span></span><span class="Code_Red"><span class="koboSpan" id="kobo.222.1">`yaml:"name"`</span></span><span class="koboSpan" id="kobo.223.1">
    Prefix </span><span class="Code_Purple"><span class="koboSpan" id="kobo.224.1">string </span></span><span class="Code_Red"><span class="koboSpan" id="kobo.225.1">`yaml:"prefix"`</span></span><span class="koboSpan" id="kobo.226.1">
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.227.1">type </span></span><span class="koboSpan" id="kobo.228.1">Peer </span><span class="Code_Purple"><span class="koboSpan" id="kobo.229.1">struct </span></span><span class="koboSpan" id="kobo.230.1">{
    IP  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.231.1">string</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.232.1">`yaml:"ip"`</span></span><span class="koboSpan" id="kobo.233.1">
    ASN </span><span class="Code_Purple"><span class="koboSpan" id="kobo.234.1">int</span></span><span class="koboSpan" id="kobo.235.1">    </span><span class="Code_Red"><span class="koboSpan" id="kobo.236.1">`yaml:"asn"`</span></span><span class="koboSpan" id="kobo.237.1">
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.238.1">type </span></span><span class="koboSpan" id="kobo.239.1">Addr </span><span class="Code_Purple"><span class="koboSpan" id="kobo.240.1">struct </span></span><span class="koboSpan" id="kobo.241.1">{
    IP </span><span class="Code_Purple"><span class="koboSpan" id="kobo.242.1">string </span></span><span class="Code_Red"><span class="koboSpan" id="kobo.243.1">`yaml:"ip"`</span></span><span class="koboSpan" id="kobo.244.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.245.1">In each of </span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.246.1">the programs, we supply the parameters to the data model to generate the device’s configuration via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">input.yml</span></strong><span class="koboSpan" id="kobo.248.1"> file, which is available in the program’s folder. </span><span class="koboSpan" id="kobo.248.2">For the first example, this file looks </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">as follows:</span></span></p>
<pre class="source-code"><span class="Code_Brown"><span class="koboSpan" id="kobo.250.1"># input.yml</span></span>
<span class="Code_Blue"><span class="koboSpan" id="kobo.251.1">asn</span></span><span class="koboSpan" id="kobo.252.1">: </span><span class="Code_Green"><span class="koboSpan" id="kobo.253.1">65000</span></span>
<span class="Code_Blue"><span class="koboSpan" id="kobo.254.1">loopback</span></span><span class="koboSpan" id="kobo.255.1">: 
  </span><span class="Code_Blue"><span class="koboSpan" id="kobo.256.1">ip</span></span><span class="koboSpan" id="kobo.257.1">: </span><span class="Code_Red"><span class="koboSpan" id="kobo.258.1">"198.51.100.0"</span></span>
<span class="Code_Blue"><span class="koboSpan" id="kobo.259.1">uplinks</span></span><span class="koboSpan" id="kobo.260.1">:
  - </span><span class="Code_Blue"><span class="koboSpan" id="kobo.261.1">name</span></span><span class="koboSpan" id="kobo.262.1">: </span><span class="Code_Red"><span class="koboSpan" id="kobo.263.1">"ethernet-1/1"</span></span><span class="koboSpan" id="kobo.264.1">
    </span><span class="Code_Blue"><span class="koboSpan" id="kobo.265.1">prefix</span></span><span class="koboSpan" id="kobo.266.1">: </span><span class="Code_Red"><span class="koboSpan" id="kobo.267.1">"192.0.2.0/31"</span></span>
<span class="Code_Blue"><span class="koboSpan" id="kobo.268.1">peers</span></span><span class="koboSpan" id="kobo.269.1">:
  - </span><span class="Code_Blue"><span class="koboSpan" id="kobo.270.1">ip</span></span><span class="koboSpan" id="kobo.271.1">: </span><span class="Code_Red"><span class="koboSpan" id="kobo.272.1">"192.0.2.1"</span></span><span class="koboSpan" id="kobo.273.1">
    </span><span class="Code_Blue"><span class="koboSpan" id="kobo.274.1">asn</span></span><span class="koboSpan" id="kobo.275.1">: </span><span class="Code_Green"><span class="koboSpan" id="kobo.276.1">65001</span></span></pre>
<p><span class="koboSpan" id="kobo.277.1">After we</span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.278.1"> open this file for reading, we deserialize this information into an instance of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">Model</span></strong><span class="koboSpan" id="kobo.280.1"> type – which represents the data model – with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">Decode</span></strong><span class="koboSpan" id="kobo.282.1"> method. </span><span class="koboSpan" id="kobo.282.2">The following output represents </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">these steps:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.284.1">func </span></span><span class="koboSpan" id="kobo.285.1">main() {
    src, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.286.1">=</span></span><span class="koboSpan" id="kobo.287.1"> os.Open(</span><span class="Code_Red"><span class="koboSpan" id="kobo.288.1">"input.yml"</span></span><span class="koboSpan" id="kobo.289.1">)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.290.1">// process error</span></span><span class="koboSpan" id="kobo.291.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.292.1">defer </span></span><span class="koboSpan" id="kobo.293.1">src.Close()
    d :</span><span class="Code_Red"><span class="koboSpan" id="kobo.294.1">=</span></span><span class="koboSpan" id="kobo.295.1"> yaml.NewDecoder(src)
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.296.1">var </span></span><span class="koboSpan" id="kobo.297.1">input Model
    err </span><span class="Code_Red"><span class="koboSpan" id="kobo.298.1">=</span></span><span class="koboSpan" id="kobo.299.1"> d.Decode(</span><span class="Code_Red"><span class="koboSpan" id="kobo.300.1">&amp;</span></span><span class="koboSpan" id="kobo.301.1">input)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.302.1">// process error</span></span><span class="koboSpan" id="kobo.303.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.304.1">Then, we pass the input variable (of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">Model</span></strong><span class="koboSpan" id="kobo.306.1"> type) to a config generator function (</span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">devConfig</span></strong><span class="koboSpan" id="kobo.308.1">), which transforms this information into syntax that the target device can understand. </span><span class="koboSpan" id="kobo.308.2">The result of this transformation is a vendor-specific configuration serialized into bytes that you can transfer to the </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">remote device.</span></span></p>
<p><span class="koboSpan" id="kobo.310.1">A transport library establishes the connection to the remote device using default credentials, which you can overwrite via command-line flags. </span><span class="koboSpan" id="kobo.310.2">The session we have created has an </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">io.Writer</span></strong><span class="koboSpan" id="kobo.312.1"> element that we can use to send the configuration to the </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">remote device:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer058">
<span class="koboSpan" id="kobo.314.1"><img alt="Figure 6.2 – Program structure" src="image/B16971_06_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.315.1">Figure 6.2 – Program structure</span></p>
<p><span class="koboSpan" id="kobo.316.1">Now that</span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.317.1"> we’re familiar with the structure of the program, let’s explore different implementations of it to learn more about the Go packages that are available to communicate with network devices, starting with SSH </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">and Scrapligo.</span></span></p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.319.1">Using Go’s SSH package to access network devices</span></h2>
<p><span class="koboSpan" id="kobo.320.1">The</span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.321.1"> first device from the topology that we are configuring is the containerized Nokia </span><strong class="bold"><span class="koboSpan" id="kobo.322.1">SR Linux</span></strong><span class="koboSpan" id="kobo.323.1">. </span><span class="koboSpan" id="kobo.323.2">Although</span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.324.1"> this NOS supports a variety of interfaces, including structured APIs such as gNMI and NETCONF, in this case, we are configuring it interactively via SSH, using the same commands that a human operator would use. </span><span class="koboSpan" id="kobo.324.2">We will execute these commands as a multi-line string, which we can craft using Go’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">text/template</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.326.1">template package.</span></span></p>
<p><span class="koboSpan" id="kobo.327.1">Go’s SSH package, </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">golang.org/x/crypto/ssh</span></strong><span class="koboSpan" id="kobo.329.1">, belongs to a set of packages that are still part of the Go project but developed outside the main Go tree under looser compatibility requirements. </span><span class="koboSpan" id="kobo.329.2">Although this is not the only SSH Go client, other packages tend to reuse parts of this package, so they become </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">higher-level abstractions.</span></span></p>
<p><span class="koboSpan" id="kobo.331.1">As described</span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.332.1"> in the general program design, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">Model</span></strong><span class="koboSpan" id="kobo.334.1"> data structure to hold the device configuration inputs and merge them with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">srlTemplate</span></strong><span class="koboSpan" id="kobo.336.1"> template to produce a valid device configuration as a buffer </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">of bytes:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.338.1">const </span></span><span class="koboSpan" id="kobo.339.1">srlTemplate =</span><span class="Code_Red"><span class="koboSpan" id="kobo.340.1"> `</span></span>
<span class="Code_Red"><span class="koboSpan" id="kobo.341.1">enter candidate</span></span>
<span class="Code_Red"><span class="koboSpan" id="kobo.342.1">{{- range $uplink := .Uplinks }}</span></span>
<span class="Code_Red"><span class="koboSpan" id="kobo.343.1">set / interface {{ $uplink.Name }} subinterface 0 ipv4 address {{ $uplink.Prefix }}</span></span>
<span class="Code_Red"><span class="koboSpan" id="kobo.344.1">set / network-instance default interface {{ $uplink.Name }}.0</span></span>
<span class="Code_Red"><span class="koboSpan" id="kobo.345.1">{{- end }}</span></span>
<span class="Code_Red"><span class="koboSpan" id="kobo.346.1">...</span></span>
<span class="Code_Red"><span class="koboSpan" id="kobo.347.1">`</span></span></pre>
<p><span class="koboSpan" id="kobo.348.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">srlTemplate</span></strong><span class="koboSpan" id="kobo.350.1"> constant has a template that starts by looping (using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">range</span></strong><span class="koboSpan" id="kobo.352.1"> keyword) over the uplinks of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">Model</span></strong><span class="koboSpan" id="kobo.354.1"> instance. </span><span class="koboSpan" id="kobo.354.2">For each </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">Link</span></strong><span class="koboSpan" id="kobo.356.1">, it takes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">Name</span></strong><span class="koboSpan" id="kobo.358.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">Prefix</span></strong><span class="koboSpan" id="kobo.360.1"> properties of it to create a couple of CLI commands we can place in a buffer. </span><span class="koboSpan" id="kobo.360.2">In the following code, we are running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">Execute</span></strong><span class="koboSpan" id="kobo.362.1"> method to pass the inputs via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">in</span></strong><span class="koboSpan" id="kobo.364.1"> variable and put the binary representation of interactive CLI commands on </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">b</span></strong><span class="koboSpan" id="kobo.366.1">, which we later expect to send to the remote </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">device (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">cfg</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">):</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.370.1">func </span></span><span class="koboSpan" id="kobo.371.1">devConfig(in Model)(b bytes.Buffer, err </span><span class="Code_Purple"><span class="koboSpan" id="kobo.372.1">error</span></span><span class="koboSpan" id="kobo.373.1">){
    t, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.374.1">=</span></span><span class="koboSpan" id="kobo.375.1"> template.New(</span><span class="Code_Red"><span class="koboSpan" id="kobo.376.1">"config"</span></span><span class="koboSpan" id="kobo.377.1">).Parse(srlTemplate)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.378.1">// process error</span></span><span class="koboSpan" id="kobo.379.1">
    err </span><span class="Code_Red"><span class="koboSpan" id="kobo.380.1">=</span></span><span class="koboSpan" id="kobo.381.1"> t.Execute(</span><span class="Code_Red"><span class="koboSpan" id="kobo.382.1">&amp;</span></span><span class="koboSpan" id="kobo.383.1">b, in)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.384.1">// process error</span></span><span class="koboSpan" id="kobo.385.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.386.1">return </span></span><span class="koboSpan" id="kobo.387.1">b, </span><span class="Code_Blue"><span class="koboSpan" id="kobo.388.1">nil</span></span><span class="koboSpan" id="kobo.389.1">
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.390.1">func </span></span><span class="koboSpan" id="kobo.391.1">main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.392.1">/* ... </span><span class="koboSpan" id="kobo.392.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.392.3">*/</span></span><span class="koboSpan" id="kobo.393.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.394.1">var </span></span><span class="koboSpan" id="kobo.395.1">input Model
    err </span><span class="Code_Red"><span class="koboSpan" id="kobo.396.1">=</span></span><span class="koboSpan" id="kobo.397.1"> d.Decode(</span><span class="Code_Red"><span class="koboSpan" id="kobo.398.1">&amp;</span></span><span class="koboSpan" id="kobo.399.1">input)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.400.1">// process error</span></span><span class="koboSpan" id="kobo.401.1">
    cfg, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.402.1">=</span></span><span class="koboSpan" id="kobo.403.1"> devConfig(input)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.404.1">/* ... </span><span class="koboSpan" id="kobo.404.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.404.3">*/</span></span><span class="koboSpan" id="kobo.405.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.406.1">We</span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.407.1"> have hardcoded the authentication credentials to the correct values to fit the lab, but you can override them if necessary. </span><span class="koboSpan" id="kobo.407.2">We use these arguments to establish initial connectivity with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">srl</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.409.1">network device:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.410.1">func </span></span><span class="koboSpan" id="kobo.411.1">main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.412.1">/* ... </span><span class="koboSpan" id="kobo.412.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.412.3">*/</span></span><span class="koboSpan" id="kobo.413.1">
    settings :</span><span class="Code_Red"><span class="koboSpan" id="kobo.414.1">=</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.415.1">&amp;</span></span><span class="koboSpan" id="kobo.416.1">ssh.ClientConfig{
        User: *username,
        Auth: []ssh.AuthMethod{
            ssh.Password(*password),
        },
        HostKeyCallback: ssh.InsecureIgnoreHostKey(),
    }
    conn, err := ssh.Dial(
        </span><span class="Code_Red"><span class="koboSpan" id="kobo.417.1">"tcp"</span></span><span class="koboSpan" id="kobo.418.1">,
        fmt.Sprintf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.419.1">"%s:%d"</span></span><span class="koboSpan" id="kobo.420.1">, *hostname, sshPort),
        settings,
    )
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.421.1">// process error</span></span><span class="koboSpan" id="kobo.422.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.423.1">defer </span></span><span class="koboSpan" id="kobo.424.1">conn.Close()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.425.1">/* ... </span><span class="koboSpan" id="kobo.425.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.425.3">*/</span></span><span class="koboSpan" id="kobo.426.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.427.1">If the </span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.428.1">authentication credentials are correct and there are no connectivity problems, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">ssh.Dial</span></strong><span class="koboSpan" id="kobo.430.1"> function returns a connection handler (</span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">conn</span></strong><span class="koboSpan" id="kobo.432.1">), representing a single SSH connection. </span><span class="koboSpan" id="kobo.432.2">This connection acts as a single transport for potentially various channels. </span><span class="koboSpan" id="kobo.432.3">One such channel is a pseudo-terminal session used for interactive communication with the remote device, but it may also include extra channels that you can use for </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">port forwarding.</span></span></p>
<p><span class="koboSpan" id="kobo.434.1">The following code snippet spawns a new terminal session and sets the expected terminal parameters, such as terminal</span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.435.1"> height, width, and </span><strong class="bold"><span class="koboSpan" id="kobo.436.1">TeleTYpe</span></strong><span class="koboSpan" id="kobo.437.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.438.1">TTY</span></strong><span class="koboSpan" id="kobo.439.1">) speed. </span><span class="koboSpan" id="kobo.439.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">ssh.Session</span></strong><span class="koboSpan" id="kobo.441.1"> type provides functions to retrieve standard input and standard output pipes that connect to the </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">remote terminal:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.443.1">func </span></span><span class="koboSpan" id="kobo.444.1">main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.445.1">/* ... </span><span class="koboSpan" id="kobo.445.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.445.3">*/</span></span><span class="koboSpan" id="kobo.446.1">
    session, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.447.1">=</span></span><span class="koboSpan" id="kobo.448.1"> conn.NewSession()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.449.1">// process error</span></span><span class="koboSpan" id="kobo.450.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.451.1">defer </span></span><span class="koboSpan" id="kobo.452.1">session.Close()
    modes :</span><span class="Code_Red"><span class="koboSpan" id="kobo.453.1">=</span></span><span class="koboSpan" id="kobo.454.1"> ssh.TerminalModes{
        ssh.ECHO:          1,
        ssh.TTY_OP_ISPEED: </span><span class="Code_Green"><span class="koboSpan" id="kobo.455.1">115200</span></span><span class="koboSpan" id="kobo.456.1">,
        ssh.TTY_OP_OSPEED: </span><span class="Code_Green"><span class="koboSpan" id="kobo.457.1">115200</span></span><span class="koboSpan" id="kobo.458.1">,
    }
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.459.1">if </span></span><span class="koboSpan" id="kobo.460.1">err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.461.1">=</span></span><span class="koboSpan" id="kobo.462.1"> session.RequestPty(</span><span class="Code_Red"><span class="koboSpan" id="kobo.463.1">"xterm"</span></span><span class="koboSpan" id="kobo.464.1">, </span><span class="Code_Green"><span class="koboSpan" id="kobo.465.1">40</span></span><span class="koboSpan" id="kobo.466.1">, </span><span class="Code_Green"><span class="koboSpan" id="kobo.467.1">80</span></span><span class="koboSpan" id="kobo.468.1">, modes); err </span><span class="Code_Red"><span class="koboSpan" id="kobo.469.1">!=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.470.1">nil </span></span><span class="koboSpan" id="kobo.471.1">{
        log.Fatal(</span><span class="Code_Red"><span class="koboSpan" id="kobo.472.1">"request for pseudo terminal failed: "</span></span><span class="koboSpan" id="kobo.473.1">, err)
    }
    stdin, err := session.StdinPipe()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.474.1">// process error</span></span><span class="koboSpan" id="kobo.475.1">
    stdout, err := session.StdoutPipe()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.476.1">// process error</span></span><span class="koboSpan" id="kobo.477.1">
    session.Shell()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.478.1">/* ... </span><span class="koboSpan" id="kobo.478.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.478.3">*/</span></span><span class="koboSpan" id="kobo.479.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.480.1">In</span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.481.1"> conformance with the rest of the Go packages, standard input and standard output pipes implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">io.Writer</span></strong><span class="koboSpan" id="kobo.483.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">io.Reader</span></strong><span class="koboSpan" id="kobo.485.1"> interfaces, respectively. </span><span class="koboSpan" id="kobo.485.2">This means you can use them to write data in to and read output from the remote network device. </span><span class="koboSpan" id="kobo.485.3">We will go back to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">cfg</span></strong><span class="koboSpan" id="kobo.487.1"> buffer with the CLI config and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">WriteTo</span></strong><span class="koboSpan" id="kobo.489.1"> method to send this config over to the </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">target node:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.491.1">func </span></span><span class="koboSpan" id="kobo.492.1">main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.493.1">/* ... </span><span class="koboSpan" id="kobo.493.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.493.3">*/</span></span><span class="koboSpan" id="kobo.494.1">
    log.Print(</span><span class="Code_Red"><span class="koboSpan" id="kobo.495.1">"connected. </span><span class="koboSpan" id="kobo.495.2">configuring..."</span></span><span class="koboSpan" id="kobo.496.1">)
    cfg.WriteTo(stdin)
}</span></pre>
<p><span class="koboSpan" id="kobo.497.1">This is the</span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.498.1"> expected output of </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">this program:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.500.1">ch06/ssh</span><span class="Code_Blue"><span class="koboSpan" id="kobo.501.1">$ go</span></span><span class="koboSpan" id="kobo.502.1"> run main.go 
go: downloading golang.org/x/crypto v0.0.0-20220112180741-5e0467b6c7ce
go: downloading gopkg.in/yaml.v2 v2.4.0
</span><span class="Code_Green"><span class="koboSpan" id="kobo.503.1">2022</span></span><span class="koboSpan" id="kobo.504.1">/02/07 </span><span class="Code_Green"><span class="koboSpan" id="kobo.505.1">21</span></span><span class="koboSpan" id="kobo.506.1">:11:44 connected. </span><span class="koboSpan" id="kobo.506.2">configuring...
</span><span class="Code_Green"><span class="koboSpan" id="kobo.507.1">2022</span></span><span class="koboSpan" id="kobo.508.1">/02/07 </span><span class="Code_Green"><span class="koboSpan" id="kobo.509.1">21</span></span><span class="koboSpan" id="kobo.510.1">:11:44 disconnected. </span><span class="koboSpan" id="kobo.510.2">dumping output...
</span><span class="koboSpan" id="kobo.510.3">enter candidate
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.511.1">set </span></span><span class="koboSpan" id="kobo.512.1">/ interface ethernet-1/1 subinterface </span><span class="Code_Green"><span class="koboSpan" id="kobo.513.1">0</span></span><span class="koboSpan" id="kobo.514.1"> ipv4 address </span><span class="Code_Green"><span class="koboSpan" id="kobo.515.1">192</span></span><span class="koboSpan" id="kobo.516.1">.0.2.0/31
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.517.1">set </span></span><span class="koboSpan" id="kobo.518.1">/ network-instance default interface ethernet-1/1.0
...
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.519.1">set </span></span><span class="koboSpan" id="kobo.520.1">/ network-instance default protocols bgp ipv4-unicast admin-state enable
commit now
quit
Using configuration file(s): []
Welcome to the srlinux CLI.
</span><span class="koboSpan" id="kobo.520.2">Type </span><span class="Code_Red"><span class="koboSpan" id="kobo.521.1">'help'</span></span><span class="koboSpan" id="kobo.522.1"> (and press &lt;ENTER&gt;) </span><span class="Code_Purple"><span class="koboSpan" id="kobo.523.1">if </span></span><span class="koboSpan" id="kobo.524.1">you need any help using this.
</span><span class="Code_Blue"><span class="koboSpan" id="kobo.525.1">--</span></span><span class="koboSpan" id="kobo.526.1">{ running }--[  ]--                                                           
A:srl</span><span class="Code_Brown"><span class="koboSpan" id="kobo.527.1">#</span></span><span class="koboSpan" id="kobo.528.1">                                                                          
</span><span class="Code_Blue"><span class="koboSpan" id="kobo.529.1">--</span></span><span class="koboSpan" id="kobo.530.1">{ running }--[  ]--                                                           
A:srl</span><span class="Code_Brown"><span class="koboSpan" id="kobo.531.1"># enter candidate</span></span><span class="koboSpan" id="kobo.532.1">                                                          
</span><span class="Code_Blue"><span class="koboSpan" id="kobo.533.1">--</span></span><span class="koboSpan" id="kobo.534.1">{ candidate shared default }--[  ]--                                          
A:srl</span><span class="Code_Brown"><span class="koboSpan" id="kobo.535.1"># set / interface ethernet-1/1 subinterface 0 ipv4 address 192.0.2.0/31</span></span><span class="koboSpan" id="kobo.536.1">    
</span><span class="Code_Blue"><span class="koboSpan" id="kobo.537.1">--</span></span><span class="koboSpan" id="kobo.538.1">{ * candidate shared default }--[  ]-- 
.......                                
</span><span class="Code_Blue"><span class="koboSpan" id="kobo.539.1">--</span></span><span class="koboSpan" id="kobo.540.1">{ * candidate shared default }--[  ]--                                        
A:srl</span><span class="Code_Brown"><span class="koboSpan" id="kobo.541.1"># commit now</span></span><span class="koboSpan" id="kobo.542.1">                                                               
All changes have been committed. </span><span class="koboSpan" id="kobo.542.2">Leaving candidate mode.
</span><span class="Code_Blue"><span class="koboSpan" id="kobo.543.1">--</span></span><span class="koboSpan" id="kobo.544.1">{ + running }--[  ]--                                                         
A:srl</span><span class="Code_Brown"><span class="koboSpan" id="kobo.545.1"># quit</span></span></pre>
<p><span class="koboSpan" id="kobo.546.1">You can</span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.547.1"> find the complete example in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">ch06/ssh</span></strong><span class="koboSpan" id="kobo.549.1"> folder (</span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.550.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">).</span></span></p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.552.1">Automating routine SSH tasks</span></h2>
<p><span class="koboSpan" id="kobo.553.1">Common</span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.554.1"> network elements, such as routers and switches, display data for people rather than computers via the CLI. </span><span class="koboSpan" id="kobo.554.2">We rely on screen scraping to let our programs consume this human-readable data. </span><span class="koboSpan" id="kobo.554.3">One popular screen-scraping Python library, whose name comes from </span><em class="italic"><span class="koboSpan" id="kobo.555.1">scrape cli</span></em><span class="koboSpan" id="kobo.556.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">is Scrapli.</span></span></p>
<p><span class="koboSpan" id="kobo.558.1">Scrapli has a version in Go, which we will explore in the following example, called Scrapligo. </span><span class="koboSpan" id="kobo.558.2">The goal of this package is to offer the next layer of abstraction on top of SSH and hide away some transport complexities while providing several convenient functions and supporting the CLI flavors of different </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">networking vendors.</span></span></p>
<p><span class="koboSpan" id="kobo.560.1">To show </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">scrapligo</span></strong><span class="koboSpan" id="kobo.562.1"> in action, we will configure another network device in the topology: Arista’s cEOS (</span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">ceos</span></strong><span class="koboSpan" id="kobo.564.1">). </span><span class="koboSpan" id="kobo.564.2">Just like we did with </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">srl</span></strong><span class="koboSpan" id="kobo.566.1">, we will use a list of CLI commands to push the desired network state so that the initial steps of parsing and instantiating a string from a template are the same. </span><span class="koboSpan" id="kobo.566.2">What changes is the template, which uses Arista </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">EOS’s syntax:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.568.1">const </span></span><span class="koboSpan" id="kobo.569.1">ceosTemplate = </span><span class="Code_Red"><span class="koboSpan" id="kobo.570.1">`</span></span>
<span class="Code_Red"><span class="koboSpan" id="kobo.571.1">...</span></span>
<span class="Code_Red"><span class="koboSpan" id="kobo.572.1">!</span></span>
<span class="Code_Red"><span class="koboSpan" id="kobo.573.1">router bgp {{ .ASN }}</span></span>
<span class="Code_Red"><span class="koboSpan" id="kobo.574.1">  router-id {{ .Loopback.IP }}</span></span>
<span class="Code_Red"><span class="koboSpan" id="kobo.575.1">{{- range $peer := .Peers }}  </span></span>
<span class="Code_Red"><span class="koboSpan" id="kobo.576.1">  neighbor {{ $peer.IP }} remote-as {{ $peer.ASN }}</span></span>
<span class="Code_Red"><span class="koboSpan" id="kobo.577.1">{{- end }}</span></span>
<span class="Code_Red"><span class="koboSpan" id="kobo.578.1">  redistribute connected</span></span>
<span class="Code_Red"><span class="koboSpan" id="kobo.579.1">!</span></span>
<span class="Code_Red"><span class="koboSpan" id="kobo.580.1">`</span></span></pre>
<p><span class="koboSpan" id="kobo.581.1">The</span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.582.1"> difference starts when we get to the SSH connection setup. </span><span class="koboSpan" id="kobo.582.2">We create a device driver (</span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">GetNetworkDriver</span></strong><span class="koboSpan" id="kobo.584.1">) to connect to the remote device with the device hostname and authentication credentials. </span><span class="koboSpan" id="kobo.584.2">The platform definition comes from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">platform</span></strong><span class="koboSpan" id="kobo.586.1"> package of </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">scrapligo</span></strong><span class="koboSpan" id="kobo.588.1">. </span><span class="koboSpan" id="kobo.588.2">From then on, it only takes a single method call on this driver to open an SSH connection to the </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">remote device:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.590.1">func </span></span><span class="koboSpan" id="kobo.591.1">main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.592.1">/* ... </span><span class="koboSpan" id="kobo.592.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.592.3">*/</span></span><span class="koboSpan" id="kobo.593.1">
    conn, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.594.1">=</span></span><span class="koboSpan" id="kobo.595.1"> platform.NewPlatform(
        *nos,
        *hostname,
        options.WithAuthNoStrictKey(),
        options.WithAuthUsername(*username),
        options.WithAuthPassword(*password),
    )
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.596.1">// process error  </span></span><span class="koboSpan" id="kobo.597.1">
    driver, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.598.1">=</span></span><span class="koboSpan" id="kobo.599.1"> conn.GetNetworkDriver()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.600.1">// process error  </span></span><span class="koboSpan" id="kobo.601.1">
 
    err </span><span class="Code_Red"><span class="koboSpan" id="kobo.602.1">=</span></span><span class="koboSpan" id="kobo.603.1"> driver.Open()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.604.1">// process error  </span></span><span class="koboSpan" id="kobo.605.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.606.1">defer </span></span><span class="koboSpan" id="kobo.607.1">driver.Close()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.608.1">/* ... </span><span class="koboSpan" id="kobo.608.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.608.3">*/</span></span><span class="koboSpan" id="kobo.609.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.610.1">One of </span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.611.1">the extra features that </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">scrapli</span></strong><span class="koboSpan" id="kobo.613.1"> offers is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">cscrapligocfg</span></strong><span class="koboSpan" id="kobo.615.1"> package, which defines a high-level API to work with a remote network device’s configuration. </span><span class="koboSpan" id="kobo.615.2">This API understands different CLI flavors, it can sanitize a configuration before sending it to the device, and it can generate configuration diffs for us. </span><span class="koboSpan" id="kobo.615.3">But, most importantly, this package allows for a single function call to load the entire device configuration as a string, taking care of things such as privilege escalation and configuration merging or replacement. </span><span class="koboSpan" id="kobo.615.4">We will do this here with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">LoadConfig</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.617.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.618.1">func main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.619.1">/* ... </span><span class="koboSpan" id="kobo.619.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.619.3">*/</span></span><span class="koboSpan" id="kobo.620.1">
    conf, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.621.1">=</span></span><span class="koboSpan" id="kobo.622.1"> cfg.NewCfg(driver, *nos)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.623.1">// process error</span></span><span class="koboSpan" id="kobo.624.1">
 
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.625.1">// sanitize config by removing keywords like "!" </span><span class="koboSpan" id="kobo.625.2">and "end"</span></span><span class="koboSpan" id="kobo.626.1">
    err </span><span class="Code_Red"><span class="koboSpan" id="kobo.627.1">=</span></span><span class="koboSpan" id="kobo.628.1"> conf.Prepare()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.629.1">// process error</span></span><span class="koboSpan" id="kobo.630.1">
 
    response, err </span><span class="Code_Red"><span class="koboSpan" id="kobo.631.1">=</span></span><span class="koboSpan" id="kobo.632.1"> conf.LoadConfig(config.String(), </span><span class="Code_Blue"><span class="koboSpan" id="kobo.633.1">false</span></span><span class="koboSpan" id="kobo.634.1">)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.635.1">// process error</span></span><span class="koboSpan" id="kobo.636.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.637.1">These are all the steps you need to configure the device in this case. </span><span class="koboSpan" id="kobo.637.2">After you run the program with </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">go run</span></strong><span class="koboSpan" id="kobo.639.1">, you can </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">ssh</span></strong><span class="koboSpan" id="kobo.641.1"> to the device to check that the configuration is </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">now there:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.643.1">ch06/scrapli</span><span class="Code_Blue"><span class="koboSpan" id="kobo.644.1">$ go</span></span><span class="koboSpan" id="kobo.645.1"> run main.go 
2022/02/14 17:06:16 Generated config: 
!
</span><span class="koboSpan" id="kobo.645.2">configure
!
</span><span class="koboSpan" id="kobo.645.3">ip routing
!
</span><span class="koboSpan" id="kobo.645.4">interface Ethernet1
  no switchport
  ip address </span><span class="Code_Green"><span class="koboSpan" id="kobo.646.1">192</span></span><span class="koboSpan" id="kobo.647.1">.0.2.1/31
!
</span><span class="koboSpan" id="kobo.647.2">...</span></pre>
<p><span class="koboSpan" id="kobo.648.1">Normally, to </span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.649.1">get a response coming back from a device, we need to read the response buffer carefully until we see a command-line prompt, as it normally ends with</span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.650.1"> an </span><strong class="bold"><span class="koboSpan" id="kobo.651.1">end-of-file</span></strong><span class="koboSpan" id="kobo.652.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.653.1">EOF</span></strong><span class="koboSpan" id="kobo.654.1">). </span><span class="koboSpan" id="kobo.654.2">Although we don’t show it here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">scrapligo</span></strong><span class="koboSpan" id="kobo.656.1"> can do this for us by reading the received buffer and converting the response into </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">a string.</span></span></p>
<p><span class="koboSpan" id="kobo.658.1">Another popular Go SSH package that provides a high-level API to execute commands at scale is </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">yahoo/vssh</span></strong><span class="koboSpan" id="kobo.660.1">. </span><span class="koboSpan" id="kobo.660.2">We won’t cover it here, but you can find an example in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">ch06/vssh</span></strong><span class="koboSpan" id="kobo.662.1"> directory of this book’s repository (</span><em class="italic"><span class="koboSpan" id="kobo.663.1">Further reading</span></em><span class="koboSpan" id="kobo.664.1">) to configure the network devices of </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">the topology.</span></span></p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.666.1">Interacting with network devices via HTTP</span></h1>
<p><span class="koboSpan" id="kobo.667.1">Over the</span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.668.1"> last decade, networking vendors have begun to include </span><strong class="bold"><span class="koboSpan" id="kobo.669.1">application programming interfaces</span></strong><span class="koboSpan" id="kobo.670.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.671.1">APIs</span></strong><span class="koboSpan" id="kobo.672.1">) to </span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.673.1">manage their devices as a supplement to the CLI. </span><span class="koboSpan" id="kobo.673.2">It’s not uncommon to find network devices with a robust RESTful API that gives you read and write access </span><span class="No-Break"><span class="koboSpan" id="kobo.674.1">to it.</span></span></p>
<p><span class="koboSpan" id="kobo.675.1">A RESTful API is a stateless client-server communication architecture that runs over HTTP. </span><span class="koboSpan" id="kobo.675.2">The request and responses generally transport structured data (JSON, XML, and so on), but they might as well carry plain text. </span><span class="koboSpan" id="kobo.675.3">This makes the RESTful API a better-suited interface for </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">machine-to-machine interactions.</span></span></p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.677.1">Using Go’s HTTP package to access network devices</span></h2>
<p><span class="koboSpan" id="kobo.678.1">The remaining</span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.679.1"> device to configure is NVIDIA’s Cumulus Linux (</span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">cvx</span></strong><span class="koboSpan" id="kobo.681.1">). </span><span class="koboSpan" id="kobo.681.2">We will use its OpenAPI-based RESTful API to configure it. </span><span class="koboSpan" id="kobo.681.3">We will encode the configuration in a JSON message and send it over an HTTP connection with Go’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">net/http</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.683.1"> package.</span></span></p>
<p><span class="koboSpan" id="kobo.684.1">As in the SSH examples, we normally load the input data and transform it into the shape the target device expects with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">devConfig</span></strong><span class="koboSpan" id="kobo.686.1"> function, but in this case, it’s a JSON payload. </span><span class="koboSpan" id="kobo.686.2">Because of this, we no longer need templates to build the network device configuration, as we can now use data structures in Go to encode and decode data from JSON or any other </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">encoding format.</span></span></p>
<p><span class="koboSpan" id="kobo.688.1">The data structures represent the configuration data model of the target device. </span><span class="koboSpan" id="kobo.688.2">Ideally, this data model would match the one we defined previously, so we don’t need to define anything else. </span><span class="koboSpan" id="kobo.688.3">But that’s not what we see in the field, where all the network vendors have proprietary data models. </span><span class="koboSpan" id="kobo.688.4">The good news is that both IETF and OpenConfig offer vendor-agnostic models; we’ll explore these later in </span><a href="B16971_08.xhtml#_idTextAnchor182"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.689.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.690.1">, </span><em class="italic"><span class="koboSpan" id="kobo.691.1">Network APIs</span></em><span class="koboSpan" id="kobo.692.1">. </span><span class="koboSpan" id="kobo.692.2">For now, these are some of the data structures we will use for this </span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">device’s configuration:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.694.1">type </span></span><span class="koboSpan" id="kobo.695.1">router </span><span class="Code_Purple"><span class="koboSpan" id="kobo.696.1">struct </span></span><span class="koboSpan" id="kobo.697.1">{
    Bgp
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.698.1">type </span></span><span class="koboSpan" id="kobo.699.1">bgp </span><span class="Code_Purple"><span class="koboSpan" id="kobo.700.1">struct </span></span><span class="koboSpan" id="kobo.701.1">{
    ASN      </span><span class="Code_Purple"><span class="koboSpan" id="kobo.702.1">int</span></span><span class="koboSpan" id="kobo.703.1">
    RouterID </span><span class="Code_Purple"><span class="koboSpan" id="kobo.704.1">string</span></span><span class="koboSpan" id="kobo.705.1">
    AF       </span><span class="Code_Purple"><span class="koboSpan" id="kobo.706.1">map</span></span><span class="koboSpan" id="kobo.707.1">[</span><span class="Code_Purple"><span class="koboSpan" id="kobo.708.1">string</span></span><span class="koboSpan" id="kobo.709.1">]addressFamily
    Enabled  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.710.1">string</span></span><span class="koboSpan" id="kobo.711.1">
    Neighbor </span><span class="Code_Purple"><span class="koboSpan" id="kobo.712.1">map</span></span><span class="koboSpan" id="kobo.713.1">[</span><span class="Code_Purple"><span class="koboSpan" id="kobo.714.1">string</span></span><span class="koboSpan" id="kobo.715.1">]neighbor
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.716.1">type </span></span><span class="koboSpan" id="kobo.717.1">neighbor </span><span class="Code_Purple"><span class="koboSpan" id="kobo.718.1">struct </span></span><span class="koboSpan" id="kobo.719.1">{
    RemoteAS </span><span class="Code_Purple"><span class="koboSpan" id="kobo.720.1">int</span></span><span class="koboSpan" id="kobo.721.1">
    Type     </span><span class="Code_Purple"><span class="koboSpan" id="kobo.722.1">string</span></span><span class="koboSpan" id="kobo.723.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.724.1">Inside </span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.725.1">the main function, we parse the program flags and use them to store the HTTP connection settings inside a data structure with all the details required to build an HTTP request, including any non-default transport settings for an HTTP client. </span><span class="koboSpan" id="kobo.725.2">We do this entirely for convenience purposes as we want to pass these details to </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">different functions:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.727.1">type </span></span><span class="koboSpan" id="kobo.728.1">cvx </span><span class="Code_Purple"><span class="koboSpan" id="kobo.729.1">struct </span></span><span class="koboSpan" id="kobo.730.1">{
    url   </span><span class="Code_Purple"><span class="koboSpan" id="kobo.731.1">string</span></span><span class="koboSpan" id="kobo.732.1">
    token </span><span class="Code_Purple"><span class="koboSpan" id="kobo.733.1">string</span></span><span class="koboSpan" id="kobo.734.1">
    httpC http.Client
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.735.1">func </span></span><span class="koboSpan" id="kobo.736.1">main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.737.1">/* ... </span><span class="koboSpan" id="kobo.737.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.737.3">*/</span></span><span class="koboSpan" id="kobo.738.1">
    device :</span><span class="Code_Red"><span class="koboSpan" id="kobo.739.1">=</span></span><span class="koboSpan" id="kobo.740.1"> cvx{
        url:   fmt.Sprintf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.741.1">"https://%s:%d"</span></span><span class="koboSpan" id="kobo.742.1">, *hostname, defaultNVUEPort),
        token: base64.StdEncoding.EncodeToString([]</span><span class="Code_Purple"><span class="koboSpan" id="kobo.743.1">byte</span></span><span class="koboSpan" id="kobo.744.1">(fmt.Sprintf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.745.1">"%s:%s</span></span><span class="koboSpan" id="kobo.746.1">", *username, *password))),
        httpC: http.Client{
            Transport: </span><span class="Code_Red"><span class="koboSpan" id="kobo.747.1">&amp;</span></span><span class="koboSpan" id="kobo.748.1">http.Transport{
                TLSClientConfig: </span><span class="Code_Red"><span class="koboSpan" id="kobo.749.1">&amp;</span></span><span class="koboSpan" id="kobo.750.1">tls.Config{InsecureSkipVerify: </span><span class="Code_Blue"><span class="koboSpan" id="kobo.751.1">true</span></span><span class="koboSpan" id="kobo.752.1">},
            },
        },
    }
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.753.1">/* ... </span><span class="koboSpan" id="kobo.753.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.753.3">*/</span></span><span class="koboSpan" id="kobo.754.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.755.1">Now, we</span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.756.1"> can send the configuration over and make it a candidate config on the target device. </span><span class="koboSpan" id="kobo.756.2">We can later apply this configuration on the device by referencing the revision ID we associate our desired configuration with. </span><span class="koboSpan" id="kobo.756.3">Let’s look at the steps to do this that showcase different attributes to consider when working </span><span class="No-Break"><span class="koboSpan" id="kobo.757.1">with HTTP.</span></span></p>
<p><span class="koboSpan" id="kobo.758.1">First, we will create a new revision ID, which we include as a query parameter </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">(?rev=&lt;revisionID&gt;</span></strong><span class="koboSpan" id="kobo.760.1">) in the URL to connect to the device API. </span><span class="koboSpan" id="kobo.760.2">Now, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">addr</span></strong><span class="koboSpan" id="kobo.762.1"> is variable the target device URL that contains </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">device hostname</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.764.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">revisionID</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.766.1">:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.767.1">func </span></span><span class="koboSpan" id="kobo.768.1">main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.769.1">/* ... </span><span class="koboSpan" id="kobo.769.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.769.3">*/</span></span><span class="koboSpan" id="kobo.770.1">
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.771.1">// create a new candidate configuration revision</span></span><span class="koboSpan" id="kobo.772.1">
    revisionID, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.773.1">=</span></span><span class="koboSpan" id="kobo.774.1"> createRevision(device)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.775.1">// process error</span></span><span class="koboSpan" id="kobo.776.1">
    addr, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.777.1">=</span></span><span class="koboSpan" id="kobo.778.1"> url.Parse(device.url + </span><span class="Code_Red"><span class="koboSpan" id="kobo.779.1">"/nvue_v1/"</span></span><span class="koboSpan" id="kobo.780.1">)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.781.1">// process error</span></span><span class="koboSpan" id="kobo.782.1">
    params :</span><span class="Code_Red"><span class="koboSpan" id="kobo.783.1">=</span></span><span class="koboSpan" id="kobo.784.1"> url.Values{}
    params.Add(</span><span class="Code_Red"><span class="koboSpan" id="kobo.785.1">"rev"</span></span><span class="koboSpan" id="kobo.786.1">, revisionID)
    addr.RawQuery </span><span class="Code_Red"><span class="koboSpan" id="kobo.787.1">=</span></span><span class="koboSpan" id="kobo.788.1"> params.Encode()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.789.1">/* ... </span><span class="koboSpan" id="kobo.789.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.789.3">*/</span></span><span class="koboSpan" id="kobo.790.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.791.1">With the</span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.792.1"> URL linked to the revision ID, we put together the PATCH request for the configuration change. </span><span class="koboSpan" id="kobo.792.2">This points to </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">addr</span></strong><span class="koboSpan" id="kobo.794.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">cfg</span></strong><span class="koboSpan" id="kobo.796.1">, which is the JSON device configuration that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">devConfig</span></strong><span class="koboSpan" id="kobo.798.1"> function returns. </span><span class="koboSpan" id="kobo.798.2">We also add an HTTP </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">Authorization</span></strong><span class="koboSpan" id="kobo.800.1"> header with the encoded username and password and signal that the payload is a </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">JSON message:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.802.1">func </span></span><span class="koboSpan" id="kobo.803.1">main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.804.1">/* ... </span><span class="koboSpan" id="kobo.804.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.804.3">*/</span></span><span class="koboSpan" id="kobo.805.1">
    req, err := http.NewRequest(</span><span class="Code_Red"><span class="koboSpan" id="kobo.806.1">"PATCH"</span></span><span class="koboSpan" id="kobo.807.1">, addr.String(), </span><span class="Code_Red"><span class="koboSpan" id="kobo.808.1">&amp;</span></span><span class="koboSpan" id="kobo.809.1">cfg)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.810.1">// process error</span></span><span class="koboSpan" id="kobo.811.1">
    req.Header.Add(</span><span class="Code_Red"><span class="koboSpan" id="kobo.812.1">"Content-Type"</span></span><span class="koboSpan" id="kobo.813.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.814.1">"application/json"</span></span><span class="koboSpan" id="kobo.815.1">)
    req.Header.Add(</span><span class="Code_Red"><span class="koboSpan" id="kobo.816.1">"Authorization"</span></span><span class="koboSpan" id="kobo.817.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.818.1">"Basic "+</span></span><span class="koboSpan" id="kobo.819.1">device.token)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.820.1">/* ... </span><span class="koboSpan" id="kobo.820.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.820.3">*/</span></span><span class="koboSpan" id="kobo.821.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.822.1">Once we have the HTTP request built, we can pass it to the device HTTP client’s method, </span><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">Do</span></strong><span class="koboSpan" id="kobo.824.1">, which serializes everything into a binary format, sets up a TCP session, and sends the HTTP request </span><span class="No-Break"><span class="koboSpan" id="kobo.825.1">over it.</span></span></p>
<p><span class="koboSpan" id="kobo.826.1">Finally, to apply the candidate configuration changes, we must make another PATCH request inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.827.1">applyRevision</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.828.1"> function:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.829.1">func </span></span><span class="koboSpan" id="kobo.830.1">main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.831.1">/* ... </span><span class="koboSpan" id="kobo.831.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.831.3">*/</span></span><span class="koboSpan" id="kobo.832.1">
    res, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.833.1">=</span></span><span class="koboSpan" id="kobo.834.1"> device.httpC.Do(req)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.835.1">// process error</span></span><span class="koboSpan" id="kobo.836.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.837.1">defer </span></span><span class="koboSpan" id="kobo.838.1">res.Body.Close()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.839.1">// Apply candidate revision</span></span><span class="koboSpan" id="kobo.840.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.841.1">if </span></span><span class="koboSpan" id="kobo.842.1">err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.843.1">=</span></span><span class="koboSpan" id="kobo.844.1"> applyRevision(device, revisionID); err </span><span class="Code_Red"><span class="koboSpan" id="kobo.845.1">!=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.846.1">nil </span></span><span class="koboSpan" id="kobo.847.1">{
        log.Fatal(err)
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.848.1">You </span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.849.1">can find the code for this example in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">ch06/http</span></strong><span class="koboSpan" id="kobo.851.1"> directory of this book’s GitHub repository (</span><em class="italic"><span class="koboSpan" id="kobo.852.1">Further reading</span></em><span class="koboSpan" id="kobo.853.1">). </span><span class="koboSpan" id="kobo.853.2">This is what you should see when you run </span><span class="No-Break"><span class="koboSpan" id="kobo.854.1">this program:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.855.1">ch06/http</span><span class="Code_Blue"><span class="koboSpan" id="kobo.856.1">$ go </span></span><span class="koboSpan" id="kobo.857.1">run main.go 
</span><span class="Code_Green"><span class="koboSpan" id="kobo.858.1">2022</span></span><span class="koboSpan" id="kobo.859.1">/02/14 </span><span class="Code_Green"><span class="koboSpan" id="kobo.860.1">16</span></span><span class="koboSpan" id="kobo.861.1">:42:26 generated config {
 </span><span class="Code_Red"><span class="koboSpan" id="kobo.862.1">"interface"</span></span><span class="koboSpan" id="kobo.863.1">: {
  </span><span class="Code_Red"><span class="koboSpan" id="kobo.864.1">"lo"</span></span><span class="koboSpan" id="kobo.865.1">: {
   </span><span class="Code_Red"><span class="koboSpan" id="kobo.866.1">"ip"</span></span><span class="koboSpan" id="kobo.867.1">: {
    </span><span class="Code_Red"><span class="koboSpan" id="kobo.868.1">"address"</span></span><span class="koboSpan" id="kobo.869.1">: {
     </span><span class="Code_Red"><span class="koboSpan" id="kobo.870.1">"198.51.100.2/32"</span></span><span class="koboSpan" id="kobo.871.1">: {}
...
 </span><span class="Code_Red"><span class="koboSpan" id="kobo.872.1">"router"</span></span><span class="koboSpan" id="kobo.873.1">: {
  </span><span class="Code_Red"><span class="koboSpan" id="kobo.874.1">"bgp"</span></span><span class="koboSpan" id="kobo.875.1">: {
   </span><span class="Code_Red"><span class="koboSpan" id="kobo.876.1">"autonomous-system"</span></span><span class="koboSpan" id="kobo.877.1">: </span><span class="Code_Green"><span class="koboSpan" id="kobo.878.1">65002</span></span><span class="koboSpan" id="kobo.879.1">,
   </span><span class="Code_Red"><span class="koboSpan" id="kobo.880.1">"router-id"</span></span><span class="koboSpan" id="kobo.881.1">: </span><span class="Code_Red"><span class="koboSpan" id="kobo.882.1">"198.51.100.2"</span></span><span class="koboSpan" id="kobo.883.1">
  }
 },
 </span><span class="Code_Red"><span class="koboSpan" id="kobo.884.1">"vrf"</span></span><span class="koboSpan" id="kobo.885.1">: {
  </span><span class="Code_Red"><span class="koboSpan" id="kobo.886.1">"default"</span></span><span class="koboSpan" id="kobo.887.1">: {
   </span><span class="Code_Red"><span class="koboSpan" id="kobo.888.1">"router"</span></span><span class="koboSpan" id="kobo.889.1">: {
    </span><span class="Code_Red"><span class="koboSpan" id="kobo.890.1">"bgp"</span></span><span class="koboSpan" id="kobo.891.1">: {
...
</span><span class="koboSpan" id="kobo.891.2">     </span><span class="Code_Red"><span class="koboSpan" id="kobo.892.1">"enable"</span></span><span class="koboSpan" id="kobo.893.1">: </span><span class="Code_Red"><span class="koboSpan" id="kobo.894.1">"on"</span></span><span class="koboSpan" id="kobo.895.1">,
     </span><span class="Code_Red"><span class="koboSpan" id="kobo.896.1">"neighbor"</span></span><span class="koboSpan" id="kobo.897.1">: {
      </span><span class="Code_Red"><span class="koboSpan" id="kobo.898.1">"192.0.2.2"</span></span><span class="koboSpan" id="kobo.899.1">: {
       </span><span class="Code_Red"><span class="koboSpan" id="kobo.900.1">"remote-as"</span></span><span class="koboSpan" id="kobo.901.1">: </span><span class="Code_Green"><span class="koboSpan" id="kobo.902.1">65001</span></span><span class="koboSpan" id="kobo.903.1">,
       </span><span class="Code_Red"><span class="koboSpan" id="kobo.904.1">"type"</span></span><span class="koboSpan" id="kobo.905.1">: </span><span class="Code_Red"><span class="koboSpan" id="kobo.906.1">"numbered"</span></span><span class="koboSpan" id="kobo.907.1">
      },
      </span><span class="Code_Red"><span class="koboSpan" id="kobo.908.1">"203.0.113.4"</span></span><span class="koboSpan" id="kobo.909.1">: {
       </span><span class="Code_Red"><span class="koboSpan" id="kobo.910.1">"remote-as"</span></span><span class="koboSpan" id="kobo.911.1">: </span><span class="Code_Green"><span class="koboSpan" id="kobo.912.1">65005</span></span><span class="koboSpan" id="kobo.913.1">,
       </span><span class="Code_Red"><span class="koboSpan" id="kobo.914.1">"type"</span></span><span class="koboSpan" id="kobo.915.1">: </span><span class="Code_Red"><span class="koboSpan" id="kobo.916.1">"numbered"</span></span><span class="koboSpan" id="kobo.917.1">
      }
...
</span><span class="koboSpan" id="kobo.917.2">}
</span><span class="Code_Green"><span class="koboSpan" id="kobo.918.1">2022</span></span><span class="koboSpan" id="kobo.919.1">/02/14 </span><span class="Code_Green"><span class="koboSpan" id="kobo.920.1">16</span></span><span class="koboSpan" id="kobo.921.1">:42:27 Created revisionID: changeset/cumulus/2022-02-14_16.42.26_K4FJ
{
  </span><span class="Code_Red"><span class="koboSpan" id="kobo.922.1">"state"</span></span><span class="koboSpan" id="kobo.923.1">: </span><span class="Code_Red"><span class="koboSpan" id="kobo.924.1">"apply"</span></span><span class="koboSpan" id="kobo.925.1">,
  </span><span class="Code_Red"><span class="koboSpan" id="kobo.926.1">"transition"</span></span><span class="koboSpan" id="kobo.927.1">: {
    </span><span class="Code_Red"><span class="koboSpan" id="kobo.928.1">"issue"</span></span><span class="koboSpan" id="kobo.929.1">: {},
    </span><span class="Code_Red"><span class="koboSpan" id="kobo.930.1">"progress"</span></span><span class="koboSpan" id="kobo.931.1">: </span><span class="Code_Red"><span class="koboSpan" id="kobo.932.1">""</span></span><span class="koboSpan" id="kobo.933.1">
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.934.1">Just like with SSH, we rarely use </span><strong class="source-inline"><span class="koboSpan" id="kobo.935.1">net/http</span></strong><span class="koboSpan" id="kobo.936.1"> directly in our programs to interact with a REST API and</span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.937.1"> normally use a higher-level </span><span class="No-Break"><span class="koboSpan" id="kobo.938.1">package instead.</span></span></p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.939.1">Getting config inputs from other systems via HTTP</span></h2>
<p><span class="koboSpan" id="kobo.940.1">Until </span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.941.1">this point, the data to generate a particular device configuration has come from a static file that is present in the program’s folder. </span><span class="koboSpan" id="kobo.941.2">These values are network </span><span class="No-Break"><span class="koboSpan" id="kobo.942.1">device vendor-agnostic.</span></span></p>
<p><span class="koboSpan" id="kobo.943.1">In real-world </span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.944.1">network automation systems, these values can come from other systems. </span><span class="koboSpan" id="kobo.944.2">For example, an </span><strong class="bold"><span class="koboSpan" id="kobo.945.1">IP address management </span></strong><span class="koboSpan" id="kobo.946.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.947.1">IPAM</span></strong><span class="koboSpan" id="kobo.948.1">) tool can allocate IP addresses dynamically via a REST API call for a particular device, which you can use to build its configuration. </span><span class="koboSpan" id="kobo.948.2">The collection of systems that supply these parameters becomes what some refer to as the </span><em class="italic"><span class="koboSpan" id="kobo.949.1">source of truth</span></em><span class="koboSpan" id="kobo.950.1">. </span><span class="koboSpan" id="kobo.950.2">Nautobot is an infrastructure resource modeling application that falls into </span><span class="No-Break"><span class="koboSpan" id="kobo.951.1">this category.</span></span></p>
<p><span class="koboSpan" id="kobo.952.1">This also highlights the fact that to automate networks, we not only need to interact with network devices but also integrate with other systems such as Nautobot. </span><span class="koboSpan" id="kobo.952.2">This is why we are dedicating this example to exploring how to Go use to interact with a free public instance of Nautobot</span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.953.1"> available for anyone </span><span class="No-Break"><span class="koboSpan" id="kobo.954.1">at </span></span><a href="https://demo.nautobot.com/"><span class="No-Break"><span class="koboSpan" id="kobo.955.1">https://demo.nautobot.com/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.956.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.957.1">The Go client package for Nautobot is automatically generated from its OpenAPI specification, which means its structure might be familiar to you if you have already worked with other OpenAPI-derived packages, which is an advantage of machine-generated code. </span></p>
<p><span class="koboSpan" id="kobo.958.1">In the following example, we are using the auto-generated Nautobot Go package to define a Nautobot API client pointing to </span><a href="https://demo.nautobot.com/"><span class="koboSpan" id="kobo.959.1">https://demo.nautobot.com/</span></a><span class="koboSpan" id="kobo.960.1"> with an </span><span class="No-Break"><span class="koboSpan" id="kobo.961.1">API token:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.962.1">func </span></span><span class="koboSpan" id="kobo.963.1">main() {
    token, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.964.1">=</span></span><span class="koboSpan" id="kobo.965.1"> NewSecurityProviderNautobotToken("...")
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.966.1">// process error</span></span><span class="koboSpan" id="kobo.967.1">
 
    c, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.968.1">=</span></span><span class="koboSpan" id="kobo.969.1"> nb.NewClientWithResponses(
        </span><span class="Code_Red"><span class="koboSpan" id="kobo.970.1">"https://demo.nautobot.com/api/"</span></span><span class="koboSpan" id="kobo.971.1">,
        nb.WithRequestEditorFn(token.Intercept),
    )
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.972.1">/* ... </span><span class="koboSpan" id="kobo.972.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.972.3">*/</span></span><span class="koboSpan" id="kobo.973.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.974.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">c</span></strong><span class="koboSpan" id="kobo.976.1"> client</span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.977.1"> allows us to interact with the remote Nautobot instance. </span><span class="koboSpan" id="kobo.977.2">In this example, we want to add one of the lab topology nodes (</span><strong class="source-inline"><span class="koboSpan" id="kobo.978.1">ceos</span></strong><span class="koboSpan" id="kobo.979.1">) to the </span><strong class="bold"><span class="koboSpan" id="kobo.980.1">data center infrastructure management</span></strong><span class="koboSpan" id="kobo.981.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.982.1">DCIM</span></strong><span class="koboSpan" id="kobo.983.1">) resource collection of the</span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.984.1"> Nautobot instance. </span><span class="koboSpan" id="kobo.984.2">The device details are in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.985.1">device.json</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.986.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.987.1">{
    "name": </span><span class="Code_Red"><span class="koboSpan" id="kobo.988.1">"ams01-ceos-02"</span></span><span class="koboSpan" id="kobo.989.1">,
    "device_type": {
        "slug": </span><span class="Code_Red"><span class="koboSpan" id="kobo.990.1">"ceos"</span></span><span class="koboSpan" id="kobo.991.1">
    },
    "device_role": {
        "slug": </span><span class="Code_Red"><span class="koboSpan" id="kobo.992.1">"router"</span></span><span class="koboSpan" id="kobo.993.1">
    },
    "site": {
        "slug": </span><span class="Code_Red"><span class="koboSpan" id="kobo.994.1">"ams01"</span></span><span class="koboSpan" id="kobo.995.1">
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.996.1">Before we can add the device to Nautobot, we must make sure the device type, device role, and site we are referencing in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.997.1">device.json</span></strong><span class="koboSpan" id="kobo.998.1"> file exist by name already in Nautobot. </span><span class="koboSpan" id="kobo.998.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.999.1">createResources</span></strong><span class="koboSpan" id="kobo.1000.1"> function takes care of this. </span><span class="koboSpan" id="kobo.1000.2">Then, we get the IDs of these resources (device type, device role, and site) with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1001.1">getDeviceIDs</span></strong><span class="koboSpan" id="kobo.1002.1"> function, to associate the new device with its type, role, </span><span class="No-Break"><span class="koboSpan" id="kobo.1003.1">and site:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1004.1">func </span></span><span class="koboSpan" id="kobo.1005.1">main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1006.1">/* ... </span><span class="koboSpan" id="kobo.1006.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.1006.3">*/</span></span><span class="koboSpan" id="kobo.1007.1">
    err </span><span class="Code_Red"><span class="koboSpan" id="kobo.1008.1">=</span></span><span class="koboSpan" id="kobo.1009.1"> createResources(c)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1010.1">// process error</span></span><span class="koboSpan" id="kobo.1011.1">
 
    dev, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1012.1">=</span></span><span class="koboSpan" id="kobo.1013.1"> os.Open(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1014.1">"device.json"</span></span><span class="koboSpan" id="kobo.1015.1">)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1016.1">// process error</span></span><span class="koboSpan" id="kobo.1017.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1018.1">defer </span></span><span class="koboSpan" id="kobo.1019.1">dev.Close()
 
    d :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1020.1">=</span></span><span class="koboSpan" id="kobo.1021.1"> json.NewDecoder(dev)
 
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1022.1">var </span></span><span class="koboSpan" id="kobo.1023.1">device nb.Device
    err </span><span class="Code_Red"><span class="koboSpan" id="kobo.1024.1">=</span></span><span class="koboSpan" id="kobo.1025.1"> d.Decode(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1026.1">&amp;</span></span><span class="koboSpan" id="kobo.1027.1">device)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1028.1">// process error</span></span><span class="koboSpan" id="kobo.1029.1">
 
    found, devWithIDs, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1030.1">=</span></span><span class="koboSpan" id="kobo.1031.1"> getDeviceIDs(c, device)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1032.1">/* ... </span><span class="koboSpan" id="kobo.1032.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.1032.3">*/</span></span><span class="koboSpan" id="kobo.1033.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.1034.1">If the device</span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.1035.1"> is not already in Nautobot, we can create it with the auto-generated </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1036.1">DcimDevicesCreateWithResponse</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1037.1"> function:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1038.1">func </span></span><span class="koboSpan" id="kobo.1039.1">main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1040.1">/* ... </span><span class="koboSpan" id="kobo.1040.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.1040.3">*/</span></span><span class="koboSpan" id="kobo.1041.1">
    created, err := c.DcimDevicesCreateWithResponse(
        context.TODO(),
        nb.DcimDevicesCreateJSONRequestBody(*devWithIDs))
    check(err)
}</span></pre>
<p><span class="koboSpan" id="kobo.1042.1">After running the program with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1043.1">go run nautobot</span></strong><span class="koboSpan" id="kobo.1044.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1045.1">ch06/nautobot</span></strong><span class="koboSpan" id="kobo.1046.1"> folder, you</span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.1047.1"> should see the following in the Nautobot graphical interface </span><span class="No-Break"><span class="koboSpan" id="kobo.1048.1">at </span></span><a href="https://demo.nautobot.com/"><span class="No-Break"><span class="koboSpan" id="kobo.1049.1">https://demo.nautobot.com/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1050.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer059">
<span class="koboSpan" id="kobo.1051.1"><img alt="Figure 6.3 – Nautobot screenshot" src="image/B16971_06_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1052.1">Figure 6.3 – Nautobot screenshot</span></p>
<p><span class="koboSpan" id="kobo.1053.1">The data that we pass to these Dcim functions ends up in HTTP requests, just like the ones we built manually earlier in this chapter. </span><span class="koboSpan" id="kobo.1053.2">Here, we don’t deal with URL queries, HTTP paths, or JSON payloads directly as the package abstracts away all that from us. </span><span class="koboSpan" id="kobo.1053.3">This allows the developers to focus more on business value and less on implementation details. </span><span class="koboSpan" id="kobo.1053.4">It makes the API easier </span><span class="No-Break"><span class="koboSpan" id="kobo.1054.1">to consume.</span></span></p>
<p><span class="koboSpan" id="kobo.1055.1">The focus of this chapter so far has been more on pushing configurations down to network devices and less on reading the state of the network after this operation. </span><span class="koboSpan" id="kobo.1055.2">While configuration management’s primary focus is on producing and deploying configurations in the correct format, state validation can play a key role in verifying your configuration changes have been successful. </span><span class="koboSpan" id="kobo.1055.3">In the next section, we will learn how to retrieve and parse operational data from a </span><span class="No-Break"><span class="koboSpan" id="kobo.1056.1">remote device.</span></span></p>
<h1 id="_idParaDest-157"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.1057.1">State validation</span></h1>
<p><span class="koboSpan" id="kobo.1058.1">The way</span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.1059.1"> network devices model and store their state internally is often different from their configuration data model. </span><span class="koboSpan" id="kobo.1059.2">Traditional CLI-first network devices display the state in a tabular format to the end user, making it easier for network operators to interpret and reason about it. </span><span class="koboSpan" id="kobo.1059.3">In API-enabled network operating systems, they can present the state in a structured format, making the data friendlier for automation, but we still need to prepare the right data model </span><span class="No-Break"><span class="koboSpan" id="kobo.1060.1">for deserialization.</span></span></p>
<p><span class="koboSpan" id="kobo.1061.1">In this section, we</span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.1062.1"> will look at three different methods you could use to read the state from a network device through a code example that gathers operational data from the devices we just configured with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1063.1">crypto/ssh</span></strong><span class="koboSpan" id="kobo.1064.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1065.1">net/http</span></strong><span class="koboSpan" id="kobo.1066.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1067.1">scrapligo</span></strong><span class="koboSpan" id="kobo.1068.1"> in the preceding sections of this chapter. </span><span class="koboSpan" id="kobo.1068.2">For each network device, we will use one of these resources to get the data in the format </span><span class="No-Break"><span class="koboSpan" id="kobo.1069.1">we need:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1070.1">RESTful API calls</span></strong><span class="koboSpan" id="kobo.1071.1">: To </span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.1072.1">retrieve and parse data from an </span><span class="No-Break"><span class="koboSpan" id="kobo.1073.1">HTTP interface</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1074.1">Regular expressions</span></strong><span class="koboSpan" id="kobo.1075.1">: To </span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.1076.1">parse plain text received </span><span class="No-Break"><span class="koboSpan" id="kobo.1077.1">via SSH</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1078.1">TextFSM templates</span></strong><span class="koboSpan" id="kobo.1079.1">: To </span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.1080.1">simplify parsing </span><span class="No-Break"><span class="koboSpan" id="kobo.1081.1">tabular data</span></span></li>
</ul>
<h2 id="_idParaDest-158"><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.1082.1">Checking routing information</span></h2>
<p><span class="koboSpan" id="kobo.1083.1">At this</span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.1084.1"> point, you </span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.1085.1">should have a three-node topology running. </span><span class="koboSpan" id="kobo.1085.2">Each network device has a loopback address we redistribute into BGP. </span><span class="koboSpan" id="kobo.1085.3">Arista cEOS’s loopback address is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1086.1">198.51.100.1/32</span></strong><span class="koboSpan" id="kobo.1087.1">, for example. </span><span class="koboSpan" id="kobo.1087.2">The goal of the next program is to verify the setup. </span><span class="koboSpan" id="kobo.1087.3">We retrieve the routing table information from every device to check whether all three IPv4 loopback addresses are present. </span><span class="koboSpan" id="kobo.1087.4">This way, we can verify our configuration intent – established end-to-end reachability between </span><span class="No-Break"><span class="koboSpan" id="kobo.1088.1">all devices.</span></span></p>
<p><span class="koboSpan" id="kobo.1089.1">The program has two </span><span class="No-Break"><span class="koboSpan" id="kobo.1090.1">building blocks:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1091.1">GetRoutes</span></strong><span class="koboSpan" id="kobo.1092.1">: A</span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.1093.1"> method that connects to the network device, gets the information we need, and puts it in a </span><span class="No-Break"><span class="koboSpan" id="kobo.1094.1">common format</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1095.1">checkRoutes</span></strong><span class="koboSpan" id="kobo.1096.1">: A </span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.1097.1">function that reads the routes from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1098.1">GetRoutes</span></strong><span class="koboSpan" id="kobo.1099.1"> and compares them to the list of loopback addresses we expect to </span><span class="No-Break"><span class="koboSpan" id="kobo.1100.1">see (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1101.1">expectedRoutes</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1102.1">)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1103.1">One</span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.1104.1"> caveat is that the API type a network device supports to access its operational data remotely may vary, from the transport </span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.1105.1">protocol to the format of the textual representation of the data. </span><span class="koboSpan" id="kobo.1105.2">In our example, this translates into different implementation details of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1106.1">GetRoutes</span></strong><span class="koboSpan" id="kobo.1107.1"> per networking vendor. </span><span class="koboSpan" id="kobo.1107.2">Here, we take it a bit to the extreme for educational purposes and make the implementation per vendor completely different from one another to showcase REST APIs, regular expressions, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1108.1">TextFSM independently:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer060">
<span class="koboSpan" id="kobo.1109.1"><img alt="Figure 6.4 – Checking routing information" src="image/B16971_06_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1110.1">Figure 6.4 – Checking routing information</span></p>
<p><span class="koboSpan" id="kobo.1111.1">Each network device has its own data structure. </span><span class="koboSpan" id="kobo.1111.2">For example, we create SRL for SR Linux. </span><span class="koboSpan" id="kobo.1111.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1112.1">SRL</span></strong><span class="koboSpan" id="kobo.1113.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1114.1">CVX</span></strong><span class="koboSpan" id="kobo.1115.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1116.1">CEOS</span></strong><span class="koboSpan" id="kobo.1117.1"> types implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1118.1">Router</span></strong><span class="koboSpan" id="kobo.1119.1"> interface, as each one has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1120.1">GetRoutes</span></strong><span class="koboSpan" id="kobo.1121.1"> method that contains the implementation details for that </span><span class="No-Break"><span class="koboSpan" id="kobo.1122.1">specific vendor.</span></span></p>
<p><span class="koboSpan" id="kobo.1123.1">In the main program, a user only needs to initialize the devices with the authentication details, so it creates a variable of the type we created for that device. </span><span class="koboSpan" id="kobo.1123.2">Then, it can run the route collection tasks concurrently by firing off a goroutine for each device that runs the device type’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1124.1">GetRoutes</span></strong><span class="koboSpan" id="kobo.1125.1"> method. </span><span class="koboSpan" id="kobo.1125.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1126.1">Router</span></strong><span class="koboSpan" id="kobo.1127.1"> interface successfully hides away the implementation details of a particular </span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.1128.1">vendor</span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.1129.1"> from the user, as the call is always the </span><span class="No-Break"><span class="koboSpan" id="kobo.1130.1">same </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1131.1">router.GetRoutes</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1132.1">:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1133.1">type </span></span><span class="koboSpan" id="kobo.1134.1">Router </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1135.1">interface </span></span><span class="koboSpan" id="kobo.1136.1">{
    GetRoutes(wg *sync.WaitGroup)
}
 
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1137.1">func </span></span><span class="koboSpan" id="kobo.1138.1">main() {
     cvx :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1139.1">=</span></span><span class="koboSpan" id="kobo.1140.1"> CVX{
     Hostname: </span><span class="Code_Red"><span class="koboSpan" id="kobo.1141.1">"clab-netgo-cvx"</span></span><span class="koboSpan" id="kobo.1142.1">,
      Authentication: Authentication{
      Username: </span><span class="Code_Red"><span class="koboSpan" id="kobo.1143.1">"cumulus"</span></span><span class="koboSpan" id="kobo.1144.1">,
     Password: </span><span class="Code_Red"><span class="koboSpan" id="kobo.1145.1">"cumulus"</span></span><span class="koboSpan" id="kobo.1146.1">,
     },
    }
    srl := SRL{
     Hostname: </span><span class="Code_Red"><span class="koboSpan" id="kobo.1147.1">"clab-netgo-srl"</span></span><span class="koboSpan" id="kobo.1148.1">,
     Authentication: Authentication{
      Username: </span><span class="Code_Red"><span class="koboSpan" id="kobo.1149.1">"admin"</span></span><span class="koboSpan" id="kobo.1150.1">,
      Password: </span><span class="Code_Red"><span class="koboSpan" id="kobo.1151.1">"admin"</span></span><span class="koboSpan" id="kobo.1152.1">,
     },
    }
    ceos := CEOS{
     Hostname: </span><span class="Code_Red"><span class="koboSpan" id="kobo.1153.1">"clab-netgo-ceos"</span></span><span class="koboSpan" id="kobo.1154.1">,
     Authentication: Authentication{
      Username: </span><span class="Code_Red"><span class="koboSpan" id="kobo.1155.1">"admin"</span></span><span class="koboSpan" id="kobo.1156.1">,
      Password: </span><span class="Code_Red"><span class="koboSpan" id="kobo.1157.1">"admin"</span></span><span class="koboSpan" id="kobo.1158.1">,
     },
    }
 
    log.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1159.1">"Checking reachability..."</span></span><span class="koboSpan" id="kobo.1160.1">)
 
    devices := []Router{cvx, srl, ceos}
 
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1161.1">var </span></span><span class="koboSpan" id="kobo.1162.1">wg sync.WaitGroup
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1163.1">for </span></span><span class="koboSpan" id="kobo.1164.1">_, router := </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1165.1">range </span></span><span class="koboSpan" id="kobo.1166.1">devices {
        wg.Add(1)
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1167.1">go </span></span><span class="koboSpan" id="kobo.1168.1">router.GetRoutes(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1169.1">&amp;</span></span><span class="koboSpan" id="kobo.1170.1">wg)
    }
    wg.Wait()
}</span></pre>
<p><span class="koboSpan" id="kobo.1171.1">Because</span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.1172.1"> all </span><strong class="source-inline"><span class="koboSpan" id="kobo.1173.1">GetRoutes</span></strong><span class="koboSpan" id="kobo.1174.1"> instances run in the</span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.1175.1"> background in their own goroutine, we added a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1176.1">wg</span></strong><span class="koboSpan" id="kobo.1177.1"> wait group to make sure we don’t finish the main goroutine until we have collected and verified all the devices. </span><span class="koboSpan" id="kobo.1177.2">Before the end of each </span><strong class="source-inline"><span class="koboSpan" id="kobo.1178.1">GetRoutes</span></strong><span class="koboSpan" id="kobo.1179.1"> method, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1180.1">expectedRoutes</span></strong><span class="koboSpan" id="kobo.1181.1"> function to process the routes we get from </span><span class="No-Break"><span class="koboSpan" id="kobo.1182.1">that device.</span></span></p>
<p><span class="koboSpan" id="kobo.1183.1">We verify the parsed state (routes) by checking that each </span><strong class="source-inline"><span class="koboSpan" id="kobo.1184.1">expectedRoutes</span></strong><span class="koboSpan" id="kobo.1185.1">, which contains a unique set of loopback addresses, is present in each device’s routing table. </span><span class="koboSpan" id="kobo.1185.2">For every IPv4 prefix received, we check whether it’s present in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1186.1">expectedRoutes</span></strong><span class="koboSpan" id="kobo.1187.1"> and change a boolean flag to signal this. </span><span class="koboSpan" id="kobo.1187.2">If, by the end of this, we have prefixes in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1188.1">expectedRoutes</span></strong><span class="koboSpan" id="kobo.1189.1"> with a Boolean value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1190.1">false</span></strong><span class="koboSpan" id="kobo.1191.1">, it means they were not present in the device’s routing</span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.1192.1"> table, and we create a </span><span class="No-Break"><span class="koboSpan" id="kobo.1193.1">log </span></span><span class="No-Break"><a id="_idIndexMarker617"/></span><span class="No-Break"><span class="koboSpan" id="kobo.1194.1">message:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1195.1">func </span></span><span class="koboSpan" id="kobo.1196.1">checkRoutes(device </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1197.1">string</span></span><span class="koboSpan" id="kobo.1198.1">, in []</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1199.1">string</span></span><span class="koboSpan" id="kobo.1200.1">, wg *sync.WaitGroup) {
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1201.1">defer </span></span><span class="koboSpan" id="kobo.1202.1">wg.Done()
    log.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1203.1">"Checking %s routes"</span></span><span class="koboSpan" id="kobo.1204.1">, device)
    expectedRoutes := </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1205.1">map</span></span><span class="koboSpan" id="kobo.1206.1">[</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1207.1">string</span></span><span class="koboSpan" id="kobo.1208.1">]</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1209.1">bool</span></span><span class="koboSpan" id="kobo.1210.1">{
        </span><span class="Code_Red"><span class="koboSpan" id="kobo.1211.1">"198.51.100.0/32"</span></span><span class="koboSpan" id="kobo.1212.1">: </span><span class="Code_Blue"><span class="koboSpan" id="kobo.1213.1">false</span></span><span class="koboSpan" id="kobo.1214.1">,
        </span><span class="Code_Red"><span class="koboSpan" id="kobo.1215.1">"198.51.100.1/32"</span></span><span class="koboSpan" id="kobo.1216.1">: </span><span class="Code_Blue"><span class="koboSpan" id="kobo.1217.1">false</span></span><span class="koboSpan" id="kobo.1218.1">,
        </span><span class="Code_Red"><span class="koboSpan" id="kobo.1219.1">"198.51.100.2/32"</span></span><span class="koboSpan" id="kobo.1220.1">: </span><span class="Code_Blue"><span class="koboSpan" id="kobo.1221.1">false</span></span><span class="koboSpan" id="kobo.1222.1">,
    }
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1223.1">for </span></span><span class="koboSpan" id="kobo.1224.1">_, route := </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1225.1">range </span></span><span class="koboSpan" id="kobo.1226.1">in {
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1227.1">if </span></span><span class="koboSpan" id="kobo.1228.1">_, ok := expectedRoutes[route]; ok {
            log.Print(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1229.1">"Route "</span></span><span class="koboSpan" id="kobo.1230.1">, route,
                        </span><span class="Code_Red"><span class="koboSpan" id="kobo.1231.1">" found on "</span></span><span class="koboSpan" id="kobo.1232.1">, device)
            expectedRoutes[route] = </span><span class="Code_Blue"><span class="koboSpan" id="kobo.1233.1">true</span></span><span class="koboSpan" id="kobo.1234.1">
        }
    }
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1235.1">for </span></span><span class="koboSpan" id="kobo.1236.1">route, found := </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1237.1">range </span></span><span class="koboSpan" id="kobo.1238.1">expectedRoutes {
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1239.1">if </span></span><span class="koboSpan" id="kobo.1240.1">!found {
            log.Print(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1241.1">"! </span><span class="koboSpan" id="kobo.1241.2">Route "</span></span><span class="koboSpan" id="kobo.1242.1">, route, 
                        </span><span class="Code_Red"><span class="koboSpan" id="kobo.1243.1">" NOT found on "</span></span><span class="koboSpan" id="kobo.1244.1">, device)
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.1245.1">Following this, we examine each of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1246.1">GetRoutes</span></strong><span class="koboSpan" id="kobo.1247.1"> method implementations. </span><span class="koboSpan" id="kobo.1247.2">As with the rest </span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.1248.1">of the</span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.1249.1"> examples, you can find the complete program in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1250.1">ch06/state</span></strong><span class="koboSpan" id="kobo.1251.1"> folder of this book’s GitHub repository (</span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1252.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1253.1">).</span></span></p>
<h3><span class="koboSpan" id="kobo.1254.1">Parsing command outputs with regular expressions</span></h3>
<p><span class="koboSpan" id="kobo.1255.1">We use </span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.1256.1">regular expressions to parse and extract information from unstructured data. </span><span class="koboSpan" id="kobo.1256.2">The Go standard library includes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1257.1">regexp</span></strong><span class="koboSpan" id="kobo.1258.1"> package, which understands the RE2 syntax. </span><span class="koboSpan" id="kobo.1258.2">This is a regular expression library designed with safety as one of its primary goals. </span><span class="koboSpan" id="kobo.1258.3">One of the main consequences of that decision is the lack of back-references and look-around operations, which are unsafe and can lead to denial of </span><span class="No-Break"><span class="koboSpan" id="kobo.1259.1">service exploits.</span></span></p>
<p><span class="koboSpan" id="kobo.1260.1">In this case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1261.1">GetRoutes</span></strong><span class="koboSpan" id="kobo.1262.1"> method uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.1263.1">scrapligo</span></strong><span class="koboSpan" id="kobo.1264.1"> to connect and sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1265.1">show</span></strong><span class="koboSpan" id="kobo.1266.1"> command to extract the routing table information from an SRL device type in this case. </span><span class="koboSpan" id="kobo.1266.2">One way to parse this information is to iterate over the output line by line while matching expected patterns with regular expressions, close to what we did for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1267.1">ch05/closed-loop</span></strong><span class="koboSpan" id="kobo.1268.1"> example (</span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1269.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1270.1">):</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1271.1">func </span></span><span class="koboSpan" id="kobo.1272.1">(r SRL) GetRoutes(wg *sync.WaitGroup) {
    lookupCmd :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1273.1">=</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.1274.1">"show network-instance default route-table ipv4-unicast summary"</span></span><span class="koboSpan" id="kobo.1275.1">
 
    conn, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1276.1">=</span></span><span class="koboSpan" id="kobo.1277.1"> platform.NewPlatform(
        "nokia_srl",
        r.Hostname,
        options.WithAuthNoStrictKey(),
        options.WithAuthUsername(r.Username),
        options.WithAuthPassword(r.Password),
        options.WithTermWidth(176),
    )
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1278.1">// process error</span></span><span class="koboSpan" id="kobo.1279.1">
 
    driver, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1280.1">=</span></span><span class="koboSpan" id="kobo.1281.1"> conn.GetNetworkDriver()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1282.1">// process error</span></span><span class="koboSpan" id="kobo.1283.1">
    err </span><span class="Code_Red"><span class="koboSpan" id="kobo.1284.1">=</span></span><span class="koboSpan" id="kobo.1285.1"> driver.Open()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1286.1">// process error </span></span><span class="koboSpan" id="kobo.1287.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1288.1">defer </span></span><span class="koboSpan" id="kobo.1289.1">driver.Close()
 
    resp, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1290.1">=</span></span><span class="koboSpan" id="kobo.1291.1"> driver.SendCommand(lookupCmd)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1292.1">// process error</span></span><span class="koboSpan" id="kobo.1293.1">
 
    ipv4Prefix :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1294.1">=</span></span><span class="koboSpan" id="kobo.1295.1"> regexp.
</span><span class="koboSpan" id="kobo.1295.2">            MustCompile(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1296.1">`(\d{1,3}\.){3}\d{1,3}\/\d{1,2}`</span></span><span class="koboSpan" id="kobo.1297.1">)
 
    out := []</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1298.1">string</span></span><span class="koboSpan" id="kobo.1299.1">{}
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1300.1">for </span></span><span class="koboSpan" id="kobo.1301.1">_, match := </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1302.1">range </span></span><span class="koboSpan" id="kobo.1303.1">ipv4Prefix.FindAll(
    resp.RawResult, </span><span class="Code_Red"><span class="koboSpan" id="kobo.1304.1">-</span></span><span class="Code_Green"><span class="koboSpan" id="kobo.1305.1">1</span></span><span class="koboSpan" id="kobo.1306.1">) {
        out = </span><span class="Code_Blue"><span class="koboSpan" id="kobo.1307.1">append</span></span><span class="koboSpan" id="kobo.1308.1">(out, </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1309.1">string</span></span><span class="koboSpan" id="kobo.1310.1">(match))
    }
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1311.1">go </span></span><span class="koboSpan" id="kobo.1312.1">checkRoutes(r.Hostname, out, wg)
}</span></pre>
<p><span class="koboSpan" id="kobo.1313.1">To make</span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.1314.1"> things a bit simpler, we assume that anything that matches the IPv4 address pattern in the entire output is a prefix installed in the routing table. </span><span class="koboSpan" id="kobo.1314.2">This way, instead of reading and parsing a tabular data structure, we tell our program to find all text occurrences that match the IPv4 route pattern and put them on a string slice (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1315.1">out</span></strong><span class="koboSpan" id="kobo.1316.1">) that we pass to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1317.1">checkRoutes</span></strong><span class="koboSpan" id="kobo.1318.1"> function for </span><span class="No-Break"><span class="koboSpan" id="kobo.1319.1">further processing.</span></span></p>
<h3><span class="koboSpan" id="kobo.1320.1">Parsing semi-formatted command outputs with templates</span></h3>
<p><span class="koboSpan" id="kobo.1321.1">Parsing </span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.1322.1">various output formats with regular expressions can be tedious and error-prone. </span><span class="koboSpan" id="kobo.1322.2">This is why Google created </span><strong class="source-inline"><span class="koboSpan" id="kobo.1323.1">TextFSM</span></strong><span class="koboSpan" id="kobo.1324.1">, initially as a Python library, to implement a template-based parsing of semi-formatted text. </span><span class="koboSpan" id="kobo.1324.2">They designed it specifically to parse information from network devices and it has a wide range of community-developed templates</span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.1325.1"> maintained in </span><strong class="bold"><span class="koboSpan" id="kobo.1326.1">ntc-templates</span></strong><span class="koboSpan" id="kobo.1327.1"> (</span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1328.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1329.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.1330.1">We will use one of these community templates to parse the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1331.1">ip</span></strong><span class="koboSpan" id="kobo.1332.1"> route command’s output in the implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1333.1">GetRoutes</span></strong><span class="koboSpan" id="kobo.1334.1"> for Arista cEOS. </span><span class="koboSpan" id="kobo.1334.2">Scrapligo embeds a Go port of TextFSM and can conveniently parse the response using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1335.1">TextFsmParse</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1336.1"> function:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1337.1">func </span></span><span class="koboSpan" id="kobo.1338.1">(r CEOS) GetRoutes(wg *sync.WaitGroup) {
    template := </span><span class="Code_Red"><span class="koboSpan" id="kobo.1339.1">"https://raw.githubusercontent.com/networktocode/ntc-templates/master/ntc_templates/templates/arista_eos_show_ip_route.textfsm"</span></span><span class="koboSpan" id="kobo.1340.1">
    lookupCmd :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1341.1">=</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.1342.1">"sh ip route"</span></span><span class="koboSpan" id="kobo.1343.1">
    conn, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1344.1">=</span></span><span class="koboSpan" id="kobo.1345.1"> core.NewEOSDriver(
        r.Hostname,
        base.WithAuthStrictKey(</span><span class="Code_Blue"><span class="koboSpan" id="kobo.1346.1">false</span></span><span class="koboSpan" id="kobo.1347.1">),
        base.WithAuthUsername(r.Username),
        base.WithAuthPassword(r.Password),
    )
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1348.1">// process error</span></span><span class="koboSpan" id="kobo.1349.1">
    err </span><span class="Code_Red"><span class="koboSpan" id="kobo.1350.1">=</span></span><span class="koboSpan" id="kobo.1351.1"> conn.Open()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1352.1">// process error</span></span><span class="koboSpan" id="kobo.1353.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1354.1">defer </span></span><span class="koboSpan" id="kobo.1355.1">conn.Close()
    resp, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1356.1">=</span></span><span class="koboSpan" id="kobo.1357.1"> conn.SendCommand(lookupCmd)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1358.1">// process error</span></span><span class="koboSpan" id="kobo.1359.1">
    parsed, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1360.1">=</span></span><span class="koboSpan" id="kobo.1361.1"> resp.TextFsmParse(template)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1362.1">// process error</span></span><span class="koboSpan" id="kobo.1363.1">
    out :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1364.1">=</span></span><span class="koboSpan" id="kobo.1365.1"> []</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1366.1">string</span></span><span class="koboSpan" id="kobo.1367.1">{}
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1368.1">for </span></span><span class="koboSpan" id="kobo.1369.1">_, match :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1370.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.1371.1">range </span></span><span class="koboSpan" id="kobo.1372.1">parsed {
        out </span><span class="Code_Red"><span class="koboSpan" id="kobo.1373.1">=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.1374.1">append</span></span><span class="koboSpan" id="kobo.1375.1">(out, fmt.Sprintf(
                </span><span class="Code_Red"><span class="koboSpan" id="kobo.1376.1">"%s/%s"</span></span><span class="koboSpan" id="kobo.1377.1">, match[</span><span class="Code_Red"><span class="koboSpan" id="kobo.1378.1">"NETWORK"</span></span><span class="koboSpan" id="kobo.1379.1">], match[</span><span class="Code_Red"><span class="koboSpan" id="kobo.1380.1">"MASK"</span></span><span class="koboSpan" id="kobo.1381.1">]))
    }
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1382.1">go </span></span><span class="koboSpan" id="kobo.1383.1">checkRoutes(r.Hostname, out, wg)
}</span></pre>
<p><span class="koboSpan" id="kobo.1384.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1385.1">parsed</span></strong><span class="koboSpan" id="kobo.1386.1"> variable</span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.1387.1"> that stores the parsed data is a slice that contains </span><strong class="source-inline"><span class="koboSpan" id="kobo.1388.1">map[string]interface{}</span></strong><span class="koboSpan" id="kobo.1389.1"> values, where keys correspond to the TextFSM values defined in a template. </span><span class="koboSpan" id="kobo.1389.2">Thus, just by looking at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1390.1">show ip route</span></strong><span class="koboSpan" id="kobo.1391.1"> template, we can extract the network and mask (prefix length) information and append it to a string slice (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1392.1">out</span></strong><span class="koboSpan" id="kobo.1393.1">) that we pass to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1394.1">checkRoutes</span></strong><span class="koboSpan" id="kobo.1395.1"> function for </span><span class="No-Break"><span class="koboSpan" id="kobo.1396.1">further processing.</span></span></p>
<h3><span class="koboSpan" id="kobo.1397.1">Getting JSON-formatted data with REST API requests</span></h3>
<p><span class="koboSpan" id="kobo.1398.1">Thus</span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.1399.1"> far in this chapter, we’ve seen two different ways of interacting with a REST API – one using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1400.1">net/http</span></strong><span class="koboSpan" id="kobo.1401.1"> package and another using an auto-generated high-level package (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1402.1">nautobot</span></strong><span class="koboSpan" id="kobo.1403.1">). </span><span class="koboSpan" id="kobo.1403.2">But you also have other options, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1404.1">go-resty</span></strong><span class="koboSpan" id="kobo.1405.1">, which builds on top of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1406.1">net/http</span></strong><span class="koboSpan" id="kobo.1407.1"> to offer an improved user experience when interacting with REST </span><span class="No-Break"><span class="koboSpan" id="kobo.1408.1">API endpoints.</span></span></p>
<p><span class="koboSpan" id="kobo.1409.1">In the following implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1410.1">GetRoutes</span></strong><span class="koboSpan" id="kobo.1411.1">, we are taking advantage of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1412.1">go-resty</span></strong><span class="koboSpan" id="kobo.1413.1"> to build the required HTTP headers for authentication, extend the URL with query parameters, and </span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.1414.1">unmarshal a response into a user-defined data </span><span class="No-Break"><span class="koboSpan" id="kobo.1415.1">structure (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1416.1">routes</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1417.1">):</span></span></p>
<pre class="source-code"><span class="Code_Green"><span class="koboSpan" id="kobo.1418.1">Code Block 1:</span></span>
<span class="Code_Purple"><span class="koboSpan" id="kobo.1419.1">func</span></span><span class="koboSpan" id="kobo.1420.1"> (r CVX) GetRoutes(wg </span><span class="Code_Red"><span class="koboSpan" id="kobo.1421.1">*</span></span><span class="koboSpan" id="kobo.1422.1">sync.WaitGroup) {
	client :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1423.1">=</span></span><span class="koboSpan" id="kobo.1424.1"> resty.NewWithClient(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1425.1">&amp;</span></span><span class="koboSpan" id="kobo.1426.1">http.Client{
		Transport: </span><span class="Code_Red"><span class="koboSpan" id="kobo.1427.1">&amp;</span></span><span class="koboSpan" id="kobo.1428.1">http.Transport{
			TLSClientConfig: </span><span class="Code_Red"><span class="koboSpan" id="kobo.1429.1">&amp;</span></span><span class="koboSpan" id="kobo.1430.1">tls.Config{InsecureSkipVerify: </span><span class="Code_Blue"><span class="koboSpan" id="kobo.1431.1">true</span></span><span class="koboSpan" id="kobo.1432.1">},
		},
	})
	client.SetBaseURL(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1433.1">"https://" +</span></span><span class="koboSpan" id="kobo.1434.1"> r.Hostname </span><span class="Code_Red"><span class="koboSpan" id="kobo.1435.1">+ ":8765"</span></span><span class="koboSpan" id="kobo.1436.1"> )
	client.SetBasicAuth(r.Username, r.Password)
	</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1437.1">var</span></span><span class="koboSpan" id="kobo.1438.1"> routes </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1439.1">map</span></span><span class="koboSpan" id="kobo.1440.1">[</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1441.1">string</span></span><span class="koboSpan" id="kobo.1442.1">]</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1443.1">interface</span></span><span class="koboSpan" id="kobo.1444.1">{}
	_, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1445.1">=</span></span><span class="koboSpan" id="kobo.1446.1"> client.R().
		</span><span class="koboSpan" id="kobo.1446.2">SetResult(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1447.1">&amp;</span></span><span class="koboSpan" id="kobo.1448.1">routes).
		</span><span class="koboSpan" id="kobo.1448.2">SetQueryParams(map[string]string{
			</span><span class="Code_Red"><span class="koboSpan" id="kobo.1449.1">"rev"</span></span><span class="koboSpan" id="kobo.1450.1">: </span><span class="Code_Red"><span class="koboSpan" id="kobo.1451.1">"operational"</span></span><span class="koboSpan" id="kobo.1452.1">,
		}).
		</span><span class="koboSpan" id="kobo.1452.2">Get(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1453.1">"/nvue_v1/vrf/default/router/rib/ipv4/route"</span></span><span class="koboSpan" id="kobo.1454.1">)
	</span><span class="Code_Brown"><span class="koboSpan" id="kobo.1455.1">// process error</span></span><span class="koboSpan" id="kobo.1456.1">
	out :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1457.1">=</span></span><span class="koboSpan" id="kobo.1458.1"> []</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1459.1">string</span></span><span class="koboSpan" id="kobo.1460.1">{}
	</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1461.1">for</span></span><span class="koboSpan" id="kobo.1462.1"> route :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1463.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.1464.1">range</span></span><span class="koboSpan" id="kobo.1465.1"> routes {
		out </span><span class="Code_Red"><span class="koboSpan" id="kobo.1466.1">=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.1467.1">append</span></span><span class="koboSpan" id="kobo.1468.1">(out, route)
	}
	</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1469.1">go</span></span><span class="koboSpan" id="kobo.1470.1"> checkRoutes(r.Hostname, out, wg)
}</span></pre>
<p><span class="koboSpan" id="kobo.1471.1">We </span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.1472.1">have created a REST API client to request the routing table information (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1473.1">...rib/ipv4/route</span></strong><span class="koboSpan" id="kobo.1474.1">) from the target device (type CVX). </span><span class="koboSpan" id="kobo.1474.2">We decoded the JSON payload response with the routing table prefixes as keys into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1475.1">routes</span></strong><span class="koboSpan" id="kobo.1476.1"> variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1477.1">map[string]interface{}</span></strong><span class="koboSpan" id="kobo.1478.1"> type. </span><span class="koboSpan" id="kobo.1478.2">Next, we looped through </span><strong class="source-inline"><span class="koboSpan" id="kobo.1479.1">routes</span></strong><span class="koboSpan" id="kobo.1480.1"> to append all keys to a string slice (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1481.1">out</span></strong><span class="koboSpan" id="kobo.1482.1">) we can pass to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1483.1">checkRoutes</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1484.1"> function.</span></span></p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.1485.1">Validating end-to-end reachability</span></h2>
<p><span class="koboSpan" id="kobo.1486.1">You can </span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.1487.1">run this program to check whether all three routers in the topology can reach one another from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1488.1">ch06/state</span></strong><span class="koboSpan" id="kobo.1489.1"> folder (</span><em class="italic"><span class="koboSpan" id="kobo.1490.1">Further reading</span></em><span class="koboSpan" id="kobo.1491.1">). </span><span class="koboSpan" id="kobo.1491.2">Make sure all the devices have the configs from the examples that used </span><strong class="source-inline"><span class="koboSpan" id="kobo.1492.1">crypto/ssh</span></strong><span class="koboSpan" id="kobo.1493.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1494.1">net/http</span></strong><span class="koboSpan" id="kobo.1495.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1496.1">scrapligo</span></strong><span class="koboSpan" id="kobo.1497.1"> to configure them earlier in this chapter. </span><span class="koboSpan" id="kobo.1497.2">The expected output should look </span><span class="No-Break"><span class="koboSpan" id="kobo.1498.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1499.1">ch06/state</span><span class="Code_Blue"><span class="koboSpan" id="kobo.1500.1">$ go</span></span><span class="koboSpan" id="kobo.1501.1"> run main.go 
</span><span class="Code_Green"><span class="koboSpan" id="kobo.1502.1">2022</span></span><span class="koboSpan" id="kobo.1503.1">/03/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1504.1">17</span></span><span class="koboSpan" id="kobo.1505.1">:06:30 Checking reachability...
</span><span class="Code_Green"><span class="koboSpan" id="kobo.1506.1">2022</span></span><span class="koboSpan" id="kobo.1507.1">/03/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1508.1">17</span></span><span class="koboSpan" id="kobo.1509.1">:06:30 Collecting CEOS routes
</span><span class="Code_Green"><span class="koboSpan" id="kobo.1510.1">2022</span></span><span class="koboSpan" id="kobo.1511.1">/03/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1512.1">17</span></span><span class="koboSpan" id="kobo.1513.1">:06:30 Collecting CVX routes
</span><span class="Code_Green"><span class="koboSpan" id="kobo.1514.1">2022</span></span><span class="koboSpan" id="kobo.1515.1">/03/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1516.1">17</span></span><span class="koboSpan" id="kobo.1517.1">:06:30 Collecting SRL routes
</span><span class="Code_Green"><span class="koboSpan" id="kobo.1518.1">2022</span></span><span class="koboSpan" id="kobo.1519.1">/03/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1520.1">17</span></span><span class="koboSpan" id="kobo.1521.1">:06:30 Checking clab-netgo-cvx routes
</span><span class="Code_Green"><span class="koboSpan" id="kobo.1522.1">2022</span></span><span class="koboSpan" id="kobo.1523.1">/03/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1524.1">17</span></span><span class="koboSpan" id="kobo.1525.1">:06:30 Route </span><span class="Code_Green"><span class="koboSpan" id="kobo.1526.1">198</span></span><span class="koboSpan" id="kobo.1527.1">.51.100.0/32 found on clab-netgo-cvx
</span><span class="Code_Green"><span class="koboSpan" id="kobo.1528.1">2022</span></span><span class="koboSpan" id="kobo.1529.1">/03/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1530.1">17</span></span><span class="koboSpan" id="kobo.1531.1">:06:30 Route </span><span class="Code_Green"><span class="koboSpan" id="kobo.1532.1">198</span></span><span class="koboSpan" id="kobo.1533.1">.51.100.1/32 found on clab-netgo-cvx
</span><span class="Code_Green"><span class="koboSpan" id="kobo.1534.1">2022</span></span><span class="koboSpan" id="kobo.1535.1">/03/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1536.1">17</span></span><span class="koboSpan" id="kobo.1537.1">:06:30 Route </span><span class="Code_Green"><span class="koboSpan" id="kobo.1538.1">198</span></span><span class="koboSpan" id="kobo.1539.1">.51.100.2/32 found on clab-netgo-cvx
</span><span class="Code_Green"><span class="koboSpan" id="kobo.1540.1">2022</span></span><span class="koboSpan" id="kobo.1541.1">/03/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1542.1">17</span></span><span class="koboSpan" id="kobo.1543.1">:06:31 Checking clab-netgo-ceos routes
</span><span class="Code_Green"><span class="koboSpan" id="kobo.1544.1">2022</span></span><span class="koboSpan" id="kobo.1545.1">/03/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1546.1">17</span></span><span class="koboSpan" id="kobo.1547.1">:06:31 Route </span><span class="Code_Green"><span class="koboSpan" id="kobo.1548.1">198</span></span><span class="koboSpan" id="kobo.1549.1">.51.100.0/32 found on clab-netgo-ceos
</span><span class="Code_Green"><span class="koboSpan" id="kobo.1550.1">2022</span></span><span class="koboSpan" id="kobo.1551.1">/03/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1552.1">17</span></span><span class="koboSpan" id="kobo.1553.1">:06:31 Route </span><span class="Code_Green"><span class="koboSpan" id="kobo.1554.1">198</span></span><span class="koboSpan" id="kobo.1555.1">.51.100.1/32 found on clab-netgo-ceos
</span><span class="Code_Green"><span class="koboSpan" id="kobo.1556.1">2022</span></span><span class="koboSpan" id="kobo.1557.1">/03/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1558.1">17</span></span><span class="koboSpan" id="kobo.1559.1">:06:31 Route </span><span class="Code_Green"><span class="koboSpan" id="kobo.1560.1">198</span></span><span class="koboSpan" id="kobo.1561.1">.51.100.2/32 found on clab-netgo-ceos
</span><span class="Code_Green"><span class="koboSpan" id="kobo.1562.1">2022</span></span><span class="koboSpan" id="kobo.1563.1">/03/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1564.1">17</span></span><span class="koboSpan" id="kobo.1565.1">:06:34 Checking clab-netgo-srl routes
</span><span class="Code_Green"><span class="koboSpan" id="kobo.1566.1">2022</span></span><span class="koboSpan" id="kobo.1567.1">/03/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1568.1">17</span></span><span class="koboSpan" id="kobo.1569.1">:06:34 Route </span><span class="Code_Green"><span class="koboSpan" id="kobo.1570.1">198</span></span><span class="koboSpan" id="kobo.1571.1">.51.100.0/32 found on clab-netgo-srl
</span><span class="Code_Green"><span class="koboSpan" id="kobo.1572.1">2022</span></span><span class="koboSpan" id="kobo.1573.1">/03/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1574.1">17</span></span><span class="koboSpan" id="kobo.1575.1">:06:34 Route </span><span class="Code_Green"><span class="koboSpan" id="kobo.1576.1">198</span></span><span class="koboSpan" id="kobo.1577.1">.51.100.1/32 found on clab-netgo-srl
</span><span class="Code_Green"><span class="koboSpan" id="kobo.1578.1">2022</span></span><span class="koboSpan" id="kobo.1579.1">/03/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1580.1">17</span></span><span class="koboSpan" id="kobo.1581.1">:06:34 Route </span><span class="Code_Green"><span class="koboSpan" id="kobo.1582.1">198</span></span><span class="koboSpan" id="kobo.1583.1">.51.100.2/32 found on clab-netgo-srl</span></pre>
<p><span class="koboSpan" id="kobo.1584.1">If any of the routes</span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.1585.1"> were not present on any of the devices, we would’ve seen messages such </span><span class="No-Break"><span class="koboSpan" id="kobo.1586.1">as these:</span></span></p>
<pre class="source-code"><span class="Code_Green"><span class="koboSpan" id="kobo.1587.1">2022</span></span><span class="koboSpan" id="kobo.1588.1">/03/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1589.1">15</span></span><span class="koboSpan" id="kobo.1590.1">:59:55 ! </span><span class="koboSpan" id="kobo.1590.2">Route </span><span class="Code_Green"><span class="koboSpan" id="kobo.1591.1">198</span></span><span class="koboSpan" id="kobo.1592.1">.51.100.0/32 NOT found on clab-netgo-cvx
</span><span class="Code_Green"><span class="koboSpan" id="kobo.1593.1">2022</span></span><span class="koboSpan" id="kobo.1594.1">/03/10 </span><span class="Code_Green"><span class="koboSpan" id="kobo.1595.1">15</span></span><span class="koboSpan" id="kobo.1596.1">:59:55 ! </span><span class="koboSpan" id="kobo.1596.2">Route </span><span class="Code_Green"><span class="koboSpan" id="kobo.1597.1">198</span></span><span class="koboSpan" id="kobo.1598.1">.51.100.1/32 NOT found on clab-netgo-cvx</span></pre>
<h1 id="_idParaDest-160"><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.1599.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1600.1">Configuration generation, deployment, reporting, and compliance remain the most popular network automation operations. </span><span class="koboSpan" id="kobo.1600.2">This is where the immediate benefits of introducing automation are greatest and most visible, making it the first logical step into the world of automation and DevOps. </span><span class="koboSpan" id="kobo.1600.3">Configuration management is one of those repetitive tasks network engineers spend most of their time on, so it’s a natural fit for automation. </span><span class="koboSpan" id="kobo.1600.4">But sending a new configuration to a device is just part of a broader process that should consider failure handling, from syntax errors in the configuration to how to recover properly if the connection to a remote device drops. </span><span class="koboSpan" id="kobo.1600.5">In this context, you can abstract some repetitive tasks with reusable code that offers generic functionality to reduce the time and effort to automate your use cases. </span><span class="koboSpan" id="kobo.1600.6">This is what automation frameworks offer, which we will discuss in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1601.1">next chapter.</span></span></p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.1602.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.1603.1">To learn more about the topics that were covered in this chapter, take a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.1604.1">following resources:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1605.1">NetDevOps 2020 </span><span class="No-Break"><span class="koboSpan" id="kobo.1606.1">Survey: </span></span><a href="https://dgarros.github.io/netdevops-survey/reports/2020"><span class="No-Break"><span class="koboSpan" id="kobo.1607.1">https://dgarros.github.io/netdevops-survey/reports/2020</span></span></a></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1608.1">topo</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1609.1">directory: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/topo-base/topo.yml"><span class="No-Break"><span class="koboSpan" id="kobo.1610.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/topo-base/topo.yml</span></span></a></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1611.1">ch06/ssh</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1612.1">folder: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch06/ssh"><span class="No-Break"><span class="koboSpan" id="kobo.1613.1">https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch06/ssh</span></span></a></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1614.1">ch06/vssh</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1615.1">directory: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch06/vssh"><span class="No-Break"><span class="koboSpan" id="kobo.1616.1">https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch06/vssh</span></span></a></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1617.1">ch06/http</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1618.1">directory: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch06/http"><span class="No-Break"><span class="koboSpan" id="kobo.1619.1">https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch06/http</span></span></a></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.1620.1">demo.nautobot.com: </span></span><a href="https://demo.nautobot.com/"><span class="No-Break"><span class="koboSpan" id="kobo.1621.1">https://demo.nautobot.com/</span></span></a></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1622.1">ch06/state</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1623.1">directory: </span></span><span class="No-Break"><span class="koboSpan" id="kobo.1624.1">https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch06/ssh</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1625.1">ch05/closed-loop</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1626.1">example: </span></span><span class="No-Break"><span class="koboSpan" id="kobo.1627.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch05/closed-loop/main.go#L138</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.1628.1">ntc-templates: </span></span><a href="https://github.com/networktocode/ntc-templates"><span class="No-Break"><span class="koboSpan" id="kobo.1629.1">https://github.com/networktocode/ntc-templates</span></span></a></li>
</ul>
</div>
</body></html>