- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Configuration Management
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置管理
- en: Configuration management is a process that helps us enforce the desired configuration
    state on an IT system. It’s a way to make sure a network device, in our context,
    performs as expected as we roll out new settings. As this becomes a mundane task
    we perform repeatedly, it’s no surprise network configuration management is the
    most common network automation use case according to the NetDevOps 2020 Survey
    (*Further reading*).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理是一个帮助我们强制在IT系统上实施所需配置状态的过程。在我们的上下文中，这是一种确保网络设备在推出新设置时按预期运行的方法。由于这成为我们反复执行的一项日常任务，因此网络配置管理是NetDevOps
    2020调查（*进一步阅读*）中最常见的网络自动化用例也就不足为奇了。
- en: 'In the previous chapter, we discussed common configuration management tasks,
    along with some helpful tools and libraries that can help you write programs to
    automate those tasks in Go. In this chapter, we will focus on a few concrete examples,
    taking a closer look at how Go can help us connect and interact with network devices
    from different networking vendors using standard protocols. We will cover four
    areas in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了常见的配置管理任务，以及一些有用的工具和库，这些工具和库可以帮助您编写程序以Go语言自动化这些任务。在本章中，我们将关注几个具体的例子，更深入地了解Go如何帮助我们使用标准协议连接和交互来自不同网络供应商的网络设备。本章我们将涵盖以下四个方面：
- en: Before we introduce any new examples, we will define a three-node multi-vendor
    virtual network lab to test the code examples in this chapter and later chapters
    of this book.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在介绍任何新示例之前，我们将定义一个由三个节点组成的多供应商虚拟网络实验室，以测试本章和本书后续章节中的代码示例。
- en: Next, we will explore how we can use Go and SSH to interact with network devices.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何使用Go和SSH与网络设备交互。
- en: Then, we will repeat the exercise following the same program structure as with
    SSH but using HTTP to contrast these different options.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将按照与SSH相同的程序结构重复练习，但使用HTTP来对比这些不同的选项。
- en: Finally, we will extract and parse the resulting operational state to verify
    that our configuration changes have been successful.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将提取并解析生成的操作状态，以验证我们的配置更改是否成功。
- en: Note that we have deliberately avoided talking about YANG-based APIs here as
    we will cover them extensively in the last few chapters of this book.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里故意没有讨论基于YANG的API，因为我们将在这本书的最后几章中详细介绍它们。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Environment setup
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境设置
- en: Interacting with network devices via SSH
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过SSH与网络设备交互
- en: Interacting with network devices via HTTP
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过HTTP与网络设备交互
- en: State validation
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态验证
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the code examples for this chapter in the book’s GitHub repository:
    [https://github.com/PacktPublishing/Network-Automation-with-Go](https://github.com/PacktPublishing/Network-Automation-with-Go),
    under the `ch06` folder.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub仓库中找到本章的代码示例：[https://github.com/PacktPublishing/Network-Automation-with-Go](https://github.com/PacktPublishing/Network-Automation-with-Go)，在`ch06`文件夹下。
- en: Important Note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We recommend that you execute the Go programs in this chapter in a virtual lab
    environment. Refer to the *Appendix* for prerequisites and instructions on how
    to build it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您在虚拟实验室环境中执行本章的Go程序。请参阅*附录*以获取先决条件和构建它的说明。
- en: Environment setup
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境设置
- en: One of the easiest and safest ways to learn and experiment with network automation
    is to build a lab environment. Thanks to the progress we’ve had in the last decade,
    today, we have access to virtualized and containerized network devices from different
    networking vendors and plenty of tools that can help us build a virtual topology
    from them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 学习和实验网络自动化最简单、最安全的方法之一是构建一个实验室环境。多亏了过去十年我们所取得的进步，今天，我们可以访问来自不同网络供应商的虚拟化和容器化网络设备，以及大量可以帮助我们构建虚拟拓扑的工具。
- en: 'In this book, we will use one of those tools: **Containerlab**. This tool,
    which is written in Go, allows you to build arbitrary network topologies from
    container images. The fact that you can create and run topologies based on a plain
    YAML file in a matter of seconds makes it a strong choice to run quick tests.
    Please refer to the *Appendix* for installation instructions and recommendations
    for host operating systems.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用这些工具之一：**Containerlab**。这个用Go编写的工具允许您从容器镜像中构建任意网络拓扑。您可以在几秒钟内创建和运行基于纯YAML文件的拓扑，这使得它成为快速测试的一个强有力的选择。请参阅*附录*以获取安装说明和主机操作系统的推荐。
- en: Creating the topology
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建拓扑
- en: 'Throughout the rest of this book, we will work with a base network topology
    consisting of three containerized network devices running different **network
    operating** **systems** (**NOSes**):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将使用一个基础网络拓扑，该拓扑由三个运行不同**网络操作系统**（NOSes）的容器化网络设备组成：
- en: '`srl`: Running Nokia’s **Service Router Linux** (**SR Linux**)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`srl`：运行诺基亚的**服务路由器Linux**（**SR Linux**）'
- en: '`cvx`: Running NVIDIA’s Cumulus Linux'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cvx`：运行NVIDIA的Cumulus Linux'
- en: '`ceos`: Running Arista’s EOS'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ceos`：运行Arista的EOS'
- en: 'The following diagram depicts the device interconnections. They all come up
    with their default (blank) configuration:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了设备之间的连接。它们都使用默认（空白）配置启动：
- en: '![Figure 6.1 – Test topology](img/B16971_06_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 测试拓扑](img/B16971_06_01.jpg)'
- en: Figure 6.1 – Test topology
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 测试拓扑
- en: 'We can describe this topology with the following YAML file, which is a representation
    that **Containerlab** can interpret and translate into a running topology:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下YAML文件描述此拓扑，这是**Containerlab**可以解释并将其转换为运行拓扑的表示：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can find this YAML file, like the rest of the code examples, in this book’s
    GitHub repository, specifically in the `topo-base` directory. If you go through
    the *Appendix* to learn more about Containerlab or you have it running already,
    you can bring up the entire lab with the following command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub仓库中找到这个YAML文件，就像其他代码示例一样，具体位于`topo-base`目录中。如果您通过*附录*学习更多关于Containerlab的内容，或者您已经运行了它，您可以使用以下命令启动整个实验室：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once the lab is up, you can access each device by its hostname using the credentials
    shown in the following table:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实验室启动，您可以使用以下表中显示的凭证通过设备的主机名访问每个设备：
- en: '| Device | Username | Password |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 设备 | 用户名 | 密码 |'
- en: '| clab-netgo-srl | admin | admin |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| clab-netgo-srl | admin | admin |'
- en: '| clab-netgo-ceos | admin | admin |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| clab-netgo-ceos | admin | admin |'
- en: '| clab-netgo-cvx | cumulus | cumulus |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| clab-netgo-cvx | cumulus | cumulus |'
- en: Table 6.1 – Containerlab access credentials
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1 – Containerlab访问凭证
- en: 'For example, to access NVIDIA’s device via SSH, you would execute `ssh cumulus@clab-netgo-cvx`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要通过SSH访问NVIDIA的设备，您将执行`ssh cumulus@clab-netgo-cvx`：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you want to learn more about Containerlab or run this lab setup in the cloud,
    check out the instructions in the *Appendix* of this book.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于Containerlab的信息，或者想在云中运行此实验室设置，请查看本书*附录*中的说明。
- en: Interacting with network devices via SSH
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过SSH与网络设备交互
- en: '**Secure Shell** (**SSH**) is the predominant protocol that network engineers
    use to securely access and configure network devices via a **command-line interface**
    (**CLI**) that transports unstructured data to display to end users. This interface
    simulates a computer terminal, so we’ve used it traditionally for human interactions.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全外壳协议**（**SSH**）是网络工程师用来通过**命令行界面**（**CLI**）安全访问和配置网络设备的主要协议，该界面传输非结构化数据以显示给最终用户。该界面模拟计算机终端，因此我们传统上用它来进行人类交互。'
- en: One of the first steps network engineers take when they embark on the journey
    of automating mundane tasks is to create scripts that run a set of CLI commands
    for them in sequence to achieve an outcome. Otherwise, they would run the commands
    themselves interactively via an SSH pseudo-terminal.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 网络工程师在开始自动化日常任务之旅时采取的第一个步骤之一是创建脚本，这些脚本会按顺序运行一系列CLI命令以实现结果。否则，他们将通过SSH伪终端交互式地运行这些命令。
- en: While this gives us speed, this is not the only benefit of network automation.
    As we cover different technologies through the rest of this book, other benefits,
    such as reliability, repeatability, and consistency, to name a few, become a common
    theme. For now, we will start by crafting an SSH connection to a network device
    in Go and send configuration commands line by line, to then take advantage of
    a higher-level package in Go that abstracts away the connection details of the
    different networking vendors, making the development experience simpler for network
    engineers.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这为我们提供了速度，但这并不是网络自动化的唯一好处。随着我们在本书的其余部分介绍不同的技术，其他好处，如可靠性、可重复性和一致性等，成为了一个常见主题。现在，我们将从在Go中创建一个到网络设备的SSH连接开始，逐行发送配置命令，然后利用Go中更高层次的包，该包抽象了不同网络供应商的连接细节，使网络工程师的开发体验更加简单。
- en: Describing the network device configurations
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述网络设备配置
- en: The first task we want to do with Go is to configure each of the devices of
    the three-node topology we defined in the preceding section. As a learning exercise,
    we will create three different Go programs to configure each device independently
    so that you can contrast the different approaches. While each program is unique,
    they all follow the same design structure. One program uses SSH to connect and
    configure a device, another one uses Scrapligo, and the last one uses HTTP, as
    we’ll cover in the next section.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想用Go做的第一个任务是配置我们在上一节中定义的三个节点拓扑中的每个设备。作为一个学习练习，我们将创建三个不同的Go程序来独立配置每个设备，以便您可以对比不同的方法。虽然每个程序都是独特的，但它们都遵循相同的设计结构。一个程序使用SSH连接和配置设备，另一个使用Scrapligo，最后一个使用HTTP，我们将在下一节中介绍。
- en: 'To make the code examples meaningful, but at the same time not overly complicated,
    we have limited the device configurations to apply to the following sections:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码示例有意义，同时又不至于过于复杂，我们已将设备配置限制应用于以下部分：
- en: A unique IPv4 address on each of the transit links
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个中继链路上都有一个唯一的IPv4地址
- en: A **Border Gateway Protocol** (**BGP**) peering established between those IPs
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这些IP之间建立了一个**边界网关协议**（**BGP**）对等连接
- en: A unique loopback address that is also redistributed into BGP
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个唯一的环回地址，也被重新分配到BGP中
- en: The goal of these settings is to establish reachability between all three loopback
    interfaces.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置的目的是在所有三个环回接口之间建立可达性。
- en: 'In real-life automation systems, developers strive to find a common data model
    you can use to represent device configurations for any vendor. The two main examples
    of this are IETF and OpenConfig YANG models. We will do the same in this case
    by defining a standard schema for the input data we will use for all three network
    devices but using Go directly to define the data structures instead of the YANG
    modeling language. This schema has just enough information to meet the goal of
    establishing end-to-end reachability:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中的自动化系统中，开发人员努力寻找一个通用的数据模型，您可以使用它来表示任何供应商的设备配置。这个例子中的两个主要例子是IETF和OpenConfig
    YANG模型。我们将在这个案例中做同样的事情，通过定义我们将用于所有三个网络设备的标准输入数据模式，但直接使用Go来定义数据结构而不是YANG建模语言。此模式包含足够的信息以满足建立端到端可达性的目标：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In each of the programs, we supply the parameters to the data model to generate
    the device’s configuration via the `input.yml` file, which is available in the
    program’s folder. For the first example, this file looks as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个程序中，我们通过`input.yml`文件（该文件位于程序文件夹中）向数据模型提供参数，以生成设备的配置。对于第一个示例，此文件如下所示：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After we open this file for reading, we deserialize this information into an
    instance of a `Model` type – which represents the data model – with the `Decode`
    method. The following output represents these steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们打开此文件进行读取后，我们使用`Decode`方法将此信息反序列化为一个`Model`类型的实例 – 这代表数据模型。以下输出表示这些步骤：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Then, we pass the input variable (of the `Model` type) to a config generator
    function (`devConfig`), which transforms this information into syntax that the
    target device can understand. The result of this transformation is a vendor-specific
    configuration serialized into bytes that you can transfer to the remote device.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将输入变量（`Model`类型）传递给配置生成函数（`devConfig`），该函数将此信息转换为目标设备可以理解的语法。这种转换的结果是特定供应商的配置序列化为字节，您可以将其传输到远程设备。
- en: 'A transport library establishes the connection to the remote device using default
    credentials, which you can overwrite via command-line flags. The session we have
    created has an `io.Writer` element that we can use to send the configuration to
    the remote device:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 传输库使用默认凭据与远程设备建立连接，您可以通过命令行标志来覆盖这些凭据。我们创建的会话有一个`io.Writer`元素，我们可以使用它将配置发送到远程设备：
- en: '![Figure 6.2 – Program structure](img/B16971_06_02.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 程序结构](img/B16971_06_02.jpg)'
- en: Figure 6.2 – Program structure
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 程序结构
- en: Now that we’re familiar with the structure of the program, let’s explore different
    implementations of it to learn more about the Go packages that are available to
    communicate with network devices, starting with SSH and Scrapligo.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了程序的结构，让我们探索不同的实现来了解更多关于可用于与网络设备通信的Go包，从SSH和Scrapligo开始。
- en: Using Go’s SSH package to access network devices
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Go的SSH包访问网络设备
- en: The first device from the topology that we are configuring is the containerized
    Nokia `text/template` template package.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要配置的第一个设备是从拓扑中配置的容器化诺基亚`text/template`模板包。
- en: Go’s SSH package, `golang.org/x/crypto/ssh`, belongs to a set of packages that
    are still part of the Go project but developed outside the main Go tree under
    looser compatibility requirements. Although this is not the only SSH Go client,
    other packages tend to reuse parts of this package, so they become higher-level
    abstractions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的 SSH 包 `golang.org/x/crypto/ssh` 属于一组仍然是 Go 项目的一部分但开发在主 Go 树之外、兼容性要求更宽松的包。尽管这并非唯一的
    SSH Go 客户端，但其他包倾向于重用此包的部分，因此它们成为更高层次的抽象。
- en: 'As described in the general program design, we use the `Model` data structure
    to hold the device configuration inputs and merge them with the `srlTemplate`
    template to produce a valid device configuration as a buffer of bytes:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如一般程序设计所述，我们使用 `Model` 数据结构来保存设备配置输入，并将它们与 `srlTemplate` 模板合并，以生成有效的设备配置作为字节数据缓冲区：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `srlTemplate` constant has a template that starts by looping (using the
    `range` keyword) over the uplinks of a `Model` instance. For each `Link`, it takes
    the `Name` and `Prefix` properties of it to create a couple of CLI commands we
    can place in a buffer. In the following code, we are running the `Execute` method
    to pass the inputs via the `in` variable and put the binary representation of
    interactive CLI commands on `b`, which we later expect to send to the remote device
    (`cfg`):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`srlTemplate` 常量有一个模板，它首先通过（使用 `range` 关键字）遍历 `Model` 实例的上联。对于每个 `Link`，它取其
    `Name` 和 `Prefix` 属性来创建我们可以放置在缓冲区中的几个 CLI 命令。在下面的代码中，我们正在运行 `Execute` 方法，通过 `in`
    变量传递输入，并将交互式 CLI 命令的二进制表示放在 `b` 上，我们稍后预计将其发送到远程设备（`cfg`）：'
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We have hardcoded the authentication credentials to the correct values to fit
    the lab, but you can override them if necessary. We use these arguments to establish
    initial connectivity with the `srl` network device:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将认证凭据硬编码为正确的值以适应实验室，但如有必要，您可以覆盖它们。我们使用这些参数与 `srl` 网络设备建立初始连接：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If the authentication credentials are correct and there are no connectivity
    problems, the `ssh.Dial` function returns a connection handler (`conn`), representing
    a single SSH connection. This connection acts as a single transport for potentially
    various channels. One such channel is a pseudo-terminal session used for interactive
    communication with the remote device, but it may also include extra channels that
    you can use for port forwarding.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果认证凭据正确且没有连接问题，`ssh.Dial` 函数返回一个连接处理器（`conn`），代表一个单一的 SSH 连接。此连接作为可能各种通道的单个传输。其中一个通道是用于与远程设备进行交互式通信的伪终端会话，但它也可能包括额外的通道，您可以使用它们进行端口转发。
- en: 'The following code snippet spawns a new terminal session and sets the expected
    terminal parameters, such as terminal height, width, and `ssh.Session` type provides
    functions to retrieve standard input and standard output pipes that connect to
    the remote terminal:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段启动一个新的终端会话并设置预期的终端参数，例如终端高度、宽度和 `ssh.Session` 类型提供的函数用于检索连接到远程终端的标准输入和标准输出管道：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In conformance with the rest of the Go packages, standard input and standard
    output pipes implement the `io.Writer` and `io.Reader` interfaces, respectively.
    This means you can use them to write data in to and read output from the remote
    network device. We will go back to the `cfg` buffer with the CLI config and use
    the `WriteTo` method to send this config over to the target node:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Go 包的其他部分一致，标准输入和标准输出管道分别实现了 `io.Writer` 和 `io.Reader` 接口。这意味着您可以使用它们向远程网络设备写入数据并从其读取输出。我们将回到带有
    CLI 配置的 `cfg` 缓冲区，并使用 `WriteTo` 方法将此配置发送到目标节点：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is the expected output of this program:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是此程序的预期输出：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can find the complete example in the `ch06/ssh` folder (*Further reading*).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `ch06/ssh` 文件夹中找到完整的示例（*进一步阅读*）。
- en: Automating routine SSH tasks
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化常规 SSH 任务
- en: Common network elements, such as routers and switches, display data for people
    rather than computers via the CLI. We rely on screen scraping to let our programs
    consume this human-readable data. One popular screen-scraping Python library,
    whose name comes from *scrape cli*, is Scrapli.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的网络元素，如路由器和交换机，通过 CLI 向人们显示数据而不是计算机。我们依赖于屏幕抓取让我们的程序消费这种可读数据。一个流行的屏幕抓取 Python
    库，其名称来自 *scrape cli*，是 Scrapli。
- en: Scrapli has a version in Go, which we will explore in the following example,
    called Scrapligo. The goal of this package is to offer the next layer of abstraction
    on top of SSH and hide away some transport complexities while providing several
    convenient functions and supporting the CLI flavors of different networking vendors.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Scrapli 有一个 Go 版本，我们将在下面的示例中探索，称为 Scrapligo。这个包的目标是在 SSH 之上提供下一层的抽象，同时隐藏一些传输复杂性，并提供几个方便的功能，并支持不同网络供应商的
    CLI 风格。
- en: 'To show `scrapligo` in action, we will configure another network device in
    the topology: Arista’s cEOS (`ceos`). Just like we did with `srl`, we will use
    a list of CLI commands to push the desired network state so that the initial steps
    of parsing and instantiating a string from a template are the same. What changes
    is the template, which uses Arista EOS’s syntax:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示 `scrapligo` 的实际应用，我们将在拓扑中配置另一个网络设备：Arista 的 cEOS (`ceos`)。就像我们使用 `srl`
    一样，我们将使用一系列 CLI 命令来推送所需的网络状态，这样解析和从模板实例化字符串的初始步骤就相同了。变化的是模板，它使用了 Arista EOS 的语法：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The difference starts when we get to the SSH connection setup. We create a
    device driver (`GetNetworkDriver`) to connect to the remote device with the device
    hostname and authentication credentials. The platform definition comes from the
    `platform` package of `scrapligo`. From then on, it only takes a single method
    call on this driver to open an SSH connection to the remote device:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 差异开始于我们到达 SSH 连接设置时。我们创建一个设备驱动程序 (`GetNetworkDriver`) 来连接到远程设备，使用设备主机名和认证凭证。平台定义来自
    `scrapligo` 的 `platform` 包。从那时起，只需对这个驱动程序进行一次方法调用即可打开到远程设备的 SSH 连接：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'One of the extra features that `scrapli` offers is the `cscrapligocfg` package,
    which defines a high-level API to work with a remote network device’s configuration.
    This API understands different CLI flavors, it can sanitize a configuration before
    sending it to the device, and it can generate configuration diffs for us. But,
    most importantly, this package allows for a single function call to load the entire
    device configuration as a string, taking care of things such as privilege escalation
    and configuration merging or replacement. We will do this here with the `LoadConfig`
    method:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`scrapli` 提供的一个额外功能是 `cscrapligocfg` 包，它定义了一个高级 API 来与远程网络设备的配置一起工作。这个 API
    理解不同的 CLI 风格，它可以在发送到设备之前清理配置，并为我们生成配置差异。但最重要的是，这个包允许通过单个函数调用将整个设备配置作为字符串加载，处理诸如权限提升和配置合并或替换等问题。我们将使用
    `LoadConfig` 方法来完成这项工作：'
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'These are all the steps you need to configure the device in this case. After
    you run the program with `go run`, you can `ssh` to the device to check that the
    configuration is now there:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是在这种情况下配置设备所需的步骤。运行程序后使用 `go run`，你可以使用 `ssh` 连接到设备以检查配置是否已经存在：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Normally, to get a response coming back from a device, we need to read the response
    buffer carefully until we see a command-line prompt, as it normally ends with
    an `scrapligo` can do this for us by reading the received buffer and converting
    the response into a string.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，为了从设备获取响应，我们需要仔细读取响应缓冲区，直到我们看到命令行提示符，因为它通常以 `scrapligo` 可以为我们完成这项工作，通过读取接收到的缓冲区并将响应转换为字符串。
- en: Another popular Go SSH package that provides a high-level API to execute commands
    at scale is `yahoo/vssh`. We won’t cover it here, but you can find an example
    in the `ch06/vssh` directory of this book’s repository (*Further reading*) to
    configure the network devices of the topology.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个流行的 Go SSH 包，提供执行大量命令的高级 API 是 `yahoo/vssh`。这里我们不会涉及它，但你可以在本书仓库的 `ch06/vssh`
    目录中找到一个示例（*进一步阅读*），以配置拓扑中的网络设备。
- en: Interacting with network devices via HTTP
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 HTTP 与网络设备交互
- en: Over the last decade, networking vendors have begun to include **application
    programming interfaces** (**APIs**) to manage their devices as a supplement to
    the CLI. It’s not uncommon to find network devices with a robust RESTful API that
    gives you read and write access to it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去十年中，网络设备供应商开始包括 **应用程序编程接口** (**API**) 来管理他们的设备，作为 CLI 的补充。发现具有强大 RESTful
    API 的网络设备并不罕见，这些 API 可以提供对该设备的读写访问。
- en: A RESTful API is a stateless client-server communication architecture that runs
    over HTTP. The request and responses generally transport structured data (JSON,
    XML, and so on), but they might as well carry plain text. This makes the RESTful
    API a better-suited interface for machine-to-machine interactions.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API是一种无状态的客户端-服务器通信架构，它运行在HTTP之上。请求和响应通常传输结构化数据（JSON、XML等），但它们也可以携带纯文本。这使得RESTful
    API更适合机器之间的交互。
- en: Using Go’s HTTP package to access network devices
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Go的HTTP包访问网络设备
- en: The remaining device to configure is NVIDIA’s Cumulus Linux (`cvx`). We will
    use its OpenAPI-based RESTful API to configure it. We will encode the configuration
    in a JSON message and send it over an HTTP connection with Go’s `net/http` package.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下要配置的设备是NVIDIA的Cumulus Linux（`cvx`）。我们将使用其基于OpenAPI的RESTful API来配置它。我们将配置编码在一个JSON消息中，并通过Go的`net/http`包发送一个HTTP连接。
- en: As in the SSH examples, we normally load the input data and transform it into
    the shape the target device expects with the `devConfig` function, but in this
    case, it’s a JSON payload. Because of this, we no longer need templates to build
    the network device configuration, as we can now use data structures in Go to encode
    and decode data from JSON or any other encoding format.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与SSH示例一样，我们通常使用`devConfig`函数加载输入数据并将其转换为目标设备期望的形状，但在这个案例中，它是一个JSON有效负载。正因为如此，我们不再需要模板来构建网络设备配置，因为我们现在可以使用Go中的数据结构来编码和解码来自JSON或其他任何编码格式的数据。
- en: 'The data structures represent the configuration data model of the target device.
    Ideally, this data model would match the one we defined previously, so we don’t
    need to define anything else. But that’s not what we see in the field, where all
    the network vendors have proprietary data models. The good news is that both IETF
    and OpenConfig offer vendor-agnostic models; we’ll explore these later in [*Chapter
    8*](B16971_08.xhtml#_idTextAnchor182), *Network APIs*. For now, these are some
    of the data structures we will use for this device’s configuration:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构表示目标设备的配置数据模型。理想情况下，这个数据模型应该与我们之前定义的相匹配，这样我们就不需要定义其他任何内容。但在实际应用中，我们看到所有网络供应商都有自己的数据模型。好消息是，IETF和OpenConfig都提供了供应商无关的模型；我们将在[*第8章*](B16971_08.xhtml#_idTextAnchor182)“网络API”中稍后探讨这些内容。现在，我们将使用以下数据结构为此设备的配置：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Inside the main function, we parse the program flags and use them to store
    the HTTP connection settings inside a data structure with all the details required
    to build an HTTP request, including any non-default transport settings for an
    HTTP client. We do this entirely for convenience purposes as we want to pass these
    details to different functions:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数内部，我们解析程序标志并使用它们将HTTP连接设置存储在一个数据结构中，该数据结构包含构建HTTP请求所需的所有详细信息，包括HTTP客户端的非默认传输设置。我们这样做完全是出于方便，因为我们想将这些详细信息传递给不同的函数：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, we can send the configuration over and make it a candidate config on the
    target device. We can later apply this configuration on the device by referencing
    the revision ID we associate our desired configuration with. Let’s look at the
    steps to do this that showcase different attributes to consider when working with
    HTTP.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以发送配置并将其作为目标设备上的候选配置。我们可以通过引用我们与所需配置关联的修订ID来在设备上应用此配置。让我们看看执行此操作的步骤，这些步骤展示了在处理HTTP时需要考虑的不同属性。
- en: 'First, we will create a new revision ID, which we include as a query parameter
    `(?rev=<revisionID>`) in the URL to connect to the device API. Now, the `addr`
    is variable the target device URL that contains `device hostname` and `revisionID`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个新的修订ID，并将其作为查询参数`(?rev=<revisionID>`)包含在URL中，以便连接到设备API。现在，`addr`是包含`设备主机名`和`修订ID`的目标设备URL：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With the URL linked to the revision ID, we put together the PATCH request for
    the configuration change. This points to `addr` and `cfg`, which is the JSON device
    configuration that the `devConfig` function returns. We also add an HTTP `Authorization`
    header with the encoded username and password and signal that the payload is a
    JSON message:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过链接到修订ID的URL，我们组装了配置更改的PATCH请求。这指向`addr`和`cfg`，即`devConfig`函数返回的JSON设备配置。我们还添加了一个带有编码的用户名和密码的HTTP
    `Authorization`头，并指示有效负载是一个JSON消息：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Once we have the HTTP request built, we can pass it to the device HTTP client’s
    method, `Do`, which serializes everything into a binary format, sets up a TCP
    session, and sends the HTTP request over it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们构建了 HTTP 请求，我们就可以将其传递给设备 HTTP 客户端的 `Do` 方法，该方法将所有内容序列化为二进制格式，设置 TCP 会话，并通过它发送
    HTTP 请求。
- en: 'Finally, to apply the candidate configuration changes, we must make another
    PATCH request inside the `applyRevision` function:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了应用候选配置更改，我们必须在 `applyRevision` 函数内部进行另一个 PATCH 请求：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can find the code for this example in the `ch06/http` directory of this
    book’s GitHub repository (*Further reading*). This is what you should see when
    you run this program:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书 GitHub 存储库的 `ch06/http` 目录中找到这个例子的代码（*进一步阅读*）。运行此程序时您应该看到以下内容：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Just like with SSH, we rarely use `net/http` directly in our programs to interact
    with a REST API and normally use a higher-level package instead.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 就像使用 SSH 一样，我们很少在我们的程序中直接使用 `net/http` 来与 REST API 交互，通常使用更高级别的包。
- en: Getting config inputs from other systems via HTTP
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 HTTP 从其他系统获取配置输入
- en: Until this point, the data to generate a particular device configuration has
    come from a static file that is present in the program’s folder. These values
    are network device vendor-agnostic.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，生成特定设备配置的数据一直来自程序文件夹中存在的静态文件。这些值是网络设备厂商无关的。
- en: In real-world network automation systems, these values can come from other systems.
    For example, an **IP address management** (**IPAM**) tool can allocate IP addresses
    dynamically via a REST API call for a particular device, which you can use to
    build its configuration. The collection of systems that supply these parameters
    becomes what some refer to as the *source of truth*. Nautobot is an infrastructure
    resource modeling application that falls into this category.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的网络自动化系统中，这些值可以来自其他系统。例如，一个 **IP 地址管理**（**IPAM**）工具可以通过对特定设备的 REST API
    调用动态分配 IP 地址，您可以使用这些地址来构建其配置。提供这些参数的系统集合成为一些人所说的 *真相来源*。Nautobot 是一个基础设施资源建模应用程序，属于这一类别。
- en: This also highlights the fact that to automate networks, we not only need to
    interact with network devices but also integrate with other systems such as Nautobot.
    This is why we are dedicating this example to exploring how to Go use to interact
    with a free public instance of Nautobot available for anyone at [https://demo.nautobot.com/](https://demo.nautobot.com/).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这也突出了这样一个事实，为了自动化网络，我们不仅需要与网络设备交互，还需要与其他系统（如 Nautobot）集成。这就是为什么我们将这个例子专门用于探索如何使用
    Go 与 Nautobot 的免费公共实例交互，该实例对任何人都可以在 [https://demo.nautobot.com/](https://demo.nautobot.com/)
    上访问。
- en: The Go client package for Nautobot is automatically generated from its OpenAPI
    specification, which means its structure might be familiar to you if you have
    already worked with other OpenAPI-derived packages, which is an advantage of machine-generated
    code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Nautobot 的 Go 客户端包是从其 OpenAPI 规范自动生成的，这意味着如果您已经与其他 OpenAPI 衍生的包合作过，其结构可能对您来说很熟悉，这是机器生成代码的一个优点。
- en: 'In the following example, we are using the auto-generated Nautobot Go package
    to define a Nautobot API client pointing to [https://demo.nautobot.com/](https://demo.nautobot.com/)
    with an API token:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们使用自动生成的 Nautobot Go 包来定义一个指向 [https://demo.nautobot.com/](https://demo.nautobot.com/)
    的 Nautobot API 客户端，并使用 API 令牌：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `c` client allows us to interact with the remote Nautobot instance. In
    this example, we want to add one of the lab topology nodes (`ceos`) to the `device.json`
    file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`c` 客户端使我们能够与远程 Nautobot 实例进行交互。在这个例子中，我们想要将实验室拓扑中的一个节点（`ceos`）添加到 `device.json`
    文件中：'
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Before we can add the device to Nautobot, we must make sure the device type,
    device role, and site we are referencing in the `device.json` file exist by name
    already in Nautobot. The `createResources` function takes care of this. Then,
    we get the IDs of these resources (device type, device role, and site) with the
    `getDeviceIDs` function, to associate the new device with its type, role, and
    site:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够将设备添加到 Nautobot 之前，我们必须确保在 `device.json` 文件中引用的设备类型、设备角色和站点名称已经在 Nautobot
    中存在。`createResources` 函数负责这一点。然后，我们使用 `getDeviceIDs` 函数获取这些资源的 ID（设备类型、设备角色和站点），以便将新设备与其类型、角色和站点关联：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If the device is not already in Nautobot, we can create it with the auto-generated
    `DcimDevicesCreateWithResponse` function:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备尚未在 Nautobot 中，我们可以使用自动生成的 `DcimDevicesCreateWithResponse` 函数创建它：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After running the program with `go run nautobot` from the `ch06/nautobot` folder,
    you should see the following in the Nautobot graphical interface at [https://demo.nautobot.com/](https://demo.nautobot.com/):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在从`ch06/nautobot`文件夹中运行`go run nautobot`程序后，你应该在Nautobot图形界面中看到以下内容：[https://demo.nautobot.com/](https://demo.nautobot.com/)
- en: '![Figure 6.3 – Nautobot screenshot](img/B16971_06_03.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – Nautobot截图](img/B16971_06_03.jpg)'
- en: Figure 6.3 – Nautobot screenshot
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – Nautobot截图
- en: The data that we pass to these Dcim functions ends up in HTTP requests, just
    like the ones we built manually earlier in this chapter. Here, we don’t deal with
    URL queries, HTTP paths, or JSON payloads directly as the package abstracts away
    all that from us. This allows the developers to focus more on business value and
    less on implementation details. It makes the API easier to consume.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给这些Dcim函数的数据最终会出现在HTTP请求中，就像我们在本章前面手动构建的那些一样。在这里，我们不需要直接处理URL查询、HTTP路径或JSON有效负载，因为这个包为我们抽象了所有这些。这允许开发者更多地关注业务价值，而不是实现细节。这使得API更容易使用。
- en: The focus of this chapter so far has been more on pushing configurations down
    to network devices and less on reading the state of the network after this operation.
    While configuration management’s primary focus is on producing and deploying configurations
    in the correct format, state validation can play a key role in verifying your
    configuration changes have been successful. In the next section, we will learn
    how to retrieve and parse operational data from a remote device.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章的重点更多地在于将配置推送到网络设备，而不是在操作之后读取网络的状态。虽然配置管理的重点是产生和部署正确格式的配置，但状态验证可以在验证配置更改是否成功中发挥关键作用。在下一节中，我们将学习如何从远程设备检索和解析操作数据。
- en: State validation
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态验证
- en: The way network devices model and store their state internally is often different
    from their configuration data model. Traditional CLI-first network devices display
    the state in a tabular format to the end user, making it easier for network operators
    to interpret and reason about it. In API-enabled network operating systems, they
    can present the state in a structured format, making the data friendlier for automation,
    but we still need to prepare the right data model for deserialization.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 网络设备内部建模和存储其状态的方式通常与其配置数据模型不同。传统的以CLI为主的网络设备以表格格式向最终用户显示状态，这使得网络操作员更容易解释和推理。在具有API的网络操作系统上，它们可以以结构化格式呈现状态，使数据更适合自动化，但我们仍然需要准备正确的数据模型以进行反序列化。
- en: 'In this section, we will look at three different methods you could use to read
    the state from a network device through a code example that gathers operational
    data from the devices we just configured with `crypto/ssh`, `net/http`, and `scrapligo`
    in the preceding sections of this chapter. For each network device, we will use
    one of these resources to get the data in the format we need:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过一个代码示例来查看三种不同的方法，您可以使用这些方法从网络设备读取状态，该示例从本章前面几节中用`crypto/ssh`、`net/http`和`scrapligo`配置的设备中收集操作数据。对于每个网络设备，我们将使用这些资源之一来获取我们所需格式的数据：
- en: '**RESTful API calls**: To retrieve and parse data from an HTTP interface'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RESTful API调用**：用于从HTTP接口检索和解析数据'
- en: '**Regular expressions**: To parse plain text received via SSH'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正则表达式**：用于解析通过SSH接收的纯文本'
- en: '**TextFSM templates**: To simplify parsing tabular data'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TextFSM模板**：用于简化解析表格数据'
- en: Checking routing information
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查路由信息
- en: At this point, you should have a three-node topology running. Each network device
    has a loopback address we redistribute into BGP. Arista cEOS’s loopback address
    is `198.51.100.1/32`, for example. The goal of the next program is to verify the
    setup. We retrieve the routing table information from every device to check whether
    all three IPv4 loopback addresses are present. This way, we can verify our configuration
    intent – established end-to-end reachability between all devices.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该有一个三个节点的拓扑运行。每个网络设备都有一个回环地址，我们将它重新分配到BGP中。例如，Arista cEOS的回环地址是`198.51.100.1/32`。下一个程序的目标是验证设置。我们从每个设备检索路由表信息，以检查是否所有三个IPv4回环地址都存在。这样，我们可以验证我们的配置意图——在所有设备之间建立端到端可达性。
- en: 'The program has two building blocks:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 程序有两个构建块：
- en: '`GetRoutes`: A method that connects to the network device, gets the information
    we need, and puts it in a common format'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetRoutes`：一个连接到网络设备、获取所需信息并将其放入通用格式的方法'
- en: '`checkRoutes`: A function that reads the routes from `GetRoutes` and compares
    them to the list of loopback addresses we expect to see (`expectedRoutes`)'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`checkRoutes`：一个函数，它从`GetRoutes`读取路由，并将其与我们期望看到的环回地址列表（`expectedRoutes`）进行比较'
- en: 'One caveat is that the API type a network device supports to access its operational
    data remotely may vary, from the transport protocol to the format of the textual
    representation of the data. In our example, this translates into different implementation
    details of `GetRoutes` per networking vendor. Here, we take it a bit to the extreme
    for educational purposes and make the implementation per vendor completely different
    from one another to showcase REST APIs, regular expressions, and TextFSM independently:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一个需要注意的问题是，网络设备支持的API类型可能因传输协议和数据文本表示的格式而异。在我们的例子中，这转化为不同网络供应商的`GetRoutes`实现细节的不同。在这里，为了教育目的，我们将每个供应商的实现做得完全不同，以独立展示REST
    API、正则表达式和TextFSM：
- en: '![Figure 6.4 – Checking routing information](img/B16971_06_04.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 – 检查路由信息](img/B16971_06_04.jpg)'
- en: Figure 6.4 – Checking routing information
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 检查路由信息
- en: Each network device has its own data structure. For example, we create SRL for
    SR Linux. The `SRL`, `CVX`, and `CEOS` types implement the `Router` interface,
    as each one has a `GetRoutes` method that contains the implementation details
    for that specific vendor.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 每个网络设备都有自己的数据结构。例如，我们为SR Linux创建了SRL。`SRL`、`CVX`和`CEOS`类型实现了`Router`接口，因为每个都有一个包含特定供应商实现细节的`GetRoutes`方法。
- en: 'In the main program, a user only needs to initialize the devices with the authentication
    details, so it creates a variable of the type we created for that device. Then,
    it can run the route collection tasks concurrently by firing off a goroutine for
    each device that runs the device type’s `GetRoutes` method. The `Router` interface
    successfully hides away the implementation details of a particular vendor from
    the user, as the call is always the same `router.GetRoutes`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在主程序中，用户只需要用认证详情初始化设备，因此它创建了一个为我们创建的那种类型的变量。然后，它可以通过为每个设备启动一个运行设备类型`GetRoutes`方法的goroutine来并发运行路由收集任务。`Router`接口成功地隐藏了特定供应商的实现细节，因为调用始终是相同的`router.GetRoutes`：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Because all `GetRoutes` instances run in the background in their own goroutine,
    we added a `wg` wait group to make sure we don’t finish the main goroutine until
    we have collected and verified all the devices. Before the end of each `GetRoutes`
    method, we call the `expectedRoutes` function to process the routes we get from
    that device.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有`GetRoutes`实例都在各自的goroutine中后台运行，我们添加了一个`wg`等待组，以确保在收集和验证所有设备之前，我们不结束主goroutine。在每个`GetRoutes`方法结束之前，我们调用`expectedRoutes`函数来处理从该设备获取的路由。
- en: 'We verify the parsed state (routes) by checking that each `expectedRoutes`,
    which contains a unique set of loopback addresses, is present in each device’s
    routing table. For every IPv4 prefix received, we check whether it’s present in
    `expectedRoutes` and change a boolean flag to signal this. If, by the end of this,
    we have prefixes in `expectedRoutes` with a Boolean value of `false`, it means
    they were not present in the device’s routing table, and we create a log message:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过检查每个包含唯一一组环回地址的`expectedRoutes`是否存在于每个设备的路由表中来验证解析后的状态（路由）。对于收到的每个IPv4前缀，我们检查它是否存在于`expectedRoutes`中，并更改一个布尔标志来表示这一点。如果到最后，`expectedRoutes`中存在布尔值为`false`的前缀，这意味着它们没有出现在设备的路由表中，我们将创建一个日志消息：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Following this, we examine each of the `GetRoutes` method implementations. As
    with the rest of the examples, you can find the complete program in the `ch06/state`
    folder of this book’s GitHub repository (*Further reading*).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们检查每个`GetRoutes`方法实现。与其它示例一样，你可以在本书GitHub仓库的`ch06/state`文件夹中找到完整的程序（*进一步阅读*）。
- en: Parsing command outputs with regular expressions
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用正则表达式解析命令输出
- en: We use regular expressions to parse and extract information from unstructured
    data. The Go standard library includes the `regexp` package, which understands
    the RE2 syntax. This is a regular expression library designed with safety as one
    of its primary goals. One of the main consequences of that decision is the lack
    of back-references and look-around operations, which are unsafe and can lead to
    denial of service exploits.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用正则表达式解析和从非结构化数据中提取信息。Go标准库包括`regexp`包，它理解RE2语法。这是一个以安全性作为其主要目标的正则表达式库。该决策的一个主要后果是缺乏回溯和前瞻操作，这些操作是不安全的，可能导致拒绝服务攻击。
- en: 'In this case, the `GetRoutes` method uses `scrapligo` to connect and sends
    a `show` command to extract the routing table information from an SRL device type
    in this case. One way to parse this information is to iterate over the output
    line by line while matching expected patterns with regular expressions, close
    to what we did for the `ch05/closed-loop` example (*Further reading*):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`GetRoutes`方法使用`scrapligo`连接并发送一个`show`命令，从本例中的SRL设备类型中提取路由表信息。解析这些信息的一种方法是一行一行地迭代输出，同时使用正则表达式匹配预期的模式，这接近我们在`ch05/closed-loop`示例中做的事情（*进一步阅读*）：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To make things a bit simpler, we assume that anything that matches the IPv4
    address pattern in the entire output is a prefix installed in the routing table.
    This way, instead of reading and parsing a tabular data structure, we tell our
    program to find all text occurrences that match the IPv4 route pattern and put
    them on a string slice (`out`) that we pass to the `checkRoutes` function for
    further processing.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更简单一些，我们假设整个输出中与IPv4地址模式匹配的任何内容都是在路由表中安装的前缀。这样，我们就不需要读取和解析表格数据结构，而是告诉我们的程序找到所有匹配IPv4路由模式的文本出现，并将它们放在我们传递给`checkRoutes`函数以进行进一步处理的字符串切片（`out`）中。
- en: Parsing semi-formatted command outputs with templates
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用模板解析半格式化的命令输出
- en: Parsing various output formats with regular expressions can be tedious and error-prone.
    This is why Google created `TextFSM`, initially as a Python library, to implement
    a template-based parsing of semi-formatted text. They designed it specifically
    to parse information from network devices and it has a wide range of community-developed
    templates maintained in **ntc-templates** (*Further reading*).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正则表达式解析各种输出格式可能会很繁琐且容易出错。这就是为什么谷歌创建了`TextFSM`，最初作为一个Python库，以实现基于模板的半格式化文本解析。他们专门设计它来解析来自网络设备的信息，并且它有一个广泛的社区开发模板，维护在**ntc-templates**（*进一步阅读*）中。
- en: 'We will use one of these community templates to parse the `ip` route command’s
    output in the implementation of `GetRoutes` for Arista cEOS. Scrapligo embeds
    a Go port of TextFSM and can conveniently parse the response using the `TextFsmParse`
    function:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这些社区模板之一来解析`GetRoutes`实现中Arista cEOS的`ip`路由命令的输出。Scrapligo嵌入了一个TextFSM的Go端口，并可以使用`TextFsmParse`函数方便地解析响应：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `parsed` variable that stores the parsed data is a slice that contains `map[string]interface{}`
    values, where keys correspond to the TextFSM values defined in a template. Thus,
    just by looking at the `show ip route` template, we can extract the network and
    mask (prefix length) information and append it to a string slice (`out`) that
    we pass to the `checkRoutes` function for further processing.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 存储解析数据的`parsed`变量是一个包含`map[string]interface{}`值的切片，其中键对应于模板中定义的TextFSM值。因此，仅通过查看`show
    ip route`模板，我们就可以提取网络和掩码（前缀长度）信息，并将其追加到我们传递给`checkRoutes`函数以进行进一步处理的字符串切片（`out`）中。
- en: Getting JSON-formatted data with REST API requests
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用REST API请求获取JSON格式化的数据
- en: Thus far in this chapter, we’ve seen two different ways of interacting with
    a REST API – one using the `net/http` package and another using an auto-generated
    high-level package (`nautobot`). But you also have other options, such as `go-resty`,
    which builds on top of `net/http` to offer an improved user experience when interacting
    with REST API endpoints.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们看到了两种与REST API交互的不同方式——一种使用`net/http`包，另一种使用自动生成的面向高级的包（`nautobot`）。但您还有其他选择，例如`go-resty`，它建立在`net/http`之上，以提供与REST
    API端点交互时改进的用户体验。
- en: 'In the following implementation of `GetRoutes`, we are taking advantage of
    `go-resty` to build the required HTTP headers for authentication, extend the URL
    with query parameters, and unmarshal a response into a user-defined data structure
    (`routes`):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下`GetRoutes`的实现中，我们利用`go-resty`构建所需的HTTP头以进行身份验证，通过查询参数扩展URL，并将响应反序列化到用户定义的数据结构（`routes`）中：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We have created a REST API client to request the routing table information (`...rib/ipv4/route`)
    from the target device (type CVX). We decoded the JSON payload response with the
    routing table prefixes as keys into the `routes` variable of the `map[string]interface{}`
    type. Next, we looped through `routes` to append all keys to a string slice (`out`)
    we can pass to the `checkRoutes` function.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已创建了一个REST API客户端，用于从目标设备（类型CVX）请求路由表信息（`...rib/ipv4/route`）。我们使用路由表前缀作为键将JSON有效负载响应解码到`map[string]interface{}`类型的`routes`变量中。接下来，我们遍历`routes`，将所有键追加到一个字符串切片（`out`）中，我们可以将其传递给`checkRoutes`函数。
- en: Validating end-to-end reachability
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证端到端可达性
- en: 'You can run this program to check whether all three routers in the topology
    can reach one another from the `ch06/state` folder (*Further reading*). Make sure
    all the devices have the configs from the examples that used `crypto/ssh`, `net/http`,
    and `scrapligo` to configure them earlier in this chapter. The expected output
    should look as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从`ch06/state`文件夹运行此程序来检查拓扑中的所有三个路由器是否可以从彼此访问（*进一步阅读*）。确保所有设备都具有从本章早期使用`crypto/ssh`、`net/http`和`scrapligo`配置它们的示例配置。预期的输出应如下所示：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If any of the routes were not present on any of the devices, we would’ve seen
    messages such as these:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何路由在任何设备上不存在，我们会看到如下消息：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Configuration generation, deployment, reporting, and compliance remain the most
    popular network automation operations. This is where the immediate benefits of
    introducing automation are greatest and most visible, making it the first logical
    step into the world of automation and DevOps. Configuration management is one
    of those repetitive tasks network engineers spend most of their time on, so it’s
    a natural fit for automation. But sending a new configuration to a device is just
    part of a broader process that should consider failure handling, from syntax errors
    in the configuration to how to recover properly if the connection to a remote
    device drops. In this context, you can abstract some repetitive tasks with reusable
    code that offers generic functionality to reduce the time and effort to automate
    your use cases. This is what automation frameworks offer, which we will discuss
    in the next chapter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 配置生成、部署、报告和合规性仍然是网络自动化操作中最受欢迎的操作。这就是引入自动化带来的即时效益最大、最明显的地方，使其成为进入自动化和DevOps世界的第一步逻辑步骤。配置管理是网络工程师花费大部分时间进行的那些重复性任务之一，因此它非常适合自动化。但是，将新的配置发送到设备只是更广泛流程的一部分，该流程应考虑故障处理，从配置中的语法错误到如何正确恢复与远程设备的连接中断。在这种情况下，您可以使用可重用代码抽象一些重复性任务，这些代码提供通用功能，以减少自动化用例的时间和努力。这正是自动化框架所提供的，我们将在下一章中讨论。
- en: Further reading
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章所涉及的主题，请查看以下资源：
- en: 'NetDevOps 2020 Survey: [https://dgarros.github.io/netdevops-survey/reports/2020](https://dgarros.github.io/netdevops-survey/reports/2020)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NetDevOps 2020调查：[https://dgarros.github.io/netdevops-survey/reports/2020](https://dgarros.github.io/netdevops-survey/reports/2020)
- en: '`topo` directory: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/topo-base/topo.yml](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/topo-base/topo.yml)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`topo` 目录：[https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/topo-base/topo.yml](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/topo-base/topo.yml)'
- en: '`ch06/ssh` folder: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch06/ssh](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch06/ssh)'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch06/ssh` 文件夹：[https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch06/ssh](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch06/ssh)'
- en: '`ch06/vssh` directory: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch06/vssh](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch06/vssh)'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch06/vssh` 目录：[https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch06/vssh](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch06/vssh)'
- en: '`ch06/http` directory: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch06/http](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch06/http)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch06/http` 目录：[https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch06/http](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch06/http)'
- en: 'demo.nautobot.com: [https://demo.nautobot.com/](https://demo.nautobot.com/)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: demo.nautobot.com：[https://demo.nautobot.com/](https://demo.nautobot.com/)
- en: '`ch06/state` directory: https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch06/ssh'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch06/state` 目录: https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch06/ssh'
- en: '`ch05/closed-loop` example: https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch05/closed-loop/main.go#L138'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch05/closed-loop` 示例: https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch05/closed-loop/main.go#L138'
- en: 'ntc-templates: [https://github.com/networktocode/ntc-templates](https://github.com/networktocode/ntc-templates)'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ntc-templates: [https://github.com/networktocode/ntc-templates](https://github.com/networktocode/ntc-templates)'
