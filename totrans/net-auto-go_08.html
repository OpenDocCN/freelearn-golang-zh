<html><head></head><body>
<div id="_idContainer074">
<h1 class="chapter-number" id="_idParaDest-183"><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-184"><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.2.1">Network APIs</span></h1>
<p><span class="koboSpan" id="kobo.3.1">As the ways we build, deploy, and operate networks evolve, new protocols and interfaces are emerging to ease machine-to-machine communication—a primary enabler of network automation. </span><span class="koboSpan" id="kobo.3.2">In this and the following chapters, we’ll navigate through some of these new capabilities and explore how to take advantage of them in the context of the Go </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">programming language.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">The network </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">Command-Line Interface</span></strong><span class="koboSpan" id="kobo.7.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.8.1">CLI</span></strong><span class="koboSpan" id="kobo.9.1">) is what we, network engineers, have used for decades to operate and manage network devices. </span><span class="koboSpan" id="kobo.9.2">As we move toward a more programmatic approach to managing networks, simply relying on faster CLI command execution might not be enough to deploy network automation solutions </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">at scale.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">Solutions that don’t have a strong foundation are brittle and unstable. </span><span class="koboSpan" id="kobo.11.2">Hence, when possible, we prefer to build network automation projects based on structured data and machine-friendly </span><strong class="bold"><span class="koboSpan" id="kobo.12.1">Application Programming Interfaces</span></strong><span class="koboSpan" id="kobo.13.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.14.1">APIs</span></strong><span class="koboSpan" id="kobo.15.1">). </span><span class="koboSpan" id="kobo.15.2">The target use case for these interfaces isn’t direct human interaction, so you can rely on Go to translate between remote API calls and a local, </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">user-facing interface.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">When we talk about APIs, we generally refer to different things that make up the API developer experience, which you need to consider when evaluating </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">an API:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.19.1">A set of </span><strong class="bold"><span class="koboSpan" id="kobo.20.1">Remote Procedure Calls</span></strong><span class="koboSpan" id="kobo.21.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.22.1">RPCs</span></strong><span class="koboSpan" id="kobo.23.1">) defining the rules of interaction between a client and a server—at the very least, this would include a standard set of create, get, update, and </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">delete operations.</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">The structure and data type exchanged—product vendors can define this using data model specification languages such as YANG </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">or OpenAPI.</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">The underlying protocol that wraps the modeled data, which you can serialize into one of the standard formats, such as XML or JSON, and transports it between a client and a server—this could be SSH or, more often these </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">days, HTTP.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.29.1">In the networking world, we have another dimension in the API landscape that determines the origin of a model specification document. </span><span class="koboSpan" id="kobo.29.2">While every networking vendor is free to write their own data models, there are two sources of vendor-agnostic models—IETF and OpenConfig—that strive to offer a vendor-neutral way of configuring and monitoring network devices. </span><span class="koboSpan" id="kobo.29.3">Because of this variability in the API ecosystem, it’s impossible to cover all protocols and standards, so in this chapter, we’ll only cover a subset of network APIs, selected based on availability, practicality, </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">and usefulness:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.31.1">We’ll start by looking at OpenAPI as one of the most prevalent API specification standards in a wider </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">infrastructure landscape.</span></span></li>
<li><span class="koboSpan" id="kobo.33.1">We’ll then move on to JSON-RPC, which uses vendor-specific </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">YANG models.</span></span></li>
<li><span class="koboSpan" id="kobo.35.1">After that, we’ll show an example of an RFC-standard HTTP-based protocol </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">called RESTCONF.</span></span></li>
<li><span class="koboSpan" id="kobo.37.1">Finally, we’ll look at how you can leverage </span><strong class="bold"><span class="koboSpan" id="kobo.38.1">Protocol Buffers</span></strong><span class="koboSpan" id="kobo.39.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.40.1">protobuf</span></strong><span class="koboSpan" id="kobo.41.1">) and gRPC to interact with network devices and </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">stream telemetry.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.43.1">In this chapter, we’ll focus only on these network APIs, as the others are outside of the scope. </span><span class="koboSpan" id="kobo.43.2">The most notable absentee is the </span><strong class="bold"><span class="koboSpan" id="kobo.44.1">Network Configuration Protocol</span></strong><span class="koboSpan" id="kobo.45.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.46.1">NETCONF</span></strong><span class="koboSpan" id="kobo.47.1">)—one of the oldest network APIs, defined originally by IETF in 2006. </span><span class="koboSpan" id="kobo.47.2">We’re skipping NETCONF mainly because of the lack of support for XML in some Go packages we use throughout this chapter. </span><span class="koboSpan" id="kobo.47.3">Although NETCONF is in use today and offers relevant capabilities, such as different configuration datastores, configuration validation, and network-wide configuration transactions, in the future, it may get displaced by technologies running over HTTP and TLS, such as RESTCONF, gNMI, and various proprietary </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">network APIs.</span></span></p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.49.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.50.1">You can find the code examples for this chapter in the book’s GitHub repository (refer to the </span><em class="italic"><span class="koboSpan" id="kobo.51.1">Further reading</span></em><span class="koboSpan" id="kobo.52.1"> section), under the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">ch08</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.54.1"> folder.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.55.1">Important Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.56.1">We recommend you execute the Go programs in this chapter in a virtual lab environment. </span><span class="koboSpan" id="kobo.56.2">Refer to the appendix for prerequisites and instructions on how to </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">build it.</span></span></p>
<h1 id="_idParaDest-186"><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.58.1">API data modeling</span></h1>
<p><span class="koboSpan" id="kobo.59.1">Before </span><a id="_idIndexMarker703"/><span class="koboSpan" id="kobo.60.1">we look at any code, let’s review what data modeling is, what its key components are, and their relationships. </span><span class="koboSpan" id="kobo.60.2">While we focus on the configuration management side of model-driven APIs for this explanation, similar rules and assumptions apply to workflows involving state data retrieval </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">and verification.</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">The main goal of a configuration management workflow is to transform some input into a serialized data payload whose structure adheres to a data model. </span><span class="koboSpan" id="kobo.62.2">This input is usually some user-facing data, which has its own structure and may contain only a small subset of the total number of configuration values. </span><span class="koboSpan" id="kobo.62.3">But this input has a one-to-one relationship with the resulting configuration, meaning that rerunning the same workflow should result in the same set of RPCs with the same payloads and the same configuration state on a </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">network device.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">At the center of it all is a data model—a text document that describes the hierarchical structure and types of values of a (configuration) data payload. </span><span class="koboSpan" id="kobo.64.2">This document becomes a contract with all potential clients—as long as they send their data in the right format, a server should be able to understand it and parse it. </span><span class="koboSpan" id="kobo.64.3">This contract works both ways so that when a client requests some information from a server, it can expect to receive it in a </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">predetermined format.</span></span></p>
<p><span class="koboSpan" id="kobo.66.1">The following diagram shows the main components of a model-driven configuration management workflow and </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">their relationships:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer068">
<span class="koboSpan" id="kobo.68.1"><img alt="Figure 8.1 – Data modeling concepts" src="image/B16971_08_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.69.1">Figure 8.1 – Data modeling concepts</span></p>
<p><span class="koboSpan" id="kobo.70.1">Thus far, we’ve </span><a id="_idIndexMarker704"/><span class="koboSpan" id="kobo.71.1">discussed a model, its input, and the resulting configuration. </span><span class="koboSpan" id="kobo.71.2">The only thing we haven’t mentioned until now is the </span><em class="italic"><span class="koboSpan" id="kobo.72.1">bindings</span></em><span class="koboSpan" id="kobo.73.1">. </span><span class="koboSpan" id="kobo.73.2">We use this term to refer to a broad set of tools and libraries that can help us generate the final configuration data payload programmatically, that is, without resorting to a set of text templates or building these data payloads manually, both of which we consider an anti-pattern in any network automation workflow. </span><span class="koboSpan" id="kobo.73.3">We produce these bindings based on the data model and they represent a programmatic view of the model. </span><span class="koboSpan" id="kobo.73.4">They may also include several helper functions to serialize and deserialize data structures into one of the expected output formats, for example, JSON or protobuf. </span><span class="koboSpan" id="kobo.73.5">We’ll spend most of this chapter discussing and interacting with bindings as they become the main interface for a data model inside of the </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">programming language.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">Now that we’ve covered some theory, it’s time to put it into practice. </span><span class="koboSpan" id="kobo.75.2">In the following section, we’ll examine OpenAPI models and one way you can instantiate and </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">validate them.</span></span></p>
<h1 id="_idParaDest-187"><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.77.1">OpenAPI</span></h1>
<p><span class="koboSpan" id="kobo.78.1">Within a</span><a id="_idIndexMarker705"/><span class="koboSpan" id="kobo.79.1"> greater infrastructure landscape, HTTP and JSON are two commonly used standards for machine-to-machine communication. </span><span class="koboSpan" id="kobo.79.2">Most web-based services, including public and private clouds, use a combination of these technologies to expose their externally </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">facing APIs.</span></span></p>
<p><span class="koboSpan" id="kobo.81.1">The OpenAPI Specification allows us to define and consume RESTful APIs. </span><span class="koboSpan" id="kobo.81.2">It lets us describe the enabled HTTP paths, responses, and JSON schemas for the corresponding payloads. </span><span class="koboSpan" id="kobo.81.3">It serves as a contract between an API provider and its clients to allow for a more stable and reliable API consumer experience and enables API evolution </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">through versioning.</span></span></p>
<p><span class="koboSpan" id="kobo.83.1">We don’t widely use OpenAPI in networking, arguably for historical reasons. </span><span class="koboSpan" id="kobo.83.2">YANG and its ecosystem of protocols predate OpenAPI and the rate of change in network operating systems is</span><a id="_idIndexMarker706"/><span class="koboSpan" id="kobo.84.1"> not as fast as you might expect. </span><span class="koboSpan" id="kobo.84.2">But we often find OpenAPI support in network appliances—SDN controllers, monitoring and</span><a id="_idIndexMarker707"/><span class="koboSpan" id="kobo.85.1"> provisioning systems or </span><strong class="bold"><span class="koboSpan" id="kobo.86.1">Domain Name System</span></strong><span class="koboSpan" id="kobo.87.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.88.1">DNS</span></strong><span class="koboSpan" id="kobo.89.1">), </span><strong class="bold"><span class="koboSpan" id="kobo.90.1">Dynamic Host Configuration Protocol</span></strong><span class="koboSpan" id="kobo.91.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.92.1">DHCP</span></strong><span class="koboSpan" id="kobo.93.1">), and </span><strong class="bold"><span class="koboSpan" id="kobo.94.1">IP Address Management</span></strong><span class="koboSpan" id="kobo.95.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.96.1">IPAM</span></strong><span class="koboSpan" id="kobo.97.1">) products. </span><span class="koboSpan" id="kobo.97.2">This makes working with OpenAPI a </span><a id="_idIndexMarker708"/><span class="koboSpan" id="kobo.98.1">valuable skill to have for any network </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">automation engineer.</span></span></p>
<p><span class="koboSpan" id="kobo.100.1">In </span><em class="italic"><span class="koboSpan" id="kobo.101.1">Chapters 6</span></em><span class="koboSpan" id="kobo.102.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.103.1">7</span></em><span class="koboSpan" id="kobo.104.1">, we went through an example of how to interact with Nautobot’s external OpenAPI-based interface. </span><span class="koboSpan" id="kobo.104.2">We used a Go package produced by an open source code generation framework based on Nautobot’s OpenAPI specification. </span><span class="koboSpan" id="kobo.104.3">One thing to be mindful of with automatic code generation tools is that they rely on a certain version of the OpenAPI Specification. </span><span class="koboSpan" id="kobo.104.4">If the version of your API specification is different (there are nine different OpenAPI versions today; refer to the </span><em class="italic"><span class="koboSpan" id="kobo.105.1">Further reading</span></em><span class="koboSpan" id="kobo.106.1"> section), the tool may not generate the Go code. </span><span class="koboSpan" id="kobo.106.2">Hence, we want to explore an </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">alternative approach.</span></span></p>
<p><span class="koboSpan" id="kobo.108.1">In this section, we’ll </span><a id="_idIndexMarker709"/><span class="koboSpan" id="kobo.109.1">configure NVIDIA’s Cumulus Linux device (</span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">cvx</span></strong><span class="koboSpan" id="kobo.111.1">), which has an OpenAPI-based HTTP API, using </span><strong class="bold"><span class="koboSpan" id="kobo.112.1">Configure Unify Execute</span></strong><span class="koboSpan" id="kobo.113.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.114.1">CUE</span></strong><span class="koboSpan" id="kobo.115.1">; refer to the </span><em class="italic"><span class="koboSpan" id="kobo.116.1">Further reading</span></em><span class="koboSpan" id="kobo.117.1"> section)—an open source </span><strong class="bold"><span class="koboSpan" id="kobo.118.1">Domain-Specific Language</span></strong><span class="koboSpan" id="kobo.119.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.120.1">DSL</span></strong><span class="koboSpan" id="kobo.121.1">) designed</span><a id="_idIndexMarker710"/><span class="koboSpan" id="kobo.122.1"> to define, generate, and validate </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">structured data.</span></span></p>
<p><span class="koboSpan" id="kobo.124.1">CUE’s primary user-facing interface is CLI, but it also has first-class Go API support, so we’ll focus on how to interact with it entirely within Go code while providing the corresponding shell commands </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">where appropriate.</span></span></p>
<p><span class="koboSpan" id="kobo.126.1">The following</span><a id="_idIndexMarker711"/><span class="koboSpan" id="kobo.127.1"> figure shows a high-level overview of the Go program we’ll </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">discuss next:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer069">
<span class="koboSpan" id="kobo.129.1"><img alt="Figure 8.2 – Working with OpenAPI data models" src="image/B16971_08_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.130.1">Figure 8.2 – Working with OpenAPI data models</span></p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.131.1">Data modeling</span></h2>
<p><span class="koboSpan" id="kobo.132.1">Starting </span><a id="_idIndexMarker712"/><span class="koboSpan" id="kobo.133.1">from the top of the diagram, the first thing we need to do is produce the CUE code we can use to generate the data structures to configure a </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">network device.</span></span></p>
<p><span class="koboSpan" id="kobo.135.1">Although CUE can import existing structured data and generate CUE code, it may take a few iterations to get to a point where the code organization is optimal. </span><span class="koboSpan" id="kobo.135.2">It turned out to be faster to write this code from scratch for the example we present here. </span><span class="koboSpan" id="kobo.135.3">The result is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">ch08/cue/template.cue</span></strong><span class="koboSpan" id="kobo.137.1"> file (refer to the </span><em class="italic"><span class="koboSpan" id="kobo.138.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.139.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.140.1"> section).</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.141.1">Important Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.142.1">We won’t cover CUE syntax or any of its core concepts and principles in this book but will instead focus on its Go API. </span><span class="koboSpan" id="kobo.142.2">For more details about the language, please refer to CUE’s official documentation, linked in the </span><em class="italic"><span class="koboSpan" id="kobo.143.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.144.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.145.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.146.1">CUE resembles JSON with heavy influences from Go. </span><span class="koboSpan" id="kobo.146.2">It allows you to define data structures and map values between different data structures via references. </span><span class="koboSpan" id="kobo.146.3">Data generation in CUE thus becomes an exercise of data transformation with strict value typing and schema validation. </span><span class="koboSpan" id="kobo.146.4">Here’s a snippet from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">template.cue</span></strong><span class="koboSpan" id="kobo.148.1"> file mentioned earlier, which defines three top-level objects for interfaces, routing, and </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">VRF configuration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.150.1">package cvx
import</span><span class="Code_Green"> </span><span class="Code_Red"><span class="koboSpan" id="kobo.151.1">"network.automation:input"</span></span>
<span class="Code_Blue"><span class="koboSpan" id="kobo.152.1">interface:</span></span><span class="koboSpan" id="kobo.153.1"> _interfaces
</span><span class="Code_Blue"><span class="koboSpan" id="kobo.154.1">router:</span></span><span class="koboSpan" id="kobo.155.1"> bgp: {
    _global_bgp
}
</span><span class="Code_Blue"><span class="koboSpan" id="kobo.156.1">vrf:</span></span><span class="koboSpan" id="kobo.157.1"> _vrf
</span><span class="Code_Blue"><span class="koboSpan" id="kobo.158.1">_global_bgp:</span></span><span class="koboSpan" id="kobo.159.1"> {
    </span><span class="Code_Blue"><span class="koboSpan" id="kobo.160.1">"autonomous-system": </span></span><span class="koboSpan" id="kobo.161.1">input.asn
</span><span class="Code_Green"><span class="koboSpan" id="kobo.162.1">    </span></span><span class="Code_Blue"><span class="koboSpan" id="kobo.163.1">enable:</span></span><span class="Code_Green"><span class="koboSpan" id="kobo.164.1">              </span></span><span class="Code_Red"><span class="koboSpan" id="kobo.165.1">"on"</span></span>
<span class="Code_Green"><span class="koboSpan" id="kobo.166.1">    </span></span><span class="Code_Blue"><span class="koboSpan" id="kobo.167.1">"router-id"</span></span><span class="Code_Green"><span class="koboSpan" id="kobo.168.1">:         </span></span><span class="koboSpan" id="kobo.169.1">input.loopback.ip
</span><span class="Code_Green"><span class="koboSpan" id="kobo.170.1">}</span></span>
<span class="Code_Blue"><span class="koboSpan" id="kobo.171.1">_interfaces: </span></span><span class="koboSpan" id="kobo.172.1">{
    </span><span class="Code_Blue"><span class="koboSpan" id="kobo.173.1">lo:</span></span><span class="koboSpan" id="kobo.174.1"> {
        </span><span class="Code_Blue"><span class="koboSpan" id="kobo.175.1">ip:</span></span><span class="koboSpan" id="kobo.176.1"> address: </span><span class="Code_Red"><span class="koboSpan" id="kobo.177.1">"\(input.LoopbackIP)"</span></span><span class="koboSpan" id="kobo.178.1">: {}
        </span><span class="Code_Blue"><span class="koboSpan" id="kobo.179.1">type:</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.180.1">"loopback"</span></span><span class="koboSpan" id="kobo.181.1">
    }
    for intf in input.uplinks {
        </span><span class="Code_Blue"><span class="koboSpan" id="kobo.182.1">"\(intf.name)": </span></span><span class="koboSpan" id="kobo.183.1">{
            </span><span class="Code_Blue"><span class="koboSpan" id="kobo.184.1">type:</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.185.1">"swp"</span></span><span class="koboSpan" id="kobo.186.1">
            </span><span class="Code_Blue"><span class="koboSpan" id="kobo.187.1">ip:</span></span><span class="koboSpan" id="kobo.188.1"> address:</span><span class="Code_Green"> </span><span class="Code_Red"><span class="koboSpan" id="kobo.189.1">"\(intf.prefix)"</span></span><span class="koboSpan" id="kobo.190.1">: {}
</span><span class="Code_Green"><span class="koboSpan" id="kobo.191.1">        </span></span><span class="koboSpan" id="kobo.192.1">}
    }
}
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.193.1">/* ... </span><span class="koboSpan" id="kobo.193.2">omitted for brevity ... </span><span class="koboSpan" id="kobo.193.3">*/</span></span></pre>
<p class="callout-heading"><span class="koboSpan" id="kobo.194.1">Important Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.195.1">You can refer to CUE’s </span><em class="italic"><span class="koboSpan" id="kobo.196.1">References and Visibility</span></em><span class="koboSpan" id="kobo.197.1"> tutorial (linked in the </span><em class="italic"><span class="koboSpan" id="kobo.198.1">Further reading</span></em><span class="koboSpan" id="kobo.199.1"> section) for explanations about emitted values, references, and the use </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">of underscores.</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">This file has</span><a id="_idIndexMarker713"/><span class="koboSpan" id="kobo.202.1"> references to an external CUE package called input, which provides the required input data for the data model in the preceding output. </span><span class="koboSpan" id="kobo.202.2">This separation of data templates and their inputs allows you to distribute these files separately and potentially have them come from different sources. </span><span class="koboSpan" id="kobo.202.3">CUE provides a guarantee</span><a id="_idIndexMarker714"/><span class="koboSpan" id="kobo.203.1"> that the result is always the same, no matter the order you follow to assemble </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">those files.</span></span></p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.205.1">Data input</span></h2>
<p><span class="koboSpan" id="kobo.206.1">Now, let’s see </span><a id="_idIndexMarker715"/><span class="koboSpan" id="kobo.207.1">how we define and provide inputs to the preceding data model. </span><span class="koboSpan" id="kobo.207.2">We use the same data structure we used in </span><em class="italic"><span class="koboSpan" id="kobo.208.1">Chapters 6</span></em><span class="koboSpan" id="kobo.209.1">, </span><em class="italic"><span class="koboSpan" id="kobo.210.1">Configuration Management</span></em><span class="koboSpan" id="kobo.211.1">, and </span><a href="B16971_07.xhtml#_idTextAnchor161"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.212.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.213.1">, </span><em class="italic"><span class="koboSpan" id="kobo.214.1">Automation Frameworks</span></em><span class="koboSpan" id="kobo.215.1">, in a YAML file (</span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">input.yaml</span></strong><span class="koboSpan" id="kobo.217.1">), which for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">cvx</span></strong><span class="koboSpan" id="kobo.219.1"> lab device looks </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">as follows:</span></span></p>
<pre class="source-code"><span class="Code_Brown"><span class="koboSpan" id="kobo.221.1"># input.yaml</span></span>
<span class="Code_Blue"><span class="koboSpan" id="kobo.222.1">asn:</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.223.1">65002</span></span>
<span class="Code_Blue"><span class="koboSpan" id="kobo.224.1">loopback: </span></span><span class="koboSpan" id="kobo.225.1">
  </span><span class="Code_Blue"><span class="koboSpan" id="kobo.226.1">ip:</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.227.1">"198.51.100.2"</span></span>
<span class="Code_Blue"><span class="koboSpan" id="kobo.228.1">uplinks:</span></span><span class="koboSpan" id="kobo.229.1">
  </span><span class="Code_Blue"><span class="koboSpan" id="kobo.230.1">- name:</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.231.1">"swp1"</span></span><span class="koboSpan" id="kobo.232.1">
    </span><span class="Code_Blue"><span class="koboSpan" id="kobo.233.1">prefix:</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.234.1">"192.0.2.3/31"</span></span>
<span class="Code_Blue"><span class="koboSpan" id="kobo.235.1">peers:</span></span><span class="koboSpan" id="kobo.236.1">
  </span><span class="Code_Blue"><span class="koboSpan" id="kobo.237.1">- ip:</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.238.1">"192.0.2.2"</span></span><span class="koboSpan" id="kobo.239.1">
    </span><span class="Code_Blue"><span class="koboSpan" id="kobo.240.1">asn:</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.241.1">65001</span></span></pre>
<p><span class="koboSpan" id="kobo.242.1">Using CUE, we can validate that this input data is correct by building a corresponding object and introducing constraints, for example, a valid ASN range or IPv4 prefix format. </span><span class="koboSpan" id="kobo.242.2">CUE allows you to define extra values directly inside the schema definition, either by hardcoding defaults (</span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">input.VRFs</span></strong><span class="koboSpan" id="kobo.244.1">) or referencing other values from the same </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">context (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">input.LoopbackIP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.248.1">package input
import (
    </span><span class="Code_Red"><span class="koboSpan" id="kobo.249.1">"net"</span></span><span class="koboSpan" id="kobo.250.1">
)
</span><span class="Code_Blue"><span class="koboSpan" id="kobo.251.1">asn:</span></span><span class="koboSpan" id="kobo.252.1"> &lt;=65535 &amp; &gt;=64512
</span><span class="Code_Blue"><span class="koboSpan" id="kobo.253.1">loopback:</span></span><span class="koboSpan" id="kobo.254.1"> ip: net.IPv4 &amp; string
</span><span class="Code_Blue"><span class="koboSpan" id="kobo.255.1">uplinks:</span></span><span class="koboSpan" id="kobo.256.1"> [...{
    </span><span class="Code_Blue"><span class="koboSpan" id="kobo.257.1">name:</span></span><span class="koboSpan" id="kobo.258.1">   string
</span><span class="Code_Green"><span class="koboSpan" id="kobo.259.1">    </span></span><span class="Code_Blue"><span class="koboSpan" id="kobo.260.1">prefix:</span></span><span class="Code_Green"> </span><span class="koboSpan" id="kobo.261.1">net.IPCIDR &amp; string
}]
</span><span class="Code_Blue"><span class="koboSpan" id="kobo.262.1">peers:</span></span><span class="koboSpan" id="kobo.263.1"> [...{
    </span><span class="Code_Blue"><span class="koboSpan" id="kobo.264.1">ip:</span></span><span class="koboSpan" id="kobo.265.1">  net.IPv4 &amp; string
</span><span class="Code_Green"><span class="koboSpan" id="kobo.266.1">    </span></span><span class="Code_Blue"><span class="koboSpan" id="kobo.267.1">asn:</span></span><span class="Code_Green"> </span><span class="koboSpan" id="kobo.268.1">&lt;=65535 &amp; &gt;=64512
}]
</span><span class="Code_Blue"><span class="koboSpan" id="kobo.269.1">LoopbackIP:</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.270.1">"\(loopback.ip)/32"</span></span>
<span class="Code_Blue"><span class="koboSpan" id="kobo.271.1">VRFs:</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.272.1">[{</span></span><span class="Code_Blue"><span class="koboSpan" id="kobo.273.1">name:</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.274.1">"default"</span></span><span class="Code_Green"><span class="koboSpan" id="kobo.275.1">}]</span></span></pre>
<p><span class="koboSpan" id="kobo.276.1">In the </span><a id="_idIndexMarker716"/><span class="koboSpan" id="kobo.277.1">main function of the example program, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">importInput</span></strong><span class="koboSpan" id="kobo.279.1"> helper function to read the input YAML file and generate a corresponding </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">CUE file:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.281.1">import</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.282.1">"cuelang.org/go/cue/load"</span></span>
<span class="Code_Purple"><span class="koboSpan" id="kobo.283.1">func</span></span><span class="koboSpan" id="kobo.284.1"> main() {
    err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.285.1">=</span></span><span class="koboSpan" id="kobo.286.1"> importInput()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.287.1">/* ... </span><span class="koboSpan" id="kobo.287.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.287.3">*/</span></span><span class="koboSpan" id="kobo.288.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.289.1">The program saves the resulting file as </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">input.cue</span></strong><span class="koboSpan" id="kobo.291.1"> in the local directory. </span><span class="koboSpan" id="kobo.291.2">The implementation details of this function are not too important as you can perform the same action from the command line with </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">cue import input.yaml -</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">p input</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.295.1">At this stage, we can validate that our input conforms to the schema and constraints shown earlier. </span><span class="koboSpan" id="kobo.295.2">For example, if we had set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">asn</span></strong><span class="koboSpan" id="kobo.297.1"> value in </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">input.yaml</span></strong><span class="koboSpan" id="kobo.299.1"> to something outside of the </span><a id="_idIndexMarker717"/><span class="koboSpan" id="kobo.300.1">expected range, CUE would’ve caught and reported </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">this error:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.302.1">ch08/cue</span><span class="Code_Blue"><span class="koboSpan" id="kobo.303.1">$ cue</span></span><span class="koboSpan" id="kobo.304.1"> eval network.automation:input </span><span class="Code_Blue"><span class="koboSpan" id="kobo.305.1">-c</span></span><span class="koboSpan" id="kobo.306.1">
asn: invalid value 10 (out of bound &gt;</span><span class="Code_Red"><span class="koboSpan" id="kobo.307.1">=</span></span><span class="Code_Green"><span class="koboSpan" id="kobo.308.1">64512</span></span><span class="koboSpan" id="kobo.309.1">):
    ./schema.cue:7:16
    ./input.cue:3:6</span></pre>
<h2 id="_idParaDest-190"><a id="_idTextAnchor189"/><span class="koboSpan" id="kobo.310.1">Device configuration</span></h2>
<p><span class="koboSpan" id="kobo.311.1">Now</span><a id="_idIndexMarker718"/><span class="koboSpan" id="kobo.312.1"> we have all the pieces in place to configure our network device. </span><span class="koboSpan" id="kobo.312.2">We produce the final configuration instance by compiling the template defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">cvx</span></strong><span class="koboSpan" id="kobo.314.1"> package into a concrete CUE value. </span><span class="koboSpan" id="kobo.314.2">We do this in </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">three steps.</span></span></p>
<p><span class="koboSpan" id="kobo.316.1">First, we load all CUE files from the local directory, specifying the name of the package containing the </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">template (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">cvx</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">):</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.320.1">func</span></span><span class="koboSpan" id="kobo.321.1"> main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.322.1">/* ... </span><span class="koboSpan" id="kobo.322.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.322.3">*/</span></span><span class="koboSpan" id="kobo.323.1">
    bis :</span><span class="Code_Red"><span class="koboSpan" id="kobo.324.1">=</span></span><span class="koboSpan" id="kobo.325.1"> load.Instances([]</span><span class="Code_Purple"><span class="koboSpan" id="kobo.326.1">string</span></span><span class="koboSpan" id="kobo.327.1">{</span><span class="Code_Red"><span class="koboSpan" id="kobo.328.1">"."</span></span><span class="koboSpan" id="kobo.329.1">}, </span><span class="Code_Red"><span class="koboSpan" id="kobo.330.1">&amp;</span></span><span class="koboSpan" id="kobo.331.1">load.Config{
        Package: </span><span class="Code_Red"><span class="koboSpan" id="kobo.332.1">"cvx"</span></span><span class="koboSpan" id="kobo.333.1">,
    })
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.334.1">/* ... </span><span class="koboSpan" id="kobo.334.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.334.3">*/</span></span><span class="koboSpan" id="kobo.335.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.336.1">Second, we compile all loaded files into a CUE value, which resolves all imports and combines the input with </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">the template:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.338.1">func</span></span><span class="koboSpan" id="kobo.339.1"> main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.340.1">/* ... </span><span class="koboSpan" id="kobo.340.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.340.3">*/</span></span><span class="koboSpan" id="kobo.341.1">
    ctx :</span><span class="Code_Red"><span class="koboSpan" id="kobo.342.1">=</span></span><span class="koboSpan" id="kobo.343.1"> cuecontext.New()
    i :</span><span class="Code_Red"><span class="koboSpan" id="kobo.344.1">=</span></span><span class="koboSpan" id="kobo.345.1"> ctx.BuildInstance(instances[</span><span class="Code_Green"><span class="koboSpan" id="kobo.346.1">0</span></span><span class="koboSpan" id="kobo.347.1">])
    if i.Err() </span><span class="Code_Red"><span class="koboSpan" id="kobo.348.1">!=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.349.1">nil</span></span><span class="Code_Green"> </span><span class="koboSpan" id="kobo.350.1">{
        msg :</span><span class="Code_Red"><span class="koboSpan" id="kobo.351.1">=</span></span><span class="koboSpan" id="kobo.352.1"> errors.Details(i.Err(), </span><span class="Code_Blue"><span class="koboSpan" id="kobo.353.1">nil</span></span><span class="koboSpan" id="kobo.354.1">)
        fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.355.1">"Compile Error:\n%s\n"</span></span><span class="koboSpan" id="kobo.356.1">, msg)
    }
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.357.1">/* ... </span><span class="koboSpan" id="kobo.357.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.357.3">*/</span></span><span class="koboSpan" id="kobo.358.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.359.1">Finally, we </span><a id="_idIndexMarker719"/><span class="koboSpan" id="kobo.360.1">validate that we can resolve all references and that the input provides all the </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">required fields:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.362.1">func</span></span><span class="koboSpan" id="kobo.363.1"> main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.364.1">/* ... </span><span class="koboSpan" id="kobo.364.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.364.3">*/</span></span><span class="koboSpan" id="kobo.365.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.366.1">if</span></span><span class="koboSpan" id="kobo.367.1"> err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.368.1">=</span></span><span class="koboSpan" id="kobo.369.1"> i.Validate(
        cue.Final(),
        cue.Concrete(</span><span class="Code_Blue"><span class="koboSpan" id="kobo.370.1">true</span></span><span class="koboSpan" id="kobo.371.1">),
    ); err </span><span class="Code_Red"><span class="koboSpan" id="kobo.372.1">!=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.373.1">nil</span></span><span class="Code_Green"> </span><span class="koboSpan" id="kobo.374.1">{
        msg :</span><span class="Code_Red"><span class="koboSpan" id="kobo.375.1">=</span></span><span class="koboSpan" id="kobo.376.1"> errors.Details(err, </span><span class="Code_Blue"><span class="koboSpan" id="kobo.377.1">nil</span></span><span class="koboSpan" id="kobo.378.1">)
        fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.379.1">"Validate Error:\n%s\n"</span></span><span class="koboSpan" id="kobo.380.1">, msg)
    }
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.381.1">/* ... </span><span class="koboSpan" id="kobo.381.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.381.3">*/</span></span><span class="koboSpan" id="kobo.382.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.383.1">Once we know the CUE value is concrete, we can safely marshal it into JSON and send it directly to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">cvx</span></strong><span class="koboSpan" id="kobo.385.1"> device. </span><span class="koboSpan" id="kobo.385.2">The body of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">sendBytes</span></strong><span class="koboSpan" id="kobo.387.1"> function implements the three-stage commit process we discussed in </span><a href="B16971_06.xhtml#_idTextAnchor144"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.388.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.389.1">, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.390.1">Configuration Management</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.392.1">func</span></span><span class="koboSpan" id="kobo.393.1"> main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.394.1">/* ... </span><span class="koboSpan" id="kobo.394.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.394.3">*/</span></span><span class="koboSpan" id="kobo.395.1">
    data, err := e.MarshalJSON()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.396.1">// check error</span></span><span class="koboSpan" id="kobo.397.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.398.1">if</span></span><span class="koboSpan" id="kobo.399.1"> err := sendBytes(data); err </span><span class="Code_Red"><span class="koboSpan" id="kobo.400.1">!=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.401.1">nil</span></span><span class="Code_Green"> </span><span class="koboSpan" id="kobo.402.1">{
        log.Fatal(err)
    }
    log.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.403.1">"Successfully configured the device"</span></span><span class="koboSpan" id="kobo.404.1">)
}</span></pre>
<p><span class="koboSpan" id="kobo.405.1">You can </span><a id="_idIndexMarker720"/><span class="koboSpan" id="kobo.406.1">find the full program in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">ch08/cue</span></strong><span class="koboSpan" id="kobo.408.1"> directory (refer to the </span><em class="italic"><span class="koboSpan" id="kobo.409.1">Further reading</span></em><span class="koboSpan" id="kobo.410.1"> section) of this book’s GitHub repository (refer to the </span><em class="italic"><span class="koboSpan" id="kobo.411.1">Further reading</span></em><span class="koboSpan" id="kobo.412.1"> section). </span><span class="koboSpan" id="kobo.412.2">The same directory includes the complete version of the CUE files with a data template and input schema and the input YAML file. </span><span class="koboSpan" id="kobo.412.3">Successful execution of this program should produce an output </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.414.1">ch08/cue</span><span class="Code_Blue"><span class="koboSpan" id="kobo.415.1">$ go</span></span><span class="koboSpan" id="kobo.416.1"> run main.go
main.go:140: Created revisionID: changeset/cumulus/2022-05-25_20.56.51_KF9A
</span><span class="Code_Green"><span class="koboSpan" id="kobo.417.1">{</span></span><span class="koboSpan" id="kobo.418.1">
  </span><span class="Code_Red"><span class="koboSpan" id="kobo.419.1">"state"</span></span><span class="koboSpan" id="kobo.420.1">: </span><span class="Code_Red"><span class="koboSpan" id="kobo.421.1">"apply"</span></span><span class="koboSpan" id="kobo.422.1">,
  </span><span class="Code_Red"><span class="koboSpan" id="kobo.423.1">"transition"</span></span><span class="koboSpan" id="kobo.424.1">: </span><span class="Code_Green"><span class="koboSpan" id="kobo.425.1">{</span></span><span class="koboSpan" id="kobo.426.1">
    </span><span class="Code_Red"><span class="koboSpan" id="kobo.427.1">"issue"</span></span><span class="koboSpan" id="kobo.428.1">: {</span><span class="Code_Green"><span class="koboSpan" id="kobo.429.1">}</span></span><span class="koboSpan" id="kobo.430.1">,
    </span><span class="Code_Red"><span class="koboSpan" id="kobo.431.1">"progress"</span></span><span class="koboSpan" id="kobo.432.1">: </span><span class="Code_Red"><span class="koboSpan" id="kobo.433.1">""</span></span><span class="koboSpan" id="kobo.434.1">
  </span><span class="Code_Green"><span class="koboSpan" id="kobo.435.1">}</span></span><span class="koboSpan" id="kobo.436.1">
}
main.go:69: Successfully configured the device</span></pre>
<p><span class="koboSpan" id="kobo.437.1">Keep in mind that although we focus on CUE’s Go API in this chapter, you can do the same set of actions using the CUE CLI (executable binary). </span><span class="koboSpan" id="kobo.437.2">This even includes the three-stage commit to submit and apply the </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">cvx</span></strong><span class="koboSpan" id="kobo.439.1"> configuration. </span><span class="koboSpan" id="kobo.439.2">Using the built-in CUE scripting language, you can define any sequence of tasks, such as making HTTP calls or checking and parsing responses. </span><span class="koboSpan" id="kobo.439.3">You can save these actions or tasks in a special </span><em class="italic"><span class="koboSpan" id="kobo.440.1">tool</span></em><span class="koboSpan" id="kobo.441.1"> file and they automatically become available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">cue</span></strong><span class="koboSpan" id="kobo.443.1"> binary. </span><span class="koboSpan" id="kobo.443.2">You can read more about this in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">ch08/cue</span></strong><span class="koboSpan" id="kobo.445.1"> readme document and find example source code in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">ch08/cue/cue_tool.cue</span></strong><span class="koboSpan" id="kobo.447.1"> file (refer to the </span><em class="italic"><span class="koboSpan" id="kobo.448.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.449.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.450.1"> section).</span></span></p>
<p><span class="koboSpan" id="kobo.451.1">CUE has </span><a id="_idIndexMarker721"/><span class="koboSpan" id="kobo.452.1">many use cases outside of what we’ve just described and different open source projects </span><a id="_idIndexMarker722"/><span class="koboSpan" id="kobo.453.1">such as </span><strong class="bold"><span class="koboSpan" id="kobo.454.1">Istio</span></strong><span class="koboSpan" id="kobo.455.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.456.1">dagger.io</span></strong><span class="koboSpan" id="kobo.457.1"> (refer to the </span><em class="italic"><span class="koboSpan" id="kobo.458.1">Further reading</span></em><span class="koboSpan" id="kobo.459.1"> section) have</span><a id="_idIndexMarker723"/><span class="koboSpan" id="kobo.460.1"> adopted it and use it in their products. </span><span class="koboSpan" id="kobo.460.2">We encourage you to explore other CUE use cases </span><a id="_idIndexMarker724"/><span class="koboSpan" id="kobo.461.1">beyond what’s covered in this book, as well as similar configuration languages </span><a id="_idIndexMarker725"/><span class="koboSpan" id="kobo.462.1">such as </span><strong class="bold"><span class="koboSpan" id="kobo.463.1">Jsonnet</span></strong><span class="koboSpan" id="kobo.464.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.465.1">Dhall</span></strong><span class="koboSpan" id="kobo.466.1"> (refer to the </span><em class="italic"><span class="koboSpan" id="kobo.467.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.468.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.469.1"> section).</span></span></p>
<p><span class="koboSpan" id="kobo.470.1">We’ve covered a few different ways of interacting with an OpenAPI provider. </span><span class="koboSpan" id="kobo.470.2">For the rest of this chapter, we’ll focus on YANG-based APIs. </span><span class="koboSpan" id="kobo.470.3">The first one we’ll introduce is a JSON-RPC interface implementation </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">from Nokia.</span></span></p>
<h1 id="_idParaDest-191"><a id="_idTextAnchor190"/><span class="koboSpan" id="kobo.472.1">JSON-RPC</span></h1>
<p><span class="koboSpan" id="kobo.473.1">JSON-RPC is </span><a id="_idIndexMarker726"/><span class="koboSpan" id="kobo.474.1">a lightweight protocol you can use to exchange structured data between a client and a server. </span><span class="koboSpan" id="kobo.474.2">It can work over different transport protocols, but we’ll focus only on HTTP. </span><span class="koboSpan" id="kobo.474.3">Although JSON-RPC is a standard, it only defines the top-level RPC layer, while payloads and operations remain specific to </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">each implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.476.1">In this section, we’ll show how to use Nokia-specific YANG models to configure the srl device from our lab topology, as SR Linux supports sending and receiving YANG payloads over JSON-RPC (refer to the </span><em class="italic"><span class="koboSpan" id="kobo.477.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.478.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.479.1"> section).</span></span></p>
<p><span class="koboSpan" id="kobo.480.1">We’ll try to avoid building YANG data payloads manually or relying on traditional text templating methods. </span><span class="koboSpan" id="kobo.480.2">The sheer size of some YANG models, as well as model deviations and augmentations, make it impossible to build the payloads manually. </span><span class="koboSpan" id="kobo.480.3">To do this at scale, we need to rely on a programmatic approach to build configuration instances and retrieve state data. </span><span class="koboSpan" id="kobo.480.4">This is where we use openconfig/ygot (YANG Go Tools) (refer to the </span><em class="italic"><span class="koboSpan" id="kobo.481.1">Further reading</span></em><span class="koboSpan" id="kobo.482.1"> section)—a set of tools and APIs for automatic code generation from a collection of </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">YANG models.</span></span></p>
<p><span class="koboSpan" id="kobo.484.1">At a high level, the structure of the example program is analogous to the one in the </span><em class="italic"><span class="koboSpan" id="kobo.485.1">OpenAPI</span></em><span class="koboSpan" id="kobo.486.1"> section. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.487.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.488.1">.3</span></em><span class="koboSpan" id="kobo.489.1"> shows the building blocks of the program we’ll review in </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">this section:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer070">
<span class="koboSpan" id="kobo.491.1"><img alt="Figure 8.3 – Working with YANG data models" src="image/B16971_08_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.492.1">Figure 8.3 – Working with YANG data models</span></p>
<p><span class="koboSpan" id="kobo.493.1">We’ll start by</span><a id="_idIndexMarker727"/><span class="koboSpan" id="kobo.494.1"> combining the auto-generated Go bindings with the input data and building a configuration instance to provision the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">srl</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.496.1"> device.</span></span></p>
<h2 id="_idParaDest-192"><a id="_idTextAnchor191"/><span class="koboSpan" id="kobo.497.1">Code generation</span></h2>
<p><span class="koboSpan" id="kobo.498.1">Starting </span><a id="_idIndexMarker728"/><span class="koboSpan" id="kobo.499.1">from the top of the preceding diagram, the first step is to generate the corresponding Go code from a set of Nokia’s YANG models (refer to the </span><em class="italic"><span class="koboSpan" id="kobo.500.1">Further reading</span></em><span class="koboSpan" id="kobo.501.1"> section). </span><span class="koboSpan" id="kobo.501.2">We’ll only use a subset of Nokia’s YANG models to generate the bindings to configure what we need, namely L3 interfaces, BGP, and route redistribution. </span><span class="koboSpan" id="kobo.501.3">This way, we keep the size of the generated Go package small and constrained to our specific </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">use case.</span></span></p>
<p><span class="koboSpan" id="kobo.503.1">Sadly, there</span><a id="_idIndexMarker729"/><span class="koboSpan" id="kobo.504.1"> is no universal rule for how to pinpoint the list of models you need apart from reading and understanding YANG models or reverse-engineering them from an existing configuration. </span><span class="koboSpan" id="kobo.504.2">Thankfully, Nokia has developed a YANG browser (refer to the </span><em class="italic"><span class="koboSpan" id="kobo.505.1">Further reading</span></em><span class="koboSpan" id="kobo.506.1"> section) that includes a pattern-matching search that highlights the relevant XPaths and can help you find the right set of </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">YANG models.</span></span></p>
<p><span class="koboSpan" id="kobo.508.1">Once we’ve identified which models we need, we can use the ygot generator tool to build a Go package based on them. </span><span class="koboSpan" id="kobo.508.2">We won’t describe all the flags of this tool, as ygot’s official documentation (refer to the </span><em class="italic"><span class="koboSpan" id="kobo.509.1">Further reading</span></em><span class="koboSpan" id="kobo.510.1"> section) covers them. </span><span class="koboSpan" id="kobo.510.2">Still, we want to highlight the most important options </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">we’ll use:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">generate_fakeroot</span></strong><span class="koboSpan" id="kobo.513.1">: This encapsulates all generated Go data structures in a top-level </span><em class="italic"><span class="koboSpan" id="kobo.514.1">fake</span></em><span class="koboSpan" id="kobo.515.1"> root data structure called </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">Device</span></strong><span class="koboSpan" id="kobo.517.1"> to join all modules in a common hierarchy. </span><span class="koboSpan" id="kobo.517.2">Because there isn’t a YANG model that defines a universal root top-level container for all devices, network devices just add the YANG modules they support at the root (</span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">/</span></strong><span class="koboSpan" id="kobo.519.1">). </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">ygot</span></strong><span class="koboSpan" id="kobo.521.1"> represents the root via this </span><em class="italic"><span class="koboSpan" id="kobo.522.1">fake</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.523.1">root container.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">path</span></strong><span class="koboSpan" id="kobo.525.1">: This flag helps </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">ygot</span></strong><span class="koboSpan" id="kobo.527.1"> find and resolve any YANG data </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">model imports.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.529.1">The complete command to auto-generate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">srl</span></strong><span class="koboSpan" id="kobo.531.1"> package and place it in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">./pkg/srl/</span></strong><span class="koboSpan" id="kobo.533.1"> directory we used </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">is this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.535.1">ch08/json-rpc</span><span class="Code_Blue"><span class="koboSpan" id="kobo.536.1">$ go</span></span><span class="koboSpan" id="kobo.537.1"> run \
  github.com/openconfig/ygot/generator \
    </span><span class="Code_Blue"><span class="koboSpan" id="kobo.538.1">-path</span></span><span class="Code_Red"><span class="koboSpan" id="kobo.539.1">=</span></span><span class="koboSpan" id="kobo.540.1">yang \
    </span><span class="Code_Blue"><span class="koboSpan" id="kobo.541.1">-generate_fakeroot -fakeroot_name</span></span><span class="Code_Red"><span class="koboSpan" id="kobo.542.1">=</span></span><span class="koboSpan" id="kobo.543.1">device \
    </span><span class="Code_Blue"><span class="koboSpan" id="kobo.544.1">-output_file</span></span><span class="Code_Red"><span class="koboSpan" id="kobo.545.1">=</span></span><span class="koboSpan" id="kobo.546.1">pkg/srl/srl.go \
    </span><span class="Code_Blue"><span class="koboSpan" id="kobo.547.1">-package_name</span></span><span class="Code_Red"><span class="koboSpan" id="kobo.548.1">=</span></span><span class="koboSpan" id="kobo.549.1">srl \
    yang/srl_nokia/models/network-instance/srl_nokia-bgp.yang \
    yang/srl_nokia/models/routing-policy/srl_nokia-routing-policy.yang \
    yang/srl_nokia/models/network-instance/srl_nokia-ip-route-tables.yang</span></pre>
<p><span class="koboSpan" id="kobo.550.1">Since the </span><a id="_idIndexMarker730"/><span class="koboSpan" id="kobo.551.1">preceding command has several flags, it may be desirable to remember their exact set to make the build reproducible in the future. </span><span class="koboSpan" id="kobo.551.2">One alternative is to include it in a code build utility, such as make. </span><span class="koboSpan" id="kobo.551.3">Another, more Go-native option is to include it in the source code using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">//go:generate</span></strong><span class="koboSpan" id="kobo.553.1"> directive, as you can see in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">ch08/json-rpc/main.go</span></strong><span class="koboSpan" id="kobo.555.1"> file (refer to the </span><em class="italic"><span class="koboSpan" id="kobo.556.1">Further reading</span></em><span class="koboSpan" id="kobo.557.1"> section). </span><span class="koboSpan" id="kobo.557.2">Thus, you can generate the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">srl</span></strong><span class="koboSpan" id="kobo.559.1"> repeatedly using </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">this command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.561.1">ch08/json-rpc</span><span class="Code_Blue"><span class="koboSpan" id="kobo.562.1">$ go</span></span><span class="koboSpan" id="kobo.563.1"> generate ./...</span></pre>
<h2 id="_idParaDest-193"><a id="_idTextAnchor192"/><span class="koboSpan" id="kobo.564.1">Building configuration</span></h2>
<p><span class="koboSpan" id="kobo.565.1">Now</span><a id="_idIndexMarker731"/><span class="koboSpan" id="kobo.566.1"> that we’ve built a YANG-based Go package, we can create a programmatic instance of our desired configuration state and populate it. </span><span class="koboSpan" id="kobo.566.2">We do all this within Go, with the full flexibility of a general-purpose programming language at </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">our disposal.</span></span></p>
<p><span class="koboSpan" id="kobo.568.1">For example, we can design the configuration program as a set of methods, with the input model being the receiver argument. </span><span class="koboSpan" id="kobo.568.2">After we read and decode the input data, we create an empty </span><em class="italic"><span class="koboSpan" id="kobo.569.1">fake</span></em><span class="koboSpan" id="kobo.570.1"> root device we extend iteratively until we build the complete YANG instance with all the relevant values we want </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">to configure.</span></span></p>
<p><span class="koboSpan" id="kobo.572.1">The benefit of using a root device is that we don’t need to worry about individual paths. </span><span class="koboSpan" id="kobo.572.2">We can send our payload to </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">/</span></strong><span class="koboSpan" id="kobo.574.1">, assuming that the resulting YANG tree hierarchy starts from </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">the root:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.576.1">import</span></span><span class="koboSpan" id="kobo.577.1"> (
  api </span><span class="Code_Red"><span class="koboSpan" id="kobo.578.1">"json-rpc/pkg/srl"</span></span><span class="koboSpan" id="kobo.579.1">
)
</span><span class="Code_Brown"><span class="koboSpan" id="kobo.580.1">// Input Data Model</span></span>
<span class="Code_Purple"><span class="koboSpan" id="kobo.581.1">type</span></span><span class="koboSpan" id="kobo.582.1"> Model </span><span class="Code_Purple"><span class="koboSpan" id="kobo.583.1">struct</span></span><span class="koboSpan" id="kobo.584.1"> {
  Uplinks  []Link </span><span class="Code_Red"><span class="koboSpan" id="kobo.585.1">`yaml:"uplinks"`</span></span><span class="koboSpan" id="kobo.586.1">
  Peers    []Peer </span><span class="Code_Red"><span class="koboSpan" id="kobo.587.1">`yaml:"peers"`</span></span><span class="koboSpan" id="kobo.588.1">
  ASN      int    </span><span class="Code_Red"><span class="koboSpan" id="kobo.589.1">`yaml:"asn"`</span></span><span class="koboSpan" id="kobo.590.1">
  Loopback Addr   </span><span class="Code_Red"><span class="koboSpan" id="kobo.591.1">`yaml:"loopback"`</span></span><span class="koboSpan" id="kobo.592.1">
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.593.1">func</span></span><span class="koboSpan" id="kobo.594.1"> main() {
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.595.1">/* ... </span><span class="koboSpan" id="kobo.595.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.595.3">*/</span></span><span class="koboSpan" id="kobo.596.1">
  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.597.1">var</span></span><span class="koboSpan" id="kobo.598.1"> input Model
  d.Decode(</span><span class="Code_Red"><span class="koboSpan" id="kobo.599.1">&amp;</span></span><span class="koboSpan" id="kobo.600.1">input)
  device :</span><span class="Code_Red"><span class="koboSpan" id="kobo.601.1">= &amp;</span></span><span class="koboSpan" id="kobo.602.1">api.Device{}
  input.buildDefaultPolicy(device)
  input.buildL3Interfaces(device)
  input.buildNetworkInstance(device)
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.603.1">/* ... </span><span class="koboSpan" id="kobo.603.2">&lt;continues next (main) &gt; ... </span><span class="koboSpan" id="kobo.603.3">*/</span></span><span class="koboSpan" id="kobo.604.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.605.1">The</span><a id="_idIndexMarker732"/><span class="koboSpan" id="kobo.606.1"> preceding code calls three methods on input. </span><span class="koboSpan" id="kobo.606.2">Let’s zoom in on </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">buildNetworkInstance</span></strong><span class="koboSpan" id="kobo.608.1">, responsible for L3 routing configuration. </span><span class="koboSpan" id="kobo.608.2">This method is where we define a </span><em class="italic"><span class="koboSpan" id="kobo.609.1">network instance</span></em><span class="koboSpan" id="kobo.610.1">, which is a commonly used abstraction for </span><strong class="bold"><span class="koboSpan" id="kobo.611.1">VPN Routing and Forwarding</span></strong><span class="koboSpan" id="kobo.612.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.613.1">VRF</span></strong><span class="koboSpan" id="kobo.614.1">) instances and </span><strong class="bold"><span class="koboSpan" id="kobo.615.1">Virtual Switch Instances</span></strong><span class="koboSpan" id="kobo.616.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.617.1">VSIs</span></strong><span class="koboSpan" id="kobo.618.1">). </span><span class="koboSpan" id="kobo.618.2">We create a new network instance from the top-level root device to ensure we attach it to the top of the </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">YANG tree:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.620.1">func</span></span><span class="koboSpan" id="kobo.621.1"> (m </span><span class="Code_Red"><span class="koboSpan" id="kobo.622.1">*</span></span><span class="koboSpan" id="kobo.623.1">Model) buildNetworkInstance(dev </span><span class="Code_Red"><span class="koboSpan" id="kobo.624.1">*</span></span><span class="koboSpan" id="kobo.625.1">api.Device) </span><span class="Code_Purple"><span class="koboSpan" id="kobo.626.1">error</span></span><span class="Code_Red"> </span><span class="koboSpan" id="kobo.627.1">{
  ni, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.628.1">=</span></span><span class="koboSpan" id="kobo.629.1"> dev.NewNetworkInstance(defaultNetInst)
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.630.1">/* ... </span><span class="koboSpan" id="kobo.630.2">&lt;continues next (buildNetworkInstance) &gt; ... </span><span class="koboSpan" id="kobo.630.3">*/</span></span><span class="koboSpan" id="kobo.631.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.632.1">In the next code snippet, we move all uplinks and a loopback interface into the newly created network </span><a id="_idIndexMarker733"/><span class="koboSpan" id="kobo.633.1">instance by defining each subinterface as a child of the default </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">network instance:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.635.1">func</span></span><span class="koboSpan" id="kobo.636.1"> (m </span><span class="Code_Red"><span class="koboSpan" id="kobo.637.1">*</span></span><span class="koboSpan" id="kobo.638.1">Model) buildNetworkInstance(dev </span><span class="Code_Red"><span class="koboSpan" id="kobo.639.1">*</span></span><span class="koboSpan" id="kobo.640.1">api.Device) </span><span class="Code_Purple"><span class="koboSpan" id="kobo.641.1">error</span></span><span class="Code_Red"> </span><span class="koboSpan" id="kobo.642.1">{
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.643.1">// ... </span><span class="koboSpan" id="kobo.643.2">&lt;continues from before (buildNetworkInstance) &gt;</span></span><span class="Code_ligh-Blue"> </span><span class="koboSpan" id="kobo.644.1">
  links :</span><span class="Code_Red"><span class="koboSpan" id="kobo.645.1">=</span></span><span class="koboSpan" id="kobo.646.1"> m.Uplinks
  links </span><span class="Code_Red"><span class="koboSpan" id="kobo.647.1">=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.648.1">append</span></span><span class="koboSpan" id="kobo.649.1">(
    links,
    Link{
      Name:   srlLoopback,
      Prefix: fmt.Sprintf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.650.1">"%s/32"</span></span><span class="koboSpan" id="kobo.651.1">, m.Loopback.IP),
    },
  )
  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.652.1">for</span></span><span class="koboSpan" id="kobo.653.1"> _, link :</span><span class="Code_Red"><span class="koboSpan" id="kobo.654.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.655.1">range</span></span><span class="koboSpan" id="kobo.656.1"> links {
    linkName :</span><span class="Code_Red"><span class="koboSpan" id="kobo.657.1">=</span></span><span class="koboSpan" id="kobo.658.1"> fmt.Sprintf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.659.1">"%s.%d"</span></span><span class="koboSpan" id="kobo.660.1">, link.Name,
                            defaultSubIdx)
    ni.NewInterface(linkName)
  }
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.661.1">/* ... </span><span class="koboSpan" id="kobo.661.2">&lt;continues next (buildNetworkInstance) &gt; ... </span><span class="koboSpan" id="kobo.661.3">*/</span></span><span class="koboSpan" id="kobo.662.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.663.1">Next, we define the global BGP settings by manually populating the BGP struct and attaching it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">Protocols.Bgp</span></strong><span class="koboSpan" id="kobo.665.1"> field of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">default</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.667.1">network instance:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.668.1">func</span></span><span class="koboSpan" id="kobo.669.1"> (m </span><span class="Code_Red"><span class="koboSpan" id="kobo.670.1">*</span></span><span class="koboSpan" id="kobo.671.1">Model) buildNetworkInstance(dev </span><span class="Code_Red"><span class="koboSpan" id="kobo.672.1">*</span></span><span class="koboSpan" id="kobo.673.1">api.Device) </span><span class="Code_Purple"><span class="koboSpan" id="kobo.674.1">error</span></span><span class="Code_Red"> </span><span class="koboSpan" id="kobo.675.1">{
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.676.1">// ... </span><span class="koboSpan" id="kobo.676.2">&lt;continues from before (buildNetworkInstance) &gt;</span></span><span class="Code_ligh-Blue"> </span><span class="koboSpan" id="kobo.677.1">
  ni.Protocols =
  </span><span class="Code_Red"><span class="koboSpan" id="kobo.678.1">&amp;</span></span><span class="koboSpan" id="kobo.679.1">api.SrlNokiaNetworkInstance_NetworkInstance_Protocols{
    Bgp: 
    &amp;api.
</span><span class="koboSpan" id="kobo.679.2">    SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp{
      AutonomousSystem: ygot.Uint32(</span><span class="Code_Purple"><span class="koboSpan" id="kobo.680.1">uint32</span></span><span class="koboSpan" id="kobo.681.1">(m.ASN)),
      RouterId:         ygot.String(m.Loopback.IP),
      Ipv4Unicast: 
      </span><span class="Code_Red"><span class="koboSpan" id="kobo.682.1">&amp;</span></span><span class="koboSpan" id="kobo.683.1">api. 
</span><span class="koboSpan" id="kobo.683.2">SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Ipv4Unicast{
        AdminState: api.SrlNokiaBgp_AdminState_enable,
      },
    },
  }
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.684.1">/* ... </span><span class="koboSpan" id="kobo.684.2">&lt;continues next (buildNetworkInstance) &gt; ... </span><span class="koboSpan" id="kobo.684.3">*/</span></span><span class="koboSpan" id="kobo.685.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.686.1">The</span><a id="_idIndexMarker734"/><span class="koboSpan" id="kobo.687.1"> final part of the configuration is BGP neighbors. </span><span class="koboSpan" id="kobo.687.2">We iterate over a list of peers defined in the input data model and add a new entry under the BGP struct we set </span><span class="No-Break"><span class="koboSpan" id="kobo.688.1">up earlier:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.689.1">func</span></span><span class="koboSpan" id="kobo.690.1"> (m </span><span class="Code_Red"><span class="koboSpan" id="kobo.691.1">*</span></span><span class="koboSpan" id="kobo.692.1">Model) buildNetworkInstance(dev </span><span class="Code_Red"><span class="koboSpan" id="kobo.693.1">*</span></span><span class="koboSpan" id="kobo.694.1">api.Device) </span><span class="Code_Purple"><span class="koboSpan" id="kobo.695.1">error</span></span><span class="Code_Red"> </span><span class="koboSpan" id="kobo.696.1">{
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.697.1">// ... </span><span class="koboSpan" id="kobo.697.2">&lt;continues from before (buildNetworkInstance) &gt;</span></span><span class="Code_ligh-Blue"> </span><span class="koboSpan" id="kobo.698.1">
  ni.Protocols.Bgp.NewGroup(defaultBGPGroup)
  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.699.1">for</span></span><span class="koboSpan" id="kobo.700.1"> _, peer :</span><span class="Code_Red"><span class="koboSpan" id="kobo.701.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.702.1">range</span></span><span class="koboSpan" id="kobo.703.1"> m.Peers {
    n, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.704.1">=</span></span><span class="koboSpan" id="kobo.705.1"> ni.Protocols.Bgp.NewNeighbor(peer.IP)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.706.1">// check error</span></span><span class="koboSpan" id="kobo.707.1">
    n.PeerAs </span><span class="Code_Red"><span class="koboSpan" id="kobo.708.1">=</span></span><span class="koboSpan" id="kobo.709.1"> ygot.Uint32(</span><span class="Code_Purple"><span class="koboSpan" id="kobo.710.1">uint32</span></span><span class="koboSpan" id="kobo.711.1">(peer.ASN))
    n.PeerGroup </span><span class="Code_Red"><span class="koboSpan" id="kobo.712.1">=</span></span><span class="koboSpan" id="kobo.713.1"> ygot.String(defaultBGPGroup)
  }
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.714.1">/* ... </span><span class="koboSpan" id="kobo.714.2">&lt;continues next (buildNetworkInstance) &gt; ... </span><span class="koboSpan" id="kobo.714.3">*/</span></span><span class="koboSpan" id="kobo.715.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.716.1">When </span><a id="_idIndexMarker735"/><span class="koboSpan" id="kobo.717.1">we finish populating the Go structs, we make sure that all provided values are correct and match the YANG constraints. </span><span class="koboSpan" id="kobo.717.2">We can do this with a single call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">Validate</span></strong><span class="koboSpan" id="kobo.719.1"> method on the </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">parent container:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.721.1">func</span></span><span class="koboSpan" id="kobo.722.1"> (m </span><span class="Code_Red"><span class="koboSpan" id="kobo.723.1">*</span></span><span class="koboSpan" id="kobo.724.1">Model) buildNetworkInstance(dev </span><span class="Code_Red"><span class="koboSpan" id="kobo.725.1">*</span></span><span class="koboSpan" id="kobo.726.1">api.Device) </span><span class="Code_Purple"><span class="koboSpan" id="kobo.727.1">error</span></span><span class="Code_Red"> </span><span class="koboSpan" id="kobo.728.1">{
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.729.1">/* ... </span><span class="koboSpan" id="kobo.729.2">&lt;continues from before (buildNetworkInstance) &gt; ... </span><span class="koboSpan" id="kobo.729.3">*/</span></span><span class="koboSpan" id="kobo.730.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.731.1">if</span></span><span class="koboSpan" id="kobo.732.1"> err := ni.Validate(); err </span><span class="Code_Red"><span class="koboSpan" id="kobo.733.1">!=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.734.1">nil</span></span><span class="koboSpan" id="kobo.735.1"> {
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.736.1">return</span></span><span class="koboSpan" id="kobo.737.1"> err
    }
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.738.1">return</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.739.1">nil</span></span><span class="koboSpan" id="kobo.740.1">
}</span></pre>
<h2 id="_idParaDest-194"><a id="_idTextAnchor193"/><span class="koboSpan" id="kobo.741.1">Device configuration</span></h2>
<p><span class="koboSpan" id="kobo.742.1">Once</span><a id="_idIndexMarker736"/><span class="koboSpan" id="kobo.743.1"> we have populated a YANG model instance with all the input values, the next step is to send it to the target device. </span><span class="koboSpan" id="kobo.743.2">We do this in a </span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">few steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.745.1">We use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">ygot</span></strong><span class="koboSpan" id="kobo.747.1"> helper function to produce a map from the current YANG instance. </span><span class="koboSpan" id="kobo.747.2">This map is ready to be serialized into JSON according to the rules defined </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">in RFC7951.</span></span></li>
<li><span class="koboSpan" id="kobo.749.1">We use the standard </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">encoding/json</span></strong><span class="koboSpan" id="kobo.751.1"> library to build a single JSON-RPC request that updates the entire YANG tree with our </span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">configuration changes.</span></span></li>
<li><span class="koboSpan" id="kobo.753.1">Using the </span><a id="_idIndexMarker737"/><span class="koboSpan" id="kobo.754.1">standard </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">net/http</span></strong><span class="koboSpan" id="kobo.756.1"> package, we send this request to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">srl</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.758.1"> device:</span></span><pre class="console"><span class="Code_Purple"><span class="koboSpan" id="kobo.759.1">func</span></span><span class="koboSpan" id="kobo.760.1"> main() {</span></pre><pre class="console"><span class="koboSpan" id="kobo.761.1">    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.762.1">/* ... </span><span class="koboSpan" id="kobo.762.2">&lt;continues from before (main) &gt; ... </span><span class="koboSpan" id="kobo.762.3">*/</span></span></pre><pre class="console"><span class="koboSpan" id="kobo.763.1">    v, err := ygot.ConstructIETFJSON(device, nil)</span></pre><pre class="console"><span class="koboSpan" id="kobo.764.1">    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.765.1">// check error</span></span></pre><pre class="console"><span class="koboSpan" id="kobo.766.1">    value, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.767.1">=</span></span><span class="koboSpan" id="kobo.768.1"> json.Marshal(RpcRequest{</span></pre><pre class="console"><span class="koboSpan" id="kobo.769.1">        Version: </span><span class="Code_Red"><span class="koboSpan" id="kobo.770.1">"2.0"</span></span><span class="koboSpan" id="kobo.771.1">,</span></pre><pre class="console"><span class="koboSpan" id="kobo.772.1">        ID:      </span><span class="Code_Green"><span class="koboSpan" id="kobo.773.1">0</span></span><span class="koboSpan" id="kobo.774.1">,</span></pre><pre class="console"><span class="koboSpan" id="kobo.775.1">        Method:  </span><span class="Code_Red"><span class="koboSpan" id="kobo.776.1">"set"</span></span><span class="koboSpan" id="kobo.777.1">,</span></pre><pre class="console"><span class="koboSpan" id="kobo.778.1">        Params: Params{</span></pre><pre class="console"><span class="koboSpan" id="kobo.779.1">            Commands: []</span><span class="Code_Red"><span class="koboSpan" id="kobo.780.1">*</span></span><span class="koboSpan" id="kobo.781.1">Command{</span></pre><pre class="console"><span class="koboSpan" id="kobo.782.1">                {</span></pre><pre class="console"><span class="koboSpan" id="kobo.783.1">                    Action: </span><span class="Code_Red"><span class="koboSpan" id="kobo.784.1">"update"</span></span><span class="koboSpan" id="kobo.785.1">,</span></pre><pre class="console"><span class="koboSpan" id="kobo.786.1">                    Path:   </span><span class="Code_Red"><span class="koboSpan" id="kobo.787.1">"/"</span></span><span class="koboSpan" id="kobo.788.1">,</span></pre><pre class="console"><span class="koboSpan" id="kobo.789.1">                    Value:  v,</span></pre><pre class="console"><span class="koboSpan" id="kobo.790.1">                },</span></pre><pre class="console"><span class="koboSpan" id="kobo.791.1">            },</span></pre><pre class="console"><span class="koboSpan" id="kobo.792.1">        },</span></pre><pre class="console"><span class="koboSpan" id="kobo.793.1">    })</span></pre><pre class="console"><span class="koboSpan" id="kobo.794.1">    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.795.1">// check error</span></span></pre><pre class="console"><span class="koboSpan" id="kobo.796.1">    req, err := http.NewRequest(</span></pre><pre class="console"><span class="koboSpan" id="kobo.797.1">        </span><span class="Code_Red"><span class="koboSpan" id="kobo.798.1">"POST"</span></span><span class="koboSpan" id="kobo.799.1">,</span></pre><pre class="console"><span class="koboSpan" id="kobo.800.1">        hostname,</span></pre><pre class="console"><span class="koboSpan" id="kobo.801.1">        bytes.NewBuffer(value),</span></pre><pre class="console"><span class="koboSpan" id="kobo.802.1">    )</span></pre><pre class="console"><span class="koboSpan" id="kobo.803.1">    resp, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.804.1">=</span></span><span class="koboSpan" id="kobo.805.1"> client.Do(req)</span></pre><pre class="console"><span class="koboSpan" id="kobo.806.1">     </span><span class="Code_Brown"><span class="koboSpan" id="kobo.807.1">// check error</span></span></pre><pre class="console"><span class="koboSpan" id="kobo.808.1">    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.809.1">defer</span></span><span class="koboSpan" id="kobo.810.1"> resp.Body.Close()</span></pre><pre class="console"><span class="koboSpan" id="kobo.811.1">    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.812.1">if</span></span><span class="koboSpan" id="kobo.813.1"> resp.StatusCode </span><span class="Code_Red"><span class="koboSpan" id="kobo.814.1">!=</span></span><span class="koboSpan" id="kobo.815.1"> http.StatusOK {</span></pre><pre class="console"><span class="koboSpan" id="kobo.816.1">        log.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.817.1">"Status: %s"</span></span><span class="koboSpan" id="kobo.818.1">, resp.Status)</span></pre><pre class="console"><span class="koboSpan" id="kobo.819.1">    }</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.820.1">You can</span><a id="_idIndexMarker738"/><span class="koboSpan" id="kobo.821.1"> find the complete program that configures the srl device in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">ch08/json-rpc</span></strong><span class="koboSpan" id="kobo.823.1"> directory (refer to the </span><em class="italic"><span class="koboSpan" id="kobo.824.1">Further reading</span></em><span class="koboSpan" id="kobo.825.1"> section) of this book’s GitHub repository. </span><span class="koboSpan" id="kobo.825.2">To run it, </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">cd</span></strong><span class="koboSpan" id="kobo.827.1"> into this folder and run the </span><span class="No-Break"><span class="koboSpan" id="kobo.828.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.829.1">ch08/json-rpc</span><span class="Code_Blue"><span class="koboSpan" id="kobo.830.1">$ go</span></span><span class="koboSpan" id="kobo.831.1"> run main.go
2022/04/26 </span><span class="Code_Red"><span class="koboSpan" id="kobo.832.1">13</span></span><span class="koboSpan" id="kobo.833.1">:09:03 Successfully configured the device</span></pre>
<p><span class="koboSpan" id="kobo.834.1">This program only verifies that we executed the RPC successfully; it doesn’t yet check to confirm that it had the desired effect, which we will discuss later in this chapter. </span><span class="koboSpan" id="kobo.834.2">As with most HTTP-based protocols, a single RPC is a single transaction, so you can assume the target device applied the changes, as long as you receive a successful response. </span><span class="koboSpan" id="kobo.834.3">It’s worth mentioning that some JSON-RPC implementations have more session control functions that allow multistage commits, rollbacks, and </span><span class="No-Break"><span class="koboSpan" id="kobo.835.1">other features.</span></span></p>
<p><span class="koboSpan" id="kobo.836.1">In the following section, we’ll take a similar approach of configuring a network device based on its YANG models but introduce a couple of twists to show OpenConfig models and the </span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">RESTCONF API.</span></span></p>
<h1 id="_idParaDest-195"><a id="_idTextAnchor194"/><span class="koboSpan" id="kobo.838.1">RESTCONF</span></h1>
<p><span class="koboSpan" id="kobo.839.1">The </span><a id="_idIndexMarker739"/><span class="koboSpan" id="kobo.840.1">IETF designed RESTCONF as an HTTP-based alternative to NETCONF that </span><a id="_idIndexMarker740"/><span class="koboSpan" id="kobo.841.1">offers </span><strong class="bold"><span class="koboSpan" id="kobo.842.1">Create, Read, Update, and Delete</span></strong><span class="koboSpan" id="kobo.843.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.844.1">CRUD</span></strong><span class="koboSpan" id="kobo.845.1">) operations on a conceptual datastore containing YANG-modeled data. </span><span class="koboSpan" id="kobo.845.2">It may lack some NETCONF features, such as different datastores, exclusive configuration locking, and batch and rollback operations, but the exact set of supported and unsupported features depends on the implementation and network device capabilities. </span><span class="koboSpan" id="kobo.845.3">That said, because it uses HTTP methods and supports JSON encoding, RESTCONF reduces the barrier of entry for external systems to integrate and inter-operate with a </span><span class="No-Break"><span class="koboSpan" id="kobo.846.1">network device.</span></span></p>
<p><span class="koboSpan" id="kobo.847.1">RESTCONF supports</span><a id="_idIndexMarker741"/><span class="koboSpan" id="kobo.848.1"> a standard set of CRUD operations through HTTP methods: POST, PUT, PATCH, GET, and DELETE. </span><span class="koboSpan" id="kobo.848.2">RESTCONF builds HTTP messages with the YANG XPath translated into a REST-like URI and it transports the payload in the message body. </span><span class="koboSpan" id="kobo.848.3">Although RESTCONF supports both XML and JSON encoding, we will only focus on the latter, with the rules of the encoding defined in RFC7951. </span><span class="koboSpan" id="kobo.848.4">We’ll use Arista’s EOS as a test device, which has its RESTCONF API enabled when launching the </span><span class="No-Break"><span class="koboSpan" id="kobo.849.1">lab topology.</span></span></p>
<p><span class="koboSpan" id="kobo.850.1">The structure of the program we’ll create in this section is the same as for the JSON-RPC example illustrated in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.851.1">Figure 8</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.852.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">.</span></span></p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor195"/><span class="koboSpan" id="kobo.854.1">Code generation</span></h2>
<p><span class="koboSpan" id="kobo.855.1">The code generation </span><a id="_idIndexMarker742"/><span class="koboSpan" id="kobo.856.1">process is almost the same as the one we followed in the </span><em class="italic"><span class="koboSpan" id="kobo.857.1">JSON-RPC</span></em><span class="koboSpan" id="kobo.858.1"> section. </span><span class="koboSpan" id="kobo.858.2">We use openconfig/ygot (refer to the </span><em class="italic"><span class="koboSpan" id="kobo.859.1">Further reading</span></em><span class="koboSpan" id="kobo.860.1"> section) to generate a Go package from a set of YANG models that EOS supports. </span><span class="koboSpan" id="kobo.860.2">But there are a few notable differences that are worth mentioning before </span><span class="No-Break"><span class="koboSpan" id="kobo.861.1">moving forward:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.862.1">Instead of vendor-specific YANG models, we use vendor-neutral OpenConfig models, which Arista </span><span class="No-Break"><span class="koboSpan" id="kobo.863.1">EOS supports.</span></span></li>
<li><span class="koboSpan" id="kobo.864.1">When generating Go code with openconfig/ygot (refer to the </span><em class="italic"><span class="koboSpan" id="kobo.865.1">Further reading</span></em><span class="koboSpan" id="kobo.866.1"> section), you might run into situations when more than one model is defined in the same namespace. </span><span class="koboSpan" id="kobo.866.2">In those cases, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">-exclude_modules</span></strong><span class="koboSpan" id="kobo.868.1"> flag to ignore a certain YANG model without having to remove its source file from the configured </span><span class="No-Break"><span class="koboSpan" id="kobo.869.1">search path.</span></span></li>
<li><span class="koboSpan" id="kobo.870.1">We enable OpenConfig path compression to optimize the generated Go code by removing the YANG containers containing </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">list</span></strong><span class="koboSpan" id="kobo.872.1"> nodes. </span><span class="koboSpan" id="kobo.872.2">Refer to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">ygen</span></strong><span class="koboSpan" id="kobo.874.1"> library design documentation for more details (</span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.875.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.876.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.877.1">We also show an alternative approach where we don’t generate a </span><em class="italic"><span class="koboSpan" id="kobo.878.1">fake</span></em><span class="koboSpan" id="kobo.879.1"> root device. </span><span class="koboSpan" id="kobo.879.2">As a result, we can’t apply all the changes in a single RPC. </span><span class="koboSpan" id="kobo.879.3">Instead, we have to make more than one HTTP call, each with its own unique </span><span class="No-Break"><span class="koboSpan" id="kobo.880.1">URI path.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.881.1">Before we </span><a id="_idIndexMarker743"/><span class="koboSpan" id="kobo.882.1">can generate the Go code, we need to identify the supported set of Arista YANG models (refer to the </span><em class="italic"><span class="koboSpan" id="kobo.883.1">Further reading</span></em><span class="koboSpan" id="kobo.884.1"> section) and copy them into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">yang</span></strong><span class="koboSpan" id="kobo.886.1"> directory. </span><span class="koboSpan" id="kobo.886.2">We use the following command to generate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">eos</span></strong><span class="koboSpan" id="kobo.888.1"> Go package from that list </span><span class="No-Break"><span class="koboSpan" id="kobo.889.1">of models:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.890.1">ch08/restconf</span><span class="Code_Blue"><span class="koboSpan" id="kobo.891.1">$ go</span></span><span class="koboSpan" id="kobo.892.1"> run github.com/openconfig/ygot/generator \
  </span><span class="Code_Blue"><span class="koboSpan" id="kobo.893.1">-path</span></span><span class="Code_Red"><span class="koboSpan" id="kobo.894.1">=</span></span><span class="koboSpan" id="kobo.895.1">yang \
  </span><span class="Code_Blue"><span class="koboSpan" id="kobo.896.1">-output_file</span></span><span class="Code_Red"><span class="koboSpan" id="kobo.897.1">=</span></span><span class="koboSpan" id="kobo.898.1">pkg/eos/eos.go \
  </span><span class="Code_Blue"><span class="koboSpan" id="kobo.899.1">-compress_paths</span></span><span class="Code_Red"><span class="koboSpan" id="kobo.900.1">=</span></span><span class="koboSpan" id="kobo.901.1">true \
  </span><span class="Code_Blue"><span class="koboSpan" id="kobo.902.1">-exclude_modules</span></span><span class="Code_Red"><span class="koboSpan" id="kobo.903.1">=</span></span><span class="koboSpan" id="kobo.904.1">ietf-interfaces \
  </span><span class="Code_Blue"><span class="koboSpan" id="kobo.905.1">-package_name</span></span><span class="Code_Red"><span class="koboSpan" id="kobo.906.1">=</span></span><span class="koboSpan" id="kobo.907.1">eos \
  yang/openconfig/public/release/models/bgp/openconfig-bgp.yang \
  yang/openconfig/public/release/models/interfaces/openconfig-if-ip.yang \
  yang/openconfig/public/release/models/network-instance/openconfig-network-instance.yang \
  yang/release/openconfig/models/interfaces/arista-intf-augments-min.yang</span></pre>
<p><span class="koboSpan" id="kobo.908.1">For the same reasons we described in the </span><em class="italic"><span class="koboSpan" id="kobo.909.1">JSON-RPC</span></em><span class="koboSpan" id="kobo.910.1"> section, we can also embed this command into the Go source code to generate the same Go package using the following </span><span class="No-Break"><span class="koboSpan" id="kobo.911.1">command instead:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.912.1">ch08/restconf</span><span class="Code_Blue"><span class="koboSpan" id="kobo.913.1">$ go</span></span><span class="koboSpan" id="kobo.914.1"> generate ./...</span></pre>
<h2 id="_idParaDest-197"><a id="_idTextAnchor196"/><span class="koboSpan" id="kobo.915.1">Building configuration</span></h2>
<p><span class="koboSpan" id="kobo.916.1">In </span><a id="_idIndexMarker744"/><span class="koboSpan" id="kobo.917.1">this example, we won’t apply all changes in a single HTTP call so that we can show you how to update a specific part of a YANG tree without affecting other, unrelated parts. </span><span class="koboSpan" id="kobo.917.2">In the preceding section, we worked around that by using an </span><strong class="source-inline"><span class="koboSpan" id="kobo.918.1">Update</span></strong><span class="koboSpan" id="kobo.919.1"> operation, which merges the configuration we send with the existing configuration on </span><span class="No-Break"><span class="koboSpan" id="kobo.920.1">the device.</span></span></p>
<p><span class="koboSpan" id="kobo.921.1">But in certain cases, we want to avoid the </span><em class="italic"><span class="koboSpan" id="kobo.922.1">merge</span></em><span class="koboSpan" id="kobo.923.1"> behavior and ensure that only the configuration we send is present on the device (declarative management). </span><span class="koboSpan" id="kobo.923.2">For that, we could’ve imported all existing configurations and identified the parts that we want to keep or replace before sending a new configuration version to the target device. </span><span class="koboSpan" id="kobo.923.3">Instead, we create a configuration for the specific parts of a YANG tree via a series </span><span class="No-Break"><span class="koboSpan" id="kobo.924.1">of RPCs.</span></span></p>
<p><span class="koboSpan" id="kobo.925.1">To simplify RESTCONF API calls, we create a special </span><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">restconfRequest</span></strong><span class="koboSpan" id="kobo.927.1"> type that holds a URI path and a corresponding payload to send to the device. </span><span class="koboSpan" id="kobo.927.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">main</span></strong><span class="koboSpan" id="kobo.929.1"> function starts with parsing the inputs for the data model and preparing a variable to store a set of </span><span class="No-Break"><span class="koboSpan" id="kobo.930.1">RESTCONF RPCs:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.931.1">type</span></span><span class="koboSpan" id="kobo.932.1"> restconfRequest </span><span class="Code_Purple"><span class="koboSpan" id="kobo.933.1">struct</span></span><span class="koboSpan" id="kobo.934.1"> {
    path    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.935.1">string</span></span><span class="koboSpan" id="kobo.936.1">
    payload []</span><span class="Code_Purple"><span class="koboSpan" id="kobo.937.1">byte</span></span><span class="koboSpan" id="kobo.938.1">
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.939.1">func</span></span><span class="koboSpan" id="kobo.940.1"> main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.941.1">/* ... </span><span class="koboSpan" id="kobo.941.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.941.3">*/</span></span><span class="koboSpan" id="kobo.942.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.943.1">var</span></span><span class="koboSpan" id="kobo.944.1"> input Model
    err </span><span class="Code_Red"><span class="koboSpan" id="kobo.945.1">=</span></span><span class="koboSpan" id="kobo.946.1"> d.Decode(&amp;input)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.947.1">// check error</span></span><span class="koboSpan" id="kobo.948.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.949.1">var</span></span><span class="koboSpan" id="kobo.950.1"> cmds []*restconfRequest
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.951.1">/* ... </span><span class="koboSpan" id="kobo.951.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.951.3">*/</span></span><span class="koboSpan" id="kobo.952.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.953.1">As in the JSON-RPC example, we build the desired configuration instance in a series of method calls. </span><span class="koboSpan" id="kobo.953.2">This time, each method returns one </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">restConfRequest</span></strong><span class="koboSpan" id="kobo.955.1"> that has enough</span><a id="_idIndexMarker745"/><span class="koboSpan" id="kobo.956.1"> details to build an </span><span class="No-Break"><span class="koboSpan" id="kobo.957.1">HTTP request:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.958.1">func</span></span><span class="koboSpan" id="kobo.959.1"> main() {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.960.1">/* ... </span><span class="koboSpan" id="kobo.960.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.960.3">*/</span></span><span class="Code_ligh-Blue"> </span><span class="koboSpan" id="kobo.961.1">
    l3Intfs, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.962.1">=</span></span><span class="koboSpan" id="kobo.963.1"> input.buildL3Interfaces()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.964.1">// check error</span></span><span class="koboSpan" id="kobo.965.1">
    cmds </span><span class="Code_Red"><span class="koboSpan" id="kobo.966.1">=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.967.1">append</span></span><span class="koboSpan" id="kobo.968.1">(cmds, l3Intfs...)
    bgp, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.969.1">=</span></span><span class="koboSpan" id="kobo.970.1"> input.buildBGPConfig()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.971.1">// check error</span></span><span class="koboSpan" id="kobo.972.1">
    cmds </span><span class="Code_Red"><span class="koboSpan" id="kobo.973.1">=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.974.1">append</span></span><span class="koboSpan" id="kobo.975.1">(cmds, bgp)
    redistr, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.976.1">=</span></span><span class="koboSpan" id="kobo.977.1"> input.enableRedistribution()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.978.1">// check error</span></span><span class="koboSpan" id="kobo.979.1">
    cmds </span><span class="Code_Red"><span class="koboSpan" id="kobo.980.1">=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.981.1">append</span></span><span class="koboSpan" id="kobo.982.1">(cmds, redistr)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.983.1">/* ... </span><span class="koboSpan" id="kobo.983.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.983.3">*/</span></span><span class="koboSpan" id="kobo.984.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.985.1">Let’s examine one of these methods that creates a YANG configuration from our inputs. </span><span class="koboSpan" id="kobo.985.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.986.1">enableRedistribution</span></strong><span class="koboSpan" id="kobo.987.1"> method generates a configuration to enable redistribution between a</span><a id="_idIndexMarker746"/><span class="koboSpan" id="kobo.988.1"> directly connected table and the BGP </span><strong class="bold"><span class="koboSpan" id="kobo.989.1">Routing Information Base</span></strong><span class="koboSpan" id="kobo.990.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.991.1">RIB</span></strong><span class="koboSpan" id="kobo.992.1">). </span><span class="koboSpan" id="kobo.992.2">OpenConfig defines a special </span><strong class="source-inline"><span class="koboSpan" id="kobo.993.1">TableConnection</span></strong><span class="koboSpan" id="kobo.994.1"> struct that uses a pair of YANG enums to identify the redistribution source </span><span class="No-Break"><span class="koboSpan" id="kobo.995.1">and destination:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.996.1">const</span></span><span class="koboSpan" id="kobo.997.1"> defaultNetInst </span><span class="Code_Red"><span class="koboSpan" id="kobo.998.1">= "default"</span></span>
<span class="Code_Purple"><span class="koboSpan" id="kobo.999.1">func</span></span><span class="koboSpan" id="kobo.1000.1"> (m </span><span class="Code_Red"><span class="koboSpan" id="kobo.1001.1">*</span></span><span class="koboSpan" id="kobo.1002.1">Model) enableRedistribution() (</span><span class="Code_Red"><span class="koboSpan" id="kobo.1003.1">*</span></span><span class="koboSpan" id="kobo.1004.1">restconfRequest, </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1005.1">error</span></span><span class="koboSpan" id="kobo.1006.1">) {
    netInst :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1007.1">= &amp;</span></span><span class="koboSpan" id="kobo.1008.1">api.NetworkInstance{
        Name: ygot.String(defaultNetInst),
    }
    _, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1009.1">=</span></span><span class="koboSpan" id="kobo.1010.1"> netInst.NewTableConnection(
        api.OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE_DIRECTLY_CONNECTED,
        api.OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE_BGP,
        api.OpenconfigTypes_ADDRESS_FAMILY_IPV4,
    )
    
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1011.1">/* ... </span><span class="koboSpan" id="kobo.1011.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.1011.3">*/</span></span><span class="koboSpan" id="kobo.1012.1">
    value, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1013.1">=</span></span><span class="koboSpan" id="kobo.1014.1"> ygot.Marshal7951(netInst)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1015.1">// check error</span></span><span class="koboSpan" id="kobo.1016.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1017.1">return</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.1018.1">&amp;</span></span><span class="koboSpan" id="kobo.1019.1">restconfRequest{
        path: fmt.Sprintf(
            </span><span class="Code_Red"><span class="koboSpan" id="kobo.1020.1">"/network-instances/network-instance=%s"</span></span><span class="koboSpan" id="kobo.1021.1">,
            defaultNetInst,
        ),
        payload: value,
    }, </span><span class="Code_Blue"><span class="koboSpan" id="kobo.1022.1">nil</span></span><span class="koboSpan" id="kobo.1023.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.1024.1">The rest of the code in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1025.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1026.1">.3</span></em><span class="koboSpan" id="kobo.1027.1"> shows the building blocks of the program we review in </span><span class="No-Break"><span class="koboSpan" id="kobo.1028.1">this section.</span></span></p>
<h2 id="_idParaDest-198"><a id="_idTextAnchor197"/><span class="koboSpan" id="kobo.1029.1">Device configuration</span></h2>
<p><span class="koboSpan" id="kobo.1030.1">Once </span><a id="_idIndexMarker747"/><span class="koboSpan" id="kobo.1031.1">we’ve prepared all the required RESTCONF RPCs, we can send them to the device. </span><span class="koboSpan" id="kobo.1031.2">We iterate over each </span><strong class="source-inline"><span class="koboSpan" id="kobo.1032.1">restconfRequest</span></strong><span class="koboSpan" id="kobo.1033.1"> and pass it to a helper function, catching any </span><span class="No-Break"><span class="koboSpan" id="kobo.1034.1">returned errors.</span></span></p>
<p><span class="koboSpan" id="kobo.1035.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1036.1">restconfPost</span></strong><span class="koboSpan" id="kobo.1037.1"> helper function has just enough code to build an HTTP request using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1038.1">net/http</span></strong><span class="koboSpan" id="kobo.1039.1"> package and send it to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1040.1">ceos</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1041.1"> device:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1042.1">const</span></span><span class="koboSpan" id="kobo.1043.1"> restconfPath = </span><span class="Code_Red"><span class="koboSpan" id="kobo.1044.1">"/restconf/data"</span></span>
<span class="Code_Purple"><span class="koboSpan" id="kobo.1045.1">func</span></span><span class="koboSpan" id="kobo.1046.1"> restconfPost(cmd </span><span class="Code_Red"><span class="koboSpan" id="kobo.1047.1">*</span></span><span class="koboSpan" id="kobo.1048.1">restconfRequest) </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1049.1">error</span></span><span class="Code_Red"> </span><span class="koboSpan" id="kobo.1050.1">{
  baseURL, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1051.1">=</span></span><span class="koboSpan" id="kobo.1052.1"> url.Parse(
    fmt.Sprintf(
      </span><span class="Code_Red"><span class="koboSpan" id="kobo.1053.1">"https://%s:%d%s"</span></span><span class="koboSpan" id="kobo.1054.1">,
      ceosHostname,
      defaultRestconfPort,
      restconfPath,
    ),
  )
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1055.1">// return error if not nil</span></span><span class="koboSpan" id="kobo.1056.1">
  baseURL.Path = path.Join(restconfPath, cmd.path)
  req, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1057.1">=</span></span><span class="koboSpan" id="kobo.1058.1"> http.NewRequest(
    </span><span class="Code_Red"><span class="koboSpan" id="kobo.1059.1">"POST"</span></span><span class="koboSpan" id="kobo.1060.1">,
    baseURL.String(),
    bytes.NewBuffer(cmd.payload),
  )
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1061.1">// return error if not nil</span></span><span class="koboSpan" id="kobo.1062.1">
  req.Header.Add(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1063.1">"Content-Type"</span></span><span class="koboSpan" id="kobo.1064.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.1065.1">"application/json"</span></span><span class="koboSpan" id="kobo.1066.1">)
  req.Header.Add(
    </span><span class="Code_Red"><span class="koboSpan" id="kobo.1067.1">"Authorization"</span></span><span class="koboSpan" id="kobo.1068.1">,
    </span><span class="Code_Red"><span class="koboSpan" id="kobo.1069.1">"Basic "</span></span><span class="koboSpan" id="kobo.1070.1">+base64.StdEncoding.EncodeToString(
      []</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1071.1">byte</span></span><span class="koboSpan" id="kobo.1072.1">(
        fmt.Sprintf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1073.1">"%s:%s"</span></span><span class="koboSpan" id="kobo.1074.1">, ceosUsername, ceosPassword),
      ),
    ),
  )
  client :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1075.1">=</span></span><span class="koboSpan" id="kobo.1076.1"> &amp;http.Client{Transport: &amp;http.Transport{
        TLSClientConfig: 
          &amp;tls.Config{
            InsecureSkipVerify: </span><span class="Code_Blue"><span class="koboSpan" id="kobo.1077.1">true</span></span><span class="koboSpan" id="kobo.1078.1">
          },
      }
  }
  resp, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1079.1">=</span></span><span class="koboSpan" id="kobo.1080.1"> client.Do(req)
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1081.1">/* ... </span><span class="koboSpan" id="kobo.1081.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.1081.3">*/</span></span><span class="koboSpan" id="kobo.1082.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.1083.1">You can find</span><a id="_idIndexMarker748"/><span class="koboSpan" id="kobo.1084.1"> the complete program in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1085.1">ch08/restconf</span></strong><span class="koboSpan" id="kobo.1086.1"> directory (refer to the </span><em class="italic"><span class="koboSpan" id="kobo.1087.1">Further reading</span></em><span class="koboSpan" id="kobo.1088.1"> section) of this book’s GitHub repository. </span><span class="koboSpan" id="kobo.1088.2">Running it from a host running the lab topology should produce a similar output </span><span class="No-Break"><span class="koboSpan" id="kobo.1089.1">to this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1090.1">ch08/restconf</span><span class="Code_Blue"><span class="koboSpan" id="kobo.1091.1">$ go</span></span><span class="koboSpan" id="kobo.1092.1"> run main.go
2022/04/28 20:49:16 Successfully configured the device</span></pre>
<p><span class="koboSpan" id="kobo.1093.1">At this </span><a id="_idIndexMarker749"/><span class="koboSpan" id="kobo.1094.1">point, we should have all three nodes of our lab topology fully configured. </span><span class="koboSpan" id="kobo.1094.2">Still, we haven’t confirmed that what we’ve done has had the desired effect. </span><span class="koboSpan" id="kobo.1094.3">In the next section, we’ll go through a process of state validation and show how you can do it using </span><span class="No-Break"><span class="koboSpan" id="kobo.1095.1">network APIs.</span></span></p>
<h1 id="_idParaDest-199"><a id="_idTextAnchor198"/><span class="koboSpan" id="kobo.1096.1">State validation</span></h1>
<p><span class="koboSpan" id="kobo.1097.1">In the last</span><a id="_idIndexMarker750"/><span class="koboSpan" id="kobo.1098.1"> three sections of this chapter, we pushed device configs without verifying that the configuration changes had the desired effect. </span><span class="koboSpan" id="kobo.1098.2">This is because we need all devices configured before we can validate the resulting converged operational state. </span><span class="koboSpan" id="kobo.1098.3">Now, with all the code examples from the </span><em class="italic"><span class="koboSpan" id="kobo.1099.1">OpenAPI</span></em><span class="koboSpan" id="kobo.1100.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1101.1">JSON-RPC</span></em><span class="koboSpan" id="kobo.1102.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.1103.1">RESTCONF</span></em><span class="koboSpan" id="kobo.1104.1"> sections executed against the lab topology, we can verify whether we achieved our configuration intent—establish end-to-end reachability between loopback IP addresses of all </span><span class="No-Break"><span class="koboSpan" id="kobo.1105.1">three devices.</span></span></p>
<p><span class="koboSpan" id="kobo.1106.1">In this section, we’ll use the same protocols and modeling language we used earlier in this chapter to validate that each lab device can see the loopback IP address of the other two lab devices </span><a id="_idIndexMarker751"/><span class="koboSpan" id="kobo.1107.1">in its </span><strong class="bold"><span class="koboSpan" id="kobo.1108.1">Forwarding Information Base</span></strong><span class="koboSpan" id="kobo.1109.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1110.1">FIB</span></strong><span class="koboSpan" id="kobo.1111.1">) table. </span><span class="koboSpan" id="kobo.1111.2">You can find the complete code for this section in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1112.1">ch08/state</span></strong><span class="koboSpan" id="kobo.1113.1"> directory (refer to the </span><em class="italic"><span class="koboSpan" id="kobo.1114.1">Further reading</span></em><span class="koboSpan" id="kobo.1115.1"> section) of this book’s GitHub repository. </span><span class="koboSpan" id="kobo.1115.2">Next, we’ll examine a single example of how you can do this with Arista’s cEOS (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1116.1">ceos</span></strong><span class="koboSpan" id="kobo.1117.1">) </span><span class="No-Break"><span class="koboSpan" id="kobo.1118.1">lab device.</span></span></p>
<h2 id="_idParaDest-200"><a id="_idTextAnchor199"/><span class="koboSpan" id="kobo.1119.1">Operational state modeling</span></h2>
<p><span class="koboSpan" id="kobo.1120.1">One</span><a id="_idIndexMarker752"/><span class="koboSpan" id="kobo.1121.1"> thing we need to be mindful of when talking about the operational state of a network element is the difference between the applied and the derived state, as described by the YANG operational state IETF draft (refer to the </span><em class="italic"><span class="koboSpan" id="kobo.1122.1">Further reading</span></em><span class="koboSpan" id="kobo.1123.1"> section). </span><span class="koboSpan" id="kobo.1123.2">The former refers to the currently active device configuration and should reflect what an operator has already applied. </span><span class="koboSpan" id="kobo.1123.3">The latter is a set of read-only values that result from the device’s internal operations, such as CPU or memory utilization, and interaction with external elements, such as packet counters or BGP neighbor state. </span><span class="koboSpan" id="kobo.1123.4">Although we aren’t explicitly mentioning it when we’re talking about an operational state, assume we’re referring to the derived state unless we </span><span class="No-Break"><span class="koboSpan" id="kobo.1124.1">state otherwise.</span></span></p>
<p><span class="koboSpan" id="kobo.1125.1">Historically, there’ve been different ways to model the device’s operational state </span><span class="No-Break"><span class="koboSpan" id="kobo.1126.1">in YANG:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1127.1">You could either enclose everything in a top-level container or read from a separate </span><strong class="source-inline"><span class="koboSpan" id="kobo.1128.1">state</span></strong><span class="koboSpan" id="kobo.1129.1"> datastore, completely distinct from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1130.1">config</span></strong><span class="koboSpan" id="kobo.1131.1"> container/datastore we use for </span><span class="No-Break"><span class="koboSpan" id="kobo.1132.1">configuration management.</span></span></li>
<li><span class="koboSpan" id="kobo.1133.1">Another way is to create a separate </span><strong class="source-inline"><span class="koboSpan" id="kobo.1134.1">state</span></strong><span class="koboSpan" id="kobo.1135.1"> container for every YANG sub-tree alongside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1136.1">config</span></strong><span class="koboSpan" id="kobo.1137.1"> container. </span><span class="koboSpan" id="kobo.1137.2">This is what the YANG operational state IETF draft (refer to the </span><em class="italic"><span class="koboSpan" id="kobo.1138.1">Further reading</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.1139.1">section) describes.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1140.1">Depending</span><a id="_idIndexMarker753"/><span class="koboSpan" id="kobo.1141.1"> on which approach you use, you may need to adjust how you construct your RPC request. </span><span class="koboSpan" id="kobo.1141.2">For example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1142.1">srl</span></strong><span class="koboSpan" id="kobo.1143.1"> device needs an explicit reference to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1144.1">state</span></strong><span class="koboSpan" id="kobo.1145.1"> datastore. </span><span class="koboSpan" id="kobo.1145.2">What we show in the next code example is the alternative approach, where you retrieve a part of the YANG sub-tree and extract the relevant state information </span><span class="No-Break"><span class="koboSpan" id="kobo.1146.1">from it.</span></span></p>
<p><span class="koboSpan" id="kobo.1147.1">It’s worth noting that OpenAPI is less strict about the structure and composition of its models and the state may come from a different part of a tree or require a specific query parameter to reference the operational datastore, depending on </span><span class="No-Break"><span class="koboSpan" id="kobo.1148.1">the implementation.</span></span></p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor200"/><span class="koboSpan" id="kobo.1149.1">Operational state processing</span></h2>
<p><span class="koboSpan" id="kobo.1150.1">Configuration management </span><a id="_idIndexMarker754"/><span class="koboSpan" id="kobo.1151.1">workflows typically involve the processing of some input data to generate a device-specific configuration. </span><span class="koboSpan" id="kobo.1151.2">This is a common workflow that we often use to show the capabilities of an API. </span><span class="koboSpan" id="kobo.1151.3">But there is an equally important workflow that involves operators retrieving state data from a network device, which they process and verify. </span><span class="koboSpan" id="kobo.1151.4">In that case, the information flows in the opposite direction—from a network device to a </span><span class="No-Break"><span class="koboSpan" id="kobo.1152.1">client application.</span></span></p>
<p><span class="koboSpan" id="kobo.1153.1">At the beginning of this chapter, we discussed the configuration management workflow, so now we want to give a high-level overview of the state </span><span class="No-Break"><span class="koboSpan" id="kobo.1154.1">retrieval workflow:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1155.1">We start by querying a remote API endpoint, represented by a set of URL and HTTP </span><span class="No-Break"><span class="koboSpan" id="kobo.1156.1">query parameters.</span></span></li>
<li><span class="koboSpan" id="kobo.1157.1">We receive an HTTP response, which has a binary payload attached </span><span class="No-Break"><span class="koboSpan" id="kobo.1158.1">to it.</span></span></li>
<li><span class="koboSpan" id="kobo.1159.1">We unmarshal this payload into a Go struct that follows the device’s </span><span class="No-Break"><span class="koboSpan" id="kobo.1160.1">data model.</span></span></li>
<li><span class="koboSpan" id="kobo.1161.1">Inside this struct, we look at the relevant parts of the state we can extract </span><span class="No-Break"><span class="koboSpan" id="kobo.1162.1">and evaluate.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1163.1">The following code snippet from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1164.1">ch08/state</span></strong><span class="koboSpan" id="kobo.1165.1"> program (refer to the </span><em class="italic"><span class="koboSpan" id="kobo.1166.1">Further reading</span></em><span class="koboSpan" id="kobo.1167.1"> section) is a concrete example of this workflow. </span><span class="koboSpan" id="kobo.1167.2">The program structure follows the same pattern we described in the </span><em class="italic"><span class="koboSpan" id="kobo.1168.1">State validation</span></em><span class="koboSpan" id="kobo.1169.1"> section of </span><a href="B16971_06.xhtml#_idTextAnchor144"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1170.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.1171.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1172.1">Configuration Management</span></em><span class="koboSpan" id="kobo.1173.1">. </span><span class="koboSpan" id="kobo.1173.2">Hence, in this chapter, we’ll only zoom in on the most relevant part—the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1174.1">GetRoutes</span></strong><span class="koboSpan" id="kobo.1175.1"> function, which connects to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1176.1">ceos</span></strong><span class="koboSpan" id="kobo.1177.1"> device and retrieves</span><a id="_idIndexMarker755"/><span class="koboSpan" id="kobo.1178.1"> the content of its </span><span class="No-Break"><span class="koboSpan" id="kobo.1179.1">routing table.</span></span></p>
<p><span class="koboSpan" id="kobo.1180.1">It starts by building an HTTP request with the device-specific </span><span class="No-Break"><span class="koboSpan" id="kobo.1181.1">login information:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1182.1">func</span></span><span class="koboSpan" id="kobo.1183.1"> (r CEOS) GetRoutes(wg </span><span class="Code_Red"><span class="koboSpan" id="kobo.1184.1">*</span></span><span class="koboSpan" id="kobo.1185.1">sync.WaitGroup) {
  client :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1186.1">=</span></span><span class="koboSpan" id="kobo.1187.1"> resty.NewWithClient(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1188.1">&amp;</span></span><span class="koboSpan" id="kobo.1189.1">http.Client{
    Transport: </span><span class="Code_Red"><span class="koboSpan" id="kobo.1190.1">&amp;</span></span><span class="koboSpan" id="kobo.1191.1">http.Transport{
      TLSClientConfig: </span><span class="Code_Red"><span class="koboSpan" id="kobo.1192.1">&amp;</span></span><span class="koboSpan" id="kobo.1193.1">tls.Config{
        InsecureSkipVerify: </span><span class="Code_Blue"><span class="koboSpan" id="kobo.1194.1">true</span></span><span class="koboSpan" id="kobo.1195.1">},
    },
  })
  client.SetBaseURL(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1196.1">"https://" +</span></span><span class="koboSpan" id="kobo.1197.1"> r.Hostname </span><span class="Code_Red"><span class="koboSpan" id="kobo.1198.1">+ ":6020"</span></span><span class="koboSpan" id="kobo.1199.1">)
  client.SetBasicAuth(r.Username, r.Password)
  resp, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1200.1">=</span></span><span class="koboSpan" id="kobo.1201.1"> client.R().
</span><span class="koboSpan" id="kobo.1201.2">    SetHeader(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1202.1">"Accept"</span></span><span class="koboSpan" id="kobo.1203.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.1204.1">"application/yang-data+json"</span></span><span class="koboSpan" id="kobo.1205.1">).
</span><span class="koboSpan" id="kobo.1205.2">    Get(fmt.Sprintf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1206.1">"/restconf/data/network-instances/network-instance=%s/afts"</span></span><span class="koboSpan" id="kobo.1207.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.1208.1">"default"</span></span><span class="koboSpan" id="kobo.1209.1">))
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1210.1">/* ... </span><span class="koboSpan" id="kobo.1210.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.1210.3">*/</span></span><span class="koboSpan" id="kobo.1211.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.1212.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.1213.1">Abstract Forwarding Table</span></strong><span class="koboSpan" id="kobo.1214.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1215.1">AFT</span></strong><span class="koboSpan" id="kobo.1216.1">) in the</span><a id="_idIndexMarker756"/><span class="koboSpan" id="kobo.1217.1"> code example is an OpenConfig representation of the FIB (routing) table and the GET API call retrieves a JSON </span><a id="_idIndexMarker757"/><span class="koboSpan" id="kobo.1218.1">representation of the default </span><strong class="bold"><span class="koboSpan" id="kobo.1219.1">Virtual Routing and Forwarding</span></strong><span class="koboSpan" id="kobo.1220.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1221.1">VRF</span></strong><span class="koboSpan" id="kobo.1222.1">) </span><span class="No-Break"><span class="koboSpan" id="kobo.1223.1">routing table.</span></span></p>
<p><span class="koboSpan" id="kobo.1224.1">Next, we create </span><a id="_idIndexMarker758"/><span class="koboSpan" id="kobo.1225.1">an instance of the Go struct corresponding to the part of the YANG tree we queried and pass it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1226.1">Unmarshal</span></strong><span class="koboSpan" id="kobo.1227.1"> function for deserialization. </span><span class="koboSpan" id="kobo.1227.2">The resulting Go struct now has one </span><strong class="source-inline"><span class="koboSpan" id="kobo.1228.1">Ipv4Entry</span></strong><span class="koboSpan" id="kobo.1229.1"> value for each entry in the default FIB and we store that list of prefixes in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1230.1">out</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1231.1"> slice:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1232.1">import</span></span><span class="koboSpan" id="kobo.1233.1"> eosAPI </span><span class="Code_Red"><span class="koboSpan" id="kobo.1234.1">"restconf/pkg/eos"</span></span>
<span class="Code_Purple"><span class="koboSpan" id="kobo.1235.1">func</span></span><span class="koboSpan" id="kobo.1236.1"> (r CEOS) GetRoutes(wg </span><span class="Code_Red"><span class="koboSpan" id="kobo.1237.1">*</span></span><span class="koboSpan" id="kobo.1238.1">sync.WaitGroup) {
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1239.1">/* ... </span><span class="koboSpan" id="kobo.1239.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.1239.3">*/</span></span><span class="koboSpan" id="kobo.1240.1">
  response :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1241.1">= &amp;</span></span><span class="koboSpan" id="kobo.1242.1">eosAPI.NetworkInstance_Afts{}
  err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1243.1">=</span></span><span class="koboSpan" id="kobo.1244.1"> eosAPI.Unmarshal(resp.Body(), response)
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1245.1">// process error</span></span><span class="koboSpan" id="kobo.1246.1">
  out :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1247.1">=</span></span><span class="koboSpan" id="kobo.1248.1"> []</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1249.1">string</span></span><span class="koboSpan" id="kobo.1250.1">{}
  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1251.1">for</span></span><span class="koboSpan" id="kobo.1252.1"> key :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1253.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.1254.1">range</span></span><span class="koboSpan" id="kobo.1255.1"> response.Ipv4Entry {
    out </span><span class="Code_Red"><span class="koboSpan" id="kobo.1256.1">=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.1257.1">append</span></span><span class="koboSpan" id="kobo.1258.1">(out, key)
  }
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1259.1">/* ... </span><span class="koboSpan" id="kobo.1259.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.1259.3">*/</span></span><span class="koboSpan" id="kobo.1260.1">
  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1261.1">go</span></span><span class="koboSpan" id="kobo.1262.1"> checkRoutes(r.Hostname, out, expectedRoutes, wg)
}</span></pre>
<p><span class="koboSpan" id="kobo.1263.1">In this example, we import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1264.1">eos</span></strong><span class="koboSpan" id="kobo.1265.1"> package (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1266.1">restconf/pkg/eos</span></strong><span class="koboSpan" id="kobo.1267.1">) we auto-generated in the </span><em class="italic"><span class="koboSpan" id="kobo.1268.1">RESTCONF</span></em><span class="koboSpan" id="kobo.1269.1"> section of this chapter, which lives outside the root directory of this program. </span><span class="koboSpan" id="kobo.1269.2">To do this, we add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1270.1">replace restconf =&gt; ../restconf/</span></strong><span class="koboSpan" id="kobo.1271.1"> instruction to this program’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1272.1">go.mod</span></strong><span class="koboSpan" id="kobo.1273.1"> file (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1274.1">ch08/state/go.mod</span></strong><span class="koboSpan" id="kobo.1275.1">; refer to the </span><em class="italic"><span class="koboSpan" id="kobo.1276.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1277.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1278.1"> section).</span></span></p>
<p><span class="koboSpan" id="kobo.1279.1">For the remaining lab devices, we follow a similar state retrieval workflow. </span><span class="koboSpan" id="kobo.1279.2">The only difference is in the YANG paths and the model-based Go structs we use for deserialization. </span><span class="koboSpan" id="kobo.1279.3">You can find the full program code in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1280.1">ch08/state</span></strong><span class="koboSpan" id="kobo.1281.1"> directory (refer to the </span><em class="italic"><span class="koboSpan" id="kobo.1282.1">Further reading</span></em><span class="koboSpan" id="kobo.1283.1"> section) of this book’s </span><span class="No-Break"><span class="koboSpan" id="kobo.1284.1">GitHub repository.</span></span></p>
<p><span class="koboSpan" id="kobo.1285.1">In this</span><a id="_idIndexMarker759"/><span class="koboSpan" id="kobo.1286.1"> chapter, we have covered network APIs based on HTTP version 1.1 that use common encoding formats, such as JSON. </span><span class="koboSpan" id="kobo.1286.2">Although HTTP is still very popular and this is unlikely to change soon, it has its own limitations that may manifest themselves in large-scale deployments. </span><span class="koboSpan" id="kobo.1286.3">HTTP 1.1 is a text-based protocol, which means it’s not efficient on the wire and its client-server origins make it difficult to adapt it for bi-directional streaming. </span><span class="koboSpan" id="kobo.1286.4">The next version of this protocol, HTTP/2, overcomes these shortcomings. </span><span class="koboSpan" id="kobo.1286.5">HTTP/2 is the transport protocol of the gRPC framework, which is what we’ll examine in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1287.1">next section.</span></span></p>
<h1 id="_idParaDest-202"><a id="_idTextAnchor201"/><span class="koboSpan" id="kobo.1288.1">gRPC</span></h1>
<p><span class="koboSpan" id="kobo.1289.1">Network automation </span><a id="_idIndexMarker760"/><span class="koboSpan" id="kobo.1290.1">opens a door that until recently seemed closed or at least prevented network engineers from reusing technologies that have had success in other areas, such as microservices or </span><span class="No-Break"><span class="koboSpan" id="kobo.1291.1">cloud infrastructure.</span></span></p>
<p><span class="koboSpan" id="kobo.1292.1">One of the most recent advances in network device management is the introduction of gRPC. </span><span class="koboSpan" id="kobo.1292.2">We can use this high-performance RPC framework for a wide range of network operations, from configuration management to state streaming and software management. </span><span class="koboSpan" id="kobo.1292.3">But performance is not the only thing that is appealing about gRPC. </span><span class="koboSpan" id="kobo.1292.4">Just like with YANG and OpenAPI apps, gRPC auto-generates client and server stubs in different programming languages, which enables us to create an ecosystem of tools around </span><span class="No-Break"><span class="koboSpan" id="kobo.1293.1">the API.</span></span></p>
<p><span class="koboSpan" id="kobo.1294.1">In this section, we’ll go over the following topics to help you understand the gRPC </span><span class="No-Break"><span class="koboSpan" id="kobo.1295.1">API better:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.1296.1">Protobuf</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.1297.1">gRPC transport</span></span></li>
<li><span class="koboSpan" id="kobo.1298.1">Defining </span><span class="No-Break"><span class="koboSpan" id="kobo.1299.1">gRPC services</span></span></li>
<li><span class="koboSpan" id="kobo.1300.1">Configuring network devices </span><span class="No-Break"><span class="koboSpan" id="kobo.1301.1">with gRPC</span></span></li>
<li><span class="koboSpan" id="kobo.1302.1">Streaming telemetry from a network device </span><span class="No-Break"><span class="koboSpan" id="kobo.1303.1">with gRPC</span></span></li>
</ul>
<h2 id="_idParaDest-203"><a id="_idTextAnchor202"/><span class="koboSpan" id="kobo.1304.1">Protobuf</span></h2>
<p><span class="koboSpan" id="kobo.1305.1">gRPC uses</span><a id="_idIndexMarker761"/><span class="koboSpan" id="kobo.1306.1"> protobuf as its </span><strong class="bold"><span class="koboSpan" id="kobo.1307.1">Interface Definition Language</span></strong><span class="koboSpan" id="kobo.1308.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1309.1">IDL</span></strong><span class="koboSpan" id="kobo.1310.1">) to allow</span><a id="_idIndexMarker762"/><span class="koboSpan" id="kobo.1311.1"> you to share structured data between remote</span><a id="_idIndexMarker763"/><span class="koboSpan" id="kobo.1312.1"> software components that may be written in different </span><span class="No-Break"><span class="koboSpan" id="kobo.1313.1">programming languages.</span></span></p>
<p><span class="koboSpan" id="kobo.1314.1">When working</span><a id="_idIndexMarker764"/><span class="koboSpan" id="kobo.1315.1"> with protobuf, one of the first steps is to model the information you’re serializing by creating a protobuf file. </span><span class="koboSpan" id="kobo.1315.2">This file has a list of </span><em class="italic"><span class="koboSpan" id="kobo.1316.1">messages</span></em><span class="koboSpan" id="kobo.1317.1"> defining the structure and type of data </span><span class="No-Break"><span class="koboSpan" id="kobo.1318.1">to exchange.</span></span></p>
<p><span class="koboSpan" id="kobo.1319.1">If we take the input data model we have been using throughout this book as an example and encode it in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1320.1">.proto</span></strong><span class="koboSpan" id="kobo.1321.1"> file, it would look something </span><span class="No-Break"><span class="koboSpan" id="kobo.1322.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1323.1">message </span><span class="Code_Green"><span class="koboSpan" id="kobo.1324.1">Router</span></span><span class="Code_Red"> </span><span class="koboSpan" id="kobo.1325.1">{
  repeated </span><span class="Code_Green"><span class="koboSpan" id="kobo.1326.1">Uplink</span></span><span class="Code_Red"> </span><span class="koboSpan" id="kobo.1327.1">uplinks </span><span class="Code_Red"><span class="koboSpan" id="kobo.1328.1">=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1329.1">1</span></span><span class="koboSpan" id="kobo.1330.1">;
  repeated </span><span class="Code_Green"><span class="koboSpan" id="kobo.1331.1">Peer</span></span><span class="Code_Red"> </span><span class="koboSpan" id="kobo.1332.1">peers </span><span class="Code_Red"><span class="koboSpan" id="kobo.1333.1">=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1334.1">2</span></span><span class="koboSpan" id="kobo.1335.1">;
  int32 asn = </span><span class="Code_Green"><span class="koboSpan" id="kobo.1336.1">3</span></span><span class="koboSpan" id="kobo.1337.1">;
  </span><span class="Code_Green"><span class="koboSpan" id="kobo.1338.1">Addr</span></span><span class="Code_Red"> </span><span class="koboSpan" id="kobo.1339.1">loopback </span><span class="Code_Red"><span class="koboSpan" id="kobo.1340.1">=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1341.1">4</span></span><span class="koboSpan" id="kobo.1342.1">; 
}
message </span><span class="Code_Green"><span class="koboSpan" id="kobo.1343.1">Uplink</span></span><span class="Code_Red"> </span><span class="koboSpan" id="kobo.1344.1">{
    string name </span><span class="Code_Red"><span class="koboSpan" id="kobo.1345.1">=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1346.1">1</span></span><span class="koboSpan" id="kobo.1347.1">;
    string prefix </span><span class="Code_Red"><span class="koboSpan" id="kobo.1348.1">=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1349.1">2</span></span><span class="koboSpan" id="kobo.1350.1">;
}
message </span><span class="Code_Green"><span class="koboSpan" id="kobo.1351.1">Peer</span></span><span class="Code_Red"> </span><span class="koboSpan" id="kobo.1352.1">{
    string ip </span><span class="Code_Red"><span class="koboSpan" id="kobo.1353.1">=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1354.1">1</span></span><span class="koboSpan" id="kobo.1355.1">;
    int32 asn </span><span class="Code_Red"><span class="koboSpan" id="kobo.1356.1">=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1357.1">2</span></span><span class="koboSpan" id="kobo.1358.1">;
}
message </span><span class="Code_Green"><span class="koboSpan" id="kobo.1359.1">Addr</span></span><span class="Code_Red"> </span><span class="koboSpan" id="kobo.1360.1">{
  string ip </span><span class="Code_Red"><span class="koboSpan" id="kobo.1361.1">=</span></span> <span class="Code_Green"><span class="koboSpan" id="kobo.1362.1">1</span></span><span class="koboSpan" id="kobo.1363.1">;
}</span></pre>
<p><span class="koboSpan" id="kobo.1364.1">Each field </span><a id="_idIndexMarker765"/><span class="koboSpan" id="kobo.1365.1">has an explicit type and a unique sequence number that identifies it within the </span><span class="No-Break"><span class="koboSpan" id="kobo.1366.1">enclosing message.</span></span></p>
<p><span class="koboSpan" id="kobo.1367.1">The next</span><a id="_idIndexMarker766"/><span class="koboSpan" id="kobo.1368.1"> step in the workflow, just like with OpenAPI or YANG, is to generate bindings for Go (or any other programming language). </span><span class="koboSpan" id="kobo.1368.2">For this, we use the protobuf compiler, protoc, which generates the source code with data structures and methods to access and validate </span><span class="No-Break"><span class="koboSpan" id="kobo.1369.1">different fields:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1370.1">ch08/protobuf$ protoc --go_out=. </span><span class="koboSpan" id="kobo.1370.2">model.proto</span></pre>
<p><span class="koboSpan" id="kobo.1371.1">The preceding command saves the bindings in a single file, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1372.1">pb/model.pb.go</span></strong><span class="koboSpan" id="kobo.1373.1">. </span><span class="koboSpan" id="kobo.1373.2">You can view the contents of this file to see what structs and functions you can use. </span><span class="koboSpan" id="kobo.1373.3">For example, we automatically get this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1374.1">Router</span></strong><span class="koboSpan" id="kobo.1375.1"> struct, which is what we had to define </span><span class="No-Break"><span class="koboSpan" id="kobo.1376.1">manually before:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1377.1">type</span></span><span class="koboSpan" id="kobo.1378.1"> Router </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1379.1">struct</span></span><span class="koboSpan" id="kobo.1380.1"> {
  Uplinks  []</span><span class="Code_Red"><span class="koboSpan" id="kobo.1381.1">*</span></span><span class="koboSpan" id="kobo.1382.1">Uplink 
  Peers    []</span><span class="Code_Red"><span class="koboSpan" id="kobo.1383.1">*</span></span><span class="koboSpan" id="kobo.1384.1">Peer   
  Asn      </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1385.1">int32</span></span><span class="Code_Red"><span class="koboSpan" id="kobo.1386.1">     </span></span><span class="koboSpan" id="kobo.1387.1">
  Loopback </span><span class="Code_Red"><span class="koboSpan" id="kobo.1388.1">*</span></span><span class="koboSpan" id="kobo.1389.1">Addr
}</span></pre>
<p><span class="koboSpan" id="kobo.1390.1">Protobuf encodes</span><a id="_idIndexMarker767"/><span class="koboSpan" id="kobo.1391.1"> a series of key-value pairs in a binary format similar to how routing protocols encode </span><strong class="bold"><span class="koboSpan" id="kobo.1392.1">Type-Length-Values</span></strong><span class="koboSpan" id="kobo.1393.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1394.1">TLVs</span></strong><span class="koboSpan" id="kobo.1395.1">). </span><span class="koboSpan" id="kobo.1395.2">But instead of sending the key name and a declared type for each field, it just sends the field number as the key with its value appended to the end of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1396.1">byte stream.</span></span></p>
<p><span class="koboSpan" id="kobo.1397.1">As with TLVs, Protobuf </span><a id="_idIndexMarker768"/><span class="koboSpan" id="kobo.1398.1">needs to know the length of each value to encode and decode a message successfully. </span><span class="koboSpan" id="kobo.1398.2">For this, Protobuf encodes a wire type in the 8-bit key field along with the field number that comes from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1399.1">.proto</span></strong><span class="koboSpan" id="kobo.1400.1"> file. </span><span class="koboSpan" id="kobo.1400.2">The following table shows the wire </span><span class="No-Break"><span class="koboSpan" id="kobo.1401.1">types available:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-2">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1402.1">Type</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1403.1">Meaning</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1404.1">Used For</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1405.1">0</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.1406.1">Varint</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1407.1">int32, int64, uint32, uint64, sint32, sint64, </span><span class="No-Break"><span class="koboSpan" id="kobo.1408.1">bool, enum</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1409.1">1</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.1410.1">64-bit</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1411.1">fixed64, </span><span class="No-Break"><span class="koboSpan" id="kobo.1412.1">sfixed64, double</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1413.1">2</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.1414.1">Length-delimited</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1415.1">string, bytes, embedded messages, packed </span><span class="No-Break"><span class="koboSpan" id="kobo.1416.1">repeated fields</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1417.1">5</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.1418.1">32-bit</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1419.1">fixed32, </span><span class="No-Break"><span class="koboSpan" id="kobo.1420.1">sfixed32, float</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1421.1">Table 8.1 – Protobuf wire types</span></p>
<p><span class="koboSpan" id="kobo.1422.1">This</span><a id="_idIndexMarker769"/><span class="koboSpan" id="kobo.1423.1"> generates a dense message (small output) that a CPU can process faster compared to a JSON- or XML-encoded message. </span><span class="koboSpan" id="kobo.1423.2">The downside is the message you generate is not human-readable in its native format and it’s only meaningful if you have the message definition (proto file) to find out the name and type for </span><span class="No-Break"><span class="koboSpan" id="kobo.1424.1">each field.</span></span></p>
<h3><span class="koboSpan" id="kobo.1425.1">Protobuf on the wire</span></h3>
<p><span class="koboSpan" id="kobo.1426.1">One of the </span><a id="_idIndexMarker770"/><span class="koboSpan" id="kobo.1427.1">easiest ways to see how protobuf looks in a binary format is to save it into a file. </span><span class="koboSpan" id="kobo.1427.2">In our book’s GitHub repository, we have an example in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1428.1">ch08/protobuf/write</span></strong><span class="koboSpan" id="kobo.1429.1"> directory (refer to the </span><em class="italic"><span class="koboSpan" id="kobo.1430.1">Further reading</span></em><span class="koboSpan" id="kobo.1431.1"> section) that reads a sample </span><strong class="source-inline"><span class="koboSpan" id="kobo.1432.1">input.yaml</span></strong><span class="koboSpan" id="kobo.1433.1"> file and populates the data structure generated from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1434.1">.proto</span></strong><span class="koboSpan" id="kobo.1435.1"> file we discussed earlier. </span><span class="koboSpan" id="kobo.1435.2">We then serialize and save the result into a file we name </span><strong class="source-inline"><span class="koboSpan" id="kobo.1436.1">router.data</span></strong><span class="koboSpan" id="kobo.1437.1">. </span><span class="koboSpan" id="kobo.1437.2">You can use the following command to execute </span><span class="No-Break"><span class="koboSpan" id="kobo.1438.1">this example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1439.1">ch08/protobuf/write</span><span class="Code_Blue"><span class="koboSpan" id="kobo.1440.1">$ go</span></span><span class="koboSpan" id="kobo.1441.1"> run protobuf</span></pre>
<p><span class="koboSpan" id="kobo.1442.1">You can see the content of the generated protobuf message by viewing the file with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1443.1">hexdump -C router.data</span></strong><span class="koboSpan" id="kobo.1444.1">. </span><span class="koboSpan" id="kobo.1444.2">If we group some bytes for convenience and refer to the proto definition file, we can make sense of the data, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1445.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer071">
<span class="koboSpan" id="kobo.1446.1"><img alt="Figure 8.4 – Protobuf-encoded message" src="image/B16971_08_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1447.1">Figure 8.4 – Protobuf-encoded message</span></p>
<p><span class="koboSpan" id="kobo.1448.1">To give </span><a id="_idIndexMarker771"/><span class="koboSpan" id="kobo.1449.1">you an idea of how efficient the protobuf encoding is, we’ve included a couple of JSON files encoding the same data. </span><span class="koboSpan" id="kobo.1449.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1450.1">router.json</span></strong><span class="koboSpan" id="kobo.1451.1"> file is a compact (space-free) JSON encoding. </span><span class="koboSpan" id="kobo.1451.2">The second version, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1452.1">router_ident.json</span></strong><span class="koboSpan" id="kobo.1453.1">, has the same JSON payload indented with extra spaces, which can happen if you generate JSON from a text template or use </span><em class="italic"><span class="koboSpan" id="kobo.1454.1">pretty print</span></em><span class="koboSpan" id="kobo.1455.1"> functions before sending the data over </span><span class="No-Break"><span class="koboSpan" id="kobo.1456.1">the network:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1457.1">ch08/protobuf</span><span class="Code_Blue"><span class="koboSpan" id="kobo.1458.1">$ ls -ls</span></span><span class="koboSpan" id="kobo.1459.1"> router* </span><span class="Green-Dark"><span class="koboSpan" id="kobo.1460.1">|</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.1461.1">awk </span></span><span class="Code_Red"><span class="koboSpan" id="kobo.1462.1">'{print $6, $10}'</span></span>
<span class="Code_Green"><span class="koboSpan" id="kobo.1463.1">108</span></span><span class="koboSpan" id="kobo.1464.1"> router.data
</span><span class="Code_Green"><span class="koboSpan" id="kobo.1465.1">454</span></span><span class="koboSpan" id="kobo.1466.1"> router_indent.json
</span><span class="Code_Green"><span class="koboSpan" id="kobo.1467.1">220</span></span><span class="koboSpan" id="kobo.1468.1"> router.json</span></pre>
<p><span class="koboSpan" id="kobo.1469.1">The difference between JSON and protobuf is quite stark and can become very important when transferring and encoding/decoding </span><span class="No-Break"><span class="koboSpan" id="kobo.1470.1">large datasets.</span></span></p>
<p><span class="koboSpan" id="kobo.1471.1">Now that we know some basics about gRPC data encoding, we can move on to the protocol used to transfer </span><span class="No-Break"><span class="koboSpan" id="kobo.1472.1">these messages.</span></span></p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor203"/><span class="koboSpan" id="kobo.1473.1">gRPC transport</span></h2>
<p><span class="koboSpan" id="kobo.1474.1">Besides</span><a id="_idIndexMarker772"/><span class="koboSpan" id="kobo.1475.1"> efficient binary encoding and enabling simpler framing to serialize your data—compared to newline-delimited plain text—the gRPC framework also attempts to exchange those messages as efficiently as possible over </span><span class="No-Break"><span class="koboSpan" id="kobo.1476.1">the network.</span></span></p>
<p><span class="koboSpan" id="kobo.1477.1">While you can only process one request/response message at a time with HTTP/1.1, gRPC makes use of HTTP/2 to multiplex parallel requests over the same TCP connection. </span><span class="koboSpan" id="kobo.1477.2">Another benefit of HTTP/2 is that it supports header compression. </span><em class="italic"><span class="koboSpan" id="kobo.1478.1">Table 8.2</span></em><span class="koboSpan" id="kobo.1479.1"> shows the various transport methods used by </span><span class="No-Break"><span class="koboSpan" id="kobo.1480.1">different APIs:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table002">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1481.1">API</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1482.1">Transport</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1483.1">RPC/Methods</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.1484.1">NETCONF</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.1485.1">SSH</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1486.1">get-config, edit-config, </span><span class="No-Break"><span class="koboSpan" id="kobo.1487.1">commit, lock</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.1488.1">RESTCONF</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.1489.1">HTTP</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1490.1">GET, POST, </span><span class="No-Break"><span class="koboSpan" id="kobo.1491.1">DELETE, PUT</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.1492.1">gRPC</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.1493.1">HTTP/2</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.1494.1">Unary, server streaming, client streaming, </span><span class="No-Break"><span class="koboSpan" id="kobo.1495.1">bidirectional streaming</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1496.1">Table 8.2 – API comparative table</span></p>
<p><span class="koboSpan" id="kobo.1497.1">Compared to the older network APIs, gRPC not only allows you to make unary or single requests, but it also supports full-duplex streaming. </span><span class="koboSpan" id="kobo.1497.2">Both the client and server can stream data simultaneously, so you no longer need to work around the limitations of the traditional client-server mode </span><span class="No-Break"><span class="koboSpan" id="kobo.1498.1">of interaction.</span></span></p>
<h2 id="_idParaDest-205"><a id="_idTextAnchor204"/><span class="koboSpan" id="kobo.1499.1">Defining gRPC services</span></h2>
<p><span class="koboSpan" id="kobo.1500.1">gRPC uses</span><a id="_idIndexMarker773"/><span class="koboSpan" id="kobo.1501.1"> Protobuf to define statically typed services and messages in a file that we can use to generate the code for client and server applications to consume. </span><span class="koboSpan" id="kobo.1501.2">gRPC abstracts the underlying transport and serialization details, allowing developers to focus on the business logic of their </span><span class="No-Break"><span class="koboSpan" id="kobo.1502.1">applications instead.</span></span></p>
<p><span class="koboSpan" id="kobo.1503.1">A gRPC service is a collection of RPCs that accept and return protobuf messages. </span><span class="koboSpan" id="kobo.1503.2">In the following output, you can see a snippet from Cisco IOS XR’s proto file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1504.1">ems_grpc.proto</span></strong><span class="koboSpan" id="kobo.1505.1"> (refer to the </span><em class="italic"><span class="koboSpan" id="kobo.1506.1">Further reading</span></em><span class="koboSpan" id="kobo.1507.1"> section). </span><span class="koboSpan" id="kobo.1507.2">This file defines a gRPC service called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1508.1">gRPCConfigOper</span></strong><span class="koboSpan" id="kobo.1509.1"> with several RPCs to perform a standard set of configuration </span><span class="No-Break"><span class="koboSpan" id="kobo.1510.1">management operations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1511.1">syntax = </span><span class="Code_Red"><span class="koboSpan" id="kobo.1512.1">"proto3"</span></span><span class="koboSpan" id="kobo.1513.1">;
service gRPCConfigOper {
  rpc GetConfig(ConfigGetArgs) returns(stream ConfigGetReply) {};
        
  rpc MergeConfig(ConfigArgs) returns(ConfigReply) {};
    
  rpc DeleteConfig(ConfigArgs) returns(ConfigReply) {};
    
  rpc ReplaceConfig(ConfigArgs) returns(ConfigReply) {};
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1514.1">/* ... </span><span class="koboSpan" id="kobo.1514.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.1514.3">*/</span></span><span class="koboSpan" id="kobo.1515.1">
  rpc CreateSubs(CreateSubsArgs) returns(stream CreateSubsReply) {};
}</span></pre>
<p><span class="koboSpan" id="kobo.1516.1">As well </span><a id="_idIndexMarker774"/><span class="koboSpan" id="kobo.1517.1">as the configuration management operations, this Cisco IOS XR protobuf definition includes a streaming telemetry subscription (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1518.1">CreateSubs</span></strong><span class="koboSpan" id="kobo.1519.1">) RPC. </span><span class="koboSpan" id="kobo.1519.2">The message format for the request and response is also part of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1520.1">ems_grpc.proto</span></strong><span class="koboSpan" id="kobo.1521.1"> file (refer to the </span><em class="italic"><span class="koboSpan" id="kobo.1522.1">Further reading</span></em><span class="koboSpan" id="kobo.1523.1"> section). </span><span class="koboSpan" id="kobo.1523.2">For example, to invoke the telemetry subscription RPC, the client has to send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1524.1">ConfigArgs</span></strong><span class="koboSpan" id="kobo.1525.1"> message and the server (router) should reply with a stream of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1526.1">CreateSubsReply</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1527.1"> messages.</span></span></p>
<p><span class="koboSpan" id="kobo.1528.1">Unlike with </span><a id="_idIndexMarker775"/><span class="koboSpan" id="kobo.1529.1">NETCONF, where </span><strong class="bold"><span class="koboSpan" id="kobo.1530.1">Request for Comments</span></strong><span class="koboSpan" id="kobo.1531.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1532.1">RFC</span></strong><span class="koboSpan" id="kobo.1533.1">) documents predefine all RPCs, networking vendors didn’t initially push for a standard set of gRPC services. </span><span class="koboSpan" id="kobo.1533.2">This flexibility comes with a cost, as any other vendor could define a similar service, but with different names and message types. </span><span class="koboSpan" id="kobo.1533.3">Here, you can see a snippet from Juniper’s telemetry protobuf file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1534.1">telemetry.proto</span></strong><span class="koboSpan" id="kobo.1535.1"> (refer to the </span><em class="italic"><span class="koboSpan" id="kobo.1536.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1537.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1538.1"> section):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1539.1">syntax = </span><span class="Code_Red"><span class="koboSpan" id="kobo.1540.1">"proto3"</span></span><span class="koboSpan" id="kobo.1541.1">;
service OpenConfigTelemetry {
  rpc telemetrySubscribe(SubscriptionRequest) returns (stream OpenConfigData) {}
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1542.1">/* ... </span><span class="koboSpan" id="kobo.1542.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.1542.3">*/</span></span><span class="koboSpan" id="kobo.1543.1">
  rpc getTelemetryOperationalState(GetOperationalStateRequest) returns(GetOperationalStateReply) {}
  rpc getDataEncodings(DataEncodingRequest) returns (DataEncodingReply) {}
}</span></pre>
<p><span class="koboSpan" id="kobo.1544.1">This is</span><a id="_idIndexMarker776"/><span class="koboSpan" id="kobo.1545.1"> something that the OpenConfig community is addressing with the definition of vendor-agnostic services, such as gNMI (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1546.1">gnmi.proto</span></strong><span class="koboSpan" id="kobo.1547.1">; refer to the </span><em class="italic"><span class="koboSpan" id="kobo.1548.1">Further reading</span></em><span class="koboSpan" id="kobo.1549.1"> section), which we will explore in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1550.1">next chapter:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1551.1">service gNMI {
  rpc Capabilities(CapabilityRequest) returns (CapabilityResponse);
  rpc Get(GetRequest) returns (GetResponse);
  rpc Set(SetRequest) returns (SetResponse);
  rpc Subscribe(stream SubscribeRequest) returns (stream SubscribeResponse);
}</span></pre>
<p><span class="koboSpan" id="kobo.1552.1">Now, let’s see how you can use these RPCs </span><span class="No-Break"><span class="koboSpan" id="kobo.1553.1">with Go.</span></span></p>
<h2 id="_idParaDest-206"><a id="_idTextAnchor205"/><span class="koboSpan" id="kobo.1554.1">Configuring network devices with gRPC</span></h2>
<p><span class="koboSpan" id="kobo.1555.1">In our</span><a id="_idIndexMarker777"/><span class="koboSpan" id="kobo.1556.1"> example program, we configure an IOS XR device with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1557.1">ReplaceConfig</span></strong><span class="koboSpan" id="kobo.1558.1"> RPC, defined in a service called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1559.1">gRPCConfigOper</span></strong><span class="koboSpan" id="kobo.1560.1">. </span><span class="koboSpan" id="kobo.1560.2">You can find all the source code for this program in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1561.1">ch08/grpc</span></strong><span class="koboSpan" id="kobo.1562.1"> directory of this book’s GitHub repository (refer to the </span><em class="italic"><span class="koboSpan" id="kobo.1563.1">Further reading</span></em><span class="koboSpan" id="kobo.1564.1"> section). </span><span class="koboSpan" id="kobo.1564.2">You can use the following command to execute this program against a test device in Cisco’s </span><span class="No-Break"><span class="koboSpan" id="kobo.1565.1">DevNet sandbox:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1566.1">ch08/grpc</span><span class="Code_Blue"><span class="koboSpan" id="kobo.1567.1">$ go</span></span><span class="koboSpan" id="kobo.1568.1"> run grpc</span></pre>
<p><span class="koboSpan" id="kobo.1569.1">Following the same configuration management workflow we’ve used throughout this chapter, we’ll start by generating the code for the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1570.1">gRPC service:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1571.1">service gRPCConfigOper { 
  rpc ReplaceConfig(ConfigArgs) returns(ConfigReply) {};
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1572.1">message</span></span><span class="koboSpan" id="kobo.1573.1"> ConfigArgs {
  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1574.1">int64</span></span><span class="Code_Red"> </span><span class="koboSpan" id="kobo.1575.1">ReqId = </span><span class="Code_Green"><span class="koboSpan" id="kobo.1576.1">1</span></span><span class="koboSpan" id="kobo.1577.1">;
  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1578.1">string</span></span><span class="Code_Red"> </span><span class="koboSpan" id="kobo.1579.1">yangjson = </span><span class="Code_Green"><span class="koboSpan" id="kobo.1580.1">2</span></span><span class="koboSpan" id="kobo.1581.1">;
  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1582.1">bool</span></span><span class="Code_Red"><span class="koboSpan" id="kobo.1583.1">   </span></span><span class="koboSpan" id="kobo.1584.1">Confirmed = </span><span class="Code_Green"><span class="koboSpan" id="kobo.1585.1">3</span></span><span class="koboSpan" id="kobo.1586.1">;
  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1587.1">uint32</span></span><span class="Code_Red"><span class="koboSpan" id="kobo.1588.1">  </span></span><span class="koboSpan" id="kobo.1589.1">ConfirmTimeout = </span><span class="Code_Green"><span class="koboSpan" id="kobo.1590.1">4</span></span><span class="koboSpan" id="kobo.1591.1">;
}</span></pre>
<p><span class="koboSpan" id="kobo.1592.1">One thing to remember when working with gRPC-based network APIs is that they might not define the full data tree natively as protobuf schemas. </span><span class="koboSpan" id="kobo.1592.2">In the preceding example, one field defines a string called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1593.1">yangjson</span></strong><span class="koboSpan" id="kobo.1594.1"> that expects a YANG-based JSON payload, not exploring any further what might be inside that “string.” </span><span class="koboSpan" id="kobo.1594.2">Carrying a YANG-based JSON payload is what we also did in the JSON-RPC and RESTCONF examples. </span><span class="koboSpan" id="kobo.1594.3">In a sense, gRPC serves as a thin RPC wrapper in this example, not too different from JSON-RPC. </span><span class="koboSpan" id="kobo.1594.4">We are still doing the configuration management work with YANG-based </span><span class="No-Break"><span class="koboSpan" id="kobo.1595.1">data structures.</span></span></p>
<p><span class="koboSpan" id="kobo.1596.1">Since we’re now using both gRPC and YANG schemas, we have to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1597.1">protoc</span></strong><span class="koboSpan" id="kobo.1598.1"> together with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1599.1">ygot</span></strong><span class="koboSpan" id="kobo.1600.1"> to generate their respective bindings. </span><span class="koboSpan" id="kobo.1600.2">We run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1601.1">protoc</span></strong><span class="koboSpan" id="kobo.1602.1"> command to generate the code from the proto definition in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1603.1">ch08/grpc/proto</span></strong><span class="koboSpan" id="kobo.1604.1"> (refer to the </span><em class="italic"><span class="koboSpan" id="kobo.1605.1">Further reading</span></em><span class="koboSpan" id="kobo.1606.1"> section) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1607.1">ygot</span></strong><span class="koboSpan" id="kobo.1608.1"> to generate code from a set of OpenConfig YANG models. </span><span class="koboSpan" id="kobo.1608.2">You can find the exact set of commands in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1609.1">ch08/grpc/generate_code</span></strong><span class="koboSpan" id="kobo.1610.1"> file (refer to the </span><em class="italic"><span class="koboSpan" id="kobo.1611.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1612.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1613.1"> section).</span></span></p>
<p><span class="koboSpan" id="kobo.1614.1">Before</span><a id="_idIndexMarker778"/><span class="koboSpan" id="kobo.1615.1"> we can connect to the target device, we need to gather all the information we need to run the program, so we reuse the data structures from </span><a href="B16971_06.xhtml#_idTextAnchor144"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1616.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.1617.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1618.1">Configuration Management</span></em><span class="koboSpan" id="kobo.1619.1">, to store </span><span class="No-Break"><span class="koboSpan" id="kobo.1620.1">this data:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1621.1">type</span></span><span class="koboSpan" id="kobo.1622.1"> Authentication </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1623.1">struct</span></span><span class="koboSpan" id="kobo.1624.1"> {
  Username </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1625.1">string</span></span><span class="koboSpan" id="kobo.1626.1">
  Password </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1627.1">string</span></span><span class="koboSpan" id="kobo.1628.1">
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1629.1">type</span></span><span class="koboSpan" id="kobo.1630.1"> IOSXR </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1631.1">struct</span></span><span class="koboSpan" id="kobo.1632.1"> {
  Hostname </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1633.1">string</span></span><span class="koboSpan" id="kobo.1634.1">
  Authentication
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1635.1">type</span></span><span class="koboSpan" id="kobo.1636.1"> xrgrpc </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1637.1">struct</span></span><span class="koboSpan" id="kobo.1638.1"> {
  IOSXR
  conn </span><span class="Code_Red"><span class="koboSpan" id="kobo.1639.1">*</span></span><span class="koboSpan" id="kobo.1640.1">grpc.ClientConn
  ctx  context.Context
}</span></pre>
<p><span class="koboSpan" id="kobo.1641.1">We start the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1642.1">main</span></strong><span class="koboSpan" id="kobo.1643.1"> function of the program by populating the access credentials and processing </span><a id="_idIndexMarker779"/><span class="koboSpan" id="kobo.1644.1">the device configuration inputs, just like in other examples in </span><span class="No-Break"><span class="koboSpan" id="kobo.1645.1">the book:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1646.1">func</span></span><span class="koboSpan" id="kobo.1647.1"> main() {
  iosxr :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1648.1">=</span></span><span class="koboSpan" id="kobo.1649.1"> xrgrpc{
    IOSXR: IOSXR{
      Hostname: </span><span class="Code_Red"><span class="koboSpan" id="kobo.1650.1">"sandbox-iosxr-1.cisco.com"</span></span><span class="koboSpan" id="kobo.1651.1">,
      Authentication: Authentication{
        Username: </span><span class="Code_Red"><span class="koboSpan" id="kobo.1652.1">"admin"</span></span><span class="koboSpan" id="kobo.1653.1">,
        Password: </span><span class="Code_Red"><span class="koboSpan" id="kobo.1654.1">"C1sco12345"</span></span><span class="koboSpan" id="kobo.1655.1">,
      },
    },
  }
  src, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1656.1">=</span></span><span class="koboSpan" id="kobo.1657.1"> os.Open(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1658.1">"input.yml"</span></span><span class="koboSpan" id="kobo.1659.1">)
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1660.1">// process error</span></span><span class="koboSpan" id="kobo.1661.1">
  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1662.1">defer</span></span><span class="koboSpan" id="kobo.1663.1"> src.Close()
  d :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1664.1">=</span></span><span class="koboSpan" id="kobo.1665.1"> yaml.NewDecoder(src)
  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1666.1">var</span></span><span class="koboSpan" id="kobo.1667.1"> input Model
  err </span><span class="Code_Red"><span class="koboSpan" id="kobo.1668.1">=</span></span><span class="koboSpan" id="kobo.1669.1"> d.Decode(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1670.1">&amp;</span></span><span class="koboSpan" id="kobo.1671.1">input)
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1672.1">/* ... </span><span class="koboSpan" id="kobo.1672.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.1672.3">*/</span></span><span class="koboSpan" id="kobo.1673.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.1674.1">Next, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1675.1">ygot</span></strong><span class="koboSpan" id="kobo.1676.1"> Go bindings from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1677.1">grpc/pkg/oc</span></strong><span class="koboSpan" id="kobo.1678.1"> package to prepare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1679.1">yangjson</span></strong><span class="koboSpan" id="kobo.1680.1"> payload. </span><span class="koboSpan" id="kobo.1680.2">We build the BGP configuration in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1681.1">buildNetworkInstance</span></strong><span class="koboSpan" id="kobo.1682.1"> method in the same way we showed in the </span><em class="italic"><span class="koboSpan" id="kobo.1683.1">JSON-RPC</span></em><span class="koboSpan" id="kobo.1684.1"> section of this chapter. </span><span class="koboSpan" id="kobo.1684.2">Once the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1685.1">oc.Device</span></strong><span class="koboSpan" id="kobo.1686.1"> struct is fully populated, we serialize it into a </span><span class="No-Break"><span class="koboSpan" id="kobo.1687.1">JSON string:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1688.1">func</span></span><span class="koboSpan" id="kobo.1689.1"> main() {
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1690.1">/* ... </span><span class="koboSpan" id="kobo.1690.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.1690.3">*/</span></span><span class="koboSpan" id="kobo.1691.1">
  device :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1692.1">= &amp;</span></span><span class="koboSpan" id="kobo.1693.1">oc.Device{}
  input.buildNetworkInstance(device)
  payload, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1694.1">=</span></span><span class="koboSpan" id="kobo.1695.1"> ygot.EmitJSON(device,
  </span><span class="Code_Red"><span class="koboSpan" id="kobo.1696.1">&amp;</span></span><span class="koboSpan" id="kobo.1697.1">ygot.EmitJSONConfig{
    Format: ygot.RFC7951,
    Indent: </span><span class="Code_Red"><span class="koboSpan" id="kobo.1698.1">"  "</span></span><span class="koboSpan" id="kobo.1699.1">,
    RFC7951Config: </span><span class="Code_Red"><span class="koboSpan" id="kobo.1700.1">&amp;</span></span><span class="koboSpan" id="kobo.1701.1">ygot.RFC7951JSONConfig{
      AppendModuleName: </span><span class="Code_Blue"><span class="koboSpan" id="kobo.1702.1">true</span></span><span class="koboSpan" id="kobo.1703.1">,
    },
  })
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1704.1">/* ... </span><span class="koboSpan" id="kobo.1704.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.1704.3">*/</span></span><span class="koboSpan" id="kobo.1705.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.1706.1">To </span><a id="_idIndexMarker780"/><span class="koboSpan" id="kobo.1707.1">simplify the interactions with the target device, we created a thin wrapper around the gRPC API. </span><span class="koboSpan" id="kobo.1707.2">We define a handful of method receivers for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1708.1">xrgrpc</span></strong><span class="koboSpan" id="kobo.1709.1"> type that implement things such as initial connection establishment and deleting or replacing RPCs. </span><span class="koboSpan" id="kobo.1709.2">This is how we connect and replace the target </span><span class="No-Break"><span class="koboSpan" id="kobo.1710.1">device’s configuration:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1711.1">func</span></span><span class="koboSpan" id="kobo.1712.1"> main() {
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1713.1">/* ... </span><span class="koboSpan" id="kobo.1713.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.1713.3">*/</span></span><span class="koboSpan" id="kobo.1714.1">
  iosxr.Connect()
  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1715.1">defer</span></span><span class="koboSpan" id="kobo.1716.1"> router.conn.Close()
  iosxr.ReplaceConfig(payload)
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1717.1">/* ... </span><span class="koboSpan" id="kobo.1717.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.1717.3">*/</span></span><span class="Code_ligh-Blue"> </span><span class="koboSpan" id="kobo.1718.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.1719.1">Looking closer at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1720.1">ReplaceConfig</span></strong><span class="koboSpan" id="kobo.1721.1"> method, we can see exactly how to invoke the required </span><a id="_idIndexMarker781"/><span class="koboSpan" id="kobo.1722.1">RPC. </span><span class="koboSpan" id="kobo.1722.2">We dynamically generate a random ID and populate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1723.1">ConfigArg</span></strong><span class="koboSpan" id="kobo.1724.1"> message with the YANG-based JSON payload that we generated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1725.1">ygot</span></strong><span class="koboSpan" id="kobo.1726.1"> a couple of steps before. </span><span class="koboSpan" id="kobo.1726.2">The inner </span><strong class="source-inline"><span class="koboSpan" id="kobo.1727.1">ReplaceConfig</span></strong><span class="koboSpan" id="kobo.1728.1"> method is the one that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1729.1">protoc</span></strong><span class="koboSpan" id="kobo.1730.1"> command automatically generated </span><span class="No-Break"><span class="koboSpan" id="kobo.1731.1">for us:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1732.1">func</span></span><span class="koboSpan" id="kobo.1733.1"> (x </span><span class="Code_Red"><span class="koboSpan" id="kobo.1734.1">*</span></span><span class="koboSpan" id="kobo.1735.1">xrgrpc) ReplaceConfig(json </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1736.1">string</span></span><span class="koboSpan" id="kobo.1737.1">) </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1738.1">error</span></span><span class="Code_Red"> </span><span class="koboSpan" id="kobo.1739.1">{
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1740.1">// Random int64 for id</span></span><span class="koboSpan" id="kobo.1741.1">
  id :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1742.1">=</span></span><span class="koboSpan" id="kobo.1743.1"> rand.Int63()
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1744.1">// 'g' is the gRPC stub.</span></span><span class="koboSpan" id="kobo.1745.1">
  g :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1746.1">=</span></span><span class="koboSpan" id="kobo.1747.1"> xr.NewGRPCConfigOperClient(x.conn)
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1748.1">// We send 'a' to the router via the stub.</span></span><span class="koboSpan" id="kobo.1749.1">
  a :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1750.1">=</span></span><span class="koboSpan" id="kobo.1751.1"> xr.ConfigArgs{ReqId: id, Yangjson: json}
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1752.1">// 'r' is the result that comes back from the target.</span></span><span class="koboSpan" id="kobo.1753.1">
  r, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1754.1">=</span></span><span class="koboSpan" id="kobo.1755.1"> g.ReplaceConfig(x.ctx, </span><span class="Code_Red"><span class="koboSpan" id="kobo.1756.1">&amp;</span></span><span class="koboSpan" id="kobo.1757.1">a)
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1758.1">// process error</span></span><span class="koboSpan" id="kobo.1759.1">
  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1760.1">return</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.1761.1">nil</span></span><span class="koboSpan" id="kobo.1762.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.1763.1">The configuration payload we send in this case is a string blob, but we can also encode the content fields with protobuf if the target devices support this. </span><span class="koboSpan" id="kobo.1763.2">This is what we’ll examine next with a streaming </span><span class="No-Break"><span class="koboSpan" id="kobo.1764.1">telemetry example.</span></span></p>
<h2 id="_idParaDest-207"><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.1765.1">Streaming telemetry from a network device with gRPC</span></h2>
<p><span class="koboSpan" id="kobo.1766.1">gRPC streaming</span><a id="_idIndexMarker782"/><span class="koboSpan" id="kobo.1767.1"> capabilities allow </span><a id="_idIndexMarker783"/><span class="koboSpan" id="kobo.1768.1">network devices to send data over a persistent TCP connection either continuously (stream) or on demand (poll). </span><span class="koboSpan" id="kobo.1768.2">We’ll continue with the same program we started earlier and reuse the same connection we set up to configure a network device to subscribe to a </span><span class="No-Break"><span class="koboSpan" id="kobo.1769.1">telemetry stream.</span></span></p>
<p><span class="koboSpan" id="kobo.1770.1">Even though we initiated a connection to the Cisco IOS XR device, the data now flows in the opposite direction. </span><span class="koboSpan" id="kobo.1770.2">This means we need to be able to decode the information we receive and there are two different ways of </span><span class="No-Break"><span class="koboSpan" id="kobo.1771.1">doing this.</span></span></p>
<p><span class="koboSpan" id="kobo.1772.1">Once we’ve configured the device, we request it to stream the operational state of all BGP neighbors. </span><span class="koboSpan" id="kobo.1772.2">In the first scenario, we’ll cover the case where you have the BGP neighbor proto definition to decode the messages you get. </span><span class="koboSpan" id="kobo.1772.3">Then, we’ll examine a less efficient option where a proto definition </span><span class="No-Break"><span class="koboSpan" id="kobo.1773.1">is unnecessary.</span></span></p>
<h3><span class="koboSpan" id="kobo.1774.1">Decoding YANG-defined data with Protobuf</span></h3>
<p><span class="koboSpan" id="kobo.1775.1">We </span><a id="_idIndexMarker784"/><span class="koboSpan" id="kobo.1776.1">use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1777.1">CreateSubs</span></strong><span class="koboSpan" id="kobo.1778.1"> RPC to subscribe to a telemetry stream. </span><span class="koboSpan" id="kobo.1778.2">We need to submit the subscription ID we want to stream and choose an encoding option between </span><strong class="source-inline"><span class="koboSpan" id="kobo.1779.1">gpb</span></strong><span class="koboSpan" id="kobo.1780.1"> for protobuf or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1781.1">gpbkv</span></strong><span class="koboSpan" id="kobo.1782.1"> for an option we’ll explore at the end of this chapter. </span><span class="koboSpan" id="kobo.1782.2">The following output shows the proto definition of this RPC and its </span><span class="No-Break"><span class="koboSpan" id="kobo.1783.1">message types:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1784.1">service gRPCConfigOper { 
  rpc CreateSubs(CreateSubsArgs) returns(stream CreateSubsReply) {};
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1785.1">message</span></span><span class="koboSpan" id="kobo.1786.1"> CreateSubsArgs {
  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1787.1">int64</span></span><span class="Code_Red"> </span><span class="koboSpan" id="kobo.1788.1">ReqId = </span><span class="Code_Green"><span class="koboSpan" id="kobo.1789.1">1</span></span><span class="koboSpan" id="kobo.1790.1">;
  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1791.1">int64</span></span><span class="Code_Red"> </span><span class="koboSpan" id="kobo.1792.1">encode = </span><span class="Code_Green"><span class="koboSpan" id="kobo.1793.1">2</span></span><span class="koboSpan" id="kobo.1794.1">;
  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1795.1">string</span></span><span class="Code_Red"> </span><span class="koboSpan" id="kobo.1796.1">subidstr = </span><span class="Code_Green"><span class="koboSpan" id="kobo.1797.1">3</span></span><span class="koboSpan" id="kobo.1798.1">;
  QOSMarking qos = </span><span class="Code_Green"><span class="koboSpan" id="kobo.1799.1">4</span></span><span class="koboSpan" id="kobo.1800.1">;
  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1801.1">repeated</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.1802.1">string</span></span><span class="Code_Red"> </span><span class="koboSpan" id="kobo.1803.1">Subscriptions = </span><span class="Code_Green"><span class="koboSpan" id="kobo.1804.1">5</span></span><span class="koboSpan" id="kobo.1805.1">;
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1806.1">message</span></span><span class="koboSpan" id="kobo.1807.1"> CreateSubsReply {
  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1808.1">int64</span></span><span class="Code_Red"> </span><span class="koboSpan" id="kobo.1809.1">ResReqId = </span><span class="Code_Green"><span class="koboSpan" id="kobo.1810.1">1</span></span><span class="koboSpan" id="kobo.1811.1">;
  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1812.1">bytes</span></span><span class="Code_Red"> </span><span class="koboSpan" id="kobo.1813.1">data = </span><span class="Code_Green"><span class="koboSpan" id="kobo.1814.1">2</span></span><span class="koboSpan" id="kobo.1815.1">;
  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1816.1">string</span></span><span class="Code_Red"> </span><span class="koboSpan" id="kobo.1817.1">errors = </span><span class="Code_Green"><span class="koboSpan" id="kobo.1818.1">3</span></span><span class="koboSpan" id="kobo.1819.1">;
}</span></pre>
<p><span class="koboSpan" id="kobo.1820.1">Similar</span><a id="_idIndexMarker785"/><span class="koboSpan" id="kobo.1821.1"> to the configuration part of the program, we create a helper function to submit the request to the router. </span><span class="koboSpan" id="kobo.1821.2">The main difference is that now the reply is a data stream. </span><span class="koboSpan" id="kobo.1821.3">We store the result of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1822.1">CreateSubs</span></strong><span class="koboSpan" id="kobo.1823.1"> in a variable we </span><span class="No-Break"><span class="koboSpan" id="kobo.1824.1">call </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1825.1">st</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1826.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1827.1">For data streams, gRPC gives us the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1828.1">Recv</span></strong><span class="koboSpan" id="kobo.1829.1"> method, which blocks until it receives a message. </span><span class="koboSpan" id="kobo.1829.2">To continue processing in the main thread, we run an anonymous function in a separate goroutine that calls the auto-generated </span><strong class="source-inline"><span class="koboSpan" id="kobo.1830.1">GetData</span></strong><span class="koboSpan" id="kobo.1831.1"> method. </span><span class="koboSpan" id="kobo.1831.2">This method returns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1832.1">data</span></strong><span class="koboSpan" id="kobo.1833.1"> field of each message we get and we send it over a channel (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1834.1">b</span></strong><span class="koboSpan" id="kobo.1835.1">) back to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1836.1">main goroutine:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1837.1">func</span></span><span class="koboSpan" id="kobo.1838.1"> (x </span><span class="Code_Red"><span class="koboSpan" id="kobo.1839.1">*</span></span><span class="koboSpan" id="kobo.1840.1">xrgrpc) GetSubscription(sub, enc </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1841.1">string</span></span><span class="koboSpan" id="kobo.1842.1">) (</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1843.1">chan</span></span><span class="koboSpan" id="kobo.1844.1"> []</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1845.1">byte</span></span><span class="koboSpan" id="kobo.1846.1">, </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1847.1">chan</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.1848.1">error</span></span><span class="koboSpan" id="kobo.1849.1">, </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1850.1">error</span></span><span class="koboSpan" id="kobo.1851.1">) {
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1852.1">/* ... </span><span class="koboSpan" id="kobo.1852.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.1852.3">*/</span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.1853.1">  </span></span>
<span class="Code_Brown"><span class="koboSpan" id="kobo.1854.1">  // 'c' is the gRPC stub.</span></span><span class="koboSpan" id="kobo.1855.1">
  c :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1856.1">=</span></span><span class="koboSpan" id="kobo.1857.1"> xr.NewGRPCConfigOperClient(x.conn)
  /</span><span class="Code_ligh-Blue"><span class="koboSpan" id="kobo.1858.1">/ 'b' is the bytes channel where telemetry is sent.</span></span><span class="koboSpan" id="kobo.1859.1">
  b :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1860.1">=</span></span><span class="koboSpan" id="kobo.1861.1"> make(</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1862.1">chan</span></span><span class="koboSpan" id="kobo.1863.1"> []</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1864.1">byte</span></span><span class="koboSpan" id="kobo.1865.1">)
  a :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1866.1">=</span></span><span class="koboSpan" id="kobo.1867.1"> xr.CreateSubsArgs{
        ReqId: id, Encode: encoding, Subidstr: sub}
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1868.1">// 'r' is the result that comes back from the target.</span></span><span class="koboSpan" id="kobo.1869.1">
  st, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1870.1">=</span></span><span class="koboSpan" id="kobo.1871.1"> c.CreateSubs(x.ctx, &amp;a)
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1872.1">// process error</span></span><span class="koboSpan" id="kobo.1873.1">
  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1874.1">go func</span></span><span class="koboSpan" id="kobo.1875.1">() {
    r, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1876.1">=</span></span><span class="koboSpan" id="kobo.1877.1"> st.Recv()
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1878.1">/* ... </span><span class="koboSpan" id="kobo.1878.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.1878.3">*/</span></span><span class="koboSpan" id="kobo.1879.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1880.1">for</span></span><span class="koboSpan" id="kobo.1881.1"> {
      </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1882.1">select</span></span><span class="koboSpan" id="kobo.1883.1"> {
      </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1884.1">/* ... </span><span class="koboSpan" id="kobo.1884.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.1884.3">*/</span></span><span class="koboSpan" id="kobo.1885.1">
      </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1886.1">case</span></span><span class="koboSpan" id="kobo.1887.1"> b </span><span class="Code_Red"><span class="koboSpan" id="kobo.1888.1">&lt;-</span></span><span class="koboSpan" id="kobo.1889.1"> r.GetData():
      </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1890.1">/* ... </span><span class="koboSpan" id="kobo.1890.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.1890.3">*/</span></span><span class="koboSpan" id="kobo.1891.1">
      }
    }
  }()
  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1892.1">return</span></span><span class="koboSpan" id="kobo.1893.1"> b, e, err
}</span></pre>
<p><span class="koboSpan" id="kobo.1894.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1895.1">data</span></strong><span class="koboSpan" id="kobo.1896.1"> field, and </span><a id="_idIndexMarker786"/><span class="koboSpan" id="kobo.1897.1">hence the data we receive in channel </span><strong class="source-inline"><span class="koboSpan" id="kobo.1898.1">b</span></strong><span class="koboSpan" id="kobo.1899.1">, consist of arrays of bytes that we need to decode. </span><span class="koboSpan" id="kobo.1899.2">We know this is a streaming telemetry message, so we use its proto-generated code to decode its fields. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1900.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1901.1">.5</span></em><span class="koboSpan" id="kobo.1902.1"> shows an example of how we can get to BGP state information by following the proto </span><span class="No-Break"><span class="koboSpan" id="kobo.1903.1">file definitions:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer072">
<span class="koboSpan" id="kobo.1904.1"><img alt="Figure 8.5 – Protobuf telemetry message (protobuf)" src="image/B16971_08_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1905.1">Figure 8.5 – Protobuf telemetry message (protobuf)</span></p>
<p><span class="koboSpan" id="kobo.1906.1">Back in </span><a id="_idIndexMarker787"/><span class="koboSpan" id="kobo.1907.1">the main goroutine, we listen out for what the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1908.1">GetSubscription</span></strong><span class="koboSpan" id="kobo.1909.1"> channel returns and iterate over each message we get. </span><span class="koboSpan" id="kobo.1909.2">We unmarshal the data received into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1910.1">Telemetry</span></strong><span class="koboSpan" id="kobo.1911.1"> message. </span><span class="koboSpan" id="kobo.1911.2">At this point, we have access to the general telemetry data, so we can use the auto-generated functions to access some of its fields, such as the timestamp and the </span><span class="No-Break"><span class="koboSpan" id="kobo.1912.1">encoding path:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1913.1">func</span></span><span class="koboSpan" id="kobo.1914.1"> main() {
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1915.1">/* ... </span><span class="koboSpan" id="kobo.1915.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.1915.3">*/</span></span><span class="koboSpan" id="kobo.1916.1">
  ch, errCh, err := router.GetSubscription(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1917.1">"BGP"</span></span><span class="koboSpan" id="kobo.1918.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.1919.1">"gpb"</span></span><span class="koboSpan" id="kobo.1920.1">)
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1921.1">// process error</span></span><span class="koboSpan" id="kobo.1922.1">
    
  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1923.1">for</span></span><span class="koboSpan" id="kobo.1924.1"> msg :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1925.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.1926.1">range</span></span><span class="koboSpan" id="kobo.1927.1"> ch {
    message :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1928.1">=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.1929.1">new</span></span><span class="koboSpan" id="kobo.1930.1">(telemetry.Telemetry)
    proto.Unmarshal(msg, message)
        
    t :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1931.1">=</span></span><span class="koboSpan" id="kobo.1932.1"> time.UnixMilli(</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1933.1">int64</span></span><span class="koboSpan" id="kobo.1934.1">(message.GetMsgTimestamp()))
    fmt.Printf(
      </span><span class="Code_Red"><span class="koboSpan" id="kobo.1935.1">"Time: %v\nPath: %v\n\n"</span></span><span class="koboSpan" id="kobo.1936.1">,
      t.Format(time.ANSIC),
      message.GetEncodingPath(),
    )
    </span><span class="Code_ligh-Blue"><span class="koboSpan" id="kobo.1937.1">/* ... </span><span class="koboSpan" id="kobo.1937.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.1937.3">*/</span></span><span class="koboSpan" id="kobo.1938.1">
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.1939.1">Following </span><a id="_idIndexMarker788"/><span class="koboSpan" id="kobo.1940.1">that, we extract the content of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1941.1">data_bgp</span></strong><span class="koboSpan" id="kobo.1942.1"> field to access the BGP data encoded with protobuf. </span><span class="koboSpan" id="kobo.1942.2">Cisco IOS XR lists the items in rows, so for each one, we unmarshal the content into the auto-generated </span><strong class="source-inline"><span class="koboSpan" id="kobo.1943.1">BgpNbrBag</span></strong><span class="koboSpan" id="kobo.1944.1"> data structure, from where we can access all operational information of a BGP neighbor. </span><span class="koboSpan" id="kobo.1944.2">This way, we get the connection state and the IPv4 address of the BGP peer, which we print to </span><span class="No-Break"><span class="koboSpan" id="kobo.1945.1">the screen:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1946.1">func</span></span><span class="koboSpan" id="kobo.1947.1"> main() {
  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1948.1">for</span></span><span class="koboSpan" id="kobo.1949.1"> msg :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1950.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.1951.1">range</span></span><span class="koboSpan" id="kobo.1952.1"> ch {
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1953.1">/* ... </span><span class="koboSpan" id="kobo.1953.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.1953.3">*/</span></span><span class="Code_ligh-Blue"><span class="koboSpan" id="kobo.1954.1">  </span></span><span class="koboSpan" id="kobo.1955.1">
    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1956.1">for</span></span><span class="koboSpan" id="kobo.1957.1"> _, row :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1958.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.1959.1">range</span></span><span class="koboSpan" id="kobo.1960.1"> message.GetDataGpb().GetRow() {
      content :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1961.1">=</span></span><span class="koboSpan" id="kobo.1962.1"> row.GetContent()
      nbr :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1963.1">=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.1964.1">new</span></span><span class="koboSpan" id="kobo.1965.1">(bgp.BgpNbrBag)
      err </span><span class="Code_Red"><span class="koboSpan" id="kobo.1966.1">=</span></span><span class="koboSpan" id="kobo.1967.1"> proto.Unmarshal(content, nbr)
      </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1968.1">if</span></span><span class="koboSpan" id="kobo.1969.1"> err </span><span class="Code_Red"><span class="koboSpan" id="kobo.1970.1">!=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.1971.1">nil</span></span><span class="Code_Green"> </span><span class="koboSpan" id="kobo.1972.1">{
        fmt.Printf(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1973.1">"could decode Content: %v\n"</span></span><span class="koboSpan" id="kobo.1974.1">, err)
        </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1975.1">return</span></span><span class="koboSpan" id="kobo.1976.1">
      }
      state :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1977.1">=</span></span><span class="koboSpan" id="kobo.1978.1"> nbr.GetConnectionState()
      addr :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1979.1">=</span></span><span class="koboSpan" id="kobo.1980.1"> nbr.GetConnectionRemoteAddress().Ipv4Address
      fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1981.1">"  Neighbor: "</span></span><span class="koboSpan" id="kobo.1982.1">, addr)
      fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1983.1">"  Connection state: "</span></span><span class="koboSpan" id="kobo.1984.1">, state)
    }
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.1985.1">If you </span><a id="_idIndexMarker789"/><span class="koboSpan" id="kobo.1986.1">don’t have access to the BGP message definition (proto file), gRPC can still represent the fields with protobuf, but it has to add the name and value type for each one, so the receiving end can parse them. </span><span class="koboSpan" id="kobo.1986.2">This is what we’ll </span><span class="No-Break"><span class="koboSpan" id="kobo.1987.1">examine next.</span></span></p>
<h3><span class="koboSpan" id="kobo.1988.1">Protobuf self-describing messages</span></h3>
<p><span class="koboSpan" id="kobo.1989.1">While </span><a id="_idIndexMarker790"/><span class="koboSpan" id="kobo.1990.1">self-describing messages in a way defeat the purpose of protobuf by sending unnecessary data, we’ve included an example here to contrast how you could parse a message in </span><span class="No-Break"><span class="koboSpan" id="kobo.1991.1">this scenario:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer073">
<span class="koboSpan" id="kobo.1992.1"><img alt="Figure 8.6 – Protobuf self-describing telemetry message (JSON)" src="image/B16971_08_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1993.1">Figure 8.6 – Protobuf self-describing telemetry message (JSON)</span></p>
<p><span class="koboSpan" id="kobo.1994.1">The </span><a id="_idIndexMarker791"/><span class="koboSpan" id="kobo.1995.1">telemetry header is the same, but when you choose </span><strong class="source-inline"><span class="koboSpan" id="kobo.1996.1">gpbkv</span></strong><span class="koboSpan" id="kobo.1997.1"> as the encoding format, Cisco IOS XR sends the data in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1998.1">data_bgpkv</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1999.1">field instead:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.2000.1">func</span></span><span class="koboSpan" id="kobo.2001.1"> main() {
  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.2002.1">for</span></span><span class="koboSpan" id="kobo.2003.1"> msg :</span><span class="Code_Red"><span class="koboSpan" id="kobo.2004.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.2005.1">range</span></span><span class="koboSpan" id="kobo.2006.1"> ch {
    message :</span><span class="Code_Red"><span class="koboSpan" id="kobo.2007.1">=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.2008.1">new</span></span><span class="koboSpan" id="kobo.2009.1">(telemetry.Telemetry)
    err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.2010.1">=</span></span><span class="koboSpan" id="kobo.2011.1"> proto.Unmarshal(msg, message)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.2012.1">/* ... </span><span class="koboSpan" id="kobo.2012.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.2012.3">*/</span></span><span class="koboSpan" id="kobo.2013.1">
    b, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.2014.1">=</span></span><span class="koboSpan" id="kobo.2015.1"> json.Marshal(message.GetDataGpbkv())
    check(err)
    j :</span><span class="Code_Red"><span class="koboSpan" id="kobo.2016.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.2017.1">string</span></span><span class="koboSpan" id="kobo.2018.1">(b)
    </span><span class="Code_Brown"><span class="koboSpan" id="kobo.2019.1">// https://go.dev/play/p/uyWenG-1Keu</span></span><span class="koboSpan" id="kobo.2020.1">
    data :</span><span class="Code_Red"><span class="koboSpan" id="kobo.2021.1">=</span></span><span class="koboSpan" id="kobo.2022.1"> gjson.Get(
      j,
      </span><span class="Code_Red"><span class="koboSpan" id="kobo.2023.1">"0.fields.0.fields.#(name==neighbor-address).ValueByType.StringValue"</span></span><span class="koboSpan" id="kobo.2024.1">,
    )
    fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.2025.1">"  Neighbor: "</span></span><span class="koboSpan" id="kobo.2026.1">, data)
    data </span><span class="Code_Red"><span class="koboSpan" id="kobo.2027.1">=</span></span><span class="koboSpan" id="kobo.2028.1"> gjson.Get(
      j,
      </span><span class="Code_Red"><span class="koboSpan" id="kobo.2029.1">"0.fields.1.fields.#(name==connection-state).ValueByType.StringValue"</span></span><span class="koboSpan" id="kobo.2030.1">,
    )
    fmt.Println(</span><span class="Code_Red"><span class="koboSpan" id="kobo.2031.1">"  Connection state: "</span></span><span class="koboSpan" id="kobo.2032.1">, data)
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.2033.1">At this </span><a id="_idIndexMarker792"/><span class="koboSpan" id="kobo.2034.1">point, what you have is a big JSON file you can navigate using a Go package of your preference. </span><span class="koboSpan" id="kobo.2034.2">Here, we’ve used </span><strong class="source-inline"><span class="koboSpan" id="kobo.2035.1">gjson</span></strong><span class="koboSpan" id="kobo.2036.1">. </span><span class="koboSpan" id="kobo.2036.2">To test this program, you can rerun the same program we described earlier with an extra flag to enable the self-describing </span><span class="No-Break"><span class="koboSpan" id="kobo.2037.1">key-value messages:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.2038.1">ch08/grpc</span><span class="Code_Blue"><span class="koboSpan" id="kobo.2039.1">$ go</span></span><span class="koboSpan" id="kobo.2040.1"> run grpc </span><span class="Code_Blue"><span class="koboSpan" id="kobo.2041.1">-kvmode</span></span><span class="Code_Red"><span class="koboSpan" id="kobo.2042.1">=</span></span><span class="koboSpan" id="kobo.2043.1">true</span></pre>
<p><span class="koboSpan" id="kobo.2044.1">While this method might seem less involved, not only do you compromise the performance benefits but also, by not knowing the Go data structures beforehand, it opens up room for bugs and typos, it prevents you from taking advantage of the auto-completion features of most IDEs, and it makes your code less explicit. </span><span class="koboSpan" id="kobo.2044.2">All of that has a negative impact</span><a id="_idIndexMarker793"/><span class="koboSpan" id="kobo.2045.1"> on code development </span><span class="No-Break"><span class="koboSpan" id="kobo.2046.1">and troubleshooting.</span></span></p>
<h1 id="_idParaDest-208"><a id="_idTextAnchor207"/><span class="koboSpan" id="kobo.2047.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.2048.1">In this chapter, we explored different ways to use APIs and RPCs to interact with network devices. </span><span class="koboSpan" id="kobo.2048.2">One common theme we saw throughout this chapter was having a model for any data we exchange. </span><span class="koboSpan" id="kobo.2048.3">Although the network community has embraced YANG as the standard language to model network configuration and operational state data, the implementation differences across networking vendors still impede its </span><span class="No-Break"><span class="koboSpan" id="kobo.2049.1">wide adoption.</span></span></p>
<p><span class="koboSpan" id="kobo.2050.1">In the next chapter, we’ll look at how OpenConfig tries to increase the adoption of declarative configuration and model-driven management and operations by defining a set of vendor-neutral models </span><span class="No-Break"><span class="koboSpan" id="kobo.2051.1">and protocols.</span></span></p>
<h1 id="_idParaDest-209"><a id="_idTextAnchor208"/><span class="koboSpan" id="kobo.2052.1">Further reading</span></h1>
<ul>
<li><span class="koboSpan" id="kobo.2053.1">The book’s GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.2054.1">repository: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go"><span class="No-Break"><span class="koboSpan" id="kobo.2055.1">https://github.com/PacktPublishing/Network-Automation-with-Go</span></span></a></li>
<li><span class="koboSpan" id="kobo.2056.1">OpenAPI </span><span class="No-Break"><span class="koboSpan" id="kobo.2057.1">versions: </span></span><a href="https://swagger.io/specification/#appendix-a-revision-history"><span class="No-Break"><span class="koboSpan" id="kobo.2058.1">https://swagger.io/specification/#appendix-a-revision-history</span></span></a></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.2059.1">CUE: </span></span><a href="https://cuelang.org/"><span class="No-Break"><span class="koboSpan" id="kobo.2060.1">https://cuelang.org/</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2061.1">ch08/cue/template.cue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2062.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/cue/template.cue"><span class="No-Break"><span class="koboSpan" id="kobo.2063.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/cue/template.cue</span></span></a></li>
<li><span class="koboSpan" id="kobo.2064.1">CUE’s </span><em class="italic"><span class="koboSpan" id="kobo.2065.1">References and Visibility</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.2066.1">tutorial: </span></span><a href="https://cuelang.org/docs/tutorials/tour/references/"><span class="No-Break"><span class="koboSpan" id="kobo.2067.1">https://cuelang.org/docs/tutorials/tour/references/</span></span></a></li>
<li><span class="koboSpan" id="kobo.2068.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2069.1">ch08/cue</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.2070.1">directory: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/cue"><span class="No-Break"><span class="koboSpan" id="kobo.2071.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/cue</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2072.1">ch08/cue/cue_tool.cue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2073.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/cue/cue_tool.cue"><span class="No-Break"><span class="koboSpan" id="kobo.2074.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/cue/cue_tool.cue</span></span></a></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.2075.1">Istio: </span></span><a href="https://istio.io/"><span class="No-Break"><span class="koboSpan" id="kobo.2076.1">https://istio.io/</span></span></a></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.2077.1">dagger.io: </span></span><a href="https://dagger.io/"><span class="No-Break"><span class="koboSpan" id="kobo.2078.1">https://dagger.io/</span></span></a></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.2079.1">Jsonnet: </span></span><a href="https://github.com/google/go-jsonnet"><span class="No-Break"><span class="koboSpan" id="kobo.2080.1">https://github.com/google/go-jsonnet</span></span></a></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.2081.1">Dhall: </span></span><a href="https://github.com/philandstuff/dhall-golang"><span class="No-Break"><span class="koboSpan" id="kobo.2082.1">https://github.com/philandstuff/dhall-golang</span></span></a></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.2083.1">JSON-RPC: </span></span><a href="https://documentation.nokia.com/srlinux/SR_Linux_HTML_R21-11/SysMgmt_Guide/json-interface.html"><span class="No-Break"><span class="koboSpan" id="kobo.2084.1">https://documentation.nokia.com/srlinux/SR_Linux_HTML_R21-11/SysMgmt_Guide/json-interface.html</span></span></a></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.2085.1">openconfig/ygot: </span></span><span class="No-Break"><span class="koboSpan" id="kobo.2086.1">https://github.com/openconfig/ygot</span></span></li>
<li><span class="koboSpan" id="kobo.2087.1">Nokia’s YANG </span><span class="No-Break"><span class="koboSpan" id="kobo.2088.1">models: </span></span><a href="https://github.com/nokia/srlinux-yang-models"><span class="No-Break"><span class="koboSpan" id="kobo.2089.1">https://github.com/nokia/srlinux-yang-models</span></span></a></li>
<li><span class="koboSpan" id="kobo.2090.1">The YANG </span><span class="No-Break"><span class="koboSpan" id="kobo.2091.1">browser: </span></span><a href="https://yang.srlinux.dev/v21.6.4/"><span class="No-Break"><span class="koboSpan" id="kobo.2092.1">https://yang.srlinux.dev/v21.6.4/</span></span></a></li>
<li><span class="koboSpan" id="kobo.2093.1">ygot’s official </span><span class="No-Break"><span class="koboSpan" id="kobo.2094.1">documentation: </span></span><a href="https://github.com/openconfig/ygot#introduction"><span class="No-Break"><span class="koboSpan" id="kobo.2095.1">https://github.com/openconfig/ygot#introduction</span></span></a></li>
<li><span class="koboSpan" id="kobo.2096.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2097.1">ch08/json-rpc/main.go</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.2098.1">file: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/json-rpc/main.go"><span class="No-Break"><span class="koboSpan" id="kobo.2099.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/json-rpc/main.go</span></span></a></li>
<li><span class="koboSpan" id="kobo.2100.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2101.1">ch08/json-rpc</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.2102.1">directory: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/json-rpc"><span class="No-Break"><span class="koboSpan" id="kobo.2103.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/json-rpc</span></span></a></li>
<li><span class="koboSpan" id="kobo.2104.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2105.1">yget</span></strong><span class="koboSpan" id="kobo.2106.1"> library design </span><span class="No-Break"><span class="koboSpan" id="kobo.2107.1">documentation: </span></span><a href="https://github.com/openconfig/ygot/blob/master/docs/design.md#openconfig-path-compression"><span class="No-Break"><span class="koboSpan" id="kobo.2108.1">https://github.com/openconfig/ygot/blob/master/docs/design.md#openconfig-path-compression</span></span></a></li>
<li><span class="koboSpan" id="kobo.2109.1">Arista YANG </span><span class="No-Break"><span class="koboSpan" id="kobo.2110.1">models: </span></span><a href="https://github.com/aristanetworks/yang"><span class="No-Break"><span class="koboSpan" id="kobo.2111.1">https://github.com/aristanetworks/yang</span></span></a></li>
<li><span class="koboSpan" id="kobo.2112.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2113.1">ch08/restconf</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.2114.1">directory: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch08/restconf"><span class="No-Break"><span class="koboSpan" id="kobo.2115.1">https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch08/restconf</span></span></a></li>
<li><span class="koboSpan" id="kobo.2116.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2117.1">ch08/state</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.2118.1">directory: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch08/state"><span class="No-Break"><span class="koboSpan" id="kobo.2119.1">https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch08/state</span></span></a></li>
<li><span class="koboSpan" id="kobo.2120.1">IETF </span><span class="No-Break"><span class="koboSpan" id="kobo.2121.1">draft: </span></span><a href="https://datatracker.ietf.org/doc/html/draft-openconfig-netmod-opstate-01"><span class="No-Break"><span class="koboSpan" id="kobo.2122.1">https://datatracker.ietf.org/doc/html/draft-openconfig-netmod-opstate-01</span></span></a></li>
<li><span class="koboSpan" id="kobo.2123.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2124.1">ch08/state</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.2125.1">program: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch08/state"><span class="No-Break"><span class="koboSpan" id="kobo.2126.1">https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch08/state</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2127.1">ch08/state/go.mod</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2128.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/state/go.mod"><span class="No-Break"><span class="koboSpan" id="kobo.2129.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/state/go.mod</span></span></a></li>
<li><span class="koboSpan" id="kobo.2130.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2131.1">ch08/protobuf/write</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.2132.1">directory: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch08/protobuf/write"><span class="No-Break"><span class="koboSpan" id="kobo.2133.1">https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch08/protobuf/write</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2134.1">ems_grpc.proto</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2135.1">: </span></span><a href="https://github.com/nleiva/xrgrpc/blob/master/proto/ems/ems_grpc.proto"><span class="No-Break"><span class="koboSpan" id="kobo.2136.1">https://github.com/nleiva/xrgrpc/blob/master/proto/ems/ems_grpc.proto</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2137.1">telemetry.proto</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2138.1">: </span></span><a href="https://github.com/Juniper/jtimon/blob/master/telemetry/telemetry.proto"><span class="No-Break"><span class="koboSpan" id="kobo.2139.1">https://github.com/Juniper/jtimon/blob/master/telemetry/telemetry.proto</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2140.1">gnmi.proto</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2141.1">: </span></span><a href="https://github.com/openconfig/gnmi/blob/master/proto/gnmi/gnmi.proto"><span class="No-Break"><span class="koboSpan" id="kobo.2142.1">https://github.com/openconfig/gnmi/blob/master/proto/gnmi/gnmi.proto</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2143.1">ch08/grpc/proto</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2144.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch08/grpc/proto"><span class="No-Break"><span class="koboSpan" id="kobo.2145.1">https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch08/grpc/proto</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2146.1">ch08/grpc/generate_code</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2147.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/grpc/generate_code"><span class="No-Break"><span class="koboSpan" id="kobo.2148.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/grpc/generate_code</span></span></a></li>
</ul>
</div>
</body></html>