["```go\npackage cvx\nimport \"network.automation:input\"\ninterface: _interfaces\nrouter: bgp: {\n    _global_bgp\n}\nvrf: _vrf\n_global_bgp: {\n    \"autonomous-system\": input.asn\n    enable:              \"on\"\n    \"router-id\":         input.loopback.ip\n}\n_interfaces: {\n    lo: {\n        ip: address: \"\\(input.LoopbackIP)\": {}\n        type: \"loopback\"\n    }\n    for intf in input.uplinks {\n        \"\\(intf.name)\": {\n            type: \"swp\"\n            ip: address: \"\\(intf.prefix)\": {}\n        }\n    }\n}\n/* ... omitted for brevity ... */\n```", "```go\n# input.yaml\nasn: 65002\nloopback: \n  ip: \"198.51.100.2\"\nuplinks:\n  - name: \"swp1\"\n    prefix: \"192.0.2.3/31\"\npeers:\n  - ip: \"192.0.2.2\"\n    asn: 65001\n```", "```go\npackage input\nimport (\n    \"net\"\n)\nasn: <=65535 & >=64512\nloopback: ip: net.IPv4 & string\nuplinks: [...{\n    name:   string\n    prefix: net.IPCIDR & string\n}]\npeers: [...{\n    ip:  net.IPv4 & string\n    asn: <=65535 & >=64512\n}]\nLoopbackIP: \"\\(loopback.ip)/32\"\nVRFs: [{name: \"default\"}]\n```", "```go\nimport \"cuelang.org/go/cue/load\"\nfunc main() {\n    err := importInput()\n    /* ... <continues next > ... */\n}\n```", "```go\nch08/cue$ cue eval network.automation:input -c\nasn: invalid value 10 (out of bound >=64512):\n    ./schema.cue:7:16\n    ./input.cue:3:6\n```", "```go\nfunc main() {\n    /* ... <continues from before > ... */\n    bis := load.Instances([]string{\".\"}, &load.Config{\n        Package: \"cvx\",\n    })\n    /* ... <continues next > ... */\n}\n```", "```go\nfunc main() {\n    /* ... <continues from before > ... */\n    ctx := cuecontext.New()\n    i := ctx.BuildInstance(instances[0])\n    if i.Err() != nil {\n        msg := errors.Details(i.Err(), nil)\n        fmt.Printf(\"Compile Error:\\n%s\\n\", msg)\n    }\n    /* ... <continues next > ... */\n}\n```", "```go\nfunc main() {\n    /* ... <continues from before > ... */\n    if err := i.Validate(\n        cue.Final(),\n        cue.Concrete(true),\n    ); err != nil {\n        msg := errors.Details(err, nil)\n        fmt.Printf(\"Validate Error:\\n%s\\n\", msg)\n    }\n    /* ... <continues next > ... */\n}\n```", "```go\nfunc main() {\n    /* ... <continues from before > ... */\n    data, err := e.MarshalJSON()\n    // check error\n    if err := sendBytes(data); err != nil {\n        log.Fatal(err)\n    }\n    log.Printf(\"Successfully configured the device\")\n}\n```", "```go\nch08/cue$ go run main.go\nmain.go:140: Created revisionID: changeset/cumulus/2022-05-25_20.56.51_KF9A\n{\n  \"state\": \"apply\",\n  \"transition\": {\n    \"issue\": {},\n    \"progress\": \"\"\n  }\n}\nmain.go:69: Successfully configured the device\n```", "```go\nch08/json-rpc$ go run \\\n  github.com/openconfig/ygot/generator \\\n    -path=yang \\\n    -generate_fakeroot -fakeroot_name=device \\\n    -output_file=pkg/srl/srl.go \\\n    -package_name=srl \\\n    yang/srl_nokia/models/network-instance/srl_nokia-bgp.yang \\\n    yang/srl_nokia/models/routing-policy/srl_nokia-routing-policy.yang \\\n    yang/srl_nokia/models/network-instance/srl_nokia-ip-route-tables.yang\n```", "```go\nch08/json-rpc$ go generate ./...\n```", "```go\nimport (\n  api \"json-rpc/pkg/srl\"\n)\n// Input Data Model\ntype Model struct {\n  Uplinks  []Link `yaml:\"uplinks\"`\n  Peers    []Peer `yaml:\"peers\"`\n  ASN      int    `yaml:\"asn\"`\n  Loopback Addr   `yaml:\"loopback\"`\n}\nfunc main() {\n  /* ... <omitted for brevity > ... */\n  var input Model\n  d.Decode(&input)\n  device := &api.Device{}\n  input.buildDefaultPolicy(device)\n  input.buildL3Interfaces(device)\n  input.buildNetworkInstance(device)\n  /* ... <continues next (main) > ... */\n}\n```", "```go\nfunc (m *Model) buildNetworkInstance(dev *api.Device) error {\n  ni, err := dev.NewNetworkInstance(defaultNetInst)\n  /* ... <continues next (buildNetworkInstance) > ... */\n}\n```", "```go\nfunc (m *Model) buildNetworkInstance(dev *api.Device) error {\n  // ... <continues from before (buildNetworkInstance) > \n  links := m.Uplinks\n  links = append(\n    links,\n    Link{\n      Name:   srlLoopback,\n      Prefix: fmt.Sprintf(\"%s/32\", m.Loopback.IP),\n    },\n  )\n  for _, link := range links {\n    linkName := fmt.Sprintf(\"%s.%d\", link.Name,\n                            defaultSubIdx)\n    ni.NewInterface(linkName)\n  }\n  /* ... <continues next (buildNetworkInstance) > ... */\n}\n```", "```go\nfunc (m *Model) buildNetworkInstance(dev *api.Device) error {\n  // ... <continues from before (buildNetworkInstance) > \n  ni.Protocols =\n  &api.SrlNokiaNetworkInstance_NetworkInstance_Protocols{\n    Bgp: \n    &api.\n    SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp{\n      AutonomousSystem: ygot.Uint32(uint32(m.ASN)),\n      RouterId:         ygot.String(m.Loopback.IP),\n      Ipv4Unicast: \n      &api. \nSrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Ipv4Unicast{\n        AdminState: api.SrlNokiaBgp_AdminState_enable,\n      },\n    },\n  }\n  /* ... <continues next (buildNetworkInstance) > ... */\n}\n```", "```go\nfunc (m *Model) buildNetworkInstance(dev *api.Device) error {\n  // ... <continues from before (buildNetworkInstance) > \n  ni.Protocols.Bgp.NewGroup(defaultBGPGroup)\n  for _, peer := range m.Peers {\n    n, err := ni.Protocols.Bgp.NewNeighbor(peer.IP)\n    // check error\n    n.PeerAs = ygot.Uint32(uint32(peer.ASN))\n    n.PeerGroup = ygot.String(defaultBGPGroup)\n  }\n  /* ... <continues next (buildNetworkInstance) > ... */\n}\n```", "```go\nfunc (m *Model) buildNetworkInstance(dev *api.Device) error {\n    /* ... <continues from before (buildNetworkInstance) > ... */\n    if err := ni.Validate(); err != nil {\n        return err\n    }\n    return nil\n}\n```", "```go\n    func main() {\n    ```", "```go\n        /* ... <continues from before (main) > ... */\n    ```", "```go\n        v, err := ygot.ConstructIETFJSON(device, nil)\n    ```", "```go\n        // check error\n    ```", "```go\n        value, err := json.Marshal(RpcRequest{\n    ```", "```go\n            Version: \"2.0\",\n    ```", "```go\n            ID:      0,\n    ```", "```go\n            Method:  \"set\",\n    ```", "```go\n            Params: Params{\n    ```", "```go\n                Commands: []*Command{\n    ```", "```go\n                    {\n    ```", "```go\n                        Action: \"update\",\n    ```", "```go\n                        Path:   \"/\",\n    ```", "```go\n                        Value:  v,\n    ```", "```go\n                    },\n    ```", "```go\n                },\n    ```", "```go\n            },\n    ```", "```go\n        })\n    ```", "```go\n        // check error\n    ```", "```go\n        req, err := http.NewRequest(\n    ```", "```go\n            \"POST\",\n    ```", "```go\n            hostname,\n    ```", "```go\n            bytes.NewBuffer(value),\n    ```", "```go\n        )\n    ```", "```go\n        resp, err := client.Do(req)\n    ```", "```go\n         // check error\n    ```", "```go\n        defer resp.Body.Close()\n    ```", "```go\n        if resp.StatusCode != http.StatusOK {\n    ```", "```go\n            log.Printf(\"Status: %s\", resp.Status)\n    ```", "```go\n        }\n    ```", "```go\nch08/json-rpc$ go run main.go\n2022/04/26 13:09:03 Successfully configured the device\n```", "```go\nch08/restconf$ go run github.com/openconfig/ygot/generator \\\n  -path=yang \\\n  -output_file=pkg/eos/eos.go \\\n  -compress_paths=true \\\n  -exclude_modules=ietf-interfaces \\\n  -package_name=eos \\\n  yang/openconfig/public/release/models/bgp/openconfig-bgp.yang \\\n  yang/openconfig/public/release/models/interfaces/openconfig-if-ip.yang \\\n  yang/openconfig/public/release/models/network-instance/openconfig-network-instance.yang \\\n  yang/release/openconfig/models/interfaces/arista-intf-augments-min.yang\n```", "```go\nch08/restconf$ go generate ./...\n```", "```go\ntype restconfRequest struct {\n    path    string\n    payload []byte\n}\nfunc main() {\n    /* ... <omitted for brevity > ... */\n    var input Model\n    err = d.Decode(&input)\n    // check error\n    var cmds []*restconfRequest\n    /* ... <continues next > ... */\n}\n```", "```go\nfunc main() {\n    /* ... <continues from before > ... */ \n    l3Intfs, err := input.buildL3Interfaces()\n    // check error\n    cmds = append(cmds, l3Intfs...)\n    bgp, err := input.buildBGPConfig()\n    // check error\n    cmds = append(cmds, bgp)\n    redistr, err := input.enableRedistribution()\n    // check error\n    cmds = append(cmds, redistr)\n    /* ... <continues next > ... */\n}\n```", "```go\nconst defaultNetInst = \"default\"\nfunc (m *Model) enableRedistribution() (*restconfRequest, error) {\n    netInst := &api.NetworkInstance{\n        Name: ygot.String(defaultNetInst),\n    }\n    _, err := netInst.NewTableConnection(\n        api.OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE_DIRECTLY_CONNECTED,\n        api.OpenconfigPolicyTypes_INSTALL_PROTOCOL_TYPE_BGP,\n        api.OpenconfigTypes_ADDRESS_FAMILY_IPV4,\n    )\n\n    /* ... <omitted for brevity > ... */\n    value, err := ygot.Marshal7951(netInst)\n    // check error\n    return &restconfRequest{\n        path: fmt.Sprintf(\n            \"/network-instances/network-instance=%s\",\n            defaultNetInst,\n        ),\n        payload: value,\n    }, nil\n}\n```", "```go\nconst restconfPath = \"/restconf/data\"\nfunc restconfPost(cmd *restconfRequest) error {\n  baseURL, err := url.Parse(\n    fmt.Sprintf(\n      \"https://%s:%d%s\",\n      ceosHostname,\n      defaultRestconfPort,\n      restconfPath,\n    ),\n  )\n  // return error if not nil\n  baseURL.Path = path.Join(restconfPath, cmd.path)\n  req, err := http.NewRequest(\n    \"POST\",\n    baseURL.String(),\n    bytes.NewBuffer(cmd.payload),\n  )\n  // return error if not nil\n  req.Header.Add(\"Content-Type\", \"application/json\")\n  req.Header.Add(\n    \"Authorization\",\n    \"Basic \"+base64.StdEncoding.EncodeToString(\n      []byte(\n        fmt.Sprintf(\"%s:%s\", ceosUsername, ceosPassword),\n      ),\n    ),\n  )\n  client := &http.Client{Transport: &http.Transport{\n        TLSClientConfig: \n          &tls.Config{\n            InsecureSkipVerify: true\n          },\n      }\n  }\n  resp, err := client.Do(req)\n  /* ... <omitted for brevity > ... */\n}\n```", "```go\nch08/restconf$ go run main.go\n2022/04/28 20:49:16 Successfully configured the device\n```", "```go\nfunc (r CEOS) GetRoutes(wg *sync.WaitGroup) {\n  client := resty.NewWithClient(&http.Client{\n    Transport: &http.Transport{\n      TLSClientConfig: &tls.Config{\n        InsecureSkipVerify: true},\n    },\n  })\n  client.SetBaseURL(\"https://\" + r.Hostname + \":6020\")\n  client.SetBasicAuth(r.Username, r.Password)\n  resp, err := client.R().\n    SetHeader(\"Accept\", \"application/yang-data+json\").\n    Get(fmt.Sprintf(\"/restconf/data/network-instances/network-instance=%s/afts\", \"default\"))\n  /* ... <continues next > ... */\n}\n```", "```go\nimport eosAPI \"restconf/pkg/eos\"\nfunc (r CEOS) GetRoutes(wg *sync.WaitGroup) {\n  /* ... <continues from before > ... */\n  response := &eosAPI.NetworkInstance_Afts{}\n  err := eosAPI.Unmarshal(resp.Body(), response)\n  // process error\n  out := []string{}\n  for key := range response.Ipv4Entry {\n    out = append(out, key)\n  }\n  /* ... <omitted for brevity > ... */\n  go checkRoutes(r.Hostname, out, expectedRoutes, wg)\n}\n```", "```go\nmessage Router {\n  repeated Uplink uplinks = 1;\n  repeated Peer peers = 2;\n  int32 asn = 3;\n  Addr loopback = 4; \n}\nmessage Uplink {\n    string name = 1;\n    string prefix = 2;\n}\nmessage Peer {\n    string ip = 1;\n    int32 asn = 2;\n}\nmessage Addr {\n  string ip = 1;\n}\n```", "```go\nch08/protobuf$ protoc --go_out=. model.proto\n```", "```go\ntype Router struct {\n  Uplinks  []*Uplink \n  Peers    []*Peer   \n  Asn      int32     \n  Loopback *Addr\n}\n```", "```go\nch08/protobuf/write$ go run protobuf\n```", "```go\nch08/protobuf$ ls -ls router* | awk '{print $6, $10}'\n108 router.data\n454 router_indent.json\n220 router.json\n```", "```go\nsyntax = \"proto3\";\nservice gRPCConfigOper {\n  rpc GetConfig(ConfigGetArgs) returns(stream ConfigGetReply) {};\n\n  rpc MergeConfig(ConfigArgs) returns(ConfigReply) {};\n\n  rpc DeleteConfig(ConfigArgs) returns(ConfigReply) {};\n\n  rpc ReplaceConfig(ConfigArgs) returns(ConfigReply) {};\n  /* ... <omitted for brevity > ... */\n  rpc CreateSubs(CreateSubsArgs) returns(stream CreateSubsReply) {};\n}\n```", "```go\nsyntax = \"proto3\";\nservice OpenConfigTelemetry {\n  rpc telemetrySubscribe(SubscriptionRequest) returns (stream OpenConfigData) {}\n  /* ... <omitted for brevity > ... */\n  rpc getTelemetryOperationalState(GetOperationalStateRequest) returns(GetOperationalStateReply) {}\n  rpc getDataEncodings(DataEncodingRequest) returns (DataEncodingReply) {}\n}\n```", "```go\nservice gNMI {\n  rpc Capabilities(CapabilityRequest) returns (CapabilityResponse);\n  rpc Get(GetRequest) returns (GetResponse);\n  rpc Set(SetRequest) returns (SetResponse);\n  rpc Subscribe(stream SubscribeRequest) returns (stream SubscribeResponse);\n}\n```", "```go\nch08/grpc$ go run grpc\n```", "```go\nservice gRPCConfigOper { \n  rpc ReplaceConfig(ConfigArgs) returns(ConfigReply) {};\n}\nmessage ConfigArgs {\n  int64 ReqId = 1;\n  string yangjson = 2;\n  bool   Confirmed = 3;\n  uint32  ConfirmTimeout = 4;\n}\n```", "```go\ntype Authentication struct {\n  Username string\n  Password string\n}\ntype IOSXR struct {\n  Hostname string\n  Authentication\n}\ntype xrgrpc struct {\n  IOSXR\n  conn *grpc.ClientConn\n  ctx  context.Context\n}\n```", "```go\nfunc main() {\n  iosxr := xrgrpc{\n    IOSXR: IOSXR{\n      Hostname: \"sandbox-iosxr-1.cisco.com\",\n      Authentication: Authentication{\n        Username: \"admin\",\n        Password: \"C1sco12345\",\n      },\n    },\n  }\n  src, err := os.Open(\"input.yml\")\n  // process error\n  defer src.Close()\n  d := yaml.NewDecoder(src)\n  var input Model\n  err = d.Decode(&input)\n  /* ... <continues next > ... */\n}\n```", "```go\nfunc main() {\n  /* ... <continues from before > ... */\n  device := &oc.Device{}\n  input.buildNetworkInstance(device)\n  payload, err := ygot.EmitJSON(device,\n  &ygot.EmitJSONConfig{\n    Format: ygot.RFC7951,\n    Indent: \"  \",\n    RFC7951Config: &ygot.RFC7951JSONConfig{\n      AppendModuleName: true,\n    },\n  })\n  /* ... <continues next > ... */\n}\n```", "```go\nfunc main() {\n  /* ... <continues from before > ... */\n  iosxr.Connect()\n  defer router.conn.Close()\n  iosxr.ReplaceConfig(payload)\n  /* ... <continues next > ... */ \n}\n```", "```go\nfunc (x *xrgrpc) ReplaceConfig(json string) error {\n  // Random int64 for id\n  id := rand.Int63()\n  // 'g' is the gRPC stub.\n  g := xr.NewGRPCConfigOperClient(x.conn)\n  // We send 'a' to the router via the stub.\n  a := xr.ConfigArgs{ReqId: id, Yangjson: json}\n  // 'r' is the result that comes back from the target.\n  r, err := g.ReplaceConfig(x.ctx, &a)\n  // process error\n  return nil\n}\n```", "```go\nservice gRPCConfigOper { \n  rpc CreateSubs(CreateSubsArgs) returns(stream CreateSubsReply) {};\n}\nmessage CreateSubsArgs {\n  int64 ReqId = 1;\n  int64 encode = 2;\n  string subidstr = 3;\n  QOSMarking qos = 4;\n  repeated string Subscriptions = 5;\n}\nmessage CreateSubsReply {\n  int64 ResReqId = 1;\n  bytes data = 2;\n  string errors = 3;\n}\n```", "```go\nfunc (x *xrgrpc) GetSubscription(sub, enc string) (chan []byte, chan error, error) {\n  /* ... <omitted for brevity > ... */\n\n  // 'c' is the gRPC stub.\n  c := xr.NewGRPCConfigOperClient(x.conn)\n  // 'b' is the bytes channel where telemetry is sent.\n  b := make(chan []byte)\n  a := xr.CreateSubsArgs{\n        ReqId: id, Encode: encoding, Subidstr: sub}\n  // 'r' is the result that comes back from the target.\n  st, err := c.CreateSubs(x.ctx, &a)\n  // process error\n  go func() {\n    r, err := st.Recv()\n    /* ... <omitted for brevity > ... */\n    for {\n      select {\n      /* ... <omitted for brevity > ... */\n      case b <- r.GetData():\n      /* ... <omitted for brevity > ... */\n      }\n    }\n  }()\n  return b, e, err\n}\n```", "```go\nfunc main() {\n  /* ... <omitted for brevity > ... */\n  ch, errCh, err := router.GetSubscription(\"BGP\", \"gpb\")\n  // process error\n\n  for msg := range ch {\n    message := new(telemetry.Telemetry)\n    proto.Unmarshal(msg, message)\n\n    t := time.UnixMilli(int64(message.GetMsgTimestamp()))\n    fmt.Printf(\n      \"Time: %v\\nPath: %v\\n\\n\",\n      t.Format(time.ANSIC),\n      message.GetEncodingPath(),\n    )\n    /* ... <continues next > ... */\n  }\n}\n```", "```go\nfunc main() {\n  for msg := range ch {\n    /* ... <continues from before > ... */  \n    for _, row := range message.GetDataGpb().GetRow() {\n      content := row.GetContent()\n      nbr := new(bgp.BgpNbrBag)\n      err = proto.Unmarshal(content, nbr)\n      if err != nil {\n        fmt.Printf(\"could decode Content: %v\\n\", err)\n        return\n      }\n      state := nbr.GetConnectionState()\n      addr := nbr.GetConnectionRemoteAddress().Ipv4Address\n      fmt.Println(\"  Neighbor: \", addr)\n      fmt.Println(\"  Connection state: \", state)\n    }\n  }\n}\n```", "```go\nfunc main() {\n  for msg := range ch {\n    message := new(telemetry.Telemetry)\n    err := proto.Unmarshal(msg, message)\n    /* ... <omitted for brevity > ... */\n    b, err := json.Marshal(message.GetDataGpbkv())\n    check(err)\n    j := string(b)\n    // https://go.dev/play/p/uyWenG-1Keu\n    data := gjson.Get(\n      j,\n      \"0.fields.0.fields.#(name==neighbor-address).ValueByType.StringValue\",\n    )\n    fmt.Println(\"  Neighbor: \", data)\n    data = gjson.Get(\n      j,\n      \"0.fields.1.fields.#(name==connection-state).ValueByType.StringValue\",\n    )\n    fmt.Println(\"  Connection state: \", data)\n  }\n}\n```", "```go\nch08/grpc$ go run grpc -kvmode=true\n```"]