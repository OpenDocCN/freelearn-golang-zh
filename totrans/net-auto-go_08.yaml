- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Network APIs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络API
- en: As the ways we build, deploy, and operate networks evolve, new protocols and
    interfaces are emerging to ease machine-to-machine communication—a primary enabler
    of network automation. In this and the following chapters, we’ll navigate through
    some of these new capabilities and explore how to take advantage of them in the
    context of the Go programming language.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们构建、部署和运营网络的方式不断发展，新的协议和接口正在出现，以简化机器之间的通信——这是网络自动化的主要推动力。在本章和接下来的章节中，我们将探讨一些这些新功能，并探索如何在Go编程语言的环境中利用它们。
- en: The network **Command-Line Interface** (**CLI**) is what we, network engineers,
    have used for decades to operate and manage network devices. As we move toward
    a more programmatic approach to managing networks, simply relying on faster CLI
    command execution might not be enough to deploy network automation solutions at
    scale.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的**命令行界面**（**CLI**）是我们，网络工程师，几十年来用于操作和管理网络设备的方式。随着我们朝着更程序化的网络管理方法发展，仅仅依赖于更快的CLI命令执行可能不足以大规模部署网络自动化解决方案。
- en: Solutions that don’t have a strong foundation are brittle and unstable. Hence,
    when possible, we prefer to build network automation projects based on structured
    data and machine-friendly **Application Programming Interfaces** (**APIs**). The
    target use case for these interfaces isn’t direct human interaction, so you can
    rely on Go to translate between remote API calls and a local, user-facing interface.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 没有强大基础解决方案是脆弱且不稳定的。因此，在可能的情况下，我们更倾向于基于结构化数据和机器友好的**应用程序编程接口**（**API**）来构建网络自动化项目。这些接口的目标用例不是直接的人机交互，因此你可以依赖Go在远程API调用和本地用户界面之间进行转换。
- en: 'When we talk about APIs, we generally refer to different things that make up
    the API developer experience, which you need to consider when evaluating an API:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论API时，我们通常指的是构成API开发者体验的不同事物，这些是你评估API时需要考虑的：
- en: A set of **Remote Procedure Calls** (**RPCs**) defining the rules of interaction
    between a client and a server—at the very least, this would include a standard
    set of create, get, update, and delete operations.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组定义客户端和服务器之间交互规则的**远程过程调用**（**RPC**）——至少包括创建、获取、更新和删除的标准操作集。
- en: The structure and data type exchanged—product vendors can define this using
    data model specification languages such as YANG or OpenAPI.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交换的结构和数据类型——产品供应商可以使用YANG或OpenAPI等数据模型规范语言来定义这一点。
- en: The underlying protocol that wraps the modeled data, which you can serialize
    into one of the standard formats, such as XML or JSON, and transports it between
    a client and a server—this could be SSH or, more often these days, HTTP.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包裹模型数据的底层协议，您可以将它序列化为标准格式之一，如XML或JSON，并在客户端和服务器之间传输——这可能是SSH，或者更常见的是HTTP。
- en: 'In the networking world, we have another dimension in the API landscape that
    determines the origin of a model specification document. While every networking
    vendor is free to write their own data models, there are two sources of vendor-agnostic
    models—IETF and OpenConfig—that strive to offer a vendor-neutral way of configuring
    and monitoring network devices. Because of this variability in the API ecosystem,
    it’s impossible to cover all protocols and standards, so in this chapter, we’ll
    only cover a subset of network APIs, selected based on availability, practicality,
    and usefulness:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络领域，API景观中还有一个维度决定了模型规范文档的来源。虽然每个网络供应商都可以自由编写自己的数据模型，但有两个供应商无关的模型来源——IETF和OpenConfig——努力提供一种供应商中立的配置和监控网络设备的方式。由于API生态系统的这种可变性，不可能涵盖所有协议和标准，因此在本章中，我们只涵盖了一小部分网络API，这些API是根据可用性、实用性和有用性选择的：
- en: We’ll start by looking at OpenAPI as one of the most prevalent API specification
    standards in a wider infrastructure landscape.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将从OpenAPI开始，它是更广泛的基础设施领域中最为普遍的API规范标准之一。
- en: We’ll then move on to JSON-RPC, which uses vendor-specific YANG models.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们将转向JSON-RPC，它使用供应商特定的YANG模型。
- en: After that, we’ll show an example of an RFC-standard HTTP-based protocol called
    RESTCONF.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，我们将展示一个基于RFC标准的HTTP协议的示例，称为RESTCONF。
- en: Finally, we’ll look at how you can leverage **Protocol Buffers** (**protobuf**)
    and gRPC to interact with network devices and stream telemetry.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将探讨如何利用**协议缓冲区**（**protobuf**）和gRPC与网络设备进行交互并流式传输遥测数据。
- en: In this chapter, we’ll focus only on these network APIs, as the others are outside
    of the scope. The most notable absentee is the **Network Configuration Protocol**
    (**NETCONF**)—one of the oldest network APIs, defined originally by IETF in 2006\.
    We’re skipping NETCONF mainly because of the lack of support for XML in some Go
    packages we use throughout this chapter. Although NETCONF is in use today and
    offers relevant capabilities, such as different configuration datastores, configuration
    validation, and network-wide configuration transactions, in the future, it may
    get displaced by technologies running over HTTP and TLS, such as RESTCONF, gNMI,
    and various proprietary network APIs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将仅关注这些网络API，因为其他内容超出了范围。最引人注目的是缺席的**网络配置协议**（**NETCONF**）——这是最古老的网络API之一，最初由IETF于2006年定义。我们跳过NETCONF主要是因为我们在本章使用的某些Go包中缺乏对XML的支持。尽管NETCONF今天仍在使用，并提供了相关的功能，如不同的配置数据存储、配置验证和网络范围内的配置事务，但在未来，它可能会被运行在HTTP和TLS之上的技术所取代，如RESTCONF、gNMI和各种专有网络API。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code examples for this chapter in the book’s GitHub repository
    (refer to the *Further reading* section), under the `ch08` folder.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的GitHub仓库中找到本章的代码示例（参考*进一步阅读*部分），在`ch08`文件夹下。
- en: Important Note
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We recommend you execute the Go programs in this chapter in a virtual lab environment.
    Refer to the appendix for prerequisites and instructions on how to build it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议你在虚拟实验室环境中执行本章的Go程序。有关先决条件和构建它的说明，请参阅附录。
- en: API data modeling
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API数据建模
- en: Before we look at any code, let’s review what data modeling is, what its key
    components are, and their relationships. While we focus on the configuration management
    side of model-driven APIs for this explanation, similar rules and assumptions
    apply to workflows involving state data retrieval and verification.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看任何代码之前，让我们回顾一下什么是数据建模，它的关键组件是什么，以及它们之间的关系。虽然我们在这个解释中关注的是模型驱动API的配置管理方面，但类似的规则和假设也适用于涉及状态数据检索和验证的工作流程。
- en: The main goal of a configuration management workflow is to transform some input
    into a serialized data payload whose structure adheres to a data model. This input
    is usually some user-facing data, which has its own structure and may contain
    only a small subset of the total number of configuration values. But this input
    has a one-to-one relationship with the resulting configuration, meaning that rerunning
    the same workflow should result in the same set of RPCs with the same payloads
    and the same configuration state on a network device.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理工作流程的主要目标是把一些输入转换成一个结构符合数据模型的序列化数据负载。这个输入通常是面向用户的数据，它有自己的结构，可能只包含配置值总数的一小部分。但这个输入与结果配置有一对一的关系，这意味着重新运行相同的流程应该会产生相同的一组RPCs，具有相同的负载和相同的网络设备上的配置状态。
- en: At the center of it all is a data model—a text document that describes the hierarchical
    structure and types of values of a (configuration) data payload. This document
    becomes a contract with all potential clients—as long as they send their data
    in the right format, a server should be able to understand it and parse it. This
    contract works both ways so that when a client requests some information from
    a server, it can expect to receive it in a predetermined format.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切的中心是一个数据模型——一个文本文档，描述了（配置）数据负载的分层结构和值类型。这份文档成为所有潜在客户的合同——只要他们以正确的格式发送数据，服务器就应该能够理解并解析它。这份合同是双向的，因此当客户端从服务器请求一些信息时，它可以期望以预定的格式接收它。
- en: 'The following diagram shows the main components of a model-driven configuration
    management workflow and their relationships:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图展示了模型驱动配置管理工作流程的主要组件及其关系：
- en: '![Figure 8.1 – Data modeling concepts](img/B16971_08_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 数据建模概念](img/B16971_08_01.jpg)'
- en: Figure 8.1 – Data modeling concepts
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 数据建模概念
- en: Thus far, we’ve discussed a model, its input, and the resulting configuration.
    The only thing we haven’t mentioned until now is the *bindings*. We use this term
    to refer to a broad set of tools and libraries that can help us generate the final
    configuration data payload programmatically, that is, without resorting to a set
    of text templates or building these data payloads manually, both of which we consider
    an anti-pattern in any network automation workflow. We produce these bindings
    based on the data model and they represent a programmatic view of the model. They
    may also include several helper functions to serialize and deserialize data structures
    into one of the expected output formats, for example, JSON or protobuf. We’ll
    spend most of this chapter discussing and interacting with bindings as they become
    the main interface for a data model inside of the programming language.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了一个模型、其输入以及产生的配置。直到现在，我们还没有提到的是 *绑定*。我们使用这个术语来指代一组广泛的工具和库，它们可以帮助我们以编程方式生成最终的配置数据负载，也就是说，不依赖于一系列文本模板或手动构建这些数据负载，这两者我们都认为在任何网络自动化工作流程中都是反模式。我们根据数据模型生成这些绑定，它们代表了模型的程序性视图。它们还可能包括几个辅助函数，用于将数据结构序列化和反序列化到预期的输出格式之一，例如
    JSON 或 protobuf。我们将在本章的大部分内容中讨论和交互绑定，因为它们成为编程语言内部数据模型的主要接口。
- en: Now that we’ve covered some theory, it’s time to put it into practice. In the
    following section, we’ll examine OpenAPI models and one way you can instantiate
    and validate them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了一些理论，是时候将其付诸实践了。在接下来的部分，我们将探讨 OpenAPI 模型以及一种你可以实例化和验证它们的方法。
- en: OpenAPI
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenAPI
- en: Within a greater infrastructure landscape, HTTP and JSON are two commonly used
    standards for machine-to-machine communication. Most web-based services, including
    public and private clouds, use a combination of these technologies to expose their
    externally facing APIs.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在更广泛的基础设施景观中，HTTP 和 JSON 是机器到机器通信中常用的两种标准。大多数基于 Web 的服务，包括公共和私有云，都使用这些技术的组合来公开其外部
    API。
- en: The OpenAPI Specification allows us to define and consume RESTful APIs. It lets
    us describe the enabled HTTP paths, responses, and JSON schemas for the corresponding
    payloads. It serves as a contract between an API provider and its clients to allow
    for a more stable and reliable API consumer experience and enables API evolution
    through versioning.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI 规范允许我们定义和消费 RESTful API。它让我们能够描述对应的负载的启用 HTTP 路径、响应和 JSON 架构。它作为 API
    提供者和其客户端之间的合同，以允许更稳定和可靠的 API 消费者体验，并通过版本控制实现 API 的进化。
- en: We don’t widely use OpenAPI in networking, arguably for historical reasons.
    YANG and its ecosystem of protocols predate OpenAPI and the rate of change in
    network operating systems is not as fast as you might expect. But we often find
    OpenAPI support in network appliances—SDN controllers, monitoring and provisioning
    systems or **Domain Name System** (**DNS**), **Dynamic Host Configuration Protocol**
    (**DHCP**), and **IP Address Management** (**IPAM**) products. This makes working
    with OpenAPI a valuable skill to have for any network automation engineer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在网络上并不广泛使用 OpenAPI，可以说这是出于历史原因。YANG 及其协议生态系统早于 OpenAPI，网络操作系统的变化速度也没有你想象的那么快。但我们在网络设备中经常发现
    OpenAPI 的支持——SDN 控制器、监控和配置系统或 **域名系统** (**DNS**)、**动态主机配置协议** (**DHCP**) 和 **IP
    地址管理** (**IPAM**) 产品。这使得 OpenAPI 对于任何网络自动化工程师来说是一项有价值的技能。
- en: In *Chapters 6* and *7*, we went through an example of how to interact with
    Nautobot’s external OpenAPI-based interface. We used a Go package produced by
    an open source code generation framework based on Nautobot’s OpenAPI specification.
    One thing to be mindful of with automatic code generation tools is that they rely
    on a certain version of the OpenAPI Specification. If the version of your API
    specification is different (there are nine different OpenAPI versions today; refer
    to the *Further reading* section), the tool may not generate the Go code. Hence,
    we want to explore an alternative approach.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 6 章* 和 *第 7 章* 中，我们通过一个示例了解了如何与 Nautobot 的外部基于 OpenAPI 的接口交互。我们使用了一个基于
    Nautobot OpenAPI 规范的开源代码生成框架生产的 Go 包。在使用自动代码生成工具时，需要注意的一点是，它们依赖于 OpenAPI 规范的某个版本。如果你的
    API 规范版本不同（今天有九个不同的 OpenAPI 版本；请参阅 *进一步阅读* 部分），工具可能不会生成 Go 代码。因此，我们想要探索一种替代方法。
- en: In this section, we’ll configure NVIDIA’s Cumulus Linux device (`cvx`), which
    has an OpenAPI-based HTTP API, using **Configure Unify Execute** (**CUE**; refer
    to the *Further reading* section)—an open source **Domain-Specific Language**
    (**DSL**) designed to define, generate, and validate structured data.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将配置NVIDIA的Cumulus Linux设备（`cvx`），该设备具有基于OpenAPI的HTTP API，使用**配置统一执行**（**CUE**；参见**进一步阅读**部分）——一个开源的**领域特定语言**（**DSL**），用于定义、生成和验证结构化数据。
- en: CUE’s primary user-facing interface is CLI, but it also has first-class Go API
    support, so we’ll focus on how to interact with it entirely within Go code while
    providing the corresponding shell commands where appropriate.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: CUE的主要用户界面是CLI，但它也支持一流的Go API，因此我们将专注于如何在Go代码中完全与之交互，并在适当的地方提供相应的shell命令。
- en: 'The following figure shows a high-level overview of the Go program we’ll discuss
    next:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图展示了我们将讨论的Go程序的高级概述：
- en: '![Figure 8.2 – Working with OpenAPI data models](img/B16971_08_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 使用OpenAPI数据模型](img/B16971_08_02.jpg)'
- en: Figure 8.2 – Working with OpenAPI data models
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 使用OpenAPI数据模型
- en: Data modeling
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据建模
- en: Starting from the top of the diagram, the first thing we need to do is produce
    the CUE code we can use to generate the data structures to configure a network
    device.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从图表的顶部开始，我们首先需要生成可以用来生成配置网络设备的数据结构的CUE代码。
- en: Although CUE can import existing structured data and generate CUE code, it may
    take a few iterations to get to a point where the code organization is optimal.
    It turned out to be faster to write this code from scratch for the example we
    present here. The result is in the `ch08/cue/template.cue` file (refer to the
    *Further* *reading* section).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然CUE可以导入现有的结构化数据并生成CUE代码，但要达到代码组织最优化的点可能需要几次迭代。对于这里展示的示例，从头开始编写此代码要快得多。结果位于`ch08/cue/template.cue`文件中（参见**进一步****阅读**部分）。
- en: Important Note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We won’t cover CUE syntax or any of its core concepts and principles in this
    book but will instead focus on its Go API. For more details about the language,
    please refer to CUE’s official documentation, linked in the *Further* *reading*
    section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不会涵盖CUE语法或其任何核心概念和原则，而是将专注于其Go API。有关该语言的更多详细信息，请参阅CUE的官方文档，该文档在**进一步****阅读**部分链接。
- en: 'CUE resembles JSON with heavy influences from Go. It allows you to define data
    structures and map values between different data structures via references. Data
    generation in CUE thus becomes an exercise of data transformation with strict
    value typing and schema validation. Here’s a snippet from the `template.cue` file
    mentioned earlier, which defines three top-level objects for interfaces, routing,
    and VRF configuration:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: CUE类似于JSON，受到Go的强烈影响。它允许您通过引用定义数据结构并在不同的数据结构之间映射值。因此，CUE中的数据生成成为一项数据转换练习，具有严格的值类型和模式验证。以下是前面提到的`template.cue`文件的一个片段，它定义了三个顶级对象，用于接口、路由和VRF配置：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Important Note
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You can refer to CUE’s *References and Visibility* tutorial (linked in the *Further
    reading* section) for explanations about emitted values, references, and the use
    of underscores.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考CUE的**引用和可见性**教程（在**进一步阅读**部分链接），了解输出值、引用以及下划线使用的方法。
- en: This file has references to an external CUE package called input, which provides
    the required input data for the data model in the preceding output. This separation
    of data templates and their inputs allows you to distribute these files separately
    and potentially have them come from different sources. CUE provides a guarantee
    that the result is always the same, no matter the order you follow to assemble
    those files.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件引用了一个名为`input`的外部CUE包，它为前面输出中的数据模型提供了所需的数据输入。这种数据模板及其输入的分离允许您分别分发这些文件，并且它们可能来自不同的来源。CUE提供保证，无论您遵循什么顺序组装这些文件，结果始终相同。
- en: Data input
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据输入
- en: 'Now, let’s see how we define and provide inputs to the preceding data model.
    We use the same data structure we used in *Chapters 6*, *Configuration Management*,
    and [*Chapter 7*](B16971_07.xhtml#_idTextAnchor161), *Automation Frameworks*,
    in a YAML file (`input.yaml`), which for the `cvx` lab device looks as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何定义和提供前面数据模型的输入。我们使用与*第6章*、*配置管理*和[*第7章*](B16971_07.xhtml#_idTextAnchor161)、*自动化框架*中使用的相同数据结构，在YAML文件（`input.yaml`）中，对于`cvx`实验室设备如下所示：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Using CUE, we can validate that this input data is correct by building a corresponding
    object and introducing constraints, for example, a valid ASN range or IPv4 prefix
    format. CUE allows you to define extra values directly inside the schema definition,
    either by hardcoding defaults (`input.VRFs`) or referencing other values from
    the same context (`input.LoopbackIP`):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CUE，我们可以通过构建相应的对象并引入约束来验证这些输入数据是否正确，例如，一个有效的ASN范围或IPv4前缀格式。CUE允许你直接在模式定义中定义额外的值，无论是通过硬编码默认值（`input.VRFs`）还是引用同一上下文中的其他值（`input.LoopbackIP`）：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the main function of the example program, we use the `importInput` helper
    function to read the input YAML file and generate a corresponding CUE file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例程序的主函数中，我们使用`importInput`辅助函数读取输入YAML文件并生成相应的CUE文件：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The program saves the resulting file as `input.cue` in the local directory.
    The implementation details of this function are not too important as you can perform
    the same action from the command line with `cue import input.yaml -``p input`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将生成的文件保存为本地目录中的`input.cue`。这个函数的实现细节并不重要，因为你可以通过命令行使用`cue import input.yaml
    -p input`执行相同的操作。
- en: 'At this stage, we can validate that our input conforms to the schema and constraints
    shown earlier. For example, if we had set the `asn` value in `input.yaml` to something
    outside of the expected range, CUE would’ve caught and reported this error:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们可以验证我们的输入是否符合前面显示的模式和约束。例如，如果我们把`input.yaml`中的`asn`值设置在预期范围之外，CUE就会捕获并报告这个错误：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Device configuration
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备配置
- en: Now we have all the pieces in place to configure our network device. We produce
    the final configuration instance by compiling the template defined in the `cvx`
    package into a concrete CUE value. We do this in three steps.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好配置我们的网络设备。我们通过将`cvx`包中定义的模板编译成具体的CUE值来生成最终的配置实例。我们分三步完成这项工作。
- en: 'First, we load all CUE files from the local directory, specifying the name
    of the package containing the template (`cvx`):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们加载本地目录中所有的CUE文件，指定包含模板的包名（`cvx`）：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Second, we compile all loaded files into a CUE value, which resolves all imports
    and combines the input with the template:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步，我们将所有加载的文件编译成一个CUE值，这解决了所有导入并将输入与模板结合：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we validate that we can resolve all references and that the input
    provides all the required fields:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们验证是否可以解析所有引用，并且输入提供了所有必需的字段：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once we know the CUE value is concrete, we can safely marshal it into JSON
    and send it directly to the `cvx` device. The body of the `sendBytes` function
    implements the three-stage commit process we discussed in [*Chapter 6*](B16971_06.xhtml#_idTextAnchor144),
    *Configuration Management*:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道CUE值是具体的，我们就可以安全地将它序列化为JSON并发送到`cvx`设备。`sendBytes`函数的主体实现了我们在[*第6章*](B16971_06.xhtml#_idTextAnchor144)“配置管理”中讨论的三阶段提交过程：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can find the full program in the `ch08/cue` directory (refer to the *Further
    reading* section) of this book’s GitHub repository (refer to the *Further reading*
    section). The same directory includes the complete version of the CUE files with
    a data template and input schema and the input YAML file. Successful execution
    of this program should produce an output like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书GitHub仓库的`ch08/cue`目录（参考*进一步阅读*部分）中找到完整的程序（参考*进一步阅读*部分）。该目录包括带有数据模板和输入模式的完整CUE文件以及输入YAML文件。该程序的正常执行应该产生如下输出：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Keep in mind that although we focus on CUE’s Go API in this chapter, you can
    do the same set of actions using the CUE CLI (executable binary). This even includes
    the three-stage commit to submit and apply the `cvx` configuration. Using the
    built-in CUE scripting language, you can define any sequence of tasks, such as
    making HTTP calls or checking and parsing responses. You can save these actions
    or tasks in a special *tool* file and they automatically become available in the
    `cue` binary. You can read more about this in the `ch08/cue` readme document and
    find example source code in the `ch08/cue/cue_tool.cue` file (refer to the *Further*
    *reading* section).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，尽管我们在这章中关注CUE的Go API，但你也可以使用CUE CLI（可执行二进制文件）执行相同的操作集。这甚至包括三阶段提交以提交和应用`cvx`配置。使用内置的CUE脚本语言，你可以定义任何任务序列，例如进行HTTP调用或检查和解析响应。你可以将这些操作或任务保存到特殊的*工具*文件中，它们将自动在`cue`二进制文件中可用。你可以在`ch08/cue`的readme文档中了解更多信息，并在该书的GitHub仓库的`ch08/cue/cue_tool.cue`文件中找到示例源代码（参考*进一步阅读*部分）。
- en: CUE has many use cases outside of what we’ve just described and different open
    source projects such as **Istio** and **dagger.io** (refer to the *Further reading*
    section) have adopted it and use it in their products. We encourage you to explore
    other CUE use cases beyond what’s covered in this book, as well as similar configuration
    languages such as **Jsonnet** and **Dhall** (refer to the *Further* *reading*
    section).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: CUE 在我们刚刚描述的应用场景之外还有许多用途，不同的开源项目如 **Istio** 和 **dagger.io**（参考 *进一步阅读* 部分）已经采用了它并在其产品中使用。我们鼓励您探索本书涵盖之外的其他
    CUE 用例，以及类似的配置语言如 **Jsonnet** 和 **Dhall**（参考 *进一步阅读* 部分）。
- en: We’ve covered a few different ways of interacting with an OpenAPI provider.
    For the rest of this chapter, we’ll focus on YANG-based APIs. The first one we’ll
    introduce is a JSON-RPC interface implementation from Nokia.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了几种与 OpenAPI 提供者交互的不同方式。在本章的剩余部分，我们将专注于基于 YANG 的 API。我们将介绍的第一个是诺基亚的 JSON-RPC
    接口实现。
- en: JSON-RPC
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON-RPC
- en: JSON-RPC is a lightweight protocol you can use to exchange structured data between
    a client and a server. It can work over different transport protocols, but we’ll
    focus only on HTTP. Although JSON-RPC is a standard, it only defines the top-level
    RPC layer, while payloads and operations remain specific to each implementation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-RPC 是一种轻量级协议，您可以使用它来在客户端和服务器之间交换结构化数据。它可以在不同的传输协议上工作，但我们将仅关注 HTTP。尽管 JSON-RPC
    是一种标准，但它只定义了顶级 RPC 层，而有效载荷和操作则保持对每个实现的特定性。
- en: In this section, we’ll show how to use Nokia-specific YANG models to configure
    the srl device from our lab topology, as SR Linux supports sending and receiving
    YANG payloads over JSON-RPC (refer to the *Further* *reading* section).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示如何使用诺基亚特定的 YANG 模型来配置我们实验室拓扑中的 srl 设备，因为 SR Linux 支持通过 JSON-RPC 发送和接收
    YANG 有效载荷（参考 *进一步阅读* 部分）。
- en: We’ll try to avoid building YANG data payloads manually or relying on traditional
    text templating methods. The sheer size of some YANG models, as well as model
    deviations and augmentations, make it impossible to build the payloads manually.
    To do this at scale, we need to rely on a programmatic approach to build configuration
    instances and retrieve state data. This is where we use openconfig/ygot (YANG
    Go Tools) (refer to the *Further reading* section)—a set of tools and APIs for
    automatic code generation from a collection of YANG models.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尽量避免手动构建 YANG 数据有效载荷或依赖传统的文本模板方法。一些 YANG 模型的巨大规模，以及模型偏差和增强，使得手动构建有效载荷变得不可能。为了大规模地完成这项工作，我们需要依赖一种程序化的方法来构建配置实例和检索状态数据。这就是我们使用
    openconfig/ygot（YANG Go 工具）（参考 *进一步阅读* 部分）的地方——一套从一组 YANG 模型自动生成代码的工具和 API。
- en: 'At a high level, the structure of the example program is analogous to the one
    in the *OpenAPI* section. *Figure 8**.3* shows the building blocks of the program
    we’ll review in this section:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，示例程序的结构与 *OpenAPI* 部分中的类似。*图 8.3* 展示了本节中我们将要审查的程序的基本构建块：
- en: '![Figure 8.3 – Working with YANG data models](img/B16971_08_03.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – 使用 YANG 数据模型](img/B16971_08_03.jpg)'
- en: Figure 8.3 – Working with YANG data models
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 使用 YANG 数据模型
- en: We’ll start by combining the auto-generated Go bindings with the input data
    and building a configuration instance to provision the `srl` device.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先将自动生成的 Go 绑定与输入数据结合起来，构建一个配置实例来配置 `srl` 设备。
- en: Code generation
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码生成
- en: Starting from the top of the preceding diagram, the first step is to generate
    the corresponding Go code from a set of Nokia’s YANG models (refer to the *Further
    reading* section). We’ll only use a subset of Nokia’s YANG models to generate
    the bindings to configure what we need, namely L3 interfaces, BGP, and route redistribution.
    This way, we keep the size of the generated Go package small and constrained to
    our specific use case.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面图表的顶部开始，第一步是从一组诺基亚的 YANG 模型生成相应的 Go 代码（参考 *进一步阅读* 部分）。我们将仅使用诺基亚 YANG 模型的一个子集来生成绑定，以配置我们所需要的，即
    L3 接口、BGP 和路由重分发。这样，我们保持生成的 Go 包的大小小，并限制在我们的特定用例中。
- en: Sadly, there is no universal rule for how to pinpoint the list of models you
    need apart from reading and understanding YANG models or reverse-engineering them
    from an existing configuration. Thankfully, Nokia has developed a YANG browser
    (refer to the *Further reading* section) that includes a pattern-matching search
    that highlights the relevant XPaths and can help you find the right set of YANG
    models.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，除了阅读和理解 YANG 模型或从现有配置中逆向工程它们之外，没有通用的规则来确定您需要的模型列表。幸运的是，诺基亚开发了一个 YANG 浏览器（参考
    *进一步阅读* 部分），它包括一个模式匹配搜索，可以突出显示相关的 XPaths，并帮助您找到正确的 YANG 模型集。
- en: 'Once we’ve identified which models we need, we can use the ygot generator tool
    to build a Go package based on them. We won’t describe all the flags of this tool,
    as ygot’s official documentation (refer to the *Further reading* section) covers
    them. Still, we want to highlight the most important options we’ll use:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了需要的模型，我们就可以使用 ygot 生成器工具根据它们构建一个 Go 包。我们不会描述这个工具的所有标志，因为 ygot 的官方文档（参考
    *进一步阅读* 部分）涵盖了它们。不过，我们想强调我们将使用的重要选项：
- en: '`generate_fakeroot`: This encapsulates all generated Go data structures in
    a top-level *fake* root data structure called `Device` to join all modules in
    a common hierarchy. Because there isn’t a YANG model that defines a universal
    root top-level container for all devices, network devices just add the YANG modules
    they support at the root (`/`). `ygot` represents the root via this *fake* root
    container.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generate_fakeroot`: 这将所有生成的 Go 数据结构封装在一个名为 `Device` 的顶级 *模拟* 根数据结构中，以将所有模块连接到一个共同的层次结构中。因为没有
    YANG 模型定义了一个适用于所有设备的通用根顶级容器，网络设备只需在根 (`/`) 处添加它们支持的 YANG 模块。`ygot` 通过这个 *模拟* 根容器表示根。'
- en: '`path`: This flag helps `ygot` find and resolve any YANG data model imports.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`: 此标志帮助 `ygot` 查找并解决任何 YANG 数据模型导入。'
- en: 'The complete command to auto-generate the `srl` package and place it in the
    `./pkg/srl/` directory we used is this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成 `srl` 包并将其放置在我们使用的 `./pkg/srl/` 目录的完整命令如下：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since the preceding command has several flags, it may be desirable to remember
    their exact set to make the build reproducible in the future. One alternative
    is to include it in a code build utility, such as make. Another, more Go-native
    option is to include it in the source code using the `//go:generate` directive,
    as you can see in the `ch08/json-rpc/main.go` file (refer to the *Further reading*
    section). Thus, you can generate the same `srl` repeatedly using this command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面的命令有几个标志，可能需要记住它们的确切集合，以便将来可以重复构建。一个替代方案是将它们包含在一个代码构建工具中，例如 make。另一个更符合
    Go 习惯的选项是使用 `//go:generate` 指令将其包含在源代码中，正如您在 `ch08/json-rpc/main.go` 文件中看到的那样（参考
    *进一步阅读* 部分）。因此，您可以使用此命令反复生成相同的 `srl`：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Building configuration
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建配置
- en: Now that we’ve built a YANG-based Go package, we can create a programmatic instance
    of our desired configuration state and populate it. We do all this within Go,
    with the full flexibility of a general-purpose programming language at our disposal.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了一个基于 YANG 的 Go 包，我们可以创建一个程序实例来表示我们想要的配置状态，并填充它。我们所有这些操作都在 Go 中完成，利用通用编程语言的全部灵活性。
- en: For example, we can design the configuration program as a set of methods, with
    the input model being the receiver argument. After we read and decode the input
    data, we create an empty *fake* root device we extend iteratively until we build
    the complete YANG instance with all the relevant values we want to configure.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将配置程序设计为一组方法，输入模型作为接收器参数。在读取和解析输入数据后，我们创建一个空的 *模拟* 根设备，我们迭代地扩展它，直到构建包含所有我们想要配置的相关值的完整
    YANG 实例。
- en: 'The benefit of using a root device is that we don’t need to worry about individual
    paths. We can send our payload to `/`, assuming that the resulting YANG tree hierarchy
    starts from the root:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用根设备的好处是我们不需要担心单个路径。我们可以将有效载荷发送到 `/`，假设生成的 YANG 树层次结构从根开始：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code calls three methods on input. Let’s zoom in on `buildNetworkInstance`,
    responsible for L3 routing configuration. This method is where we define a *network
    instance*, which is a commonly used abstraction for **VPN Routing and Forwarding**
    (**VRF**) instances and **Virtual Switch Instances** (**VSIs**). We create a new
    network instance from the top-level root device to ensure we attach it to the
    top of the YANG tree:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码在输入上调用三个方法。让我们聚焦于 `buildNetworkInstance` 方法，它负责 L3 路由配置。此方法是我们定义 *网络实例*
    的地方，它是用于 **VPN 路由和转发**（**VRF**）实例和 **虚拟交换实例**（**VSIs**）的常用抽象。我们从顶级根设备创建一个新的网络实例，以确保我们将其附加到
    YANG 树的顶部：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the next code snippet, we move all uplinks and a loopback interface into
    the newly created network instance by defining each subinterface as a child of
    the default network instance:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个代码片段中，我们将所有上行链路和环回接口移动到新创建的网络实例中，通过将每个子接口定义为默认网络实例的子项来实现：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we define the global BGP settings by manually populating the BGP struct
    and attaching it to the `Protocols.Bgp` field of the `default` network instance:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过手动填充 BGP 结构并将其附加到 `default` 网络实例的 `Protocols.Bgp` 字段来定义全局 BGP 设置：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The final part of the configuration is BGP neighbors. We iterate over a list
    of peers defined in the input data model and add a new entry under the BGP struct
    we set up earlier:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 配置的最后部分是 BGP 邻居。我们遍历输入数据模型中定义的对等体列表，并在我们之前设置的 BGP 结构下添加一个新的条目：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When we finish populating the Go structs, we make sure that all provided values
    are correct and match the YANG constraints. We can do this with a single call
    to the `Validate` method on the parent container:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成填充 Go 结构时，我们确保所有提供的值都是正确的，并且符合 YANG 约束。我们可以通过在父容器上调用 `Validate` 方法来完成此操作：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Device configuration
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备配置
- en: 'Once we have populated a YANG model instance with all the input values, the
    next step is to send it to the target device. We do this in a few steps:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们用所有输入值填充了 YANG 模型实例，下一步就是将其发送到目标设备。我们通过几个步骤来完成此操作：
- en: We use a `ygot` helper function to produce a map from the current YANG instance.
    This map is ready to be serialized into JSON according to the rules defined in
    RFC7951.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `ygot` 辅助函数从当前的 YANG 实例生成一个映射。此映射已准备好根据 RFC7951 中定义的规则序列化为 JSON。
- en: We use the standard `encoding/json` library to build a single JSON-RPC request
    that updates the entire YANG tree with our configuration changes.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用标准的 `encoding/json` 库构建一个单一的 JSON-RPC 请求，该请求使用我们的配置更改更新整个 YANG 树。
- en: 'Using the standard `net/http` package, we send this request to the `srl` device:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用标准的 `net/http` 包，我们将此请求发送到 `srl` 设备：
- en: '[PRE18]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can find the complete program that configures the srl device in the `ch08/json-rpc`
    directory (refer to the *Further reading* section) of this book’s GitHub repository.
    To run it, `cd` into this folder and run the following command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书 GitHub 仓库的 `ch08/json-rpc` 目录中找到配置 srl 设备的完整程序（参考 *进一步阅读* 部分）。要运行它，请
    `cd` 到此文件夹并运行以下命令：
- en: '[PRE48]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This program only verifies that we executed the RPC successfully; it doesn’t
    yet check to confirm that it had the desired effect, which we will discuss later
    in this chapter. As with most HTTP-based protocols, a single RPC is a single transaction,
    so you can assume the target device applied the changes, as long as you receive
    a successful response. It’s worth mentioning that some JSON-RPC implementations
    have more session control functions that allow multistage commits, rollbacks,
    and other features.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序仅验证我们成功执行了 RPC；它尚未检查以确认它是否产生了预期的效果，我们将在本章后面讨论。与大多数基于 HTTP 的协议一样，单个 RPC 是一个单一的事务，因此您可以假设目标设备已应用了更改，只要您收到成功的响应。值得一提的是，一些
    JSON-RPC 实现具有更多的会话控制功能，允许多阶段提交、回滚和其他功能。
- en: In the following section, we’ll take a similar approach of configuring a network
    device based on its YANG models but introduce a couple of twists to show OpenConfig
    models and the RESTCONF API.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将采取类似的方法配置网络设备，基于其 YANG 模型，但将引入一些变化以展示 OpenConfig 模型和 RESTCONF API。
- en: RESTCONF
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTCONF
- en: The IETF designed RESTCONF as an HTTP-based alternative to NETCONF that offers
    **Create, Read, Update, and Delete** (**CRUD**) operations on a conceptual datastore
    containing YANG-modeled data. It may lack some NETCONF features, such as different
    datastores, exclusive configuration locking, and batch and rollback operations,
    but the exact set of supported and unsupported features depends on the implementation
    and network device capabilities. That said, because it uses HTTP methods and supports
    JSON encoding, RESTCONF reduces the barrier of entry for external systems to integrate
    and inter-operate with a network device.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: IETF 设计 RESTCONF 作为基于 HTTP 的 NETCONF 替代方案，它提供对包含 YANG 模型数据的概念数据存储的 **创建、读取、更新和删除**（**CRUD**）操作。它可能缺少一些
    NETCONF 功能，例如不同的数据存储、排他性配置锁定以及批量和回滚操作，但具体支持的和不支持的功能取决于实现和网络设备的功能。话虽如此，由于它使用 HTTP
    方法并支持 JSON 编码，RESTCONF 减少了外部系统集成和与网络设备互操作入门的障碍。
- en: 'RESTCONF supports a standard set of CRUD operations through HTTP methods: POST,
    PUT, PATCH, GET, and DELETE. RESTCONF builds HTTP messages with the YANG XPath
    translated into a REST-like URI and it transports the payload in the message body.
    Although RESTCONF supports both XML and JSON encoding, we will only focus on the
    latter, with the rules of the encoding defined in RFC7951\. We’ll use Arista’s
    EOS as a test device, which has its RESTCONF API enabled when launching the lab
    topology.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: RESTCONF 通过 HTTP 方法支持一组标准的 CRUD 操作：POST、PUT、PATCH、GET 和 DELETE。RESTCONF 使用 YANG
    XPath 转换为类似 REST 的 URI 来构建 HTTP 消息，并在消息体中传输有效负载。尽管 RESTCONF 支持 XML 和 JSON 编码，但我们将仅关注后者，其编码规则定义在
    RFC7951 中。我们将使用 Arista 的 EOS 作为测试设备，在启动实验室拓扑时，其 RESTCONF API 已启用。
- en: The structure of the program we’ll create in this section is the same as for
    the JSON-RPC example illustrated in *Figure 8**.3*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中创建的程序结构与 *图 8**.3* 中所示的 JSON-RPC 示例相同。
- en: Code generation
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码生成
- en: 'The code generation process is almost the same as the one we followed in the
    *JSON-RPC* section. We use openconfig/ygot (refer to the *Further reading* section)
    to generate a Go package from a set of YANG models that EOS supports. But there
    are a few notable differences that are worth mentioning before moving forward:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 代码生成过程几乎与我们在 *JSON-RPC* 部分遵循的过程相同。我们使用 openconfig/ygot（请参阅 *进一步阅读* 部分）从 EOS
    支持的一组 YANG 模型生成一个 Go 包。但在继续之前，有一些值得注意的差异需要提及：
- en: Instead of vendor-specific YANG models, we use vendor-neutral OpenConfig models,
    which Arista EOS supports.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用的是供应商中立的 OpenConfig 模型，而不是特定于供应商的 YANG 模型，这些模型 Arista EOS 支持。
- en: When generating Go code with openconfig/ygot (refer to the *Further reading*
    section), you might run into situations when more than one model is defined in
    the same namespace. In those cases, you can use the `-exclude_modules` flag to
    ignore a certain YANG model without having to remove its source file from the
    configured search path.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 openconfig/ygot（请参阅 *进一步阅读* 部分）生成 Go 代码时，您可能会遇到在同一个命名空间中定义了多个模型的情况。在这种情况下，您可以使用
    `-exclude_modules` 标志忽略特定的 YANG 模型，而无需从配置的搜索路径中删除其源文件。
- en: We enable OpenConfig path compression to optimize the generated Go code by removing
    the YANG containers containing `list` nodes. Refer to the `ygen` library design
    documentation for more details (*Further reading*).
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过移除包含 `list` 节点的 YANG 容器来启用 OpenConfig 路径压缩，以优化生成的 Go 代码。有关更多详细信息，请参阅 `ygen`
    库设计文档（*进一步阅读*）。
- en: We also show an alternative approach where we don’t generate a *fake* root device.
    As a result, we can’t apply all the changes in a single RPC. Instead, we have
    to make more than one HTTP call, each with its own unique URI path.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还展示了另一种方法，其中我们不生成一个 *假* 的根设备。因此，我们无法在一个 RPC 中应用所有更改。相反，我们必须进行多个 HTTP 调用，每个调用都有自己的唯一
    URI 路径。
- en: 'Before we can generate the Go code, we need to identify the supported set of
    Arista YANG models (refer to the *Further reading* section) and copy them into
    the `yang` directory. We use the following command to generate the `eos` Go package
    from that list of models:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够生成 Go 代码之前，我们需要确定支持的 Arista YANG 模型集（请参阅 *进一步阅读* 部分），并将它们复制到 `yang` 目录中。我们使用以下命令从该模型列表生成
    `eos` Go 包：
- en: '[PRE49]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'For the same reasons we described in the *JSON-RPC* section, we can also embed
    this command into the Go source code to generate the same Go package using the
    following command instead:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在 *JSON-RPC* 部分描述的原因，我们也可以使用以下命令将此命令嵌入到 Go 源代码中，以生成相同的 Go 包：
- en: '[PRE50]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Building configuration
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建配置
- en: In this example, we won’t apply all changes in a single HTTP call so that we
    can show you how to update a specific part of a YANG tree without affecting other,
    unrelated parts. In the preceding section, we worked around that by using an `Update`
    operation, which merges the configuration we send with the existing configuration
    on the device.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们不会在一个单独的HTTP调用中应用所有更改，这样我们就可以向您展示如何更新YANG树的特定部分，而不会影响其他无关的部分。在前一节中，我们通过使用`Update`操作来解决这个问题，该操作将我们发送的配置与设备上现有的配置合并。
- en: But in certain cases, we want to avoid the *merge* behavior and ensure that
    only the configuration we send is present on the device (declarative management).
    For that, we could’ve imported all existing configurations and identified the
    parts that we want to keep or replace before sending a new configuration version
    to the target device. Instead, we create a configuration for the specific parts
    of a YANG tree via a series of RPCs.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 但在某些情况下，我们希望避免*合并*行为，并确保只有我们发送的配置存在于设备上（声明式管理）。为此，我们本可以导入所有现有的配置，并确定我们想要保留或替换的部分，然后再向目标设备发送新的配置版本。相反，我们通过一系列RPC创建一个针对YANG树特定部分的配置。
- en: 'To simplify RESTCONF API calls, we create a special `restconfRequest` type
    that holds a URI path and a corresponding payload to send to the device. The `main`
    function starts with parsing the inputs for the data model and preparing a variable
    to store a set of RESTCONF RPCs:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化RESTCONF API调用，我们创建了一个特殊的`restconfRequest`类型，它包含一个URI路径和要发送到设备的相应有效载荷。`main`函数从解析数据模型的输入和准备一个变量以存储一组RESTCONF
    RPC开始：
- en: '[PRE51]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As in the JSON-RPC example, we build the desired configuration instance in
    a series of method calls. This time, each method returns one `restConfRequest`
    that has enough details to build an HTTP request:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与JSON-RPC示例一样，我们通过一系列方法调用构建所需的配置实例。这次，每个方法返回一个包含足够详细信息以构建HTTP请求的`restConfRequest`：
- en: '[PRE52]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let’s examine one of these methods that creates a YANG configuration from our
    inputs. The `enableRedistribution` method generates a configuration to enable
    redistribution between a directly connected table and the BGP `TableConnection`
    struct that uses a pair of YANG enums to identify the redistribution source and
    destination:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查这些方法之一，它可以从我们的输入创建一个YANG配置。`enableRedistribution`方法生成一个配置，以在直接连接的表和用于识别重分布源和目标的BGP
    `TableConnection`结构之间启用重分布：
- en: '[PRE53]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The rest of the code in *Figure 8**.3* shows the building blocks of the program
    we review in this section.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8**.3* 中的其余代码显示了本节中我们审查的程序的基本构建块。'
- en: Device configuration
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备配置
- en: Once we’ve prepared all the required RESTCONF RPCs, we can send them to the
    device. We iterate over each `restconfRequest` and pass it to a helper function,
    catching any returned errors.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们准备好了所有必要的RESTCONF RPC，我们就可以将它们发送到设备。我们遍历每个`restconfRequest`，并将其传递给一个辅助函数，捕获任何返回的错误。
- en: 'The `restconfPost` helper function has just enough code to build an HTTP request
    using the `net/http` package and send it to the `ceos` device:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`restconfPost`辅助函数有足够的代码来使用`net/http`包构建一个HTTP请求并将其发送到`ceos`设备：'
- en: '[PRE54]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You can find the complete program in the `ch08/restconf` directory (refer to
    the *Further reading* section) of this book’s GitHub repository. Running it from
    a host running the lab topology should produce a similar output to this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书GitHub仓库的`ch08/restconf`目录中找到完整的程序（参考*进一步阅读*部分）。从运行实验室拓扑结构的宿主机上运行它应该会产生与这个类似的输出：
- en: '[PRE55]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: At this point, we should have all three nodes of our lab topology fully configured.
    Still, we haven’t confirmed that what we’ve done has had the desired effect. In
    the next section, we’ll go through a process of state validation and show how
    you can do it using network APIs.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们应该已经完全配置了我们的实验室拓扑结构中的所有三个节点。尽管如此，我们还没有确认我们所做的一切是否达到了预期的效果。在下一节中，我们将通过状态验证的过程，并展示如何使用网络API来完成这一过程。
- en: State validation
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态验证
- en: In the last three sections of this chapter, we pushed device configs without
    verifying that the configuration changes had the desired effect. This is because
    we need all devices configured before we can validate the resulting converged
    operational state. Now, with all the code examples from the *OpenAPI*, *JSON-RPC*,
    and *RESTCONF* sections executed against the lab topology, we can verify whether
    we achieved our configuration intent—establish end-to-end reachability between
    loopback IP addresses of all three devices.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后三个部分中，我们在验证配置更改是否产生预期效果之前就推动了设备配置。这是因为我们需要所有设备配置完毕后才能验证产生的收敛操作状态。现在，随着所有来自
    *OpenAPI*、*JSON-RPC* 和 *RESTCONF* 部分的代码示例在实验室拓扑结构上执行，我们可以验证我们是否实现了配置意图——在所有三个设备的回环
    IP 地址之间建立端到端可达性。
- en: In this section, we’ll use the same protocols and modeling language we used
    earlier in this chapter to validate that each lab device can see the loopback
    IP address of the other two lab devices in its `ch08/state` directory (refer to
    the *Further reading* section) of this book’s GitHub repository. Next, we’ll examine
    a single example of how you can do this with Arista’s cEOS (`ceos`) lab device.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用本章前面使用的相同协议和建模语言来验证每个实验室设备是否可以在其 GitHub 仓库的 `ch08/state` 目录（参考 *进一步阅读*
    部分）中看到其他两个实验室设备的回环 IP 地址。接下来，我们将检查一个使用 Arista 的 cEOS (`ceos`) 实验室设备的单个示例。
- en: Operational state modeling
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作状态建模
- en: One thing we need to be mindful of when talking about the operational state
    of a network element is the difference between the applied and the derived state,
    as described by the YANG operational state IETF draft (refer to the *Further reading*
    section). The former refers to the currently active device configuration and should
    reflect what an operator has already applied. The latter is a set of read-only
    values that result from the device’s internal operations, such as CPU or memory
    utilization, and interaction with external elements, such as packet counters or
    BGP neighbor state. Although we aren’t explicitly mentioning it when we’re talking
    about an operational state, assume we’re referring to the derived state unless
    we state otherwise.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论网络元素的操作状态时，需要注意 YANG 操作状态 IETF 草案（参考 *进一步阅读* 部分）中描述的已应用状态和导出状态之间的区别。前者指的是当前活动的设备配置，应该反映操作员已经应用的内容。后者是一组只读值，由设备的内部操作产生，例如
    CPU 或内存利用率，以及与外部元素（如数据包计数器或 BGP 邻居状态）的交互。尽管在我们谈论操作状态时没有明确提及，但除非我们明确说明，否则假设我们指的是导出状态。
- en: 'Historically, there’ve been different ways to model the device’s operational
    state in YANG:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，在 YANG 中对设备的操作状态进行建模的方法有很多：
- en: You could either enclose everything in a top-level container or read from a
    separate `state` datastore, completely distinct from the `config` container/datastore
    we use for configuration management.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以选择将所有内容都包含在一个顶级容器中，或者从独立的 `state` 数据存储中读取，与用于配置管理的 `config` 容器/数据存储完全不同。
- en: Another way is to create a separate `state` container for every YANG sub-tree
    alongside the `config` container. This is what the YANG operational state IETF
    draft (refer to the *Further reading* section) describes.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种方法是为每个 YANG 子树创建一个独立的 `state` 容器，与 `config` 容器并列。这正是 YANG 操作状态 IETF 草案（参考
    *进一步阅读* 部分）所描述的。
- en: Depending on which approach you use, you may need to adjust how you construct
    your RPC request. For example, the `srl` device needs an explicit reference to
    the `state` datastore. What we show in the next code example is the alternative
    approach, where you retrieve a part of the YANG sub-tree and extract the relevant
    state information from it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你使用的方法，你可能需要调整构建 RPC 请求的方式。例如，`srl` 设备需要一个对 `state` 数据存储的显式引用。我们在下一个代码示例中展示了另一种方法，即从
    YANG 子树中检索一部分，并从中提取相关的状态信息。
- en: It’s worth noting that OpenAPI is less strict about the structure and composition
    of its models and the state may come from a different part of a tree or require
    a specific query parameter to reference the operational datastore, depending on
    the implementation.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，OpenAPI 对其模型的结构和组成要求不那么严格，状态可能来自树的不同部分，或者根据实现需要特定的查询参数来引用操作数据存储。
- en: Operational state processing
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作状态处理
- en: Configuration management workflows typically involve the processing of some
    input data to generate a device-specific configuration. This is a common workflow
    that we often use to show the capabilities of an API. But there is an equally
    important workflow that involves operators retrieving state data from a network
    device, which they process and verify. In that case, the information flows in
    the opposite direction—from a network device to a client application.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理工作流程通常涉及处理一些输入数据以生成特定于设备的配置。这是一个常见的流程，我们经常用它来展示API的功能。但还有一个同样重要的流程，涉及操作员从网络设备检索状态数据，然后处理和验证这些数据。在这种情况下，信息流的方向是从网络设备到客户端应用程序。
- en: 'At the beginning of this chapter, we discussed the configuration management
    workflow, so now we want to give a high-level overview of the state retrieval
    workflow:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们讨论了配置管理工作流程，因此现在我们想要提供一个关于状态检索工作流程的高级概述：
- en: We start by querying a remote API endpoint, represented by a set of URL and
    HTTP query parameters.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先查询一个远程API端点，该端点由一组URL和HTTP查询参数表示。
- en: We receive an HTTP response, which has a binary payload attached to it.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们收到一个带有附加二进制有效载荷的HTTP响应。
- en: We unmarshal this payload into a Go struct that follows the device’s data model.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将这个有效载荷反序列化到一个遵循设备数据模型的Go结构体中。
- en: Inside this struct, we look at the relevant parts of the state we can extract
    and evaluate.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个结构体内部，我们查看可以提取和评估的状态的相关部分。
- en: The following code snippet from the `ch08/state` program (refer to the *Further
    reading* section) is a concrete example of this workflow. The program structure
    follows the same pattern we described in the *State validation* section of [*Chapter
    6*](B16971_06.xhtml#_idTextAnchor144), *Configuration Management*. Hence, in this
    chapter, we’ll only zoom in on the most relevant part—the `GetRoutes` function,
    which connects to the `ceos` device and retrieves the content of its routing table.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从`ch08/state`程序（参考*进一步阅读*部分）中的代码片段，这是该工作流程的具体示例。程序结构遵循我们在[*第6章*](B16971_06.xhtml#_idTextAnchor144)的*状态验证*部分中描述的相同模式，即*配置管理*。因此，在本章中，我们只聚焦于最相关的部分——`GetRoutes`函数，该函数连接到`ceos`设备并检索其路由表的内容。
- en: 'It starts by building an HTTP request with the device-specific login information:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先使用设备特定的登录信息构建一个HTTP请求：
- en: '[PRE56]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The **Abstract Forwarding Table** (**AFT**) in the code example is an OpenConfig
    representation of the FIB (routing) table and the GET API call retrieves a JSON
    representation of the default **Virtual Routing and Forwarding** (**VRF**) routing
    table.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例中的**抽象转发表**（**AFT**）是FIB（路由）表的OpenConfig表示，GET API调用检索默认**虚拟路由和转发**（**VRF**）路由表的JSON表示。
- en: 'Next, we create an instance of the Go struct corresponding to the part of the
    YANG tree we queried and pass it to the `Unmarshal` function for deserialization.
    The resulting Go struct now has one `Ipv4Entry` value for each entry in the default
    FIB and we store that list of prefixes in the `out` slice:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个与查询的YANG树部分相对应的Go结构体实例，并将其传递给`Unmarshal`函数进行反序列化。结果Go结构体现在为默认FIB中的每个条目都有一个`Ipv4Entry`值，我们将这些前缀列表存储在`out`切片中：
- en: '[PRE57]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In this example, we import the `eos` package (`restconf/pkg/eos`) we auto-generated
    in the *RESTCONF* section of this chapter, which lives outside the root directory
    of this program. To do this, we add the `replace restconf => ../restconf/` instruction
    to this program’s `go.mod` file (`ch08/state/go.mod`; refer to the *Further* *reading*
    section).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们导入了在本章*RESTCONF*部分自动生成的`eos`包（`restconf/pkg/eos`），它位于本程序根目录之外。为此，我们在本程序的`go.mod`文件（`ch08/state/go.mod`；参考*进一步阅读*部分）中添加了`replace
    restconf => ../restconf/`指令。
- en: For the remaining lab devices, we follow a similar state retrieval workflow.
    The only difference is in the YANG paths and the model-based Go structs we use
    for deserialization. You can find the full program code in the `ch08/state` directory
    (refer to the *Further reading* section) of this book’s GitHub repository.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于剩余的实验室设备，我们遵循类似的状态检索工作流程。唯一的区别在于我们用于反序列化的YANG路径和基于模型的Go结构体。您可以在本书GitHub仓库的`ch08/state`目录（参考*进一步阅读*部分）中找到完整的程序代码。
- en: In this chapter, we have covered network APIs based on HTTP version 1.1 that
    use common encoding formats, such as JSON. Although HTTP is still very popular
    and this is unlikely to change soon, it has its own limitations that may manifest
    themselves in large-scale deployments. HTTP 1.1 is a text-based protocol, which
    means it’s not efficient on the wire and its client-server origins make it difficult
    to adapt it for bi-directional streaming. The next version of this protocol, HTTP/2,
    overcomes these shortcomings. HTTP/2 is the transport protocol of the gRPC framework,
    which is what we’ll examine in the next section.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了基于 HTTP 版本 1.1 的网络 API，这些 API 使用常见的编码格式，如 JSON。尽管 HTTP 仍然非常流行，并且这种情况不太可能很快改变，但它有其自身的局限性，这些局限性可能在大型部署中显现出来。HTTP
    1.1 是一种基于文本的协议，这意味着它在网络上的效率不高，其客户端-服务器起源使其难以适应双向流。该协议的下一个版本 HTTP/2，克服了这些缺点。HTTP/2
    是 gRPC 框架的传输协议，我们将在下一节中对其进行研究。
- en: gRPC
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gRPC
- en: Network automation opens a door that until recently seemed closed or at least
    prevented network engineers from reusing technologies that have had success in
    other areas, such as microservices or cloud infrastructure.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 网络自动化打开了一扇直到最近似乎关闭或至少阻止网络工程师重用在其他领域取得成功的技术的门，例如微服务或云基础设施。
- en: One of the most recent advances in network device management is the introduction
    of gRPC. We can use this high-performance RPC framework for a wide range of network
    operations, from configuration management to state streaming and software management.
    But performance is not the only thing that is appealing about gRPC. Just like
    with YANG and OpenAPI apps, gRPC auto-generates client and server stubs in different
    programming languages, which enables us to create an ecosystem of tools around
    the API.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 网络设备管理中最新的进展之一是引入了 gRPC。我们可以使用这个高性能 RPC 框架进行各种网络操作，从配置管理到状态流和软件管理。但性能并不是 gRPC
    吸引人的唯一因素。就像 YANG 和 OpenAPI 应用程序一样，gRPC 在不同的编程语言中自动生成客户端和服务器存根，这使得我们能够围绕 API 创建一个工具生态系统。
- en: 'In this section, we’ll go over the following topics to help you understand
    the gRPC API better:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍以下主题，以帮助您更好地理解 gRPC API：
- en: Protobuf
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Protobuf
- en: gRPC transport
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gRPC 传输
- en: Defining gRPC services
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义 gRPC 服务
- en: Configuring network devices with gRPC
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 gRPC 配置网络设备
- en: Streaming telemetry from a network device with gRPC
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 gRPC 从网络设备中流式传输遥测数据
- en: Protobuf
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Protobuf
- en: gRPC uses protobuf as its **Interface Definition Language** (**IDL**) to allow
    you to share structured data between remote software components that may be written
    in different programming languages.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 使用 protobuf 作为其 **接口定义语言** (**IDL**)，允许您在可能用不同编程语言编写的远程软件组件之间共享结构化数据。
- en: When working with protobuf, one of the first steps is to model the information
    you’re serializing by creating a protobuf file. This file has a list of *messages*
    defining the structure and type of data to exchange.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 protobuf 时，第一步是创建一个 protobuf 文件来建模您要序列化的信息。此文件包含一个 *消息* 列表，定义了交换数据的结构和类型。
- en: 'If we take the input data model we have been using throughout this book as
    an example and encode it in a `.proto` file, it would look something like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以本书中一直使用的输入数据模型为例，并将其编码在 `.proto` 文件中，它看起来可能像这样：
- en: '[PRE58]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Each field has an explicit type and a unique sequence number that identifies
    it within the enclosing message.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字段都有一个显式的类型和一个唯一的序列号，用于在包含的消息中标识它。
- en: 'The next step in the workflow, just like with OpenAPI or YANG, is to generate
    bindings for Go (or any other programming language). For this, we use the protobuf
    compiler, protoc, which generates the source code with data structures and methods
    to access and validate different fields:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作流程的下一步，就像 OpenAPI 或 YANG 一样，是为 Go（或任何其他编程语言）生成绑定。为此，我们使用 protobuf 编译器 protoc，它生成包含数据结构和访问和验证不同字段的方法的源代码：
- en: '[PRE59]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The preceding command saves the bindings in a single file, `pb/model.pb.go`.
    You can view the contents of this file to see what structs and functions you can
    use. For example, we automatically get this `Router` struct, which is what we
    had to define manually before:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将绑定保存在单个文件中，`pb/model.pb.go`。您可以查看此文件的 内容，以了解您可以使用哪些结构和函数。例如，我们自动获得这个 `Router`
    结构体，这是我们之前必须手动定义的：
- en: '[PRE60]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Protobuf encodes a series of key-value pairs in a binary format similar to how
    routing protocols encode **Type-Length-Values** (**TLVs**). But instead of sending
    the key name and a declared type for each field, it just sends the field number
    as the key with its value appended to the end of the byte stream.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Protobuf 以类似于路由协议编码 **类型-长度-值**（**TLVs**）的二进制格式编码一系列键值对。但它不是为每个字段发送键名和声明的类型，而是只发送字段编号作为键，并将其值附加到字节流的末尾。
- en: 'As with TLVs, Protobuf needs to know the length of each value to encode and
    decode a message successfully. For this, Protobuf encodes a wire type in the 8-bit
    key field along with the field number that comes from the `.proto` file. The following
    table shows the wire types available:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 与 TLVs 一样，Protobuf 需要知道每个值的长度才能成功编码和解码消息。为此，Protobuf 在 8 位键字段中编码了一个线类型，以及来自
    `.proto` 文件的字段编号。以下表格显示了可用的线类型：
- en: '| **Type** | **Meaning** | **Used For** |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **含义** | **用途** |'
- en: '| 0 | Varint | int32, int64, uint32, uint64, sint32, sint64, bool, enum |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 可变长整型 | int32、int64、uint32、uint64、sint32、sint64、bool、枚举 |'
- en: '| 1 | 64-bit | fixed64, sfixed64, double |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 64 位 | fixed64、sfixed64、double |'
- en: '| 2 | Length-delimited | string, bytes, embedded messages, packed repeated
    fields |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 长度限定 | 字符串、字节、嵌入的消息、打包的重复字段 |'
- en: '| 5 | 32-bit | fixed32, sfixed32, float |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 32 位 | fixed32、sfixed32、float |'
- en: Table 8.1 – Protobuf wire types
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.1 – Protobuf 线类型
- en: This generates a dense message (small output) that a CPU can process faster
    compared to a JSON- or XML-encoded message. The downside is the message you generate
    is not human-readable in its native format and it’s only meaningful if you have
    the message definition (proto file) to find out the name and type for each field.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成了一个密集的消息（输出小），CPU 可以比 JSON 或 XML 编码的消息更快地处理。缺点是生成的消息在其原生格式下不可读，并且只有当您有消息定义（proto
    文件）以找出每个字段的名称和类型时才有意义。
- en: Protobuf on the wire
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线路上的 Protobuf
- en: 'One of the easiest ways to see how protobuf looks in a binary format is to
    save it into a file. In our book’s GitHub repository, we have an example in the
    `ch08/protobuf/write` directory (refer to the *Further reading* section) that
    reads a sample `input.yaml` file and populates the data structure generated from
    the `.proto` file we discussed earlier. We then serialize and save the result
    into a file we name `router.data`. You can use the following command to execute
    this example:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 protobuf 在二进制格式中的样子，最简单的方法是将它保存到一个文件中。在我们的 GitHub 仓库中，我们在 `ch08/protobuf/write`
    目录中有一个示例（参考 *进一步阅读* 部分），该示例读取一个示例 `input.yaml` 文件，并填充从我们之前讨论的 `.proto` 文件生成的数据结构。然后我们序列化并将结果保存到我们命名为
    `router.data` 的文件中。您可以使用以下命令执行此示例：
- en: '[PRE61]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You can see the content of the generated protobuf message by viewing the file
    with `hexdump -C router.data`. If we group some bytes for convenience and refer
    to the proto definition file, we can make sense of the data, as shown in the following
    figure:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用 `hexdump -C router.data` 命令查看生成的 protobuf 消息的内容。如果我们为了方便将一些字节分组并参考 proto
    定义文件，我们可以理解这些数据，如下所示：
- en: '![Figure 8.4 – Protobuf-encoded message](img/B16971_08_04.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 – Protobuf 编码的消息](img/B16971_08_04.jpg)'
- en: Figure 8.4 – Protobuf-encoded message
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – Protobuf 编码的消息
- en: 'To give you an idea of how efficient the protobuf encoding is, we’ve included
    a couple of JSON files encoding the same data. The `router.json` file is a compact
    (space-free) JSON encoding. The second version, called `router_ident.json`, has
    the same JSON payload indented with extra spaces, which can happen if you generate
    JSON from a text template or use *pretty print* functions before sending the data
    over the network:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您了解 protobuf 编码的效率，我们包含了一些编码相同数据的 JSON 文件。`router.json` 文件是一个紧凑的（无空格）JSON
    编码。第二个版本，称为 `router_ident.json`，具有相同的 JSON 有效负载，但缩进并添加了额外的空格，这可能会在从文本模板生成 JSON
    或在网络传输数据之前使用 *pretty print* 函数时发生：
- en: '[PRE62]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The difference between JSON and protobuf is quite stark and can become very
    important when transferring and encoding/decoding large datasets.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 和 protobuf 之间的差异非常明显，并且在传输和编码/解码大型数据集时可能会变得非常重要。
- en: Now that we know some basics about gRPC data encoding, we can move on to the
    protocol used to transfer these messages.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了一些关于 gRPC 数据编码的基础知识，我们可以继续了解用于传输这些消息的协议。
- en: gRPC transport
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: gRPC 传输
- en: Besides efficient binary encoding and enabling simpler framing to serialize
    your data—compared to newline-delimited plain text—the gRPC framework also attempts
    to exchange those messages as efficiently as possible over the network.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 除了高效的二进制编码和允许更简单的帧来序列化你的数据——与换行符分隔的纯文本相比——gRPC框架还试图尽可能高效地在网络上交换这些消息。
- en: 'While you can only process one request/response message at a time with HTTP/1.1,
    gRPC makes use of HTTP/2 to multiplex parallel requests over the same TCP connection.
    Another benefit of HTTP/2 is that it supports header compression. *Table 8.2*
    shows the various transport methods used by different APIs:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你一次只能处理一个请求/响应消息的HTTP/1.1，但gRPC利用HTTP/2在相同的TCP连接上多路复用并行请求。HTTP/2的另一个好处是它支持头部压缩。*表8.2*显示了不同API使用的各种传输方法：
- en: '| **API** | **Transport** | **RPC/Methods** |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| **API** | **传输** | **RPC/方法** |'
- en: '| NETCONF | SSH | get-config, edit-config, commit, lock |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| NETCONF | SSH | get-config，edit-config，commit，lock |'
- en: '| RESTCONF | HTTP | GET, POST, DELETE, PUT |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| RESTCONF | HTTP | GET，POST，DELETE，PUT |'
- en: '| gRPC | HTTP/2 | Unary, server streaming, client streaming, bidirectional
    streaming |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| gRPC | HTTP/2 | 单一请求，服务器流式传输，客户端流式传输，双向流式传输 |'
- en: Table 8.2 – API comparative table
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.2 – API比较表
- en: Compared to the older network APIs, gRPC not only allows you to make unary or
    single requests, but it also supports full-duplex streaming. Both the client and
    server can stream data simultaneously, so you no longer need to work around the
    limitations of the traditional client-server mode of interaction.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 与较老的网络API相比，gRPC不仅允许你进行单一或单个请求，还支持全双工流式传输。客户端和服务器可以同时流式传输数据，因此你不再需要绕过传统客户端-服务器交互模式的限制。
- en: Defining gRPC services
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义gRPC服务
- en: gRPC uses Protobuf to define statically typed services and messages in a file
    that we can use to generate the code for client and server applications to consume.
    gRPC abstracts the underlying transport and serialization details, allowing developers
    to focus on the business logic of their applications instead.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC使用Protobuf在文件中定义静态类型的服务和消息，我们可以使用它来生成客户端和服务器应用程序的代码。gRPC抽象了底层的传输和序列化细节，使开发者能够专注于其应用程序的业务逻辑。
- en: 'A gRPC service is a collection of RPCs that accept and return protobuf messages.
    In the following output, you can see a snippet from Cisco IOS XR’s proto file
    called `ems_grpc.proto` (refer to the *Further reading* section). This file defines
    a gRPC service called `gRPCConfigOper` with several RPCs to perform a standard
    set of configuration management operations:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 一个gRPC服务是一组接受和返回protobuf消息的RPC。在以下输出中，你可以看到Cisco IOS XR的proto文件`ems_grpc.proto`的片段（参见*进一步阅读*部分）。该文件定义了一个名为`gRPCConfigOper`的gRPC服务，具有几个RPC来执行一组标准的配置管理操作：
- en: '[PRE63]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As well as the configuration management operations, this Cisco IOS XR protobuf
    definition includes a streaming telemetry subscription (`CreateSubs`) RPC. The
    message format for the request and response is also part of the `ems_grpc.proto`
    file (refer to the *Further reading* section). For example, to invoke the telemetry
    subscription RPC, the client has to send a `ConfigArgs` message and the server
    (router) should reply with a stream of `CreateSubsReply` messages.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 除了配置管理操作之外，这个Cisco IOS XR protobuf定义还包括一个流式遥测订阅（`CreateSubs`）RPC。请求和响应的消息格式也是`ems_grpc.proto`文件的一部分（参见*进一步阅读*部分）。例如，要调用遥测订阅RPC，客户端必须发送一个`ConfigArgs`消息，服务器（路由器）应该回复一系列`CreateSubsReply`消息。
- en: 'Unlike with NETCONF, where `telemetry.proto` (refer to the *Further* *reading*
    section):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 与NETCONF不同，其中`telemetry.proto`（参见*进一步阅读*部分）：
- en: '[PRE64]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This is something that the OpenConfig community is addressing with the definition
    of vendor-agnostic services, such as gNMI (`gnmi.proto`; refer to the *Further
    reading* section), which we will explore in the next chapter:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是OpenConfig社区通过定义供应商无关的服务来解决的问题，例如gNMI（`gnmi.proto`；参见*进一步阅读*部分），我们将在下一章中探讨：
- en: '[PRE65]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Now, let’s see how you can use these RPCs with Go.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用Go来使用这些RPC。
- en: Configuring network devices with gRPC
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用gRPC配置网络设备
- en: 'In our example program, we configure an IOS XR device with the `ReplaceConfig`
    RPC, defined in a service called `gRPCConfigOper`. You can find all the source
    code for this program in the `ch08/grpc` directory of this book’s GitHub repository
    (refer to the *Further reading* section). You can use the following command to
    execute this program against a test device in Cisco’s DevNet sandbox:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例程序中，我们使用名为`gRPCConfigOper`的服务中的`ReplaceConfig` RPC配置一个IOS XR设备。你可以在这个书的GitHub仓库的`ch08/grpc`目录中找到这个程序的完整源代码（参考*进一步阅读*部分）。你可以使用以下命令在Cisco的DevNet沙盒中对测试设备执行此程序：
- en: '[PRE66]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Following the same configuration management workflow we’ve used throughout
    this chapter, we’ll start by generating the code for the following gRPC service:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 按照本章中使用的相同的配置管理工作流程，我们将首先为以下gRPC服务生成代码：
- en: '[PRE67]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: One thing to remember when working with gRPC-based network APIs is that they
    might not define the full data tree natively as protobuf schemas. In the preceding
    example, one field defines a string called `yangjson` that expects a YANG-based
    JSON payload, not exploring any further what might be inside that “string.” Carrying
    a YANG-based JSON payload is what we also did in the JSON-RPC and RESTCONF examples.
    In a sense, gRPC serves as a thin RPC wrapper in this example, not too different
    from JSON-RPC. We are still doing the configuration management work with YANG-based
    data structures.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当与基于gRPC的网络API一起工作时，有一件事需要记住，它们可能不会原生地以protobuf模式定义完整的数据树。在先前的示例中，一个字段定义了一个名为`yangjson`的字符串，它期望一个基于YANG的JSON有效负载，并没有进一步探索那个“字符串”里面可能是什么。携带基于YANG的JSON有效负载是我们也在JSON-RPC和RESTCONF示例中做的事情。在某种意义上，gRPC在这个示例中充当了一个薄的RPC包装器，与JSON-RPC没有太大区别。我们仍然在使用基于YANG的数据结构进行配置管理的工作。
- en: Since we’re now using both gRPC and YANG schemas, we have to use `protoc` together
    with `ygot` to generate their respective bindings. We run the `protoc` command
    to generate the code from the proto definition in `ch08/grpc/proto` (refer to
    the *Further reading* section) and `ygot` to generate code from a set of OpenConfig
    YANG models. You can find the exact set of commands in the `ch08/grpc/generate_code`
    file (refer to the *Further* *reading* section).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在同时使用gRPC和YANG模式，我们必须使用`protoc`与`ygot`一起生成它们各自的绑定。我们运行`protoc`命令从`ch08/grpc/proto`（参考*进一步阅读*部分）中的proto定义生成代码，并使用`ygot`从一组OpenConfig
    YANG模型生成代码。你可以在`ch08/grpc/generate_code`文件中找到确切的命令集（参考*进一步* *阅读*部分）。
- en: 'Before we can connect to the target device, we need to gather all the information
    we need to run the program, so we reuse the data structures from [*Chapter 6*](B16971_06.xhtml#_idTextAnchor144),
    *Configuration Management*, to store this data:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够连接到目标设备之前，我们需要收集运行程序所需的所有信息，因此我们重用[*第6章*](B16971_06.xhtml#_idTextAnchor144)中*配置管理*部分的数据结构来存储这些数据：
- en: '[PRE68]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We start the `main` function of the program by populating the access credentials
    and processing the device configuration inputs, just like in other examples in
    the book:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过填充访问凭证和处理设备配置输入来启动程序的`main`函数，就像书中其他示例中一样：
- en: '[PRE69]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Next, we use the `ygot` Go bindings from the `grpc/pkg/oc` package to prepare
    the `yangjson` payload. We build the BGP configuration in the `buildNetworkInstance`
    method in the same way we showed in the *JSON-RPC* section of this chapter. Once
    the `oc.Device` struct is fully populated, we serialize it into a JSON string:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用来自`grpc/pkg/oc`包的`ygot` Go绑定来准备`yangjson`有效负载。我们以与本章*JSON-RPC*部分中展示的相同方式在`buildNetworkInstance`方法中构建BGP配置。一旦`oc.Device`结构体完全填充，我们就将其序列化为JSON字符串：
- en: '[PRE70]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'To simplify the interactions with the target device, we created a thin wrapper
    around the gRPC API. We define a handful of method receivers for the `xrgrpc`
    type that implement things such as initial connection establishment and deleting
    or replacing RPCs. This is how we connect and replace the target device’s configuration:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化与目标设备的交互，我们围绕gRPC API创建了一个薄的包装器。我们为`xrgrpc`类型定义了一些方法接收器，实现了诸如初始连接建立和删除或替换RPC等功能。这就是我们连接和替换目标设备配置的方式：
- en: '[PRE71]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Looking closer at the `ReplaceConfig` method, we can see exactly how to invoke
    the required RPC. We dynamically generate a random ID and populate the `ConfigArg`
    message with the YANG-based JSON payload that we generated with `ygot` a couple
    of steps before. The inner `ReplaceConfig` method is the one that the `protoc`
    command automatically generated for us:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看`ReplaceConfig`方法，我们可以看到如何调用所需的RPC。我们动态生成一个随机ID，并用我们在几步之前用`ygot`生成的基于YANG的JSON有效负载填充`ConfigArg`消息。内部的`ReplaceConfig`方法是`protoc`命令为我们自动生成的：
- en: '[PRE72]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The configuration payload we send in this case is a string blob, but we can
    also encode the content fields with protobuf if the target devices support this.
    This is what we’ll examine next with a streaming telemetry example.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们发送的配置有效负载是一个字符串blob，但如果我们目标设备支持，我们也可以使用protobuf对内容字段进行编码。这就是我们将通过流式遥测示例来检查的内容。
- en: Streaming telemetry from a network device with gRPC
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用gRPC从网络设备流式传输遥测数据
- en: gRPC streaming capabilities allow network devices to send data over a persistent
    TCP connection either continuously (stream) or on demand (poll). We’ll continue
    with the same program we started earlier and reuse the same connection we set
    up to configure a network device to subscribe to a telemetry stream.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC流式传输功能允许网络设备通过持久的TCP连接连续（流式）或按需（轮询）发送数据。我们将继续使用我们之前开始的相同程序，并重用我们设置的相同连接来配置一个网络设备以订阅遥测流。
- en: Even though we initiated a connection to the Cisco IOS XR device, the data now
    flows in the opposite direction. This means we need to be able to decode the information
    we receive and there are two different ways of doing this.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们初始化了与Cisco IOS XR设备的连接，但数据现在流向相反的方向。这意味着我们需要能够解码我们接收到的信息，并且有两种不同的方法来做这件事。
- en: Once we’ve configured the device, we request it to stream the operational state
    of all BGP neighbors. In the first scenario, we’ll cover the case where you have
    the BGP neighbor proto definition to decode the messages you get. Then, we’ll
    examine a less efficient option where a proto definition is unnecessary.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们配置了设备，我们就请求它流式传输所有BGP邻居的操作状态。在第一种场景中，我们将讨论你拥有BGP邻居协议定义以解码你收到的消息的情况。然后，我们将检查一个不太高效的选项，其中不需要协议定义。
- en: Decoding YANG-defined data with Protobuf
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Protobuf解码YANG定义的数据
- en: 'We use the `CreateSubs` RPC to subscribe to a telemetry stream. We need to
    submit the subscription ID we want to stream and choose an encoding option between
    `gpb` for protobuf or `gpbkv` for an option we’ll explore at the end of this chapter.
    The following output shows the proto definition of this RPC and its message types:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`CreateSubs` RPC来订阅遥测流。我们需要提交我们想要流式传输的订阅ID，并在`gpb`（用于protobuf）或`gpbkv`（我们将在本章末尾探讨的选项）之间选择一个编码选项。以下输出显示了此RPC及其消息类型的协议定义：
- en: '[PRE73]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Similar to the configuration part of the program, we create a helper function
    to submit the request to the router. The main difference is that now the reply
    is a data stream. We store the result of `CreateSubs` in a variable we call `st`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 与程序配置部分类似，我们创建一个辅助函数来提交对路由器的请求。主要区别在于现在回复是一个数据流。我们将`CreateSubs`的结果存储在一个我们称为`st`的变量中。
- en: 'For data streams, gRPC gives us the `Recv` method, which blocks until it receives
    a message. To continue processing in the main thread, we run an anonymous function
    in a separate goroutine that calls the auto-generated `GetData` method. This method
    returns the `data` field of each message we get and we send it over a channel
    (`b`) back to the main goroutine:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据流，gRPC为我们提供了`Recv`方法，该方法会阻塞，直到它收到一条消息。为了在主线程中继续处理，我们在一个单独的goroutine中运行一个匿名函数，该函数调用自动生成的`GetData`方法。此方法返回我们收到的每条消息的`data`字段，并将其通过一个通道（`b`）发送回主goroutine：
- en: '[PRE74]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `data` field, and hence the data we receive in channel `b`, consist of
    arrays of bytes that we need to decode. We know this is a streaming telemetry
    message, so we use its proto-generated code to decode its fields. *Figure 8**.5*
    shows an example of how we can get to BGP state information by following the proto
    file definitions:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`字段，以及我们在通道`b`中接收到的数据，由我们需要解码的字节数组组成。我们知道这是一个流式遥测消息，因此我们使用其协议生成的代码来解码其字段。*图8**.5*展示了我们如何通过遵循协议文件定义来获取BGP状态信息的一个示例：'
- en: '![Figure 8.5 – Protobuf telemetry message (protobuf)](img/B16971_08_06.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5 – Protobuf遥测消息（protobuf）](img/B16971_08_06.jpg)'
- en: Figure 8.5 – Protobuf telemetry message (protobuf)
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – Protobuf遥测消息（protobuf）
- en: 'Back in the main goroutine, we listen out for what the `GetSubscription` channel
    returns and iterate over each message we get. We unmarshal the data received into
    a `Telemetry` message. At this point, we have access to the general telemetry
    data, so we can use the auto-generated functions to access some of its fields,
    such as the timestamp and the encoding path:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在主goroutine中，我们监听`GetSubscription`通道返回的内容，并对我们收到的每个消息进行迭代。我们将接收到的数据解包到`Telemetry`消息中。在这个时候，我们可以访问一般遥测数据，因此我们可以使用自动生成的函数来访问一些字段，例如时间戳和编码路径：
- en: '[PRE75]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Following that, we extract the content of the `data_bgp` field to access the
    BGP data encoded with protobuf. Cisco IOS XR lists the items in rows, so for each
    one, we unmarshal the content into the auto-generated `BgpNbrBag` data structure,
    from where we can access all operational information of a BGP neighbor. This way,
    we get the connection state and the IPv4 address of the BGP peer, which we print
    to the screen:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们提取`data_bgp`字段的内容以访问使用protobuf编码的BGP数据。Cisco IOS XR按行列出项目，因此对于每一个，我们将内容解包到自动生成的`BgpNbrBag`数据结构中，从这里我们可以访问BGP邻居的所有操作信息。这样，我们获取了BGP对等方的连接状态和IPv4地址，并将其打印到屏幕上：
- en: '[PRE76]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: If you don’t have access to the BGP message definition (proto file), gRPC can
    still represent the fields with protobuf, but it has to add the name and value
    type for each one, so the receiving end can parse them. This is what we’ll examine
    next.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法访问BGP消息定义（proto文件），gRPC仍然可以使用protobuf表示字段，但必须为每个字段添加名称和值类型，以便接收端可以解析它们。这就是我们接下来要检查的内容。
- en: Protobuf self-describing messages
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Protobuf自描述消息
- en: 'While self-describing messages in a way defeat the purpose of protobuf by sending
    unnecessary data, we’ve included an example here to contrast how you could parse
    a message in this scenario:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然自描述消息在某种程度上抵消了protobuf的作用，因为它发送了不必要的数据，但我们在这里提供了一个示例，以对比在这种情况下如何解析消息：
- en: '![Figure 8.6 – Protobuf self-describing telemetry message (JSON)](img/B16971_08_05.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6 – Protobuf自描述遥测消息（JSON）](img/B16971_08_05.jpg)'
- en: Figure 8.6 – Protobuf self-describing telemetry message (JSON)
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – Protobuf自描述遥测消息（JSON）
- en: 'The telemetry header is the same, but when you choose `gpbkv` as the encoding
    format, Cisco IOS XR sends the data in the `data_bgpkv` field instead:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 遥测头是相同的，但是当你选择`gpbkv`作为编码格式时，Cisco IOS XR会在`data_bgpkv`字段中发送数据：
- en: '[PRE77]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'At this point, what you have is a big JSON file you can navigate using a Go
    package of your preference. Here, we’ve used `gjson`. To test this program, you
    can rerun the same program we described earlier with an extra flag to enable the
    self-describing key-value messages:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你有一个大型的JSON文件，你可以使用你偏好的Go包来导航。在这里，我们使用了`gjson`。为了测试这个程序，你可以重新运行我们之前描述的相同程序，并添加一个额外的标志来启用自描述的键值消息：
- en: '[PRE78]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: While this method might seem less involved, not only do you compromise the performance
    benefits but also, by not knowing the Go data structures beforehand, it opens
    up room for bugs and typos, it prevents you from taking advantage of the auto-completion
    features of most IDEs, and it makes your code less explicit. All of that has a
    negative impact on code development and troubleshooting.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法可能看起来不那么复杂，但你不仅会牺牲性能优势，而且由于事先不知道Go数据结构，它为错误和打字错误打开了空间，它阻止了你利用大多数IDE的自动完成功能，并且使你的代码不那么明确。所有这些都对代码开发和故障排除产生了负面影响。
- en: Summary
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored different ways to use APIs and RPCs to interact
    with network devices. One common theme we saw throughout this chapter was having
    a model for any data we exchange. Although the network community has embraced
    YANG as the standard language to model network configuration and operational state
    data, the implementation differences across networking vendors still impede its
    wide adoption.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用API和RPC与网络设备交互的不同方法。贯穿本章的一个共同主题是对于任何交换的数据都有一个模型。尽管网络社区已经接受YANG作为建模网络配置和操作状态数据的标准语言，但不同网络供应商之间的实现差异仍然阻碍了其广泛采用。
- en: In the next chapter, we’ll look at how OpenConfig tries to increase the adoption
    of declarative configuration and model-driven management and operations by defining
    a set of vendor-neutral models and protocols.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨OpenConfig如何通过定义一组供应商中立的模型和协议来尝试增加声明性配置和模型驱动管理及操作的采用。
- en: Further reading
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The book’s GitHub repository: [https://github.com/PacktPublishing/Network-Automation-with-Go](https://github.com/PacktPublishing/Network-Automation-with-Go)'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该书的 GitHub 仓库：[https://github.com/PacktPublishing/Network-Automation-with-Go](https://github.com/PacktPublishing/Network-Automation-with-Go)
- en: 'OpenAPI versions: [https://swagger.io/specification/#appendix-a-revision-history](https://swagger.io/specification/#appendix-a-revision-history)'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenAPI 版本：[https://swagger.io/specification/#appendix-a-revision-history](https://swagger.io/specification/#appendix-a-revision-history)
- en: 'CUE: [https://cuelang.org/](https://cuelang.org/)'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'CUE: [https://cuelang.org/](https://cuelang.org/)'
- en: '`ch08/cue/template.cue`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/cue/template.cue](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/cue/template.cue)'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch08/cue/template.cue`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/cue/template.cue](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/cue/template.cue)'
- en: 'CUE’s *References and Visibility* tutorial: [https://cuelang.org/docs/tutorials/tour/references/](https://cuelang.org/docs/tutorials/tour/references/)'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CUE 的 *引用和可见性* 教程：[https://cuelang.org/docs/tutorials/tour/references/](https://cuelang.org/docs/tutorials/tour/references/)
- en: 'The `ch08/cue` directory: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/cue](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/cue)'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch08/cue` 目录：[https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/cue](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/cue)'
- en: '`ch08/cue/cue_tool.cue`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/cue/cue_tool.cue](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/cue/cue_tool.cue)'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch08/cue/cue_tool.cue`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/cue/cue_tool.cue](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/cue/cue_tool.cue)'
- en: 'Istio: [https://istio.io/](https://istio.io/)'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Istio: [https://istio.io/](https://istio.io/)'
- en: 'dagger.io: [https://dagger.io/](https://dagger.io/)'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'dagger.io: [https://dagger.io/](https://dagger.io/)'
- en: 'Jsonnet: [https://github.com/google/go-jsonnet](https://github.com/google/go-jsonnet)'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Jsonnet: [https://github.com/google/go-jsonnet](https://github.com/google/go-jsonnet)'
- en: 'Dhall: [https://github.com/philandstuff/dhall-golang](https://github.com/philandstuff/dhall-golang)'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Dhall: [https://github.com/philandstuff/dhall-golang](https://github.com/philandstuff/dhall-golang)'
- en: 'JSON-RPC: [https://documentation.nokia.com/srlinux/SR_Linux_HTML_R21-11/SysMgmt_Guide/json-interface.html](https://documentation.nokia.com/srlinux/SR_Linux_HTML_R21-11/SysMgmt_Guide/json-interface.html)'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'JSON-RPC: [https://documentation.nokia.com/srlinux/SR_Linux_HTML_R21-11/SysMgmt_Guide/json-interface.html](https://documentation.nokia.com/srlinux/SR_Linux_HTML_R21-11/SysMgmt_Guide/json-interface.html)'
- en: 'openconfig/ygot: https://github.com/openconfig/ygot'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'openconfig/ygot: https://github.com/openconfig/ygot'
- en: 'Nokia’s YANG models: [https://github.com/nokia/srlinux-yang-models](https://github.com/nokia/srlinux-yang-models)'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诺基亚的 YANG 模型：[https://github.com/nokia/srlinux-yang-models](https://github.com/nokia/srlinux-yang-models)
- en: 'The YANG browser: [https://yang.srlinux.dev/v21.6.4/](https://yang.srlinux.dev/v21.6.4/)'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YANG 浏览器：[https://yang.srlinux.dev/v21.6.4/](https://yang.srlinux.dev/v21.6.4/)
- en: 'ygot’s official documentation: [https://github.com/openconfig/ygot#introduction](https://github.com/openconfig/ygot#introduction)'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ygot 的官方文档：[https://github.com/openconfig/ygot#introduction](https://github.com/openconfig/ygot#introduction)
- en: 'The `ch08/json-rpc/main.go` file: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/json-rpc/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/json-rpc/main.go)'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch08/json-rpc/main.go` 文件：[https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/json-rpc/main.go](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/json-rpc/main.go)'
- en: 'The `ch08/json-rpc` directory: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/json-rpc](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/json-rpc)'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch08/json-rpc` 目录：[https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/json-rpc](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/json-rpc)'
- en: 'The `yget` library design documentation: [https://github.com/openconfig/ygot/blob/master/docs/design.md#openconfig-path-compression](https://github.com/openconfig/ygot/blob/master/docs/design.md#openconfig-path-compression)'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yget` 库的设计文档：[https://github.com/openconfig/ygot/blob/master/docs/design.md#openconfig-path-compression](https://github.com/openconfig/ygot/blob/master/docs/design.md#openconfig-path-compression)'
- en: 'Arista YANG models: [https://github.com/aristanetworks/yang](https://github.com/aristanetworks/yang)'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arista YANG 模型：[https://github.com/aristanetworks/yang](https://github.com/aristanetworks/yang)
- en: 'The `ch08/restconf` directory: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch08/restconf](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch08/restconf)'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch08/restconf` 目录：[https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch08/restconf](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch08/restconf)'
- en: 'The `ch08/state` directory: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch08/state](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch08/state)'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch08/state` 目录: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch08/state](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch08/state)'
- en: 'IETF draft: [https://datatracker.ietf.org/doc/html/draft-openconfig-netmod-opstate-01](https://datatracker.ietf.org/doc/html/draft-openconfig-netmod-opstate-01)'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'IETF 草案: [https://datatracker.ietf.org/doc/html/draft-openconfig-netmod-opstate-01](https://datatracker.ietf.org/doc/html/draft-openconfig-netmod-opstate-01)'
- en: 'The `ch08/state` program: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch08/state](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch08/state)'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch08/state` 程序: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch08/state](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch08/state)'
- en: '`ch08/state/go.mod`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/state/go.mod](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/state/go.mod)'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch08/state/go.mod`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/state/go.mod](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/state/go.mod)'
- en: 'The `ch08/protobuf/write` directory: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch08/protobuf/write](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch08/protobuf/write)'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch08/protobuf/write` 目录: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch08/protobuf/write](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch08/protobuf/write)'
- en: '`ems_grpc.proto`: [https://github.com/nleiva/xrgrpc/blob/master/proto/ems/ems_grpc.proto](https://github.com/nleiva/xrgrpc/blob/master/proto/ems/ems_grpc.proto)'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ems_grpc.proto`: [https://github.com/nleiva/xrgrpc/blob/master/proto/ems/ems_grpc.proto](https://github.com/nleiva/xrgrpc/blob/master/proto/ems/ems_grpc.proto)'
- en: '`telemetry.proto`: [https://github.com/Juniper/jtimon/blob/master/telemetry/telemetry.proto](https://github.com/Juniper/jtimon/blob/master/telemetry/telemetry.proto)'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`telemetry.proto`: [https://github.com/Juniper/jtimon/blob/master/telemetry/telemetry.proto](https://github.com/Juniper/jtimon/blob/master/telemetry/telemetry.proto)'
- en: '`gnmi.proto`: [https://github.com/openconfig/gnmi/blob/master/proto/gnmi/gnmi.proto](https://github.com/openconfig/gnmi/blob/master/proto/gnmi/gnmi.proto)'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gnmi.proto`: [https://github.com/openconfig/gnmi/blob/master/proto/gnmi/gnmi.proto](https://github.com/openconfig/gnmi/blob/master/proto/gnmi/gnmi.proto)'
- en: '`ch08/grpc/proto`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch08/grpc/proto](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch08/grpc/proto)'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch08/grpc/proto`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch08/grpc/proto](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/ch08/grpc/proto)'
- en: '`ch08/grpc/generate_code`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/grpc/generate_code](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/grpc/generate_code)'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ch08/grpc/generate_code`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/grpc/generate_code](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch08/grpc/generate_code)'
