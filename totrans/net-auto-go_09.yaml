- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenConfig
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenConfig is a group of network operators (see the *Further reading* section)
    with the common goal of streamlining the way we manage and operate networks. They
    welcome anyone operating a production network as a member and, more recently,
    have started to accept contributions from vendors when more than one of them implements
    the same feature (that they want to include in a YANG model).
  prefs: []
  type: TYPE_NORMAL
- en: Their initial focus was to create a set of vendor-neutral YANG data models based
    on common operational use cases and requirements from the field. This later expanded
    to include vendor-neutral **Remote Procedure Calls** (**RPCs**) for configuring,
    streaming telemetry, performing operational commands, and manipulating forwarding
    entries (see *Further reading*) on network devices. In this chapter, we will focus
    primarily on the OpenConfig RPCs, as we already covered YANG data models in [*Chapter
    8*](B16971_08.xhtml#_idTextAnchor182), *Network APIs*.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that sets OpenConfig apart from other similar initiatives is that
    they not only work publicly on the specifications but also write open source code
    that implements these specifications, helping you to interact with OpenConfig-compliant
    devices. They write most of these projects in Go, including but not limited to
    ygot, gNxI Tools, the gNMI collector, the gNMI CLI utility, the gNMI test framework,
    gRPC tunnels, and IS-IS LSDB parsing (see *Further reading*). We encourage you
    to explore those projects, especially the ones we do not cover in this book, as
    they target a wide range of network-related applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, OpenConfig includes four gRPC services:'
  prefs: []
  type: TYPE_NORMAL
- en: '**gRPC Network Management Interface** (**gNMI**): For streaming telemetry and
    configuration management'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**gRPC Network Operations Interface** (**gNOI**): For executing operational
    commands on network devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**gRPC Routing Information Base Interface** (**gRIBI**): To let an external
    client inject routing entries on a network element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**gRPC Network Security Interface** (**gNSI**): Infrastructure services for
    securing access to a compliant network device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following sections, we will examine the following common operational
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Device provisioning, with the gNMI `Set` RPC, to label correctly the primary
    and backup interfaces between two nodes in the lab topology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streaming telemetry, with the `Subscribe` RPC, where a Go program reacts to
    a gNMI telemetry stream to make changes to the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network operations, with a `traceroute` example with the gNOI `Traceroute` RPC,
    to check that all the forwarding paths in the network are working as expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code examples for this chapter in the book’s GitHub repository
    (see *Further reading*), in the `ch09` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: We recommend you execute the Go programs in this chapter in a virtual lab environment.
    Refer to the appendix for prerequisites and instructions on how to build the fully
    configured network topology.
  prefs: []
  type: TYPE_NORMAL
- en: The first example we discuss in the following section explores gNMI to configure
    network devices with Go.
  prefs: []
  type: TYPE_NORMAL
- en: Device provisioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B16971_06.xhtml#_idTextAnchor144), *Configuration Management*,
    we discussed applying the desired configuration state on a network device. Network
    engineers routinely have to log in to network devices to provision new services,
    bring up new connections, or remove outdated configurations. We covered the different
    transport options available to configure network devices such as SSH or HTTP in
    the same chapter, and in [*Chapter 8*](B16971_08.xhtml#_idTextAnchor182), *Network
    APIs*, we added gRPC as another option.
  prefs: []
  type: TYPE_NORMAL
- en: We briefly touched on modeling network device configurations with a data modeling
    language such as YANG, so we could move from configuring networks with semi-structured
    vendor-specific CLI syntax to a model where we exchange structured data with the
    network to change its configuration state.
  prefs: []
  type: TYPE_NORMAL
- en: OpenConfig defines a gRPC service specifically for configuration management
    called gNMI. It aims to provide a common gRPC protobuf definition that any vendor
    can implement, alongside their existing proprietary gRPC services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The protobuf definition for gNMI is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: gNMI particularly offers configuration management capabilities via the `Set`
    RPC that you can use to make changes on a target node. The gNMI specification
    (see *Further reading*) has extensive documentation on all available gNMI RPCs.
    In this section, we will focus on `Set`.
  prefs: []
  type: TYPE_NORMAL
- en: Set RPC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Set` RPC lets you change the state of a target network device. You do this
    by sending a `SetRequest` message that encodes all changes you want to make.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can update, replace, or delete values in the data tree of the target device
    in a single transaction, using dedicated fields of the `SetRequest` message. This
    means that unless the target can apply every specified change, it must roll all
    of them back and return to its previous state. The following protobuf definition
    shows the options you have in a `SetRequest` message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The field called `Path` in `SetRequest` encodes a YANG data tree path. It’s
    worth noting that gNMI is not limited to using OpenConfig YANG models; it works
    equally well with vendor-defined YANG models. gNMI describes the data tree path
    as a series of `PathElem` (path elements). Each one of these is a data tree node
    that has a name, and it may have one or more attributes (keys) associated with
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, the `/interfaces/interface[name=Ethernet2]/config/description`
    path lets you set the description on the `Ethernet2` interface on a target device.
    The only data node in this case that has an attribute is `interface`, which needs
    a `name`. To configure an IPv4 address on the native VLAN in that same interface,
    you can use a path that looks like this: `/interfaces/interface[name=Ethernet2]/subinterfaces/subinterface[index=0]/ipv4/addresses/address[ip=192.0.2.2]`.
    In this case, you need to add the `subinterface` index, as the interface could
    have IP addresses on different sub-interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have identified the data path, you need to build the content that has
    the new values you want to set on the target device, which is a data instance
    of a YANG schema. You only need this for `replace` and `update`. For `delete`,
    the path is enough to tell the target device what to remove from the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `Update` message that you would use to send the values for either `replace`
    or `update` has a `Path` and `TypedValue` pair. The latter lets you encode the
    content in different formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A value could be a string for an interface description, such as `PRIMARY: TO
    -> CVX:swp1` or a JSON value to describe the IPv4 address of an interface such
    as `{"config":{"ip":"192.0.2.2","prefix-length":31}}`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using gNMI to configure network interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The virtual lab topology for this chapter, which you can bring up by running
    `make lab-full` from the root of this book’s GitHub repository, has two connections
    between `ceos` and `cvx`. They have IPv4 addresses configured already, but they
    don’t have a description that lets you identify the roles of these interfaces,
    whether they are the primary or the backup link:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – A dual link between ceos and cvx](img/B16971_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – A dual link between ceos and cvx
  prefs: []
  type: TYPE_NORMAL
- en: In the next example, we add a description to those interfaces on the `ceos`
    side via gNMI. To do this, we use the gNMIc package (`karimra/gnmic/api`). We
    chose gNMIc over the official gNMI package (`openconfig/gnmi`) because it’s more
    developer-friendly and higher-level. It lets us conveniently encode the gNMI paths
    as strings, instead of Go data structures, as the gNMIc docs (see *Further reading*)
    describe. You can find the code for this example in the `ch09/gnmi` directory
    of this book’s GitHub repository (see *Further reading*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The gNMIc package has a `NewTarget` function that creates a new gNMI target
    device. In the following example, we wrap this function in the `createTarget`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step in the code is to read the connection details from a YAML file
    (`input.yml`) to create this target device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We store all target devices in the `Routers` data structure. In our case, we
    only have one device (`clab-netgo-ceos`) but the connection details are a list,
    so we could’ve added more devices if we wanted to. Now, with the target data,
    we use the `CreateGNMIClient` method to set up the underlying gRPC connection
    to the target device (`clab-netgo-ceos:6030`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With the connection established, we now can send the `Set` requests. Another
    YAML file (`api-ceos.yml`) has a list of parameters for each request: `prefix`,
    `encoding`, `path`, and `value`. You can add `prefix` when you want to reduce
    the length of a path. In our Go program, we save this list of parameters in the
    `info` slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is to iterate over the `info` slice, build a `Set` request with
    the `NewSetRequest` function, and send it to the target device using the `Set`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, `NewSetRequest` has only one `Update` message, but you could include several
    messages in a single request.
  prefs: []
  type: TYPE_NORMAL
- en: 'You get the following output when running this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'What you see on the terminal screen are the `SetResponse` messages, containing
    the `path`, `response`, and `timestamp` values of the operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you connect to the `ceos` device now, you will see the following in its
    running configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Configuring network devices is one of those repetitive tasks that most network
    engineers spend a good amount of time on, so automating this process has the potential
    to have a good return on investment.
  prefs: []
  type: TYPE_NORMAL
- en: The years of work of the OpenConfig working group, which released the official
    gNMI package (`openconfig/gnmi`), set the path for the emergence of other open
    source packages and libraries such as gNMIc (`karimra/gnmic`) and pyGNMI (`akarneliuk/pygnmi`),
    creating a community around these vendor-neutral gRPC services to drive consistent
    automation practices in our networks.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will cover another OpenConfig gRPC service that
    enhances your network visibility capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Streaming telemetry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditionally, network engineers have relied on the **Simple Network Management
    Protocol** (**SNMP**) to gather state information from network devices. Devices
    encode this information in a binary format using the **Abstract Syntax Notation
    One** (**ASN.1**) and send it to a receiver, typically a collector or a **Network
    Management System** (**NMS**). The latter would use one of the **Management Information
    Bases** (**MIBs**) to decode the received information and store it locally for
    further processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'This has been the way we’ve done network monitoring for decades, but this approach
    has room for improvement:'
  prefs: []
  type: TYPE_NORMAL
- en: The limited number of vendor-neutral data models means that even the basic things
    require unique MIBs that you may need to update every time you do a major network
    OS upgrade.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MIBs use a notation defined by a subset of ASN.1, which isn’t the best way to
    structure values. It has no concept of lists or key-value pairs. Instead, you
    must implement these with indexed values and extra lookup tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SNMP uses UDP as its transport protocol to avoid putting an extra burden on
    the collector. This means that you could miss some events completely, leaving
    blind spots in the stream of telemetry data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since SNMP primarily relies on polling, we can only see aggregated values and
    may miss important state transitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SNMP does not generally timestamp when a value changes. Collectors can only
    infer timing based on the time of collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'gNMI offers a new approach to network monitoring via a dedicated `Subscribe`
    RPC. At the very least, it offers the same capabilities as SNMP but takes it further,
    making the protocol more feature-rich and versatile:'
  prefs: []
  type: TYPE_NORMAL
- en: One of the greatest improvements is telemetry streaming. Now, you can continuously
    receive any value of the operational YANG tree from a network device, which gives
    you better visibility into all state transitions along with their timestamps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have a choice to receive telemetry data only when there is a change as opposed
    to a periodic transmission.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thanks to the underlying gRPC transport, gNMI supports both dial-in and dial-out
    connection methods and delivers messages using a reliable HTTP/2 protocol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenConfig defines vendor-neutral YANG models to describe the operational state
    of a network device, which enables clients to parse and process the received data
    from different vendors in a standard pipeline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Even with streaming telemetry, you are not necessarily getting an update for
    every counter increment. Network devices have local processes that periodically
    poll internal data stores to get the latest metrics or stats, such as interface
    packet counters, which they feed to their gNMI process. Hence, how real-time the
    data you receive is depends not only on how often you get streaming messages but
    also on the internal polling cadence. Still, you will probably see the most relevant
    system events, such as BGP state transitions, which you would otherwise miss with
    SNMP.
  prefs: []
  type: TYPE_NORMAL
- en: These features are just a subset of the gNMI capabilities. The gNMI specification
    (see *Further reading*) can serve as a good reference for all gNMI protocol features.
    Next, we examine the gNMI protobuf message for the telemetry service to help you
    understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Subscribe RPC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'gNMI defines a single RPC to subscribe to a telemetry stream. Network devices
    receive one or more `SubscribeRequest` messages and respond with a stream of `SubscribeResponse`
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'gNMI clients have different options to control their telemetry subscriptions.
    The following figure shows the composition of the `SubscribeRequest` message,
    highlighting some of these options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – gNMI subscribe protobuf messages](img/B16971_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – gNMI subscribe protobuf messages
  prefs: []
  type: TYPE_NORMAL
- en: 'The most basic way to control the telemetry subscription is by specifying `Path`
    and `SubscriptionMode`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Path**: References the part of the YANG tree you want to monitor. You can
    subscribe to anything, from the entire device state to just a single leaf value.
    It follows the gNMI path convention (see *Further reading*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SubscriptionMode**: Determines whether to send the telemetry on-change or
    periodically:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In return, a network device sends you a stream of response messages with the
    following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**TypedValue**: The most critical field, containing the actual telemetry value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: The full gNMI path of the value, which identifies the unique YANG
    leaf node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**timestamp**: To help you arrange and process received data in the right order
    or find out when a value last changed for those that do not change frequently:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are just scratching the surface of the `Subscribe` RPC. You can check the
    `gnmi.proto` file to see the complete set of protobuf messages and read the telemetry
    section of the gNMI specification (see *Further reading*) to get a better idea
    of the capabilities and features offered by the protocol. Here are some features
    you can learn about that we don’t cover in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: gNMI lets you poll or take an instant one-off (`ONCE`) snapshot of telemetry
    values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some network devices can send several `Update` messages bundled in a single
    `SubscribeResponse`. This comes at the expense of reduced timestamp accuracy,
    since there’s only a single timestamp for all transported values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are not interested in seeing every single value, you can let a network
    device aggregate those values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For values that different YANG models define, you can specify the definition
    you prefer to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: As with OpenConfig YANG models, the exact set of implemented features varies
    from vendor to vendor.
  prefs: []
  type: TYPE_NORMAL
- en: Streaming telemetry processing pipelines with gNMI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To receive or collect the data from a gNMI-compliant network device, you could
    use the Go gNMI client implementation from the official gNMI repository (see *Further
    reading*). Another alternative is gNMIc (see *Further reading*), which builds
    on top of the official gNMI client and provides more capabilities, such as data
    transformation and wide support of northbound interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: gNMIc can serve as a link between a network device and a **T****ime-Series Database**
    (**TSDB**) or a message queue, as it can transform the received telemetry data
    into a format popular open source projects, such as Prometheus, InfluxDB, NATS,
    and Kafka, can understand. You can run gNMIc as a command-line tool to interact
    with network devices or as a daemon, subscribing to telemetry data and publishing
    it into a message queue or a database.
  prefs: []
  type: TYPE_NORMAL
- en: Event-manager sample program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s examine one example of a telemetry processing pipeline via an implementation
    of a primitive event-manager application. The goal of this program is to react
    to an increased packet rate by temporarily enabling a backup interface to redistribute
    incoming traffic. The following diagram depicts the high-level architecture of
    the telemetry processing pipeline and includes the following main components:'
  prefs: []
  type: TYPE_NORMAL
- en: A gNMIC process running as a daemon, collecting and processing network telemetry
    data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A TSDB (Prometheus) storing the collected telemetry data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AlertManager (see *Further reading*) processing alerts received from Prometheus
    and triggering external events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A Go program that implements the event-manager business logic:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.3 – The event-manager application](img/B16971_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – The event-manager application
  prefs: []
  type: TYPE_NORMAL
- en: 'You can spin up these components with `make gnmic-start` from the root of this
    book’s GitHub repository (see *Further reading*). This command starts the gNMIc
    daemon and brings up Prometheus, Grafana, and AlertManager using `docker-compose`.
    These applications now run alongside our test lab topology and interact with it
    over standard network interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – The event-manager topology](img/B16971_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – The event-manager topology
  prefs: []
  type: TYPE_NORMAL
- en: 'We configured these applications using a series of files located in the `topo`-`full/workdir/`
    (see *Further reading*) directory of this book’s GitHub repository (see *Further
    reading*). These files get mounted into their respective containers, as we define
    in the configuration files of either Containerlab (`topo.yml` – see *Further reading*)
    or Docker Compose (`docker-compose.yml` – see *Further reading*). Here’s a brief
    description of the role these applications play in our setup:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The gNMIc daemon process runs in `Host-3` of the test topology. It subscribes
    to telemetry data from the `cvx` device and exposes it as Prometheus-style metrics.
    We manage these settings in the `gnmic.yaml` file that looks like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can find the Prometheus configuration values in the `prometheus.yml` file.
    We configure it to scrape the gNMIc endpoint every 2 seconds and store the collected
    data in its TSDB:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The same configuration file includes a reference to the alert definition file,
    called `alert.rules`, and the connection details of the AlertManager:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside of the `alert.rules` file, we define a single alert we call `HighLinkUtilization`.
    Every 10 seconds, Prometheus checks whether the incoming packet rate has exceeded
    a predefined threshold of 50 packets per 30-second interval, in which case it
    fires an alert and sends it to the AlertManager:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'AlertManager has its own configuration file, called `alertmanager.yml`, that
    controls how to aggregate and route incoming alerts from Prometheus. In our case,
    we have a single alert type, so we only need one route. We decrease the default
    aggregation timers to enable faster reaction time and specify the webhook URL
    where to send these alerts:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: event-manager parses the alert and toggles a backup interface to re-balance
    the traffic coming into the `cvx` device. Its behavior is fairly static, so we
    don’t need a configuration file for it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The event-manager program implements a standard web server that listens to
    incoming requests and dispatches them to a handler function. Here, we decode the
    received Prometheus alert and invoke the `toggleBackup` function based on its
    status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two *uplinks* between the `cvx` and `ceos` devices, and we only use
    one of them by default. The backup uplink does BGP ASN prepending and only receives
    traffic when we announce more specific or disaggregated prefixes. The `toggleBackup`
    function does this by toggling a permit/deny statement on an IP prefix list (on
    `cvx`), thereby enabling or disabling the BGP disaggregation behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The final `sendBytes` function applies the constructed configuration using the
    three-stage commit process we discussed in [*Chapter 6*](B16971_06.xhtml#_idTextAnchor144),
    *Configuration Management*.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing the data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can connect to the local instance of Grafana running at `:3000` using `admin`
    as the username/password to test the complete telemetry-driven pipeline in action.
    This Grafana instance comes up pre-integrated with Prometheus as its data source,
    and it includes a pre-built `event-manager` dashboard that plots the incoming
    packet rate for both `cvx` links to `ceos`.
  prefs: []
  type: TYPE_NORMAL
- en: Run `make traffic-start` from the root of this book’s GitHub repository (see
    *Further reading*) to generate traffic in the lab topology. All traffic should
    initially flow over the primary connection between `cvx` and `ceos` (`swp1`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to start the event-manager application so that we can load-balance
    traffic across both connections. To do this, run the event-manager Go application
    inside the `host-2` container. This translates to the command that we execute
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Open a new terminal window or tab and run `make traffic-start` again, but increase
    the traffic generation period from the default `60s` using the `DURATION` variable.
    For example, the following command would generate traffic for 2 minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'This can help you see the longer-term effect of traffic re-balancing. Logs
    should show that the traffic rate has triggered an alert and the application implemented
    corrective actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'All three of the tests we performed should get you a similar-looking graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Event-manager visualization](img/B16971_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Event-manager visualization
  prefs: []
  type: TYPE_NORMAL
- en: Streaming telemetry is a powerful capability that you can adapt to a wide variety
    of business use cases. However, most of these use cases are specific to the operating
    network environment, so it’s hard to come up with a set of *killer applications*
    that would apply to every network. Hence, it’s important to know how to implement
    the required business logic in code, which is what we have tried to show you in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we cover another OpenConfig gRPC service you can use
    to automate operational tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Network operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding sections, we explored how the OpenConfig management interface
    approaches two common network automation use cases: configuration management and
    operational state collection. These two tasks alone can get you a long way in
    your network automation journey, but there is a set of common operational tasks
    that don’t fall into either of these categories.'
  prefs: []
  type: TYPE_NORMAL
- en: To automate all aspects of network operations, we need to perform tasks such
    as network device reloads, software life cycle management, and counter and adjacency
    resets. You normally execute these activities as part of interactive CLI workflows,
    with prompts and warnings that assume a human operator is involved in the process.
    This makes the automation of these tasks a major undertaking, as we have to resort
    to screen-scraping, which increases the already high risk of these tasks.
  prefs: []
  type: TYPE_NORMAL
- en: To address these challenges, OpenConfig proposed a new gRPC API, designed to
    abstract away the interactive commands and surface these network operations capabilities
    in a standard, vendor-neutral way.
  prefs: []
  type: TYPE_NORMAL
- en: gNOI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'gNOI defines a list of gRPC services that address a wide range of network operations
    use cases. Each service represents one operational process with a set of actions,
    and the following table includes a few examples to give you an idea of the challenges
    gNOI attempts to solve:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Service** | **Description** | **RPC examples** |'
  prefs: []
  type: TYPE_TB
- en: '| OS | NOS package management | Install, Activate, and Verify |'
  prefs: []
  type: TYPE_TB
- en: '| File | File operations | Get, Transfer, Put, and Remove |'
  prefs: []
  type: TYPE_TB
- en: '| L2 | L2 protocols operations | ClearNeighborDiscovery and ClearLLDPInterface
    |'
  prefs: []
  type: TYPE_TB
- en: '| Cert | Certificate management | Rotate, Install, GenerateCSR, and RevokeCertificates
    |'
  prefs: []
  type: TYPE_TB
- en: '| System | System operations | Ping, Traceroute, Reboot, and Time |'
  prefs: []
  type: TYPE_TB
- en: Table 9.1 – gNOI use case examples
  prefs: []
  type: TYPE_NORMAL
- en: Some RPCs are a one-shot with immediate response, some stream responses synchronously
    until complete or canceled, and some work asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'The gNOI GitHub repository (see *Further reading*) protobuf files have the
    most recent list of actions for each service. At the time of writing, this is
    the top-level definition of the `system.proto` file (see *Further reading*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: We don’t cover all gNOI RPCs in this book. Instead, we focus on just one and
    include an example program built around it.
  prefs: []
  type: TYPE_NORMAL
- en: Traceroute RPC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most, if not all, network engineers are familiar with the `traceroute` command.
    This is a common way to explore the forwarding path between a pair of network
    endpoints. When you run `traceroute` from a network device’s interactive shell,
    the terminal prints the result on your screen. With gNOI, `traceroute` is an action
    we request via an RPC with a `TracerouteRequest` message in the payload, and the
    result is a stream (one or many) of `TracerouteResponse` messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the `traceroute` command-line arguments and flags, the request message
    lets you specify options such as source address, the maximum number of hops, and
    whether to perform reverse DNS lookups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Each response message includes the results of a single measurement cycle, including
    the hop count, the round-trip time, and the responding address extracted from
    a probe reply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s see an example of how to use the gNOI interface with Go.
  prefs: []
  type: TYPE_NORMAL
- en: Path verifier application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the streaming telemetry section of this chapter, we explored the implementation
    of an event-manager application that enables or disables a backup link as the
    traffic through the primary interface crosses a pre-defined threshold. We used
    Grafana to plot the traffic rate for both interfaces to confirm that the application
    works as intended.
  prefs: []
  type: TYPE_NORMAL
- en: In real-world automation use cases involving complex workflows, relying on visual
    clues is not always the right approach. Ideally, we need a programmatic way to
    verify that the backup link is actually working. We use the gNOI `Traceroute`
    RPC to check this in the next code example. The goal is to explore diverse network
    paths and confirm that we are forwarding some traffic flows over the backup interface.
    You can find the code example for this section in the `ch09/gnoi-trace` directory
    of this book’s GitHub repository (see *Further reading*).
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by setting up a gRPC session to the `ceos` virtual network device
    and creating a new API client for the gNOI `System` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Next, we create a `sync.WaitGroup` to coordinate all goroutines running traceroutes
    to different destinations. These goroutines send the collected results back to
    the `main` goroutine over the `traceCh` channel. For each traceroute destination
    encoded as `string`, the traceroute result includes a list of responded IP addresses
    per network hop.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it easier to compare lists of IP addresses in the following steps,
    we store them as a set using the `deckarep/golang-set` (`mapset`) third-party
    package, because Go doesn’t implement sets natively in the standard library. We
    encode the hop count implicitly as the index of the `[]``mapset.Set` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Each goroutine runs a single traceroute, and we only specify the source and
    destination fields of the `TracerouteRequest` message, leaving the rest options
    as default. As we receive responses, we store the results in the `route` slice.
    When the traceroute stops, which is when the error type is `io.EOF`, we send the
    accumulated response over the `traceCh` channel and call `wg.Done`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Since network devices have default control plane security settings that may
    restrict them from processing every incoming `goto` statements in the code to
    retry a traceroute in case we don’t get any information for any one hop. `START`
    and `FINISH` are the two labels we used to implement this retry logic, with the
    latter serving as a fall-through case when we don’t get a result after several
    attempts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have completed all traceroute requests, we can process and analyze
    the results. To simplify the code logic, we first transform the data to store
    a map between a hop count and a set of IP addresses per traceroute destination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can traverse over each hop and check whether there is a discrepancy
    between a set of responding IP addresses for different traceroute destinations,
    which would mean that the packets went over different paths. If we detect this,
    we print it on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run this program from the `ch09/gnoi-trace` folder. Make sure `lab-full`
    is up and running first. You should see output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Generate traffic with `make traffic-start` and run this program again. In another
    tab, run simultaneously the event-manager application from the `clab-netgo-host-2`
    host to activate the backup link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The last output shows that the path that `203.0.113.252/32` and `203.0.113.251/32`
    follow is different from the path that `203.0.113.253/32` follows (primary link).
    This is because the event-manager disaggregated `.252` and `.251` from the main
    `203.0.113.250/30` prefix. Now, we know that the backup link is working as expected,
    as it is carrying traffic for these two IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, networking vendors were not incentivized to create vendor-neutral
    APIs and data models, as it doesn’t allow them to differentiate themselves from
    the competition. And while standards bodies such as the Internet Engineering Task
    Force (IETF) produce standards for the networking industry, they can’t always
    influence what vendors actually implement. Also, some vendors might still perceive
    technological lock-ins as an effective way to keep their existing customer base.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, the OpenConfig community of network operators has more leverage
    to influence networking vendors to adopt vendor-independent data models and APIs.
    OpenConfig adoption is still relatively low, in both model and feature coverage,
    but, as long as the OC participants continue to push for more, the coverage will
    increase, which, in turn, will drive the adoption in the wider networking community.
  prefs: []
  type: TYPE_NORMAL
- en: Even today, OpenConfig provides a vendor-neutral way of doing a lot of common
    networking tasks, including configuration management, monitoring, and operations.
    In this chapter, we’ve shown the two most popular interfaces, gNMI and gNOI, ignoring
    the less common gRIBI, which is outside of the scope of this book. We hope this
    chapter provides enough examples of tools and workflows that you can use with
    Go to consume and interact with OpenConfig-compliant devices.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, by introducing streaming telemetry, we have started exploring
    the world of network monitoring, a critical task for a business. The ability to
    observe network-wide state and collect and process data plane information are
    all important in determining the health of your network. In the next chapter,
    we will examine a few concrete examples of network monitoring tasks and use cases
    and learn how Go can help us automate them.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network operators: [https://www.openconfig.net/about/participants/](https://www.openconfig.net/about/participants/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Manipulating forwarding entries: https://github.com/openconfig/gribi/blob/master/doc/motivation.md#grpc-service-for-rib-injection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'gNMI collector: https://github.com/openconfig/gnmi/tree/master/cmd/gnmi_collector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'gNMI CLI utility: [https://github.com/openconfig/gnmi/tree/master/cmd/gnmi_cli](https://github.com/openconfig/gnmi/tree/master/cmd/gnmi_cli
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'gNMI Test framework: [https://github.com/openconfig/gnmitest](https://github.com/openconfig/gnmitest
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'gRPC tunnel: [https://github.com/openconfig/grpctunnel](https://github.com/openconfig/grpctunnel
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IS-IS LSDB parsing: [https://github.com/openconfig/lsdbparse](https://github.com/openconfig/lsdbparse
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ygot: [https://github.com/openconfig/ygot](https://github.com/openconfig/ygot
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'gNxI Tools: https://github.com/google/gnxi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Book’s GitHub repository: [https://github.com/PacktPublishing/Network-Automation-with-Go](https://github.com/PacktPublishing/Network-Automation-with-Go
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'gNMI specification: [https://github.com/openconfig/reference/blob/master/rpc/gnmi/gnmi-specification.md](https://github.com/openconfig/reference/blob/master/rpc/gnmi/gnmi-specification.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'gNMIc docs: https://gnmic.kmrd.dev/user_guide/golang_package/intro/#set-request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'gNMI path convention: [https://github.com/openconfig/reference/blob/master/rpc/gnmi/gnmi-path-conventions.md](https://github.com/openconfig/reference/blob/master/rpc/gnmi/gnmi-path-conventions.md
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'gNMI repository: [https://github.com/openconfig/gnmi](https://github.com/openconfig/gnmi
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'gNMIc: [https://gnmic.kmrd.dev/](https://gnmic.kmrd.dev/ )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AlertManager: [https://prometheus.io/docs/alerting/latest/alertmanager/](https://prometheus.io/docs/alerting/latest/alertmanager/
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`full/workdir/`: [https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/topo-full/workdir](https://github.com/PacktPublishing/Network-Automation-with-Go/tree/main/topo-full/workdir
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`topo.yml`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/topo-full/topo.yml](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/topo-full/topo.yml
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-compose.yml`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch09/docker-compose.yml](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch09/docker-compose.yml
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'gNOI GitHub repository: [https://github.com/openconfig/gnoi](https://github.com/openconfig/gnoi
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`system.proto` file: [https://github.com/openconfig/gnoi/blob/master/system/system.proto](https://github.com/openconfig/gnoi/blob/master/system/system.proto)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
