<html><head></head><body>
<div id="_idContainer089">
<h1 class="chapter-number" id="_idParaDest-226"><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-227"><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.2.1">Network Monitoring</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Despite the popularity of configuration management, we actually spend more time monitoring networks than configuring them. </span><span class="koboSpan" id="kobo.3.2">As networks become more and more complex, with new layers of encapsulation and IP address translations, our ability to understand whether a network functions correctly to let us meet customer </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">service-level agreements</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">SLAs</span></strong><span class="koboSpan" id="kobo.7.1">) is becoming increasingly difficult. </span></p>
<p><span class="koboSpan" id="kobo.8.1">Engineers working in the cloud infrastructure space have come up with the term </span><em class="italic"><span class="koboSpan" id="kobo.9.1">observability</span></em><span class="koboSpan" id="kobo.10.1">, referring to the ability to reason about the internal state of a system by observing its external outputs. </span><span class="koboSpan" id="kobo.10.2">Translated into networking terms, this may include passive monitoring through logs and state telemetry collection or active monitoring using distributed probing, data processing, and visualization. </span></p>
<p><span class="koboSpan" id="kobo.11.1">The ultimate goal of all this is to reduce the </span><strong class="bold"><span class="koboSpan" id="kobo.12.1">mean time to repair</span></strong><span class="koboSpan" id="kobo.13.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.14.1">MTTR</span></strong><span class="koboSpan" id="kobo.15.1">), adhere to customer SLAs, and shift to proactive problem resolution. </span><span class="koboSpan" id="kobo.15.2">Go is a very popular language of choice for these kinds of tasks, and in this chapter we will examine a few of the tools, packages, and platforms that can help you with network monitoring. </span><span class="koboSpan" id="kobo.15.3">Here are the highlights of </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.17.1">We will explore traffic monitoring by looking at how to capture and parse network packets </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">with Go.</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Next, we will look at how to process and aggregate data plane telemetry to get meaningful insights into the current </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">network behavior.</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">We show how you can use active probing to measure network performance, and how to produce, collect, and visualize </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">performance metrics.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.23.1">We will deliberately avoid talking about YANG-based telemetry, as we covered this already in </span><a href="B16971_08.xhtml#_idTextAnchor182"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.24.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.25.1">, </span><em class="italic"><span class="koboSpan" id="kobo.26.1">Network APIs</span></em><span class="koboSpan" id="kobo.27.1">, and </span><a href="B16971_09.xhtml#_idTextAnchor209"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.28.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.29.1">, </span><em class="italic"><span class="koboSpan" id="kobo.30.1">OpenConfig</span></em><span class="koboSpan" id="kobo.31.1">. </span></p>
<p><span class="koboSpan" id="kobo.32.1">Another area that we haven’t touched on so far and that we want to discuss briefly in this chapter is the developer experience. </span><span class="koboSpan" id="kobo.32.2">As we write more code, maintaining existing software becomes an important part of our day-to-day operations. </span><span class="koboSpan" id="kobo.32.3">We introduce one tool per section of this chapter, acknowledging that we are just scratching the surface and that this topic could be the subject of an entire book. </span><span class="koboSpan" id="kobo.32.4">In the end, we don’t strive to give a comprehensive overview of all tools there are out there but just want to give you an idea of what developing Go code in production may </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">feel like.</span></span></p>
<h1 id="_idParaDest-228"><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.34.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.35.1">You can find the code examples for this chapter in the book’s GitHub repository (see the </span><em class="italic"><span class="koboSpan" id="kobo.36.1">Further reading</span></em><span class="koboSpan" id="kobo.37.1"> section), under the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">ch10</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.39.1"> folder.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.40.1">Important Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.41.1">We recommend you execute the Go programs in this chapter in a virtual lab environment. </span><span class="koboSpan" id="kobo.41.2">Refer to the </span><em class="italic"><span class="koboSpan" id="kobo.42.1">Appendix</span></em><span class="koboSpan" id="kobo.43.1"> for prerequisites and instructions on how to build the fully configured </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">network topology.</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">The first example we will discuss in the following section explores packet capturing and parsing capabilities </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">in Go.</span></span></p>
<h1 id="_idParaDest-229"><a id="_idTextAnchor228"/><span class="koboSpan" id="kobo.47.1">Data plane telemetry processing</span></h1>
<p><span class="koboSpan" id="kobo.48.1">Network </span><a id="_idIndexMarker899"/><span class="koboSpan" id="kobo.49.1">activities such as capacity planning, billing, or </span><strong class="bold"><span class="koboSpan" id="kobo.50.1">distributed denial-of-service</span></strong><span class="koboSpan" id="kobo.51.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.52.1">DDoS</span></strong><span class="koboSpan" id="kobo.53.1">) attack </span><a id="_idIndexMarker900"/><span class="koboSpan" id="kobo.54.1">monitoring require insights into the traffic flowing through a network. </span><span class="koboSpan" id="kobo.54.2">One way we can offer such visibility is by deploying a packet sampling technology. </span><span class="koboSpan" id="kobo.54.3">The premise is that at a high-enough rate, it’s possible to capture only a randomly sampled subset of packets to build a good understanding of the overall network </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">traffic patterns.</span></span></p>
<p><span class="koboSpan" id="kobo.56.1">While it’s the hardware that samples the packets, it’s the software that aggregates them into flows and exports them. </span><span class="koboSpan" id="kobo.56.2">NetFlow, sFlow, and </span><strong class="bold"><span class="koboSpan" id="kobo.57.1">IP Flow Information Export</span></strong><span class="koboSpan" id="kobo.58.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.59.1">IPFIX</span></strong><span class="koboSpan" id="kobo.60.1">) are </span><a id="_idIndexMarker901"/><span class="koboSpan" id="kobo.61.1">the three main protocols we use for this, and they define the structure of the payload and what metadata to include with each </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">sampled packet.</span></span></p>
<p><span class="koboSpan" id="kobo.63.1">One of the first steps in any telemetry processing pipeline is information ingestion. </span><span class="koboSpan" id="kobo.63.2">In our context, this means receiving and parsing data plane telemetry packets to extract and process flow records. </span><span class="koboSpan" id="kobo.63.3">In this section, we will look at how you can capture and process packets with the help of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">google/gopacket</span></strong><span class="koboSpan" id="kobo.65.1"> package (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.66.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">).</span></span></p>
<h2 id="_idParaDest-230"><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.68.1">Packet capturing</span></h2>
<p><span class="koboSpan" id="kobo.69.1">In </span><a href="B16971_04.xhtml#_idTextAnchor109"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.70.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.71.1">, </span><em class="italic"><span class="koboSpan" id="kobo.72.1">Networking (TCP/IP) with Go</span></em><span class="koboSpan" id="kobo.73.1">, we discussed how to build a UDP ping application </span><a id="_idIndexMarker902"/><span class="koboSpan" id="kobo.74.1">using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">net</span></strong><span class="koboSpan" id="kobo.76.1"> package from Go’s standard library. </span><span class="koboSpan" id="kobo.76.2">And while we should probably take a similar approach when building an sFlow collector, we will do something different for the </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">next example.</span></span></p>
<p><span class="koboSpan" id="kobo.78.1">Instead of building a data plane telemetry collector, we designed our application to tap into an existing flow of telemetry packets, assuming the network devices in the topology are sending them to an existing collector somewhere in the network. </span><span class="koboSpan" id="kobo.78.2">This allows you to avoid changing the existing telemetry service configuration while still being able to capture and process telemetry traffic. </span><span class="koboSpan" id="kobo.78.3">You can use a program like this when you want a transparent tool that can run directly on a network device, on demand, and for a short period </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">of time.</span></span></p>
<p><span class="koboSpan" id="kobo.80.1">In the test lab topology, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">cvx</span></strong><span class="koboSpan" id="kobo.82.1"> node runs an agent that exports sampled metrics using the sFlow protocol. </span><span class="koboSpan" id="kobo.82.2">The sFlow traffic flows toward </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">host-2</span></strong><span class="koboSpan" id="kobo.84.1">, where it gets intercepted by the example application using </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">a tap:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer081">
<span class="koboSpan" id="kobo.86.1"><img alt="Figure 10.1 – sFlow application" src="image/B16971_10_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.87.1">Figure 10.1 – sFlow application</span></p>
<p><span class="koboSpan" id="kobo.88.1">To show </span><a id="_idIndexMarker903"/><span class="koboSpan" id="kobo.89.1">you the packet-capturing capabilities of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">google/gopacket</span></strong><span class="koboSpan" id="kobo.91.1"> package, we intercept all sFlow packets using </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">pcapgo</span></strong><span class="koboSpan" id="kobo.93.1"> – a native Go implementation of the traffic-capturing API in Linux. </span><span class="koboSpan" id="kobo.93.2">Although it’s less feature-rich than its counterpart </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">pcap</span></strong><span class="koboSpan" id="kobo.95.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">pfring</span></strong><span class="koboSpan" id="kobo.97.1"> packages, the benefit of </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">pcapgo</span></strong><span class="koboSpan" id="kobo.99.1"> is that it doesn’t rely on any external C libraries and can work natively on any </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">Linux distribution.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">In the first part of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">packet-capture</span></strong><span class="koboSpan" id="kobo.103.1"> program, which you can find in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">ch10/packet-capture</span></strong><span class="koboSpan" id="kobo.105.1"> folder of this book’s GitHub repository, we set up a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">af_packet</span></strong><span class="koboSpan" id="kobo.107.1"> socket handler with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">pcapgo.NewEthernetHandle</span></strong><span class="koboSpan" id="kobo.109.1"> function, passing it the name of the interface </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">to monitor:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.111.1">import </span></span><span class="koboSpan" id="kobo.112.1">(
     </span><span class="Code_Red"><span class="koboSpan" id="kobo.113.1">"github.com/google/gopacket/pcapgo"</span></span><span class="koboSpan" id="kobo.114.1">
)
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.115.1">var </span></span><span class="koboSpan" id="kobo.116.1">(
     intf = flag.String(</span><span class="Code_Red"><span class="koboSpan" id="kobo.117.1">"intf"</span></span><span class="koboSpan" id="kobo.118.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.119.1">"eth0"</span></span><span class="koboSpan" id="kobo.120.1">, </span><span class="Code_Red"><span class="koboSpan" id="kobo.121.1">"interface"</span></span><span class="koboSpan" id="kobo.122.1">)
)
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.123.1">func </span></span><span class="koboSpan" id="kobo.124.1">main() {
     handle, err := pcapgo.NewEthernetHandle(*intf)
     </span><span class="Code_Brown"><span class="koboSpan" id="kobo.125.1">/* ... </span><span class="koboSpan" id="kobo.125.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.125.3">*/</span></span><span class="koboSpan" id="kobo.126.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.127.1">At this point, </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">handle</span></strong><span class="koboSpan" id="kobo.129.1"> gives us</span><a id="_idIndexMarker904"/><span class="koboSpan" id="kobo.130.1"> access to all packets on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">eth0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.132.1"> interface.</span></span></p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.133.1">Packet filtering</span></h2>
<p><span class="koboSpan" id="kobo.134.1">While we</span><a id="_idIndexMarker905"/><span class="koboSpan" id="kobo.135.1"> could just capture all packets through the interface, for the sake of experimenting, we will include an example of how to filter the traffic we capture </span><a id="_idIndexMarker906"/><span class="koboSpan" id="kobo.136.1">with a </span><strong class="bold"><span class="koboSpan" id="kobo.137.1">Berkeley Packet Filter</span></strong><span class="koboSpan" id="kobo.138.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.139.1">BPF</span></strong><span class="koboSpan" id="kobo.140.1">) program in Go. </span></p>
<p><span class="koboSpan" id="kobo.141.1">First, we generate a compiled packet-matching code in a human-readable format, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">-d</span></strong><span class="koboSpan" id="kobo.143.1"> option of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">tcpdump</span></strong><span class="koboSpan" id="kobo.145.1"> command to filter IP and </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">UDP packets:</span></span></p>
<pre class="source-code"><span class="Code_ligh-Blue"><span class="koboSpan" id="kobo.147.1">$ sudo </span></span><span class="koboSpan" id="kobo.148.1">tcpdump </span><span class="Code_Blue"><span class="koboSpan" id="kobo.149.1">-p -ni </span></span><span class="koboSpan" id="kobo.150.1">eth0 </span><span class="Code_Blue"><span class="koboSpan" id="kobo.151.1">-d</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.152.1">"ip and udp"</span></span><span class="koboSpan" id="kobo.153.1">
(000) ldh      [12]
(001) jeq      </span><span class="Code_Brown"><span class="koboSpan" id="kobo.154.1">#0x800</span></span><span class="koboSpan" id="kobo.155.1">           </span><span class="Code_Brown"><span class="koboSpan" id="kobo.156.1">jt 2    jf 5</span></span><span class="koboSpan" id="kobo.157.1">
(002) ldb      [23]
(003) jeq      </span><span class="Code_Brown"><span class="koboSpan" id="kobo.158.1">#0x11</span></span><span class="koboSpan" id="kobo.159.1">            </span><span class="Code_Brown"><span class="koboSpan" id="kobo.160.1">jt 4    jf 5</span></span><span class="koboSpan" id="kobo.161.1">
(004) ret      </span><span class="Code_Brown"><span class="koboSpan" id="kobo.162.1">#262144</span></span><span class="koboSpan" id="kobo.163.1">
(005) ret      </span><span class="Code_Brown"><span class="koboSpan" id="kobo.164.1">#0</span></span></pre>
<p><span class="koboSpan" id="kobo.165.1">Then, we convert each of the preceding instructions into a corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">bpf.Instruction</span></strong><span class="koboSpan" id="kobo.167.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">golang.org/x/net/bpf</span></strong><span class="koboSpan" id="kobo.169.1"> package. </span><span class="koboSpan" id="kobo.169.2">We assemble these </span><a id="_idIndexMarker907"/><span class="koboSpan" id="kobo.170.1">instructions into a set of </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">[]bpf.RawInstruction</span></strong><span class="koboSpan" id="kobo.172.1"> that are ready to load into a BPF </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">virtual machine:</span></span></p>
<pre class="source-code"><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.174.1">import</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.175.1"> (</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.176.1">  </span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.177.1">"golang.org/x/net/bpf"</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.178.1">)</span></span>
<span lang="en-US" xml:lang="en-US"> </span>
<span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.179.1">func</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.180.1"> main() {</span></span>
<span class="Code_Brown" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.181.1">/* ... </span><span class="koboSpan" id="kobo.181.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.181.3">*/</span></span>
<span lang="en-US" xml:lang="en-US"> </span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.182.1">  rawInstructions, err := bpf.Assemble([]bpf.Instruction{</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.183.1">    </span></span><span class="Code_Brown" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.184.1">// Load "EtherType" field from the ethernet header.</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.185.1">    bpf.LoadAbsolute{Off: </span></span><span class="Code_Green" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.186.1">12</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.187.1">, Size: </span></span><span class="Code_Green" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.188.1">2</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.189.1">},</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.190.1">    </span></span><span class="Code_Brown" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.191.1">// Skip to last instruction if EtherType isn't IPv4.</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.192.1">    bpf.JumpIf{Cond: bpf.JumpNotEqual, Val: </span></span><span class="Code_Green" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.193.1">0x800</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.194.1">,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.195.1">                    SkipTrue: </span></span><span class="Code_Green" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.196.1">3</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.197.1">},</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.198.1">    </span></span><span class="Code_Brown" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.199.1">// Load "Protocol" field from the IPv4 header.</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.200.1">    bpf.LoadAbsolute{Off: </span></span><span class="Code_Green" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.201.1">23</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.202.1">, Size: </span></span><span class="Code_Green" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.203.1">1</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.204.1">},</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.205.1">    </span></span><span class="Code_Brown" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.206.1">// Skip to the last instruction if Protocol is not UDP.</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.207.1">    bpf.JumpIf{Cond: bpf.JumpNotEqual, Val: </span></span><span class="Code_Green" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.208.1">0x11</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.209.1">,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.210.1">                    SkipTrue: </span></span><span class="Code_Green" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.211.1">1</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.212.1">},</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.213.1">    </span></span><span class="Code_Brown" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.214.1">// "send up to 4k of the packet to userspace."</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.215.1">    bpf.RetConstant{Val: </span></span><span class="Code_Green" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.216.1">4096</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.217.1">},</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.218.1">    </span></span><span class="Code_Brown" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.219.1">// Verdict is "ignore packet and return to the stack."</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.220.1">    bpf.RetConstant{Val: </span></span><span class="Code_Green" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.221.1">0</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.222.1">},</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.223.1">  })</span></span>
<span lang="en-US" xml:lang="en-US"> </span>
<span lang="en-US" xml:lang="en-US"> </span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.224.1">  handle.SetBPF(rawInstructions)</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.225.1">  </span></span><span class="Code_Brown" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.226.1">/* ... </span><span class="koboSpan" id="kobo.226.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.226.3">*/</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.227.1">}</span></span></pre>
<p><span class="koboSpan" id="kobo.228.1">We can</span><a id="_idIndexMarker908"/><span class="koboSpan" id="kobo.229.1"> attach the result to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">EthernetHandle</span></strong><span class="koboSpan" id="kobo.231.1"> function we created earlier, to act as a packet filter and reduce the number of packets received by </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.233.1">In summary, we copy all packets that match the </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">0x800</span></strong><span class="koboSpan" id="kobo.235.1"> EtherType and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">0x11</span></strong><span class="koboSpan" id="kobo.237.1"> IP protocol to the user space process, where our Go program runs, while all the other packets, including the ones we match, continue through the network stack. </span><span class="koboSpan" id="kobo.237.2">This makes this program completely transparent to any existing traffic flows, and you can use it without having to change the configuration of the </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">sFlow agent.</span></span></p>
<h2 id="_idParaDest-232"><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.239.1">Packet processing</span></h2>
<p><span class="koboSpan" id="kobo.240.1">All </span><a id="_idIndexMarker909"/><span class="koboSpan" id="kobo.241.1">packets that the kernel sends to the user space become available in the Go application through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">PacketSource</span></strong><span class="koboSpan" id="kobo.243.1"> type, which we build by combining the </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">EthernetHandle</span></strong><span class="koboSpan" id="kobo.245.1"> function we created with an Ethernet </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">packet decoder:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.247.1">func </span></span><span class="koboSpan" id="kobo.248.1">main() {
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.249.1">/* ... </span><span class="koboSpan" id="kobo.249.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.249.3">*/</span></span><span class="koboSpan" id="kobo.250.1">
     packetSource :</span><span class="Code_Red"><span class="koboSpan" id="kobo.251.1">=</span></span><span class="koboSpan" id="kobo.252.1"> gopacket.NewPacketSource(
           handle,
           layers.LayerTypeEthernet,
     )
     </span><span class="Code_Brown"><span class="koboSpan" id="kobo.253.1">/* ... </span><span class="koboSpan" id="kobo.253.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.253.3">*/</span></span><span class="koboSpan" id="kobo.254.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.255.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">PacketSource</span></strong><span class="koboSpan" id="kobo.257.1"> structure sends each received and decoded packet over a Go channel, which</span><a id="_idIndexMarker910"/><span class="koboSpan" id="kobo.258.1"> means we can use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">for</span></strong><span class="koboSpan" id="kobo.260.1"> loop to iterate over them one by one. </span><span class="koboSpan" id="kobo.260.2">Inside this loop, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">gopacket</span></strong><span class="koboSpan" id="kobo.262.1"> to match packet layers and extract information about L2, L3, and L4 networking headers, including protocol-specific details such as the </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">sFlow payload:</span></span></p>
<pre class="source-code"><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.264.1">func</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.265.1"> main() {</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.266.1">  </span></span><span class="Code_Brown" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.267.1">/* ... </span><span class="koboSpan" id="kobo.267.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.267.3">*/</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.268.1">  </span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.269.1">for</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.270.1"> packet :</span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.271.1">=</span></span><span lang="en-US" xml:lang="en-US"> </span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.272.1">range</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.273.1"> packetSource.Packets() {</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.274.1">    sflowLayer :</span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.275.1">=</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.276.1"> packet.Layer(layers.LayerTypeSFlow)</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.277.1">    </span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.278.1">if</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.279.1"> sflowLayer </span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.280.1">!=</span></span><span lang="en-US" xml:lang="en-US"> </span><span class="Code_Blue" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.281.1">nil</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.282.1"> {</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.283.1">      sflow, ok :</span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.284.1">=</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.285.1"> sflowLayer.(*layers.SFlowDatagram)</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.286.1">      </span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.287.1">if</span></span><span lang="en-US" xml:lang="en-US"> </span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.288.1">!</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.289.1">ok {</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.290.1">        </span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.291.1">continue</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.292.1">      }</span></span>
<span lang="en-US" xml:lang="en-US"> </span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.293.1">      </span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.294.1">for</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.295.1"> _, sample :</span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.296.1">=</span></span><span lang="en-US" xml:lang="en-US"> </span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.297.1">range</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.298.1"> sflow.FlowSamples {</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.299.1">        </span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.300.1">for</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.301.1"> _, record :</span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.302.1">=</span></span><span lang="en-US" xml:lang="en-US"> </span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.303.1">range</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.304.1"> sample.GetRecords() {</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.305.1">          p, ok :</span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.306.1">=</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.307.1"> record.(layers.SFlowRawPacketFlowRecord)</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.308.1">          </span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.309.1">if</span></span><span lang="en-US" xml:lang="en-US"> </span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.310.1">!</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.311.1">ok {</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.312.1">            log.Println(</span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.313.1">"failed to decode sflow record"</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.314.1">)</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.315.1">            </span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.316.1">continue</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.317.1">          }</span></span>
<span lang="en-US" xml:lang="en-US"> </span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.318.1">          srcIP, dstIP := p.Header.</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.319.1">            NetworkLayer().</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.320.1">            NetworkFlow().</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.321.1">            Endpoints()</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.322.1">          sPort, dPort := p.Header.</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.323.1">            TransportLayer().</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.324.1">            TransportFlow().</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.325.1">            Endpoints()</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.326.1">          log.Printf(</span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.327.1">"flow record: %s:%s &lt;-&gt; %s:%s\n"</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.328.1">,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.329.1">            srcIP,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.330.1">            sPort,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.331.1">            dstIP,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.332.1">            dPort,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.333.1">          )</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.334.1">        }</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.335.1">      }</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.336.1">     }</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.337.1">  }</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.338.1">}</span></span></pre>
<p><span class="koboSpan" id="kobo.339.1">The </span><a id="_idIndexMarker911"/><span class="koboSpan" id="kobo.340.1">benefit of using </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">gopacket</span></strong><span class="koboSpan" id="kobo.342.1"> specifically for sFlow decoding is that it can parse and create another </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">gopacket.Packet</span></strong><span class="koboSpan" id="kobo.344.1"> based on the sampled </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">packet’s headers.</span></span></p>
<h2 id="_idParaDest-233"><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.346.1">Generating traffic</span></h2>
<p><span class="koboSpan" id="kobo.347.1">To test</span><a id="_idIndexMarker912"/><span class="koboSpan" id="kobo.348.1"> this Go application, we need to generate some traffic in the lab topology, so the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">cvx</span></strong><span class="koboSpan" id="kobo.350.1"> device can generate sFlow records about it. </span><span class="koboSpan" id="kobo.350.2">Here, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">microsoft/ethr</span></strong><span class="koboSpan" id="kobo.352.1"> – a Go-based traffic generator that offers a user experience and features comparable to </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">iperf</span></strong><span class="koboSpan" id="kobo.354.1">. </span><span class="koboSpan" id="kobo.354.2">It can generate and receive a fixed volume of network traffic and measure bandwidth, latency, loss, and jitter. </span><span class="koboSpan" id="kobo.354.3">In our case, we only need it to generate a few low-volume traffic flows over the lab network to trigger the data plane </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">flow sampling.</span></span></p>
<p><span class="koboSpan" id="kobo.356.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">packet-capture</span></strong><span class="koboSpan" id="kobo.358.1"> application taps into the existing sFlow traffic, parses and extracts flow records, and prints that information on the screen. </span><span class="koboSpan" id="kobo.358.2">To test the program, run </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">make capture-start</span></strong><span class="koboSpan" id="kobo.360.1"> from the root of this book’s GitHub repository (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.361.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">):</span></span></p>
<pre class="source-code"><span class="Code_ligh-Blue"><span class="koboSpan" id="kobo.363.1">$ make </span></span><span class="koboSpan" id="kobo.364.1">capture-start
docker exec </span><span class="Code_Blue"><span class="koboSpan" id="kobo.365.1">-d</span></span><span class="koboSpan" id="kobo.366.1"> clab-netgo-cvx systemctl </span><span class="Code_Blue"><span class="koboSpan" id="kobo.367.1">restart </span></span><span class="koboSpan" id="kobo.368.1">hsflowd
docker exec </span><span class="Code_Blue"><span class="koboSpan" id="kobo.369.1">-d</span></span><span class="koboSpan" id="kobo.370.1"> clab-netgo-host-3 ./ethr </span><span class="Code_Blue"><span class="koboSpan" id="kobo.371.1">-s</span></span><span class="koboSpan" id="kobo.372.1">
docker exec </span><span class="Code_Blue"><span class="koboSpan" id="kobo.373.1">-d</span></span><span class="koboSpan" id="kobo.374.1"> clab-netgo-host-1 ./ethr </span><span class="Code_Blue"><span class="koboSpan" id="kobo.375.1">-c</span></span><span class="koboSpan" id="kobo.376.1"> 203.0.113.253 </span><span class="Code_Blue"><span class="koboSpan" id="kobo.377.1">-b</span></span><span class="koboSpan" id="kobo.378.1"> 900K </span><span class="Code_Blue"><span class="koboSpan" id="kobo.379.1">-d</span></span><span class="koboSpan" id="kobo.380.1"> 60s </span><span class="Code_Blue"><span class="koboSpan" id="kobo.381.1">-p</span></span><span class="koboSpan" id="kobo.382.1"> udp </span><span class="Code_Blue"><span class="koboSpan" id="kobo.383.1">-l</span></span><span class="koboSpan" id="kobo.384.1"> 1KB
docker exec </span><span class="Code_Blue"><span class="koboSpan" id="kobo.385.1">-d</span></span><span class="koboSpan" id="kobo.386.1"> clab-netgo-host-1 ./ethr </span><span class="Code_Blue"><span class="koboSpan" id="kobo.387.1">-c</span></span><span class="koboSpan" id="kobo.388.1"> 203.0.113.252 </span><span class="Code_Blue"><span class="koboSpan" id="kobo.389.1">-b</span></span><span class="koboSpan" id="kobo.390.1"> 600K </span><span class="Code_Blue"><span class="koboSpan" id="kobo.391.1">-d</span></span><span class="koboSpan" id="kobo.392.1"> 60s </span><span class="Code_Blue"><span class="koboSpan" id="kobo.393.1">-p</span></span><span class="koboSpan" id="kobo.394.1"> udp </span><span class="Code_Blue"><span class="koboSpan" id="kobo.395.1">-l</span></span><span class="koboSpan" id="kobo.396.1"> 1KB
docker exec </span><span class="Code_Blue"><span class="koboSpan" id="kobo.397.1">-d</span></span><span class="koboSpan" id="kobo.398.1"> clab-netgo-host-1 ./ethr </span><span class="Code_Blue"><span class="koboSpan" id="kobo.399.1">-c</span></span><span class="koboSpan" id="kobo.400.1"> 203.0.113.251 </span><span class="Code_Blue"><span class="koboSpan" id="kobo.401.1">-b</span></span><span class="koboSpan" id="kobo.402.1"> 400K </span><span class="Code_Blue"><span class="koboSpan" id="kobo.403.1">-d</span></span><span class="koboSpan" id="kobo.404.1"> 60s </span><span class="Code_Blue"><span class="koboSpan" id="kobo.405.1">-p</span></span><span class="koboSpan" id="kobo.406.1"> udp </span><span class="Code_Blue"><span class="koboSpan" id="kobo.407.1">-l</span></span><span class="koboSpan" id="kobo.408.1"> 1KB
</span><span class="Code_Blue"><span class="koboSpan" id="kobo.409.1">cd</span></span><span class="koboSpan" id="kobo.410.1"> ch10/packet-capture; go build </span><span class="Code_Blue"><span class="koboSpan" id="kobo.411.1">-o</span></span><span class="koboSpan" id="kobo.412.1"> packet-capture main.go
docker exec </span><span class="Code_Blue"><span class="koboSpan" id="kobo.413.1">-it </span></span><span class="koboSpan" id="kobo.414.1">clab-netgo-host-2 /workdir/packet-capture/packet-capture
</span><span class="Code_Green"><span class="koboSpan" id="kobo.415.1">2022</span></span><span class="koboSpan" id="kobo.416.1">/02/28 </span><span class="Code_Green"><span class="koboSpan" id="kobo.417.1">21</span></span><span class="koboSpan" id="kobo.418.1">:50:25  flow record: </span><span class="Code_Green"><span class="koboSpan" id="kobo.419.1">203</span></span><span class="koboSpan" id="kobo.420.1">.0.113.0:60087 &lt;-&gt; </span><span class="Code_Green"><span class="koboSpan" id="kobo.421.1">203</span></span><span class="koboSpan" id="kobo.422.1">.0.113.252:8888
</span><span class="Code_Green"><span class="koboSpan" id="kobo.423.1">2022</span></span><span class="koboSpan" id="kobo.424.1">/02/28 </span><span class="Code_Green"><span class="koboSpan" id="kobo.425.1">21</span></span><span class="koboSpan" id="kobo.426.1">:50:25  flow record: </span><span class="Code_Green"><span class="koboSpan" id="kobo.427.1">203</span></span><span class="koboSpan" id="kobo.428.1">.0.113.0:60087 &lt;-&gt; 
</span><span class="Code_Green"><span class="koboSpan" id="kobo.429.1">203</span></span><span class="koboSpan" id="kobo.430.1">.0.113.252:8888
</span><span class="Code_Green"><span class="koboSpan" id="kobo.431.1">2022</span></span><span class="koboSpan" id="kobo.432.1">/02/28 </span><span class="Code_Green"><span class="koboSpan" id="kobo.433.1">21</span></span><span class="koboSpan" id="kobo.434.1">:50:27  flow record: </span><span class="Code_Green"><span class="koboSpan" id="kobo.435.1">203</span></span><span class="koboSpan" id="kobo.436.1">.0.113.0:40986 &lt;-&gt; </span><span class="Code_Green"><span class="koboSpan" id="kobo.437.1">203</span></span><span class="koboSpan" id="kobo.438.1">.0.113.252:8888
</span><span class="Code_Green"><span class="koboSpan" id="kobo.439.1">2022</span></span><span class="koboSpan" id="kobo.440.1">/02/28 </span><span class="Code_Green"><span class="koboSpan" id="kobo.441.1">21</span></span><span class="koboSpan" id="kobo.442.1">:50:29  flow record: </span><span class="Code_Green"><span class="koboSpan" id="kobo.443.1">203</span></span><span class="koboSpan" id="kobo.444.1">.0.113.0:60087 &lt;-&gt; </span><span class="Code_Green"><span class="koboSpan" id="kobo.445.1">203</span></span><span class="koboSpan" id="kobo.446.1">.0.113.252:8888
</span><span class="Code_Green"><span class="koboSpan" id="kobo.447.1">2022</span></span><span class="koboSpan" id="kobo.448.1">/02/28 </span><span class="Code_Green"><span class="koboSpan" id="kobo.449.1">21</span></span><span class="koboSpan" id="kobo.450.1">:50:29  flow record: </span><span class="Code_Green"><span class="koboSpan" id="kobo.451.1">203</span></span><span class="koboSpan" id="kobo.452.1">.0.113.0:49138 &lt;-&gt; </span><span class="Code_Green"><span class="koboSpan" id="kobo.453.1">203</span></span><span class="koboSpan" id="kobo.454.1">.0.113.251:8888
</span><span class="Code_Green"><span class="koboSpan" id="kobo.455.1">2022</span></span><span class="koboSpan" id="kobo.456.1">/02/28 </span><span class="Code_Green"><span class="koboSpan" id="kobo.457.1">21</span></span><span class="koboSpan" id="kobo.458.1">:50:30  flow record: </span><span class="Code_Green"><span class="koboSpan" id="kobo.459.1">203</span></span><span class="koboSpan" id="kobo.460.1">.0.113.0:60087 &lt;-&gt; </span><span class="Code_Green"><span class="koboSpan" id="kobo.461.1">203</span></span><span class="koboSpan" id="kobo.462.1">.0.113.252:8888
</span><span class="Code_Green"><span class="koboSpan" id="kobo.463.1">2022</span></span><span class="koboSpan" id="kobo.464.1">/02/28 </span><span class="Code_Green"><span class="koboSpan" id="kobo.465.1">21</span></span><span class="koboSpan" id="kobo.466.1">:50:30  flow record: </span><span class="Code_Green"><span class="koboSpan" id="kobo.467.1">203</span></span><span class="koboSpan" id="kobo.468.1">.0.113.0:49138 &lt;-&gt; </span><span class="Code_Green"><span class="koboSpan" id="kobo.469.1">203</span></span><span class="koboSpan" id="kobo.470.1">.0.113.251:8888</span></pre>
<p><span class="koboSpan" id="kobo.471.1">As promised, before</span><a id="_idIndexMarker913"/><span class="koboSpan" id="kobo.472.1"> we move on to the next section, let’s review the first </span><em class="italic"><span class="koboSpan" id="kobo.473.1">developer experience</span></em><span class="koboSpan" id="kobo.474.1"> tool of </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">the chapter.</span></span></p>
<h1 id="_idParaDest-234"><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.476.1">Debugging Go programs</span></h1>
<p><span class="koboSpan" id="kobo.477.1">Reading </span><a id="_idIndexMarker914"/><span class="koboSpan" id="kobo.478.1">and reasoning about an existing code base is a laborious task, and it gets even harder as programs mature and evolve. </span><span class="koboSpan" id="kobo.478.2">This is why, when learning a new language, it’s very important to have at least a basic understanding of the debugging process. </span><span class="koboSpan" id="kobo.478.3">Debugging allows us to halt the execution of a program at a pre-defined place and step through the code line by line while examining in-memory variables and </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">data structures.</span></span></p>
<p><span class="koboSpan" id="kobo.480.1">In the following example, we use Delve to debug the </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">packet-capture</span></strong><span class="koboSpan" id="kobo.482.1"> program we just ran. </span><span class="koboSpan" id="kobo.482.2">Before you can start, you need to generate some traffic through the lab topology with </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">make traffic-start</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.485.1">$ make traffic-start
docker exec -d clab-netgo-cvx systemctl restart hsflowd
docker exec -d clab-netgo-host-3 ./ethr -s
docker exec -d clab-netgo-host-1 ./ethr -c 203.0.113.253 -b 900K -d 60s -p udp -l 1KB
docker exec -d clab-netgo-host-1 ./ethr -c 203.0.113.252 -b 600K -d 60s -p udp -l 1KB
docker exec -d clab-netgo-host-1 ./ethr -c 203.0.113.251 -b 400K -d 60s -p udp -l 1KB</span></pre>
<p><span class="koboSpan" id="kobo.486.1">The Delve binary file is already pre-installed in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">host</span></strong><span class="koboSpan" id="kobo.488.1"> lab containers, so you can connect to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">host-2</span></strong><span class="koboSpan" id="kobo.490.1"> container with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">docker exec -it</span></strong><span class="koboSpan" id="kobo.492.1"> command and start the Delve shell with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">dlv </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">debug</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.495.1"> command:</span></span></p>
<pre class="source-code"><span class="Code_ligh-Blue"><span class="koboSpan" id="kobo.496.1">$ docker </span></span><span class="koboSpan" id="kobo.497.1">exec </span><span class="Code_Blue"><span class="koboSpan" id="kobo.498.1">-it </span></span><span class="koboSpan" id="kobo.499.1">clab-netgo-host-2 </span><span class="Code_Blue"><span class="koboSpan" id="kobo.500.1">bash</span></span><span class="koboSpan" id="kobo.501.1">
root@host-2:/</span><span class="Code_Red"><span class="koboSpan" id="kobo.502.1"># cd workdir/ch10/packet-capture/</span></span><span class="koboSpan" id="kobo.503.1">
root@host-2:/workdir/packet-capture</span><span class="Code_Red"><span class="koboSpan" id="kobo.504.1"># dlv debug main.go</span></span></pre>
<p><span class="koboSpan" id="kobo.505.1">Once</span><a id="_idIndexMarker915"/><span class="koboSpan" id="kobo.506.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">dlv</span></strong><span class="koboSpan" id="kobo.508.1"> interactive shell, you can use different built-in commands to control the execution of the program (you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">help</span></strong><span class="koboSpan" id="kobo.510.1"> to view the full list of commands). </span><span class="koboSpan" id="kobo.510.2">Set a breakpoint at line 49 of </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">main.go</span></strong><span class="koboSpan" id="kobo.512.1"> and run the program until the point where we receive the </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">first packet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.514.1">(dlv) break main.go:49
Breakpoint 1 set at 0x5942ce for main.main() ./main.go:49
(dlv) continue
&gt; main.main() ./main.go:49 (hits goroutine(1):1 total:1) (PC: 0x5942ce)
    44:    packetSource := gopacket.NewPacketSource(
    45:      handle,
    46:      layers.LayerTypeEthernet,
    47:    )
    48:    for packet := range packetSource.Packets() {
=&gt;  49:      if l4 := packet.TransportLayer(); l4 == nil {
    50:        continue
    51:      }
    52:  
    53:      sflowLayer := packet.Layer(layers.LayerTypeSFlow)
    54:      if sflowLayer != nil {</span></pre>
<p><span class="koboSpan" id="kobo.515.1">When execution stops at a breakpoint, you can examine the local variables using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">locals</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.517.1"> command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.518.1">(dlv) locals
err = error nil
handle = ("*github.com/google/gopacket/pcapgo.EthernetHandle")(0xc000162200)
rawInstructions = []golang.org/x/net/bpf.RawInstruction len: 6, cap: 6, [...]
packetSource = ("*github.com/google/gopacket.PacketSource")(0xc00009aab0)
packet = github.com/google/gopacket.Packet(*github.com/google/gopacket.eagerPacket) 0xc0000c3c08</span></pre>
<p><span class="koboSpan" id="kobo.519.1">You can </span><a id="_idIndexMarker916"/><span class="koboSpan" id="kobo.520.1">print the variable contents on a screen, as in the following example for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">packet</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.522.1"> variable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.523.1">(dlv) print packet
github.com/google/gopacket.Packet(*github.com/google/gopacket.eagerPacket) *{
  packet: github.com/google/gopacket.packet {
    data: []uint8 len: 758, cap: 758, [170,193,171,140,219,204,170,193,171,198,150,242,8,0,69,0,2,232,40,71,64,0,63,17,18,182,192,0,2,5,203,0,113,2,132,19,24,199,2,212,147,6,0,0,0,5,0,0,0,1,203,0,113,129,0,1,134,160,0,0,0,39,0,2,...+694 more],
    /* ... </span><span class="koboSpan" id="kobo.523.2">&lt; omitted &gt; ... </span><span class="koboSpan" id="kobo.523.3">*/
    last: github.com/google/gopacket.Layer(*github.com/google/gopacket.DecodeFailure) ...,
    metadata: (*"github.com/google/gopacket.PacketMetadata")(0xc0000c6200),
    decodeOptions: (*"github.com/google/gopacket.DecodeOptions")(0xc0000c6250),
    link: github.com/google/gopacket.LinkLayer(*github.com/google/gopacket/layers.Ethernet) ...,
    network: github.com/google/gopacket.NetworkLayer(*github.com/google/gopacket/layers.IPv4) ...,
    transport: github.com/google/gopacket.TransportLayer(*github.com/google/gopacket/layers.UDP) ...,
    application: github.com/google/gopacket.ApplicationLayer nil,
    failure: github.com/google/gopacket.ErrorLayer(*github.com/google/gopacket.DecodeFailure) ...,},}</span></pre>
<p><span class="koboSpan" id="kobo.524.1">The text-based navigation</span><a id="_idIndexMarker917"/><span class="koboSpan" id="kobo.525.1"> and verbosity of the output may be intimidating for beginners, but luckily, we have alternative </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">visualization options.</span></span></p>
<h2 id="_idParaDest-235"><a id="_idTextAnchor234"/><span class="koboSpan" id="kobo.527.1">Debugging from an IDE</span></h2>
<p><span class="koboSpan" id="kobo.528.1">If </span><a id="_idIndexMarker918"/><span class="koboSpan" id="kobo.529.1">debugging in a console is not your preferred option, most of the popular </span><strong class="bold"><span class="koboSpan" id="kobo.530.1">Integrated Development Environments</span></strong><span class="koboSpan" id="kobo.531.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.532.1">IDEs</span></strong><span class="koboSpan" id="kobo.533.1">) come with some form of support for Go debugging. </span><span class="koboSpan" id="kobo.533.2">For example, Delve integrates with </span><strong class="bold"><span class="koboSpan" id="kobo.534.1">Visual Studio Code</span></strong><span class="koboSpan" id="kobo.535.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.536.1">VSCode</span></strong><span class="koboSpan" id="kobo.537.1">) and </span><a id="_idIndexMarker919"/><span class="koboSpan" id="kobo.538.1">you can also configure it for remote debugging. </span></p>
<p><span class="koboSpan" id="kobo.539.1">Although you can set up VSCode for remote debugging in different ways, in this example, we run Delve manually inside a container in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">headless</span></strong><span class="koboSpan" id="kobo.541.1"> mode while specifying the port at which to listen for </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">incoming connections:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.543.1">$ docker exec -it clab-netgo-host-2 bash 
root@host-2:/# cd workdir/ch10/packet-capture/
root@host-2:/workdir/ch10/packet-capture#  dlv debug main.go --listen=:2345 --headless --api-version=2
API server listening at: [::]:2345</span></pre>
<p><span class="koboSpan" id="kobo.544.1">Now, we </span><a id="_idIndexMarker920"/><span class="koboSpan" id="kobo.545.1">need to tell VSCode how to connect to the remote Delve process. </span><span class="koboSpan" id="kobo.545.2">You can do this by including a JSON config file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">.vscode</span></strong><span class="koboSpan" id="kobo.547.1"> folder next to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">main.go</span></strong><span class="koboSpan" id="kobo.549.1"> file. </span><span class="koboSpan" id="kobo.549.2">Here’s an example file you can find in </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">ch10/packet-capture/.vscode/launch.json</span></strong><span class="koboSpan" id="kobo.551.1"> in this book’s </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">GitHub repository:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.553.1">{
	"version": </span><span class="Code_Red"><span class="koboSpan" id="kobo.554.1">"0.2.0"</span></span><span class="koboSpan" id="kobo.555.1">,
	"configurations": [
        {
            "name": </span><span class="Code_Red"><span class="koboSpan" id="kobo.556.1">"Connect to server"</span></span><span class="koboSpan" id="kobo.557.1">,
            "type": </span><span class="Code_Red"><span class="koboSpan" id="kobo.558.1">"go"</span></span><span class="koboSpan" id="kobo.559.1">,
            "request": </span><span class="Code_Red"><span class="koboSpan" id="kobo.560.1">"attach"</span></span><span class="koboSpan" id="kobo.561.1">,
            "mode": </span><span class="Code_Red"><span class="koboSpan" id="kobo.562.1">"remote"</span></span><span class="koboSpan" id="kobo.563.1">,
            "remotePath": "/workdir/ch10/packet-capture",
            "port": </span><span class="Code_Green"><span class="koboSpan" id="kobo.564.1">2345</span></span><span class="koboSpan" id="kobo.565.1">,
            "host": </span><span class="Code_Red"><span class="koboSpan" id="kobo.566.1">"ec2-3-224-127-79.compute-1.amazonaws.com"</span></span><span class="koboSpan" id="kobo.567.1">,  
        },
    ]
}</span></pre>
<p><span class="koboSpan" id="kobo.568.1">You need to replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">host</span></strong><span class="koboSpan" id="kobo.570.1"> value with the one where the lab is running and then start an instance of VSCode from the root of the Go program (</span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">code ch10/packet-capture</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer082">
<span class="koboSpan" id="kobo.573.1"><img alt="Figure 10.2 – VSCode development environment " src="image/B16971_10_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.574.1">Figure 10.2 – VSCode development environment </span></p>
<p><span class="koboSpan" id="kobo.575.1">In VSCode, now you can go to the debug icon in the left menu to get to </span><strong class="bold"><span class="koboSpan" id="kobo.576.1">RUN AND DEBUG</span></strong><span class="koboSpan" id="kobo.577.1">, where </span><a id="_idIndexMarker921"/><span class="koboSpan" id="kobo.578.1">you should see the </span><strong class="bold"><span class="koboSpan" id="kobo.579.1">Connect to server</span></strong><span class="koboSpan" id="kobo.580.1"> option that reads the preceding JSON config file. </span><span class="koboSpan" id="kobo.580.2">Click on the green arrow to connect to the remote </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">debugging process.</span></span></p>
<p><span class="koboSpan" id="kobo.582.1">At this point, you can navigate through the code and examine local variables inside the VSCode </span><strong class="bold"><span class="koboSpan" id="kobo.583.1">user interface</span></strong><span class="koboSpan" id="kobo.584.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.585.1">UI</span></strong><span class="koboSpan" id="kobo.586.1">), while </span><a id="_idIndexMarker922"/><span class="koboSpan" id="kobo.587.1">the debugging process is running inside </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">a container:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer083">
<span class="koboSpan" id="kobo.589.1"><img alt="Figure 10.3 – VSCode debugging" src="image/B16971_10_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.590.1">Figure 10.3 – VSCode debugging</span></p>
<p><span class="koboSpan" id="kobo.591.1">In the next section, we</span><a id="_idIndexMarker923"/><span class="koboSpan" id="kobo.592.1"> will look at how to add value to the data plane telemetry we collect and process by aggregating it to generate a report of the highest </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">bandwidth consumers.</span></span></p>
<h1 id="_idParaDest-236"><a id="_idTextAnchor235"/><span class="koboSpan" id="kobo.594.1">Data plane telemetry aggregation</span></h1>
<p><span class="koboSpan" id="kobo.595.1">After collecting </span><a id="_idIndexMarker924"/><span class="koboSpan" id="kobo.596.1">and parsing data plane telemetry, we need to think about what to do with it next. </span><span class="koboSpan" id="kobo.596.2">Looking at raw data is not always helpful because of the sheer number of flows and lack of any meaningful context. </span><span class="koboSpan" id="kobo.596.3">Hence, the next logical step in a telemetry processing pipeline is data enrichment </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">and aggregation.</span></span></p>
<p><span class="koboSpan" id="kobo.598.1">Telemetry enrichment refers to the process of adding extra metadata to each flow based on some external source of information. </span><span class="koboSpan" id="kobo.598.2">For example, these external sources can provide a correlation between a public IP and its country of origin or BGP ASN, or between a private IP and its aggregate subnets or device identity. </span></p>
<p><span class="koboSpan" id="kobo.599.1">Another technique that can help us interpret and reason about the telemetry we collect is aggregation. </span><span class="koboSpan" id="kobo.599.2">We can combine different flow records either based on the IP prefix boundary or flow metadata, such as a BGP ASN, to help network operators draw meaningful insights and create high-level views of the data. </span></p>
<p><span class="koboSpan" id="kobo.600.1">You could </span><a id="_idIndexMarker925"/><span class="koboSpan" id="kobo.601.1">build the entire telemetry processing pipeline out of open source components with ready-to-use examples (see </span><em class="italic"><span class="koboSpan" id="kobo.602.1">Further reading</span></em><span class="koboSpan" id="kobo.603.1">) available on the internet, but sooner or later, you might need to write some code to meet your specific business requirements. </span><span class="koboSpan" id="kobo.603.2">In the following section, we will work on a scenario where we need to aggregate data plane telemetry to better understand the traffic patterns in </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">our network.</span></span></p>
<h2 id="_idParaDest-237"><a id="_idTextAnchor236"/><span class="koboSpan" id="kobo.605.1">Top talkers</span></h2>
<p><span class="koboSpan" id="kobo.606.1">In the </span><a id="_idIndexMarker926"/><span class="koboSpan" id="kobo.607.1">absence of long-term telemetry storage, getting a just-in-time snapshot of the highest bandwidth consumers can be quite helpful. </span><span class="koboSpan" id="kobo.607.2">We refer to this application as </span><em class="italic"><span class="koboSpan" id="kobo.608.1">top talkers</span></em><span class="koboSpan" id="kobo.609.1">, and it works by displaying a</span><a id="_idIndexMarker927"/><span class="koboSpan" id="kobo.610.1"> list of network flows that are sorted based on their relative interface bandwidth utilization. </span></p>
<p><span class="koboSpan" id="kobo.611.1">Let’s walk through an example Go application that implements </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">this feature.</span></span></p>
<h3><span class="koboSpan" id="kobo.613.1">Exploring telemetry data</span></h3>
<p><span class="koboSpan" id="kobo.614.1">In our </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">top-talkers</span></strong><span class="koboSpan" id="kobo.616.1"> application, we </span><a id="_idIndexMarker928"/><span class="koboSpan" id="kobo.617.1">collect sFlow records with </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">netsampler/goflow2</span></strong><span class="koboSpan" id="kobo.619.1">, a package designed specifically to collect, enrich, and save sFlow, IPFIX, or NetFlow telemetry. </span><span class="koboSpan" id="kobo.619.2">This package ingests raw protocol data and produces normalized (protocol-independent) flow records. </span><span class="koboSpan" id="kobo.619.3">By default, you can save these normalized records in a file or send them to a Kafka queue. </span><span class="koboSpan" id="kobo.619.4">In our case, we store them in memory for further processing. </span></p>
<p><span class="koboSpan" id="kobo.620.1">To store the flow records in memory, we save the most relevant fields of each flow record we receive in a user-defined data structure we </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">call </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">MyFlow</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.624.1">type </span></span><span class="koboSpan" id="kobo.625.1">MyFlow </span><span class="Code_Purple"><span class="koboSpan" id="kobo.626.1">struct </span></span><span class="koboSpan" id="kobo.627.1">{
     Key         </span><span class="Code_Purple"><span class="koboSpan" id="kobo.628.1">string</span></span><span class="koboSpan" id="kobo.629.1">
     SrcAddr     </span><span class="Code_Purple"><span class="koboSpan" id="kobo.630.1">string </span></span><span class="Code_Red"><span class="koboSpan" id="kobo.631.1">`json:"SrcAddr,omitempty"`</span></span><span class="koboSpan" id="kobo.632.1">
     DstAddr     </span><span class="Code_Purple"><span class="koboSpan" id="kobo.633.1">string </span></span><span class="Code_Red"><span class="koboSpan" id="kobo.634.1">`json:"DstAddr,omitempty"`</span></span><span class="koboSpan" id="kobo.635.1">
     SrcPort     </span><span class="Code_Purple"><span class="koboSpan" id="kobo.636.1">int    </span></span><span class="Code_Red"><span class="koboSpan" id="kobo.637.1">`json:"SrcPort,omitempty"`</span></span><span class="koboSpan" id="kobo.638.1">
     DstPort     </span><span class="Code_Purple"><span class="koboSpan" id="kobo.639.1">int    </span></span><span class="Code_Red"><span class="koboSpan" id="kobo.640.1">`json:"DstPort,omitempty"`</span></span><span class="koboSpan" id="kobo.641.1">
     Count       </span><span class="Code_Purple"><span class="koboSpan" id="kobo.642.1">int    </span></span><span class="Code_Brown"><span class="koboSpan" id="kobo.643.1">// times we've seen this flow sample</span></span><span class="koboSpan" id="kobo.644.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.645.1">Additionally, we </span><a id="_idIndexMarker929"/><span class="koboSpan" id="kobo.646.1">create a flow key as a concatenation of the ports and IP addresses of the source and destination to uniquely identify </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">each flow:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer084">
<span class="koboSpan" id="kobo.648.1"><img alt="Figure 10.4 – A flow key" src="image/B16971_10_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.649.1">Figure 10.4 – A flow key</span></p>
<p><span class="koboSpan" id="kobo.650.1">To help us calculate the final result, we create another data structure we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">topTalker</span></strong><span class="koboSpan" id="kobo.652.1">, which has </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">two fields:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">flowMap</span></strong><span class="koboSpan" id="kobo.655.1">: A map to store a collection of </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">MyFlow</span></strong><span class="koboSpan" id="kobo.657.1">-type flows. </span><span class="koboSpan" id="kobo.657.2">We use the key we created to </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">index them.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">Heap</span></strong><span class="koboSpan" id="kobo.660.1">: A helper data structure that keeps track of the most frequently </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">seen flows:</span></span><pre class="console"><span class="Code_Purple"><span class="koboSpan" id="kobo.662.1">type </span></span><span class="koboSpan" id="kobo.663.1">Heap []*MyFlow</span></pre><pre class="console"><span class="Code_Purple"><span class="koboSpan" id="kobo.664.1">type </span></span><span class="koboSpan" id="kobo.665.1">topTalker </span><span class="Code_Purple"><span class="koboSpan" id="kobo.666.1">struct </span></span><span class="koboSpan" id="kobo.667.1">{</span></pre><pre class="console"><span class="koboSpan" id="kobo.668.1">     flowMap </span><span class="Code_Purple"><span class="koboSpan" id="kobo.669.1">map</span></span><span class="koboSpan" id="kobo.670.1">[</span><span class="Code_Purple"><span class="koboSpan" id="kobo.671.1">string</span></span><span class="koboSpan" id="kobo.672.1">]*MyFlow</span></pre><pre class="console"><span class="koboSpan" id="kobo.673.1">     heap    Heap</span></pre><pre class="console"><span class="koboSpan" id="kobo.674.1">}</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.675.1">Since we use a high-level sFlow package (</span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">goflow2</span></strong><span class="koboSpan" id="kobo.677.1">), we don’t need to worry about setting up a UDP listener or receiving and decoding packets, but we need to tell </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">goflow2</span></strong><span class="koboSpan" id="kobo.679.1"> the </span><a id="_idIndexMarker930"/><span class="koboSpan" id="kobo.680.1">format to report flow records (</span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">json</span></strong><span class="koboSpan" id="kobo.682.1">) and point to a custom transport driver (</span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">tt</span></strong><span class="koboSpan" id="kobo.684.1">) that determines what to do with the data after the sFlow package normalizes the received </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">flow records:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.686.1">import </span></span><span class="koboSpan" id="kobo.687.1">(
  </span><span class="Code_Red"><span class="koboSpan" id="kobo.688.1">"github.com/netsampler/goflow2/format"</span></span><span class="koboSpan" id="kobo.689.1">
  </span><span class="Code_Red"><span class="koboSpan" id="kobo.690.1">"github.com/netsampler/goflow2/utils"</span></span><span class="koboSpan" id="kobo.691.1">
)
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.692.1">func </span></span><span class="koboSpan" id="kobo.693.1">main() {
     tt := topTalker{
           flowMap: </span><span class="Code_Blue"><span class="koboSpan" id="kobo.694.1">make</span></span><span class="koboSpan" id="kobo.695.1">(</span><span class="Code_Purple"><span class="koboSpan" id="kobo.696.1">map</span></span><span class="koboSpan" id="kobo.697.1">[</span><span class="Code_Purple"><span class="koboSpan" id="kobo.698.1">string</span></span><span class="koboSpan" id="kobo.699.1">]*MyPacket),
           heap:    </span><span class="Code_Blue"><span class="koboSpan" id="kobo.700.1">make</span></span><span class="koboSpan" id="kobo.701.1">(Heap, 0),
     }
     formatter, err := format.FindFormat(ctx, </span><span class="Code_Red"><span class="koboSpan" id="kobo.702.1">"json"</span></span><span class="koboSpan" id="kobo.703.1">)
     </span><span class="Code_Brown"><span class="koboSpan" id="kobo.704.1">// process error</span></span><span class="koboSpan" id="kobo.705.1">
     sSFlow :</span><span class="Code_Red"><span class="koboSpan" id="kobo.706.1">=</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.707.1">&amp;</span></span><span class="koboSpan" id="kobo.708.1">utils.StateSFlow{
           Format:    formatter,
           Logger:    log.StandardLogger(),
           Transport: </span><span class="Code_Red"><span class="koboSpan" id="kobo.709.1">&amp;</span></span><span class="koboSpan" id="kobo.710.1">tt,
     }
     </span><span class="Code_Purple"><span class="koboSpan" id="kobo.711.1">go </span></span><span class="koboSpan" id="kobo.712.1">sSFlow.FlowRoutine(1, hostname, </span><span class="Code_Green"><span class="koboSpan" id="kobo.713.1">6343</span></span><span class="koboSpan" id="kobo.714.1">, </span><span class="Code_Blue"><span class="koboSpan" id="kobo.715.1">false</span></span><span class="koboSpan" id="kobo.716.1">)
}</span></pre>
<p><span class="koboSpan" id="kobo.717.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">Transport</span></strong><span class="koboSpan" id="kobo.719.1"> field in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">utils.StateSFlow</span></strong><span class="koboSpan" id="kobo.721.1"> type of the preceding code snippet accepts </span><a id="_idIndexMarker931"/><span class="koboSpan" id="kobo.722.1">any type that implements </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">TransportInterface</span></strong><span class="koboSpan" id="kobo.724.1">. </span><span class="koboSpan" id="kobo.724.2">This interface expects a single method (</span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">Send()</span></strong><span class="koboSpan" id="kobo.726.1">) where all the enrichment and aggregation may </span><span class="No-Break"><span class="koboSpan" id="kobo.727.1">take place:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.728.1">type </span></span><span class="koboSpan" id="kobo.729.1">StateSFlow </span><span class="Code_Purple"><span class="koboSpan" id="kobo.730.1">struct </span></span><span class="koboSpan" id="kobo.731.1">{
     Format    format.FormatInterface
     Transport transport.TransportInterface
     Logger    Logger
     </span><span class="Code_Brown"><span class="koboSpan" id="kobo.732.1">/* ... </span><span class="koboSpan" id="kobo.732.2">&lt; other fields &gt; ... </span><span class="koboSpan" id="kobo.732.3">*/</span></span><span class="koboSpan" id="kobo.733.1">
}
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.734.1">type </span></span><span class="koboSpan" id="kobo.735.1">TransportInterface </span><span class="Code_Purple"><span class="koboSpan" id="kobo.736.1">interface </span></span><span class="koboSpan" id="kobo.737.1">{
     Send(key, data []</span><span class="Code_Purple"><span class="koboSpan" id="kobo.738.1">byte</span></span><span class="koboSpan" id="kobo.739.1">) </span><span class="Code_Purple"><span class="koboSpan" id="kobo.740.1">error</span></span><span class="koboSpan" id="kobo.741.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.742.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">Send</span></strong><span class="koboSpan" id="kobo.744.1"> method accepts two arguments, one representing the source IP of an sFlow datagram and the second one containing the actual </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">flow record.</span></span></p>
<h3><span class="koboSpan" id="kobo.746.1">Telemetry processing</span></h3>
<p><span class="koboSpan" id="kobo.747.1">In our</span><a id="_idIndexMarker932"/><span class="koboSpan" id="kobo.748.1"> implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">Send</span></strong><span class="koboSpan" id="kobo.750.1"> method (to satisfy the </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">TransportInterface</span></strong><span class="koboSpan" id="kobo.752.1"> interface), we first parse the input binary data and deserialize it into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">MyFlow</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.754.1">data structure:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.755.1">func </span></span><span class="koboSpan" id="kobo.756.1">(c *topTalker) Send(key, data []</span><span class="Code_Purple"><span class="koboSpan" id="kobo.757.1">byte</span></span><span class="koboSpan" id="kobo.758.1">) </span><span class="Code_Purple"><span class="koboSpan" id="kobo.759.1">error </span></span><span class="koboSpan" id="kobo.760.1">{
     </span><span class="Code_Purple"><span class="koboSpan" id="kobo.761.1">var </span></span><span class="koboSpan" id="kobo.762.1">myFlow MyFlow
     json.Unmarshal(data, </span><span class="Code_Red"><span class="koboSpan" id="kobo.763.1">&amp;</span></span><span class="koboSpan" id="kobo.764.1">myFlow)
     </span><span class="Code_Brown"><span class="koboSpan" id="kobo.765.1">/* ... </span><span class="koboSpan" id="kobo.765.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.765.3">*/</span></span><span class="koboSpan" id="kobo.766.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.767.1">Bearing in mind that sFlow can capture packets going in either direction, we need to ensure that both flows count toward the same in-memory flow record. </span><span class="koboSpan" id="kobo.767.2">This means creating a special flow key that satisfies the following </span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">two conditions:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.769.1">It must be the same for both ingress and egress packets of the </span><span class="No-Break"><span class="koboSpan" id="kobo.770.1">same flow.</span></span></li>
<li><span class="koboSpan" id="kobo.771.1">It must be unique for all </span><span class="No-Break"><span class="koboSpan" id="kobo.772.1">bidirectional flows.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.773.1">We do</span><a id="_idIndexMarker933"/><span class="koboSpan" id="kobo.774.1"> this by sorting the source and destination IPs when constructing the bidirectional flow key, as the next code </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">snippet shows:</span></span></p>
<pre class="source-code"><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.776.1">var</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.777.1"> flowMapKey </span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.778.1">= `%s:%d&lt;-&gt;%s:%d`</span></span>
<span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.779.1">func</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.780.1"> (c *topTalker) Send(key, data []</span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.781.1">byte</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.782.1">) </span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.783.1">error</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.784.1"> {</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.785.1">  </span></span><span class="Code_Brown" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.786.1">/* ... </span><span class="koboSpan" id="kobo.786.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.786.3">*/</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.787.1">  ips := []</span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.788.1">string</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.789.1">{myFlow.SrcAddr, myFlow.DstAddr}</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.790.1">  sort.Strings(ips)</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.791.1">  </span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.792.1">var</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.793.1"> mapKey </span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.794.1">string</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.795.1">  </span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.796.1">if</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.797.1"> ips[0] </span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.798.1">!=</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.799.1"> myFlow.SrcAddr {</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.800.1">    mapKey </span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.801.1">=</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.802.1"> fmt.Sprintf(</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.803.1">      flowMapKey,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.804.1">      myFlow.SrcAddr,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.805.1">      myFlow.SrcPort,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.806.1">      myFlow.DstAddr,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.807.1">      myFlow.DstPort,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.808.1">    )</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.809.1">  } </span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.810.1">else</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.811.1"> {</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.812.1">    mapKey </span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.813.1">=</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.814.1"> fmt.Sprintf(</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.815.1">      flowMapKey,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.816.1">      myFlow.DstAddr,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.817.1">      myFlow.DstPort,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.818.1">      myFlow.SrcAddr,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.819.1">      myFlow.SrcPort,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.820.1">    )</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.821.1">  }</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.822.1">  </span></span><span class="Code_Brown" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.823.1">/* ... </span><span class="koboSpan" id="kobo.823.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.823.3">*/</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.824.1">}</span></span></pre>
<p><span class="koboSpan" id="kobo.825.1">With a unique </span><a id="_idIndexMarker934"/><span class="koboSpan" id="kobo.826.1">key that represents both directions of a flow, we can save it in the map (</span><strong class="source-inline"><span class="koboSpan" id="kobo.827.1">flowMap</span></strong><span class="koboSpan" id="kobo.828.1">) to store in memory. </span><span class="koboSpan" id="kobo.828.2">For each received flow record, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">Send</span></strong><span class="koboSpan" id="kobo.830.1"> method performs the </span><span class="No-Break"><span class="koboSpan" id="kobo.831.1">following checks:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.832.1">If this is the first time we’ve seen this flow, then we save it on the map and set the count number </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.835.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.836.1">Otherwise, we update the flow by incrementing its count </span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">by one:</span></span></li>
</ul>
<pre class="source-code"><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.838.1">func</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.839.1"> (c *topTalker) Send(key, data []</span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.840.1">byte</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.841.1">) </span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.842.1">error</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.843.1"> {</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.844.1">  </span></span><span class="Code_Brown" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.845.1">/* ... </span><span class="koboSpan" id="kobo.845.2">&lt;continues from before &gt; ... </span><span class="koboSpan" id="kobo.845.3">*/</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.846.1">    myFlow.Key = mapKey</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.847.1">    foundFlow, ok := c.flowMap[mapKey]</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.848.1">    </span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.849.1">if</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.850.1"> !ok {</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.851.1">          myFlow.Count = 1</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.852.1">          c.flowMap[mapKey] = &amp;myFlow</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.853.1">          heap.Push(&amp;c.heap, &amp;myFlow)</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.854.1">          </span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.855.1">return</span></span><span lang="en-US" xml:lang="en-US"> </span><span class="Code_Blue" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.856.1">nil</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.857.1">    }</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.858.1">    c.heap.update(foundFlow)</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.859.1">    </span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.860.1">return</span></span><span lang="en-US" xml:lang="en-US"> </span><span class="Code_Blue" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.861.1">nil</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.862.1">} </span></span></pre>
<p><span class="koboSpan" id="kobo.863.1">Now, to</span><a id="_idIndexMarker935"/><span class="koboSpan" id="kobo.864.1"> display the top talkers in order, we need to sort the flow records we have saved. </span><span class="koboSpan" id="kobo.864.2">Here, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">container/heap</span></strong><span class="koboSpan" id="kobo.866.1"> package from the Go standard library. </span><span class="koboSpan" id="kobo.866.2">It implements a sorting algorithm, offering O(log n) (logarithmic) upper-bound guarantees, which means it can do additions and deletions of data very efficiently. </span></p>
<p><span class="koboSpan" id="kobo.867.1">To use this package, you only need to teach it how to compare your items. </span><span class="koboSpan" id="kobo.867.2">As you add, remove, or update elements, it will sort them automatically. </span><span class="koboSpan" id="kobo.867.3">In our example, we want to sort flow records saved as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">MyFlow</span></strong><span class="koboSpan" id="kobo.869.1"> data type. </span><span class="koboSpan" id="kobo.869.2">We define </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">Heap</span></strong><span class="koboSpan" id="kobo.871.1"> as a list of pointers to </span><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">MyFlow</span></strong><span class="koboSpan" id="kobo.873.1"> records. </span><span class="koboSpan" id="kobo.873.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">Less()</span></strong><span class="koboSpan" id="kobo.875.1"> method instructs the </span><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">container/heap</span></strong><span class="koboSpan" id="kobo.877.1"> package to compare two </span><strong class="source-inline"><span class="koboSpan" id="kobo.878.1">MyFlow</span></strong><span class="koboSpan" id="kobo.879.1"> elements, based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">Count</span></strong><span class="koboSpan" id="kobo.881.1"> field that stores the number of times we have </span><em class="italic"><span class="koboSpan" id="kobo.882.1">seen</span></em><span class="koboSpan" id="kobo.883.1"> a </span><span class="No-Break"><span class="koboSpan" id="kobo.884.1">flow record:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.885.1">type </span></span><span class="koboSpan" id="kobo.886.1">Heap []*MyFlow
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.887.1">func </span></span><span class="koboSpan" id="kobo.888.1">(h Heap) Less(i, j </span><span class="Code_Purple"><span class="koboSpan" id="kobo.889.1">int</span></span><span class="koboSpan" id="kobo.890.1">) </span><span class="Code_Purple"><span class="koboSpan" id="kobo.891.1">bool </span></span><span class="koboSpan" id="kobo.892.1">{
     </span><span class="Code_Purple"><span class="koboSpan" id="kobo.893.1">return </span></span><span class="koboSpan" id="kobo.894.1">h[i].Count </span><span class="Code_Red"><span class="koboSpan" id="kobo.895.1">&gt;</span></span><span class="koboSpan" id="kobo.896.1"> h[j].Count
}</span></pre>
<p><span class="koboSpan" id="kobo.897.1">With this, we now have an in-memory flow record store with elements sorted according to their </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">Count</span></strong><span class="koboSpan" id="kobo.899.1">. </span><span class="koboSpan" id="kobo.899.2">We can now iterate over the </span><strong class="source-inline"><span class="koboSpan" id="kobo.900.1">Heap</span></strong><span class="koboSpan" id="kobo.901.1"> slice and print its elements on the screen. </span><span class="koboSpan" id="kobo.901.2">As in the earlier example with </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">gopacket</span></strong><span class="koboSpan" id="kobo.903.1">, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">ethr</span></strong><span class="koboSpan" id="kobo.905.1"> to generate three UDP flows with different throughputs to get a consistently sorted output. </span><span class="koboSpan" id="kobo.905.2">You can trigger the flows in the topology with </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">make top-talkers-start</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.907.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.908.1">Network-Automation-with-Go </span><span class="Code_ligh-Blue"><span class="koboSpan" id="kobo.909.1">$ make </span></span><span class="koboSpan" id="kobo.910.1">top-talkers-start
docker exec </span><span class="Code_Blue"><span class="koboSpan" id="kobo.911.1">-d</span></span><span class="koboSpan" id="kobo.912.1"> clab-netgo-cvx systemctl </span><span class="Code_Blue"><span class="koboSpan" id="kobo.913.1">restart </span></span><span class="koboSpan" id="kobo.914.1">hsflowd
docker exec </span><span class="Code_Blue"><span class="koboSpan" id="kobo.915.1">-d</span></span><span class="koboSpan" id="kobo.916.1"> clab-netgo-host-3 ./ethr </span><span class="Code_Blue"><span class="koboSpan" id="kobo.917.1">-s</span></span><span class="koboSpan" id="kobo.918.1">
docker exec </span><span class="Code_Blue"><span class="koboSpan" id="kobo.919.1">-d</span></span><span class="koboSpan" id="kobo.920.1"> clab-netgo-host-1 ./ethr </span><span class="Code_Blue"><span class="koboSpan" id="kobo.921.1">-c</span></span><span class="koboSpan" id="kobo.922.1"> 203.0.113.253 </span><span class="Code_Blue"><span class="koboSpan" id="kobo.923.1">-b</span></span><span class="koboSpan" id="kobo.924.1"> 900K </span><span class="Code_Blue"><span class="koboSpan" id="kobo.925.1">-d</span></span><span class="koboSpan" id="kobo.926.1"> 60s </span><span class="Code_Blue"><span class="koboSpan" id="kobo.927.1">-p</span></span><span class="koboSpan" id="kobo.928.1"> udp </span><span class="Code_Blue"><span class="koboSpan" id="kobo.929.1">-l</span></span><span class="koboSpan" id="kobo.930.1"> 1KB
docker exec </span><span class="Code_Blue"><span class="koboSpan" id="kobo.931.1">-d</span></span><span class="koboSpan" id="kobo.932.1"> clab-netgo-host-1 ./ethr </span><span class="Code_Blue"><span class="koboSpan" id="kobo.933.1">-c</span></span><span class="koboSpan" id="kobo.934.1"> 203.0.113.252 </span><span class="Code_Blue"><span class="koboSpan" id="kobo.935.1">-b</span></span><span class="koboSpan" id="kobo.936.1"> 600K </span><span class="Code_Blue"><span class="koboSpan" id="kobo.937.1">-d</span></span><span class="koboSpan" id="kobo.938.1"> 60s </span><span class="Code_Blue"><span class="koboSpan" id="kobo.939.1">-p</span></span><span class="koboSpan" id="kobo.940.1"> udp </span><span class="Code_Blue"><span class="koboSpan" id="kobo.941.1">-l</span></span><span class="koboSpan" id="kobo.942.1"> 1KB
docker exec </span><span class="Code_Blue"><span class="koboSpan" id="kobo.943.1">-d</span></span><span class="koboSpan" id="kobo.944.1"> clab-netgo-host-1 ./ethr </span><span class="Code_Blue"><span class="koboSpan" id="kobo.945.1">-c</span></span><span class="koboSpan" id="kobo.946.1"> 203.0.113.251 </span><span class="Code_Blue"><span class="koboSpan" id="kobo.947.1">-b</span></span><span class="koboSpan" id="kobo.948.1"> 400K </span><span class="Code_Blue"><span class="koboSpan" id="kobo.949.1">-d</span></span><span class="koboSpan" id="kobo.950.1"> 60s </span><span class="Code_Blue"><span class="koboSpan" id="kobo.951.1">-p</span></span><span class="koboSpan" id="kobo.952.1"> udp </span><span class="Code_Blue"><span class="koboSpan" id="kobo.953.1">-l</span></span><span class="koboSpan" id="kobo.954.1"> 1KB</span></pre>
<p><span class="koboSpan" id="kobo.955.1">Then, run</span><a id="_idIndexMarker936"/><span class="koboSpan" id="kobo.956.1"> the Top-talkers Go application with </span><strong class="source-inline"><span class="koboSpan" id="kobo.957.1">go run main.go</span></strong><span class="koboSpan" id="kobo.958.1"> from within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.959.1">host-2</span></strong><span class="koboSpan" id="kobo.960.1"> container (</span><strong class="source-inline"><span class="koboSpan" id="kobo.961.1">clab-netgo-host-2</span></strong><span class="koboSpan" id="kobo.962.1">) to get a real-time </span><span class="No-Break"><span class="koboSpan" id="kobo.963.1">Top-talkers table:</span></span></p>
<pre class="source-code"><span class="Code_Blue" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.964.1">$ cd </span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.965.1">ch10/top-talkers;</span></span><span class="Code_Blue" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.966.1"> sudo </span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.967.1">ip netns exec clab-netgo-host-2 /usr/local/go/bin/go run main.go;</span></span><span class="Code_Blue" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.968.1"> cd </span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.969.1">../../</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.970.1">Top Talkers</span></span>
<span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.971.1">+</span></span><span class="Code_Blue" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.972.1">---</span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.973.1">+</span></span><span class="Code_Blue" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.974.1">-------------------</span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.975.1">+</span></span><span class="Code_Blue" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.976.1">--------------------</span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.977.1">+</span></span><span class="Code_Blue" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.978.1">------</span></span>
<span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.979.1">| # | FROM              | TO                 | PROTO </span></span>
<span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.980.1">+</span></span><span class="Code_Blue" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.981.1">---</span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.982.1">+</span></span><span class="Code_Blue" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.983.1">-------------------</span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.984.1">+</span></span><span class="Code_Blue" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.985.1">--------------------</span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.986.1">+</span></span><span class="Code_Blue" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.987.1">------</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.988.1">| </span></span><span class="Code_Green" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.989.1">1</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.990.1"> | </span></span><span class="Code_Green" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.991.1">203</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.992.1">.0.113.253:8888 | </span></span><span class="Code_Green" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.993.1">203</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.994.1">.0.113.0:48494 | UDP | </span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.995.1">| </span></span><span class="Code_Green" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.996.1">2</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.997.1"> | </span></span><span class="Code_Green" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.998.1">203</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.999.1">.0.113.252:8888 | </span></span><span class="Code_Green" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1000.1">203</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1001.1">.0.113.0:42912 | UDP | </span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1002.1">| </span></span><span class="Code_Green" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1003.1">3</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1004.1"> | </span></span><span class="Code_Green" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1005.1">203</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1006.1">.0.113.251:8888 | </span></span><span class="Code_Green" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1007.1">203</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1008.1">.0.113.0:42882 | UDP | </span></span>
<span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1009.1">+</span></span><span class="Code_Blue" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1010.1">---</span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1011.1">+</span></span><span class="Code_Blue" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1012.1">-------------------</span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1013.1">+</span></span><span class="Code_Blue" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1014.1">--------------------</span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1015.1">+</span></span><span class="Code_Blue" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1016.1">------</span></span></pre>
<p><span class="koboSpan" id="kobo.1017.1">Note that due to low traffic volume, random packet sampling, and limited test duration, your results may be slightly different but should converge to a similar distribution after several </span><span class="No-Break"><span class="koboSpan" id="kobo.1018.1">test iterations.</span></span></p>
<h2 id="_idParaDest-238"><a id="_idTextAnchor237"/><span class="koboSpan" id="kobo.1019.1">Testing Go programs</span></h2>
<p><span class="koboSpan" id="kobo.1020.1">Code testing is</span><a id="_idIndexMarker937"/><span class="koboSpan" id="kobo.1021.1"> an integral part of any production software development process. </span><span class="koboSpan" id="kobo.1021.2">Good test coverage improves application reliability and increases tolerance to bugs introduced at later stages of software development. </span><span class="koboSpan" id="kobo.1021.3">Go has native support for testing with its </span><strong class="source-inline"><span class="koboSpan" id="kobo.1022.1">testing</span></strong><span class="koboSpan" id="kobo.1023.1"> package from the standard library and built-in command-line tool, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">go test</span></strong><span class="koboSpan" id="kobo.1025.1">. </span><span class="koboSpan" id="kobo.1025.2">With test coverage built into the Go tool, it’s uncommon to see third-party packages used for testing </span><span class="No-Break"><span class="koboSpan" id="kobo.1026.1">Go code.</span></span></p>
<p><span class="koboSpan" id="kobo.1027.1">Table-driven testing is one of the most popular testing methodologies in Go. </span><span class="koboSpan" id="kobo.1027.2">The idea is to describe test cases as a slice of custom data structures, with each one providing both inputs and expected results for each test case. </span><span class="koboSpan" id="kobo.1027.3">Writing test cases as a table makes it easier to create new scenarios, consider corner cases, and interpret existing </span><span class="No-Break"><span class="koboSpan" id="kobo.1028.1">code behaviors.</span></span></p>
<p><span class="koboSpan" id="kobo.1029.1">We can test part of the code of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1030.1">top-talkers</span></strong><span class="koboSpan" id="kobo.1031.1"> example we just reviewed by building a</span><a id="_idIndexMarker938"/><span class="koboSpan" id="kobo.1032.1"> set of table tests for the heap implementation we used to sort the flow records. </span></p>
<p><span class="koboSpan" id="kobo.1033.1">Let’s create a test file, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1034.1">main_test.go</span></strong><span class="koboSpan" id="kobo.1035.1">, with a single test function </span><span class="No-Break"><span class="koboSpan" id="kobo.1036.1">in it:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1037.1">package </span></span><span class="koboSpan" id="kobo.1038.1">main
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1039.1">import </span></span><span class="koboSpan" id="kobo.1040.1">(
     </span><span class="Code_Red"><span class="koboSpan" id="kobo.1041.1">"container/heap"</span></span><span class="koboSpan" id="kobo.1042.1">
     </span><span class="Code_Red"><span class="koboSpan" id="kobo.1043.1">"testing"</span></span><span class="koboSpan" id="kobo.1044.1">
)
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1045.1">func </span></span><span class="koboSpan" id="kobo.1046.1">TestHeap(t *testing.T) {
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1047.1">// code tests</span></span><span class="koboSpan" id="kobo.1048.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.1049.1">Both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1050.1">_test.go</span></strong><span class="koboSpan" id="kobo.1051.1"> filename suffix and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1052.1">Test&lt;Name&gt;</span></strong><span class="koboSpan" id="kobo.1053.1"> function prefix are naming conventions that allow Go to detect testing code and exclude it during </span><span class="No-Break"><span class="koboSpan" id="kobo.1054.1">binary compilation.</span></span></p>
<p><span class="koboSpan" id="kobo.1055.1">We design each test case to have all the relevant information, including </span><span class="No-Break"><span class="koboSpan" id="kobo.1056.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1057.1">A name to use in </span><span class="No-Break"><span class="koboSpan" id="kobo.1058.1">error messages</span></span></li>
<li><span class="koboSpan" id="kobo.1059.1">A set of unique flows described by their starting counters and </span><span class="No-Break"><span class="koboSpan" id="kobo.1060.1">resulting positions:</span></span><pre class="console"><span class="Code_Purple"><span class="koboSpan" id="kobo.1061.1">type </span></span><span class="koboSpan" id="kobo.1062.1">testFlow </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1063.1">struct </span></span><span class="koboSpan" id="kobo.1064.1">{</span></pre><pre class="console"><span class="koboSpan" id="kobo.1065.1">     startCount   </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1066.1">int</span></span></pre><pre class="console"><span class="koboSpan" id="kobo.1067.1">     timesSeen    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1068.1">int</span></span></pre><pre class="console"><span class="koboSpan" id="kobo.1069.1">     wantPosition </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1070.1">int</span></span></pre><pre class="console"><span class="koboSpan" id="kobo.1071.1">     wantCount    </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1072.1">int</span></span></pre><pre class="console"><span class="koboSpan" id="kobo.1073.1">}</span></pre><pre class="console"><span class="Code_Purple"><span class="koboSpan" id="kobo.1074.1">type </span></span><span class="koboSpan" id="kobo.1075.1">testCase </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1076.1">struct </span></span><span class="koboSpan" id="kobo.1077.1">{</span></pre><pre class="console"><span class="koboSpan" id="kobo.1078.1">     name  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1079.1">string</span></span></pre><pre class="console"><span class="koboSpan" id="kobo.1080.1">     flows </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1081.1">map</span></span><span class="koboSpan" id="kobo.1082.1">[</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1083.1">string</span></span><span class="koboSpan" id="kobo.1084.1">]testFlow</span></pre><pre class="console"><span class="koboSpan" id="kobo.1085.1">}</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.1086.1">Given </span><a id="_idIndexMarker939"/><span class="koboSpan" id="kobo.1087.1">the preceding definitions, we create a test suite for a different combination of input and output values to cover as many non-repeating scenarios </span><span class="No-Break"><span class="koboSpan" id="kobo.1088.1">as possible:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1089.1"> var testCases = []testCase{
  {
    name: "single packet",
    flows: map[string]testFlow{
      "1-1": {
        startCount:   1,
        timesSeen:    0,
        wantPosition: 0,
        wantCount:    1,
      },
    },
  },{
    name: "last packet wins",
    flows: map[string]testFlow{
      "2-1": {
        startCount:   1,
        timesSeen:    1,
        wantPosition: 1,
        wantCount:    2,
      },
      "2-2": {
        startCount:   2,
        timesSeen:    1,
        wantPosition: 0,
        wantCount:    3,
      },
    },
  },</span></pre>
<p><span class="koboSpan" id="kobo.1090.1">We tie </span><a id="_idIndexMarker940"/><span class="koboSpan" id="kobo.1091.1">all this together in the body of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1092.1">TestHeap</span></strong><span class="koboSpan" id="kobo.1093.1"> function, where we iterate over all test cases. </span><span class="koboSpan" id="kobo.1093.2">For each test case, we set up its preconditions, push all flows on the heap, and update their count </span><strong class="source-inline"><span class="koboSpan" id="kobo.1094.1">timeSeen</span></strong><span class="koboSpan" id="kobo.1095.1"> number </span><span class="No-Break"><span class="koboSpan" id="kobo.1096.1">of times:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1097.1">func </span></span><span class="koboSpan" id="kobo.1098.1">TestHeap(t *testing.T) {
     </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1099.1">for </span></span><span class="koboSpan" id="kobo.1100.1">_, test :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1101.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.1102.1">range </span></span><span class="koboSpan" id="kobo.1103.1">testCases {
           h :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1104.1">=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.1105.1">make</span></span><span class="koboSpan" id="kobo.1106.1">(Heap, 0)
           </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1107.1">// pushing flow on the heap</span></span><span class="koboSpan" id="kobo.1108.1">
           </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1109.1">for </span></span><span class="koboSpan" id="kobo.1110.1">key, f :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1111.1">=</span></span> <span class="Code_Purple"><span class="koboSpan" id="kobo.1112.1">range </span></span><span class="koboSpan" id="kobo.1113.1">test.flows {
                      flow :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1114.1">=</span></span> <span class="Code_Red"><span class="koboSpan" id="kobo.1115.1">&amp;</span></span><span class="koboSpan" id="kobo.1116.1">MyFlow{
                           Count: f.startCount,
                           Key:   key,
                      }
                      heap.Push(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1117.1">&amp;</span></span><span class="koboSpan" id="kobo.1118.1">h, flow)
                      </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1119.1">// updating packet counts</span></span><span class="koboSpan" id="kobo.1120.1">
                      </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1121.1">for </span></span><span class="koboSpan" id="kobo.1122.1">j :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1123.1">=</span></span><span class="koboSpan" id="kobo.1124.1"> 0; j </span><span class="Code_Red"><span class="koboSpan" id="kobo.1125.1">&lt;</span></span><span class="koboSpan" id="kobo.1126.1"> f.timesSeen; j</span><span class="Code_Red"><span class="koboSpan" id="kobo.1127.1">++</span></span><span class="koboSpan" id="kobo.1128.1"> {
                           h.update(flow)
                      }
           }
     </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1129.1">/* ... </span><span class="koboSpan" id="kobo.1129.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.1129.3">*/</span></span><span class="koboSpan" id="kobo.1130.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.1131.1">Once</span><a id="_idIndexMarker941"/><span class="koboSpan" id="kobo.1132.1"> we have updated all flows, we remove them off the heap, one by one, based on the highest count, and check whether the resulting position and count match what we had described in the test case. </span><span class="koboSpan" id="kobo.1132.2">In case of a mismatch, we generate an error message using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1133.1">*testing.T</span></strong><span class="koboSpan" id="kobo.1134.1"> type injected by the </span><span class="No-Break"><span class="koboSpan" id="kobo.1135.1">testing package:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1136.1">func </span></span><span class="koboSpan" id="kobo.1137.1">TestHeap(t *testing.T) {
  </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1138.1">/* ... </span><span class="koboSpan" id="kobo.1138.2">&lt; continues from before &gt; ... </span><span class="koboSpan" id="kobo.1138.3">*/</span></span><span class="koboSpan" id="kobo.1139.1">
  </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1140.1">for </span></span><span class="koboSpan" id="kobo.1141.1">i :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1142.1">=</span></span><span class="koboSpan" id="kobo.1143.1"> 0; h.Len() &gt; 0; i</span><span class="Code_Red"><span class="koboSpan" id="kobo.1144.1">++</span></span><span class="koboSpan" id="kobo.1145.1"> {
                f :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1146.1">=</span></span><span class="koboSpan" id="kobo.1147.1"> heap.Pop(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1148.1">&amp;</span></span><span class="koboSpan" id="kobo.1149.1">h).(*MyFlow)
                tf :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1150.1">=</span></span><span class="koboSpan" id="kobo.1151.1"> test.flows[f.Key]
                </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1152.1">if </span></span><span class="koboSpan" id="kobo.1153.1">tf.wantPosition </span><span class="Code_Red"><span class="koboSpan" id="kobo.1154.1">!=</span></span><span class="koboSpan" id="kobo.1155.1"> i {
                           t.Errorf(
                             </span><span class="Code_Red"><span class="koboSpan" id="kobo.1156.1">"%s: unexpected position for packet key %s: got %d, want %d"</span></span><span class="koboSpan" id="kobo.1157.1">, test.name, f.Key, i, tf.wantPosition)
                }
                </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1158.1">if </span></span><span class="koboSpan" id="kobo.1159.1">tf.wantCount != f.Count {
                           t.Errorf(
                                 </span><span class="Code_Red"><span class="koboSpan" id="kobo.1160.1">"%s: unexpected count for packet key %s: got %d, want %d"</span></span><span class="koboSpan" id="kobo.1161.1">, test.name, f.Key, f.Count, tf.wantCount)
                }
           }
}</span></pre>
<p><span class="koboSpan" id="kobo.1162.1">Thus far, we’ve </span><a id="_idIndexMarker942"/><span class="koboSpan" id="kobo.1163.1">only discussed data plane telemetry, which is crucial, but not the only element of network monitoring. </span><span class="koboSpan" id="kobo.1163.2">In the following section, we will explore network control plane telemetry by building a complete end-to-end telemetry </span><span class="No-Break"><span class="koboSpan" id="kobo.1164.1">processing pipeline.</span></span></p>
<h1 id="_idParaDest-239"><a id="_idTextAnchor238"/><span class="koboSpan" id="kobo.1165.1">Measuring control plane performance</span></h1>
<p><span class="koboSpan" id="kobo.1166.1">Most </span><a id="_idIndexMarker943"/><span class="koboSpan" id="kobo.1167.1">network engineers are familiar with tools such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1168.1">ping</span></strong><span class="koboSpan" id="kobo.1169.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1170.1">traceroute</span></strong><span class="koboSpan" id="kobo.1171.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1172.1">iperf</span></strong><span class="koboSpan" id="kobo.1173.1"> to verify network data plane connectivity, reachability, and throughput. </span><span class="koboSpan" id="kobo.1173.2">At the same time, control plane performance often remains a black box, and we can only assume how long it takes for our network to re-converge. </span><span class="koboSpan" id="kobo.1173.3">In this section, we aim to address this problem by building a control plane </span><span class="No-Break"><span class="koboSpan" id="kobo.1174.1">telemetry solution.</span></span></p>
<p><span class="koboSpan" id="kobo.1175.1">Modern control plane protocols, such as BGP, distribute large volumes of information from IP routes to MAC addresses and flow definitions. </span><span class="koboSpan" id="kobo.1175.2">As the size of our networks grows, so does the churn rate of the control plane state, with users, VMs, and applications constantly moving between different locations and network segments. </span><span class="koboSpan" id="kobo.1175.3">Hence, it’s critical to have visibility of how well our control plane performs to troubleshoot network issues and take any </span><span class="No-Break"><span class="koboSpan" id="kobo.1176.1">preemptive actions.</span></span></p>
<p><span class="koboSpan" id="kobo.1177.1">The next code example covers the telemetry processing pipeline we built to monitor the control plane performance of the lab network. </span><span class="koboSpan" id="kobo.1177.2">At the heart of it, there is a special </span><strong class="source-inline"><span class="koboSpan" id="kobo.1178.1">bgp-ping</span></strong><span class="koboSpan" id="kobo.1179.1"> application that allows us to measure the round-trip time of a BGP update. </span><span class="koboSpan" id="kobo.1179.2">In this solution, we take advantage of the</span><a id="_idIndexMarker944"/><span class="koboSpan" id="kobo.1180.1"> features of the following Go packages </span><span class="No-Break"><span class="koboSpan" id="kobo.1181.1">and applications:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1182.1">jwhited/corebgp</span></strong><span class="koboSpan" id="kobo.1183.1">: A pluggable implementation of a BGP finite state machine that allows you to run arbitrary actions for different </span><span class="No-Break"><span class="koboSpan" id="kobo.1184.1">BGP states.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1185.1">osrg/gobgp</span></strong><span class="koboSpan" id="kobo.1186.1">: One of the most popular BGP implementations in Go; we use it to encode and decode </span><span class="No-Break"><span class="koboSpan" id="kobo.1187.1">BGP messages.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1188.1">cloudprober/cloudprober</span></strong><span class="koboSpan" id="kobo.1189.1">: A flexible distributed probing and </span><span class="No-Break"><span class="koboSpan" id="kobo.1190.1">monitoring framework.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1191.1">Prometheus</span></strong><span class="koboSpan" id="kobo.1192.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1193.1">Grafana</span></strong><span class="koboSpan" id="kobo.1194.1">: A popular monitoring and visualization </span><span class="No-Break"><span class="koboSpan" id="kobo.1195.1">software stack.</span></span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer085">
<span class="koboSpan" id="kobo.1196.1"><img alt="Figure 10.5 – Telemetry pipeline architecture" src="image/B16971_10_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1197.1">Figure 10.5 – Telemetry pipeline architecture</span></p>
<p><span class="koboSpan" id="kobo.1198.1">To bring up this entire setup, you can run </span><strong class="source-inline"><span class="koboSpan" id="kobo.1199.1">make bgp-ping-start</span></strong><span class="koboSpan" id="kobo.1200.1"> from the root of this book’s GitHub</span><a id="_idIndexMarker945"/><span class="koboSpan" id="kobo.1201.1"> repository (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1202.1">Further reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1203.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1204.1">Network-Automation-with-Go $ make bgp-ping-start
cd ch10/bgp-ping; go build -o bgp-ping main.go
docker exec -d clab-netgo-host-3 /workdir/bgp-ping/bgp-ping -id host-3 -nlri 100.64.0.2 -laddr 203.0.113.254 -raddr 203.0.113.129 -las 65005 -ras 65002 -p
docker exec -d clab-netgo-host-1 /workdir/bgp-ping/bgp-ping -id host-1 -nlri 100.64.0.0 -laddr 203.0.113.0 -raddr 203.0.113.1 -las 65003 -ras 65000 -p
docker exec -d clab-netgo-host-2 /cloudprober -config_file /workdir/workdir/cloudprober.cfg
cd ch10/bgp-ping; docker-compose up -d; cd ../../
Creating prometheus ... </span><span class="koboSpan" id="kobo.1204.2">done
Creating grafana    ... </span><span class="koboSpan" id="kobo.1204.3">done
http://localhost:3000</span></pre>
<p><span class="koboSpan" id="kobo.1205.1">The final line of the preceding output shows the URL that you can use to access the deployed instance of Grafana, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1206.1">admin</span></strong><span class="koboSpan" id="kobo.1207.1"> as both </span><strong class="source-inline"><span class="koboSpan" id="kobo.1208.1">username</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1209.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1210.1">password</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1211.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer086">
<span class="koboSpan" id="kobo.1212.1"><img alt="Figure 10.6 – BGP ping dashboard" src="image/B16971_10_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1213.1">Figure 10.6 – BGP ping dashboard</span></p>
<p><span class="koboSpan" id="kobo.1214.1">This</span><a id="_idIndexMarker946"/><span class="koboSpan" id="kobo.1215.1"> instance has a pre-created dashboard called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1216.1">BGP-Ping</span></strong><span class="koboSpan" id="kobo.1217.1"> that plots the graph of BGP round-trip times </span><span class="No-Break"><span class="koboSpan" id="kobo.1218.1">in milliseconds.</span></span></p>
<p><span class="koboSpan" id="kobo.1219.1">It’s important to note that there’s a lot more to routing protocol convergence and performance than the update propagation time. </span><span class="koboSpan" id="kobo.1219.2">Other important factors may include update churn due to transient events </span><a id="_idIndexMarker947"/><span class="koboSpan" id="kobo.1220.1">or </span><strong class="bold"><span class="koboSpan" id="kobo.1221.1">Forwarding Information Base</span></strong><span class="koboSpan" id="kobo.1222.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1223.1">FIB)</span></strong><span class="koboSpan" id="kobo.1224.1"> programming time. </span><span class="koboSpan" id="kobo.1224.2">We focus on a single-dimension metric in this example, but in reality, you may want to consider other performance metrics </span><span class="No-Break"><span class="koboSpan" id="kobo.1225.1">as well.</span></span></p>
<h1 id="_idParaDest-240"><a id="_idTextAnchor239"/><span class="koboSpan" id="kobo.1226.1">Measuring BGP Update propagation time</span></h1>
<p><span class="koboSpan" id="kobo.1227.1">As the</span><a id="_idIndexMarker948"/><span class="koboSpan" id="kobo.1228.1"> standard </span><strong class="source-inline"><span class="koboSpan" id="kobo.1229.1">ping</span></strong><span class="koboSpan" id="kobo.1230.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1231.1">bgp-ping</span></strong><span class="koboSpan" id="kobo.1232.1"> application works by sending and receiving probe messages. </span><span class="koboSpan" id="kobo.1232.2">A sender embeds a probe in a BGP Update message and sends it to its BGP neighbor. </span><span class="koboSpan" id="kobo.1232.3">We encode the probe as a custom BGP optional transitive attribute, which allows it to propagate transparently throughout the network until it reaches one of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1233.1">bgp-ping</span></strong><span class="koboSpan" id="kobo.1234.1"> responders. </span></p>
<p><span class="koboSpan" id="kobo.1235.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.1236.1">bgp-ping</span></strong><span class="koboSpan" id="kobo.1237.1"> responder</span><a id="_idIndexMarker949"/><span class="koboSpan" id="kobo.1238.1"> recognizes this custom transitive attribute and reflects it back to the sender. </span><span class="koboSpan" id="kobo.1238.2">This gives the sender a measure of BGP Update propagation delay within the network, which is then reported to an external metric consumer or printed on </span><span class="No-Break"><span class="koboSpan" id="kobo.1239.1">a screen.</span></span></p>
<p><span class="koboSpan" id="kobo.1240.1">Since</span><a id="_idIndexMarker950"/><span class="koboSpan" id="kobo.1241.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1242.1">bgp-ping</span></strong><span class="koboSpan" id="kobo.1243.1"> application needs to inter-operate with real BGP stacks, at the very least it has to implement the initial exchange of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1244.1">Open</span></strong><span class="koboSpan" id="kobo.1245.1"> messages to negotiate the BGP session capabilities, followed by the periodic exchange of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1246.1">Keepalive</span></strong><span class="koboSpan" id="kobo.1247.1"> messages. </span><span class="koboSpan" id="kobo.1247.2">We also need to do </span><span class="No-Break"><span class="koboSpan" id="kobo.1248.1">the following:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1249.1">Send BGP Update messages triggered by </span><span class="No-Break"><span class="koboSpan" id="kobo.1250.1">different events.</span></span></li>
<li><span class="koboSpan" id="kobo.1251.1">Encode and decode custom </span><span class="No-Break"><span class="koboSpan" id="kobo.1252.1">BGP attributes.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1253.1">Let’s see how we can implement these requirements using open source Go packages </span><span class="No-Break"><span class="koboSpan" id="kobo.1254.1">and applications.</span></span></p>
<h2 id="_idParaDest-241"><a id="_idTextAnchor240"/><span class="koboSpan" id="kobo.1255.1">Event-driven BGP state machine</span></h2>
<p><span class="koboSpan" id="kobo.1256.1">We </span><a id="_idIndexMarker951"/><span class="koboSpan" id="kobo.1257.1">use CoreBGP (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1258.1">jwhited/corebgp</span></strong><span class="koboSpan" id="kobo.1259.1">) to establish a BGP session with a peer and keep it alive until it’s shut down. </span><span class="koboSpan" id="kobo.1259.2">This gets us the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1260.1">Open</span></strong><span class="koboSpan" id="kobo.1261.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1262.1">Keepalive</span></strong><span class="koboSpan" id="kobo.1263.1"> messages we </span><span class="No-Break"><span class="koboSpan" id="kobo.1264.1">just discussed.</span></span></p>
<p><span class="koboSpan" id="kobo.1265.1">Inspired by the popular DNS server CoreDNS, CoreBGP is a minimalistic BGP server that you can extend through </span><span class="No-Break"><span class="koboSpan" id="kobo.1266.1">event-driven plugins.</span></span></p>
<p><span class="koboSpan" id="kobo.1267.1">In practice, you extend the initial capabilities by building a custom implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1268.1">Plugin</span></strong><span class="koboSpan" id="kobo.1269.1"> interface. </span><span class="koboSpan" id="kobo.1269.2">This interface defines different methods that can implement user-defined behavior at certain points </span><a id="_idIndexMarker952"/><span class="koboSpan" id="kobo.1270.1">of the BGP </span><strong class="bold"><span class="koboSpan" id="kobo.1271.1">finite state </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1272.1">machine</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1273.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1274.1">FSM</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1275.1">):</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1276.1">type </span></span><span class="koboSpan" id="kobo.1277.1">Plugin </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1278.1">interface </span></span><span class="koboSpan" id="kobo.1279.1">{
     GetCapabilities(...) []Capability
     OnOpenMessage(...) *Notification
     OnEstablished(...) handleUpdate
     OnClose(...)
}</span></pre>
<p><span class="koboSpan" id="kobo.1280.1">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1281.1">bpg-ping</span></strong><span class="koboSpan" id="kobo.1282.1"> application, we only need to send and receive BGP Update messages, so we focus on implementing the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1283.1">two methods:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1284.1">OnEstablished</span></strong><span class="koboSpan" id="kobo.1285.1">: To send BGP Update messages. </span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1286.1">handleUpdate</span></strong><span class="koboSpan" id="kobo.1287.1">: We use this to process received updates, identify ping requests, and send a </span><span class="No-Break"><span class="koboSpan" id="kobo.1288.1">response message.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1289.1">The following </span><a id="_idIndexMarker953"/><span class="koboSpan" id="kobo.1290.1">diagram shows the main functional blocks of </span><span class="No-Break"><span class="koboSpan" id="kobo.1291.1">this application:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer087">
<span class="koboSpan" id="kobo.1292.1"><img alt="Figure 10.7 – BGP Ping Design" src="image/B16971_10_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1293.1">Figure 10.7 – BGP Ping Design</span></p>
<p><span class="koboSpan" id="kobo.1294.1">Let’s start the code overview by examining the BGP Update handling logic (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1295.1">handleUpdate</span></strong><span class="koboSpan" id="kobo.1296.1">). </span><span class="koboSpan" id="kobo.1296.2">Since our goal is to parse and process BGP ping probes, we can make sure we discard any other BGP updates early in the code. </span><span class="koboSpan" id="kobo.1296.3">For every BGP Update message we</span><a id="_idIndexMarker954"/><span class="koboSpan" id="kobo.1297.1"> receive, we check whether any of the BGP attributes have the custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.1298.1">bgpPingType</span></strong><span class="koboSpan" id="kobo.1299.1"> transitive attribute we created to signal the probe or ping. </span><span class="koboSpan" id="kobo.1299.2">We silently ignore BGP updates that don’t have this attribute with a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1300.1">continue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1301.1"> statement:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1302.1">import </span></span><span class="koboSpan" id="kobo.1303.1">bgp </span><span class="Code_Red"><span class="koboSpan" id="kobo.1304.1">"github.com/osrg/gobgp/v3/pkg/packet/bgp"</span></span>
<span class="Code_Purple"><span class="koboSpan" id="kobo.1305.1">const </span></span><span class="koboSpan" id="kobo.1306.1">(
     bgpPingType = 42
)
</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1307.1">func </span></span><span class="koboSpan" id="kobo.1308.1">(p *plugin) handleUpdate(
     peer corebgp.PeerConfig,
     update []</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1309.1">byte</span></span><span class="koboSpan" id="kobo.1310.1">,
) *corebgp.Notification {
 
     msg, err := bgp.ParseBGPBody(
           </span><span class="Code_Red"><span class="koboSpan" id="kobo.1311.1">&amp;</span></span><span class="koboSpan" id="kobo.1312.1">bgp.BGPHeader{Type: bgp.BGP_MSG_UPDATE},
           update,
     )
     </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1313.1">// process error</span></span><span class="koboSpan" id="kobo.1314.1">
     </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1315.1">for </span></span><span class="koboSpan" id="kobo.1316.1">_, attr := </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1317.1">range </span></span><span class="koboSpan" id="kobo.1318.1">msg.Body.
</span><span class="koboSpan" id="kobo.1318.2">                    (*bgp.BGPUpdate).PathAttributes {
           </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1319.1">if </span></span><span class="koboSpan" id="kobo.1320.1">attr.GetType() </span><span class="Code_Red"><span class="koboSpan" id="kobo.1321.1">!=</span></span><span class="koboSpan" id="kobo.1322.1"> bgpPingType {
                      </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1323.1">continue</span></span><span class="koboSpan" id="kobo.1324.1">
           }
     </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1325.1">/* ... </span><span class="koboSpan" id="kobo.1325.2">&lt;continues next &gt; ... </span><span class="koboSpan" id="kobo.1325.3">*/</span></span><span class="koboSpan" id="kobo.1326.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.1327.1">Once we have </span><a id="_idIndexMarker955"/><span class="koboSpan" id="kobo.1328.1">determined that it’s a BGP ping message, we deal with two </span><span class="No-Break"><span class="koboSpan" id="kobo.1329.1">possible scenarios:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1330.1">If it’s a </span><strong class="bold"><span class="koboSpan" id="kobo.1331.1">ping response</span></strong><span class="koboSpan" id="kobo.1332.1">, we </span><a id="_idIndexMarker956"/><span class="koboSpan" id="kobo.1333.1">calculate the round-trip time using the timestamp extracted from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1334.1">bgpPingType</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1335.1">path attribute.</span></span></li>
<li><span class="koboSpan" id="kobo.1336.1">If it’s a </span><strong class="bold"><span class="koboSpan" id="kobo.1337.1">ping request</span></strong><span class="koboSpan" id="kobo.1338.1">, we</span><a id="_idIndexMarker957"/><span class="koboSpan" id="kobo.1339.1"> trigger a ping response by sending parsed data over a channel to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1340.1">OnEstablished</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1341.1"> function:</span></span></li>
</ul>
<pre class="source-code"><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1342.1">func</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1343.1"> (p *plugin) handleUpdate(</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1344.1">  peer corebgp.PeerConfig,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1345.1">  update []</span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1346.1">byte</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1347.1">,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1348.1">) *corebgp.Notification {</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1349.1">    </span></span><span class="Code_Brown" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1350.1">/* ... </span><span class="koboSpan" id="kobo.1350.2">&lt; continues from before &gt; ... </span><span class="koboSpan" id="kobo.1350.3">*/</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1351.1">    source, dest, ts, err := parseType42(attr)</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1352.1">    </span></span><span class="Code_Brown" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1353.1">// process error</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1354.1">    sourceHost :</span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1355.1">=</span></span><span lang="en-US" xml:lang="en-US"> </span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1356.1">string</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1357.1">(bytes.Trim(source, </span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1358.1">"\x00"</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1359.1">))</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1360.1">    destHost :</span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1361.1">=</span></span><span lang="en-US" xml:lang="en-US"> </span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1362.1">string</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1363.1">(bytes.Trim(dest, </span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1364.1">"\x00"</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1365.1">))</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1366.1">    </span></span><span class="Code_Brown" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1367.1">/* ... </span><span class="koboSpan" id="kobo.1367.2">&lt;omitted for brevity &gt; ... </span><span class="koboSpan" id="kobo.1367.3">*/</span></span>
<span lang="en-US" xml:lang="en-US"> </span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1368.1">    </span></span><span class="Code_Brown" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1369.1">// if src is us, may be a response. </span><span class="koboSpan" id="kobo.1369.2">id = router-id</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1370.1">    </span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1371.1">if</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1372.1"> sourceHost </span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1373.1">==</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1374.1"> *id {</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1375.1">      rtt :</span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1376.1">=</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1377.1"> time.Since(ts).Nanoseconds()</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1378.1">      metric :</span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1379.1">=</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1380.1"> fmt.Sprintf(</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1381.1">        </span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1382.1">"bgp_ping_rtt_ms{device=%s} %f\n"</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1383.1">,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1384.1">        destHost,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1385.1">        </span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1386.1">float64</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1387.1">(rtt)/</span></span><span class="Code_Green" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1388.1">1e6</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1389.1">,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1390.1">      )</span></span>
<span lang="en-US" xml:lang="en-US"> </span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1391.1">    p.store </span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1392.1">=</span></span><span lang="en-US" xml:lang="en-US"> </span><span class="Code_Blue" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1393.1">append</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1394.1">(p.store, metric)</span></span>
<span lang="en-US" xml:lang="en-US"> </span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1395.1">return</span></span><span lang="en-US" xml:lang="en-US"> </span><span class="Code_Blue" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1396.1">nil</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1397.1">    }</span></span>
<span lang="en-US" xml:lang="en-US"> </span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1398.1">    p.pingCh </span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1399.1">&lt;-</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1400.1"> ping{source: source, ts: ts.Unix()}</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1401.1">    </span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1402.1">return</span></span><span lang="en-US" xml:lang="en-US"> </span><span class="Code_Blue" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1403.1">nil</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1404.1">}</span></span></pre>
<p><span class="koboSpan" id="kobo.1405.1">The </span><a id="_idIndexMarker958"/><span class="koboSpan" id="kobo.1406.1">event-driven logic to send BGP updates lives in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1407.1">OnEstablished()</span></strong><span class="koboSpan" id="kobo.1408.1"> method that has a three-way select statement to listen for triggers over Go channels, representing three different states of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1409.1">bgp-ping</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1410.1"> application:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1411.1">Responding to a received ping request, triggered by a request coming from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1412.1">handleUpdate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1413.1"> function</span></span></li>
<li><span class="koboSpan" id="kobo.1414.1">Firing a new ping request, triggered by an </span><span class="No-Break"><span class="koboSpan" id="kobo.1415.1">external signal</span></span></li>
<li><span class="koboSpan" id="kobo.1416.1">Sending a scheduled withdraw message at the end of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1417.1">probing cycle:</span></span></li>
</ul>
<pre class="source-code"><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1418.1">func</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1419.1"> (p *plugin) OnEstablished(</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1420.1">  peer corebgp.PeerConfig,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1421.1">  writer corebgp.UpdateMessageWriter,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1422.1">) corebgp.UpdateMessageHandler {</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1423.1">  log.Println(</span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1424.1">"peer established, starting main loop"</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1425.1">)</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1426.1">  </span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1427.1">go func</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1428.1">() {</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1429.1">    </span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1430.1">for</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1431.1"> {</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1432.1">      </span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1433.1">select</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1434.1"> {</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1435.1">      </span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1436.1">case</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1437.1"> pingReq :</span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1438.1">= &lt;-</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1439.1">p.pingCh:</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1440.1">        </span></span><span class="Code_Brown" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1441.1">// Build the ping response payload</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1442.1">        bytes, err :</span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1443.1">=</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1444.1"> p.buildUpdate(</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1445.1">                      type42PathAttr,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1446.1">                      peer.LocalAddress,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1447.1">                      peer.LocalAS,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1448.1">        )</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1449.1">        </span></span><span class="Code_Brown" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1450.1">// process error</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1451.1">        writer.WriteUpdate(bytes)</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1452.1">        </span></span><span class="Code_Brown" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1453.1">/* ... </span><span class="koboSpan" id="kobo.1453.2">&lt; schedule a withdraw &gt; ... </span><span class="koboSpan" id="kobo.1453.3">*/</span></span>
<span lang="en-US" xml:lang="en-US"> </span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1454.1">      </span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1455.1">case</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1456.1"> &lt;-p.probeCh:</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1457.1">        </span></span><span class="Code_Brown" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1458.1">// Build the ping request payload</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1459.1">        bytes, err :</span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1460.1">=</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1461.1"> p.buildUpdate(</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1462.1">                      type42PathAttr,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1463.1">                      peer.LocalAddress,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1464.1">                      peer.LocalAS,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1465.1">        )</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1466.1">        </span></span><span class="Code_Brown" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1467.1">// process error</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1468.1">        writer.WriteUpdate(bytes)</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1469.1">        </span></span><span class="Code_Brown" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1470.1">/* ... </span><span class="koboSpan" id="kobo.1470.2">&lt; schedule a withdraw &gt; ... </span><span class="koboSpan" id="kobo.1470.3">*/</span></span>
<span lang="en-US" xml:lang="en-US"> </span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1471.1">      </span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1472.1">case</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1473.1"> &lt;-withdraw.C:</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1474.1">        bytes, err :</span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1475.1">=</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1476.1"> p.buildWithdraw()</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1477.1">        </span></span><span class="Code_Brown" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1478.1">// process error</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1479.1">        writer.WriteUpdate(bytes)</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1480.1">      }</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1481.1">    }</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1482.1">  }()</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1483.1">  </span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1484.1">return</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1485.1"> p.handleUpdate</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1486.1">}</span></span></pre>
<p><span class="koboSpan" id="kobo.1487.1">One</span><a id="_idIndexMarker959"/><span class="koboSpan" id="kobo.1488.1"> caveat of CoreBGP is that it doesn’t include its own BGP message parser or builder. </span><span class="koboSpan" id="kobo.1488.2">It sends any raw bytes that may confuse or even crash a standard BGP stack, so always use it with caution. </span></p>
<p><span class="koboSpan" id="kobo.1489.1">Now, we need a way to parse and craft a BGP message, and here is where we can use another Go library </span><span class="No-Break"><span class="koboSpan" id="kobo.1490.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1491.1">GoBGP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1492.1">.</span></span></p>
<h2 id="_idParaDest-242"><a id="_idTextAnchor241"/><span class="koboSpan" id="kobo.1493.1">Encoding and decoding BGP messages</span></h2>
<p><span class="koboSpan" id="kobo.1494.1">GoBGP is a</span><a id="_idIndexMarker960"/><span class="koboSpan" id="kobo.1495.1"> full-blown BGP stack and supports most of the BGP address families and features. </span><span class="koboSpan" id="kobo.1495.2">However, since </span><a id="_idIndexMarker961"/><span class="koboSpan" id="kobo.1496.1">we already use CoreBGP </span><a id="_idIndexMarker962"/><span class="koboSpan" id="kobo.1497.1">for BGP state management, we limit the use of GoBGP to message encoding </span><span class="No-Break"><span class="koboSpan" id="kobo.1498.1">and decoding.</span></span></p>
<p><span class="koboSpan" id="kobo.1499.1">For example, whenever we need to build a BGP withdraw update message, we call a helper function (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1500.1">buildWithdraw</span></strong><span class="koboSpan" id="kobo.1501.1">) that uses GoBGP to build the message. </span><span class="koboSpan" id="kobo.1501.2">GoBGP allows us to include only the relevant information, such </span><a id="_idIndexMarker963"/><span class="koboSpan" id="kobo.1502.1">as a list of </span><strong class="bold"><span class="koboSpan" id="kobo.1503.1">Network Layer Reachability Information</span></strong><span class="koboSpan" id="kobo.1504.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1505.1">NLRI</span></strong><span class="koboSpan" id="kobo.1506.1">), while it takes care of populating the rest of the fields, such as type, length, and building a syntactically correct </span><span class="No-Break"><span class="koboSpan" id="kobo.1507.1">BGP message:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1508.1">func </span></span><span class="koboSpan" id="kobo.1509.1">(p *plugin) buildWithdraw() ([]</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1510.1">byte</span></span><span class="koboSpan" id="kobo.1511.1">, </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1512.1">error</span></span><span class="koboSpan" id="kobo.1513.1">) {
     myNLRI := bgp.NewIPAddrPrefix(</span><span class="Code_Green"><span class="koboSpan" id="kobo.1514.1">32</span></span><span class="koboSpan" id="kobo.1515.1">, p.probe.String())
     withdrawnRoutes := []*bgp.IPAddrPrefix{myNLRI}
     msg :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1516.1">=</span></span><span class="koboSpan" id="kobo.1517.1"> bgp.NewBGPUpdateMessage(
           withdrawnRoutes,
           []bgp.PathAttributeInterface{},
           </span><span class="Code_Blue"><span class="koboSpan" id="kobo.1518.1">nil</span></span><span class="koboSpan" id="kobo.1519.1">,
     )
     </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1520.1">return </span></span><span class="koboSpan" id="kobo.1521.1">msg.Body.Serialize()
}</span></pre>
<p><span class="koboSpan" id="kobo.1522.1">Here’s</span><a id="_idIndexMarker964"/><span class="koboSpan" id="kobo.1523.1"> another example of how to use GoBGP to parse a</span><a id="_idIndexMarker965"/><span class="koboSpan" id="kobo.1524.1"> message received by CoreBGP. </span><span class="koboSpan" id="kobo.1524.2">We take a slice of bytes and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1525.1">ParseBGPBody</span></strong><span class="koboSpan" id="kobo.1526.1"> function to deserialize it into GoBGP’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1527.1">BGPMessage</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1528.1"> type:</span></span></p>
<pre class="source-code"><span class="Code_Purple"><span class="koboSpan" id="kobo.1529.1">func </span></span><span class="koboSpan" id="kobo.1530.1">(p *plugin) handleUpdate(
     peer corebgp.PeerConfig,
     update []</span><span class="Code_Purple"><span class="koboSpan" id="kobo.1531.1">byte</span></span><span class="koboSpan" id="kobo.1532.1">,
) *corebgp.Notification {
     msg, err :</span><span class="Code_Red"><span class="koboSpan" id="kobo.1533.1">=</span></span><span class="koboSpan" id="kobo.1534.1"> bgp.ParseBGPBody(
           </span><span class="Code_Red"><span class="koboSpan" id="kobo.1535.1">&amp;</span></span><span class="koboSpan" id="kobo.1536.1">bgp.BGPHeader{Type: bgp.BGP_MSG_UPDATE},
           update,
     )
     </span><span class="Code_Brown"><span class="koboSpan" id="kobo.1537.1">// process error</span></span><span class="koboSpan" id="kobo.1538.1">
     </span><span class="Code_Purple"><span class="koboSpan" id="kobo.1539.1">if </span></span><span class="koboSpan" id="kobo.1540.1">err := bgp.ValidateBGPMessage(msg); err </span><span class="Code_Red"><span class="koboSpan" id="kobo.1541.1">!=</span></span> <span class="Code_Blue"><span class="koboSpan" id="kobo.1542.1">nil </span></span><span class="koboSpan" id="kobo.1543.1">{
           log.Fatal(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1544.1">"validate BGP message "</span></span><span class="koboSpan" id="kobo.1545.1">, err)
     }</span></pre>
<p><span class="koboSpan" id="kobo.1546.1">You can now further parse this BGP message to extract various path attributes and NLRIs, as we’ve seen in the earlier overview of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1547.1">handleUpdate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1548.1"> function.</span></span></p>
<h2 id="_idParaDest-243"><a id="_idTextAnchor242"/><span class="koboSpan" id="kobo.1549.1">Collecting and exposing metrics</span></h2>
<p><span class="koboSpan" id="kobo.1550.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1551.1">bgp-ping</span></strong><span class="koboSpan" id="kobo.1552.1"> application</span><a id="_idIndexMarker966"/><span class="koboSpan" id="kobo.1553.1"> can run as a standalone process and print the results on a screen. </span><span class="koboSpan" id="kobo.1553.2">We also want to be able to integrate our application into more general-purpose system monitoring solutions. </span><span class="koboSpan" id="kobo.1553.3">To do that, it needs to expose its measurement results in a standard format that an external monitoring system can understand. </span></p>
<p><span class="koboSpan" id="kobo.1554.1">You can </span><a id="_idIndexMarker967"/><span class="koboSpan" id="kobo.1555.1">implement this capability natively by adding a web server and publishing your metrics for external consumers, or you can use an existing tool that collects and exposes metrics on behalf of your application. </span><span class="koboSpan" id="kobo.1555.2">One tool that does this is Cloudprober, which enables automated and distributed probing and monitoring, and offers native Go integration with several external probes. </span></p>
<p><span class="koboSpan" id="kobo.1556.1">We integrate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1557.1">bgp-ping</span></strong><span class="koboSpan" id="kobo.1558.1"> application with the Cloudprober via its </span><strong class="source-inline"><span class="koboSpan" id="kobo.1559.1">serverutils</span></strong><span class="koboSpan" id="kobo.1560.1"> package, which allows you to exchange probe requests and </span><a id="_idIndexMarker968"/><span class="koboSpan" id="kobo.1561.1">replies over</span><a id="_idIndexMarker969"/><span class="koboSpan" id="kobo.1562.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.1563.1">standard input (stdin)</span></strong><span class="koboSpan" id="kobo.1564.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.1565.1">standard output (stdout)</span></strong><span class="koboSpan" id="kobo.1566.1">. </span><span class="koboSpan" id="kobo.1566.2">When we start </span><strong class="source-inline"><span class="koboSpan" id="kobo.1567.1">bgp-ping</span></strong><span class="koboSpan" id="kobo.1568.1"> with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1569.1">-c</span></strong><span class="koboSpan" id="kobo.1570.1"> flag, it expects all probe triggers to come from Cloudprober and sends its results back in a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1571.1">ProbeReply</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1572.1"> message:</span></span></p>
<pre class="source-code"><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1573.1">func</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1574.1"> main() {</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1575.1">  </span></span><span class="Code_Brown" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1576.1">/* ... </span><span class="koboSpan" id="kobo.1576.2">&lt; continues from before &gt; ... </span><span class="koboSpan" id="kobo.1576.3">*/</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1577.1">  probeCh :</span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1578.1">=</span></span><span lang="en-US" xml:lang="en-US"> </span><span class="Code_Blue" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1579.1">make</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1580.1">(</span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1581.1">chan struct</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1582.1">{})</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1583.1">  resultsCh :</span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1584.1">=</span></span><span lang="en-US" xml:lang="en-US"> </span><span class="Code_Blue" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1585.1">make</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1586.1">(</span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1587.1">chan string</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1588.1">)</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1589.1">  </span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1590.1">  peerPlugin :</span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1591.1">= &amp;</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1592.1">plugin{</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1593.1">              probeCh: probeCh,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1594.1">            resultsCh: resultsCh,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1595.1">  }</span></span>
<span lang="en-US" xml:lang="en-US"> </span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1596.1">  </span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1597.1">if</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1598.1"> *cloudprober {</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1599.1">    </span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1600.1">go func</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1601.1">() {</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1602.1">      serverutils.Serve(</span></span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1603.1">func</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1604.1">(</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1605.1">        request *epb.ProbeRequest,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1606.1">        reply *epb.ProbeReply,</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1607.1">      ) {</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1608.1">        probeCh </span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1609.1">&lt;-</span></span><span lang="en-US" xml:lang="en-US"> </span><span class="Code_Purple" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1610.1">struct</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1611.1">{}{}</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1612.1">        reply.Payload </span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1613.1">=</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1614.1"> proto.String(</span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1615.1">&lt;-</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1616.1">resultsCh)</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1617.1">        if err </span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1618.1">!=</span></span><span lang="en-US" xml:lang="en-US"> </span><span class="Code_Blue" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1619.1">nil</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1620.1"> {</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1621.1">          reply.ErrorMessage </span></span><span class="Code_Red" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1622.1">=</span></span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1623.1"> proto.String(err.Error())</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1624.1">        }</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1625.1">      })</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1626.1">    }()</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1627.1">  }</span></span>
<span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1628.1">}</span></span></pre>
<p><span class="koboSpan" id="kobo.1629.1">The</span><a id="_idIndexMarker970"/><span class="koboSpan" id="kobo.1630.1"> Cloudprober application itself runs as a pre-compiled </span><a id="_idIndexMarker971"/><span class="koboSpan" id="kobo.1631.1">binary and requires minimal configuration to tell it about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1632.1">bgp-ping</span></strong><span class="koboSpan" id="kobo.1633.1"> application and its </span><span class="No-Break"><span class="koboSpan" id="kobo.1634.1">runtime options:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1635.1">probe {
  name: "bgp_ping"
  type: EXTERNAL
  targets { dummy_targets {} }
  timeout_msec: 11000
  interval_msec: 10000
  external_probe {
    mode: SERVER
    command: "/workdir/bgp-ping/bgp-ping -id host-2 -nlri 100.64.0.1 -laddr 203.0.113.2 -raddr 203.0.113.3 -las 65004 -ras 65001 -c true"
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.1636.1">All </span><a id="_idIndexMarker972"/><span class="koboSpan" id="kobo.1637.1">measurement </span><a id="_idIndexMarker973"/><span class="koboSpan" id="kobo.1638.1">results are automatically published by Cloudprober in a format that most popular cloud monitoring systems </span><span class="No-Break"><span class="koboSpan" id="kobo.1639.1">can understand.</span></span></p>
<h2 id="_idParaDest-244"><a id="_idTextAnchor243"/><span class="koboSpan" id="kobo.1640.1">Storing and visualizing metrics</span></h2>
<p><span class="koboSpan" id="kobo.1641.1">The </span><a id="_idIndexMarker974"/><span class="koboSpan" id="kobo.1642.1">final stage in this control plane telemetry processing pipeline is metrics storage and visualization. </span><span class="koboSpan" id="kobo.1642.2">Go is a very popular choice for these systems, with examples including Telegraf, InfluxDB, Prometheus, </span><span class="No-Break"><span class="koboSpan" id="kobo.1643.1">and Grafana.</span></span></p>
<p><span class="koboSpan" id="kobo.1644.1">The current </span><a id="_idIndexMarker975"/><span class="koboSpan" id="kobo.1645.1">telemetry processing example includes Prometheus and Grafana with their respective configuration files and pre-built dashboards. </span><span class="koboSpan" id="kobo.1645.2">The following configuration snippet points Prometheus at the local Cloudprober instance and tells it to scrape all available metrics every </span><span class="No-Break"><span class="koboSpan" id="kobo.1646.1">10 seconds:</span></span></p>
<pre class="source-code"><span class="Code_Blue"><span class="koboSpan" id="kobo.1647.1">scrape_configs</span></span><span class="koboSpan" id="kobo.1648.1">:
  - </span><span class="Code_Blue"><span class="koboSpan" id="kobo.1649.1">job_name</span></span><span class="koboSpan" id="kobo.1650.1">: </span><span class="Code_Red"><span class="koboSpan" id="kobo.1651.1">'bgp-ping'</span></span><span class="koboSpan" id="kobo.1652.1">
    </span><span class="Code_Blue"><span class="koboSpan" id="kobo.1653.1">scrape_interval</span></span><span class="koboSpan" id="kobo.1654.1">: 10s
    </span><span class="Code_Blue"><span class="koboSpan" id="kobo.1655.1">static_configs</span></span><span class="koboSpan" id="kobo.1656.1">:
      - </span><span class="Code_Blue"><span class="koboSpan" id="kobo.1657.1">targets</span></span><span class="koboSpan" id="kobo.1658.1">: [</span><span class="Code_Red"><span class="koboSpan" id="kobo.1659.1">'clab-netgo-host-2:9313'</span></span><span class="koboSpan" id="kobo.1660.1">]</span></pre>
<p><span class="koboSpan" id="kobo.1661.1">Although we discuss little of it here, building meaningful dashboards and alerts is as important as doing the measurements. </span><span class="koboSpan" id="kobo.1661.2">Distributed systems observability is a big topic that is extensively covered in existing books and online resources. </span><span class="koboSpan" id="kobo.1661.3">For now, we will stop at the point where we see a visual representation of the data in a Grafana dashboard but don’t want to</span><a id="_idIndexMarker976"/><span class="koboSpan" id="kobo.1662.1"> imply that a continuous linear</span><a id="_idIndexMarker977"/><span class="koboSpan" id="kobo.1663.1"> graph of absolute values is enough. </span><span class="koboSpan" id="kobo.1663.2">Most likely, to make any reasonable assumptions, you’d want to present your data as an aggregated distribution and monitor its outlying values over time, as this would give a better sign of increasing system stress and may serve as a trigger for any </span><span class="No-Break"><span class="koboSpan" id="kobo.1664.1">further actions.</span></span></p>
<h1 id="_idParaDest-245"><a id="_idTextAnchor244"/><span class="koboSpan" id="kobo.1665.1">Developing distributed applications</span></h1>
<p><span class="koboSpan" id="kobo.1666.1">Building</span><a id="_idIndexMarker978"/><span class="koboSpan" id="kobo.1667.1"> a distributed application, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1668.1">bgp-ping</span></strong><span class="koboSpan" id="kobo.1669.1">, can be a major undertaking. </span><span class="koboSpan" id="kobo.1669.2">Unit testing and debugging can help spot and fix a lot of bugs, but these processes can be time-consuming. </span><span class="koboSpan" id="kobo.1669.3">In certain cases, when an application has different components, developing your code iteratively may require some manual orchestration. </span><span class="koboSpan" id="kobo.1669.4">Steps such as building binary files and container images, starting the software process, enabling logging, and triggering events are now something you need to synchronize and repeat for all the components that include your application. </span></p>
<p><span class="koboSpan" id="kobo.1670.1">The final developer experience tool that we will cover in this chapter was specifically designed to address the preceding issues. </span><span class="koboSpan" id="kobo.1670.2">Tilt helps developers automate manual steps, and it has native integration with container and orchestration platforms, such as Kubernetes or Docker Compose. </span><span class="koboSpan" id="kobo.1670.3">You let it know which files to monitor, and it will automatically rebuild your binaries, swap out container images, and restart existing processes, all while showing you the output logs of all applications on a </span><span class="No-Break"><span class="koboSpan" id="kobo.1671.1">single screen.</span></span></p>
<p><span class="koboSpan" id="kobo.1672.1">It works by reading a special </span><strong class="source-inline"><span class="koboSpan" id="kobo.1673.1">Tiltfile</span></strong><span class="koboSpan" id="kobo.1674.1"> containing a set of instructions on what to build and how to do it. </span><span class="koboSpan" id="kobo.1674.2">Here’s a snippet from a Tiltfile that automatically launches a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1675.1">bgp-ping</span></strong><span class="koboSpan" id="kobo.1676.1"> process inside one of the host containers and restarts it every time it detects a change </span><span class="No-Break"><span class="koboSpan" id="kobo.1677.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1678.1">main.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1679.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1680.1">local_resource(</span><span class="Code_Red"><span class="koboSpan" id="kobo.1681.1">'host-1'</span></span><span class="koboSpan" id="kobo.1682.1">,
  serve_cmd=</span><span class="Code_Red"><span class="koboSpan" id="kobo.1683.1">'ip netns exec clab-netgo-host-1 go run main.go -id host-1 -nlri 100.64.0.0 -laddr 203.0.113.0 -raddr 203.0.113.1 -las 65003 -ras 65000 -p'</span></span><span class="koboSpan" id="kobo.1684.1">,
  deps=[</span><span class="Code_Red"><span class="koboSpan" id="kobo.1685.1">'./main.go'</span></span><span class="koboSpan" id="kobo.1686.1">])</span></pre>
<p><span class="koboSpan" id="kobo.1687.1">The full </span><strong class="source-inline"><span class="koboSpan" id="kobo.1688.1">Tiltfile</span></strong><span class="koboSpan" id="kobo.1689.1"> has two more resources for the other two hosts in our lab network. </span><span class="koboSpan" id="kobo.1689.2">You can </span><a id="_idIndexMarker979"/><span class="koboSpan" id="kobo.1690.1">bring up all three parts of the application with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1691.1">sudo </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1692.1">tilt up</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1693.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1694.1">Network-Automation-with-Go </span><span class="Code_ligh-Blue"><span class="koboSpan" id="kobo.1695.1">$ cd </span></span><span class="koboSpan" id="kobo.1696.1">ch10/bgp-ping
Network-Automation-with-Go/ch10/bgp-ping </span><span class="Code_ligh-Blue"><span class="koboSpan" id="kobo.1697.1">$ sudo </span></span><span class="koboSpan" id="kobo.1698.1">tilt up
Tilt started on http://localhost:10350/</span></pre>
<p><span class="koboSpan" id="kobo.1699.1">Tilt has both a console (text) and a web UI that you can use to view the logs of </span><span class="No-Break"><span class="koboSpan" id="kobo.1700.1">all resources:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer088">
<span class="koboSpan" id="kobo.1701.1"><img alt="Figure 10.8 – Tilt" src="image/B16971_10_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1702.1">Figure 10.8 – Tilt</span></p>
<p><span class="koboSpan" id="kobo.1703.1">Any change to the source code of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1704.1">bgp-ping</span></strong><span class="koboSpan" id="kobo.1705.1"> application would trigger a restart of all affected resources. </span><span class="koboSpan" id="kobo.1705.2">By automating a lot of manual steps and aggregating the logs, this tool can simplify the development process of any </span><span class="No-Break"><span class="koboSpan" id="kobo.1706.1">distributed application.</span></span></p>
<h1 id="_idParaDest-246"><a id="_idTextAnchor245"/><span class="koboSpan" id="kobo.1707.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1708.1">This concludes the chapter about network monitoring. </span><span class="koboSpan" id="kobo.1708.2">We have only touched upon a few selected subjects and admit that the topic of this chapter is too vast to cover in this book. </span><span class="koboSpan" id="kobo.1708.3">However, we hope we have provided enough resources, pointers, and ideas for you to continue the exploration of network monitoring, as it’s one of the most vibrant and actively growing areas of the network </span><span class="No-Break"><span class="koboSpan" id="kobo.1709.1">engineering discipline.</span></span></p>
<h1 id="_idParaDest-247"><a id="_idTextAnchor246"/><span class="koboSpan" id="kobo.1710.1">Further reading</span></h1>
<ul>
<li><span class="koboSpan" id="kobo.1711.1">Book’s GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.1712.1">repository: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go"><span class="No-Break"><span class="koboSpan" id="kobo.1713.1">https://github.com/PacktPublishing/Network-Automation-with-Go</span></span></a></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1714.1">google/gopacket</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1715.1">package: </span></span><a href="https://github.com/google/gopacket"><span class="No-Break"><span class="koboSpan" id="kobo.1716.1">https://github.com/google/gopacket</span></span></a></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1717.1">gdb</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1718.1">documentation: </span></span><a href="https://go.dev/doc/gdb"><span class="No-Break"><span class="koboSpan" id="kobo.1719.1">https://go.dev/doc/gdb</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1720.1">vscode-go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1721.1">: </span></span><a href="https://code.visualstudio.com/docs/languages/go"><span class="No-Break"><span class="koboSpan" id="kobo.1722.1">https://code.visualstudio.com/docs/languages/go</span></span></a></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1723.1">ch10/packet-capture/.vscode/launch.json</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1724.1">: </span></span><a href="https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch10/packet-capture/.vscode/launch.json"><span class="No-Break"><span class="koboSpan" id="kobo.1725.1">https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch10/packet-capture/.vscode/launch.json</span></span></a></li>
<li><span class="koboSpan" id="kobo.1726.1">Open source components with ready-to-use </span><span class="No-Break"><span class="koboSpan" id="kobo.1727.1">examples: </span></span><a href="https://github.com/netsampler/goflow2/tree/main/compose/kcg"><span class="No-Break"><span class="koboSpan" id="kobo.1728.1">https://github.com/netsampler/goflow2/tree/main/compose/kcg</span></span></a></li>
<li><span class="koboSpan" id="kobo.1729.1">CoreBGP </span><span class="No-Break"><span class="koboSpan" id="kobo.1730.1">documentation: </span></span><a href="https://pkg.go.dev/github.com/jwhited/corebgp#section-readme"><span class="No-Break"><span class="koboSpan" id="kobo.1731.1">https://pkg.go.dev/github.com/jwhited/corebgp#section-readme</span></span></a></li>
</ul>
</div>
</body></html>