["```go\nimport (\n     \"github.com/google/gopacket/pcapgo\"\n)\nvar (\n     intf = flag.String(\"intf\", \"eth0\", \"interface\")\n)\nfunc main() {\n     handle, err := pcapgo.NewEthernetHandle(*intf)\n     /* ... <continues next > ... */\n}\n```", "```go\n$ sudo tcpdump -p -ni eth0 -d \"ip and udp\"\n(000) ldh      [12]\n(001) jeq      #0x800           jt 2    jf 5\n(002) ldb      [23]\n(003) jeq      #0x11            jt 4    jf 5\n(004) ret      #262144\n(005) ret      #0\n```", "```go\nimport (\n  \"golang.org/x/net/bpf\"\n)\n\nfunc main() {\n/* ... <continues from before > ... */\n\n  rawInstructions, err := bpf.Assemble([]bpf.Instruction{\n    // Load \"EtherType\" field from the ethernet header.\n    bpf.LoadAbsolute{Off: 12, Size: 2},\n    // Skip to last instruction if EtherType isn't IPv4.\n    bpf.JumpIf{Cond: bpf.JumpNotEqual, Val: 0x800,\n                    SkipTrue: 3},\n    // Load \"Protocol\" field from the IPv4 header.\n    bpf.LoadAbsolute{Off: 23, Size: 1},\n    // Skip to the last instruction if Protocol is not UDP.\n    bpf.JumpIf{Cond: bpf.JumpNotEqual, Val: 0x11,\n                    SkipTrue: 1},\n    // \"send up to 4k of the packet to userspace.\"\n    bpf.RetConstant{Val: 4096},\n    // Verdict is \"ignore packet and return to the stack.\"\n    bpf.RetConstant{Val: 0},\n  })\n\n  handle.SetBPF(rawInstructions)\n  /* ... <continues next > ... */\n}\n```", "```go\nfunc main() {\n  /* ... <continues from before > ... */\n     packetSource := gopacket.NewPacketSource(\n           handle,\n           layers.LayerTypeEthernet,\n     )\n     /* ... <continues next > ... */\n}\n```", "```go\nfunc main() {\n  /* ... <continues from before > ... */\n  for packet := range packetSource.Packets() {\n    sflowLayer := packet.Layer(layers.LayerTypeSFlow)\n    if sflowLayer != nil {\n      sflow, ok := sflowLayer.(*layers.SFlowDatagram)\n      if !ok {\n        continue\n      }\n\n      for _, sample := range sflow.FlowSamples {\n        for _, record := range sample.GetRecords() {\n          p, ok := record.(layers.SFlowRawPacketFlowRecord)\n          if !ok {\n            log.Println(\"failed to decode sflow record\")\n            continue\n          }\n\n          srcIP, dstIP := p.Header.\n            NetworkLayer().\n            NetworkFlow().\n            Endpoints()\n          sPort, dPort := p.Header.\n            TransportLayer().\n            TransportFlow().\n            Endpoints()\n          log.Printf(\"flow record: %s:%s <-> %s:%s\\n\",\n            srcIP,\n            sPort,\n            dstIP,\n            dPort,\n          )\n        }\n      }\n     }\n  }\n}\n```", "```go\n$ make capture-start\ndocker exec -d clab-netgo-cvx systemctl restart hsflowd\ndocker exec -d clab-netgo-host-3 ./ethr -s\ndocker exec -d clab-netgo-host-1 ./ethr -c 203.0.113.253 -b 900K -d 60s -p udp -l 1KB\ndocker exec -d clab-netgo-host-1 ./ethr -c 203.0.113.252 -b 600K -d 60s -p udp -l 1KB\ndocker exec -d clab-netgo-host-1 ./ethr -c 203.0.113.251 -b 400K -d 60s -p udp -l 1KB\ncd ch10/packet-capture; go build -o packet-capture main.go\ndocker exec -it clab-netgo-host-2 /workdir/packet-capture/packet-capture\n2022/02/28 21:50:25  flow record: 203.0.113.0:60087 <-> 203.0.113.252:8888\n2022/02/28 21:50:25  flow record: 203.0.113.0:60087 <-> \n203.0.113.252:8888\n2022/02/28 21:50:27  flow record: 203.0.113.0:40986 <-> 203.0.113.252:8888\n2022/02/28 21:50:29  flow record: 203.0.113.0:60087 <-> 203.0.113.252:8888\n2022/02/28 21:50:29  flow record: 203.0.113.0:49138 <-> 203.0.113.251:8888\n2022/02/28 21:50:30  flow record: 203.0.113.0:60087 <-> 203.0.113.252:8888\n2022/02/28 21:50:30  flow record: 203.0.113.0:49138 <-> 203.0.113.251:8888\n```", "```go\n$ make traffic-start\ndocker exec -d clab-netgo-cvx systemctl restart hsflowd\ndocker exec -d clab-netgo-host-3 ./ethr -s\ndocker exec -d clab-netgo-host-1 ./ethr -c 203.0.113.253 -b 900K -d 60s -p udp -l 1KB\ndocker exec -d clab-netgo-host-1 ./ethr -c 203.0.113.252 -b 600K -d 60s -p udp -l 1KB\ndocker exec -d clab-netgo-host-1 ./ethr -c 203.0.113.251 -b 400K -d 60s -p udp -l 1KB\n```", "```go\n$ docker exec -it clab-netgo-host-2 bash\nroot@host-2:/# cd workdir/ch10/packet-capture/\nroot@host-2:/workdir/packet-capture# dlv debug main.go\n```", "```go\n(dlv) break main.go:49\nBreakpoint 1 set at 0x5942ce for main.main() ./main.go:49\n(dlv) continue\n> main.main() ./main.go:49 (hits goroutine(1):1 total:1) (PC: 0x5942ce)\n    44:    packetSource := gopacket.NewPacketSource(\n    45:      handle,\n    46:      layers.LayerTypeEthernet,\n    47:    )\n    48:    for packet := range packetSource.Packets() {\n=>  49:      if l4 := packet.TransportLayer(); l4 == nil {\n    50:        continue\n    51:      }\n    52:  \n    53:      sflowLayer := packet.Layer(layers.LayerTypeSFlow)\n    54:      if sflowLayer != nil {\n```", "```go\n(dlv) locals\nerr = error nil\nhandle = (\"*github.com/google/gopacket/pcapgo.EthernetHandle\")(0xc000162200)\nrawInstructions = []golang.org/x/net/bpf.RawInstruction len: 6, cap: 6, [...]\npacketSource = (\"*github.com/google/gopacket.PacketSource\")(0xc00009aab0)\npacket = github.com/google/gopacket.Packet(*github.com/google/gopacket.eagerPacket) 0xc0000c3c08\n```", "```go\n(dlv) print packet\ngithub.com/google/gopacket.Packet(*github.com/google/gopacket.eagerPacket) *{\n  packet: github.com/google/gopacket.packet {\n    data: []uint8 len: 758, cap: 758, [170,193,171,140,219,204,170,193,171,198,150,242,8,0,69,0,2,232,40,71,64,0,63,17,18,182,192,0,2,5,203,0,113,2,132,19,24,199,2,212,147,6,0,0,0,5,0,0,0,1,203,0,113,129,0,1,134,160,0,0,0,39,0,2,...+694 more],\n    /* ... < omitted > ... */\n    last: github.com/google/gopacket.Layer(*github.com/google/gopacket.DecodeFailure) ...,\n    metadata: (*\"github.com/google/gopacket.PacketMetadata\")(0xc0000c6200),\n    decodeOptions: (*\"github.com/google/gopacket.DecodeOptions\")(0xc0000c6250),\n    link: github.com/google/gopacket.LinkLayer(*github.com/google/gopacket/layers.Ethernet) ...,\n    network: github.com/google/gopacket.NetworkLayer(*github.com/google/gopacket/layers.IPv4) ...,\n    transport: github.com/google/gopacket.TransportLayer(*github.com/google/gopacket/layers.UDP) ...,\n    application: github.com/google/gopacket.ApplicationLayer nil,\n    failure: github.com/google/gopacket.ErrorLayer(*github.com/google/gopacket.DecodeFailure) ...,},}\n```", "```go\n$ docker exec -it clab-netgo-host-2 bash \nroot@host-2:/# cd workdir/ch10/packet-capture/\nroot@host-2:/workdir/ch10/packet-capture#  dlv debug main.go --listen=:2345 --headless --api-version=2\nAPI server listening at: [::]:2345\n```", "```go\n{\n\t\"version\": \"0.2.0\",\n\t\"configurations\": [\n        {\n            \"name\": \"Connect to server\",\n            \"type\": \"go\",\n            \"request\": \"attach\",\n            \"mode\": \"remote\",\n            \"remotePath\": \"/workdir/ch10/packet-capture\",\n            \"port\": 2345,\n            \"host\": \"ec2-3-224-127-79.compute-1.amazonaws.com\",  \n        },\n    ]\n}\n```", "```go\ntype MyFlow struct {\n     Key         string\n     SrcAddr     string `json:\"SrcAddr,omitempty\"`\n     DstAddr     string `json:\"DstAddr,omitempty\"`\n     SrcPort     int    `json:\"SrcPort,omitempty\"`\n     DstPort     int    `json:\"DstPort,omitempty\"`\n     Count       int    // times we've seen this flow sample\n}\n```", "```go\n    type Heap []*MyFlow\n    ```", "```go\n    type topTalker struct {\n    ```", "```go\n         flowMap map[string]*MyFlow\n    ```", "```go\n         heap    Heap\n    ```", "```go\n    }\n    ```", "```go\nimport (\n  \"github.com/netsampler/goflow2/format\"\n  \"github.com/netsampler/goflow2/utils\"\n)\nfunc main() {\n     tt := topTalker{\n           flowMap: make(map[string]*MyPacket),\n           heap:    make(Heap, 0),\n     }\n     formatter, err := format.FindFormat(ctx, \"json\")\n     // process error\n     sSFlow := &utils.StateSFlow{\n           Format:    formatter,\n           Logger:    log.StandardLogger(),\n           Transport: &tt,\n     }\n     go sSFlow.FlowRoutine(1, hostname, 6343, false)\n}\n```", "```go\ntype StateSFlow struct {\n     Format    format.FormatInterface\n     Transport transport.TransportInterface\n     Logger    Logger\n     /* ... < other fields > ... */\n}\ntype TransportInterface interface {\n     Send(key, data []byte) error\n}\n```", "```go\nfunc (c *topTalker) Send(key, data []byte) error {\n     var myFlow MyFlow\n     json.Unmarshal(data, &myFlow)\n     /* ... <continues next > ... */\n}\n```", "```go\nvar flowMapKey = `%s:%d<->%s:%d`\nfunc (c *topTalker) Send(key, data []byte) error {\n  /* ... <continues from before > ... */\n  ips := []string{myFlow.SrcAddr, myFlow.DstAddr}\n  sort.Strings(ips)\n  var mapKey string\n  if ips[0] != myFlow.SrcAddr {\n    mapKey = fmt.Sprintf(\n      flowMapKey,\n      myFlow.SrcAddr,\n      myFlow.SrcPort,\n      myFlow.DstAddr,\n      myFlow.DstPort,\n    )\n  } else {\n    mapKey = fmt.Sprintf(\n      flowMapKey,\n      myFlow.DstAddr,\n      myFlow.DstPort,\n      myFlow.SrcAddr,\n      myFlow.SrcPort,\n    )\n  }\n  /* ... <continues next > ... */\n}\n```", "```go\nfunc (c *topTalker) Send(key, data []byte) error {\n  /* ... <continues from before > ... */\n    myFlow.Key = mapKey\n    foundFlow, ok := c.flowMap[mapKey]\n    if !ok {\n          myFlow.Count = 1\n          c.flowMap[mapKey] = &myFlow\n          heap.Push(&c.heap, &myFlow)\n          return nil\n    }\n    c.heap.update(foundFlow)\n    return nil\n} \n```", "```go\ntype Heap []*MyFlow\nfunc (h Heap) Less(i, j int) bool {\n     return h[i].Count > h[j].Count\n}\n```", "```go\nNetwork-Automation-with-Go $ make top-talkers-start\ndocker exec -d clab-netgo-cvx systemctl restart hsflowd\ndocker exec -d clab-netgo-host-3 ./ethr -s\ndocker exec -d clab-netgo-host-1 ./ethr -c 203.0.113.253 -b 900K -d 60s -p udp -l 1KB\ndocker exec -d clab-netgo-host-1 ./ethr -c 203.0.113.252 -b 600K -d 60s -p udp -l 1KB\ndocker exec -d clab-netgo-host-1 ./ethr -c 203.0.113.251 -b 400K -d 60s -p udp -l 1KB\n```", "```go\n$ cd ch10/top-talkers; sudo ip netns exec clab-netgo-host-2 /usr/local/go/bin/go run main.go; cd ../../\nTop Talkers\n+---+-------------------+--------------------+------\n| # | FROM              | TO                 | PROTO \n+---+-------------------+--------------------+------\n| 1 | 203.0.113.253:8888 | 203.0.113.0:48494 | UDP | \n| 2 | 203.0.113.252:8888 | 203.0.113.0:42912 | UDP | \n| 3 | 203.0.113.251:8888 | 203.0.113.0:42882 | UDP | \n+---+-------------------+--------------------+------\n```", "```go\npackage main\nimport (\n     \"container/heap\"\n     \"testing\"\n)\nfunc TestHeap(t *testing.T) {\n  // code tests\n}\n```", "```go\n    type testFlow struct {\n    ```", "```go\n         startCount   int\n    ```", "```go\n         timesSeen    int\n    ```", "```go\n         wantPosition int\n    ```", "```go\n         wantCount    int\n    ```", "```go\n    }\n    ```", "```go\n    type testCase struct {\n    ```", "```go\n         name  string\n    ```", "```go\n         flows map[string]testFlow\n    ```", "```go\n    }\n    ```", "```go\n var testCases = []testCase{\n  {\n    name: \"single packet\",\n    flows: map[string]testFlow{\n      \"1-1\": {\n        startCount:   1,\n        timesSeen:    0,\n        wantPosition: 0,\n        wantCount:    1,\n      },\n    },\n  },{\n    name: \"last packet wins\",\n    flows: map[string]testFlow{\n      \"2-1\": {\n        startCount:   1,\n        timesSeen:    1,\n        wantPosition: 1,\n        wantCount:    2,\n      },\n      \"2-2\": {\n        startCount:   2,\n        timesSeen:    1,\n        wantPosition: 0,\n        wantCount:    3,\n      },\n    },\n  },\n```", "```go\nfunc TestHeap(t *testing.T) {\n     for _, test := range testCases {\n           h := make(Heap, 0)\n           // pushing flow on the heap\n           for key, f := range test.flows {\n                      flow := &MyFlow{\n                           Count: f.startCount,\n                           Key:   key,\n                      }\n                      heap.Push(&h, flow)\n                      // updating packet counts\n                      for j := 0; j < f.timesSeen; j++ {\n                           h.update(flow)\n                      }\n           }\n     /* ... <continues next > ... */\n}\n```", "```go\nfunc TestHeap(t *testing.T) {\n  /* ... < continues from before > ... */\n  for i := 0; h.Len() > 0; i++ {\n                f := heap.Pop(&h).(*MyFlow)\n                tf := test.flows[f.Key]\n                if tf.wantPosition != i {\n                           t.Errorf(\n                             \"%s: unexpected position for packet key %s: got %d, want %d\", test.name, f.Key, i, tf.wantPosition)\n                }\n                if tf.wantCount != f.Count {\n                           t.Errorf(\n                                 \"%s: unexpected count for packet key %s: got %d, want %d\", test.name, f.Key, f.Count, tf.wantCount)\n                }\n           }\n}\n```", "```go\nNetwork-Automation-with-Go $ make bgp-ping-start\ncd ch10/bgp-ping; go build -o bgp-ping main.go\ndocker exec -d clab-netgo-host-3 /workdir/bgp-ping/bgp-ping -id host-3 -nlri 100.64.0.2 -laddr 203.0.113.254 -raddr 203.0.113.129 -las 65005 -ras 65002 -p\ndocker exec -d clab-netgo-host-1 /workdir/bgp-ping/bgp-ping -id host-1 -nlri 100.64.0.0 -laddr 203.0.113.0 -raddr 203.0.113.1 -las 65003 -ras 65000 -p\ndocker exec -d clab-netgo-host-2 /cloudprober -config_file /workdir/workdir/cloudprober.cfg\ncd ch10/bgp-ping; docker-compose up -d; cd ../../\nCreating prometheus ... done\nCreating grafana    ... done\nhttp://localhost:3000\n```", "```go\ntype Plugin interface {\n     GetCapabilities(...) []Capability\n     OnOpenMessage(...) *Notification\n     OnEstablished(...) handleUpdate\n     OnClose(...)\n}\n```", "```go\nimport bgp \"github.com/osrg/gobgp/v3/pkg/packet/bgp\"\nconst (\n     bgpPingType = 42\n)\nfunc (p *plugin) handleUpdate(\n     peer corebgp.PeerConfig,\n     update []byte,\n) *corebgp.Notification {\n\n     msg, err := bgp.ParseBGPBody(\n           &bgp.BGPHeader{Type: bgp.BGP_MSG_UPDATE},\n           update,\n     )\n     // process error\n     for _, attr := range msg.Body.\n                    (*bgp.BGPUpdate).PathAttributes {\n           if attr.GetType() != bgpPingType {\n                      continue\n           }\n     /* ... <continues next > ... */\n}\n```", "```go\nfunc (p *plugin) handleUpdate(\n  peer corebgp.PeerConfig,\n  update []byte,\n) *corebgp.Notification {\n    /* ... < continues from before > ... */\n    source, dest, ts, err := parseType42(attr)\n    // process error\n    sourceHost := string(bytes.Trim(source, \"\\x00\"))\n    destHost := string(bytes.Trim(dest, \"\\x00\"))\n    /* ... <omitted for brevity > ... */\n\n    // if src is us, may be a response. id = router-id\n    if sourceHost == *id {\n      rtt := time.Since(ts).Nanoseconds()\n      metric := fmt.Sprintf(\n        \"bgp_ping_rtt_ms{device=%s} %f\\n\",\n        destHost,\n        float64(rtt)/1e6,\n      )\n\n    p.store = append(p.store, metric)\n return nil\n    }\n\n    p.pingCh <- ping{source: source, ts: ts.Unix()}\n    return nil\n}\n```", "```go\nfunc (p *plugin) OnEstablished(\n  peer corebgp.PeerConfig,\n  writer corebgp.UpdateMessageWriter,\n) corebgp.UpdateMessageHandler {\n  log.Println(\"peer established, starting main loop\")\n  go func() {\n    for {\n      select {\n      case pingReq := <-p.pingCh:\n        // Build the ping response payload\n        bytes, err := p.buildUpdate(\n                      type42PathAttr,\n                      peer.LocalAddress,\n                      peer.LocalAS,\n        )\n        // process error\n        writer.WriteUpdate(bytes)\n        /* ... < schedule a withdraw > ... */\n\n      case <-p.probeCh:\n        // Build the ping request payload\n        bytes, err := p.buildUpdate(\n                      type42PathAttr,\n                      peer.LocalAddress,\n                      peer.LocalAS,\n        )\n        // process error\n        writer.WriteUpdate(bytes)\n        /* ... < schedule a withdraw > ... */\n\n      case <-withdraw.C:\n        bytes, err := p.buildWithdraw()\n        // process error\n        writer.WriteUpdate(bytes)\n      }\n    }\n  }()\n  return p.handleUpdate\n}\n```", "```go\nfunc (p *plugin) buildWithdraw() ([]byte, error) {\n     myNLRI := bgp.NewIPAddrPrefix(32, p.probe.String())\n     withdrawnRoutes := []*bgp.IPAddrPrefix{myNLRI}\n     msg := bgp.NewBGPUpdateMessage(\n           withdrawnRoutes,\n           []bgp.PathAttributeInterface{},\n           nil,\n     )\n     return msg.Body.Serialize()\n}\n```", "```go\nfunc (p *plugin) handleUpdate(\n     peer corebgp.PeerConfig,\n     update []byte,\n) *corebgp.Notification {\n     msg, err := bgp.ParseBGPBody(\n           &bgp.BGPHeader{Type: bgp.BGP_MSG_UPDATE},\n           update,\n     )\n     // process error\n     if err := bgp.ValidateBGPMessage(msg); err != nil {\n           log.Fatal(\"validate BGP message \", err)\n     }\n```", "```go\nfunc main() {\n  /* ... < continues from before > ... */\n  probeCh := make(chan struct{})\n  resultsCh := make(chan string)\n\n  peerPlugin := &plugin{\n              probeCh: probeCh,\n            resultsCh: resultsCh,\n  }\n\n  if *cloudprober {\n    go func() {\n      serverutils.Serve(func(\n        request *epb.ProbeRequest,\n        reply *epb.ProbeReply,\n      ) {\n        probeCh <- struct{}{}\n        reply.Payload = proto.String(<-resultsCh)\n        if err != nil {\n          reply.ErrorMessage = proto.String(err.Error())\n        }\n      })\n    }()\n  }\n}\n```", "```go\nprobe {\n  name: \"bgp_ping\"\n  type: EXTERNAL\n  targets { dummy_targets {} }\n  timeout_msec: 11000\n  interval_msec: 10000\n  external_probe {\n    mode: SERVER\n    command: \"/workdir/bgp-ping/bgp-ping -id host-2 -nlri 100.64.0.1 -laddr 203.0.113.2 -raddr 203.0.113.3 -las 65004 -ras 65001 -c true\"\n  }\n}\n```", "```go\nscrape_configs:\n  - job_name: 'bgp-ping'\n    scrape_interval: 10s\n    static_configs:\n      - targets: ['clab-netgo-host-2:9313']\n```", "```go\nlocal_resource('host-1',\n  serve_cmd='ip netns exec clab-netgo-host-1 go run main.go -id host-1 -nlri 100.64.0.0 -laddr 203.0.113.0 -raddr 203.0.113.1 -las 65003 -ras 65000 -p',\n  deps=['./main.go'])\n```", "```go\nNetwork-Automation-with-Go $ cd ch10/bgp-ping\nNetwork-Automation-with-Go/ch10/bgp-ping $ sudo tilt up\nTilt started on http://localhost:10350/\n```"]