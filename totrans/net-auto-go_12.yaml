- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Appendix : Building a Testing Environment'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every chapter of this book includes Go code examples to illustrate some points
    we make in the text. You can find all these Go programs in this book’s GitHub
    repository (see the *Further reading* section of this chapter). While you don’t
    have to execute them all, we believe that manually running the code and observing
    the result may help reinforce the learned material and explain the finer details.
  prefs: []
  type: TYPE_NORMAL
- en: The first part of this book, *Chapters 1* to *5*, includes relatively short
    code examples you can run in the Go Playground (*Further reading*) or on any computer
    with Go installed. For instructions on how to install Go, you can refer to *Chapter
    1* or follow the official download and installation procedure (*Further reading*).
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the book, starting from [*Chapter 6*](B16971_06.xhtml#_idTextAnchor144),
    assumes you can interact with a virtual topology, which we run in containers with
    the help of `containerlab` (*Further reading*). This *Appendix* documents the
    process of building a testing environment that includes the compatible version
    of `containerlab` and other related dependencies, to make sure you get a seamless
    experience running examples from any chapter of this book.
  prefs: []
  type: TYPE_NORMAL
- en: What is a testing environment?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary goal is to build an environment with the right set of hardware and
    software that meets the minimum requirements to execute the code examples. We
    base the requirements on the assumption that you’re deploying a **virtual machine**
    (**VM**), as we realize you might not deploy this on a dedicated bare-metal server.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to deploying a VM for testing (testbed), you have two options,
    both of which we discuss later:'
  prefs: []
  type: TYPE_NORMAL
- en: You can deploy this VM in a self-hosted environment, such as VMware or **Kernel-based
    Virtual** **Machine** (**KVM**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You could use a cloud-hosted environment—for example, **Amazon Web** **Services**
    (**AWS**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the hardware perspective, we assume that the underlying CPU architecture
    is 64-bit x86, and our recommendation is to give the VM at least 2 vCPUs and 4
    GB of RAM and ideally double that to make things a bit faster.
  prefs: []
  type: TYPE_NORMAL
- en: We describe all software provisioning and configuration in an Ansible playbook
    included in this book’s GitHub repository (*Further reading*). We highly recommend
    you use the automated approach we have prepared for you to install all the dependencies
    to run the code examples in the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can still install these packages on top of any Linux distribution—for example,
    **Windows Subsystem for Linux version 2** (**WSL 2**). In case you want to do
    the installation manually, we include a full list of dependencies here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Package** | **Version** |'
  prefs: []
  type: TYPE_TB
- en: '| Go | 1.18.1 |'
  prefs: []
  type: TYPE_TB
- en: '| `containerlab` | 0.25.1 |'
  prefs: []
  type: TYPE_TB
- en: '| Docker | 20.10.14 |'
  prefs: []
  type: TYPE_TB
- en: '| `ansible-core` (only required for [*Chapter 7*](B16971_07.xhtml#_idTextAnchor161))
    | 2.12.5 |'
  prefs: []
  type: TYPE_TB
- en: '| Terraform (only required for [*Chapter 7*](B16971_07.xhtml#_idTextAnchor161))
    | 1.1.9 |'
  prefs: []
  type: TYPE_TB
- en: Table 12.1 – Software dependencies
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – building a testing environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following section, we describe the two automated ways of building a testing
    environment. If you are unsure which option is right for you, we recommend you
    pick the first one, as it has minimal external dependencies and is completely
    managed by a cloud service provider. This is also the only option that we (the
    authors of this book) can test and verify, and hence it should give you the most
    consistent experience.
  prefs: []
  type: TYPE_NORMAL
- en: Option 1 – cloud-hosted
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have picked AWS as the cloud service provider because of its popularity and
    general familiarity in our industry. Inside this book’s GitHub repository (*Further
    reading*), we have included an Ansible playbook that completely automates all
    tasks required to create a VM in AWS. You are free to use any other cloud provider
    but you will have to do the provisioning manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'The testing environment is a single Linux VM in AWS running `containerlab`
    to create container-based network topologies. The next diagram illustrates what
    the AWS environment looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Target environment](img/B16971_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Target environment
  prefs: []
  type: TYPE_NORMAL
- en: To conform with the hardware requirements stated earlier, we recommend you run
    at least a `t2.medium`-, ideally a `t2.large`-sized VM (**Elastic Compute Cloud**
    (**EC2**) instance). But the AWS Free Tier plan (*Further reading*) does not cover
    these instance types, so you should expect to incur some charges associated with
    the running of the VM. We assume you are familiar with the costs and billing structure
    of AWS and use financial common sense when working with a cloud-hosted environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you run the playbook, you need to make sure you meet the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an AWS account (AWS Free Tier (*Further reading*)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an AWS access key (AWS Programmatic access (*Further reading*)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A Linux OS with the following packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: GNU Make
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With all this in place, you can go ahead and clone the book’s GitHub repository
    (*Further reading*) with the `git` `clone` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After you clone the repository, change directory to it.
  prefs: []
  type: TYPE_NORMAL
- en: Input variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before you can start the deployment, you need to supply your AWS account credentials
    (`AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`). You do this by exporting a
    pair of environment variables containing the key ID and secret values, as follows.
    Check out AWS Programmatic access (*Further reading*) for instructions on how
    to create an access key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides these required variables, there are other three optional input variables
    that you can adjust to fine-tune your deployment environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Values** |'
  prefs: []
  type: TYPE_TB
- en: '| `AWS_DISTRO` | `fedora` or `ubuntu` (default: `fedora`) |'
  prefs: []
  type: TYPE_TB
- en: '| `AWS_REGION` | One of the AWS Regions (default: `us-east-1`) |'
  prefs: []
  type: TYPE_TB
- en: '| `VM_SIZE` | One of the AWS instance types (default: `t2.large`) |'
  prefs: []
  type: TYPE_TB
- en: Table 12.2 – Testing VM options
  prefs: []
  type: TYPE_NORMAL
- en: 'If you choose to change any of these default values, you can do this the same
    way as the AWS access key. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In that scenario, we selected Ubuntu as the Linux distribution of the VM and
    London (`eu-west-2`) as the AWS Region for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment process
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once you have set all the required input variables, you can deploy the testing
    environment. From within the book repository directory, run the `make env-build`
    command, which deploys the VM and installs all the required software packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming that the playbook has completed successfully, you can see the VM access
    details in the logs, as the preceding output shows. You can also view the connection
    details at any time after you’ve deployed the environment by running the `make`
    `env-show` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can use this information to connect to the provisioned VM. The playbook
    generates an `lab-state/id_rsa`), so don’t forget to always use it for SSH authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can connect to the VM and check the Go version installed and take a look
    at the files of the book’s repository.
  prefs: []
  type: TYPE_NORMAL
- en: Option 2 – self-hosted
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another option is to create a VM in a private environment. This environment
    could be your personal computer running a hypervisor such as VirtualBox, an ESXi
    server, an OpenStack cluster, or something else as long as it can allocate the
    CPU and memory the VM requires to run the lab topology. The OS on the VM has to
    be either Ubuntu 22.04 or Fedora 35.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have built the VM with SSH enabled, make sure you can SSH to the IP
    address of the VM and access it with its credentials. Then, change the Ansible
    inventory file (`inventory`) in the `ch12/testbed` folder (*Further reading*)
    of your personal computer’s copy of this book’s GitHub repository to point to
    your VM. It should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Include at least the IP address (`ansible_host`) to reach the VM, and the `ansible_user`,
    `ansible_password`, or `ansible_ssh_private_key_file` user credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same `ch12/testbed` folder (*Further reading*), there is an Ansible
    playbook that calls the `configure_instance` role. Use this playbook to auto-configure
    your VM to run the book examples, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The playbook filename is `configure-local-vm.yml` and the inventory filename
    is `inventory`, so from the `ch12/testbed` folder (*Further reading*), run `ansible-playbook
    configure-local-vm.yml -i inventory -v` to get the VM ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – uploading container images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not all networking vendors make it simple to access their container-based **network
    OSes** (**NOSes**). If you can’t pull the image directly from a container registry
    such as Docker Hub, you might need to download the image from their website and
    upload it to the test VM. The only container image in the book that we can’t pull
    from a public registry at the time of writing is Arista’s **cEOS** image. Here,
    we describe the process of uploading this image into the testing environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you need to do is download the image from [arista.com](http://arista.com)
    (*Further reading*). You should select the 64-bit cEOS image from the 4.28(F)
    train—for example, `cEOS64-lab-4.28.0F.tar`. You can copy the image to the test
    VM with the `scp` command using the generated SSH private key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, SSH to the instance and import the image with the `docker` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can now use this image (`ceos:4.28`) in the `image` section of one or more
    routers in the topology file.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – iInteracting with the testing environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We recommend you start with a fresh build of a virtual network topology at the
    beginning of *Chapters 6* through *8*. To orchestrate the topologies, we use `containerlab`,
    which is available in the testing VM. `containerlab` offers a quick way to run
    arbitrary network topologies based on their definition provided in a human-readable
    YAML file.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: '`containerlab` is written in Go and serves as a great example of an interactive
    CLI program that orchestrates local container resources.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following `base` topology definition file in the `topo-base`
    directory of this book’s GitHub repository (*Further reading*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This YAML file defines a three-node topology, as the next diagram shows. One
    node runs Nokia SR Linux, another NVIDIA Cumulus Linux, and the last one runs
    Arista cEOS. In this scenario, all network devices come up with their default
    startup configurations, and throughout each chapter, we describe how to establish
    full end-to-end reachability between all three of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – “Base” network topology](img/B16971_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – “Base” network topology
  prefs: []
  type: TYPE_NORMAL
- en: 'The next two chapters (*Chapters 9* and *10*) rely on a slightly different
    version of the preceding topology. Unlike the `base` topology, the `full` topology
    comes up fully configured and includes an extra set of nodes to emulate physical
    servers attached to the network devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – “Full” network topology](img/B16971_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – “Full” network topology
  prefs: []
  type: TYPE_NORMAL
- en: These end hosts run different applications that interact with the existing network
    topology.
  prefs: []
  type: TYPE_NORMAL
- en: Launching a virtual network topology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use a `containerlab` binary to deploy the test topology. For convenience,
    we included a couple of `make` targets that you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`make lab-base` to create the `base` topology used in *Chapters 6* through
    *8*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`make lab-full` to create the `full` topology used in *Chapters 9* and *10*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example of how you can create the `base` topology from inside the
    test VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You now have `clab-netgo-ceos`, `clab-netgo-cvx` and `clab-netgo-srl` routers
    ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the devices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`containerlab` uses Docker to run the containers. This means we can use standard
    Docker capabilities to connect to the devices—for example, you can use the `docker
    exec` command to start any process inside a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`sr_cli` in the preceding example is the CLI process for an SR Linux device.
    The following table displays the “default shell” process for each virtual network
    device:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **NOS** | **Command** |'
  prefs: []
  type: TYPE_TB
- en: '| Cumulus Linux | `bash` or `vtysh` |'
  prefs: []
  type: TYPE_TB
- en: '| SR Linux | `sr_cli` |'
  prefs: []
  type: TYPE_TB
- en: '| EOS | `Cli` |'
  prefs: []
  type: TYPE_TB
- en: Table 12.3 – Device default shells
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use SSH to connect to the default shell. The next table provides
    the hostname and the corresponding credentials you can use to connect to each
    device:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Device** | **Username** | **Password** |'
  prefs: []
  type: TYPE_TB
- en: '| `clab-netgo-srl` | `admin` | `admin` |'
  prefs: []
  type: TYPE_TB
- en: '| `clab-netgo-ceos` | `admin` | `admin` |'
  prefs: []
  type: TYPE_TB
- en: '| `clab-netgo-cvx` | `cumulus` | `cumulus` |'
  prefs: []
  type: TYPE_TB
- en: Table 12.4 – Device credentials
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how you can connect to Arista cEOS and Cumulus Linux, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Once you finish the chapter, you can destroy the topology.
  prefs: []
  type: TYPE_NORMAL
- en: Destroying the network topology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can clean up both virtual network topologies using the `make` `cleanup`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `make cleanup` command only cleans up the virtual network topology while
    all the cloud resources are still running.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 – cleaning up of the cloud-hosted environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you’re done working with the cloud-hosted testing environment, you can
    clean it up so that you don’t pay for something you might no longer need. You
    can do this using another Ansible playbook that makes sure all the AWS resources
    you created before are now wiped out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Book’s GitHub repository: [https://github.com/PacktPublishing/Network-Automation-with-Go](https://github.com/PacktPublishing/Network-Automation-with-Go)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Go Playground: [https://play.golang.org/](https://play.golang.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Official download and install procedure: [https://golang.org/doc/install#install](https://golang.org/doc/install#install)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`containerlab`: [https://containerlab.dev/](https://containerlab.dev/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AWS Free Tier: [https://aws.amazon.com/free/](https://aws.amazon.com/free/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AWS Programmatic access: [https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys](https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch12/testbed`: https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch12/testbed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ch12/testbed/inventory`: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch12/testbed/inventory](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch12/testbed/inventory)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Arista: [https://www.arista.com/en/support/software-download](https://www.arista.com/en/support/software-download)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Beginner’s Guide—Downloading Python: [https://wiki.python.org/moin/BeginnersGuide/Download](https://wiki.python.org/moin/BeginnersGuide/Download)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Installing Ansible with `pip`: [https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html#installing-ansible-with-pip](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html#installing-ansible-with-pip)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Getting Started - Installing* *Git*: [https://git-scm.com/book/en/v2/Getting-Started-Installing-Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Installing `pip`—*Supported* *Methods*: [https://pip.pypa.io/en/stable/installation/#supported-methods](https://pip.pypa.io/en/stable/installation/#supported-methods)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Get Arista cEOS: [https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch12/testbed/get_arista_ceos.md](https://github.com/PacktPublishing/Network-Automation-with-Go/blob/main/ch12/testbed/get_arista_ceos.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AWS access keys: [https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys](https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AWS Regions: [https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AWS instance types: [https://aws.amazon.com/ec2/instance-types/](https://aws.amazon.com/ec2/instance-types/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
