<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer007">
			<h1 id="_idParaDest-15" class="chapter-number"><a id="_idTextAnchor014"/>1</h1>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Why Go?</h1>
			<p>At some point in your programming journey, your programs performed I/O-related tasks such as creating and removing files and directories. They may have orchestrated the creation of new processes and the execution of other programs or even facilitated communication between threads and processes on the same computer and between processes on different computers connected via <span class="No-Break">a network.</span></p>
			<p>When our programs center on using a low-level set of tasks, we categorize them as <span class="No-Break">system programming.</span></p>
			<p>It is alleged that system programming is tedious. But I do not see it this way at all! In fact, it is quite the opposite – an enjoyable and entertaining experience. It is like being a magician. You get to control the operating system and hardware, and you can make things happen that would be impossible in <span class="No-Break">other languages.</span></p>
			<p>In this chapter, we discuss why Go is an excellent fit for building efficient, high-performance system software to support <span class="No-Break">real-world scenarios.</span></p>
			<p>In this chapter, we are going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li><span class="No-Break">Choosing Go</span></li>
				<li>Concurrency <span class="No-Break">and goroutines</span></li>
				<li>Interacting with <span class="No-Break">the OS</span></li>
				<li><span class="No-Break">Tooling</span></li>
				<li>Cross-platform development <span class="No-Break">with Go</span></li>
			</ul>
			<p>By the end of this chapter, you will have a grasp of where Go is in the ecosystem of system programming, the importance of the Go concurrency model to build efficient and high-performance system software, how Go chooses to interact with the OS, the Go approach to cross-platform development, and the main commands in the Go <span class="No-Break">built-in tooling.</span></p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Choosing Go</h1>
			<p>There are plenty of languages in the system programming space nowadays: some are well established, such as C and C++; some form a wave of newcomers, such as Zig, Rust, and Odin; and others claim the title of “C/C++ killer,” with their pledges of <span class="No-Break">impressive performance.</span></p>
			<p>Sure, we can use all of them and achieve outstanding results. Still, we could fall into hidden traps such as a steep learning curve, high cognitive load, a lack of community and support, inconsistent APIs with constant breaking changes, and a lack <span class="No-Break">of adoption.</span></p>
			<p>Go’s design<a id="_idIndexMarker000"/> philosophy emphasizes simplicity, expressiveness, robustness, and efficiency. Its support for concurrency and strong dependency management, as well as its focus on composition, make it a compelling choice for system programming. Its creators aimed to build a language that provides powerful building blocks without unnecessary complexity, which makes writing, reading, understanding, and maintaining system-level code easier. People with programming experience usually take two weeks to get acquainted with Go. While they may not be considered experts, they can confidently read standard Go code and write basic to medium-complexity programs <span class="No-Break">without struggle.</span></p>
			<p>Also, Go is excellent for system programming because the language has a Unix-minded design by checking all the boxes for simplicity. Many programmers who are proficient in Python and Ruby often transition to Go, as it allows them to retain their level of expressiveness while achieving improved performance and the capability to work <span class="No-Break">with concurrency.</span></p>
			<p>It is worth noting that Go’s philosophy doesn’t prioritize zero cost in terms of CPU usage. Instead, the language aims to reduce the effort demanded from programmers, which is considered more significant and, as a by-product, makes the <span class="No-Break">experience enjoyable.</span></p>
			<p>One of the leading criticisms of using Go for system programming is the <strong class="bold">garbage collector</strong> (<strong class="bold">GC</strong>), specifically <a id="_idIndexMarker001"/>its pauses and explicit memory limits. If you still have this pet peeve with Go, don’t worry. In <a href="B21662_06.xhtml#_idTextAnchor145"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, we’ll see that more granular memory management is available from Go 1.20 <span class="No-Break">and above.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">In a GC pause worst-case scenario, the stop-the-world time is typically less than <span class="No-Break">100 microseconds.</span></p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Concurrency and goroutines</h1>
			<p>One of the most essential features of Go is its concurrency model. Concurrency<a id="_idIndexMarker002"/> is the ability to run multiple tasks at the same time. In system programming, executing many tasks in parallel is essential for improving the performance and responsiveness of <span class="No-Break">our programs.</span></p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Concurrency</h2>
			<p>Real-time systems demand <a id="_idIndexMarker003"/>precision, with concurrency being a pivotal factor. These systems coordinate tasks with exceptional timing, particularly in scenarios where even milliseconds matter. Concurrency offers significant advantages by increasing throughput (a measure of how many units of information a system can process in a given amount of time) while decreasing task completion times. Real-life instances show how concurrency improves responsiveness, making systems more flexible and tasks more efficient. Moreover, concurrency’s isolation abilities guarantee data integrity by <span class="No-Break">preventing interference.</span></p>
			<p>System programming involves a diverse range of tasks, from CPU-bound to I/O-bound. Concurrency orchestrates this diversity by allowing CPU-bound tasks to progress while I/O-bound tasks <span class="No-Break">await resources.</span></p>
			<p>Later, in <a href="B21662_10.xhtml#_idTextAnchor211"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, when we discuss distributed systems, the importance of concurrency will shine. It orchestrates tasks across an application or even different nodes in the network, which is ideal for managing <span class="No-Break">large-scale concurrency.</span></p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Goroutines</h2>
			<p>Go’s concurrency model relies on goroutines<a id="_idIndexMarker004"/> and<a id="_idIndexMarker005"/> channels. Goroutines are lightweight execution threads, often referred to as green threads. Creating them is cost-effective. Unlike conventional threads, they exhibit remarkable efficiency, enabling thousands of goroutines to run simultaneously on just a few <span class="No-Break">OS threads.</span></p>
			<p>Channels, on<a id="_idIndexMarker006"/> the other hand, provide a mechanism for goroutines to communicate and synchronize without resorting to locks. This approach is inspired<a id="_idIndexMarker007"/> by the <strong class="bold">Communicating Sequential Process</strong> (<strong class="bold">CSP</strong>) (<a href="https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf">https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf</a>) formalism, emphasizing coordinated interactions between <span class="No-Break">concurrent components.</span></p>
			<p>Diverging from numerous other programming languages that depend on external libraries or threading constructs for concurrency, Go incorporates concurrency seamlessly into its core language design. This design decision leads to code that is not only easier to comprehend but also less susceptible to errors, as the complexities of threading <span class="No-Break">are abstracted.</span></p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>CSP-inspired model</h2>
			<p>Go’s concurrency model draws<a id="_idIndexMarker008"/> inspiration from CSP, a formal language for describing concurrent systems. CSP focuses on communication and synchronization between concurrently executing entities. Unlike traditional multi-threaded programming, CSP and Go prioritize communication through channels instead of shared memory, reducing complexity and potential hazards. Synchronization and coordination are essential, with CSP using channels for process synchronization and Go using similar channels to coordinate goroutines. Safety and isolation are key, as both languages ensure safe interaction through channels, enhancing predictability and reliability. Go’s channels directly realize CSP’s communication-based approach, providing a safe way for goroutines to exchange data without the pitfalls of shared memory <span class="No-Break">and locks.</span></p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Share by communication</h2>
			<p>The <a id="_idIndexMarker009"/>famous Go proverb, “Don’t communicate by sharing memory, share memory by communicating” is often a source of discussion and misinterpretation. Still, reading it as “Share by communicating, not by locking” would be more precise, mainly because mainstream languages often rely on locks to protect shared data, leading to potential issues such as deadlocks and race conditions. Go encourages a different paradigm: <em class="italic">sharing data through channels by sending and receiving messages</em>. This “share by communicating” philosophy reduces the need for explicit locks and promotes a safer <span class="No-Break">concurrency environment.</span></p>
			<p>If you are into functional programming, I have great news for you. In Go, data is not implicitly shared between goroutines. In other words, the data is copied. Did you see the concern with data immutability? This stands in contrast to languages, where shared memory is the default mode of communication between threads. Go’s emphasis on explicit communication via channels helps avoid the unintended data sharing and race conditions that can arise in traditional threading models. Another benefit of this model is that there is no callback hell since every interaction with concurrent code is often read in a procedural manner. A regular Go function can be used in procedural code without tying the signatures with <a id="_idIndexMarker010"/><span class="No-Break">extra keywords.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Callback hell, also <a id="_idIndexMarker011"/>known as the “pyramid of doom,” is a term used in programming to describe a situation where nested and interdependent callback functions make the code difficult to read, understand, and maintain. This typically occurs in asynchronous programming environments, such as JavaScript, where callbacks are used to handle <span class="No-Break">asynchronous operations.</span></p>
			<p>In the next chapter, we will refresh all concepts of concurrency and its building blocks to prepare you for interacting with the <span class="No-Break">OS interfaces.</span></p>
			<p>In addition to its concurrency model, Go also provides a way to interact with the operating system at a low level. This is essential for system programming, where you often need to control the OS <span class="No-Break">and hardware.</span></p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor022"/>Interacting with the OS</h1>
			<p>Go’s approach to system calls is designed to be safe and efficient, especially in the context of its <span class="No-Break">concurrency model.</span></p>
			<p>In Go, system calls<a id="_idIndexMarker012"/> are comparatively lower-level in comparison to certain other programming languages. It can be helpful if you need fine-grained control over system resources, but it also means you’re dealing with more <span class="No-Break">low-level details.</span></p>
			<p>Making system calls often requires understanding the underlying operating system APIs and conventions. The side effect is that it can introduce a steeper learning curve if you are new to systems programming or <span class="No-Break">lower-level development.</span></p>
			<p>Not familiar with system calls? Fear not! The book’s second part will explore and experiment with them in detail to cover the main aspects we need to progress in our system <span class="No-Break">programming journey.</span></p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/>Tooling</h1>
			<p>Go is like a toolbox. It has everything we need to build great software, so we don’t need anything more than its standard tools to create <span class="No-Break">our programs.</span></p>
			<p>Let’s explore the principal tools that facilitate building, testing, running, error-checking, and <span class="No-Break">code formatting.</span></p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>go build</h2>
			<p>The <strong class="source-inline">go build</strong> command<a id="_idIndexMarker013"/> is used to compile Go code into an executable binary that you <span class="No-Break">can run.</span></p>
			<p>Let’s see <span class="No-Break">an example.</span></p>
			<p>Assume you have a Go source file named <strong class="source-inline">main.go</strong> containing the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
package main
import "fmt"
func main() {
    fmt.Println("Hello, Go!")
}</pre>			<p>You can compile it using the <strong class="source-inline">go </strong><span class="No-Break"><strong class="source-inline">build</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
go build main.go</pre>			<p>This will generate an executable binary named <strong class="source-inline">main</strong> (or <strong class="source-inline">main.exe</strong> on Windows). You can then run the binary to see <span class="No-Break">the output:</span></p>
			<pre class="console">
./main</pre>			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>go test</h2>
			<p>The <strong class="source-inline">go test</strong> command<a id="_idIndexMarker014"/> is used to run tests on your Go code. It automatically finds test files and runs the associated <span class="No-Break">test functions.</span></p>
			<p>Here’s <span class="No-Break">an example.</span></p>
			<p>Assume you have a Go source file named <strong class="source-inline">math.go</strong> containing a function to add <span class="No-Break">two numbers:</span></p>
			<pre class="source-code">
package math
func Add(a, b int) int {
    return a + b
}</pre>			<p>You can create a test file named <strong class="source-inline">math_test.go</strong> to write tests for the <span class="No-Break"><strong class="source-inline">Add</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
package math
import "testing"
func TestAdd(t *testing.T) {
    result := Add(2, 3)
    if result != 5 {
        t.Errorf("Expected 5, but got %d", result)
    }
}</pre>			<p>Run the tests using <a id="_idIndexMarker015"/>the <strong class="source-inline">go </strong><span class="No-Break"><strong class="source-inline">test</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
go test</pre>			<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>go run</h2>
			<p>The <strong class="source-inline">go run</strong> command<a id="_idIndexMarker016"/> allows you to run Go code directly without explicitly compiling it into <span class="No-Break">an executable.</span></p>
			<p>Let’s see this using <span class="No-Break">an example.</span></p>
			<p>Assume you have a Go source file named <strong class="source-inline">hello.go</strong> containing the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
package main
import "fmt"
func main() {
    fmt.Println("Hello, Go!")
}</pre>			<p>You can directly run the code using the <strong class="source-inline">go </strong><span class="No-Break"><strong class="source-inline">run</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
go run hello.go</pre>			<p>This will execute the code and print <strong class="source-inline">Hello, Go!</strong> to <span class="No-Break">the console.</span></p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>go vet</h2>
			<p>We use the <strong class="source-inline">go vet</strong> command<a id="_idIndexMarker017"/> to check our Go code for potential errors or suspicious constructs. It employs heuristics that may not ensure all reports are actual issues, but it can uncover errors not caught by <span class="No-Break">the compilers.</span></p>
			<p>Here’s <span class="No-Break">an example.</span></p>
			<p>Assume you have a Go source file named <strong class="source-inline">error.go</strong> containing the following code with an <span class="No-Break">intentional error:</span></p>
			<pre class="source-code">
package main
import "fmt"
func main() {
    movie_year := 1999
    movie_title := "The Matrix"
    fmt.Printf("In %s, %s was released.\n", movie_year, movie_title)
}</pre>			<p>You can use the <strong class="source-inline">go vet</strong> command <a id="_idIndexMarker018"/>to check <span class="No-Break">for errors:</span></p>
			<pre class="console">
go vet error.go</pre>			<p>It might report a warning such as this: <strong class="source-inline">Printf format %s has arg 1999 of wrong </strong><span class="No-Break"><strong class="source-inline">type int</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>go fmt</h2>
			<p>The <strong class="source-inline">go fmt</strong> command<a id="_idIndexMarker019"/> is used to format your Go code according to the Go programming style guidelines. It automatically adjusts code indentation, spacing, <span class="No-Break">and more.</span></p>
			<p>Let’s see an example for <span class="No-Break">this too.</span></p>
			<p>Assume you have a Go source file named <strong class="source-inline">unformatted.go</strong> containing improperly <span class="No-Break">formatted code:</span></p>
			<pre class="source-code">
package main
import "fmt"
func main() {
        msg:="Hello"
        fmt.Println(msg) 
}</pre>			<p>You can format the code using the <strong class="source-inline">go </strong><span class="No-Break"><strong class="source-inline">fmt</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
go fmt unformatted.go</pre>			<p>It will update the code to match the standard <span class="No-Break">formatting conventions:</span></p>
			<pre class="source-code">
package main
import "fmt"
func main() {
        msg := "Hello"
        fmt.Println(msg)
}</pre>			<p>Now that we have a good grasp of the basic tools, we can start familiarizing ourselves with Go’s <span class="No-Break">cross-platform capabilities.</span></p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/>Cross-platform development with Go</h1>
			<p>Cross-platform development<a id="_idIndexMarker020"/> with Go<a id="_idIndexMarker021"/> is a breeze. You can write code running on various operating systems and architectures <span class="No-Break">with ease.</span></p>
			<p>Cross-platform development with Go can be achieved by using the <strong class="source-inline">GOOS</strong> and <strong class="source-inline">GOARCH</strong> environment variables. The <strong class="source-inline">GOOS</strong> environment variable<a id="_idIndexMarker022"/> specifies the OS you want to target, and<a id="_idIndexMarker023"/> the <strong class="source-inline">GOARCH</strong> environment variable specifies your <span class="No-Break">target architecture.</span></p>
			<p>For example, assume you have a Go source file <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
package main
import "fmt"
func main() {
    fmt.Println("This program runs in any OS!")
}</pre>			<p>To compile code for Linux, you would<a id="_idIndexMarker024"/> set the <strong class="source-inline">GOOS</strong> environment variable to <strong class="source-inline">linux</strong> and the <strong class="source-inline">GOARCH</strong> environment variable <a id="_idIndexMarker025"/><span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">amd64</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
GOOS=linux GOARCH=amd64 go build</pre>			<p>This command will compile the code <span class="No-Break">for Linux.</span></p>
			<p>You can also use the <strong class="source-inline">GOOS</strong> and <strong class="source-inline">GOARCH</strong> environment variables to run code on different platforms. For example, to run the code you compiled for Linux on macOS, you would set the <strong class="source-inline">GOOS</strong> environment <a id="_idIndexMarker026"/>variable to <strong class="source-inline">darwin</strong> and the <strong class="source-inline">GOARCH</strong> environment<a id="_idIndexMarker027"/> variable <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">amd64</strong></span><span class="No-Break">.</span></p>
			<pre class="console">
GOOS=darwin GOARCH=amd64 go run</pre>			<p>This command will run the code <span class="No-Break">on macOS.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Although Go strives for portability across various platforms, engaging with the OS via system calls inherently ties your code to specific OS features. Code that is heavily reliant on these operations might need conditional compilation or adjustments when aiming at <span class="No-Break">different platforms.</span></p>
			<p class="callout">Leveraging build flags in Go allows you to selectively compile specific sections of your code contingent upon particular conditions, such as the target OS <span class="No-Break">or architecture.</span></p>
			<p class="callout">This can be useful when creating programs that interface with the <strong class="source-inline">golang.org/x/sys</strong> package for Windows and <span class="No-Break">Unix-like systems.</span></p>
			<p>Assume that you have two Go source files named <strong class="source-inline">main_windows.go</strong> and <strong class="source-inline">main_linux.go</strong> and you want to use build tags to ensure <span class="No-Break">code segmentation.</span></p>
			<p>Here is an example of a code using build tags to segment <span class="No-Break">for Windows:</span></p>
			<pre class="source-code">
// go:build windows
package main
import "fmt"
func main() {
    fmt.Println("This is Windows!")
}</pre>			<p> We can do the same but aiming for Linux <span class="No-Break">this time:</span></p>
			<pre class="source-code">
// go:build linux
package main
import "fmt"
func main() {
    fmt.Println("This is Linux!")
}</pre>			<p>These are the <a id="_idIndexMarker028"/>commands to<a id="_idIndexMarker029"/> use to compile these <span class="No-Break">programs, respectively:</span></p>
			<pre class="console">
GOOS=windows go build -o app.exe
GOOS=linux go build -o app</pre>			<p>When we <a id="_idIndexMarker030"/>execute <strong class="source-inline">app</strong> within a Linux environment, it should<a id="_idIndexMarker031"/> print <strong class="source-inline">This is Linux!</strong>. Meanwhile, on a Windows system, running <strong class="source-inline">app.exe</strong> will display <strong class="source-inline">This </strong><span class="No-Break"><strong class="source-inline">is Windows!</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/>Summary</h1>
			<p>This chapter provided a comprehensive guide to why Go is a top choice for system programming and insights into Go’s design philosophy, emphasizing simplicity, robustness, and efficiency. We learned about Go’s concurrency model, its approach to interacting with the OS, and how to interact with the tools for cross-platform development. These lessons are helpful as they equip us with the knowledge needed to write, read, and maintain system-level code with Go, enabling improved performance and the ability to work <span class="No-Break">with concurrency.</span></p>
			<p>In the next chapter, we explore the concurrency concepts, refreshing all related concepts and building blocks. It will prepare us for more advanced interactions with OS interfaces, enhancing our ability to create powerful and <span class="No-Break">responsive programs.</span></p>
		</div>
	</div>
</div>
</body></html>