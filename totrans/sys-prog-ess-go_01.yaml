- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Why Go?
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择 Go？
- en: At some point in your programming journey, your programs performed I/O-related
    tasks such as creating and removing files and directories. They may have orchestrated
    the creation of new processes and the execution of other programs or even facilitated
    communication between threads and processes on the same computer and between processes
    on different computers connected via a network.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的编程旅程中某个时刻，你的程序执行了与 I/O 相关的任务，例如创建和删除文件和目录。它们可能已经编排了新进程的创建和其他程序的执行，甚至促进了在同一台计算机上运行的线程和进程之间以及通过网络连接的不同计算机上的进程之间的通信。
- en: When our programs center on using a low-level set of tasks, we categorize them
    as system programming.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的程序集中在使用一组低级任务时，我们将它们归类为系统编程。
- en: It is alleged that system programming is tedious. But I do not see it this way
    at all! In fact, it is quite the opposite – an enjoyable and entertaining experience.
    It is like being a magician. You get to control the operating system and hardware,
    and you can make things happen that would be impossible in other languages.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 据说系统编程是乏味的。但我根本不这么认为！事实上，它完全相反——是一种愉快和有趣的体验。它就像是一个魔术师。你可以控制操作系统和硬件，你可以让事情发生，这在其他语言中是不可能的。
- en: In this chapter, we discuss why Go is an excellent fit for building efficient,
    high-performance system software to support real-world scenarios.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论为什么 Go 语言非常适合构建高效、高性能的系统软件以支持现实世界的场景。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Choosing Go
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择 Go
- en: Concurrency and goroutines
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发和 goroutines
- en: Interacting with the OS
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与操作系统交互
- en: Tooling
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具
- en: Cross-platform development with Go
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Go 进行跨平台开发
- en: By the end of this chapter, you will have a grasp of where Go is in the ecosystem
    of system programming, the importance of the Go concurrency model to build efficient
    and high-performance system software, how Go chooses to interact with the OS,
    the Go approach to cross-platform development, and the main commands in the Go
    built-in tooling.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解 Go 在系统编程生态系统中的位置，Go 并发模型对于构建高效和高性能系统软件的重要性，Go 如何选择与操作系统交互，Go 的跨平台开发方法以及
    Go 内置工具的主要命令。
- en: Choosing Go
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择 Go
- en: 'There are plenty of languages in the system programming space nowadays: some
    are well established, such as C and C++; some form a wave of newcomers, such as
    Zig, Rust, and Odin; and others claim the title of “C/C++ killer,” with their
    pledges of impressive performance.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在系统编程空间中有许多语言：一些已经建立得很好，如 C 和 C++；一些是新来的浪潮，如 Zig、Rust 和 Odin；还有一些声称是“C/C++
    杀手”，承诺有令人印象深刻的性能。
- en: Sure, we can use all of them and achieve outstanding results. Still, we could
    fall into hidden traps such as a steep learning curve, high cognitive load, a
    lack of community and support, inconsistent APIs with constant breaking changes,
    and a lack of adoption.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以使用所有这些工具并取得出色的成果。然而，我们可能会陷入隐藏的陷阱，例如陡峭的学习曲线、高认知负荷、缺乏社区和支持、不一致的 API 以及频繁的破坏性更改，以及缺乏采用。
- en: Go’s design philosophy emphasizes simplicity, expressiveness, robustness, and
    efficiency. Its support for concurrency and strong dependency management, as well
    as its focus on composition, make it a compelling choice for system programming.
    Its creators aimed to build a language that provides powerful building blocks
    without unnecessary complexity, which makes writing, reading, understanding, and
    maintaining system-level code easier. People with programming experience usually
    take two weeks to get acquainted with Go. While they may not be considered experts,
    they can confidently read standard Go code and write basic to medium-complexity
    programs without struggle.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的设计哲学强调简单性、表达性、健壮性和效率。其对并发的支持、强大的依赖管理以及对其组合的关注，使其成为系统编程的一个有吸引力的选择。其创造者旨在构建一个提供强大构建块而不需要不必要复杂性的语言，这使得编写、阅读、理解和维护系统级代码变得更加容易。有编程经验的人通常需要两周时间来熟悉
    Go。虽然他们可能不被认为是专家，但他们可以自信地阅读标准的 Go 代码，并编写基本到中等复杂性的程序而不会感到困难。
- en: Also, Go is excellent for system programming because the language has a Unix-minded
    design by checking all the boxes for simplicity. Many programmers who are proficient
    in Python and Ruby often transition to Go, as it allows them to retain their level
    of expressiveness while achieving improved performance and the capability to work
    with concurrency.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Go 对于系统编程来说非常出色，因为该语言具有 Unix 风格的设计，通过检查所有简化项。许多熟练掌握 Python 和 Ruby 的程序员通常会转向
    Go，因为它允许他们保持表达性水平的同时，实现性能的提升和并发工作的能力。
- en: It is worth noting that Go’s philosophy doesn’t prioritize zero cost in terms
    of CPU usage. Instead, the language aims to reduce the effort demanded from programmers,
    which is considered more significant and, as a by-product, makes the experience
    enjoyable.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Go 的哲学并不优先考虑 CPU 使用上的零成本。相反，该语言旨在减少程序员所需付出的努力，这被认为更为重要，并且作为副产品，使得体验更加愉快。
- en: One of the leading criticisms of using Go for system programming is the **garbage
    collector** (**GC**), specifically its pauses and explicit memory limits. If you
    still have this pet peeve with Go, don’t worry. In [*Chapter 6*](B21662_06.xhtml#_idTextAnchor145),
    we’ll see that more granular memory management is available from Go 1.20 and above.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Go 进行系统编程的主要批评之一是垃圾回收器（**垃圾回收器**）（**GC**），特别是其暂停和显式内存限制。如果你对 Go 仍然有这种小烦恼，不用担心。在[*第
    6 章*](B21662_06.xhtml#_idTextAnchor145)中，我们将看到从 Go 1.20 及以上版本提供了更细粒度的内存管理。
- en: Note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In a GC pause worst-case scenario, the stop-the-world time is typically less
    than 100 microseconds.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在垃圾回收暂停的最坏情况下，停止世界的时间通常小于 100 微秒。
- en: Concurrency and goroutines
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发和 goroutines
- en: One of the most essential features of Go is its concurrency model. Concurrency
    is the ability to run multiple tasks at the same time. In system programming,
    executing many tasks in parallel is essential for improving the performance and
    responsiveness of our programs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Go 最基本的功能之一是其并发模型。并发是同时运行多个任务的能力。在系统编程中，并行执行多个任务是提高程序性能和响应性的关键。
- en: Concurrency
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发
- en: Real-time systems demand precision, with concurrency being a pivotal factor.
    These systems coordinate tasks with exceptional timing, particularly in scenarios
    where even milliseconds matter. Concurrency offers significant advantages by increasing
    throughput (a measure of how many units of information a system can process in
    a given amount of time) while decreasing task completion times. Real-life instances
    show how concurrency improves responsiveness, making systems more flexible and
    tasks more efficient. Moreover, concurrency’s isolation abilities guarantee data
    integrity by preventing interference.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 实时系统需要精确性，其中并发是一个关键因素。这些系统以出色的时机协调任务，尤其是在即使是毫秒也重要的场景中。并发通过增加吞吐量（衡量系统在给定时间内可以处理多少信息单位）的同时减少任务完成时间，提供了显著的优势。现实生活中的实例显示了并发如何提高响应性，使系统更加灵活，任务更加高效。此外，并发的隔离能力通过防止干扰来保证数据完整性。
- en: System programming involves a diverse range of tasks, from CPU-bound to I/O-bound.
    Concurrency orchestrates this diversity by allowing CPU-bound tasks to progress
    while I/O-bound tasks await resources.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 系统编程涉及各种任务，从 CPU 密集型到 I/O 密集型。并发通过允许 CPU 密集型任务进行的同时，I/O 密集型任务等待资源，来协调这种多样性。
- en: Later, in [*Chapter 10*](B21662_10.xhtml#_idTextAnchor211), when we discuss
    distributed systems, the importance of concurrency will shine. It orchestrates
    tasks across an application or even different nodes in the network, which is ideal
    for managing large-scale concurrency.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的[*第 10 章*](B21662_10.xhtml#_idTextAnchor211)中，当我们讨论分布式系统时，并发的重要性将变得明显。它协调应用程序或甚至网络中不同节点的任务，这对于管理大规模并发是理想的。
- en: Goroutines
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Goroutines
- en: Go’s concurrency model relies on goroutines and channels. Goroutines are lightweight
    execution threads, often referred to as green threads. Creating them is cost-effective.
    Unlike conventional threads, they exhibit remarkable efficiency, enabling thousands
    of goroutines to run simultaneously on just a few OS threads.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的并发模型依赖于 goroutines 和 channels。Goroutines 是轻量级的执行线程，通常被称为绿色线程。创建它们是成本效益的。与传统的线程不同，它们表现出非凡的效率，使得成千上万的
    goroutines 可以在仅几个操作系统线程上同时运行。
- en: Channels, on the other hand, provide a mechanism for goroutines to communicate
    and synchronize without resorting to locks. This approach is inspired by the **Communicating
    Sequential Process** (**CSP**) ([https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf](https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf))
    formalism, emphasizing coordinated interactions between concurrent components.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，通道为goroutines提供了一个无需求助于锁的通信和同步机制。这种方法受到了**通信顺序进程**（**CSP**）[https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf](https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf)形式主义的启发，强调并发组件之间的协调交互。
- en: Diverging from numerous other programming languages that depend on external
    libraries or threading constructs for concurrency, Go incorporates concurrency
    seamlessly into its core language design. This design decision leads to code that
    is not only easier to comprehend but also less susceptible to errors, as the complexities
    of threading are abstracted.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多依赖外部库或线程结构的并发编程语言不同，Go将并发无缝地融入其核心语言设计。这个设计决策不仅使代码更容易理解，而且更不容易出错，因为线程的复杂性被抽象化了。
- en: CSP-inspired model
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSP启发的模型
- en: Go’s concurrency model draws inspiration from CSP, a formal language for describing
    concurrent systems. CSP focuses on communication and synchronization between concurrently
    executing entities. Unlike traditional multi-threaded programming, CSP and Go
    prioritize communication through channels instead of shared memory, reducing complexity
    and potential hazards. Synchronization and coordination are essential, with CSP
    using channels for process synchronization and Go using similar channels to coordinate
    goroutines. Safety and isolation are key, as both languages ensure safe interaction
    through channels, enhancing predictability and reliability. Go’s channels directly
    realize CSP’s communication-based approach, providing a safe way for goroutines
    to exchange data without the pitfalls of shared memory and locks.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Go的并发模型从并发系统描述的正式语言CSP（Communicating Sequential Processes）中汲取了灵感。CSP专注于并发执行实体之间的通信和同步。与传统的多线程编程不同，CSP和Go优先考虑通过通道进行通信，而不是共享内存，这减少了复杂性和潜在风险。同步和协调是必不可少的，CSP使用通道进行进程同步，而Go使用类似的通道来协调goroutines。安全和隔离是关键，因为这两种语言都确保通过通道进行安全交互，增强了可预测性和可靠性。Go的通道直接实现了CSP基于通信的方法，为goroutines提供了一个安全的数据交换方式，避免了共享内存和锁的陷阱。
- en: Share by communication
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过沟通来共享
- en: 'The famous Go proverb, “Don’t communicate by sharing memory, share memory by
    communicating” is often a source of discussion and misinterpretation. Still, reading
    it as “Share by communicating, not by locking” would be more precise, mainly because
    mainstream languages often rely on locks to protect shared data, leading to potential
    issues such as deadlocks and race conditions. Go encourages a different paradigm:
    *sharing data through channels by sending and receiving messages*. This “share
    by communicating” philosophy reduces the need for explicit locks and promotes
    a safer concurrency environment.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 著名的围棋谚语，“不要通过共享记忆来沟通，要通过沟通来共享记忆”常常是讨论和误解的来源。然而，将其理解为“通过沟通来共享，而不是通过锁定”会更加精确，主要是因为主流语言通常依赖于锁来保护共享数据，这可能导致死锁和竞态条件等潜在问题。Go鼓励一种不同的范式：*通过发送和接收消息在通道中共享数据*。这种“通过沟通来共享”的哲学减少了显式锁的需求，并促进了一个更安全的并发环境。
- en: If you are into functional programming, I have great news for you. In Go, data
    is not implicitly shared between goroutines. In other words, the data is copied.
    Did you see the concern with data immutability? This stands in contrast to languages,
    where shared memory is the default mode of communication between threads. Go’s
    emphasis on explicit communication via channels helps avoid the unintended data
    sharing and race conditions that can arise in traditional threading models. Another
    benefit of this model is that there is no callback hell since every interaction
    with concurrent code is often read in a procedural manner. A regular Go function
    can be used in procedural code without tying the signatures with extra keywords.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你热衷于函数式编程，我有个好消息要告诉你。在Go中，数据不是在goroutines之间隐式共享的。换句话说，数据是被复制的。你注意到数据不可变性的问题了吗？这与那些共享内存是线程间通信默认模式的语言形成对比。Go强调通过通道进行显式通信，有助于避免在传统线程模型中可能出现的意外数据共享和竞态条件。这种模型的另一个好处是，没有回调地狱，因为与并发代码的每次交互通常都是按程序方式读取的。一个常规的Go函数可以在程序代码中使用，而不需要将签名与额外的关键字绑定。
- en: Note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Callback hell, also known as the “pyramid of doom,” is a term used in programming
    to describe a situation where nested and interdependent callback functions make
    the code difficult to read, understand, and maintain. This typically occurs in
    asynchronous programming environments, such as JavaScript, where callbacks are
    used to handle asynchronous operations.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 回调地狱，也称为“死亡金字塔”，是编程中用来描述嵌套和相互依赖的回调函数使代码难以阅读、理解和维护的一个术语。这种情况通常发生在使用回调处理异步操作的异步编程环境中，如
    JavaScript。
- en: In the next chapter, we will refresh all concepts of concurrency and its building
    blocks to prepare you for interacting with the OS interfaces.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将刷新并发及其构建块的所有概念，以便为您与操作系统接口的交互做好准备。
- en: In addition to its concurrency model, Go also provides a way to interact with
    the operating system at a low level. This is essential for system programming,
    where you often need to control the OS and hardware.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其并发模型外，Go 还提供了一种与操作系统在低级别交互的方式。这对于系统编程至关重要，在系统编程中，您通常需要控制操作系统和硬件。
- en: Interacting with the OS
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与操作系统交互
- en: Go’s approach to system calls is designed to be safe and efficient, especially
    in the context of its concurrency model.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Go 对系统调用的方法旨在安全高效，尤其是在其并发模型背景下。
- en: In Go, system calls are comparatively lower-level in comparison to certain other
    programming languages. It can be helpful if you need fine-grained control over
    system resources, but it also means you’re dealing with more low-level details.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，与某些其他编程语言相比，系统调用相对较低级。如果您需要精细控制系统资源，这可能很有帮助，但也意味着您正在处理更多低级细节。
- en: Making system calls often requires understanding the underlying operating system
    APIs and conventions. The side effect is that it can introduce a steeper learning
    curve if you are new to systems programming or lower-level development.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 调用系统通常需要理解底层操作系统 API 和约定。副作用是，如果您是系统编程或低级开发的新手，它可能会引入一个更陡峭的学习曲线。
- en: Not familiar with system calls? Fear not! The book’s second part will explore
    and experiment with them in detail to cover the main aspects we need to progress
    in our system programming journey.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 不熟悉系统调用？不用担心！本书的第二部分将详细探索和实验它们，以涵盖我们在系统编程之旅中需要进步的主要方面。
- en: Tooling
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具
- en: Go is like a toolbox. It has everything we need to build great software, so
    we don’t need anything more than its standard tools to create our programs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Go 就像一个工具箱。它拥有我们构建优秀软件所需的一切，因此我们不需要比其标准工具更多的东西来创建我们的程序。
- en: Let’s explore the principal tools that facilitate building, testing, running,
    error-checking, and code formatting.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索便于构建、测试、运行、错误检查和代码格式化的主要工具。
- en: go build
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: go build
- en: The `go build` command is used to compile Go code into an executable binary
    that you can run.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `go build` 命令将 Go 代码编译成可执行的二进制文件，您可以直接运行。
- en: Let’s see an example.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子。
- en: 'Assume you have a Go source file named `main.go` containing the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个名为 `main.go` 的 Go 源文件，其中包含以下代码：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can compile it using the `go` `build` command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `go build` 命令来编译它：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will generate an executable binary named `main` (or `main.exe` on Windows).
    You can then run the binary to see the output:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个名为 `main` 的可执行二进制文件（在 Windows 上为 `main.exe`）。然后您可以运行该二进制文件以查看输出：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: go test
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: go test
- en: The `go test` command is used to run tests on your Go code. It automatically
    finds test files and runs the associated test functions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`go test` 命令用于在您的 Go 代码上运行测试。它自动找到测试文件并运行相关的测试函数。'
- en: Here’s an example.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子。
- en: 'Assume you have a Go source file named `math.go` containing a function to add
    two numbers:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个名为 `math.go` 的 Go 源文件，其中包含一个用于添加两个数字的函数：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can create a test file named `math_test.go` to write tests for the `Add`
    function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建一个名为 `math_test.go` 的测试文件来为 `Add` 函数编写测试：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Run the tests using the `go` `test` command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `go test` 命令运行测试：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: go run
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: go run
- en: The `go run` command allows you to run Go code directly without explicitly compiling
    it into an executable.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`go run` 命令允许您直接运行 Go 代码，而无需显式将其编译成可执行文件。'
- en: Let’s see this using an example.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来看看。
- en: 'Assume you have a Go source file named `hello.go` containing the following
    code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个名为 `hello.go` 的 Go 源文件，其中包含以下代码：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can directly run the code using the `go` `run` command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `go run` 命令直接运行代码：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will execute the code and print `Hello, Go!` to the console.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行代码并将 `Hello, Go!` 打印到控制台。
- en: go vet
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: go vet
- en: We use the `go vet` command to check our Go code for potential errors or suspicious
    constructs. It employs heuristics that may not ensure all reports are actual issues,
    but it can uncover errors not caught by the compilers.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `go vet` 命令来检查我们的 Go 代码中可能存在的错误或可疑结构。它使用启发式方法，可能无法确保所有报告都是实际的问题，但它可以揭示编译器未捕获的错误。
- en: Here’s an example.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子。
- en: 'Assume you have a Go source file named `error.go` containing the following
    code with an intentional error:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个名为 `error.go` 的 Go 源文件，其中包含以下代码，并故意引入了错误：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can use the `go vet` command to check for errors:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `go vet` 命令来检查错误：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It might report a warning such as this: `Printf format %s has arg 1999 of wrong`
    `type int`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能会报告如下警告：`Printf 格式 %s 有 arg 1999 错误的类型 int`。
- en: go fmt
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: go fmt
- en: The `go fmt` command is used to format your Go code according to the Go programming
    style guidelines. It automatically adjusts code indentation, spacing, and more.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`go fmt` 命令用于根据 Go 编程风格指南格式化你的 Go 代码。它自动调整代码缩进、间距等。'
- en: Let’s see an example for this too.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个例子。
- en: 'Assume you have a Go source file named `unformatted.go` containing improperly
    formatted code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个名为 `unformatted.go` 的 Go 源文件，其中包含格式不正确的代码：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can format the code using the `go` `fmt` command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `go fmt` 命令格式化代码：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It will update the code to match the standard formatting conventions:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 它将更新代码以匹配标准格式化约定：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that we have a good grasp of the basic tools, we can start familiarizing
    ourselves with Go’s cross-platform capabilities.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经很好地掌握了基本工具，我们可以开始熟悉 Go 的跨平台功能。
- en: Cross-platform development with Go
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Go 进行跨平台开发
- en: Cross-platform development with Go is a breeze. You can write code running on
    various operating systems and architectures with ease.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Go 进行跨平台开发非常简单。你可以轻松编写在多种操作系统和架构上运行的代码。
- en: Cross-platform development with Go can be achieved by using the `GOOS` and `GOARCH`
    environment variables. The `GOOS` environment variable specifies the OS you want
    to target, and the `GOARCH` environment variable specifies your target architecture.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `GOOS` 和 `GOARCH` 环境变量可以实现 Go 的跨平台开发。`GOOS` 环境变量指定了你想要的目标操作系统，而 `GOARCH`
    环境变量指定了你的目标架构。
- en: 'For example, assume you have a Go source file named `main.go`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个名为 `main.go` 的 Go 源文件：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To compile code for Linux, you would set the `GOOS` environment variable to
    `linux` and the `GOARCH` environment variable to `amd64`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 Linux 编译代码，你需要将 `GOOS` 环境变量设置为 `linux`，将 `GOARCH` 环境变量设置为 `amd64`：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This command will compile the code for Linux.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将为 Linux 编译代码。
- en: You can also use the `GOOS` and `GOARCH` environment variables to run code on
    different platforms. For example, to run the code you compiled for Linux on macOS,
    you would set the `GOOS` environment variable to `darwin` and the `GOARCH` environment
    variable to `amd64`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `GOOS` 和 `GOARCH` 环境变量在不同的平台上运行代码。例如，要运行你在 Linux 上编译的代码在 macOS 上，你需要将
    `GOOS` 环境变量设置为 `darwin`，将 `GOARCH` 环境变量设置为 `amd64`。
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This command will run the code on macOS.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将在 macOS 上运行代码。
- en: Note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Although Go strives for portability across various platforms, engaging with
    the OS via system calls inherently ties your code to specific OS features. Code
    that is heavily reliant on these operations might need conditional compilation
    or adjustments when aiming at different platforms.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Go努力实现跨各种平台的可移植性，但通过系统调用与操作系统交互本质上会将你的代码绑定到特定的操作系统功能。高度依赖这些操作的代码在针对不同平台时可能需要进行条件编译或调整。
- en: Leveraging build flags in Go allows you to selectively compile specific sections
    of your code contingent upon particular conditions, such as the target OS or architecture.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 Go 中的构建标志允许你根据特定的条件（如目标操作系统或架构）有选择性地编译代码的特定部分。
- en: This can be useful when creating programs that interface with the `golang.org/x/sys`
    package for Windows and Unix-like systems.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这在创建与 `golang.org/x/sys` 包交互的程序时可能很有用，该包用于 Windows 和类 Unix 系统。
- en: Assume that you have two Go source files named `main_windows.go` and `main_linux.go`
    and you want to use build tags to ensure code segmentation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个名为 `main_windows.go` 和 `main_linux.go` 的 Go 源文件，并且你想要使用构建标签来确保代码分段。
- en: 'Here is an example of a code using build tags to segment for Windows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用构建标签对 Windows 进行分段的代码示例：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can do the same but aiming for Linux this time:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样做，但这次目标是 Linux：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'These are the commands to use to compile these programs, respectively:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是编译这些程序的相应命令：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When we execute `app` within a Linux environment, it should print `This is Linux!`.
    Meanwhile, on a Windows system, running `app.exe` will display `This` `is Windows!`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Linux环境中执行`app`时，它应该打印`This is Linux!`。同时，在Windows系统上运行`app.exe`将显示`This`
    `is Windows!`。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter provided a comprehensive guide to why Go is a top choice for system
    programming and insights into Go’s design philosophy, emphasizing simplicity,
    robustness, and efficiency. We learned about Go’s concurrency model, its approach
    to interacting with the OS, and how to interact with the tools for cross-platform
    development. These lessons are helpful as they equip us with the knowledge needed
    to write, read, and maintain system-level code with Go, enabling improved performance
    and the ability to work with concurrency.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全面介绍了为什么Go是系统编程的首选，以及Go的设计哲学的见解，强调简洁、健壮和高效。我们学习了Go的并发模型，它与操作系统的交互方式，以及如何与跨平台开发的工具交互。这些课程对我们很有帮助，因为它们为我们提供了编写、阅读和维护使用Go编写的系统级代码所需的知识，从而提高了性能并使我们能够处理并发。
- en: In the next chapter, we explore the concurrency concepts, refreshing all related
    concepts and building blocks. It will prepare us for more advanced interactions
    with OS interfaces, enhancing our ability to create powerful and responsive programs.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨并发概念，刷新所有相关概念和构建块。这将为我们准备更高级的与操作系统接口的交互，增强我们创建强大和响应性程序的能力。
