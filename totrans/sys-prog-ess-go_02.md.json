["```go\nfunc main() {\n  say(«hello»)\n  say(«world»)\n}\n```", "```go\nfunc say(s string) {\n  for i := 1; i < 5; i++ {\n     time.Sleep(500 * time.Millisecond)\n     fmt.Println(s)\n  }\n}\n```", "```go\nhello\nhello\nhello\nhello\nhello\nworld\nworld\nworld\nworld\nworld\n```", "```go\nfunc main() {\n  go say(«hello»)\n  say(«world»)\n}\n```", "```go\nfunc main() {\n  say(«hello»)\n  go say(«world»)\n}\n```", "```go\nhello\nhello\nhello\nhello\n```", "```go\nfunc main() {\n  wg := sync.WaitGroup{}\n  wg.Add(2)\n  go say(«world», &wg)\n  go say(\"hello\", &wg)\n  wg.Wait()\n}\n```", "```go\nfunc say(s string, wg *sync.WaitGroup) {\n  defer wg.Done()\n  for i := 0; i < 5; i++ {\n     fmt.Println(s)\n  }\n}\n```", "```go\npackage main\nimport (\n     \"fmt\"\n     \"sync\"\n)\nfunc main() {\n     fmt.Println(\"Total Items Packed:\", PackItems(0))\n}\nfunc PackItems(totalItems int) int {\n     const workers = 2\n     const itemsPerWorker = 1000\n     var wg sync.WaitGroup\n     itemsPacked := 0\n     for i := 0; i < workers; i++ {\n          wg.Add(1)\n          go func(workerID int) {\n               defer wg.Done()\n               // Simulate the worker packing items into boxes.\n               for j := 0; j < itemsPerWorker; j++ {\n                      itemsPacked = totalItems\n                    // Simulate packing an item.\n                    itemsPacked++\n               // Update the total items packed without proper synchronization.\n               totalItems = itemsPacked\n               }\n          }(i)\n     }\n     // Wait for all workers to finish.\n     wg.Wait()\n     return totalItems\n}\n```", "```go\nfunc main() {\n     times := 0\n     for {\n          times++\n          counter := PackItems(0)\n          if counter != 2000 {\n               log.Fatalf(\"it should be 2000 but found %d on execution %d\", counter, times)\n          }\n     }\n}\n```", "```go\nit should be 2000 but found 1170 on execution 16421\n```", "```go\nfor j := 0; j < itemsPerWorker; j++ {\n    itemsPacked = totalItems\n    runtime.Gosched() // emulating noise!\n    itemsPacked++\n    totalItems = itemsPacked\n}\n```", "```go\nit should be 2000 but found 1507 on execution 4\n```", "```go\npackage main\nimport (\n     \"testing\"\n)\nfunc TestPackItems(t *testing.T) {\n     totalItems := PackItems(2000)\n     expectedTotal := 2000\n     if totalItems != expectedTotal {\n          t.Errorf(\"Expected total: %d, Actual total: %d\", expectedTotal, totalItems)\n     }\n}\n```", "```go\ngo test -race\n```", "```go\n==================\nWARNING: DATA RACE\nRead at 0x00c00000e288 by goroutine 9:\n  example1.PackItems.func1()\n      /tmp/main.go:35 +0xa8\n  example1.PackItems.func2()\n      /tmp/main.go:45 +0x47\nPrevious write at 0x00c00000e288 by goroutine 8:\n  example1.PackItems.func1()\n      /tmp/main.go:39 +0xba\n  example1.PackItems.func2()\n      /tmp/main.go:45 +0x47\n// Other lines omitted for brevity\n```", "```go\nimport (\n     \"fmt\"\n     \"sync\"\n     \"sync/atomic\"\n)\n```", "```go\nfor j := 0; j < itemsPerWorker; j++ {\n    atomic.AddInt32(&totalItems, int32(itemsPacked))\n}\n```", "```go\npackage main\nimport (\n     \"fmt\"\n     \"sync\"\n)\nfunc main() {\n      m := sync.Mutex{}\n     fmt.Println(\"Total Items Packed:\", PackItems(&m, 0))\n}\nfunc PackItems(m *sync.Mutex, totalItems int) int {\n     const workers = 2\n     const itemsPerWorker = 1000\n     var wg sync.WaitGroup\n     for i := 0; i < workers; i++ {\n          wg.Add(1)\n          go func(workerID int) {\n               defer wg.Done()\n               for j := 0; j < itemsPerWorker; j++ {\n                    m.Lock()\n                    itemsPacked := totalItems\n                   itemsPacked++\n                      totalItems = itemsPacked\n                    m.Unlock()\n               }\n          }(i)\n     }\n     // Wait for all workers to finish.\n     wg.Wait()\n     return totalItems\n}\n```", "```go\nfor j := 0; j < itemsPerWorker; j++ {\n    m.Lock()\n    itemsPacked = totalItems\n    m.Unlock()\n    m.Lock()\n    itemsPacked++\n    m.Unlock()\n    m.Lock()\n    totalItems = itemsPacked\n    m.Unlock()\n}\n```", "```go\nBenchmark-8                   36546             32629 ns/op\nBenchmarkMultipleLocks-8      13243             91246 ns/op\n```", "```go\n make(Chan T)\n```", "```go\n make (chan string)\n```", "```go\npackage main\nfunc main() {\n    c := make(chan string)\n    c <- \"message\"\n}\n```", "```go\nfatal error: all goroutines are sleep – dead lock!\ngoroutine 1 [chan send]:\nmain.main()\n```", "```go\npackage main\nfunc main() {\n    c := make(chan string)\n    fmt.Println(<- c )\n}\n```", "```go\nfatal error: all goroutines are sleep – dead lock!\ngoroutine 1 [chan receive]:\nmain.main()\n```", "```go\npackage main\nfunc main() {\n    c := make(chan string)\n    c <- \"message\" // Sending\n    fmt.Println(<- c ) // Receiving\n}\n```", "```go\nfatal error: all goroutines are sleep – dead lock!\ngoroutine 1 [chan send]:\nmain.main()\n```", "```go\npackage main\nimport \"fmt\"\nfunc main() {\n    balls := make(chan string)\n    go throwBalls(\"red\", balls)\n    fmt.Println(<-balls, \"received!\")\n}\nfunc throwBalls(color string, balls chan string) {\n    fmt.Printf(\"throwing the %s ball\\n\", color)\n    balls <- color\n}\n```", "```go\nthrowing the red ball\nred received!\n```", "```go\nfunc main() {\n    balls := make(chan string)\n    go throwBalls(\"red\", balls)\n    go throwBalls(\"green\", balls)\n    fmt.Println(<-balls, \"received!\")\n}\n```", "```go\nthrowing the red ball\nred received!\n```", "```go\nfunc main() {\n    balls := make(chan string)\n    go throwBalls(\"red\", balls)\n    go throwBalls(\"green\", balls)\n    fmt.Println(<-balls, \"received!\")\n    fmt.Println(<-balls, \"received!\")\n}\n```", "```go\nfunc main() {\n    balls := make(chan string)\n    go throwBalls(\"red\", balls)\n    go throwBalls(\"green\", balls)\n    fmt.Println(<-balls, \"received!\")\n    fmt.Println(<-balls, \"received!\")\n    fmt.Println(<-balls, \"received!\")\n}\n```", "```go\nfunc main() {\n    balls := make(chan string)\n    go throwBalls(\"red\", balls)\n    go throwBalls(\"green\", balls)\n    for color := range balls {\n         fmt.Println(color, \"received!\")\n    }\n}\n```", "```go\nclose(balls)\n```", "```go\ngo throwBalls(\"green\", balls)\nclose(balls)\nfor color := range balls {\n```", "```go\nfunc main() {\n    balls := make(chan string)\n    wg := sync.WaitGroup{}\n    wg.Add(2)\n    go func() {\n        defer wg.Done()\n        throwBalls(\"red\", balls)\n    }()\n    go func() {\n        defer wg.Done()\n        throwBalls(\"green\", balls)\n    }()\n    go func() {\n        wg.Wait()\n        close(balls)\n    }()\n    for color := range balls {\n        fmt.Println(color, \"received!\")\n    }\n}\n```", "```go\nthrowing the green ball\ngreen received!\nthrowing the red ball\nred received!\n```", "```go\npackage main\nimport (\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\nfunc main() {\n    clownChannel := make(chan int, 3)\n    clowns := 5\n    // senders and receivers logic here!\n    var wg sync.WaitGroup\n    wg.Wait()\n    fmt.Println(\"Circus car ride is over!\")\n}\n```", "```go\ngo func() {\n        defer close(clownChannel)\n        for clownID := range clownChannel {\n            balloon := fmt.Sprintf(\"Balloon %d\", clownID)\n            fmt.Printf(\"Driver: Drove the car with %s inside\\n\", balloon)\n            time.Sleep(time.Millisecond * 500)\n            fmt.Printf(\"Driver: Clown finished with %s, the car is ready for more!\\n\", balloon)\n        }\n    }()\n```", "```go\nfor clown := 1; clown <= clowns; clown++ {\n    wg.Add(1)\n    go func(clownID int) {\n        defer wg.Done()\n        balloon := fmt.Sprintf(\"Balloon %d\", clownID)\n        fmt.Printf(\"Clown %d: Hopped into the car with %s\\n\", clownID, balloon)\n        select {\n            case clownChannel <- clownID:\n                fmt.Printf(\"Clown %d: Finished with %s\\n\", clownID, balloon)\n            default:\n                fmt.Printf(\"Clown %d: Oops, the car is full, can't fit %s!\\n\", clownID, balloon)\n        }\n    }(clown)\n}\n```", "```go\nClown 1: Hopped into the car with Balloon 1\nClown 1: Finished with Balloon 1\nDriver: Drove the car with Balloon 1 inside\nClown 2: Hopped into the car with Balloon 2\nClown 2: Finished with Balloon 2\nClown 5: Hopped into the car with Balloon 5\nClown 5: Finished with Balloon 5\nClown 3: Hopped into the car with Balloon 3\nClown 3: Finished with Balloon 3\nClown 4: Hopped into the car with Balloon 4\nClown 4: Oops, the car is full, can't fit Balloon 4!\nCircus car ride is over!\n```", "```go\npackage main\nimport (\n    \"fmt\"\n    \"sync\"\n)\nfunc main() {\n    signalChannel := make(chan bool)\n    var wg sync.WaitGroup\n    wg.Add(1)\n    go func() {\n        defer wg.Done()\n        fmt.Println(\"Goroutine 1 is waiting for a signal...\")\n        <-signalChannel\n        fmt.Println(\"Goroutine 1 received the signal and is now doing something.\")\n    }()\n    wg.Add(1)\n    go func() {\n        defer wg.Done()\n        fmt.Println(\"Goroutine 2 is about to send a signal.\")\n        signalChannel <- true\n        fmt.Println(\"Goroutine 2 sent the signal.\")\n    }()\n    wg.Wait()\n    fmt.Println(\"Both goroutines have finished.\")\n}\n```"]