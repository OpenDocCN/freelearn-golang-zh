- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Refreshing Concurrency and Parallelism
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刷新并发和并行性
- en: This chapter will explore goroutines at the core of Go’s concurrency. You will
    learn how they function, distinguish between concurrency and parallelism, manage
    currently running goroutines, handle data race issues, use channels for communication,
    and use `Channel` states and signaling to maximize their potential. Mastering
    these concepts is essential to write efficient and error-free Go code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨Go并发核心中的goroutines。你将学习它们是如何工作的，区分并发和并行性，管理当前运行的goroutines，处理数据竞争问题，使用通道进行通信，并使用`Channel`状态和信号来最大化其潜力。掌握这些概念对于编写高效且无错误的Go代码至关重要。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding goroutines
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解goroutines
- en: Managing data races
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理数据竞争
- en: Making sense of channels
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解通道
- en: The guarantee of delivery
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交付保证
- en: State and signaling
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态和信号
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find this chapter’s source code at [https://github.com/PacktPublishing/System-Programming-Essentials-with-Go/tree/main/ch2](https://github.com/PacktPublishing/System-Programming-Essentials-with-Go/tree/main/ch2).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这个章节的源代码中找到[https://github.com/PacktPublishing/System-Programming-Essentials-with-Go/tree/main/ch2](https://github.com/PacktPublishing/System-Programming-Essentials-with-Go/tree/main/ch2)。
- en: Understanding goroutines
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解goroutines
- en: Goroutines are functions created and scheduled to be run independently by the
    Go scheduler. The Go scheduler is responsible for the management and execution
    of goroutines.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Goroutines是由Go调度器创建和调度以独立运行的函数。Go调度器负责goroutines的管理和执行。
- en: Behind the scenes, we have a complex algorithm to make goroutines work. Fortunately,
    in Golang, we can achieve this highly complex operation with simplicity using
    the `go` keyword.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，我们有一个复杂的算法来使goroutines工作。幸运的是，在Golang中，我们可以使用`go`关键字以简单的方式实现这个高度复杂的操作。
- en: Note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are accustomed to a language that has the `async`/`await` feature, you
    probably are used to deciding your function beforehand. It will be used concurrently
    to change the function signature to sign that the function can be paused/resumed.
    Calling this function also needs a special notation. When using goroutines, there
    is no need to change the function signature.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯于具有`async`/`await`功能的语言，你可能已经习惯了事先决定你的函数。它将被并发使用来更改函数签名，以表示该函数可以被暂停/恢复。调用此函数也需要特殊的符号。当使用goroutines时，不需要更改函数签名。
- en: 'In the following snippets, we have a main function calling sequentially the
    `say` function, passing as an argument `"hello"` and `"``world"`, respectively:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们有一个主函数依次调用`say`函数，分别传递参数`"hello"`和`"world"`：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `say` function receives a string as a parameter and iterates five times.
    For each iteration, we make the function sleep for 500 milliseconds and print
    the `s` parameter immediately after:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`say`函数接收一个字符串作为参数，并迭代五次。对于每次迭代，我们让函数休眠500毫秒，并在打印`s`参数后立即执行：'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When we execute the program, it should print the following output:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行程序时，它应该打印以下输出：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we introduce the `go` keyword right before the first call to the `say`
    function to introduce concurrency in our program:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在`say`函数的第一次调用之前引入`go`关键字，以在我们的程序中引入并发：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The output should alternate between `hello` and `world`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该在`hello`和`world`之间交替。
- en: So, we can achieve the same result if we create a goroutine for the second function
    call, right?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们为第二次函数调用创建一个goroutine，我们也能达到相同的结果，对吗？
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s see the results of the program now:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看程序的结果：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Wait! Something is wrong here. What did we do wrong? The main function and the
    goroutine seem out of sync.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！这里有什么不对劲。我们做错了什么？主函数和goroutine似乎不同步。
- en: We didn’t do anything wrong. That is the expected behavior. When you take a
    closer look at the first program, the goroutine is fired, and the second call
    of `say` executes in the context of the main function sequentially.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有做错什么。这是预期的行为。当你仔细观察第一个程序时，goroutine被触发，`say`的第二次调用在主函数的上下文中顺序执行。
- en: In other words, the program should wait for the function to terminate to reach
    the end of the `main` function. For the second program, we have the opposite behavior.
    The first call is a normal function call, so it prints five times as expected,
    but when the second goroutine is fired, there is no following instruction on the
    main function, so the program terminates.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，程序应该等待函数终止，以便达到`main`函数的末尾。对于第二个程序，我们有相反的行为。第一次调用是一个正常的函数调用，所以它按照预期打印了五次，但当第二个goroutine被触发时，主函数没有后续指令，所以程序终止。
- en: Although the behavior is correct from the perspective of how the program works,
    this is not our intention. We need a way to synchronize the `wait` for all the
    goroutines in this group of executions before giving the `main` function a chance
    to terminate. In situations such as this, we can leverage Go’s construct, the
    `sync` package, called `WaitGroup`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从程序运行的角度来看，行为是正确的，但这不是我们的意图。我们需要一种方法来在给`main`函数一个终止的机会之前，同步这个执行组中所有goroutine的`wait`。在这种情况下，我们可以利用Go的构造，即`sync`包中的`WaitGroup`。
- en: WaitGroup
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WaitGroup
- en: '`WaitGroup`, as the name suggests, is a Go standard library mechanism that
    allows us to wait for a group of goroutines until they finish explicitly.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如同其名，`WaitGroup`是Go标准库中的一种机制，允许我们等待一组goroutine直到它们显式完成。
- en: No particular factory function exists to create them, since their zero-value
    is already a valid usable state. Since `WaitGroup` has been created, we need to
    control how many goroutines we are waiting for. We can use the `Add()` method
    to inform the group.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 没有特定的工厂函数来创建它们，因为它们的零值已经是一个有效的可用状态。由于`WaitGroup`已经被创建，我们需要控制我们正在等待多少个goroutine。我们可以使用`Add()`方法来通知这个组。
- en: How can we inform the group that we have completed one of the routines? It couldn’t
    be more intuitive. We can achieve this using the `Done()` method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何通知组我们已经完成了一个任务？这再直观不过了。我们可以使用`Done()`方法来实现这一点。
- en: 'In the following example, we introduce the wait group to make our program output
    the messages as intended:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们引入`wait group`来使我们的程序按照预期输出消息：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We create the `WaitGroup` ( `wg := sync.WaitGroup{}`) and declare that two goroutines
    participate in this group (`wg.Add(2)`).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建`WaitGroup`（`wg := sync.WaitGroup{}`）并声明有两个goroutine参与这个组（`wg.Add(2)`）。
- en: In the last line of the program, we explicitly hold the execution with the `Wait()`
    method to avoid the program termination.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的最后一行，我们使用`Wait()`方法显式地保持执行，以避免程序终止。
- en: To make our function interact with `Waitgroup`, we need to send a reference
    to this group. Once we have its reference, the function can defer, calling `Done()`,
    to ensure that we signal correctly for our group every time the function is complete.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要使我们的函数与`Waitgroup`交互，我们需要发送对这个组的引用。一旦我们有了它的引用，函数就可以延迟调用`Done()`，以确保每次函数完成时都能正确地为我们组发出信号。
- en: 'This is the new `say` function:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新的`say`函数：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We don’t need to rely on `time.Sleep()`, so this version doesn’t have it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要依赖`time.Sleep()`，所以这个版本没有它。
- en: Now, we can control our group of goroutines. Let’s deal with one central worrisome
    issue in concurrent programming – state.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以控制我们的goroutine组。让我们处理并发编程中的一个核心担忧问题——状态。
- en: Changing shared state
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变共享状态
- en: Imagine a scenario where two diligent workers are tasked with packing items
    into boxes in a busy warehouse. Each worker fills a fixed number of things into
    packets, and we must keep track of the total number of items packed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个场景，两个勤奋的工人在繁忙的仓库里负责将物品装箱。每个工人将固定数量的物品装入包中，我们必须跟踪打包的总物品数量。
- en: This seemingly straightforward task, analogous to concurrent programming, can
    quickly become a nightmare when not handled properly. With proper synchronization,
    the workers may avoid intentionally interfering with each other’s work, leading
    to incorrect results and unpredictable behavior. It’s a classic example of a data
    race, a common challenge in concurrent programming.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个看似简单的任务，类似于并发编程，如果处理不当，很快就会变成一场噩梦。有了适当的同步，工作者可以避免有意干扰彼此的工作，导致结果不正确和不可预测的行为。这是一个经典的数据竞争示例，是并发编程中常见的挑战。
- en: The following code will walk you through an analogy where two warehouse workers
    face a data race issue while packing items into boxes. We’ll first present the
    code without proper synchronization, demonstrating the data race problem. Then,
    we’ll modify the code to address the issue, ensuring that the workers collaborate
    smoothly and accurately.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将向您展示一个类比，其中两个仓库工人面对打包项目时的数据竞争问题。我们首先展示没有适当同步的代码，以演示数据竞争问题。然后，我们将修改代码以解决问题，确保工人能够顺利且准确地合作。
- en: 'Let’s step into the bustling warehouse and witness firsthand the challenges
    of concurrency and the importance of synchronization in this example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们走进熙熙攘攘的仓库，亲眼见证并发挑战以及在这个例子中同步的重要性：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `main` function starts by calling the `PackItems` function with an initial
    `totalItems` value of 0.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数首先调用`PackItems`函数，初始`totalItems`值为0。'
- en: 'In the `PackItems` function, there are two constants defined:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PackItems`函数中，定义了两个常量：
- en: '`workers`: The number of worker goroutines (set to 2)'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`workers`：工作goroutine的数量（设置为2）'
- en: '`itemsPerWorker`: The number of items each worker should pack into boxes (set
    to 1,000)'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`itemsPerWorker`：每个工人应该打包进箱子的项目数量（设置为1,000）'
- en: '`WaitGroup` named `wg` is created to wait for all worker goroutines to finish
    before returning the final `totalItems` value.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 创建名为`wg`的`WaitGroup`，等待所有工作goroutine完成，然后返回最终的`totalItems`值。
- en: 'A loop runs `workers` times, where each iteration starts a new goroutine to
    simulate a worker packing items into boxes. Inside the goroutine, the following
    steps are performed:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个循环运行`workers`次，其中每次迭代启动一个新的goroutine来模拟工人将项目打包进箱子。在goroutine内部，执行以下步骤：
- en: A worker ID is passed to the goroutine as an argument.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个工人ID作为参数传递给goroutine。
- en: The `defer wg.Done()` statement ensures that the wait group is decremented when
    the goroutine exits.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`defer wg.Done()`语句确保当goroutine退出时，等待组会递减。'
- en: An `itemsPacked` variable is initialized with the current value of `totalItems`
    to keep track of the items packed by this worker.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`itemsPacked`变量初始化为`totalItems`的当前值，以跟踪此工人打包的项目。'
- en: A loop runs `itemsPerWorker` times, simulating the process of packing items
    into boxes. However, there’s no actual packing happening;the loop’s just incrementing
    the `itemsPacked` variable.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个循环运行`itemsPerWorker`次，模拟将项目打包进箱子的过程。然而，实际上并没有发生打包；循环只是递增`itemsPacked`变量。
- en: In the last step in the inner loop, `totalItems` receive the altered value of
    the `itemsPacked` variable, which contains the number of items packed by the worker.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内循环的最后一步，`totalItems`接收`itemsPacked`变量的修改后的值，该变量包含工人打包的项目数量。
- en: '`totalItems` variable by adding the `itemsPacked` value to it.'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将`itemsPacked`值添加到`totalItems`变量中。
- en: Since multiple goroutines attempt to modify `totalItems` concurrently without
    proper synchronization, a data race occurs, leading to unpredictable and incorrect
    results.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于多个goroutine尝试在不适当的同步下并发修改`totalItems`，因此发生数据竞争，导致不可预测和不正确的结果。
- en: Nondeterministic results
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非确定性结果
- en: 'Consider this alternative `main` function:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个替代的`main`函数：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The program constantly runs the `PackItems` function until the expected result
    of 2,000 is not achieved. Once this occurs, the program will display the incorrect
    value returned by the function and the number of attempts it took to reach that
    point.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 程序会不断运行`PackItems`函数，直到达到预期的2,000个结果。一旦发生这种情况，程序将显示函数返回的错误值以及达到该点所需的尝试次数。
- en: Because of the non-deterministic nature of the Go scheduler, the result would
    be right *most of the time*. This code would need a lot of runs to reveal its
    synchronization flaw.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Go调度器的非确定性，结果大多数时候是正确的。这段代码需要多次运行才能揭示其同步缺陷。
- en: 'In a single execution, I needed more than 16,000 iterations:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在单次执行中，我需要超过16,000次迭代：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Your turn!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您的机会！
- en: Experiment running the code on your machine. How many iterations did your code
    need to fail?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的机器上运行代码的实验。您的代码需要多少次迭代才能失败？
- en: If you’re using your personal computer, there are likely many tasks being performed,
    but your machine probably has a lot of unused resources. However, it’s important
    to consider the amount of noise on shared nodes in a cluster if you’re running
    programs in cloud environments with containers. By “noise,” I mean the work done
    on the host machine while running your program. It may be just as idle as your
    local experiment. Still, it’s likely being used to its full potential in a cost-effective
    scenario where every core and memory is utilized.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用个人电脑，可能有很多任务正在执行，但你的机器可能有很多未使用的资源。然而，如果你在具有容器的云环境中运行程序，重要的是要考虑集群中共享节点上的噪声量。这里的“噪声”是指在运行你的程序时在主机机器上执行的工作。它可能和你本地的实验一样空闲。然而，在成本效益高的场景中，每个核心和内存都得到充分利用，它很可能被充分利用。
- en: This scenario of a constant contest for resources makes our schedule much more
    inclined to choose another workload instead of just continuing to run our goroutine.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对资源的持续竞争场景使得我们的调度器更倾向于选择其他工作负载，而不是仅仅继续运行我们的goroutine。
- en: 'In the following example, we call the `runtime.Gosched` function to emulate
    noise. The idea is to give a hint to the Go scheduler, saying, “*Hey! Maybe it
    is a good moment to* *pause me*”:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们调用 `runtime.Gosched` 函数来模拟噪声。想法是向Go调度器发出提示，“*嘿！也许现在是暂停我的好时机*”：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Running the main function again, we can see that the erroneous results occur
    much faster than before. In my execution, for example, I need just four iterations:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行主函数，我们可以看到错误的结果比以前出现得更快。例如，在我的执行中，我只需要四次迭代：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Unfortunately, the code is still buggy. How can we anticipate that? At this
    point, you should have guessed that Go tools have the answer, and you’re right
    again. We can manage data races on our tests.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，代码仍然存在bug。我们如何预见到这一点？到目前为止，你应该已经猜到了Go工具提供了答案，而且你又猜对了。我们可以在测试中管理数据竞争。
- en: Managing data races
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理数据竞争
- en: When multiple goroutines access shared data or resources concurrently, a “race
    condition” can occur. As we can attest, this type of concurrency bug can lead
    to unpredictable and undesirable behavior. The Go test tool has a built-in feature
    called **Go race detection** that can detect and identify race conditions in your
    Go code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个goroutines并发访问共享数据或资源时，可能会发生“竞争条件”。正如我们所证明的，这种类型的并发bug可能导致不可预测和不受欢迎的行为。Go测试工具有一个内置功能，称为**Go竞争检测**，可以检测和识别Go代码中的竞争条件。
- en: 'So, let’s create a `main_test.go` file with a simple test case:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们创建一个 `main_test.go` 文件，并添加一个简单的测试用例：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let’s use the race detector:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用竞争检测器：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The result in the console will be something like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台中的结果可能如下所示：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The output can be quite intimidating at first glance, but the most revealing
    information initially is the message `WARNING:` `DATA RACE`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 初次看到输出时可能会感到有些令人畏惧，但最初最引人注目的信息是消息 `WARNING:` `DATA RACE`。
- en: To fix the synchronization issue in this code, we should use synchronization
    mechanisms to protect access to the `totalItems` variable. Without proper synchronization,
    concurrent writes to shared data can lead to race conditions and unexpected results.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复此代码中的同步问题，我们应该使用同步机制来保护对 `totalItems` 变量的访问。如果没有适当的同步，对共享数据的并发写入可能导致竞争条件和意外结果。
- en: We have used `WaitGroup` from the `sync` package. Let’s explore more synchronization
    mechanisms to ensure the program’s correctness.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了 `sync` 包中的 `WaitGroup`。让我们探索更多的同步机制，以确保程序的正确性。
- en: Atomic operations
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原子操作
- en: It’s heartbreaking that the term “atomic” in Go doesn’t involve physically manipulating
    atoms, like in physics or chemistry. It would be fascinating to have that capability
    in programming; instead, atomic operations in Go are focused on synchronizing
    and managing concurrency among goroutines using the sync/atomic package.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，“atomic”这个术语并不涉及物理上操纵原子，就像在物理学或化学中那样，这让人感到心碎。在编程中拥有这种能力将是非常有趣的；相反，Go中的原子操作专注于使用
    `sync/atomic` 包同步和管理goroutines之间的并发。
- en: Go offers atomic operations to load, store, add, and `int32`, `int64`, `uint32`,
    `uint64`, `uintptr`, `float32`, and `float64`. Atomic operations can’t be directly
    performed on arbitrary data structures.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了原子操作来加载、存储、添加以及 `int32`、`int64`、`uint32`、`uint64`、`uintptr`、`float32` 和
    `float64`。原子操作不能直接在任意数据结构上执行。
- en: 'Let’s change our program using the atomic package. First, we should import
    it:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用原子包修改我们的程序。首先，我们应该导入它：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Instead of updating `totalItems` directly, we will leverage the `AddInt32`
    function to guarantee the synchronization:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用`AddInt32`函数而不是直接更新`totalItems`来保证同步：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If we check for data races again, no problem will be reported.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次检查数据竞争，将不会报告任何问题。
- en: Atomic structures are great when we need to synchronize a single operation,
    but when we want to synchronize a block of code, other tools are a better fit,
    such as mutexes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要同步单个操作时，原子结构非常出色，但当我们想要同步一段代码块时，其他工具则更为合适，例如互斥锁（mutexes）。
- en: Mutexes
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 互斥锁
- en: Ah, mutexes! They’re like the bouncers at a party for goroutines. Imagine a
    bunch of these little Go creatures trying to dance around with shared data. It’s
    all fun and games until chaos breaks loose, and you have a goroutine traffic jam
    with data spills all over the place!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 哎，互斥锁！它们就像是派对上的保安，为goroutines提供保护。想象一下，有一群这些小小的Go生物试图围绕共享数据进行舞蹈。一切都很愉快，直到混乱爆发，你会有一个goroutine交通堵塞，数据到处溢出！
- en: Do not worry, as mutexes swoop in like the dance-floor supervisors, ensuring
    that only one groovy goroutine can bust a move in the critical section at a time.
    They’re like the rhythm keepers of concurrency, ensuring that everyone takes turns
    and nobody steps on each other’s toes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心，因为互斥锁就像舞池管理员一样迅速介入，确保在任意时刻只有一个酷炫的goroutine能在关键部分进行操作。它们就像是并发的节奏守护者，确保每个人轮流进行，没有人会踩到别人的脚趾。
- en: You can create a mutex by declaring a variable of type `sync.Mutex`. A mutex
    allows us to protect a critical section of code, using the `Lock()` and `Unlock()`
    methods. When a goroutine calls `Lock()`, it acquires the mutex lock, and any
    other goroutines attempting to call `Lock()` will be blocked until the lock is
    released with `Unlock()`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过声明一个`sync.Mutex`类型的变量来创建一个互斥锁。互斥锁允许我们使用`Lock()`和`Unlock()`方法来保护代码的关键部分。当一个goroutine调用`Lock()`时，它会获取互斥锁，而任何尝试调用`Lock()`的其他goroutine将会被阻塞，直到锁通过`Unlock()`被释放。
- en: 'Here is the code for our program using mutex:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们程序使用互斥锁的代码：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, we lock a block of code handling to change our shared state,
    and when we’re done, we unlock the mutex.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们锁定了一段处理共享状态更改的代码块，并在完成后解锁互斥锁。
- en: 'If the mutexes ensure the correctness handling shared state, you could consider
    two options:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果互斥锁确保了共享状态的正确处理，你可以考虑两种选择：
- en: You could use lock and unlock for every critical line
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以为每个关键行使用加锁和解锁。
- en: You could simply lock in the beginning of the function and defer the unlock
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在函数开始时简单地加锁，并使用`defer`延迟解锁。
- en: Yes, you could! Sadly, there is a catch in both approaches. We introduce latency
    indiscriminately. To make my point, let’s benchmark the second approach versus
    the original use of mutex.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你可以这样做！遗憾的是，这两种方法都存在一个缺陷。我们会无差别地引入延迟。为了说明这一点，让我们基准测试第二种方法与原始互斥锁的使用。
- en: Let’s create a second version of the function using multiple calls to lock/unlock,
    called `MultiplePackItems`, where everything remains the same except the function
    name and the inner loop.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个使用多次加锁/解锁调用的函数的第二个版本，称为`MultiplePackItems`，其中除了函数名和内部循环之外，其他一切保持不变。
- en: 'Here is the inner loop:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是内部循环的代码：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s look at the performance of both options running a benchmark test:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过基准测试来查看这两种选项的性能：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The version with multiple locks is approximately **~64%** slower than the first
    one in terms of the time taken per operation.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 多重锁的版本在每次操作所需的时间上大约比第一个版本慢**~64%**。
- en: Benchmarks
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试
- en: We’ll cover in detail benchmarks and other techniques of performance measurement
    in [*Chapter 6*](B21662_06.xhtml#_idTextAnchor145), *Analyzing Performance*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第6章*](B21662_06.xhtml#_idTextAnchor145)《分析性能》中详细讨论基准测试和其他性能测量技术。
- en: These examples show goroutines performing their tasks independently, without
    collaborating with each other. However, in many cases, our tasks require exchanging
    information or signals to make decisions, such as starting or stopping a procedure.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子显示了goroutines独立执行任务，没有相互协作。然而，在许多情况下，我们的任务需要交换信息或信号来做出决策，例如启动或停止一个过程。
- en: When exchanging information is crucial, we can use a flagship tool in Go called
    a channel.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当信息交换至关重要时，我们可以使用Go语言中的一个旗舰工具——通道（channel）。
- en: Making sense of channels
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解通道的意义
- en: Welcome to the channel carnival!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到通道狂欢节！
- en: Imagine Go channels as magical, clown-sized pipes that allow circus performers
    (goroutines) to pass around juggling balls (data) while making sure nobody drops
    the ball – quite literally!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 想象Go通道就像神奇的、巨型的管子，允许马戏团表演者（goroutines）在确保没有人掉球的情况下传递玩球（数据）。这字面意义上来说，确保没有人掉球。
- en: How to use channels
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用通道
- en: 'To use channels, we need to use a built-in function called `make()`, informing
    what type of data we’re interested in passing using this channel:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用通道，我们需要使用一个内置函数`make()`，来告知我们想要通过这个通道传递哪种类型的数据：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we want a channel of `string`, we should declare the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要一个`string`类型的通道，我们应该声明以下内容：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can inform a capacity. Channels with capacity are called buffered channels.
    We won’t bother going into detail about capacity for now. We create an unbuffered
    channel when we don’t inform the capacity.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定容量。具有容量的通道称为缓冲通道。现在我们不会深入讨论容量的问题。当我们没有指定容量时，我们创建一个无缓冲通道。
- en: An unbuffered channel
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无缓冲通道
- en: An unbuffered channel is a way to communicate between multiple goroutines, and
    it needs to respect a simple rule – the goroutine that wants to send in the channel
    and the one that wants to receive should be **ready** at the same time.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 无缓冲通道是多个goroutine之间通信的一种方式，它需要遵守一个简单的规则——想要通过通道发送数据和想要接收数据的goroutine应该同时**准备好**。
- en: Think of this as a “trust fall” exercise. The sender and receiver must trust
    each other fully, ensuring the safety of the data, just like acrobats trust their
    partners to catch them mid-air.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将其想象成一个“信任跌落”练习。发送者和接收者必须完全信任对方，确保数据的安全，就像杂技演员信任他们的搭档在空中接住他们一样。
- en: Abstract? Let’s explore this concept with examples.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象？让我们通过示例来探索这个概念。
- en: 'First, let’s send information to a channel with no receiver:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们向一个没有接收者的通道发送信息：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When we execute, the console will print something like the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行时，控制台将打印出类似以下内容：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Let’s break down this output.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析这个输出。
- en: '`all goroutines are sleep – deadlock!` is the main error message. It tells
    us that all goroutines in our program are in a `sleep` state, which implies that
    they are waiting for some event or resource to become available. However, because
    all of them are waiting and cannot make any progress, your program has encountered
    a deadlock situation.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`all goroutines are sleep – deadlock!`是主要的错误信息。它告诉我们，我们程序中的所有goroutine都处于`sleep`状态，这意味着它们正在等待某些事件或资源变得可用。然而，由于它们都在等待并且无法取得任何进展，程序遇到了死锁情况。'
- en: '`goroutine 1 [chan send]:` is the part of the message that provides additional
    information about the specific goroutine that has encountered the deadlock. In
    this case, it’s `goroutine 1`, and it was involved in a channel send operation
    (`chan send`).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`goroutine 1 [chan send]:`是消息的一部分，提供了关于遇到死锁的具体goroutine的额外信息。在这种情况下，它是`goroutine
    1`，并且它参与了通道发送操作（`chan send`）。'
- en: This deadlock occurs because the execution is paused, waiting for another goroutine
    to receive the information, but there’s none.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这种死锁发生是因为执行被暂停，等待另一个goroutine接收信息，但没有人这么做。
- en: Deadlocks
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 死锁
- en: A deadlock is a condition where two or more processes or goroutines are unable
    to proceed because they are all waiting for something that will never happen.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 死锁是一种条件，其中两个或多个进程或goroutine无法继续进行，因为它们都在等待永远不会发生的事情。
- en: 'Now, we can try the opposite; in the next example, we want to receive from
    a channel with no sender:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以尝试相反的情况；在下一个示例中，我们想要从一个没有发送者的通道接收信息：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output in the console is very similar, except that now, the error is about
    receiving:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出的内容非常相似，但现在错误信息是关于接收的：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, following the rule is as simple as sending and receiving simultaneously.
    So, declaring both will be sufficient:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，遵循规则就像同时发送和接收一样简单。所以，声明两者都将是足够的：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It’s a good idea, but unfortunately, it doesn’t work, as we can see in the
    following output:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个好主意，但不幸的是，它不起作用，正如我们可以在以下输出中看到的那样：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If we’re following the rule, why is it not working?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遵循规则，为什么它不起作用呢？
- en: Well, we’re not exactly following the rule. The rule states that the goroutine
    that wants to send in the channel and the one that wants to receive should be
    *ready* at the same time.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们并没有完全遵循规则。规则指出，想要通过通道发送数据和想要接收数据的goroutine应该同时**准备好**。
- en: The important thing to take note of is the final part – *ready at the* *same
    time*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要部分是最后的部分——**同时准备好**。
- en: Since the code runs sequentially, line by line, when we try to send `c <- "message"`,
    the program waits for the receiver to receive the message. We need to make these
    two parties send and receive the message simultaneously. We can use our concurrent
    programming knowledge to make this happen.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码是按顺序逐行运行的，当我们尝试发送`c <- "message"`时，程序会等待接收者接收消息。我们需要让这两方同时发送和接收消息。我们可以使用我们的并发编程知识来实现这一点。
- en: 'Let’s add goroutines to the mix, using the circus analogy. We’ll introduce
    a function, `throwBalls`, that will expect the color of the balls to be thrown
    (`color`) and the channel (`balls`) where it should receive these throws:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在混合中使用goroutine，使用马戏团类比。我们将引入一个函数`throwBalls`，它将期望抛出的球的颜色（`color`）和它应该接收这些抛出的通道（`balls`）：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, we have three major steps:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有三个主要步骤：
- en: We create an unbuffered string channel named `balls`.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个无缓冲的字符串通道，名为`balls`。
- en: A goroutine is launched inline using the `throwBalls` function to send “red”
    into the channel.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`throwBalls`函数内联启动goroutine来将“红色”发送到通道。
- en: The main function receives and prints the value received from the channel.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主函数接收并打印从通道接收到的值。
- en: 'The output for this example is as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的输出如下：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We did it! We successfully passed information between goroutines using channels!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做到了！我们成功地在goroutine之间使用通道传递了信息！
- en: 'But what happens when we send one more ball? Let’s try it with a green ball:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当我们再发送一个球时会发生什么？让我们用绿色球试一试：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The output shows just one ball being received. What happened?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 输出只显示接收到一个球。发生了什么？
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Red or green?
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 红色还是绿色？
- en: Since we’re launching more than one goroutine, the scheduler will elect arbitrarily
    what should execute first. Therefore, you can see green or red randomly running
    the code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们启动了多个goroutine，调度器将任意选择哪个应该首先执行。因此，你可以看到绿色或红色随机运行代码。
- en: 'We can fix the issue by putting in one more `print` statement received from
    the channel:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在通道中添加一个额外的`print`语句来解决这个问题：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Although it works, it’s not the most elegant solution. We could have trouble
    with deadlocks again if we have more receivers than senders:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它有效，但这不是最优雅的解决方案。如果我们有比发送者更多的接收者，我们可能会再次遇到死锁：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The last print will await forever, causing another deadlock.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的打印将永远等待，导致另一个死锁。
- en: If we want to make code work with any number of balls, we should stop adding
    more and more lines and replace them all with the `range` keyword.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让代码能够处理任意数量的球，我们就应该停止添加越来越多的行，并用`range`关键字替换它们。
- en: Iterating over a channel
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历通道
- en: The mechanism used to iterate over the values sent through a channel is the
    `range` keyword.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历通过通道发送的值的机制是`range`关键字。
- en: 'Let’s change the code to iterate over the channel values:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改代码以遍历通道值：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We can happily check the console to see the balls received elegantly, but wait
    – all the goroutines are asleep! Deadlock again?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以愉快地检查控制台以查看优雅地接收到的球，但是等等——所有的goroutine都在睡眠中！又死锁了？
- en: This error occurs when we iterate over channels and the range expects a channel
    to be closed to stop the iteration.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遍历通道并且`range`期望通道关闭以停止迭代时，会发生这个错误。
- en: Closing a channel
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关闭通道
- en: 'To close a channel, we need to call the built-in `close` function, passing
    the channel:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭通道，我们需要调用内置的`close`函数，并传递通道：
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'OK, we can now guarantee that the channel is closed. Let’s change the code
    by adding the `close` call between the senders and `range`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们现在可以保证通道已经关闭。让我们通过在发送者和`range`之间添加`close`调用来更改代码：
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You may have noticed that if the range stops when the channel is closed, with
    this code, the range will never run once the channel has closed.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，如果`range`在通道关闭时停止，那么使用这段代码，一旦通道关闭，`range`将永远不会运行。
- en: We need to orchestrate this group of tasks, and yes, you’re right – we’re using
    `WaitGroup` to save us again. This time, we don’t want to taint the `throwBalls`
    signature to receive our `WaitGroup`, so we’ll create inline anonymous functions
    to keep our functions unaware of the concurrency. Additionally, we want to close
    the channel when we have the guarantee that all the tasks are done. We infer this
    with the `Wait()` method from our `WaitGroup`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要协调这一组任务，是的，你是对的——我们再次使用`WaitGroup`来帮助我们。这次，我们不想污染`throwBalls`签名以接收我们的`WaitGroup`，所以我们将创建内联匿名函数以使我们的函数不知道并发。此外，当我们有保证所有任务都完成时，我们想要关闭通道。我们通过`WaitGroup`的`Wait()`方法来推断这一点。
- en: 'Here is our `main` function:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的`main`函数：
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Phew! This time, the output is correctly shown:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 呼吁！这次，输出显示正确：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: What a ride, huh? But wait! We still need to explore the buffered channels!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这是一段旅程，对吧？但是等等！我们仍然需要探索缓冲通道！
- en: Buffered channels
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓冲通道
- en: It’s analogy time!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候进行类比了！
- en: These are the channels where clowns come into play! Imagine a clown car with
    a limited number of seats (capacity). Clowns (senders) can hop in and out of the
    car, dropping juggling balls (data) into it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是小丑发挥作用的地方！想象一辆座位有限（容量）的小丑车。小丑（发送者）可以跳进跳出汽车，把杂技球（数据）扔进去。
- en: We want to create a program with buffered channels that simulate a circus car
    ride, where clowns try to get into a clown car (limited to three clowns at a time)
    with balloons. The driver controls the car and manages the clowns’ rides while
    the clowns attempt to get in. If the car is full, they wait and print a message.
    After all the clowns are done, the program waits for the car driver to finish
    and then prints that the circus car ride is over.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要创建一个带有缓冲通道的程序，模拟马戏团车之旅，其中小丑们试图进入一辆小丑车（一次最多三个小丑）并带着气球。司机控制汽车并管理小丑的乘坐，而小丑们试图进入。如果车满了，他们就会等待并打印一条消息。所有小丑都完成后，程序等待车司机完成，然后打印马戏团车之旅结束的消息。
- en: If a clown tries to stuff too many juggling balls into the car, it’s as hilarious
    as a car overflowing with clowns and juggling balls, creating a comical spectacle!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个小丑试图把太多的杂技球塞进车里，就像一辆装满了小丑和杂技球的汽车一样好笑，创造了一个滑稽的景象！
- en: 'First, let’s create the program structure to receive our senders and receivers:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建程序结构以接收我们的发送者和接收者：
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here is the driver’s goroutine (receiver):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是司机的goroutine（接收者）：
- en: '[PRE41]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We add the clown logic (sender) just below the rider’s block:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在骑手块下方添加小丑逻辑（发送者）：
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Running the code, we can see all the trouble that the clowns are making:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码后，我们可以看到小丑们制造的所有麻烦：
- en: '[PRE43]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: select
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: select
- en: The `select` statement allows us to wait on multiple communication channels
    and select the first one that becomes ready, effectively allowing us to perform
    non-blocking operations on channels.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`select`语句允许我们在多个通信通道上等待，并选择第一个就绪的通道，从而有效地允许我们在通道上执行非阻塞操作。'
- en: When working with channels, it’s easy to get caught up in comparing message
    queues and channels, but there may be better ways to understand them. The channel
    internals are ring buffers, and this information can be confusing and unhelpful
    when choosing the program design. By prioritizing an understanding of signaling
    and the guaranteed delivery of messages, you’d be better equipped to work efficiently
    with channels.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用通道工作时，很容易陷入比较消息队列和通道的困境，但可能存在更好的理解方式。通道内部是环形缓冲区，当选择程序设计时，这些信息可能会令人困惑且无助于解决问题。通过优先理解信号和消息的保证交付，你将更好地配备高效地与通道一起工作。
- en: The guarantee of delivery
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交付的保证
- en: The main difference between buffered and unbuffered channels is the guarantee
    of delivery.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲通道和无缓冲通道之间的主要区别是交付的保证。
- en: As we saw earlier, the unbuffered channels always guarantee delivery, since
    they only send a message when the receiver is ready. Conversely, the buffered
    channels can’t ensure message delivery because they can “buffer” an arbitrary
    number of messages before the synchronization step becomes mandatory. Therefore,
    the reader could fail to read a message from the channel buffer.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，无缓冲通道始终保证交付，因为它们只有在接收者准备好时才发送消息。相反，缓冲通道不能保证消息交付，因为它们可以在同步步骤成为强制性的之前“缓冲”任意数量的消息。因此，读者可能无法从通道缓冲区中读取消息。
- en: The most considerable side effect of choosing between them is how much latency
    you can afford to introduce to your program.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 选择它们之间最显著的副作用是你可以为程序引入多少延迟。
- en: Latency
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延迟
- en: Latency in the context of concurrent programming refers to the time it takes
    for a piece of data to travel from a sender (goroutine) to a receiver (goroutine)
    through a channel.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发编程的上下文中，延迟指的是数据从发送者（goroutine）通过通道到达接收者（goroutine）所需的时间。
- en: 'In Go channels, latency is influenced by several factors:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 通道中，延迟受多个因素的影响：
- en: '**Buffering**: Buffering can reduce latency when the sender and receiver are
    not perfectly synchronized.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓冲**: 缓冲可以减少发送者和接收者不完全同步时的延迟。'
- en: '**Blocking**: Unbuffered channels block the sender and receiver until they
    are ready to communicate, leading to potentially higher latency. Buffered channels
    allow the sender to continue without immediate synchronization, potentially reducing
    latency.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阻塞**: 无缓冲通道会阻塞发送者和接收者，直到他们准备好进行通信，这可能导致更高的延迟。缓冲通道允许发送者继续进行，而无需立即同步，这可能会降低延迟。'
- en: '**Goroutine scheduling**: The latency in channel communication also depends
    on how the Go runtime schedules goroutines. Factors such as the number of available
    CPU cores and the scheduling algorithm influence how quickly goroutines can be
    executed.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Goroutine调度**：通道通信中的延迟也取决于Go运行时如何调度goroutine。例如，可用的CPU核心数量和调度算法等因素会影响goroutine的执行速度。'
- en: Choosing a channel type
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择通道类型
- en: 'As a rule of thumb, we consider an unbuffered channel a strong choice for the
    following scenarios:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项经验法则，我们认为无缓冲的通道在以下场景下是一个不错的选择：
- en: '**Guaranteed delivery**: Provide a guarantee that the value being sent is received
    by another goroutine. This is especially useful in scenarios where you need to
    ensure data integrity and that no data is lost.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保证交付**：提供一种保证，即发送的值被另一个goroutine接收。这在需要确保数据完整性和无数据丢失的场景中特别有用。'
- en: '**One-to-one communication**: Unbuffered channels are best suited for one-to-one
    communication between goroutines.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对一通信**：无缓冲通道最适合goroutine之间的一对一通信。'
- en: '**Load balancing**: Unbuffered channels can be used to implement load-balancing
    patterns, ensuring that work is distributed evenly among worker goroutines.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡**：无缓冲通道可用于实现负载均衡模式，确保工作在worker goroutine之间均匀分布。'
- en: 'Conversely, buffered channels offer the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，缓冲通道提供以下功能：
- en: '**Asynchronous communication**: Buffered channels allow for asynchronous communication
    between goroutines. When sending data on a buffered channel, the sender won’t
    block until the data is received, if there is space in the channel’s buffer. This
    can improve throughput in certain scenarios.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步通信**：缓冲通道允许goroutine之间进行异步通信。在缓冲通道上发送数据时，如果通道的缓冲区有空间，发送者不会阻塞直到数据被接收。这可以在某些场景中提高吞吐量。'
- en: '**Reducing contention**: In scenarios where you have multiple senders and receivers,
    using a buffered channel can reduce contention. For example, in a producer-consumer
    pattern, you can use a buffered channel to allow producers to keep producing without
    waiting for consumers to catch up.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少竞争**：在存在多个发送者和接收者的场景中，使用缓冲通道可以减少竞争。例如，在生产者-消费者模式中，可以使用缓冲通道允许生产者继续生产，而无需等待消费者赶上。'
- en: '**Preventing deadlocks**: Buffered channels can help prevent goroutine deadlocks
    by allowing a certain level of buffering, which can be useful when you have unpredictable
    variations in a workload.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**防止死锁**：缓冲通道可以通过允许一定程度的缓冲来帮助防止goroutine死锁，这在工作负载不可预测变化时可能很有用。'
- en: '**Batch processing**: Buffered channels can be used for batch processing or
    pipelining where data is produced at one rate and consumed at another rate.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**批量处理**：缓冲通道可用于批量处理或管道，其中数据以一个速率产生，以另一个速率消费。'
- en: Now that we’ve covered the key aspects of latency and how it impacts channel
    communication in concurrent programming, let’s shift our focus to another critical
    aspect – state and signaling. Understanding the semantics of state and signaling
    is essential to avoid common pitfalls and make informed design decisions.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了延迟的关键方面以及它如何影响并发编程中的通道通信，让我们将重点转移到另一个关键方面——状态和信号。理解状态和信号的语义对于避免常见陷阱和做出明智的设计决策至关重要。
- en: State and signaling
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态和信号
- en: Exploring the semantics of state and signaling puts you ahead of the curve in
    avoiding more straightforward bugs or making good design choices.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 探索状态和信号的语义可以使你在避免更直接的错误或做出良好的设计选择方面领先一步。
- en: State
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态
- en: Although Go eased the adoption of concurrency with channels, there are some
    characteristics and pitfalls.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Go通过通道简化了并发的采用，但也有一些特性和陷阱。
- en: We should remember that channels have three states – nil, open (empty, not empty),
    and closed. These states strongly relate to what we can and cannot do with channels,
    whether from the sender’s or receiver’s perspective.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该记住，通道有三个状态——nil、open（空、非空）和closed。这些状态与我们能否以及如何使用通道，无论是从发送者还是接收者的角度来看，都有很强的关联。
- en: 'Consider a channel when you want to read from:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想从通道中读取时考虑：
- en: Reading to a `write-only` channel results in a compilation error
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向一个`只写`通道读取会导致编译错误
- en: If the channel is `nil`, reading from it indefinitely blocks your goroutine
    until it is initialized
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果通道是`nil`，则无限期地从它读取将阻塞你的goroutine，直到它被初始化
- en: Reading will be blocked in an `open` and `empty` channel until data is available
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个`开放`且`空`的通道中读取将阻塞，直到有数据可用
- en: In an `open` and `not empty` channel, reading will return data
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个`开放`且`非空`的通道中，读取将返回数据
- en: If the channel is `closed`, reading it will return the default value for its
    type and `false` to indicate closure
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果通道是`关闭`的，读取它将返回其类型的默认值，并返回`false`以指示关闭
- en: 'Writing also has its nuances:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 写入也有其细微之处：
- en: Writing to a `read-only` channel results in a compilation error
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向只读通道写入会导致编译错误
- en: Writing to a `nil` channel block until it’s initialized
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向`nil`通道写入会阻塞，直到它被初始化
- en: Writing to an `open` and `full` channel blocks until there’s space
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向一个`打开`且`满`的通道写入会阻塞，直到有空间
- en: In an `open` and `not full` channel, writing is successful
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个`打开`且`非满`的通道中，写入是成功的
- en: Writing on a `closed` channel leads to a panic
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向一个`关闭`的通道写入会导致`panic`
- en: 'Closing a channel depends on its state:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭通道取决于其状态：
- en: Closing an `open channel with data` allows reads until drained, and then returns
    the default value.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭一个带有数据的`打开通道`允许读取直到耗尽，然后返回默认值。
- en: Closing an `open empty channel` immediately closes it, and reads also return
    the default value.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭一个`打开空通道`会立即关闭它，并且读取也会返回默认值。
- en: Attempting to close an `already closed channel` results in a `panic`.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试关闭一个`已关闭的通道`会导致`panic`。
- en: Closing a read-only channel results in a compilation error.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭只读通道会导致编译错误。
- en: Signaling
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号
- en: Signaling between goroutines is an everyday use case for channels. You can use
    channels to coordinate and synchronize the execution of different goroutines by
    sending signals or messages between them.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在goroutine之间进行信号传递是频道的一个常见用例。你可以通过在它们之间发送信号或消息来使用频道协调和同步不同goroutine的执行。
- en: 'Here is a simple example of how to use a Go channel to signal between two goroutines:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个如何使用Go频道在两个goroutine之间进行信号传递的简单示例：
- en: '[PRE44]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this snippet, we create a channel called `signalChannel` to signal between
    the two goroutines. `Goroutine 1` waits for a signal on the channel using `<-signalChannel`,
    and `Goroutine 2` sends a signal using `signalChannel <-` `true`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们创建了一个名为`signalChannel`的通道，用于在两个goroutine之间进行信号传递。`Goroutine 1`使用`<-signalChannel`在通道上等待信号，而`Goroutine
    2`使用`signalChannel <- true`发送信号。
- en: The `sync.WaitGroup` ensures that we wait for both goroutines to finish before
    printing `"Both goroutines` `have finished."`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`sync.WaitGroup`确保我们在打印`"Both goroutines have finished."`之前等待两个goroutine都完成。'
- en: When you run this program, you’ll see that `Goroutine 1` waits for the signal
    from `Goroutine 2` and then proceeds with its task.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，你会看到`Goroutine 1`等待`Goroutine 2`的信号，然后继续执行其任务。
- en: Go channels are a flexible way to synchronize and coordinate complex interactions
    between goroutines. They can be used to implement concurrency patterns producer-consumer
    or fan-out/fan-in.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Go频道是同步和协调goroutine之间复杂交互的灵活方式。它们可以用来实现生产者-消费者或扇出/扇入的并发模式。
- en: Choosing your synchronization mechanism
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择你的同步机制
- en: Are channels always the answer? Definitely not! We can use mutexes or channels
    to solve the same problem. How do we choose? Prefer pragmatism. When mutexes make
    your solution easy to read and maintain, don’t think twice and go with mutexes!
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 频道总是答案吗？绝对不是！我们可以使用互斥锁或频道来解决相同的问题。我们如何选择？偏好实用主义。当互斥锁使你的解决方案易于阅读和维护时，不要犹豫，选择互斥锁！
- en: If you have trouble choosing between them, here is an opinionated guideline.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在它们之间选择有困难，这里有一个有偏见的指南。
- en: 'Use channels when you need to do the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要做以下事情时使用频道：
- en: Pass the ownership of data
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递数据的所有权
- en: Distribute units of work
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配工作单元
- en: Communicate results in an asynchronous way
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以异步方式通信结果
- en: 'Use mutexes when you’re handling the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理以下内容时，请使用互斥锁：
- en: Caches
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: Shared state
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享状态
- en: Alright, let’s wrap things up and recap what we’ve covered in this chapter.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们总结一下，回顾本章我们所学的内容。
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the functioning of goroutines, their simplicity,
    and the importance of synchronization using `WaitGroup`. We also became aware
    of the difficulties in managing shared state, using a warehouse analogy to explain
    data races. Additionally, we were introduced to Go’s race detection tool to identify
    race conditions, the significance of communication channels, and their potential
    pitfalls.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了goroutine的功能、它们的简单性和使用`WaitGroup`进行同步的重要性。我们还意识到了管理共享状态的困难，使用仓库类比来解释数据竞争。此外，我们介绍了Go的竞态检测工具来识别竞态条件，通信通道的重要性及其潜在的风险。
- en: Now that our concurrency knowledge is refreshed, let’s explore in the next chapter
    interactions with an operational system using system calls.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经更新了并发知识，让我们在下一章中探索使用系统调用的操作系统的交互。
- en: 'Part 2: Interaction with the OS'
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：与操作系统交互
- en: In this part, we will delve into system-level programming concepts using Go.
    You will explore inter-process communication (IPC) mechanisms, system event handling,
    file operations, and Unix sockets. This section provides practical examples and
    detailed explanations to equip you with the knowledge and skills to build robust
    and efficient system-level applications.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分，我们将使用Go语言深入探讨系统级编程概念。您将探索进程间通信（IPC）机制、系统事件处理、文件操作和Unix套接字。本节提供了实际示例和详细解释，以帮助您掌握构建健壮和高效系统级应用程序的知识和技能。
- en: 'This part has the following chapters:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 3*](B21662_03.xhtml#_idTextAnchor089), *Understanding System Calls*'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第3章*](B21662_03.xhtml#_idTextAnchor089), *理解系统调用*'
- en: '[*Chapter 4*](B21662_04.xhtml#_idTextAnchor110), *File and Directories operations*'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第4章*](B21662_04.xhtml#_idTextAnchor110), *文件和目录操作*'
- en: '[*Chapter 5*](B21662_05.xhtml#_idTextAnchor126), *Working with System Events*'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B21662_05.xhtml#_idTextAnchor126), *处理系统事件*'
- en: '[*Chapter 6*](B21662_06.xhtml#_idTextAnchor145), *Understanding Pipes in Inter-Process
    Communication*'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B21662_06.xhtml#_idTextAnchor145), *理解进程间通信中的管道*'
- en: '[*Chapter 7*](B21662_07.xhtml#_idTextAnchor160), *Unix Sockets*'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B21662_07.xhtml#_idTextAnchor160), *Unix套接字*'
