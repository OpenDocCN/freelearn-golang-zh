<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer011">
			<h1 id="_idParaDest-53" class="chapter-number"><a id="_idTextAnchor089"/>3</h1>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor090"/>Understanding System Calls</h1>
			<p>In this chapter, you will embark on a journey into the world of system calls, those fundamental interfaces that bridge user-level programs with the operating system kernel. Through relatable analogies and real-world parallels, we’ll demystify the intricate dance of software execution, highlighting the pivotal roles of the kernel, user mode, and <span class="No-Break">kernel mode.</span></p>
			<p>Understanding system calls<a id="_idIndexMarker094"/> and their interaction with the operating system is crucial for any software developer aiming to craft efficient and robust applications. In the broader context of this book, this chapter lays the foundation for subsequent discussions on advanced OS interactions and system-level programming. Moreover, in the real-world context, mastering these concepts equips developers with the tools to optimize software performance, troubleshoot issues at the system level, and harness the full potential of the operating <span class="No-Break">system’s capabilities.</span></p>
			<p>In this chapter, we are going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Introduction to <span class="No-Break">system calls</span></li>
				<li>The <span class="No-Break"><strong class="source-inline">syscall</strong></span><span class="No-Break"> package</span></li>
				<li>A closer look at the <strong class="source-inline">os</strong> and <span class="No-Break"><strong class="source-inline">x/sys</strong></span><span class="No-Break"> packages</span></li>
				<li>Everyday <span class="No-Break">system calls</span></li>
				<li>Developing and testing a <strong class="bold">command-line interface</strong> (<span class="No-Break"><strong class="bold">CLI</strong></span><span class="No-Break">) program</span></li>
			</ul>
			<p>By the end of this chapter, you will not only have grasped the theoretical underpinnings of system calls but also gained hands-on experience by constructing a CLI application <span class="No-Break">using Go.</span></p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor091"/>Technical requirements</h1>
			<p>You can find this chapter’s source code <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/System-Programming-Essentials-with-Go/tree/main/ch3"><span class="No-Break">https://github.com/PacktPublishing/System-Programming-Essentials-with-Go/tree/main/ch3</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor092"/>Introduction to system calls</h1>
			<p>System calls, often called “syscalls,” are fundamental to an operating system’s interface. They are <a id="_idIndexMarker095"/>low-level functions provided by the operating system kernel that allow user-level processes to request services from <span class="No-Break">the kernel.</span></p>
			<p>If you are new to the concept, some analogies could make understanding more effortless. Let’s correlate the idea <span class="No-Break">with traveling.</span></p>
			<p class="callout-heading">User mode versus kernel mode</p>
			<p class="callout">A <a id="_idIndexMarker096"/>processor (or CPU) has two modes of operation: user mode and kernel mode (also known as supervisor mode or privileged mode). These modes dictate the<a id="_idIndexMarker097"/> level of access and control that a program has over system resources. User mode is restricted and doesn’t allow direct access to certain critical system resources, while kernel mode has more privileges and can access these resources. Permission granted, proceed <span class="No-Break">with caution</span></p>
			<p>When it comes to system calls, the kernel plays the role of a strict border control officer. System calls are like the passports we need to navigate the diverse landscapes of software execution. Think of the kernel as a heavily fortified international border checkpoint. Just as travelers need permission to enter a foreign land, our processes require approval to access the kernel’s resources. System calls serve as passports, allowing us to cross the border between user and <span class="No-Break">kernel spaces.</span></p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor093"/>The catalog of services and identification</h2>
			<p>Much<a id="_idIndexMarker098"/> like a traveler’s guidebook, the kernel offers a comprehensive catalog of services<a id="_idIndexMarker099"/> through the system call <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>). These services range from creating new processes to handling <strong class="bold">input and output</strong> (<strong class="bold">I/O</strong>) operations such<a id="_idIndexMarker100"/> as amenities and attractions in a <span class="No-Break">foreign country.</span></p>
			<p>A numerical code<a id="_idIndexMarker101"/> uniquely identifies each system call, like your passport number. However, this numbering system remains hidden from everyday use. Instead, we interact with system calls by their names, much like travelers identifying services and landmarks by their local names rather than their codes. For instance, an <strong class="source-inline">open</strong> system call might be identified by the number 5 in the kernel’s internal system call table. However, as programmers, we refer to this system call by its name, “<strong class="source-inline">open</strong>,” much like travelers identify places by their local names rather than their <span class="No-Break">GPS coordinates.</span></p>
			<p>The location of the system call table depends on the OS and the architecture, but if you are curious about these identifiers, you can visit a handcrafted table at the <span class="No-Break">following link:</span></p>
			<p><a href="https://filippo.io/linux-syscall-table/"><span class="No-Break">https://filippo.io/linux-syscall-table/</span></a></p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor094"/>Information exchange</h2>
			<p>System calls<a id="_idIndexMarker102"/> are not one-way transactions; they involve a careful exchange of information. Each system call comes with arguments that dictate what data needs to travel between user space (your process’s domain) and kernel space (the kernel’s realm). Picture it as a well-coordinated cross-border conversation, where information passes seamlessly between the <span class="No-Break">two sides.</span></p>
			<p>When you use the <strong class="source-inline">write()</strong> system call to save data to a file, you pass not only the data but also information about where to write it (for example, a file descriptor and a data buffer). This data exchange is like a conversation across borders, with data moving seamlessly between the user and <span class="No-Break">kernel spaces.</span></p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor095"/>The syscall package</h1>
			<p>We observe a <a id="_idIndexMarker103"/>consistent trend: the vast majority of functionalities we require are readily accessible within the standard library, a testament to its comprehensiveness and utility. However, there is a notable exception in this pattern – the <span class="No-Break"><strong class="source-inline">syscall</strong></span><span class="No-Break"> package.</span></p>
			<p>The package has been a foundation for interfacing with system calls and constants across various architectures and operating systems. However, over time, several issues have emerged that<a id="_idIndexMarker104"/> led to <span class="No-Break">its deprecation:</span></p>
			<ul>
				<li><strong class="bold">Bloat</strong>: Who doesn’t love a package that grows without bounds? With definitions for just about every system call and constant you could (or couldn’t) think of, <strong class="source-inline">syscall</strong> was like that overstuffed closet you promise to clean <span class="No-Break">out... someday.</span></li>
				<li><strong class="bold">Testing limitations</strong>: A significant portion of the package lacks explicit tests. Moreover, cross-platform testing is unfeasible due to the <span class="No-Break">package’s design.</span></li>
				<li><strong class="bold">Curation challenges</strong>: The package was reminiscent of the Wild West when it came to changing lists – a free-for-all where almost any change was welcomed with open arms. It wasn’t just the party everyone wanted an invite to; it was also the hub for supporting a vast array of packages and systems. However, this popularity came at a cost. Determining the value of these myriad changes grew challenging, and the outcome? The <strong class="source-inline">syscall</strong> package set a record by becoming one of the least maintained, tested, and documented packages in the <span class="No-Break">standard repository.</span></li>
				<li><strong class="bold">Documentation</strong>: The <strong class="source-inline">syscall</strong> package, with its unique variations for each system, is like a mystery wrapped in an enigma for developers. While one would hope for clarity, the <strong class="source-inline">godoc</strong> tool only offers a sneak peek, very similar to a movie trailer showcasing just the highlights. This selective display, tailored to its native environment, combined with an overarching lack of documentation, turns understanding and effectively using the package into a <span class="No-Break">challenging endeavor.</span></li>
				<li><strong class="bold">Compatibility? A moving target</strong>: Despite earnest efforts to uphold the Go 1 compatibility guarantee, the <strong class="source-inline">syscall</strong> package often feels like it’s in a relentless chase, something like pursuing a unicorn. Operating systems, with their constant evolution, present a challenge that’s beyond the Go team’s control. For instance, shifts in FreeBSD have impacted the <span class="No-Break">package’s compatibility.</span></li>
			</ul>
			<p>To address these concerns, the Go team proposed <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Freezing the syscall package</strong>: Starting from Go 1.3, the <strong class="source-inline">syscall</strong> package would be <a id="_idIndexMarker105"/>frozen, meaning no further changes would be made to it. This includes not updating it even if there are changes in the operating systems <span class="No-Break">it references.</span></li>
				<li><strong class="bold">Introduction of x/sys</strong>: A new package, <strong class="source-inline">x/sys</strong> (<a href="https://pkg.go.dev/golang.org/x/sys">https://pkg.go.dev/golang.org/x/sys</a>), was created to replace the <strong class="source-inline">syscall</strong> package. This new package is easier to maintain, document, and use for <span class="No-Break">cross-platform development.</span></li>
				<li>Deprecation: While the <strong class="source-inline">syscall</strong> package would continue to exist and function, all new public development was shifted to <strong class="source-inline">x/sys</strong>. The documentation for the <strong class="source-inline">syscall</strong> package would guide users toward this <span class="No-Break">new repository.</span></li>
			</ul>
			<p>In essence, while the <strong class="source-inline">syscall</strong> package served its purpose for a time, the challenges it posed in terms of maintenance, documentation, and compatibility necessitated its deprecation in favor of a more structured and maintainable approach <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">x/sys</strong></span><span class="No-Break">.</span></p>
			<p>For more information on the decision, there is a post by Rob Pike explaining the <span class="No-Break">decision (</span><a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/freeze-syscall.md"><span class="No-Break">https://go.googlesource.com/proposal/+/refs/heads/master/design/freeze-syscall.md</span></a><span class="No-Break">).</span></p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor096"/>A closer look at the os and x/sys packages</h1>
			<p>As we can see in the <a id="_idIndexMarker106"/>Go documentation regarding the <span class="No-Break"><strong class="source-inline">x/sys</strong></span><span class="No-Break"> package:</span></p>
			<p>“<em class="italic">The primary use of x/sys is inside other packages that provide a more portable interface to the system, such as “os”, “time” </em><span class="No-Break"><em class="italic">and “net”.</em></span></p>
			<p><em class="italic">Use those packages rather than this one if you can. For details of the functions and data types in this package consult the manuals for the appropriate operating system. These calls return err == nil to indicate success; otherwise err is an operating system error describing the failure. On most systems, that error has </em><span class="No-Break"><em class="italic">type syscall.Errno.</em></span><span class="No-Break">”</span></p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor097"/>x/sys package – low-level system calls</h2>
			<p>The <strong class="source-inline">x/sys</strong> package in <a id="_idIndexMarker107"/>Go provides access to low-level system calls. It’s typically used when interacting directly with the operating system is necessary or for platform-specific operations. It’s important to exercise caution when using <strong class="source-inline">x/sys</strong>, as incorrect usage can lead to system instability or <span class="No-Break">security issues.</span></p>
			<p>To use this package, you should download it using the <span class="No-Break">Go tools:</span></p>
			<pre class="source-code">
<strong class="source-inline">go get -u golang.org/x/sys</strong></pre>			<p>Let’s explore what this package <span class="No-Break">could offer.</span></p>
			<h3>System calls</h3>
			<p>Here are some<a id="_idIndexMarker108"/> system call invocations <span class="No-Break">and constants:</span></p>
			<ul>
				<li><strong class="source-inline">unix.Syscall()</strong>: Call a specific system call <span class="No-Break">with arguments</span></li>
				<li><strong class="source-inline">unix.Syscall6()</strong>: Similar to <strong class="source-inline">Syscall()</strong> but for system calls with <span class="No-Break">six arguments</span></li>
				<li><strong class="source-inline">unix.SYS_*</strong>: Constants representing various system calls (for example, <span class="No-Break"><strong class="source-inline">unix.SYS_READ</strong></span><span class="No-Break">, </span><span class="No-Break"><strong class="source-inline">unix.SYS_WRITE</strong></span><span class="No-Break">)</span></li>
			</ul>
			<p>For example, the next two snippets result in the same outcome, printing <strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">Hello World!"</strong></span><span class="No-Break">.</span></p>
			<p>Using the <strong class="source-inline">fmt</strong> package, you get the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
fmt.Println("Hello World!")</pre>			<p>And by using the <strong class="source-inline">x/sys</strong> package, you get <span class="No-Break">the following:</span></p>
			<pre class="source-code">
unix.Syscall(unix.SYS_WRITE, 1,
  uintptr(unsafe.Pointer(&amp;[]byte("Hello, World!")[0])),
  uintptr(len("Hello, World!")),
 )</pre>			<p>Things can get complex very easily if we decide to use a low-level abstraction instead of the <span class="No-Break"><strong class="source-inline">fmt</strong></span><span class="No-Break"> package.</span></p>
			<p>We can continue exploring the package API <span class="No-Break">by category.</span></p>
			<h3>File operations</h3>
			<p>These functions<a id="_idIndexMarker109"/> let us interact with <span class="No-Break">general files:</span></p>
			<ul>
				<li><strong class="source-inline">unix.Create()</strong>: Create a <span class="No-Break">new file</span></li>
				<li><strong class="source-inline">unix.Unlink()</strong>: Remove <span class="No-Break">a file</span></li>
				<li><strong class="source-inline">unix.Mkdir()</strong>, <strong class="source-inline">unix.Rmdir()</strong>, and <strong class="source-inline">unix.Link()</strong>: Create and remove directories <span class="No-Break">and links</span></li>
				<li><strong class="source-inline">unix.Getdents()</strong>: Get <span class="No-Break">directory entries</span></li>
			</ul>
			<h3>Signals</h3>
			<p>Here are two examples of functions<a id="_idIndexMarker110"/> that interact with <span class="No-Break">OS signals:</span></p>
			<ul>
				<li><strong class="source-inline">unix.Kill()</strong>: Send a kill signal to <span class="No-Break">a process</span></li>
				<li><strong class="source-inline">unix.SIGINT</strong>: Interrupt signal (commonly known as <em class="italic">Ctrl</em> + <span class="No-Break"><em class="italic">C</em></span><span class="No-Break">)</span></li>
			</ul>
			<h3>User and group management</h3>
			<p>We can <a id="_idIndexMarker111"/>manage users and groups using the <span class="No-Break">following calls:</span></p>
			<ul>
				<li><strong class="source-inline">syscall.Setuid()</strong>, <strong class="source-inline">syscall.Setgid()</strong>, <strong class="source-inline">syscall.Setgroups()</strong>: Set user and <span class="No-Break">group IDs</span></li>
			</ul>
			<h3>System information</h3>
			<p>We can analyze<a id="_idIndexMarker112"/> some statistics on memory and swap usage and the load average using the <span class="No-Break"><strong class="source-inline">Sysinfo()</strong></span><span class="No-Break"> function:</span></p>
			<ul>
				<li><strong class="source-inline">syscall.Sysinfo()</strong>: Get <span class="No-Break">system information</span></li>
			</ul>
			<h3>File descriptors</h3>
			<p>While<a id="_idIndexMarker113"/> it’s not an everyday task, we can also interact with file <span class="No-Break">descriptors directly:</span></p>
			<ul>
				<li><strong class="source-inline">unix.FcntlInt()</strong>: Perform various operations on <span class="No-Break">file descriptors</span></li>
				<li><strong class="source-inline">unix.Dup2()</strong>: Duplicate a <span class="No-Break">file descriptor</span></li>
			</ul>
			<h3>Memory-mapped files</h3>
			<p>Mmap is <a id="_idIndexMarker114"/>an acronym for memory-mapped files. It provides a mechanism for reading and writing files without relying on system calls. When using <strong class="source-inline">Mmap()</strong>, the operating system allocates a section of a program’s virtual address space, which is directly “mapped” to a corresponding file section. If the program accesses data from that part of the address space, it will retrieve the data stored in the related part of <span class="No-Break">the file:</span></p>
			<ul>
				<li><strong class="source-inline">syscall.Mmap()</strong>: Map files or devices <span class="No-Break">into memory</span></li>
			</ul>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor098"/>Operating system functionality</h2>
			<p>The <strong class="source-inline">os</strong> package in <a id="_idIndexMarker115"/>Go provides a rich set of functions for interacting with the operating system. It’s divided into several subpackages, each focusing on a specific aspect of <span class="No-Break">OS functionality.</span></p>
			<p>The following are <a id="_idIndexMarker116"/>file and <span class="No-Break">directory operations:</span></p>
			<ul>
				<li><strong class="source-inline">os.Create()</strong>: Creates or opens a file <span class="No-Break">for writing</span></li>
				<li><strong class="source-inline">os.Mkdir()</strong> and <strong class="source-inline">os.MkdirAll()</strong>: <span class="No-Break">Create directories</span></li>
				<li><strong class="source-inline">os.Remove()</strong> and <strong class="source-inline">os.RemoveAll()</strong>: Remove files <span class="No-Break">and directories</span></li>
				<li><strong class="source-inline">os.Stat()</strong>: Get file or directory <span class="No-Break">information (metadata)</span></li>
				<li><strong class="source-inline">os.IsExist()</strong>, <strong class="source-inline">os.IsNotExist()</strong>, and <strong class="source-inline">os.IsPermission()</strong>: Check file/directory existence or <span class="No-Break">permission errors</span></li>
				<li><strong class="source-inline">os.Open()</strong>: Open a file <span class="No-Break">for reading</span></li>
				<li><strong class="source-inline">os.Rename()</strong>: Rename or move <span class="No-Break">a file</span></li>
				<li><strong class="source-inline">os.Truncate()</strong>: Resize <span class="No-Break">a file</span></li>
				<li><strong class="source-inline">os.Getwd()</strong>: Get the current <span class="No-Break">working directory</span></li>
				<li><strong class="source-inline">os.Chdir()</strong>: Change the current <span class="No-Break">working directory</span></li>
				<li><strong class="source-inline">os.Args</strong>: <span class="No-Break">Command-line arguments</span></li>
				<li><strong class="source-inline">os.Getenv()</strong>: Get <span class="No-Break">environment variables</span></li>
				<li><strong class="source-inline">os.Setenv()</strong>: Set <span class="No-Break">environment variables</span></li>
			</ul>
			<p>The following <a id="_idIndexMarker117"/>are for processes <span class="No-Break">and signals:</span></p>
			<ul>
				<li><strong class="source-inline">os.Getpid()</strong>: Get the current <span class="No-Break">process ID</span></li>
				<li><strong class="source-inline">os.Getppid()</strong>: Get the parent <span class="No-Break">process ID</span></li>
				<li><strong class="source-inline">os.Getuid()</strong> and <strong class="source-inline">os.Getgid()</strong>: Get the user and <span class="No-Break">group IDs</span></li>
				<li><strong class="source-inline">os.Geteuid()</strong> and <strong class="source-inline">os.Getegid()</strong>: Get the effective user and <span class="No-Break">group IDs</span></li>
				<li><strong class="source-inline">os.StartProcess()</strong>: Start a <span class="No-Break">new process</span></li>
				<li><strong class="source-inline">os.Exit()</strong>: Exit the <span class="No-Break">current process</span></li>
				<li><strong class="source-inline">os.Signal</strong>: Represents signals (for example, <span class="No-Break"><strong class="source-inline">SIGINT</strong></span><span class="No-Break">, </span><span class="No-Break"><strong class="source-inline">SIGTERM</strong></span><span class="No-Break">)</span></li>
				<li><strong class="source-inline">os/signal.Notify()</strong>: Notify on <span class="No-Break">signal reception</span></li>
			</ul>
			<p>The <strong class="source-inline">os</strong> package allows you to create and manipulate processes. You can start new processes, obtain information about the current process, and manipulate <span class="No-Break">its properties:</span></p>
			<pre class="source-code">
package main
import (
     "fmt"
     "os"
     "os/exec"
)
func main() {
     // Start a new process
     cmd := exec.Command("ls", "-l")
     cmd.Stdout = os.Stdout
     cmd.Stderr = os.Stderr
     err := cmd.Run()
     if err != nil {
          fmt.Println(err)
          return
     }
     // Get the current process ID
     pid := os.Getpid()
     fmt.Println("Current process ID:", pid)
}</pre>			<p>The main parts of <a id="_idIndexMarker118"/>this program are <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">exec.Command("ls", "-l")</strong>: This creates a new command to run the <strong class="source-inline">ls</strong> command with the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">l</strong></span><span class="No-Break"> flag.</span></li>
				<li><strong class="source-inline">cmd.Stdout = os.Stdout</strong>: This redirects the standard output of the <strong class="source-inline">ls</strong> command to the standard output of the <span class="No-Break">main program.</span></li>
				<li><strong class="source-inline">cmd.Stderr = os.Stderr</strong>: Similarly, this redirects the standard error of the <strong class="source-inline">ls</strong> command to the standard error of the <span class="No-Break">main program.</span></li>
				<li><strong class="source-inline">err := cmd.Run()</strong>: This runs the <strong class="source-inline">ls</strong> command. If there’s an error during its execution, it will be stored in the <span class="No-Break"><strong class="source-inline">err</strong></span><span class="No-Break"> variable.</span></li>
				<li><strong class="source-inline">os.Getpid()</strong>: This retrieves the process ID of the <span class="No-Break">current process.</span></li>
			</ul>
			<p>While the <strong class="source-inline">os</strong> package provides <a id="_idIndexMarker119"/>a high-level interface for many system-related tasks, the <strong class="source-inline">syscall</strong>(and <strong class="source-inline">x/sys</strong>) package allows you to make lower-level system calls directly. This can be useful when you need fine-grained control over <span class="No-Break">system resources.</span></p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor099"/>Portability</h2>
			<p>While <strong class="source-inline">x/sys</strong> is<a id="_idIndexMarker120"/> the go-to package to make syscalls, you must explicitly choose between Unix and Windows. The recommended way to interact with the operating system is to use the <strong class="source-inline">os</strong> package. When you build your program to a determined OS and architecture, the compiler will do the heavy lifting to use the adequate <span class="No-Break">syscall version.</span></p>
			<p>For example, while in Windows, you need to call a function with the <span class="No-Break">following signature:</span></p>
			<pre class="console">
SetEnvironmentVariable(name *uint16, value *uint16) (err error)</pre>			<p>The signature doesn’t even have the same name for Unix-based systems, as we can see in the <span class="No-Break">next snippet:</span></p>
			<pre class="console">
Setenv(key, value string) error</pre>			<p>To avoid this “signature Tetris,” we could use the function from the <strong class="source-inline">os</strong> package with the <span class="No-Break">same semantics:</span></p>
			<pre class="console">
Setenv(key, value string) error</pre>			<p>(Yes! The signature is the same as the <span class="No-Break">Unix version.)</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The primary use of <strong class="source-inline">syscall</strong> (<a href="https://pkg.go.dev/syscall">https://pkg.go.dev/syscall</a>) is inside other packages that provide a more portable interface to the system, such as <strong class="source-inline">os</strong>, <strong class="source-inline">time</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">net</strong></span><span class="No-Break">.</span></p>
			<p class="callout">From now on, we leverage the <strong class="source-inline">os</strong> package, and only in exceptional cases will we directly call the <span class="No-Break"><strong class="source-inline">x/sys</strong></span><span class="No-Break"> package.</span></p>
			<h3>Best practices</h3>
			<p>As a system<a id="_idIndexMarker121"/> programmer using the <strong class="source-inline">os</strong> and <strong class="source-inline">x/sys</strong> packages in Go, consider<a id="_idIndexMarker122"/> the following <span class="No-Break">best practices:</span></p>
			<ul>
				<li>Use the <strong class="source-inline">os</strong> package for most tasks, as it provides a safer and more <span class="No-Break">portable interface</span></li>
				<li>Reserve the <strong class="source-inline">x/sys</strong> package for situations where fine-grained control over system calls <span class="No-Break">is necessary</span></li>
				<li>Pay attention to platform-specific constants and types when using the <strong class="source-inline">x/sys</strong> package to ensure <span class="No-Break">cross-platform compatibility</span></li>
				<li>Handle errors returned by system calls and <strong class="source-inline">os</strong> package functions diligently to maintain the reliability of <span class="No-Break">your applications</span></li>
				<li>Test your system-level code on different operating systems to verify its behavior in <span class="No-Break">diverse environments</span></li>
			</ul>
			<p>Let’s explore how we can trace what is happening in the commands we do in the terminal on a <span class="No-Break">daily basis.</span></p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor100"/>Everyday system calls</h1>
			<p>Several syscalls are happening in our programs every time under our noses. We can trace these calls using the <span class="No-Break"><strong class="source-inline">strace</strong></span><span class="No-Break"> tool.</span></p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor101"/>Tracing system calls</h2>
			<p>The <strong class="source-inline">strace</strong> tool might<a id="_idIndexMarker123"/> not come pre-installed on<a id="_idIndexMarker124"/> all Linux distributions, but it’s available in most official repositories. Here’s how to install it on some <span class="No-Break">major distributions.</span></p>
			<p>Debian (using APT): Run the <span class="No-Break">following command:</span></p>
			<pre class="console">
apt-get install strace -y</pre>			<p><strong class="bold">Red Hat family (using DNF </strong><span class="No-Break"><strong class="bold">and YUM)</strong></span></p>
			<ul>
				<li>When using <strong class="source-inline">yum</strong>, run the <span class="No-Break">following command:</span><pre class="source-code">
yum install strace</pre></li>				<li>When using <strong class="source-inline">dnf</strong>, run <span class="No-Break">this command:</span><pre class="source-code">
dnf install strace</pre></li>			</ul>
			<p><strong class="bold">Arch Linux (using Pacman)</strong>: Run the <span class="No-Break">following command:</span></p>
			<pre class="console">
pacman -S strace</pre>			<h3>Basic strace usage</h3>
			<p>The basic way <a id="_idIndexMarker125"/>to use <strong class="source-inline">strace</strong> is by calling the <strong class="source-inline">strace</strong> utility followed by the program’s name; <span class="No-Break">for example:</span></p>
			<pre class="console">
strace ls</pre>			<p>This will produce <a id="_idIndexMarker126"/>an output showing system calls, their arguments, and return values. For instance, the <strong class="source-inline">execve</strong> system call (<a href="https://man7.org/linux/man-pages/man2/execve.2.html">https://man7.org/linux/man-pages/man2/execve.2.html</a>) might look <span class="No-Break">like this:</span></p>
			<pre class="console">
execve("/usr/bin/ls", ["ls"], 0x7ffdee76b2a0 /* 71 vars */) = 0</pre>			<h2 id="_idParaDest-66"><a id="_idTextAnchor102"/>Tracing specific system calls</h2>
			<p>If you only<a id="_idIndexMarker127"/> want to trace specific system calls, use the <strong class="source-inline">-e</strong> flag followed by the system call’s name. For example, to trace <strong class="source-inline">execve</strong> system calls for the <strong class="source-inline">ls</strong> command, run <span class="No-Break">the following:</span></p>
			<pre class="console">
strace -e execve ls</pre>			<p>Now, we can use our brand-new tool from our toolset to trace syscalls in our programs. Consider the following simple <span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
package main
import "unix"
func main() {
     unix.Write(1, []byte{"Hello, World!"})
}</pre>			<p>This<a id="_idIndexMarker128"/> program needs to interact with a hardware device by writing data to the standard output, our console. To gain access to the console and perform this operation, the program requires permission from the kernel. This permission is obtained through a system call, like requesting access to a specific functionality, such as sending messages to the console, which allows your program to utilize the <span class="No-Break">console’s resources.</span></p>
			<p>The <strong class="source-inline">unix.Write</strong> function<a id="_idIndexMarker129"/> is being called with <span class="No-Break">two arguments:</span></p>
			<ul>
				<li>The first argument is <strong class="source-inline">1</strong>, which is the file descriptor for standard output (<strong class="source-inline">stdout</strong>) in Unix-like systems. This means the program will write data to the console or terminal where the program <span class="No-Break">is run.</span></li>
				<li>The second argument is <strong class="source-inline">[]byte{"Hello, World!"}</strong>, which is a byte slice containing the <strong class="source-inline">"Hello, </strong><span class="No-Break"><strong class="source-inline">World!"</strong></span><span class="No-Break"> string.</span></li>
			</ul>
			<p>We build the program calling the binary <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">app</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
go build -o app main.go</pre>			<p>We then run with <strong class="source-inline">strace</strong> tool, filtering the <span class="No-Break"><strong class="source-inline">write</strong></span><span class="No-Break"> syscall:</span></p>
			<pre class="console">
strace -e write ./app 2&gt;&amp;1</pre>			<p>You should see the following output as <span class="No-Break">a result:</span></p>
			<pre class="console">
write(1, "Hello, World!", 13Hello, World!)           = 13</pre>			<p>Now, it’s time to explore a program that interacts with the OS. Let’s make and test our very first <span class="No-Break">CLI application.</span></p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor103"/>Developing and testing a CLI program</h1>
			<p>CLI applications<a id="_idIndexMarker130"/> are essential tools in software development, system administration, and automation. When creating CLI applications, interacting with <strong class="source-inline">stdin</strong> (standard input), <strong class="source-inline">stderr</strong> (standard error), and <strong class="source-inline">stdout</strong> (standard output) plays a crucial role in ensuring their effectiveness <span class="No-Break">and user-friendliness.</span></p>
			<p>In this section, we’ll explore why these standard streams are indispensable components of <span class="No-Break">CLI development.</span></p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor104"/>Standard streams</h2>
			<p>The<a id="_idIndexMarker131"/> concept of <strong class="source-inline">stdin</strong>, <strong class="source-inline">stderr</strong>, and <strong class="source-inline">stdout</strong> is deeply rooted in the Unix philosophy of “<em class="italic">everything is a file</em>.”(We will explore this more in <a href="B21662_04.xhtml#_idTextAnchor110"><span class="No-Break">Chapter 4</span></a>, File and Directory Operations.) These standardized streams provide a consistent way for CLI applications to communicate with users and other processes. Users have come to expect CLI tools to work in a certain way, and adhering to these conventions enhances the predictability and user-friendliness of <span class="No-Break">your application.</span></p>
			<p>One of the <a id="_idIndexMarker132"/>most powerful aspects of CLI applications is their ability to work together seamlessly through pipelines (see more in <a href="B21662_06.xhtml#_idTextAnchor145"><span class="No-Break">Chapter 6</span></a>, Pipes). In Unix-like systems, you can chain multiple CLI tools together, with each tool processing data from the previous one’s <strong class="source-inline">stdout</strong>. This model allows for the efficient processing of data and complex task automation. When your application interacts with <strong class="source-inline">stdout</strong>, it becomes a valuable building block in these pipelines, enabling users to create sophisticated <span class="No-Break">workflows effortlessly.</span></p>
			<h3>Input flexibility</h3>
			<p>By utilizing <strong class="source-inline">stdin</strong>, your CLI application can accept input from various sources. Users can <a id="_idIndexMarker133"/>provide input interactively via the keyboard, or they can pipe data from other processes directly into your tool. Additionally, your application can read input from files, allowing users to process data stored in various formats and locations. This flexibility makes your application adaptable to a wide range of <span class="No-Break">usage scenarios.</span></p>
			<h3>Output flexibility</h3>
			<p>Similarly, by using <strong class="source-inline">stdout</strong>, your CLI application can provide output in a format that can be easily<a id="_idIndexMarker134"/> redirected, saved to files, or used as input for other processes. This adaptability ensures that users can leverage your tool’s output in diverse ways, promoting efficiency and versatility in <span class="No-Break">their workflows.</span></p>
			<h3>Error handling</h3>
			<p><strong class="source-inline">stderr</strong> is<a id="_idIndexMarker135"/> specifically designed for error messages. Separating error messages from regular program output simplifies error detection and handling for users. When your application encounters issues, <strong class="source-inline">stderr</strong> provides a designated channel for conveying error information. This separation makes it easier for users to identify and address <span class="No-Break">problems promptly.</span></p>
			<h3>Cross-platform compatibility</h3>
			<p>The <a id="_idIndexMarker136"/>beauty of <strong class="source-inline">stdin</strong>, <strong class="source-inline">stderr</strong>, and <strong class="source-inline">stdout</strong> lies in their platform-agnostic nature. These streams work consistently across different operating systems and environments. Consequently, our CLI applications can maintain portability and compatibility, ensuring that they function reliably on various systems <span class="No-Break">without modification.</span></p>
			<h3>Testing and debugging</h3>
			<p>By following the <a id="_idIndexMarker137"/>convention of using <strong class="source-inline">stderr</strong> for<a id="_idIndexMarker138"/> error output, you make testing and debugging more straightforward. Users can easily capture and analyze error messages separately from the program’s standard output. This separation aids in pinpointing and resolving issues during development and in <span class="No-Break">production environments.</span></p>
			<h3>Logging</h3>
			<p>Many CLI applications<a id="_idIndexMarker139"/> utilize <strong class="source-inline">stderr</strong> for logging error messages. This practice enables users to monitor the application’s behavior and troubleshoot problems effectively. Proper logging enhances the maintainability of your application and contributes to its <span class="No-Break">overall robustness.</span></p>
			<h3>User experience</h3>
			<p>Consistency <a id="_idIndexMarker140"/>in using <strong class="source-inline">stdin</strong>, <strong class="source-inline">stderr</strong>, and <strong class="source-inline">stdout</strong> contributes to a positive user experience. Users are familiar with these streams and expect CLI applications to behave in a standard way. This familiarity reduces the learning curve for new users and increases overall <span class="No-Break">user satisfaction.</span></p>
			<h3>Compliance with conventions</h3>
			<p>Throughout <a id="_idIndexMarker141"/>the software development and scripting communities, many best practices and established conventions assume the use of <strong class="source-inline">stdin</strong>, <strong class="source-inline">stderr</strong>, and <strong class="source-inline">stdout</strong>. Adhering to these conventions makes it easier for your CLI application to integrate into existing workflows and practices, saving time and effort for both developers <span class="No-Break">and users.</span></p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor105"/>File descriptors</h2>
			<p>Do you <a id="_idIndexMarker142"/>ever wonder how your computer manages to juggle all those open files, network connections, and devices without breaking a digital sweat? Well, there’s a little-known secret that keeps everything running smoothly: file descriptors. These unassuming numerical IDs are the unsung heroes behind your computer’s ability to handle files, directories, devices, <span class="No-Break">and more.</span></p>
			<p>In formal terms, a file descriptor is an abstract representation or numeric identifier the operating system uses to uniquely identify and manage open files, sockets, pipes, and other I/O resources. It’s a way for programs to refer to <span class="No-Break">open resources.</span></p>
			<p>File descriptors can represent different types <span class="No-Break">of resources:</span></p>
			<ul>
				<li>Regular files: These are files on disk <span class="No-Break">containing data</span></li>
				<li>Directories: Representations of directories <span class="No-Break">on disk</span></li>
				<li>Character devices: Provide access to devices that work with streams of characters, such as keyboards and <span class="No-Break">serial ports</span></li>
				<li>Block devices: Used for accessing block-oriented devices, such as <span class="No-Break">hard drives</span></li>
				<li>Sockets: For network communication <span class="No-Break">between processes</span></li>
				<li>Pipes: Used for inter-process <span class="No-Break">communication (IPC)</span></li>
			</ul>
			<p>When a shell starts a process, it usually inherits three open file descriptors. Descriptor 0 represents the standard input, the file providing input to the process. Descriptor 1 represents the standard output, the file where the process writes its output. Descriptor 2 represents the standard error, the file where the process writes error messages and notifications regarding abnormal conditions. These descriptors are typically connected to the terminal in interactive shells or programs. In the <strong class="source-inline">os</strong> package, <strong class="source-inline">stdin</strong>, <strong class="source-inline">stdout</strong>, and <strong class="source-inline">stderr</strong> are open files pointing to the standard input, output, and error <span class="No-Break">descriptors (</span><a href="https://cs.opensource.google/go/go/+/refs/tags/go1.21.1:src/os/file.go;l=64"><span class="No-Break">https://cs.opensource.google/go/go/+/refs/tags/go1.21.1:src/os/file.go;l=64</span></a><span class="No-Break">).</span></p>
			<p>In summary, <strong class="source-inline">stdin</strong>, <strong class="source-inline">stderr</strong>, and <strong class="source-inline">stdout</strong> are integral to the development of effective, user-friendly, and interoperable CLI applications. These standardized streams provide a <a id="_idIndexMarker143"/>versatile, flexible, and reliable means of handling input, output, and errors. By embracing these streams, our CLI applications become more accessible and valuable to users, enhancing their ability to automate tasks, process data, and achieve their <span class="No-Break">goals efficiently.</span></p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor106"/>Creating a CLI application</h2>
			<p>Let’s create <a id="_idIndexMarker144"/>and test our first CLI application using the best practices for <span class="No-Break">standard streams.</span></p>
			<p>This program will capture all arguments given (words from now on). When the word length is even, it will send to <strong class="source-inline">stdout</strong>; otherwise, it will send <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">stderr</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
words := os.Args[1:]
if len(words) == 0 {
    fmt.Fprintln(os.Stderr, "No words provided.")
    os.Exit(1)
}</pre>			<p>The first line retrieves the command-line arguments passed to the program, excluding the program name itself. The program name is always the first element in the <strong class="source-inline">os.Args</strong> slice (<strong class="source-inline">os.Args[0]</strong>), so by using the <strong class="source-inline">[1:]</strong> slice, it gets all the arguments after <span class="No-Break">the program.</span></p>
			<p>The conditional checks if the length of the <strong class="source-inline">words</strong> slice is zero, meaning no command-line arguments were provided after the program name. If no arguments were provided, it prints a <strong class="source-inline">"No words provided."</strong> error message to the standard error stream using <strong class="source-inline">fmt.Fprintln(os.Stderr, "No </strong><span class="No-Break"><strong class="source-inline">words provided.")</strong></span><span class="No-Break">.</span></p>
			<p>It then exits the program with a nonzero exit code (<strong class="source-inline">os.Exit(1)</strong>). In Unix-like operating systems, an exit code of 0 typically indicates success, while a nonzero exit code indicates an error. In this case, the program is signaling that it encountered an error due to the absence of <span class="No-Break">command-line arguments:</span></p>
			<pre class="source-code">
for _, w := range words {
    if len(w)%2 == 0 {
        fmt.Fprintf(os.Stdout, "word %s is even\n", w)
    } else {
        fmt.Fprintf(os.Stderr, "word %s is odd\n", w)
    }
}</pre>			<p>This code<a id="_idIndexMarker145"/> iterates over each word in the <strong class="source-inline">words</strong> slice, checks if its length is even or odd, and then prints a corresponding message to either the standard output or <span class="No-Break">standard error.</span></p>
			<p>The <strong class="source-inline">main.go</strong> file will be <span class="No-Break">like this:</span></p>
			<pre class="source-code">
package main
import (
     "fmt"
     "os"
)
func main() {
     words := os.Args[1:]
     if len(words) == 0 {
          fmt.Fprintln(os.Stderr, "No words provided.")
          os.Exit(1)
     }
     for _, w := range words {
          if len(w)%2 == 0 {
               fmt.Fprintf(os.Stdout, "word %s is even\n", w)
          } else {
               fmt.Fprintf(os.Stderr, "word %s is odd\n", w)
          }
     }
}</pre>			<p>To see our<a id="_idIndexMarker146"/> program working, we should pass arguments, as in the <span class="No-Break">next example:</span></p>
			<pre class="console">
go run main.go alex golang error</pre>			<p>To see which words are printed to <strong class="source-inline">stdout</strong> (standard output) and which are printed to <strong class="source-inline">stderr</strong> (standard error), you can use redirection in <span class="No-Break">the terminal:</span></p>
			<pre class="console">
go run main.go word1 word2 word3 &gt; stdout.txt 2&gt; stderr.txt</pre>			<p>After running the preceding command, you can inspect the contents of <strong class="source-inline">stdout.txt</strong> and <strong class="source-inline">stderr.txt</strong> to see which words were printed to <span class="No-Break">each stream:</span></p>
			<pre class="console">
cat stdout.txt
cat stderr.txt</pre>			<p>Words with even lengths will be in <strong class="source-inline">stdout.txt</strong>, and words with odd lengths will be <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">stderr.txt</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor107"/>Redirections and standard streams</h2>
			<p>Remember<a id="_idIndexMarker147"/> that <strong class="source-inline">stdout</strong> is the file descriptor 1 and <strong class="source-inline">stderr</strong> is the file descriptor 2? Now, it’ll be <span class="No-Break">coming together.</span></p>
			<p>When we use <strong class="source-inline">&gt; stdout.txt</strong>, we’re using a shell redirection operator. It redirects the standard output (<strong class="source-inline">stdout</strong>) of the command to the left of the operator to the file on the right. Since <strong class="source-inline">stdout</strong> is the standard output, the number 1 is commonly omitted, which is not true for <strong class="source-inline">2&gt;</strong>. It specifically<a id="_idIndexMarker148"/> redirects the standard <span class="No-Break">error (</span><span class="No-Break"><strong class="source-inline">stderr</strong></span><span class="No-Break">).</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">stdout.txt</strong> and <strong class="source-inline">stderr.txt</strong> files are where the standard output and standard error of the <strong class="source-inline">go run</strong> command will be written, respectively. If any one of these files doesn’t exist, it will be created; if it does exist, it will <span class="No-Break">be overwritten.</span></p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor108"/>Making it testable</h2>
			<p>We don’t want to<a id="_idIndexMarker149"/> execute the program in the terminal to ensure the <a id="_idIndexMarker150"/>program still works in every little change. In that regard, we want to add automated tests. Let’s refactor the code to <span class="No-Break">write tests.</span></p>
			<h3>Moving the core logic</h3>
			<p>Move the <a id="_idIndexMarker151"/>core logic of checking word lengths and printing results to a separate function named <strong class="source-inline">app</strong>. This makes the code more organized and easier <span class="No-Break">to test:</span></p>
			<pre class="source-code">
func app(words []string) {
     for _, w := range words {
          if len(w)%2 == 0 {
               fmt.Fprintf(os.Stdout, "word %s is even\n", w)
          } else {
               fmt.Fprintf(os.Stderr, "word %s is odd\n", w)
          }
     }
}</pre>			<h3>Introducing a flexible configuration</h3>
			<p>Add a <strong class="source-inline">CliConfig</strong> struct<a id="_idIndexMarker152"/> to hold configuration values for the CLI. This provides flexibility for future modifications. For now, we are interested in making the standard streams easy to change for <span class="No-Break">the tests:</span></p>
			<pre class="source-code">
type CliConfig struct {
     ErrStream, OutStream io.Writer
}
func app(words []string, cfg CliConfig) {
     for _, w := range words {
          if len(w)%2 == 0 {
               fmt.Fprintf(cfg.OutStream, "word %s is even\n", w)
          } else {
               fmt.Fprintf(cfg.ErrStream, "word %s is odd\n", w)
          }
     }
}</pre>			<h3>Functional Options</h3>
			<p>Functional Options<a id="_idIndexMarker153"/> is a design pattern in Go<a id="_idIndexMarker154"/> that allows for flexible and clean configuration of objects. It’s especially useful when an object has many <span class="No-Break">optional configurations.</span></p>
			<p>This pattern provides<a id="_idIndexMarker155"/> <span class="No-Break">several benefits:</span></p>
			<ul>
				<li>Readability: It’s clear which options are being set without having to remember the order <span class="No-Break">of parameters.</span></li>
				<li>Extensibility: You can easily add new options without changing existing function signatures <span class="No-Break">or calls.</span></li>
				<li>Safety: You can ensure that the object is always in a valid state after construction. You can easily provide default values in the constructor. If an option isn’t provided, the default <span class="No-Break">is used.</span></li>
			</ul>
			<p>In our program, we have two optional configurations: <strong class="source-inline">outStream</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">errStream</strong></span><span class="No-Break">.</span></p>
			<p>Instead of using a constructor with multiple parameters or a configuration struct, you can use <span class="No-Break">functional options:</span></p>
			<pre class="source-code">
type Option func(*CliConfig) error
func WithErrStream(errStream io.Writer) Option {
     return func(c *CliConfig) error {
          c.ErrStream = errStream
          return nil
     }
}
func WithOutStream(outStream io.Writer) Option {
     return func(c *CliConfig) error {
          c.OutStream = outStream
          return nil
     }
}</pre>			<p>Now, you can <a id="_idIndexMarker156"/>have a constructor for the <strong class="source-inline">CliConfig</strong> struct that accepts <span class="No-Break">these options:</span></p>
			<pre class="source-code">
func NewCliConfig(opts ...Option) (CliConfig, error) {
     c := CliConfig{
          ErrStream: os.Stderr,
          OutStream: os.Stdout,
     }
     for _, opt := range opts {
          if err := opt(&amp;c); err != nil {
               return CliConfig{}, err
          }
     }
     return c, nil
}</pre>			<p>With the preceding setup, creating a new <strong class="source-inline">CliConfig</strong> struct becomes intuitive <span class="No-Break">and readable:</span></p>
			<pre class="console">
NewCliConfig(WithOutStream(&amp;var1),WithErrStream(&amp;var2))
NewCliConfig(WithOutStream(&amp;var1))
NewCliConfig(WithErrStream(&amp;var2))</pre>			<h3>Updating the main function</h3>
			<p>We can modify the <strong class="source-inline">main</strong> function to use the new <strong class="source-inline">CliConfig</strong> struct and the <strong class="source-inline">app</strong> function<a id="_idIndexMarker157"/> and to handle potential errors <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">NewCliConfig</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func main() {
     words := os.Args[1:]
     if len(words) == 0 {
          fmt.Fprintln(os.Stderr, "No words provided.")
          os.Exit(1)
     }
     cfg, err := NewCliConfig()
     if err != nil {
          fmt.Fprintf(os.Stderr, "Error creating config: %v\n", err)
          os.Exit(1)
     }
     app(words, cfg)
}</pre>			<h3>Testing</h3>
			<p>Let’s look at our <a id="_idIndexMarker158"/>test function and examine what we’re achieving <span class="No-Break">with it:</span></p>
			<pre class="source-code">
package main
import (
    "bytes"
    "strings"
    "testing"
)
func TestMainProgram(t *testing.T) {
    var stdoutBuf, stderrBuf bytes.Buffer
    config, err := NewCliConfig(WithOutStream(&amp;stdoutBuf), WithErrStream(&amp;stderrBuf))
    if err != nil {
        t.Fatal("Error creating config:", err)
    }
    app([]string{"main", "alex", "golang", "error"}, config)
    output := stdoutBuf.String()
    if len(output) == 0 {
        t.Fatal("Expected output, got nothing")
    }
    if !strings.Contains(output, "word alex is even") {
        t.Fatal("Expected output does not contain 'word alex is even'")
    }
    if !strings.Contains(output, "word golang is even") {
        t.Fatal("Expected output does not contain 'word golang is even'")
    }
    errors := stderrBuf.String()
    if len(errors) == 0 {
        t.Fatal("Expected errors, got nothing")
    }
    if !strings.Contains(errors, "word error is odd") {
        t.Fatal("Expected errors does not contain 'word error is odd'")
    }
}</pre>			<p>Let’s break down<a id="_idIndexMarker159"/> the key components and steps of <span class="No-Break">this test:</span></p>
			<ol>
				<li>The <strong class="source-inline">TestMainProgram</strong> function is the test function that checks the behavior of the <span class="No-Break">app function.</span></li>
				<li>Two <strong class="source-inline">bytes.Buffer</strong> variables, <strong class="source-inline">stdoutBuf</strong> and <strong class="source-inline">stderrBuf</strong>, are created. These buffers will capture the program’s standard output and standard error streams, respectively. This allows you to capture and examine the program’s output and error messages within <span class="No-Break">the test.</span></li>
				<li>The <strong class="source-inline">NewCliConfig</strong> function is called to create a <strong class="source-inline">CliConfig</strong> configuration with custom output and error streams. The <strong class="source-inline">WithOutStream</strong> and <strong class="source-inline">WithErrStream</strong> options are used to set the output and error streams to the <strong class="source-inline">stdoutBuf</strong> and <strong class="source-inline">stderrBuf</strong> buffers, respectively. This is done so that the program’s output and errors are captured and can be checked within <span class="No-Break">the test.</span></li>
				<li>The <strong class="source-inline">app</strong> function is called with a list of words as input, and the custom <strong class="source-inline">CliConfig</strong> struct is provided as configuration. In this case, the words <strong class="source-inline">"main"</strong>, <strong class="source-inline">"alex"</strong>, <strong class="source-inline">"golang"</strong>, and <strong class="source-inline">"error"</strong> are passed as arguments to simulate the behavior of <span class="No-Break">your program.</span></li>
			</ol>
			<p>The test then checks various aspects of the program’s output <span class="No-Break">and errors:</span></p>
			<ol>
				<li>It checks if there is any output captured in <strong class="source-inline">stdoutBuf</strong>. If there is no output, it fails <span class="No-Break">the test.</span></li>
				<li>It checks if the expected output messages, such as <strong class="source-inline">"word alex is even"</strong> and <strong class="source-inline">"word golang is even"</strong>, are contained within the captured output. If any expected output is missing, it fails <span class="No-Break">the test.</span></li>
				<li>It checks if there are any errors captured in <strong class="source-inline">stderrBuf</strong>. If there are no errors, it fails <span class="No-Break">the test.</span></li>
				<li>It checks if the expected error message, <strong class="source-inline">"word error is odd"</strong>, is contained within the captured errors. If the expected error is missing, it fails <span class="No-Break">the test.</span></li>
			</ol>
			<p>We can run the test with the <strong class="source-inline">go test</strong> command, and a similar output will <span class="No-Break">be displayed:</span></p>
			<pre class="console">
=== RUN   TestMainProgram
--- PASS: TestMainProgram (0.00s)
PASS</pre>			<p>In summary, this <a id="_idIndexMarker160"/>unit test verifies if the <strong class="source-inline">app</strong> function correctly produces the expected output and error messages when given a specific set of words. It captures the program’s output and errors using <strong class="source-inline">bytes.Buffer</strong>, checks for the presence of expected messages, and reports test failures if any of the expected output or error messages are missing. This test helps ensure that the <strong class="source-inline">app</strong> function behaves as expected in different scenarios, avoiding manual testing using <span class="No-Break">the terminal.</span></p>
			<p>We can now use our program with other <span class="No-Break">Linux tools:</span></p>
			<pre class="console">
go build -o cli-app main.go
ls -l | xargs app | grep even</pre>			<p>This last command lists the contents of the current directory, passes each line of that listing as an argument to the <strong class="source-inline">app</strong> command, and then filters the output of the <strong class="source-inline">app</strong> command to display only lines containing the <span class="No-Break">word “</span><span class="No-Break"><strong class="source-inline">even</strong></span><span class="No-Break">”.</span></p>
			<p>Before we move forward, it would be helpful to have a summary of this chapter’s <span class="No-Break">key concepts.</span></p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor109"/>Summary</h1>
			<p>Drawing from the analogy of traveling, we’ve seen how system calls act as passports, allowing processes to navigate the vast terrains of software execution. We’ve distinguished between user mode and kernel mode, emphasizing the privileges and restrictions associated with each. The chapter also sheds light on the challenges faced by the <strong class="source-inline">syscall</strong> package in Go, leading to its eventual deprecation in favor of the more maintainable <strong class="source-inline">x/sys</strong> package. Furthermore, throughout this chapter, we’ve successfully built a CLI application, harnessing the power of Go’s <strong class="source-inline">os</strong> and <strong class="source-inline">x/sys</strong> packages. We’ve seen firsthand how system calls can be integrated into practical software solutions, enabling direct interactions with the operating system. As you move forward, remember the best practices highlighted and the skills acquired, ensuring safe, efficient system-level programming and robust CLI tool creation <span class="No-Break">in Go.</span></p>
			<p>In the next chapter, we will explore the world of file and directory operations in Go, a vital skill set for any developer working with filesystems. Our primary emphasis will be identifying insecure permissions, determining directory sizes, and pinpointing duplicate files. These techniques hold significant importance for all developers who engage with filesystems, as they play a crucial role in upholding data integrity and safeguarding security within <span class="No-Break">software applications.</span></p>
		</div>
	</div>
</div>
</body></html>