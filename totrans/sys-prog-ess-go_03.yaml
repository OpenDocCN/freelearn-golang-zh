- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Understanding System Calls
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解系统调用
- en: In this chapter, you will embark on a journey into the world of system calls,
    those fundamental interfaces that bridge user-level programs with the operating
    system kernel. Through relatable analogies and real-world parallels, we’ll demystify
    the intricate dance of software execution, highlighting the pivotal roles of the
    kernel, user mode, and kernel mode.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将开始一段探索系统调用世界的旅程，这些基本接口将用户级程序与操作系统内核连接起来。通过相关的类比和现实世界的平行关系，我们将揭示软件执行的复杂舞蹈，强调内核、用户模式和内核模式的关键作用。
- en: Understanding system calls and their interaction with the operating system is
    crucial for any software developer aiming to craft efficient and robust applications.
    In the broader context of this book, this chapter lays the foundation for subsequent
    discussions on advanced OS interactions and system-level programming. Moreover,
    in the real-world context, mastering these concepts equips developers with the
    tools to optimize software performance, troubleshoot issues at the system level,
    and harness the full potential of the operating system’s capabilities.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 理解系统调用及其与操作系统的交互对于任何希望构建高效和健壮应用的软件开发者至关重要。在本书的更广泛背景下，本章为后续关于高级操作系统交互和系统级编程的讨论奠定了基础。此外，在现实世界的背景下，掌握这些概念使开发者能够优化软件性能，在系统级别解决问题，并充分利用操作系统的能力。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Introduction to system calls
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统调用简介
- en: The `syscall` package
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syscall` 包'
- en: A closer look at the `os` and `x/sys` packages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解 `os` 和 `x/sys` 包
- en: Everyday system calls
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每日系统调用
- en: Developing and testing a **command-line interface** (**CLI**) program
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发和测试**命令行界面**（CLI）程序
- en: By the end of this chapter, you will not only have grasped the theoretical underpinnings
    of system calls but also gained hands-on experience by constructing a CLI application
    using Go.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你不仅将掌握系统调用的理论基础，还将通过使用Go构建CLI应用程序获得实践经验。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find this chapter’s source code at [https://github.com/PacktPublishing/System-Programming-Essentials-with-Go/tree/main/ch3](https://github.com/PacktPublishing/System-Programming-Essentials-with-Go/tree/main/ch3).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/System-Programming-Essentials-with-Go/tree/main/ch3](https://github.com/PacktPublishing/System-Programming-Essentials-with-Go/tree/main/ch3)找到本章的源代码。
- en: Introduction to system calls
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统调用简介
- en: System calls, often called “syscalls,” are fundamental to an operating system’s
    interface. They are low-level functions provided by the operating system kernel
    that allow user-level processes to request services from the kernel.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用，通常称为“syscalls”，是操作系统接口的基本组成部分。它们是由操作系统内核提供的低级函数，允许用户级进程请求内核的服务。
- en: If you are new to the concept, some analogies could make understanding more
    effortless. Let’s correlate the idea with traveling.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个概念还不熟悉，一些类比可以使理解更加容易。让我们将这个想法与旅行联系起来。
- en: User mode versus kernel mode
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 用户模式与内核模式
- en: 'A processor (or CPU) has two modes of operation: user mode and kernel mode
    (also known as supervisor mode or privileged mode). These modes dictate the level
    of access and control that a program has over system resources. User mode is restricted
    and doesn’t allow direct access to certain critical system resources, while kernel
    mode has more privileges and can access these resources. Permission granted, proceed
    with caution'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器（或CPU）有两种操作模式：用户模式和内核模式（也称为管理模式或特权模式）。这些模式决定了程序对系统资源的访问和控制级别。用户模式受限，不允许直接访问某些关键系统资源，而内核模式具有更多权限，可以访问这些资源。权限已授予，请谨慎行事
- en: When it comes to system calls, the kernel plays the role of a strict border
    control officer. System calls are like the passports we need to navigate the diverse
    landscapes of software execution. Think of the kernel as a heavily fortified international
    border checkpoint. Just as travelers need permission to enter a foreign land,
    our processes require approval to access the kernel’s resources. System calls
    serve as passports, allowing us to cross the border between user and kernel spaces.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到系统调用时，内核扮演着严格的边境控制官员的角色。系统调用就像我们需要穿越软件执行多样化景观的护照。将内核想象成一个高度设防的国际边境检查站。正如旅行者需要获得进入外国土地的许可一样，我们的进程需要获得访问内核资源的批准。系统调用作为护照，允许我们穿越用户和内核空间之间的边界。
- en: The catalog of services and identification
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务目录和标识
- en: Much like a traveler’s guidebook, the kernel offers a comprehensive catalog
    of services through the system call **application programming interface** (**API**).
    These services range from creating new processes to handling **input and output**
    (**I/O**) operations such as amenities and attractions in a foreign country.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 就像一本旅行指南一样，内核通过系统调用**应用程序编程接口**（**API**）提供了一整套服务。这些服务从创建新进程到处理**输入和输出**（**I/O**）操作，如外国国家的便利设施和景点。
- en: A numerical code uniquely identifies each system call, like your passport number.
    However, this numbering system remains hidden from everyday use. Instead, we interact
    with system calls by their names, much like travelers identifying services and
    landmarks by their local names rather than their codes. For instance, an `open`
    system call might be identified by the number 5 in the kernel’s internal system
    call table. However, as programmers, we refer to this system call by its name,
    “`open`,” much like travelers identify places by their local names rather than
    their GPS coordinates.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数字代码唯一地标识每个系统调用，就像你的护照号码。然而，这个编号系统在日常使用中是隐藏的。相反，我们通过它们的名称与系统调用互动，就像旅行者通过当地名称而不是代码来识别服务和地标。例如，一个`open`系统调用可能在内核的内部系统调用表中被标识为数字5。然而，作为程序员，我们通过其名称“`open`”来引用这个系统调用，就像旅行者通过当地名称而不是GPS坐标来识别地点。
- en: 'The location of the system call table depends on the OS and the architecture,
    but if you are curious about these identifiers, you can visit a handcrafted table
    at the following link:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用表的位置取决于操作系统和架构，但如果你对这些标识符感兴趣，可以访问以下链接中的定制表格：
- en: '[https://filippo.io/linux-syscall-table/](https://filippo.io/linux-syscall-table/)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://filippo.io/linux-syscall-table/](https://filippo.io/linux-syscall-table/)'
- en: Information exchange
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信息交换
- en: System calls are not one-way transactions; they involve a careful exchange of
    information. Each system call comes with arguments that dictate what data needs
    to travel between user space (your process’s domain) and kernel space (the kernel’s
    realm). Picture it as a well-coordinated cross-border conversation, where information
    passes seamlessly between the two sides.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用不是单向交易；它们涉及仔细的信息交换。每个系统调用都带有参数，这些参数规定了哪些数据需要在用户空间（你的进程域）和内核空间（内核的领域）之间传输。想象一下，这是一个协调良好的跨境对话，信息在双方之间无缝传递。
- en: When you use the `write()` system call to save data to a file, you pass not
    only the data but also information about where to write it (for example, a file
    descriptor and a data buffer). This data exchange is like a conversation across
    borders, with data moving seamlessly between the user and kernel spaces.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`write()`系统调用来将数据保存到文件时，你不仅传递数据，还传递有关写入位置的信息（例如，文件描述符和数据缓冲区）。这种数据交换就像跨境对话，数据在用户和内核空间之间无缝移动。
- en: The syscall package
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`syscall`包'
- en: 'We observe a consistent trend: the vast majority of functionalities we require
    are readily accessible within the standard library, a testament to its comprehensiveness
    and utility. However, there is a notable exception in this pattern – the `syscall`
    package.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们观察到一种一致的趋势：我们需要的绝大多数功能都可以在标准库中轻松访问，这是其全面性和实用性的证明。然而，在这个模式中有一个显著的例外——`syscall`包。
- en: 'The package has been a foundation for interfacing with system calls and constants
    across various architectures and operating systems. However, over time, several
    issues have emerged that led to its deprecation:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 该包一直是跨各种架构和操作系统与系统调用和常量接口的基础。然而，随着时间的推移，出现了几个问题，导致其被弃用：
- en: '`syscall` was like that overstuffed closet you promise to clean out... someday.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syscall`就像你承诺要清理的……某个时候会清理的过度拥挤的衣柜。'
- en: '**Testing limitations**: A significant portion of the package lacks explicit
    tests. Moreover, cross-platform testing is unfeasible due to the package’s design.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试限制**：该包的大部分内容缺乏明确的测试。此外，由于包的设计，跨平台测试不可行。'
- en: '`syscall` package set a record by becoming one of the least maintained, tested,
    and documented packages in the standard repository.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syscall`包创下了记录，成为标准库中最少维护、测试和记录的包之一。'
- en: '`syscall` package, with its unique variations for each system, is like a mystery
    wrapped in an enigma for developers. While one would hope for clarity, the `godoc`
    tool only offers a sneak peek, very similar to a movie trailer showcasing just
    the highlights. This selective display, tailored to its native environment, combined
    with an overarching lack of documentation, turns understanding and effectively
    using the package into a challenging endeavor.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syscall`包，每个系统都有其独特的变体，对于开发者来说就像是一个谜团中的谜团。虽然人们希望有清晰的指导，但`godoc`工具只提供了一个简要的预览，非常类似于电影预告片，只展示了亮点。这种针对其原生环境的精选显示，加上普遍缺乏文档，使得理解和有效使用这个包成为一项具有挑战性的任务。'
- en: '`syscall` package often feels like it’s in a relentless chase, something like
    pursuing a unicorn. Operating systems, with their constant evolution, present
    a challenge that’s beyond the Go team’s control. For instance, shifts in FreeBSD
    have impacted the package’s compatibility.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syscall`包常常感觉像是在进行无休止的追逐，就像追逐独角兽一样。操作系统随着不断的进化，提出了超出了Go团队控制范围的挑战。例如，FreeBSD的变化影响了这个包的兼容性。'
- en: 'To address these concerns, the Go team proposed the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些担忧，Go团队提出了以下建议：
- en: '`syscall` package would be frozen, meaning no further changes would be made
    to it. This includes not updating it even if there are changes in the operating
    systems it references.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syscall`包将被冻结，这意味着不会对其做任何进一步的修改。这包括即使引用的操作系统中有所变化，也不会更新它。'
- en: '`x/sys` ([https://pkg.go.dev/golang.org/x/sys](https://pkg.go.dev/golang.org/x/sys)),
    was created to replace the `syscall` package. This new package is easier to maintain,
    document, and use for cross-platform development.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x/sys` ([https://pkg.go.dev/golang.org/x/sys](https://pkg.go.dev/golang.org/x/sys))是为了替换`syscall`包而创建的。这个新包更容易维护、文档化和用于跨平台开发。'
- en: 'Deprecation: While the `syscall` package would continue to exist and function,
    all new public development was shifted to `x/sys`. The documentation for the `syscall`
    package would guide users toward this new repository.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 废弃：虽然`syscall`包将继续存在并运行，但所有新的公共开发都转移到了`x/sys`。`syscall`包的文档将指导用户转向这个新的存储库。
- en: In essence, while the `syscall` package served its purpose for a time, the challenges
    it posed in terms of maintenance, documentation, and compatibility necessitated
    its deprecation in favor of a more structured and maintainable approach with `x/sys`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，虽然`syscall`包在一段时间内发挥了作用，但它带来的维护、文档和兼容性方面的挑战，使得它不得不被废弃，转而采用更结构化和可维护的`x/sys`方法。
- en: For more information on the decision, there is a post by Rob Pike explaining
    the decision ([https://go.googlesource.com/proposal/+/refs/heads/master/design/freeze-syscall.md](https://go.googlesource.com/proposal/+/refs/heads/master/design/freeze-syscall.md)).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个决定的更多信息，Rob Pike有一篇帖子解释了这一决定([https://go.googlesource.com/proposal/+/refs/heads/master/design/freeze-syscall.md](https://go.googlesource.com/proposal/+/refs/heads/master/design/freeze-syscall.md))。
- en: A closer look at the os and x/sys packages
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解os和x/sys包
- en: 'As we can see in the Go documentation regarding the `x/sys` package:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在Go文档中关于`x/sys`包所看到的那样：
- en: “*The primary use of x/sys is inside other packages that provide a more portable
    interface to the system, such as “os”, “time”* *and “net”.*
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: “*`x/sys`的主要用途是在其他提供更便携接口到系统的包内部，例如“os”、“time”和“net”*。”
- en: '*Use those packages rather than this one if you can. For details of the functions
    and data types in this package consult the manuals for the appropriate operating
    system. These calls return err == nil to indicate success; otherwise err is an
    operating system error describing the failure. On most systems, that error has*
    *type syscall.Errno.*”'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果可能的话，使用那些包而不是这个包。关于这个包中函数和数据类型的详细信息，请参阅相应操作系统的手册。这些调用返回err == nil表示成功；否则err是描述失败的操作系统错误。在大多数系统中，这个错误有*
    *type syscall.Errno.*”'
- en: x/sys package – low-level system calls
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: x/sys包 – 底层系统调用
- en: The `x/sys` package in Go provides access to low-level system calls. It’s typically
    used when interacting directly with the operating system is necessary or for platform-specific
    operations. It’s important to exercise caution when using `x/sys`, as incorrect
    usage can lead to system instability or security issues.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言中的`x/sys`包提供了对底层系统调用的访问。它通常在需要直接与操作系统交互或进行特定平台操作时使用。使用`x/sys`时需要谨慎，因为不当的使用可能导致系统不稳定或安全问题。
- en: 'To use this package, you should download it using the Go tools:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个包，你应该使用Go工具下载它：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s explore what this package could offer.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来探讨这个包能提供什么。
- en: System calls
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统调用
- en: 'Here are some system call invocations and constants:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些系统调用调用和常量：
- en: '`unix.Syscall()`: Call a specific system call with arguments'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unix.Syscall()`: 使用参数调用特定的系统调用'
- en: '`unix.Syscall6()`: Similar to `Syscall()` but for system calls with six arguments'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unix.Syscall6()`: 与`Syscall()`类似，但用于具有六个参数的系统调用'
- en: '`unix.SYS_*`: Constants representing various system calls (for example, `unix.SYS_READ`,
    `unix.SYS_WRITE`)'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unix.SYS_*`: 表示各种系统调用的常量（例如，`unix.SYS_READ`, `unix.SYS_WRITE`）'
- en: For example, the next two snippets result in the same outcome, printing `"``Hello
    World!"`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面两个代码片段会产生相同的结果，打印出`"Hello World!"`。
- en: 'Using the `fmt` package, you get the following output:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fmt`包，你可以得到以下输出：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And by using the `x/sys` package, you get the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`x/sys`包，你可以得到以下内容：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Things can get complex very easily if we decide to use a low-level abstraction
    instead of the `fmt` package.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定使用低级抽象而不是`fmt`包，事情可能会变得非常复杂。
- en: We can continue exploring the package API by category.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过类别继续探索包API。
- en: File operations
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件操作
- en: 'These functions let us interact with general files:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数让我们可以与普通文件交互：
- en: '`unix.Create()`: Create a new file'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unix.Create()`: 创建新文件'
- en: '`unix.Unlink()`: Remove a file'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unix.Unlink()`: 删除文件'
- en: '`unix.Mkdir()`, `unix.Rmdir()`, and `unix.Link()`: Create and remove directories
    and links'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unix.Mkdir()`, `unix.Rmdir()`, 和 `unix.Link()`: 创建和删除目录和链接'
- en: '`unix.Getdents()`: Get directory entries'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unix.Getdents()`: 获取目录条目'
- en: Signals
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信号
- en: 'Here are two examples of functions that interact with OS signals:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个与OS信号交互的函数示例：
- en: '`unix.Kill()`: Send a kill signal to a process'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unix.Kill()`: 向进程发送终止信号'
- en: '`unix.SIGINT`: Interrupt signal (commonly known as *Ctrl* + *C*)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unix.SIGINT`: 中断信号（通常称为*Ctrl* + *C*）'
- en: User and group management
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户和组管理
- en: 'We can manage users and groups using the following calls:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下调用管理用户和组：
- en: '`syscall.Setuid()`, `syscall.Setgid()`, `syscall.Setgroups()`: Set user and
    group IDs'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syscall.Setuid()`, `syscall.Setgid()`, `syscall.Setgroups()`: 设置用户和组ID'
- en: System information
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统信息
- en: 'We can analyze some statistics on memory and swap usage and the load average
    using the `Sysinfo()` function:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Sysinfo()`函数分析一些关于内存和交换使用以及平均负载的统计数据：
- en: '`syscall.Sysinfo()`: Get system information'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syscall.Sysinfo()`: 获取系统信息'
- en: File descriptors
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件描述符
- en: 'While it’s not an everyday task, we can also interact with file descriptors
    directly:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是日常任务，但我们也可以直接与文件描述符交互：
- en: '`unix.FcntlInt()`: Perform various operations on file descriptors'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unix.FcntlInt()`: 对文件描述符执行各种操作'
- en: '`unix.Dup2()`: Duplicate a file descriptor'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unix.Dup2()`: 复制文件描述符'
- en: Memory-mapped files
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存映射文件
- en: 'Mmap is an acronym for memory-mapped files. It provides a mechanism for reading
    and writing files without relying on system calls. When using `Mmap()`, the operating
    system allocates a section of a program’s virtual address space, which is directly
    “mapped” to a corresponding file section. If the program accesses data from that
    part of the address space, it will retrieve the data stored in the related part
    of the file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Mmap是内存映射文件的缩写。它提供了一种机制，可以在不依赖系统调用的前提下读写文件。当使用`Mmap()`时，操作系统会为程序分配一段虚拟地址空间，该空间直接“映射”到相应的文件部分。如果程序访问地址空间的那部分数据，它将检索存储在文件相关部分的数据：
- en: '`syscall.Mmap()`: Map files or devices into memory'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syscall.Mmap()`: 将文件或设备映射到内存'
- en: Operating system functionality
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作系统功能
- en: The `os` package in Go provides a rich set of functions for interacting with
    the operating system. It’s divided into several subpackages, each focusing on
    a specific aspect of OS functionality.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言中的`os`包提供了一组丰富的函数，用于与操作系统交互。它分为几个子包，每个子包都专注于OS功能的一个特定方面。
- en: 'The following are file and directory operations:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些文件和目录操作：
- en: '`os.Create()`: Creates or opens a file for writing'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.Create()`: 创建或打开文件以写入'
- en: '`os.Mkdir()` and `os.MkdirAll()`: Create directories'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.Mkdir()` 和 `os.MkdirAll()`: 创建目录'
- en: '`os.Remove()` and `os.RemoveAll()`: Remove files and directories'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.Remove()` 和 `os.RemoveAll()`: 删除文件和目录'
- en: '`os.Stat()`: Get file or directory information (metadata)'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.Stat()`: 获取文件或目录信息（元数据）'
- en: '`os.IsExist()`, `os.IsNotExist()`, and `os.IsPermission()`: Check file/directory
    existence or permission errors'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.IsExist()`, `os.IsNotExist()`, 和 `os.IsPermission()`: 检查文件/目录存在或权限错误'
- en: '`os.Open()`: Open a file for reading'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.Open()`: 以读取方式打开文件'
- en: '`os.Rename()`: Rename or move a file'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.Rename()`: 重命名或移动文件'
- en: '`os.Truncate()`: Resize a file'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.Truncate()`: 调整文件大小'
- en: '`os.Getwd()`: Get the current working directory'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.Getwd()`: 获取当前工作目录'
- en: '`os.Chdir()`: Change the current working directory'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.Chdir()`: 更改当前工作目录'
- en: '`os.Args`: Command-line arguments'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.Args`: 命令行参数'
- en: '`os.Getenv()`: Get environment variables'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.Getenv()`: 获取环境变量'
- en: '`os.Setenv()`: Set environment variables'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.Setenv()`: 设置环境变量'
- en: 'The following are for processes and signals:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与进程和信号相关的内容：
- en: '`os.Getpid()`: Get the current process ID'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.Getpid()`: 获取当前进程ID'
- en: '`os.Getppid()`: Get the parent process ID'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.Getppid()`: 获取父进程ID'
- en: '`os.Getuid()` and `os.Getgid()`: Get the user and group IDs'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.Getuid()`和`os.Getgid()`: 获取用户和组ID'
- en: '`os.Geteuid()` and `os.Getegid()`: Get the effective user and group IDs'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.Geteuid()`和`os.Getegid()`: 获取有效用户和组ID'
- en: '`os.StartProcess()`: Start a new process'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.StartProcess()`: 启动新进程'
- en: '`os.Exit()`: Exit the current process'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.Exit()`: 退出当前进程'
- en: '`os.Signal`: Represents signals (for example, `SIGINT`, `SIGTERM`)'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.Signal`: 表示信号（例如，`SIGINT`，`SIGTERM`）'
- en: '`os/signal.Notify()`: Notify on signal reception'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os/signal.Notify()`: 在接收到信号时通知'
- en: 'The `os` package allows you to create and manipulate processes. You can start
    new processes, obtain information about the current process, and manipulate its
    properties:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`os`包允许你创建和操作进程。你可以启动新进程，获取当前进程的信息，并操作其属性：'
- en: '[PRE3]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The main parts of this program are the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的主要部分如下：
- en: '`exec.Command("ls", "-l")`: This creates a new command to run the `ls` command
    with the `-``l` flag.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exec.Command("ls", "-l")`: 这将创建一个新的命令来运行带有`-l`标志的`ls`命令。'
- en: '`cmd.Stdout = os.Stdout`: This redirects the standard output of the `ls` command
    to the standard output of the main program.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd.Stdout = os.Stdout`: 这将`ls`命令的标准输出重定向到主程序的标准输出。'
- en: '`cmd.Stderr = os.Stderr`: Similarly, this redirects the standard error of the
    `ls` command to the standard error of the main program.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd.Stderr = os.Stderr`: 类似地，这将`ls`命令的标准错误重定向到主程序的标准错误。'
- en: '`err := cmd.Run()`: This runs the `ls` command. If there’s an error during
    its execution, it will be stored in the `err` variable.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`err := cmd.Run()`: 这将运行`ls`命令。如果在执行过程中出现错误，它将被存储在`err`变量中。'
- en: '`os.Getpid()`: This retrieves the process ID of the current process.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.Getpid()`: 这将检索当前进程的进程ID。'
- en: While the `os` package provides a high-level interface for many system-related
    tasks, the `syscall`(and `x/sys`) package allows you to make lower-level system
    calls directly. This can be useful when you need fine-grained control over system
    resources.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`os`包提供了许多系统相关任务的底层接口，但`syscall`(和`x/sys`)包允许你直接进行更底层的系统调用。这在你需要对系统资源进行精细控制时非常有用。
- en: Portability
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可移植性
- en: While `x/sys` is the go-to package to make syscalls, you must explicitly choose
    between Unix and Windows. The recommended way to interact with the operating system
    is to use the `os` package. When you build your program to a determined OS and
    architecture, the compiler will do the heavy lifting to use the adequate syscall
    version.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`x/sys`是进行系统调用的首选包，但你必须明确选择Unix和Windows。与操作系统交互的推荐方式是使用`os`包。当你将程序构建到特定的操作系统和架构时，编译器将执行繁重的工作以使用适当的系统调用版本。
- en: 'For example, while in Windows, you need to call a function with the following
    signature:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Windows中，你需要调用具有以下签名的函数：
- en: '[PRE4]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The signature doesn’t even have the same name for Unix-based systems, as we
    can see in the next snippet:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于Unix的系统，签名甚至没有相同的名称，正如我们将在下一个片段中看到的那样：
- en: '[PRE5]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To avoid this “signature Tetris,” we could use the function from the `os` package
    with the same semantics:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种“签名俄罗斯方块”，我们可以使用具有相同语义的`os`包中的函数：
- en: '[PRE6]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: (Yes! The signature is the same as the Unix version.)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: （是的！签名与Unix版本相同。）
- en: Note
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The primary use of `syscall` ([https://pkg.go.dev/syscall](https://pkg.go.dev/syscall))
    is inside other packages that provide a more portable interface to the system,
    such as `os`, `time`, and `net`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`syscall`([https://pkg.go.dev/syscall](https://pkg.go.dev/syscall))的主要用途是在提供更可移植系统接口的其他包内部，例如`os`、`time`和`net`。'
- en: From now on, we leverage the `os` package, and only in exceptional cases will
    we directly call the `x/sys` package.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们利用`os`包，只有在特殊情况下才会直接调用`x/sys`包。
- en: Best practices
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'As a system programmer using the `os` and `x/sys` packages in Go, consider
    the following best practices:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用Go中的`os`和`x/sys`包的系统程序员，请考虑以下最佳实践：
- en: Use the `os` package for most tasks, as it provides a safer and more portable
    interface
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于大多数任务，使用`os`包，因为它提供了一个更安全和更可移植的接口
- en: Reserve the `x/sys` package for situations where fine-grained control over system
    calls is necessary
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在需要精细控制系统调用的情况下保留`x/sys`包
- en: Pay attention to platform-specific constants and types when using the `x/sys`
    package to ensure cross-platform compatibility
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `x/sys` 包时，请注意平台特定的常量和类型，以确保跨平台兼容性
- en: Handle errors returned by system calls and `os` package functions diligently
    to maintain the reliability of your applications
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认真处理系统调用和 `os` 包函数返回的错误，以维护应用程序的可靠性
- en: Test your system-level code on different operating systems to verify its behavior
    in diverse environments
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同的操作系统上测试你的系统级代码，以验证其在各种环境中的行为
- en: Let’s explore how we can trace what is happening in the commands we do in the
    terminal on a daily basis.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何追踪我们在终端上日常执行的命令中发生的事情。
- en: Everyday system calls
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每日系统调用
- en: Several syscalls are happening in our programs every time under our noses. We
    can trace these calls using the `strace` tool.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序中，每次都会发生几个系统调用。我们可以使用 `strace` 工具追踪这些调用。
- en: Tracing system calls
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪系统调用
- en: The `strace` tool might not come pre-installed on all Linux distributions, but
    it’s available in most official repositories. Here’s how to install it on some
    major distributions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`strace` 工具可能不是所有 Linux 发行版都预安装的，但在大多数官方仓库中都有。以下是如何在一些主要发行版上安装它的方法。'
- en: 'Debian (using APT): Run the following command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Debian（使用 APT）：运行以下命令：
- en: '[PRE7]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Red Hat family (using DNF** **and YUM)**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**Red Hat 家族（使用 DNF 和 YUM）**'
- en: 'When using `yum`, run the following command:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 `yum` 时，运行以下命令：
- en: '[PRE8]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When using `dnf`, run this command:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 `dnf` 时，运行以下命令：
- en: '[PRE9]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Arch Linux (using Pacman)**: Run the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**Arch Linux（使用 Pacman）**：运行以下命令：'
- en: '[PRE10]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Basic strace usage
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本 strace 使用
- en: 'The basic way to use `strace` is by calling the `strace` utility followed by
    the program’s name; for example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `strace` 的基本方法是调用 `strace` 实用程序，后跟程序名称；例如：
- en: '[PRE11]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will produce an output showing system calls, their arguments, and return
    values. For instance, the `execve` system call ([https://man7.org/linux/man-pages/man2/execve.2.html](https://man7.org/linux/man-pages/man2/execve.2.html))
    might look like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个输出，显示系统调用、它们的参数和返回值。例如，`execve` 系统调用 ([https://man7.org/linux/man-pages/man2/execve.2.html](https://man7.org/linux/man-pages/man2/execve.2.html))
    可能看起来像这样：
- en: '[PRE12]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tracing specific system calls
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪特定系统调用
- en: 'If you only want to trace specific system calls, use the `-e` flag followed
    by the system call’s name. For example, to trace `execve` system calls for the
    `ls` command, run the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想跟踪特定的系统调用，请使用 `-e` 标志后跟系统调用名称。例如，要跟踪 `ls` 命令的 `execve` 系统调用，请运行以下命令：
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we can use our brand-new tool from our toolset to trace syscalls in our
    programs. Consider the following simple `main.go` file:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用我们的工具集中的新工具来追踪程序中的系统调用。考虑以下简单的 `main.go` 文件：
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This program needs to interact with a hardware device by writing data to the
    standard output, our console. To gain access to the console and perform this operation,
    the program requires permission from the kernel. This permission is obtained through
    a system call, like requesting access to a specific functionality, such as sending
    messages to the console, which allows your program to utilize the console’s resources.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序需要通过向标准输出写入数据与硬件设备交互，即我们的控制台。为了访问控制台并执行此操作，程序需要从内核获得权限。这种权限是通过系统调用获得的，例如请求访问特定功能，如向控制台发送消息，这允许你的程序利用控制台的资源。
- en: 'The `unix.Write` function is being called with two arguments:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`unix.Write` 函数正在使用两个参数被调用：'
- en: The first argument is `1`, which is the file descriptor for standard output
    (`stdout`) in Unix-like systems. This means the program will write data to the
    console or terminal where the program is run.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是 `1`，它是 Unix-like 系统中标准输出（`stdout`）的文件描述符。这意味着程序将数据写入程序运行的控制台或终端。
- en: The second argument is `[]byte{"Hello, World!"}`, which is a byte slice containing
    the `"Hello,` `World!"` string.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是 `[]byte{"Hello, World!"}`，它是一个包含 `"Hello,` `World!"` 字符串的字节切片。
- en: 'We build the program calling the binary as `app`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建的程序将二进制文件命名为 `app`：
- en: '[PRE15]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We then run with `strace` tool, filtering the `write` syscall:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后使用 `strace` 工具运行，过滤 `write` 系统调用：
- en: '[PRE16]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You should see the following output as a result:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出作为结果：
- en: '[PRE17]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, it’s time to explore a program that interacts with the OS. Let’s make and
    test our very first CLI application.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候探索一个与操作系统交互的程序了。让我们制作并测试我们的第一个 CLI 应用程序。
- en: Developing and testing a CLI program
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发和测试 CLI 程序
- en: CLI applications are essential tools in software development, system administration,
    and automation. When creating CLI applications, interacting with `stdin` (standard
    input), `stderr` (standard error), and `stdout` (standard output) plays a crucial
    role in ensuring their effectiveness and user-friendliness.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: CLI应用程序是软件开发、系统管理和自动化中的必备工具。在创建CLI应用程序时，与`stdin`（标准输入）、`stderr`（标准错误）和`stdout`（标准输出）的交互在确保其有效性和用户友好性方面起着至关重要的作用。
- en: In this section, we’ll explore why these standard streams are indispensable
    components of CLI development.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨为什么这些标准流是CLI（命令行界面）开发不可或缺的组成部分。
- en: Standard streams
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准流
- en: The concept of `stdin`, `stderr`, and `stdout` is deeply rooted in the Unix
    philosophy of “*everything is a file*.”(We will explore this more in [Chapter
    4](B21662_04.xhtml#_idTextAnchor110), File and Directory Operations.) These standardized
    streams provide a consistent way for CLI applications to communicate with users
    and other processes. Users have come to expect CLI tools to work in a certain
    way, and adhering to these conventions enhances the predictability and user-friendliness
    of your application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdin`、`stderr`和`stdout`的概念深深植根于Unix哲学的“*一切皆文件*。”（我们将在第4章[文件和目录操作](B21662_04.xhtml#_idTextAnchor110)中进一步探讨这一点。）这些标准化流为CLI应用程序与用户和其他进程之间的通信提供了一种一致的方式。用户已经习惯了CLI工具以某种方式工作，遵守这些约定增强了应用程序的可预测性和用户友好性。'
- en: One of the most powerful aspects of CLI applications is their ability to work
    together seamlessly through pipelines (see more in [Chapter 6](B21662_06.xhtml#_idTextAnchor145),
    Pipes). In Unix-like systems, you can chain multiple CLI tools together, with
    each tool processing data from the previous one’s `stdout`. This model allows
    for the efficient processing of data and complex task automation. When your application
    interacts with `stdout`, it becomes a valuable building block in these pipelines,
    enabling users to create sophisticated workflows effortlessly.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: CLI应用程序最强大的特性之一是它们能够通过管道（详见第6章[管道](B21662_06.xhtml#_idTextAnchor145)）无缝协作。在类Unix系统中，您可以链式连接多个CLI工具，每个工具处理前一个工具的`stdout`中的数据。这种模式允许高效地处理数据并实现复杂任务的自动化。当您的应用程序与`stdout`交互时，它成为这些管道中的宝贵构建块，使用户能够轻松创建复杂的流程。
- en: Input flexibility
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入灵活性
- en: By utilizing `stdin`, your CLI application can accept input from various sources.
    Users can provide input interactively via the keyboard, or they can pipe data
    from other processes directly into your tool. Additionally, your application can
    read input from files, allowing users to process data stored in various formats
    and locations. This flexibility makes your application adaptable to a wide range
    of usage scenarios.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用`stdin`，您的CLI应用程序可以接受来自各种来源的输入。用户可以通过键盘进行交互式输入，或者将其他进程的数据直接通过管道输入到您的工具中。此外，您的应用程序还可以从文件中读取输入，使用户能够处理存储在不同格式和位置的各类数据。这种灵活性使得您的应用程序能够适应广泛的用例场景。
- en: Output flexibility
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出灵活性
- en: Similarly, by using `stdout`, your CLI application can provide output in a format
    that can be easily redirected, saved to files, or used as input for other processes.
    This adaptability ensures that users can leverage your tool’s output in diverse
    ways, promoting efficiency and versatility in their workflows.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，通过使用`stdout`，您的CLI应用程序可以以易于重定向、保存到文件或用作其他进程输入的格式提供输出。这种适应性确保了用户能够以多种方式利用工具的输出，从而提高工作效率和灵活性。
- en: Error handling
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误处理
- en: '`stderr` is specifically designed for error messages. Separating error messages
    from regular program output simplifies error detection and handling for users.
    When your application encounters issues, `stderr` provides a designated channel
    for conveying error information. This separation makes it easier for users to
    identify and address problems promptly.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`stderr`专门设计用于错误消息。将错误消息与常规程序输出分开简化了用户的错误检测和处理。当您的应用程序遇到问题时，`stderr`提供了一个专门的通道来传达错误信息。这种分离使得用户能够迅速识别和解决问题。'
- en: Cross-platform compatibility
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨平台兼容性
- en: The beauty of `stdin`, `stderr`, and `stdout` lies in their platform-agnostic
    nature. These streams work consistently across different operating systems and
    environments. Consequently, our CLI applications can maintain portability and
    compatibility, ensuring that they function reliably on various systems without
    modification.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdin`、`stderr`和`stdout`的美丽之处在于它们的平台无关性。这些流在不同的操作系统和环境之间保持一致。因此，我们的命令行应用程序可以保持可移植性和兼容性，确保它们在各种系统上无需修改即可可靠地运行。'
- en: Testing and debugging
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试和调试
- en: By following the convention of using `stderr` for error output, you make testing
    and debugging more straightforward. Users can easily capture and analyze error
    messages separately from the program’s standard output. This separation aids in
    pinpointing and resolving issues during development and in production environments.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循使用`stderr`进行错误输出的惯例，可以使测试和调试更加直接。用户可以轻松地单独捕获和分析错误消息，与程序的正常输出分开。这种分离有助于在开发和生产环境中定位和解决问题。
- en: Logging
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日志记录
- en: Many CLI applications utilize `stderr` for logging error messages. This practice
    enables users to monitor the application’s behavior and troubleshoot problems
    effectively. Proper logging enhances the maintainability of your application and
    contributes to its overall robustness.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 许多命令行界面（CLI）应用程序使用`stderr`记录错误消息。这种做法使用户能够有效地监控应用程序的行为和解决问题。适当的日志记录增强了应用程序的可维护性，并有助于其整体健壮性。
- en: User experience
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户体验
- en: Consistency in using `stdin`, `stderr`, and `stdout` contributes to a positive
    user experience. Users are familiar with these streams and expect CLI applications
    to behave in a standard way. This familiarity reduces the learning curve for new
    users and increases overall user satisfaction.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`stdin`、`stderr`和`stdout`时保持一致性有助于提升用户体验。用户熟悉这些流，并期望命令行应用程序以标准方式运行。这种熟悉性降低了新用户的学习曲线，并提高了整体用户满意度。
- en: Compliance with conventions
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遵守惯例
- en: Throughout the software development and scripting communities, many best practices
    and established conventions assume the use of `stdin`, `stderr`, and `stdout`.
    Adhering to these conventions makes it easier for your CLI application to integrate
    into existing workflows and practices, saving time and effort for both developers
    and users.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发和脚本编写社区中，许多最佳实践和既定惯例都假设使用`stdin`、`stderr`和`stdout`。遵守这些惯例使得你的命令行应用程序更容易集成到现有的工作流程和实践中，为开发者和用户节省时间和精力。
- en: File descriptors
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件描述符
- en: 'Do you ever wonder how your computer manages to juggle all those open files,
    network connections, and devices without breaking a digital sweat? Well, there’s
    a little-known secret that keeps everything running smoothly: file descriptors.
    These unassuming numerical IDs are the unsung heroes behind your computer’s ability
    to handle files, directories, devices, and more.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾好奇过，你的电脑是如何在不费吹灰之力地管理所有这些打开的文件、网络连接和设备？好吧，有一个鲜为人知的秘密让一切运行得如此顺畅：文件描述符。这些不起眼的数字ID是电脑处理文件、目录、设备等背后的无名英雄。
- en: In formal terms, a file descriptor is an abstract representation or numeric
    identifier the operating system uses to uniquely identify and manage open files,
    sockets, pipes, and other I/O resources. It’s a way for programs to refer to open
    resources.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 从正式的角度来说，文件描述符是操作系统用来唯一标识和管理打开的文件、套接字、管道和其他I/O资源的抽象表示或数字标识符。它是程序引用打开资源的一种方式。
- en: 'File descriptors can represent different types of resources:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 文件描述符可以表示不同类型的资源：
- en: 'Regular files: These are files on disk containing data'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常规文件：这些是包含数据的磁盘文件
- en: 'Directories: Representations of directories on disk'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录：磁盘上目录的表示
- en: 'Character devices: Provide access to devices that work with streams of characters,
    such as keyboards and serial ports'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符设备：提供对使用字符流工作的设备（如键盘和串行端口）的访问
- en: 'Block devices: Used for accessing block-oriented devices, such as hard drives'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块设备：用于访问块设备，如硬盘
- en: 'Sockets: For network communication between processes'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字：用于进程间的网络通信
- en: 'Pipes: Used for inter-process communication (IPC)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道：用于进程间通信（IPC）
- en: When a shell starts a process, it usually inherits three open file descriptors.
    Descriptor 0 represents the standard input, the file providing input to the process.
    Descriptor 1 represents the standard output, the file where the process writes
    its output. Descriptor 2 represents the standard error, the file where the process
    writes error messages and notifications regarding abnormal conditions. These descriptors
    are typically connected to the terminal in interactive shells or programs. In
    the `os` package, `stdin`, `stdout`, and `stderr` are open files pointing to the
    standard input, output, and error descriptors ([https://cs.opensource.google/go/go/+/refs/tags/go1.21.1:src/os/file.go;l=64](https://cs.opensource.google/go/go/+/refs/tags/go1.21.1:src/os/file.go;l=64)).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当shell启动一个进程时，它通常继承三个打开的文件描述符。描述符0代表标准输入，为进程提供输入的文件。描述符1代表标准输出，进程写入输出的文件。描述符2代表标准错误，进程写入错误消息和有关异常条件的通知的文件。这些描述符通常连接到交互式shell或程序中的终端。在`os`包中，`stdin`、`stdout`和`stderr`是打开的文件，分别指向标准输入、输出和错误描述符（[https://cs.opensource.google/go/go/+/refs/tags/go1.21.1:src/os/file.go;l=64](https://cs.opensource.google/go/go/+/refs/tags/go1.21.1:src/os/file.go;l=64)）。
- en: In summary, `stdin`, `stderr`, and `stdout` are integral to the development
    of effective, user-friendly, and interoperable CLI applications. These standardized
    streams provide a versatile, flexible, and reliable means of handling input, output,
    and errors. By embracing these streams, our CLI applications become more accessible
    and valuable to users, enhancing their ability to automate tasks, process data,
    and achieve their goals efficiently.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`stdin`、`stderr`和`stdout`对于开发有效、用户友好且可互操作的CLI应用程序至关重要。这些标准化流提供了一种灵活、灵活且可靠的输入、输出和错误处理方式。通过采用这些流，我们的CLI应用程序对用户更加易于访问和有价值，增强了他们自动化任务、处理数据和高效实现目标的能力。
- en: Creating a CLI application
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建CLI应用程序
- en: Let’s create and test our first CLI application using the best practices for
    standard streams.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照标准流的最佳实践创建并测试我们的第一个命令行界面（CLI）应用程序。
- en: 'This program will capture all arguments given (words from now on). When the
    word length is even, it will send to `stdout`; otherwise, it will send to `stderr`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序将捕获所有给出的参数（从现在起称为单词）。当单词长度为偶数时，它将发送到`stdout`；否则，它将发送到`stderr`：
- en: '[PRE18]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first line retrieves the command-line arguments passed to the program, excluding
    the program name itself. The program name is always the first element in the `os.Args`
    slice (`os.Args[0]`), so by using the `[1:]` slice, it gets all the arguments
    after the program.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行检索传递给程序的命令行参数，不包括程序名称本身。程序名称总是`os.Args`切片中的第一个元素（`os.Args[0]`），因此通过使用`[1:]`切片，它获取程序之后的全部参数。
- en: The conditional checks if the length of the `words` slice is zero, meaning no
    command-line arguments were provided after the program name. If no arguments were
    provided, it prints a `"No words provided."` error message to the standard error
    stream using `fmt.Fprintln(os.Stderr, "No` `words provided.")`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 条件检查`words`切片的长度是否为零，这意味着在程序名称之后没有提供任何命令行参数。如果没有提供参数，它将使用`fmt.Fprintln(os.Stderr,
    "No words provided.")`将一个`"No words provided."`错误信息打印到标准错误流。
- en: 'It then exits the program with a nonzero exit code (`os.Exit(1)`). In Unix-like
    operating systems, an exit code of 0 typically indicates success, while a nonzero
    exit code indicates an error. In this case, the program is signaling that it encountered
    an error due to the absence of command-line arguments:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它使用非零退出代码（`os.Exit(1)`）退出程序。在类Unix操作系统中，退出代码为0通常表示成功，而非零退出代码表示错误。在这种情况下，程序表示它遇到了由于缺少命令行参数而导致的错误：
- en: '[PRE19]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code iterates over each word in the `words` slice, checks if its length
    is even or odd, and then prints a corresponding message to either the standard
    output or standard error.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码遍历`words`切片中的每个单词，检查其长度是偶数还是奇数，然后相应地将消息打印到标准输出或标准错误。
- en: 'The `main.go` file will be like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.go`文件将如下所示：'
- en: '[PRE20]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To see our program working, we should pass arguments, as in the next example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看我们的程序运行效果，我们应该传递参数，如下一个示例所示：
- en: '[PRE21]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To see which words are printed to `stdout` (standard output) and which are
    printed to `stderr` (standard error), you can use redirection in the terminal:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看哪些单词被打印到`stdout`（标准输出）和哪些被打印到`stderr`（标准错误），您可以在终端中使用重定向：
- en: '[PRE22]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After running the preceding command, you can inspect the contents of `stdout.txt`
    and `stderr.txt` to see which words were printed to each stream:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行前面的命令后，您可以检查`stdout.txt`和`stderr.txt`的内容，以查看哪些单词被打印到每个流：
- en: '[PRE23]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Words with even lengths will be in `stdout.txt`, and words with odd lengths
    will be in `stderr.txt`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 长度为偶数的单词将位于`stdout.txt`中，而长度为奇数的单词将位于`stderr.txt`中。
- en: Redirections and standard streams
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重定向和标准流
- en: Remember that `stdout` is the file descriptor 1 and `stderr` is the file descriptor
    2? Now, it’ll be coming together.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 记住`stdout`是文件描述符1，而`stderr`是文件描述符2吗？现在，它们将结合在一起。
- en: When we use `> stdout.txt`, we’re using a shell redirection operator. It redirects
    the standard output (`stdout`) of the command to the left of the operator to the
    file on the right. Since `stdout` is the standard output, the number 1 is commonly
    omitted, which is not true for `2>`. It specifically redirects the standard error
    (`stderr`).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`> stdout.txt`时，我们使用shell重定向运算符。它将命令的标准输出（`stdout`）重定向到运算符左侧的文件。由于`stdout`是标准输出，通常省略数字1，但`2>`不是这样。它专门重定向标准错误（`stderr`）。
- en: Note
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `stdout.txt` and `stderr.txt` files are where the standard output and standard
    error of the `go run` command will be written, respectively. If any one of these
    files doesn’t exist, it will be created; if it does exist, it will be overwritten.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdout.txt`和`stderr.txt`文件是`go run`命令的标准输出和标准错误将被写入的地方。如果这些文件中的任何一个不存在，它将被创建；如果它已经存在，它将被覆盖。'
- en: Making it testable
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使其可测试
- en: We don’t want to execute the program in the terminal to ensure the program still
    works in every little change. In that regard, we want to add automated tests.
    Let’s refactor the code to write tests.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望在终端中执行程序以确保程序在每次小变化后仍然工作。在这方面，我们想要添加自动化测试。让我们重构代码以编写测试。
- en: Moving the core logic
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动核心理念
- en: 'Move the core logic of checking word lengths and printing results to a separate
    function named `app`. This makes the code more organized and easier to test:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 将检查单词长度和打印结果的核心理念移动到名为`app`的单独函数中。这使得代码更加组织化，并且更容易测试：
- en: '[PRE24]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Introducing a flexible configuration
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引入灵活的配置
- en: 'Add a `CliConfig` struct to hold configuration values for the CLI. This provides
    flexibility for future modifications. For now, we are interested in making the
    standard streams easy to change for the tests:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`CliConfig`结构体来保存CLI的配置值。这为未来的修改提供了灵活性。目前，我们感兴趣的是使标准流易于更改以进行测试：
- en: '[PRE25]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Functional Options
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 功能选项
- en: Functional Options is a design pattern in Go that allows for flexible and clean
    configuration of objects. It’s especially useful when an object has many optional
    configurations.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 功能选项是Go中的一个设计模式，它允许灵活且干净地配置对象。当对象有许多可选配置时，它特别有用。
- en: 'This pattern provides several benefits:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式提供了几个好处：
- en: 'Readability: It’s clear which options are being set without having to remember
    the order of parameters.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可读性：无需记住参数的顺序，就可以清楚地知道正在设置哪些选项。
- en: 'Extensibility: You can easily add new options without changing existing function
    signatures or calls.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性：你可以轻松地添加新选项，而无需更改现有的函数签名或调用。
- en: 'Safety: You can ensure that the object is always in a valid state after construction.
    You can easily provide default values in the constructor. If an option isn’t provided,
    the default is used.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性：你可以确保对象在构造后始终处于有效状态。你可以在构造函数中轻松提供默认值。如果没有提供选项，则使用默认值。
- en: 'In our program, we have two optional configurations: `outStream` and `errStream`.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序中，我们有两个可选配置：`outStream`和`errStream`。
- en: 'Instead of using a constructor with multiple parameters or a configuration
    struct, you can use functional options:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用功能选项而不是使用带有多个参数的构造函数或配置结构体：
- en: '[PRE26]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, you can have a constructor for the `CliConfig` struct that accepts these
    options:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以为`CliConfig`结构体提供一个接受这些选项的构造函数：
- en: '[PRE27]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With the preceding setup, creating a new `CliConfig` struct becomes intuitive
    and readable:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的设置中，创建新的`CliConfig`结构体变得直观且易于阅读：
- en: '[PRE28]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Updating the main function
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新主函数
- en: 'We can modify the `main` function to use the new `CliConfig` struct and the
    `app` function and to handle potential errors from `NewCliConfig`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改`main`函数以使用新的`CliConfig`结构体和`app`函数，并处理`NewCliConfig`的潜在错误：
- en: '[PRE29]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Testing
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试
- en: 'Let’s look at our test function and examine what we’re achieving with it:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的测试函数，并检查我们用它实现了什么：
- en: '[PRE30]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let’s break down the key components and steps of this test:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这个测试的关键组件和步骤：
- en: The `TestMainProgram` function is the test function that checks the behavior
    of the app function.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TestMainProgram`函数是检查`app`函数行为的测试函数。'
- en: Two `bytes.Buffer` variables, `stdoutBuf` and `stderrBuf`, are created. These
    buffers will capture the program’s standard output and standard error streams,
    respectively. This allows you to capture and examine the program’s output and
    error messages within the test.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了两个 `bytes.Buffer` 变量，`stdoutBuf` 和 `stderrBuf`。这些缓冲区将分别捕获程序的标准输出和标准错误流。这允许你在测试中捕获和检查程序的输出和错误消息。
- en: The `NewCliConfig` function is called to create a `CliConfig` configuration
    with custom output and error streams. The `WithOutStream` and `WithErrStream`
    options are used to set the output and error streams to the `stdoutBuf` and `stderrBuf`
    buffers, respectively. This is done so that the program’s output and errors are
    captured and can be checked within the test.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `NewCliConfig` 函数创建一个具有自定义输出和错误流的 `CliConfig` 配置。使用 `WithOutStream` 和 `WithErrStream`
    选项将输出和错误流分别设置为 `stdoutBuf` 和 `stderrBuf` 缓冲区。这样做是为了捕获程序的输出和错误，并在测试中进行检查。
- en: The `app` function is called with a list of words as input, and the custom `CliConfig`
    struct is provided as configuration. In this case, the words `"main"`, `"alex"`,
    `"golang"`, and `"error"` are passed as arguments to simulate the behavior of
    your program.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`app` 函数被调用，并传入一个单词列表作为输入，同时提供自定义的 `CliConfig` 结构体作为配置。在这种情况下，单词 `"main"`、`"alex"`、`"golang"`
    和 `"error"` 作为参数传递，以模拟程序的行为。'
- en: 'The test then checks various aspects of the program’s output and errors:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 测试随后检查程序输出和错误的各个方面：
- en: It checks if there is any output captured in `stdoutBuf`. If there is no output,
    it fails the test.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它检查 `stdoutBuf` 中是否有捕获的输出。如果没有输出，则测试失败。
- en: It checks if the expected output messages, such as `"word alex is even"` and
    `"word golang is even"`, are contained within the captured output. If any expected
    output is missing, it fails the test.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它检查预期的输出消息，例如 `"word alex is even"` 和 `"word golang is even"`，是否包含在捕获的输出中。如果任何预期的输出消息缺失，则测试失败。
- en: It checks if there are any errors captured in `stderrBuf`. If there are no errors,
    it fails the test.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它检查 `stderrBuf` 中是否有捕获的错误。如果没有错误，则测试失败。
- en: It checks if the expected error message, `"word error is odd"`, is contained
    within the captured errors. If the expected error is missing, it fails the test.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它检查预期的错误消息，即 `"word error is odd"`，是否包含在捕获的错误中。如果预期的错误消息缺失，则测试失败。
- en: 'We can run the test with the `go test` command, and a similar output will be
    displayed:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `go test` 命令运行测试，并将显示类似的输出：
- en: '[PRE31]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In summary, this unit test verifies if the `app` function correctly produces
    the expected output and error messages when given a specific set of words. It
    captures the program’s output and errors using `bytes.Buffer`, checks for the
    presence of expected messages, and reports test failures if any of the expected
    output or error messages are missing. This test helps ensure that the `app` function
    behaves as expected in different scenarios, avoiding manual testing using the
    terminal.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，这个单元测试验证了当给定的单词集合特定时，`app` 函数是否正确地产生了预期的输出和错误消息。它使用 `bytes.Buffer` 捕获程序的输出和错误，检查预期消息的存在，并在预期输出或错误消息缺失时报告测试失败。这个测试有助于确保
    `app` 函数在不同场景下的行为符合预期，避免了使用终端进行手动测试。
- en: 'We can now use our program with other Linux tools:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用我们的程序与其他 Linux 工具一起使用：
- en: '[PRE32]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This last command lists the contents of the current directory, passes each line
    of that listing as an argument to the `app` command, and then filters the output
    of the `app` command to display only lines containing the word “`even`”.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条命令列出当前目录的内容，将列表中的每一行作为 `app` 命令的参数传递，然后过滤 `app` 命令的输出，只显示包含单词 “`even`” 的行。
- en: Before we move forward, it would be helpful to have a summary of this chapter’s
    key concepts.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前，有一个关于本章关键概念的摘要将是有帮助的。
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Drawing from the analogy of traveling, we’ve seen how system calls act as passports,
    allowing processes to navigate the vast terrains of software execution. We’ve
    distinguished between user mode and kernel mode, emphasizing the privileges and
    restrictions associated with each. The chapter also sheds light on the challenges
    faced by the `syscall` package in Go, leading to its eventual deprecation in favor
    of the more maintainable `x/sys` package. Furthermore, throughout this chapter,
    we’ve successfully built a CLI application, harnessing the power of Go’s `os`
    and `x/sys` packages. We’ve seen firsthand how system calls can be integrated
    into practical software solutions, enabling direct interactions with the operating
    system. As you move forward, remember the best practices highlighted and the skills
    acquired, ensuring safe, efficient system-level programming and robust CLI tool
    creation in Go.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 从旅行的类比中，我们看到了系统调用如何充当护照，使进程能够在软件执行的广阔领域中导航。我们区分了用户模式和内核模式，强调了与每种模式相关的特权和限制。本章还揭示了Go中`syscall`包面临的挑战，导致其最终被更易于维护的`x/sys`包所取代。此外，在本章中，我们成功构建了一个CLI应用程序，利用了Go的`os`和`x/sys`包的力量。我们亲眼见证了系统调用如何被集成到实际软件解决方案中，从而实现与操作系统的直接交互。随着你继续前进，请记住所强调的最佳实践和所获得的技能，确保在Go中进行安全、高效的系统级编程和健壮的CLI工具创建。
- en: In the next chapter, we will explore the world of file and directory operations
    in Go, a vital skill set for any developer working with filesystems. Our primary
    emphasis will be identifying insecure permissions, determining directory sizes,
    and pinpointing duplicate files. These techniques hold significant importance
    for all developers who engage with filesystems, as they play a crucial role in
    upholding data integrity and safeguarding security within software applications.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索Go中的文件和目录操作的世界，这对于任何与文件系统打交道的开发者来说都是一项至关重要的技能集。我们的主要重点是识别不安全的权限、确定目录大小和定位重复文件。对于所有与文件系统打交道的开发者来说，这些技术具有重大意义，因为它们在维护数据完整性和保障软件应用中的安全性方面发挥着至关重要的作用。
