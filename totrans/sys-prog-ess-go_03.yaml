- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding System Calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will embark on a journey into the world of system calls,
    those fundamental interfaces that bridge user-level programs with the operating
    system kernel. Through relatable analogies and real-world parallels, we’ll demystify
    the intricate dance of software execution, highlighting the pivotal roles of the
    kernel, user mode, and kernel mode.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding system calls and their interaction with the operating system is
    crucial for any software developer aiming to craft efficient and robust applications.
    In the broader context of this book, this chapter lays the foundation for subsequent
    discussions on advanced OS interactions and system-level programming. Moreover,
    in the real-world context, mastering these concepts equips developers with the
    tools to optimize software performance, troubleshoot issues at the system level,
    and harness the full potential of the operating system’s capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to system calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `syscall` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A closer look at the `os` and `x/sys` packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everyday system calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing and testing a **command-line interface** (**CLI**) program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will not only have grasped the theoretical underpinnings
    of system calls but also gained hands-on experience by constructing a CLI application
    using Go.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find this chapter’s source code at [https://github.com/PacktPublishing/System-Programming-Essentials-with-Go/tree/main/ch3](https://github.com/PacktPublishing/System-Programming-Essentials-with-Go/tree/main/ch3).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to system calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: System calls, often called “syscalls,” are fundamental to an operating system’s
    interface. They are low-level functions provided by the operating system kernel
    that allow user-level processes to request services from the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: If you are new to the concept, some analogies could make understanding more
    effortless. Let’s correlate the idea with traveling.
  prefs: []
  type: TYPE_NORMAL
- en: User mode versus kernel mode
  prefs: []
  type: TYPE_NORMAL
- en: 'A processor (or CPU) has two modes of operation: user mode and kernel mode
    (also known as supervisor mode or privileged mode). These modes dictate the level
    of access and control that a program has over system resources. User mode is restricted
    and doesn’t allow direct access to certain critical system resources, while kernel
    mode has more privileges and can access these resources. Permission granted, proceed
    with caution'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to system calls, the kernel plays the role of a strict border
    control officer. System calls are like the passports we need to navigate the diverse
    landscapes of software execution. Think of the kernel as a heavily fortified international
    border checkpoint. Just as travelers need permission to enter a foreign land,
    our processes require approval to access the kernel’s resources. System calls
    serve as passports, allowing us to cross the border between user and kernel spaces.
  prefs: []
  type: TYPE_NORMAL
- en: The catalog of services and identification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Much like a traveler’s guidebook, the kernel offers a comprehensive catalog
    of services through the system call **application programming interface** (**API**).
    These services range from creating new processes to handling **input and output**
    (**I/O**) operations such as amenities and attractions in a foreign country.
  prefs: []
  type: TYPE_NORMAL
- en: A numerical code uniquely identifies each system call, like your passport number.
    However, this numbering system remains hidden from everyday use. Instead, we interact
    with system calls by their names, much like travelers identifying services and
    landmarks by their local names rather than their codes. For instance, an `open`
    system call might be identified by the number 5 in the kernel’s internal system
    call table. However, as programmers, we refer to this system call by its name,
    “`open`,” much like travelers identify places by their local names rather than
    their GPS coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The location of the system call table depends on the OS and the architecture,
    but if you are curious about these identifiers, you can visit a handcrafted table
    at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://filippo.io/linux-syscall-table/](https://filippo.io/linux-syscall-table/)'
  prefs: []
  type: TYPE_NORMAL
- en: Information exchange
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: System calls are not one-way transactions; they involve a careful exchange of
    information. Each system call comes with arguments that dictate what data needs
    to travel between user space (your process’s domain) and kernel space (the kernel’s
    realm). Picture it as a well-coordinated cross-border conversation, where information
    passes seamlessly between the two sides.
  prefs: []
  type: TYPE_NORMAL
- en: When you use the `write()` system call to save data to a file, you pass not
    only the data but also information about where to write it (for example, a file
    descriptor and a data buffer). This data exchange is like a conversation across
    borders, with data moving seamlessly between the user and kernel spaces.
  prefs: []
  type: TYPE_NORMAL
- en: The syscall package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We observe a consistent trend: the vast majority of functionalities we require
    are readily accessible within the standard library, a testament to its comprehensiveness
    and utility. However, there is a notable exception in this pattern – the `syscall`
    package.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The package has been a foundation for interfacing with system calls and constants
    across various architectures and operating systems. However, over time, several
    issues have emerged that led to its deprecation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`syscall` was like that overstuffed closet you promise to clean out... someday.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing limitations**: A significant portion of the package lacks explicit
    tests. Moreover, cross-platform testing is unfeasible due to the package’s design.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`syscall` package set a record by becoming one of the least maintained, tested,
    and documented packages in the standard repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`syscall` package, with its unique variations for each system, is like a mystery
    wrapped in an enigma for developers. While one would hope for clarity, the `godoc`
    tool only offers a sneak peek, very similar to a movie trailer showcasing just
    the highlights. This selective display, tailored to its native environment, combined
    with an overarching lack of documentation, turns understanding and effectively
    using the package into a challenging endeavor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`syscall` package often feels like it’s in a relentless chase, something like
    pursuing a unicorn. Operating systems, with their constant evolution, present
    a challenge that’s beyond the Go team’s control. For instance, shifts in FreeBSD
    have impacted the package’s compatibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To address these concerns, the Go team proposed the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`syscall` package would be frozen, meaning no further changes would be made
    to it. This includes not updating it even if there are changes in the operating
    systems it references.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x/sys` ([https://pkg.go.dev/golang.org/x/sys](https://pkg.go.dev/golang.org/x/sys)),
    was created to replace the `syscall` package. This new package is easier to maintain,
    document, and use for cross-platform development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Deprecation: While the `syscall` package would continue to exist and function,
    all new public development was shifted to `x/sys`. The documentation for the `syscall`
    package would guide users toward this new repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In essence, while the `syscall` package served its purpose for a time, the challenges
    it posed in terms of maintenance, documentation, and compatibility necessitated
    its deprecation in favor of a more structured and maintainable approach with `x/sys`.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the decision, there is a post by Rob Pike explaining
    the decision ([https://go.googlesource.com/proposal/+/refs/heads/master/design/freeze-syscall.md](https://go.googlesource.com/proposal/+/refs/heads/master/design/freeze-syscall.md)).
  prefs: []
  type: TYPE_NORMAL
- en: A closer look at the os and x/sys packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we can see in the Go documentation regarding the `x/sys` package:'
  prefs: []
  type: TYPE_NORMAL
- en: “*The primary use of x/sys is inside other packages that provide a more portable
    interface to the system, such as “os”, “time”* *and “net”.*
  prefs: []
  type: TYPE_NORMAL
- en: '*Use those packages rather than this one if you can. For details of the functions
    and data types in this package consult the manuals for the appropriate operating
    system. These calls return err == nil to indicate success; otherwise err is an
    operating system error describing the failure. On most systems, that error has*
    *type syscall.Errno.*”'
  prefs: []
  type: TYPE_NORMAL
- en: x/sys package – low-level system calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `x/sys` package in Go provides access to low-level system calls. It’s typically
    used when interacting directly with the operating system is necessary or for platform-specific
    operations. It’s important to exercise caution when using `x/sys`, as incorrect
    usage can lead to system instability or security issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this package, you should download it using the Go tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let’s explore what this package could offer.
  prefs: []
  type: TYPE_NORMAL
- en: System calls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are some system call invocations and constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '`unix.Syscall()`: Call a specific system call with arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unix.Syscall6()`: Similar to `Syscall()` but for system calls with six arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unix.SYS_*`: Constants representing various system calls (for example, `unix.SYS_READ`,
    `unix.SYS_WRITE`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, the next two snippets result in the same outcome, printing `"``Hello
    World!"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `fmt` package, you get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And by using the `x/sys` package, you get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Things can get complex very easily if we decide to use a low-level abstraction
    instead of the `fmt` package.
  prefs: []
  type: TYPE_NORMAL
- en: We can continue exploring the package API by category.
  prefs: []
  type: TYPE_NORMAL
- en: File operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These functions let us interact with general files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`unix.Create()`: Create a new file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unix.Unlink()`: Remove a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unix.Mkdir()`, `unix.Rmdir()`, and `unix.Link()`: Create and remove directories
    and links'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unix.Getdents()`: Get directory entries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are two examples of functions that interact with OS signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '`unix.Kill()`: Send a kill signal to a process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unix.SIGINT`: Interrupt signal (commonly known as *Ctrl* + *C*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User and group management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can manage users and groups using the following calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '`syscall.Setuid()`, `syscall.Setgid()`, `syscall.Setgroups()`: Set user and
    group IDs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can analyze some statistics on memory and swap usage and the load average
    using the `Sysinfo()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`syscall.Sysinfo()`: Get system information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File descriptors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While it’s not an everyday task, we can also interact with file descriptors
    directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '`unix.FcntlInt()`: Perform various operations on file descriptors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unix.Dup2()`: Duplicate a file descriptor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory-mapped files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Mmap is an acronym for memory-mapped files. It provides a mechanism for reading
    and writing files without relying on system calls. When using `Mmap()`, the operating
    system allocates a section of a program’s virtual address space, which is directly
    “mapped” to a corresponding file section. If the program accesses data from that
    part of the address space, it will retrieve the data stored in the related part
    of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`syscall.Mmap()`: Map files or devices into memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating system functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `os` package in Go provides a rich set of functions for interacting with
    the operating system. It’s divided into several subpackages, each focusing on
    a specific aspect of OS functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are file and directory operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`os.Create()`: Creates or opens a file for writing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`os.Mkdir()` and `os.MkdirAll()`: Create directories'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`os.Remove()` and `os.RemoveAll()`: Remove files and directories'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`os.Stat()`: Get file or directory information (metadata)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`os.IsExist()`, `os.IsNotExist()`, and `os.IsPermission()`: Check file/directory
    existence or permission errors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`os.Open()`: Open a file for reading'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`os.Rename()`: Rename or move a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`os.Truncate()`: Resize a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`os.Getwd()`: Get the current working directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`os.Chdir()`: Change the current working directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`os.Args`: Command-line arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`os.Getenv()`: Get environment variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`os.Setenv()`: Set environment variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are for processes and signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '`os.Getpid()`: Get the current process ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`os.Getppid()`: Get the parent process ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`os.Getuid()` and `os.Getgid()`: Get the user and group IDs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`os.Geteuid()` and `os.Getegid()`: Get the effective user and group IDs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`os.StartProcess()`: Start a new process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`os.Exit()`: Exit the current process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`os.Signal`: Represents signals (for example, `SIGINT`, `SIGTERM`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`os/signal.Notify()`: Notify on signal reception'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `os` package allows you to create and manipulate processes. You can start
    new processes, obtain information about the current process, and manipulate its
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The main parts of this program are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`exec.Command("ls", "-l")`: This creates a new command to run the `ls` command
    with the `-``l` flag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd.Stdout = os.Stdout`: This redirects the standard output of the `ls` command
    to the standard output of the main program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd.Stderr = os.Stderr`: Similarly, this redirects the standard error of the
    `ls` command to the standard error of the main program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`err := cmd.Run()`: This runs the `ls` command. If there’s an error during
    its execution, it will be stored in the `err` variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`os.Getpid()`: This retrieves the process ID of the current process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the `os` package provides a high-level interface for many system-related
    tasks, the `syscall`(and `x/sys`) package allows you to make lower-level system
    calls directly. This can be useful when you need fine-grained control over system
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: Portability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While `x/sys` is the go-to package to make syscalls, you must explicitly choose
    between Unix and Windows. The recommended way to interact with the operating system
    is to use the `os` package. When you build your program to a determined OS and
    architecture, the compiler will do the heavy lifting to use the adequate syscall
    version.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, while in Windows, you need to call a function with the following
    signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The signature doesn’t even have the same name for Unix-based systems, as we
    can see in the next snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid this “signature Tetris,” we could use the function from the `os` package
    with the same semantics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: (Yes! The signature is the same as the Unix version.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The primary use of `syscall` ([https://pkg.go.dev/syscall](https://pkg.go.dev/syscall))
    is inside other packages that provide a more portable interface to the system,
    such as `os`, `time`, and `net`.
  prefs: []
  type: TYPE_NORMAL
- en: From now on, we leverage the `os` package, and only in exceptional cases will
    we directly call the `x/sys` package.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a system programmer using the `os` and `x/sys` packages in Go, consider
    the following best practices:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `os` package for most tasks, as it provides a safer and more portable
    interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reserve the `x/sys` package for situations where fine-grained control over system
    calls is necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pay attention to platform-specific constants and types when using the `x/sys`
    package to ensure cross-platform compatibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle errors returned by system calls and `os` package functions diligently
    to maintain the reliability of your applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test your system-level code on different operating systems to verify its behavior
    in diverse environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s explore how we can trace what is happening in the commands we do in the
    terminal on a daily basis.
  prefs: []
  type: TYPE_NORMAL
- en: Everyday system calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Several syscalls are happening in our programs every time under our noses. We
    can trace these calls using the `strace` tool.
  prefs: []
  type: TYPE_NORMAL
- en: Tracing system calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `strace` tool might not come pre-installed on all Linux distributions, but
    it’s available in most official repositories. Here’s how to install it on some
    major distributions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Debian (using APT): Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Red Hat family (using DNF** **and YUM)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'When using `yum`, run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When using `dnf`, run this command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Arch Linux (using Pacman)**: Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Basic strace usage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The basic way to use `strace` is by calling the `strace` utility followed by
    the program’s name; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce an output showing system calls, their arguments, and return
    values. For instance, the `execve` system call ([https://man7.org/linux/man-pages/man2/execve.2.html](https://man7.org/linux/man-pages/man2/execve.2.html))
    might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tracing specific system calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you only want to trace specific system calls, use the `-e` flag followed
    by the system call’s name. For example, to trace `execve` system calls for the
    `ls` command, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use our brand-new tool from our toolset to trace syscalls in our
    programs. Consider the following simple `main.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This program needs to interact with a hardware device by writing data to the
    standard output, our console. To gain access to the console and perform this operation,
    the program requires permission from the kernel. This permission is obtained through
    a system call, like requesting access to a specific functionality, such as sending
    messages to the console, which allows your program to utilize the console’s resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `unix.Write` function is being called with two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The first argument is `1`, which is the file descriptor for standard output
    (`stdout`) in Unix-like systems. This means the program will write data to the
    console or terminal where the program is run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second argument is `[]byte{"Hello, World!"}`, which is a byte slice containing
    the `"Hello,` `World!"` string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We build the program calling the binary as `app`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We then run with `strace` tool, filtering the `write` syscall:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, it’s time to explore a program that interacts with the OS. Let’s make and
    test our very first CLI application.
  prefs: []
  type: TYPE_NORMAL
- en: Developing and testing a CLI program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CLI applications are essential tools in software development, system administration,
    and automation. When creating CLI applications, interacting with `stdin` (standard
    input), `stderr` (standard error), and `stdout` (standard output) plays a crucial
    role in ensuring their effectiveness and user-friendliness.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll explore why these standard streams are indispensable
    components of CLI development.
  prefs: []
  type: TYPE_NORMAL
- en: Standard streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concept of `stdin`, `stderr`, and `stdout` is deeply rooted in the Unix
    philosophy of “*everything is a file*.”(We will explore this more in [Chapter
    4](B21662_04.xhtml#_idTextAnchor110), File and Directory Operations.) These standardized
    streams provide a consistent way for CLI applications to communicate with users
    and other processes. Users have come to expect CLI tools to work in a certain
    way, and adhering to these conventions enhances the predictability and user-friendliness
    of your application.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most powerful aspects of CLI applications is their ability to work
    together seamlessly through pipelines (see more in [Chapter 6](B21662_06.xhtml#_idTextAnchor145),
    Pipes). In Unix-like systems, you can chain multiple CLI tools together, with
    each tool processing data from the previous one’s `stdout`. This model allows
    for the efficient processing of data and complex task automation. When your application
    interacts with `stdout`, it becomes a valuable building block in these pipelines,
    enabling users to create sophisticated workflows effortlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Input flexibility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By utilizing `stdin`, your CLI application can accept input from various sources.
    Users can provide input interactively via the keyboard, or they can pipe data
    from other processes directly into your tool. Additionally, your application can
    read input from files, allowing users to process data stored in various formats
    and locations. This flexibility makes your application adaptable to a wide range
    of usage scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Output flexibility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similarly, by using `stdout`, your CLI application can provide output in a format
    that can be easily redirected, saved to files, or used as input for other processes.
    This adaptability ensures that users can leverage your tool’s output in diverse
    ways, promoting efficiency and versatility in their workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`stderr` is specifically designed for error messages. Separating error messages
    from regular program output simplifies error detection and handling for users.
    When your application encounters issues, `stderr` provides a designated channel
    for conveying error information. This separation makes it easier for users to
    identify and address problems promptly.'
  prefs: []
  type: TYPE_NORMAL
- en: Cross-platform compatibility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The beauty of `stdin`, `stderr`, and `stdout` lies in their platform-agnostic
    nature. These streams work consistently across different operating systems and
    environments. Consequently, our CLI applications can maintain portability and
    compatibility, ensuring that they function reliably on various systems without
    modification.
  prefs: []
  type: TYPE_NORMAL
- en: Testing and debugging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By following the convention of using `stderr` for error output, you make testing
    and debugging more straightforward. Users can easily capture and analyze error
    messages separately from the program’s standard output. This separation aids in
    pinpointing and resolving issues during development and in production environments.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many CLI applications utilize `stderr` for logging error messages. This practice
    enables users to monitor the application’s behavior and troubleshoot problems
    effectively. Proper logging enhances the maintainability of your application and
    contributes to its overall robustness.
  prefs: []
  type: TYPE_NORMAL
- en: User experience
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consistency in using `stdin`, `stderr`, and `stdout` contributes to a positive
    user experience. Users are familiar with these streams and expect CLI applications
    to behave in a standard way. This familiarity reduces the learning curve for new
    users and increases overall user satisfaction.
  prefs: []
  type: TYPE_NORMAL
- en: Compliance with conventions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Throughout the software development and scripting communities, many best practices
    and established conventions assume the use of `stdin`, `stderr`, and `stdout`.
    Adhering to these conventions makes it easier for your CLI application to integrate
    into existing workflows and practices, saving time and effort for both developers
    and users.
  prefs: []
  type: TYPE_NORMAL
- en: File descriptors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do you ever wonder how your computer manages to juggle all those open files,
    network connections, and devices without breaking a digital sweat? Well, there’s
    a little-known secret that keeps everything running smoothly: file descriptors.
    These unassuming numerical IDs are the unsung heroes behind your computer’s ability
    to handle files, directories, devices, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: In formal terms, a file descriptor is an abstract representation or numeric
    identifier the operating system uses to uniquely identify and manage open files,
    sockets, pipes, and other I/O resources. It’s a way for programs to refer to open
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'File descriptors can represent different types of resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Regular files: These are files on disk containing data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Directories: Representations of directories on disk'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Character devices: Provide access to devices that work with streams of characters,
    such as keyboards and serial ports'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Block devices: Used for accessing block-oriented devices, such as hard drives'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sockets: For network communication between processes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pipes: Used for inter-process communication (IPC)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a shell starts a process, it usually inherits three open file descriptors.
    Descriptor 0 represents the standard input, the file providing input to the process.
    Descriptor 1 represents the standard output, the file where the process writes
    its output. Descriptor 2 represents the standard error, the file where the process
    writes error messages and notifications regarding abnormal conditions. These descriptors
    are typically connected to the terminal in interactive shells or programs. In
    the `os` package, `stdin`, `stdout`, and `stderr` are open files pointing to the
    standard input, output, and error descriptors ([https://cs.opensource.google/go/go/+/refs/tags/go1.21.1:src/os/file.go;l=64](https://cs.opensource.google/go/go/+/refs/tags/go1.21.1:src/os/file.go;l=64)).
  prefs: []
  type: TYPE_NORMAL
- en: In summary, `stdin`, `stderr`, and `stdout` are integral to the development
    of effective, user-friendly, and interoperable CLI applications. These standardized
    streams provide a versatile, flexible, and reliable means of handling input, output,
    and errors. By embracing these streams, our CLI applications become more accessible
    and valuable to users, enhancing their ability to automate tasks, process data,
    and achieve their goals efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a CLI application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s create and test our first CLI application using the best practices for
    standard streams.
  prefs: []
  type: TYPE_NORMAL
- en: 'This program will capture all arguments given (words from now on). When the
    word length is even, it will send to `stdout`; otherwise, it will send to `stderr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first line retrieves the command-line arguments passed to the program, excluding
    the program name itself. The program name is always the first element in the `os.Args`
    slice (`os.Args[0]`), so by using the `[1:]` slice, it gets all the arguments
    after the program.
  prefs: []
  type: TYPE_NORMAL
- en: The conditional checks if the length of the `words` slice is zero, meaning no
    command-line arguments were provided after the program name. If no arguments were
    provided, it prints a `"No words provided."` error message to the standard error
    stream using `fmt.Fprintln(os.Stderr, "No` `words provided.")`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It then exits the program with a nonzero exit code (`os.Exit(1)`). In Unix-like
    operating systems, an exit code of 0 typically indicates success, while a nonzero
    exit code indicates an error. In this case, the program is signaling that it encountered
    an error due to the absence of command-line arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This code iterates over each word in the `words` slice, checks if its length
    is even or odd, and then prints a corresponding message to either the standard
    output or standard error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main.go` file will be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To see our program working, we should pass arguments, as in the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To see which words are printed to `stdout` (standard output) and which are
    printed to `stderr` (standard error), you can use redirection in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the preceding command, you can inspect the contents of `stdout.txt`
    and `stderr.txt` to see which words were printed to each stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Words with even lengths will be in `stdout.txt`, and words with odd lengths
    will be in `stderr.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: Redirections and standard streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember that `stdout` is the file descriptor 1 and `stderr` is the file descriptor
    2? Now, it’ll be coming together.
  prefs: []
  type: TYPE_NORMAL
- en: When we use `> stdout.txt`, we’re using a shell redirection operator. It redirects
    the standard output (`stdout`) of the command to the left of the operator to the
    file on the right. Since `stdout` is the standard output, the number 1 is commonly
    omitted, which is not true for `2>`. It specifically redirects the standard error
    (`stderr`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `stdout.txt` and `stderr.txt` files are where the standard output and standard
    error of the `go run` command will be written, respectively. If any one of these
    files doesn’t exist, it will be created; if it does exist, it will be overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: Making it testable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We don’t want to execute the program in the terminal to ensure the program still
    works in every little change. In that regard, we want to add automated tests.
    Let’s refactor the code to write tests.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the core logic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Move the core logic of checking word lengths and printing results to a separate
    function named `app`. This makes the code more organized and easier to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Introducing a flexible configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add a `CliConfig` struct to hold configuration values for the CLI. This provides
    flexibility for future modifications. For now, we are interested in making the
    standard streams easy to change for the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Functional Options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functional Options is a design pattern in Go that allows for flexible and clean
    configuration of objects. It’s especially useful when an object has many optional
    configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern provides several benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Readability: It’s clear which options are being set without having to remember
    the order of parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Extensibility: You can easily add new options without changing existing function
    signatures or calls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Safety: You can ensure that the object is always in a valid state after construction.
    You can easily provide default values in the constructor. If an option isn’t provided,
    the default is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our program, we have two optional configurations: `outStream` and `errStream`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using a constructor with multiple parameters or a configuration
    struct, you can use functional options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can have a constructor for the `CliConfig` struct that accepts these
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding setup, creating a new `CliConfig` struct becomes intuitive
    and readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Updating the main function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can modify the `main` function to use the new `CliConfig` struct and the
    `app` function and to handle potential errors from `NewCliConfig`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look at our test function and examine what we’re achieving with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down the key components and steps of this test:'
  prefs: []
  type: TYPE_NORMAL
- en: The `TestMainProgram` function is the test function that checks the behavior
    of the app function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Two `bytes.Buffer` variables, `stdoutBuf` and `stderrBuf`, are created. These
    buffers will capture the program’s standard output and standard error streams,
    respectively. This allows you to capture and examine the program’s output and
    error messages within the test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `NewCliConfig` function is called to create a `CliConfig` configuration
    with custom output and error streams. The `WithOutStream` and `WithErrStream`
    options are used to set the output and error streams to the `stdoutBuf` and `stderrBuf`
    buffers, respectively. This is done so that the program’s output and errors are
    captured and can be checked within the test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `app` function is called with a list of words as input, and the custom `CliConfig`
    struct is provided as configuration. In this case, the words `"main"`, `"alex"`,
    `"golang"`, and `"error"` are passed as arguments to simulate the behavior of
    your program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The test then checks various aspects of the program’s output and errors:'
  prefs: []
  type: TYPE_NORMAL
- en: It checks if there is any output captured in `stdoutBuf`. If there is no output,
    it fails the test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It checks if the expected output messages, such as `"word alex is even"` and
    `"word golang is even"`, are contained within the captured output. If any expected
    output is missing, it fails the test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It checks if there are any errors captured in `stderrBuf`. If there are no errors,
    it fails the test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It checks if the expected error message, `"word error is odd"`, is contained
    within the captured errors. If the expected error is missing, it fails the test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can run the test with the `go test` command, and a similar output will be
    displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In summary, this unit test verifies if the `app` function correctly produces
    the expected output and error messages when given a specific set of words. It
    captures the program’s output and errors using `bytes.Buffer`, checks for the
    presence of expected messages, and reports test failures if any of the expected
    output or error messages are missing. This test helps ensure that the `app` function
    behaves as expected in different scenarios, avoiding manual testing using the
    terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use our program with other Linux tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This last command lists the contents of the current directory, passes each line
    of that listing as an argument to the `app` command, and then filters the output
    of the `app` command to display only lines containing the word “`even`”.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move forward, it would be helpful to have a summary of this chapter’s
    key concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drawing from the analogy of traveling, we’ve seen how system calls act as passports,
    allowing processes to navigate the vast terrains of software execution. We’ve
    distinguished between user mode and kernel mode, emphasizing the privileges and
    restrictions associated with each. The chapter also sheds light on the challenges
    faced by the `syscall` package in Go, leading to its eventual deprecation in favor
    of the more maintainable `x/sys` package. Furthermore, throughout this chapter,
    we’ve successfully built a CLI application, harnessing the power of Go’s `os`
    and `x/sys` packages. We’ve seen firsthand how system calls can be integrated
    into practical software solutions, enabling direct interactions with the operating
    system. As you move forward, remember the best practices highlighted and the skills
    acquired, ensuring safe, efficient system-level programming and robust CLI tool
    creation in Go.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the world of file and directory operations
    in Go, a vital skill set for any developer working with filesystems. Our primary
    emphasis will be identifying insecure permissions, determining directory sizes,
    and pinpointing duplicate files. These techniques hold significant importance
    for all developers who engage with filesystems, as they play a crucial role in
    upholding data integrity and safeguarding security within software applications.
  prefs: []
  type: TYPE_NORMAL
