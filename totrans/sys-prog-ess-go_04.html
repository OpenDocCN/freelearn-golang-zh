<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer012">
			<h1 id="_idParaDest-74" class="chapter-number"><a id="_idTextAnchor110"/>4</h1>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor111"/>File and Directory Operations</h1>
			<p>In this chapter, we will learn how to work with files and folders using Go. We will explore many valuable topics including checking file and folder permissions, working with links, and finding the size <span class="No-Break">of folders.</span></p>
			<p>In this chapter, you will do hands-on activities. You will write and run code that works with files and folders. This way, you will learn practical skills for real-world <span class="No-Break">programming tasks.</span></p>
			<p>By the end of this chapter, you will know how to manage files and folders in Go. You can check and fix file and folder permissions, find and manage files and folders, and do many other practical tasks. This knowledge will help you create secure and effective file-related programs <span class="No-Break">in Go.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Identifying unsafe file and <span class="No-Break">directory permissions</span></li>
				<li>Scanning directories <span class="No-Break">in Go</span></li>
				<li>Symbolic links and <span class="No-Break">unlinking files</span></li>
				<li>Calculating <span class="No-Break">directory size</span></li>
				<li>Finding <span class="No-Break">duplicate files</span></li>
				<li>Optimizing <span class="No-Break">filesystem operations</span></li>
			</ul>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor112"/>Technical requirements</h1>
			<p>You can find this chapter source code <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/System-Programming-Essentials-with-Go/tree/main/ch4"><span class="No-Break">https://github.com/PacktPublishing/System-Programming-Essentials-with-Go/tree/main/ch4</span></a></p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor113"/>Identifying unsafe file and directory permissions</h1>
			<p>Retrieving <a id="_idIndexMarker161"/>information about a file or directory is a common task in programming and Go provides a platform-independent way to perform this operation. The <strong class="source-inline">os.Stat</strong> function<a id="_idIndexMarker162"/> is an essential part of the <strong class="source-inline">os</strong> package, which acts as an interface to operating system functionality. When called, the <strong class="source-inline">os.Stat</strong> function returns a <strong class="source-inline">FileInfo</strong> interface and an error. The <strong class="source-inline">FileInfo</strong> interface contains various file metadata, such as its name, size, permissions, and <span class="No-Break">modification times.</span></p>
			<p>Here’s the signature of the <span class="No-Break"><strong class="source-inline">os.Stat</strong></span><span class="No-Break"> function:</span></p>
			<pre class="console">
func Stat(name string) (FileInfo, error)</pre>			<p>The name parameter is the path to the file or directory you want to obtain <span class="No-Break">information about.</span></p>
			<p>Let’s discover how we could use <strong class="source-inline">os.Stat</strong> to get information about <span class="No-Break">a file:</span></p>
			<pre class="source-code">
package main
import (
     "fmt"
     "os"
)
func main() {
     info, err := os.Stat("example.txt")
     if err != nil {
          panic(err)
     }
     fmt.Printf("File name: %s\n", info.Name())
     fmt.Printf("File size: %d\n", info.Size())
     fmt.Printf("File permissions: %s\n", info.Mode())
     fmt.Printf("Last modified: %s\n", info.ModTime())
}</pre>			<p>In this example, in the main function, we<a id="_idIndexMarker163"/> call <strong class="source-inline">os.Stat</strong> with the path to a file named <strong class="source-inline">example.txt</strong>. When <strong class="source-inline">os.Stat</strong> returns an error, we “panic” the error and exit the program. Otherwise, we use the <strong class="source-inline">FileInfo</strong> methods (<strong class="source-inline">Name</strong>, <strong class="source-inline">Size</strong>, <strong class="source-inline">Mode</strong>, and <strong class="source-inline">ModTime</strong>) to print out some information about <span class="No-Break">the file.</span></p>
			<p>It’s <a id="_idIndexMarker164"/>important to check the error returned by <strong class="source-inline">os.Stat</strong>. If the error is non-nil, it’s likely because the file doesn’t exist or there’s a permission problem. A common way to check for a non-existent file is to use the <span class="No-Break"><strong class="source-inline">os.IsNotExist</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
info, err := os.Stat("example.txt")
if err != nil {
     if os.IsNotExist(err) {
          fmt.Println("File does not exist")
     } else {
          panic(err)
     }
}</pre>			<p>In this code, we first call the <strong class="source-inline">os.Stat</strong> function to check the status of a file. If an error occurs during this operation, we check whether the error is because the file doesn’t exist by using <a id="_idIndexMarker165"/>the <strong class="source-inline">os.IsNotExist</strong> function. If it is due to the file not existing, we display a message. However, if the error is for some other reason, we panic it and terminate the program. Once we know how to read file metadata, we can start to explore and understand files and <span class="No-Break">their permissions.</span></p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor114"/>Files and permissions</h2>
			<p>In Linux, files<a id="_idIndexMarker166"/> are categorized into various types, each<a id="_idIndexMarker167"/> serving a unique purpose. Here’s a rundown of common Linux file types along with their correlation to the <strong class="source-inline">FileMode</strong> bits returned from <span class="No-Break"><strong class="source-inline">FileInfo.Mode()</strong></span><span class="No-Break"> call.</span></p>
			<h3>Regular files</h3>
			<p>Regular files contain <a id="_idIndexMarker168"/>data such as text, images, or programs. They are denoted by <strong class="source-inline">-</strong> in the first character of the file listing. In Go, a regular file is represented by the absence of other file-type bits. You can check whether a file is a regular file using the <strong class="source-inline">IsRegular</strong> method <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">FileMode</strong></span><span class="No-Break">.</span></p>
			<h3>Directories</h3>
			<p>Directories hold <a id="_idIndexMarker169"/>other files and directories. They are denoted by <strong class="source-inline">d</strong> in the first character of the file listing. The <strong class="source-inline">os.ModeDir</strong> bit represents a directory. You can check whether a file is a directory using the <span class="No-Break"><strong class="source-inline">IsDir()</strong></span><span class="No-Break"> method.</span></p>
			<h3>Symbolic links</h3>
			<p>Symbolic links are <a id="_idIndexMarker170"/>pointers to other files. They are denoted by <strong class="source-inline">l</strong> in the first character of the file listing. The <strong class="source-inline">os.ModeSymlink</strong> bit represents a symbolic link. Unfortunately, <strong class="source-inline">FileMode</strong> in Go does not directly expose a method to check for symbolic links, but we can check whether <strong class="source-inline">FileMode&amp;os.ModeSymlink</strong> <span class="No-Break">is non-zero.</span></p>
			<h3>Named pipes (FIFOs)</h3>
			<p>Named pipes <a id="_idIndexMarker171"/>are mechanisms for inter-process communication, denoted by <strong class="source-inline">p</strong> in the first character of the file listing. The <strong class="source-inline">os.ModeNamedPipe</strong> bit represents a <span class="No-Break">named pipe.</span></p>
			<h3>Character devices</h3>
			<p>Character devices <a id="_idIndexMarker172"/>provide unbuffered, direct access to hardware devices, and are denoted by <strong class="source-inline">c</strong> in the first character of the file listing. The <strong class="source-inline">os.ModeCharDevice</strong> bit represents a <span class="No-Break">character device.</span></p>
			<h3>Block devices</h3>
			<p>Block devices<a id="_idIndexMarker173"/> provide buffered access to hardware devices and are denoted by <strong class="source-inline">b</strong> in the first character of the file listing. Go does not have a direct <strong class="source-inline">FileMode</strong> bit for block devices. However, you might still be able to work with block devices using the <strong class="source-inline">os</strong> package’s <span class="No-Break">file operations.</span></p>
			<h3>Sockets</h3>
			<p>Sockets<a id="_idIndexMarker174"/> are endpoints for communication, denoted by <strong class="source-inline">s</strong> in the first character of the file listing. The <strong class="source-inline">os.ModeSocket</strong> bit represents <span class="No-Break">a socket.</span></p>
			<p>The <strong class="source-inline">FileMode</strong> type in Go encapsulates these bits and provides methods and constants for working with file types and permissions, making it easier to perform file operations in a <span class="No-Break">cross-platform way.</span></p>
			<p>In Linux, the permissions system is a crucial aspect of file and directory security. It determines who can access, modify, or execute files and directories. Permissions are represented by a combination of read (<strong class="source-inline">r</strong>), write (<strong class="source-inline">w</strong>), and execute (<strong class="source-inline">x</strong>) permissions for three categories of users: owner, group, <span class="No-Break">and others.</span></p>
			<p>Let’s refresh what these <span class="No-Break">permissions represent:</span></p>
			<ul>
				<li><strong class="bold">Read (r)</strong>: Allows reading or<a id="_idIndexMarker175"/> viewing the file’s contents or listing a <span class="No-Break">directory’s contents</span></li>
				<li><strong class="bold">Write (w)</strong>: Allows <a id="_idIndexMarker176"/>modifying or deleting a file’s contents or adding/removing files in <span class="No-Break">a directory</span></li>
				<li><strong class="bold">Execute (x)</strong>: Allows executing <a id="_idIndexMarker177"/>a file or accessing the contents of a directory (if you have execute permission on the <span class="No-Break">directory itself)</span></li>
			</ul>
			<p>Linux file permissions are typically displayed in the form of a 9-character string, such as <strong class="source-inline">rwxr-xr—</strong>, where the first three characters represent permissions for the owner, the next three for the group, and the last three <span class="No-Break">for others.</span></p>
			<p>When we combine the file type and its permissions, we form the 10-character string that the <strong class="source-inline">ls -l</strong> command returns in the first column of the <span class="No-Break">following example:</span></p>
			<pre class="console">
-rw-r--r-- 1 user group  0 Oct 25 10:00 file1.txt
-rw-r--r-- 1 user group  0 Oct 25 10:01 file2.txt
drwxr-xr-x 2 user group 4096 Oct 25 10:02 directory1</pre>			<p>If we take a closer look at <strong class="source-inline">directory1</strong>, we can determine <span class="No-Break">the following:</span></p>
			<ul>
				<li>It’s a directory because of the first <span class="No-Break">letter </span><span class="No-Break"><strong class="source-inline">d</strong></span></li>
				<li>The owner has permission to read, write, and execute, given the first <span class="No-Break">triplet </span><span class="No-Break"><strong class="source-inline">rwx</strong></span></li>
				<li>The group and the user can read and execute, given the same <span class="No-Break">string </span><span class="No-Break"><strong class="source-inline">r-x</strong></span></li>
			</ul>
			<p>To check file<a id="_idIndexMarker178"/> permissions in Go, you can use the <strong class="source-inline">os</strong> package to inspect file and directory properties. Here’s a simple example of how to check file permissions <span class="No-Break">using Go:</span></p>
			<pre class="source-code">
package main
import (
    "fmt"
    "os"
)
func main() {
    // Stat the file to get its information
    fileInfo, err := os.Stat("example.txt")
    if err != nil {
         fmt.Println("Error:", err)
         return
    }
    // Get file permissions
    permissions := fileInfo.Mode().Perm()
    permissionString := fmt.Sprintf("%o", permissions)
    fmt.Printf("Permissions: %s\n", permissionString)
}</pre>			<p>In this example, we use the <strong class="source-inline">os.Stat</strong> to retrieve file information, and then we extract the permissions using <strong class="source-inline">fileInfo.Mode().Perm()</strong>. The <strong class="source-inline">Perm()</strong> method returns a <strong class="source-inline">os.FileMode</strong> value, which we format as an octal string <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">fmt.Sprintf</strong></span><span class="No-Break">.</span></p>
			<p>You may ask yourself, <em class="italic">why an </em><span class="No-Break"><em class="italic">octal string?</em></span></p>
			<p>Octal notation provides a compact and human-readable way to represent file permissions. The octal digit is the sum of the values for read (4), write (2), and execute (1). For example, <strong class="source-inline">rwx</strong> (read, write, execute) is 7 (4+2+1), <strong class="source-inline">r-x</strong> (read, no write, execute) is 5 (4+0+1), and <span class="No-Break">so on.</span></p>
			<p>So, for example, the<a id="_idIndexMarker179"/> permissions <strong class="source-inline">-rwxr-xr--</strong> can be succinctly represented as 755 <span class="No-Break">in octal.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The convention of using octal representation for permissions dates to the early days of Unix. Over the decades, this convention has been retained for consistency and compatibility with older scripts <span class="No-Break">and utilities.</span></p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor115"/>Scanning directories in Go</h1>
			<p>Go provides a robust and<a id="_idIndexMarker180"/> platform-independent way to work with file and directory paths, making it an excellent choice for building file-related applications. We will cover topics such as fil- path joining, cleaning, and traversal, along with some best practices for handling file <span class="No-Break">paths effectively.</span></p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor116"/>Understanding file paths</h2>
			<p>Before we dive into manipulating file paths in Go, it’s important to understand the basics. A file path is <a id="_idIndexMarker181"/>a string representation of a file or directory’s location within a filesystem. File paths typically consist of one or more directory names separated by a path separator, which varies between <span class="No-Break">operating systems.</span></p>
			<p>For example, on Unix-like systems (Linux, macOS), the path separator is <strong class="source-inline">/</strong>, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">/home/user/documents/myfile.txt</strong></span><span class="No-Break">.</span></p>
			<p>On Windows systems, the path separator is <strong class="source-inline">\</strong>, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">C:\Users\User\Documents\myfile.txt</strong></span><span class="No-Break">.</span></p>
			<p>Go provides a convenient way to work with file paths independently of the underlying operating system, ensuring <span class="No-Break">cross-platform compatibility.</span></p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor117"/>Using the path/filepath package</h2>
			<p>Go’s standard library includes <a id="_idIndexMarker182"/>the <strong class="source-inline">path/filepath</strong> package, which provides functions for manipulating file paths in a platform-independent manner. Let’s explore some common operations you can perform with <span class="No-Break">this package.</span></p>
			<h3>Joining file paths</h3>
			<p>To <a id="_idIndexMarker183"/>join multiple parts of a file path into a single, correctly formatted path, we can use <a id="_idIndexMarker184"/>the <strong class="source-inline">filepath.Join</strong> function. It takes any number of arguments, concatenates them with the appropriate path separator, and returns the resulting <span class="No-Break">file path:</span></p>
			<pre class="source-code">
package main
import (
     "fmt"
     "path/filepath"
)
func main() {
     dir := "/home/user"
     file := "document.txt"
     fullPath := filepath.Join(dir, file)
     fmt.Println("Full path:", fullPath)
}</pre>			<p>In this<a id="_idIndexMarker185"/> example, <strong class="source-inline">filepath.Join</strong> correctly handles the path separator based on the operating <a id="_idIndexMarker186"/>system. When we run this program, we should see <span class="No-Break">this output:</span></p>
			<pre class="console">
Full path: /home/user/document.txt</pre>			<h3>Cleaning file paths</h3>
			<p>File <a id="_idIndexMarker187"/>paths can become messy over time due to concatenation or user input. The <strong class="source-inline">filepath.Clean</strong> function<a id="_idIndexMarker188"/> helps clean up and simplify file paths by removing redundant separators and references to the current directory (<strong class="source-inline">.</strong>) and the parent <span class="No-Break">directory (</span><span class="No-Break"><strong class="source-inline">..</strong></span><span class="No-Break">).</span></p>
			<pre class="source-code">
package main
import (
     "fmt"
     "path/filepath"
)
func main() {
     uncleanPath := "/home/user/../documents/file.txt"
     cleanPath := filepath.Clean(uncleanPath)
     fmt.Println("Cleaned path:", cleanPath)
}</pre>			<p>In this example, <strong class="source-inline">filepath.Clean</strong> transforms <a id="_idIndexMarker189"/>the unclean path into a cleaner and more <a id="_idIndexMarker190"/>readable path. When we run this program, we should see <span class="No-Break">this output:</span></p>
			<pre class="console">
Cleaned path: /home/documents/file.txt</pre>			<h3>Splitting file paths</h3>
			<p>To extract <a id="_idIndexMarker191"/>directory and file components from a file path, we can use <strong class="source-inline">filepath.Split</strong>. In this <a id="_idIndexMarker192"/>example, <strong class="source-inline">filepath.Split</strong> separates the directory and file parts of a <span class="No-Break">file path:</span></p>
			<pre class="source-code">
package main
import (
     "fmt"
     "path/filepath"
)
func main() {
     path := "/home/user/documents/myfile.txt"
     dir, file := filepath.Split(path)
     fmt.Println("Directory:", dir)
     fmt.Println("File:", file)
}</pre>			<p>When we run this<a id="_idIndexMarker193"/> program, we should see <span class="No-Break">this output:</span></p>
			<pre class="console">
Directory: /home/user/documents/
File: myfile.txt</pre>			<h2 id="_idParaDest-82"><a id="_idTextAnchor118"/>Traversing directories</h2>
			<p>You <a id="_idIndexMarker194"/>can use the <strong class="source-inline">filepath.WalkDir</strong> function<a id="_idIndexMarker195"/> to traverse directories and perform actions on files and directories within them. This function recursively explores the <span class="No-Break">directory tree.</span></p>
			<p> Let’s analyze the signature of <span class="No-Break">this function:</span></p>
			<pre class="source-code">
func WalkDir(root string, fn fs.WalkDirFunc) error</pre>			<p>The first parameter is the root of a file tree we want to traverse. The second parameter is WalkdirFunc, which is a function type. When we look further, we can see what this <span class="No-Break">type determines:</span></p>
			<pre class="source-code">
type WalkDirFunc func(path string, d DirEntry, err error) error</pre>			<p><strong class="source-inline">path</strong> is the argument containing the argument of <strong class="source-inline">WalkDir</strong> as a prefix. In other words, if <strong class="source-inline">root</strong> is <strong class="source-inline">/home</strong> and the current iteration is over the <strong class="source-inline">Documents</strong> directory, then <strong class="source-inline">path</strong> will contain the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">home/Documents</strong></span><span class="No-Break"> string.</span></p>
			<p>The second parameter is a <strong class="source-inline">DirEntry</strong> interface. This interface is defined by <span class="No-Break">four methods.</span></p>
			<p>The <strong class="source-inline">Name()</strong> function returns the base name of the file or subdirectory, not the <span class="No-Break">full path.</span></p>
			<p>For instance, it would only return the file name <strong class="source-inline">hello.go</strong> and not the entire file path, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">home/gopher/hello.go</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">IsDir()</strong> function checks whether the given entry refers to <span class="No-Break">a directory.</span></p>
			<p>The <strong class="source-inline">Type()</strong> method returns the type bits for the given entry, which is a subset of <strong class="source-inline">FileMode</strong> bits returned by the <span class="No-Break"><strong class="source-inline">FileMode.Type</strong></span><span class="No-Break"> method.</span></p>
			<p>To get information about a file or directory, you can use the <strong class="source-inline">Info()</strong> function. It returns a <strong class="source-inline">FileInfo</strong> object that describes the file or directory. Keep in mind that the returned object may represent the file or directory as it was when the original directory was read, or as it is at the time of the call to <strong class="source-inline">Info()</strong>. If the file or directory has been deleted or renamed since the directory was read, Info may return an error <strong class="source-inline">ErrNotExist</strong>. If the entry you’re examining is a symbolic link, <strong class="source-inline">Info()</strong> will provide information about the link itself, rather than <span class="No-Break">its target.</span></p>
			<p>When using the <strong class="source-inline">WalkDir</strong> function, the result returned by the function determines the behavior of the function. If the function returns the <strong class="source-inline">SkipDir</strong> value, <strong class="source-inline">WalkDir</strong> will skip the current directory (or path if it is a directory) and move on to the next one. If the function returns the <strong class="source-inline">SkipAll</strong> value, <strong class="source-inline">WalkDir</strong> will skip all remaining directories and files, and stop walking the tree. In case the function returns a non-nil error, <strong class="source-inline">WalkDir</strong> will stop entirely and return that error. The <strong class="source-inline">err</strong> argument reports an error related to the path, which signals that <strong class="source-inline">WalkDir</strong> will not walk into that directory. The function using the <strong class="source-inline">WalkDir</strong> can decide how to handle that error. As mentioned earlier, returning the error will cause <strong class="source-inline">WalkDir</strong> to stop walking the <span class="No-Break">entire tree.</span></p>
			<p>To make it all clear, let’s expand the application of <a href="B21662_03.xhtml#_idTextAnchor089"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>. Instead of just classifying the inputs as odd or even, this program will traverse a directory tree up to a maximum depth specified, and <a id="_idIndexMarker196"/>as a bonus feature, we will permit the user to redirect the output to <span class="No-Break">a file.</span></p>
			<p>First of all, we need to add two new flags to our program in the <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
var outputFileName string
flag.StringVar(&amp;outputFileName, "f", "", "Output file (default: stdout)")
flag.Parse()</pre>			<p>This code sets up the command-line flag (<strong class="source-inline">-f</strong>) with the default value and description, associates it with a variable (<strong class="source-inline">outputFileName</strong>), and then parses the command-line arguments to populate this variable with user-provided values. This allows the program to accept specific options when running from the <span class="No-Break">command line.</span></p>
			<p>Now, let’s change <a id="_idIndexMarker197"/>the <strong class="source-inline">NewCliConfig</strong> function to set the default values for these two <span class="No-Break">new variables:</span></p>
			<pre class="source-code">
func NewCliConfig(opts ...Option) (CliConfig, error) {
  c := CliConfig{
<strong class="bold">    OutputFile: "", // empty means only OutStream is used</strong>
    ErrStream:  os.Stderr,
    OutStream:  os.Stdout,
  }
  // other lines omitted for brevity
}</pre>			<p>Now we should update our function app to this new <span class="No-Break">output option:</span></p>
			<pre class="source-code">
var outputWriter io.Writer
  if cfg.OutputFile != "" {
    outputFile, err := os.Create(cfg.OutputFile)
    if err != nil {
      fmt.Fprintf(cfg.ErrStream, "Error creating output file: %v\n", err)
      os.Exit(1)
    }
    defer outputFile.Close()
    outputWriter = io.MultiWriter(cfg.OutStream, outputFile)
  } else {
    outputWriter = cfg.OutStream
  }</pre>			<p>This first part of the <a id="_idIndexMarker198"/>function app determines whether to create an output file based on the <strong class="source-inline">cfg.OutputFile</strong> configuration variable. If an output file is created successfully, it sets up <strong class="source-inline">MultiWriter</strong> to write to both the standard output and the file. If no output file is specified, it simply uses the standard output as <strong class="source-inline">outputWriter</strong>. This design allows for flexible output handling in <span class="No-Break">a program.</span></p>
			<p>Lastly, we will traverse all directories. To exemplify how to skip directories, let’s assume that we want to always skip the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">git</strong></span><span class="No-Break"> directory:</span></p>
			<pre class="source-code">
for _, directory := range directories {
    err := filepath.WalkDir(directory, func(path string, d os.DirEntry, err error) error {
      if path == ".git" {
        return filepath.SkipDir
      }
      if d.IsDir() {
        fmt.Fprintf(outputWriter, "%s\n", path)
      }
      return nil
    })
    if err != nil {
      fmt.Fprintf(cfg.ErrStream, "Error walking the path %q: %v\n", directory, err)
      continue
    }
  }</pre>			<p>This part of the code <a id="_idIndexMarker199"/>iterates through a list of directories and recursively walks through each directory’s contents. For each directory it encounters, it prints the directory’s path to the specified output stream and handles errors that may occur during the walking process. As mentioned before, it skips processing the <strong class="source-inline">.git</strong> directories to avoid including version control metadata in <span class="No-Break">the output.</span></p>
			<p>Once we know how to traverse our filesystem, we must explore more examples in <span class="No-Break">different contexts.</span></p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor119"/>Symbolic links and unlinking files</h1>
			<p>Oh, the good old Unix system, where names such as <strong class="source-inline">link</strong> and <strong class="source-inline">unlink</strong> provide that poetic sense of symmetry, luring you into a false sense of simplistic understanding, only to have you stumbling down a rabbit hole of <span class="No-Break">system calls.</span></p>
			<p>So, link and unlink should be as related as two peas in a pod, right? Well, they are... to a <span class="No-Break">certain extent.</span></p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor120"/>Symbolic links – the shortcut of the file world</h2>
			<p>Symbolic links<a id="_idIndexMarker200"/> are like the shortcuts on your desktop, only for files in the digital realm. Imagine your computer’s filesystem as a vast library filled with books (files), and you want a convenient way to access your favorite book (file) from multiple shelves (directories). Instead of running around the library, you put up a “shortcut” sign that says, <em class="italic">“Hey, the book you’re looking for is on that shelf!”</em> That’s a symbolic link! It’s like having a teleportation spell for your files, allowing you to instantly jump from one location to another without the need for a <span class="No-Break">magic broomstick.</span></p>
			<p>Imagine you have a file called <strong class="source-inline">important_document.txt</strong> located in a directory called <strong class="source-inline">/home/user/document</strong>. You want to create a shortcut to this file in another directory called <strong class="source-inline">/home/user/desktop</strong> so you can access <span class="No-Break">it quickly.</span></p>
			<p>In the Linux command line, you can create a symbolic link using the <strong class="source-inline">ln</strong> command with the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">s</strong></span><span class="No-Break"> option:</span></p>
			<pre class="console">
ln -s /home/user/documents/important_document.txt /home/user/desktop/shortcut_to_document.txt</pre>			<p>Here’s <span class="No-Break">what’s happening:</span></p>
			<ul>
				<li><strong class="source-inline">ln</strong>: This is the command for <span class="No-Break">creating links</span></li>
				<li><strong class="source-inline">-s</strong>: This option specifies that we’re creating a symbolic <span class="No-Break">link (symlink)</span></li>
				<li><strong class="source-inline">/home/user/documents/important_document.txt</strong>: This is the source file you want to <span class="No-Break">link to</span></li>
				<li><strong class="source-inline">/home/user/desktop/shortcut_to_document.txt</strong>: This is the destination where you want to create the <span class="No-Break">symbolic link</span></li>
			</ul>
			<p>Now, when you<a id="_idIndexMarker201"/> open <strong class="source-inline">/home/user/desktop/shortcut_to_document.txt</strong>, it’s like clicking on a shortcut on your computer’s desktop, and it takes you straight <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">important_document.txt</strong></span><span class="No-Break">.</span></p>
			<p>We can achieve the same result <span class="No-Break">in Go:</span></p>
			<pre class="source-code">
package main
import (
  "fmt"
  "os"
)
func main() {
  // Define the source file path.
  sourcePath := "/home/user/Documents/important_document.txt"
  // Define the symlink path.
  symlinkPath := "/home/user/Desktop/shortcut_to_document.txt"
  // Create the symlink.
  err := os.Symlink(sourcePath, symlinkPath)
  if err != nil {
    fmt.Printf("Error creating symlink: %v\n", err)
    return
  }
  fmt.Printf("Symlink created: %s -&gt; %s\n", symlinkPath, sourcePath)
}</pre>			<p>The <strong class="source-inline">os.Symlink</strong> function is used<a id="_idIndexMarker202"/> to create the symlink. After running the <strong class="source-inline">ls -l</strong> command on the terminal, we should see something like the <span class="No-Break">following output:</span></p>
			<pre class="console">
lrwxrwxrwx 1 user user 44 Oct 29 21:44 shortcut_to_document.txt -&gt; /home/alexr/documents/important_document.txt</pre>			<p>As we discussed before, the first letter in the string <strong class="source-inline">lrwxrwxrwx</strong> denotes this file as <span class="No-Break">a symlink.</span></p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor121"/>Unlinking files – the great escape act</h2>
			<p>Unlinking<a id="_idIndexMarker203"/> files is like being a magician with a flair for dramatic exits. You’ve got a file that’s overstayed its welcome, and you want it to vanish in a puff of smoke. So, you grab your magician’s wand (the <strong class="source-inline">unlink</strong> command) and with a flick of your wrist, you shout, “Abracadabra, Hocus Pocus, Be Gone!” And just like that, the file disappears into thin air. It’s the ultimate disappearance act in the world of computing, leaving no trace behind. Now, if only you could do that with <span class="No-Break">your laundry!</span></p>
			<p>But remember, just like magic, unlinking files can be powerful, so use it wisely. You wouldn’t want to accidentally make your important documents vanish into the <span class="No-Break">digital ether!</span></p>
			<p>Now, let’s say you want to perform the great vanishing act and remove that symbolic link you created earlier. You can use <a id="_idIndexMarker204"/>the <strong class="source-inline">unlink</strong> command (or rm for removing <span class="No-Break">regular files):</span></p>
			<pre class="console">
unlink /home/user/desktop/shortcut_to_document.txt</pre>			<p><strong class="source-inline">rm</strong> is used <span class="No-Break">as follows:</span></p>
			<pre class="console">
rm /home/user/desktop/shortcut_to_document.txt</pre>			<p>Here’s <span class="No-Break">what’s happening:</span></p>
			<ul>
				<li><strong class="source-inline">unlink</strong> or <strong class="source-inline">rm</strong>: These commands are used to <span class="No-Break">remove files</span></li>
				<li><strong class="source-inline">/home/user/desktop/shortcut_to_document.txt</strong>: This is the path to the symbolic link (or file) you want <span class="No-Break">to remove</span></li>
			</ul>
			<p>We can achieve the same result using the <strong class="source-inline">Remove</strong> function from the <span class="No-Break"><strong class="source-inline">os</strong></span><span class="No-Break"> package:</span></p>
			<pre class="source-code">
package main
import (
     "fmt"
     "os"
)
func main() {
     // Define the path to the file or symlink you want to remove.
     filePath := "/path/to/your/file-or-symlink.txt"
     // Attempt to remove the file.
     err := os.Remove(filePath)
     if err != nil {
          fmt.Printf("Error removing the file: %v\n", err)
          return
     }
     fmt.Printf("File removed: %s\n", filePath)
}</pre>			<p>When we execute this program, the symbolic link disappears, just like magic! However, it’s important to note that if you used <strong class="source-inline">os.Remove</strong> to delete the link, it won’t affect the file the links refer to. It’s just removing <span class="No-Break">the shortcut.</span></p>
			<p>Let’s create a CLI to <a id="_idIndexMarker205"/>check whether a symbolic link is dangling; in other words, the file it points to does not <span class="No-Break">exist anymore.</span></p>
			<p>We can do everything the same as we did in the last CLI app, with just a <span class="No-Break">few changes:</span></p>
			<pre class="source-code">
for _, directory := range directories {
    err := filepath.Walk(directory, func(path string, info os.FileInfo, err error) error {
      if err != nil {
        fmt.Fprintf(cfg.ErrStream, "Error accessing path %s: %v\n", path, err)
        return nil
      }
      // Check if the current file is a symbolic link.
      if <strong class="bold">info.Mode()&amp;os.ModeSymlink != 0</strong> {
        // Resolve the symbolic link.
        <strong class="bold">target, err := os.Readlink(path)</strong>
        if err != nil {
          fmt.Fprintf(cfg.ErrStream, "Error reading symlink %s: %v\n", path, err)
        } else {
          // Check if the target of the symlink exists.
          <strong class="bold">_, err := os.Stat(target)</strong>
<strong class="bold">          if err != nil {</strong>
<strong class="bold">            if os.IsNotExist(err) {</strong>
<strong class="bold">              fmt.Fprintf(outputWriter, "Broken symlink found: %s -&gt; %s\n", path, target)</strong>
            } else {
              fmt.Fprintf(cfg.ErrStream, "Error checking symlink target %s: %v\n", target, err)
            }
          }
        }
      }
    })
    if err != nil {
      fmt.Fprintf(cfg.ErrStream, "Error walking directory %s: %v\n", directory, err)
    }
  }</pre>			<p>Let’s break down the <a id="_idIndexMarker206"/>most <span class="No-Break">important parts:</span></p>
			<ul>
				<li><strong class="source-inline">if info.Mode()&amp;os.ModeSymlink != 0 { ... }</strong>: This checks whether the current file is a symbolic link. If it is, it enters this block to resolve and check the validity of <span class="No-Break">the symlink.</span></li>
				<li><strong class="source-inline">target, err := os.Readlink(path)</strong>: This attempts to read the target of the symbolic link using <strong class="source-inline">os.Readlink</strong>. If an error occurs, it prints an error message indicating that reading the <span class="No-Break">symlink failed.</span></li>
				<li>It checks if the target of the symlink exists by using <strong class="source-inline">os.Stat(target)</strong>. If an error occurs during this check, it distinguishes between different types <span class="No-Break">of errors:</span></li>
				<li>If the error indicates that the target does not exist (<strong class="source-inline">os.IsNotExist(err)</strong>), it prints a message indicating a <span class="No-Break">broken symlink.</span></li>
				<li>If the error is of another type, it prints an error message indicating that checking the symlink <span class="No-Break">target failed.</span></li>
			</ul>
			<p>In a nutshell, <strong class="source-inline">link</strong> and <strong class="source-inline">unlink</strong> are the social coordinators of the UNIX filesystem world. <strong class="source-inline">link</strong> helps make new associations by adding a new name to a file, while <strong class="source-inline">unlink</strong> sends the file into the oblivion of deletion. They may seem like opposite sides of the same coin, but <strong class="source-inline">unlink</strong> is the harsh reality check to the merry matchmaking <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">link</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor122"/>Calculating directory size</h1>
			<p>One of the <a id="_idIndexMarker207"/>most common things to be done is to check the size of directories. How can we do it using all our knowledge in Go? We first need to create a function to calculate the size of <span class="No-Break">a directory:</span></p>
			<pre class="source-code">
func calculateDirSize(path string) (int64, error) {
  var size int64
  err := filepath.Walk(path, func(filePath string, fileInfo os.FileInfo, err error) error {
    if err != nil {
      return err
    }
    if !fileInfo.IsDir() {
      size += fileInfo.Size()
    }
    return nil
  })
  if err != nil {
    return 0, err
  }
  return size, nil
}</pre>			<p>This function calculates the total size of all files within a given directory, including its subdirectories. Let’s understand how this <span class="No-Break">function works:</span></p>
			<ul>
				<li><strong class="source-inline">func calculateDirSize(path string) (int64, error)</strong>: This function takes a single argument path, which is the path to the directory for which you want to calculate the size. It returns two values: an <strong class="source-inline">int64</strong> value representing the size in bytes and an <strong class="source-inline">error</strong> value indicating whether any errors occurred during <span class="No-Break">the calculation.</span></li>
				<li>It uses the <strong class="source-inline">filepath.Walk</strong> function to traverse the directory tree starting from the specified path. For each file or directory encountered during the walk, the provided callback function <span class="No-Break">is called.</span></li>
				<li><strong class="source-inline">if !fileInfo.IsDir() { size += fileInfo.Size() }</strong>: This checks whether the current item is not a directory (i.e., it’s a file). If it’s a file, it adds the size of the file (<strong class="source-inline">fileInfo.Size()</strong>) to the <strong class="source-inline">size</strong> variable. This is how it accumulates the total size of <span class="No-Break">all files.</span></li>
				<li>After the <strong class="source-inline">filepath.Walk</strong> function completes its traversal, it checks if there was any error during the walk (<strong class="source-inline">if err != nil { return 0, err }</strong>) and returns the accumulated size if there were <span class="No-Break">no errors.</span></li>
			</ul>
			<p>The <strong class="source-inline">calculateDirSize</strong> could act <a id="_idIndexMarker208"/>as an invaluable part of a more general application where it is employed to compute the sizes of various directories listed within the <strong class="source-inline">directories</strong> slice. In the process, these sizes are converted into different units such as bytes, kilobytes, megabytes, or gigabytes, offering a more human-readable representation. The results are then presented to the user through an <span class="No-Break">output stream.</span></p>
			<p>Here’s a snapshot of how this function is applied within the larger context of <span class="No-Break">the application:</span></p>
			<pre class="source-code">
  m := map[string]int64{}
  for _, directory := range directories {
    dirSize, err := calculateDirSize(directory)
    if err != nil {
      fmt.Fprintf(cfg.ErrStream, "Error calculating size of %s: %v\n", directory, err)
      continue
    }
    // Convert to MB
    m[directory] = dirSize
  }
  for dir, size := range m {
    var unit string
    switch {
    case size &lt; 1024:
      unit = "B"
    case size &lt; 1024*1024:
      size /= 1024
      unit = "KB"
    case size &lt; 1024*1024*1024:
      size /= 1024 * 1024
      unit = "MB"
    default:
      size /= 1024 * 1024 * 1024
      unit = "GB"
    }
    fmt.Fprintf(outputWriter, "%s - %d%s\n", dir, size, unit)
  }</pre>			<p>The preceding code calculates the sizes of directories listed in the <strong class="source-inline">directories</strong> slice, converts those sizes to different units (bytes, kilobytes, megabytes, or gigabytes), and then prints <span class="No-Break">the results.</span></p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor123"/>Finding duplicate files</h1>
			<p>In the <a id="_idIndexMarker209"/>realm of data management, a common challenge is identifying and managing duplicate files. In our example, the <strong class="source-inline">findDuplicateFiles</strong> function became a tool of choice for this task. Its purpose was straightforward: to locate and catalog duplicate files within a given directory. Let’s investigate how this <span class="No-Break">function operates:</span></p>
			<pre class="source-code">
func findDuplicateFiles(rootDir string) (map[string][]string, error) {
  duplicates := make(map[string][]string)
  err := filepath.Walk(rootDir, func(path string, info os.FileInfo, err error) error {
    if err != nil {
      return err
    }
    if !info.IsDir() {
      hash, err := computeFileHash(path)
      if err != nil {
        return err
      }
      duplicates[hash] = append(duplicates[hash], path)
    }
    return nil
  })
  return duplicates, err
}</pre>			<p>We can observe the following <span class="No-Break">key features:</span></p>
			<ul>
				<li><strong class="bold">Traversal with</strong> <strong class="source-inline">filepath.Walk</strong>: The function uses <strong class="source-inline">filepath.Walk</strong> to systematically explore all files within the specified directory (<strong class="source-inline">rootDir</strong>) and its subdirectories. This traversal covers <a id="_idIndexMarker210"/>every nook and cranny of <span class="No-Break">the filesystem.</span></li>
				<li><strong class="bold">File hashing</strong>: To identify duplicates, each file is hashed. This hashing process transforms file contents into unique hash values. Identical files will yield the same hash, allowing for <span class="No-Break">easy identification.</span></li>
				<li><strong class="bold">Duplication mapping</strong>: A map named <strong class="source-inline">duplicates</strong> is employed to keep track of the duplicate files. The map associates each unique hash with an array of file paths that share the same hash. Files with distinct hashes are not <span class="No-Break">considered duplicates.</span></li>
			</ul>
			<p>To apply this<a id="_idIndexMarker211"/> function in practice, let’s utilize it to scan multiple directories for duplicate files. Here’s an overview of <span class="No-Break">the process:</span></p>
			<pre class="source-code">
for _, directory := range directories {
  duplicates, err := findDuplicateFiles(directory)
  if err != nil {
    fmt.Fprintf(cfg.ErrStream, "Error finding duplicate files: %v\n", err)
    continue
  }
  // Display Duplicate Files
  for hash, files := range duplicates {
    if len(files) &gt; 1 {
      fmt.Printf("Duplicate Hash: %s\n", hash)
      for _, file := range files {
        fmt.Fprintln(outputWriter, "  -", file)
      }
    }
  }
}</pre>			<p>The <strong class="source-inline">findDuplicateFiles</strong> function recursively explores a directory and its subdirectories, hashes non-directory files, and organizes them into groups based on their hash values. This allows for the efficient identification of duplicate files within the specified <a id="_idIndexMarker212"/><span class="No-Break">directory structure.</span></p>
			<p>This is the code for the <span class="No-Break"><strong class="source-inline">computeFileHash</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
func computeFileHash(filePath string) (string, error) {
  // Attempt to open the file for reading
  file, err := os.Open(filePath)
  if err != nil {
    return "", err
  }
  // Ensure that the file is closed when the function exits
  defer file.Close()
  // Create an MD5 hash object
  hash := md5.New()
  // Copy the contents of the file into the hash object
  if _, err := io.Copy(hash, file); err != nil {
    return "", err
  }
  // Generate a hexadecimal representation of the MD5 hash and return it
  return fmt.Sprintf("%x", hash.Sum(nil)), nil
}</pre>			<p>The <strong class="source-inline">computeFileHash</strong> function<a id="_idIndexMarker213"/> opens a file, calculates the MD5 hash of its contents, converts <a id="_idIndexMarker214"/>the hash to a hexadecimal string, and returns it. This function is useful for generating unique identifiers (hashes) for files, which can be used for various purposes, including identifying duplicate files, verifying data integrity, or indexing files based on their content. In the last section, we will explore advanced optimization when we’re working <span class="No-Break">with files.</span></p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor124"/>Optimizing filesystem operations</h1>
			<p>System programming<a id="_idIndexMarker215"/> often faces challenges when it comes to optimizing file operations, especially when dealing with data that exceeds the available memory capacity. One effective solution to this problem is the use of memory-mapped files (mmap), which, when utilized properly, can significantly enhance the efficiency of <span class="No-Break">file operations.</span></p>
			<p>Memory-mapped files (<strong class="source-inline">mmap</strong>) provide<a id="_idIndexMarker216"/> a viable approach to address this issue. By directly mapping files into memory, mmap simplifies the process of working with files. Essentially, the operating system manages the disk writes, while the program interacts with the data <span class="No-Break">in memory.</span></p>
			<p>A straightforward demonstration in the Go programming language illustrates how mmap can efficiently handle file operations, even when dealing with <span class="No-Break">large files.</span></p>
			<p>First, we need to open a <span class="No-Break">large file:</span></p>
			<pre class="source-code">
  filePath := "example.txt"
  file, err := os.OpenFile(filePath, os.O_RDWR|os.O_CREATE, 0644)
  if err != nil {
    fmt.Printf("Failed to open file: %v\n", err)
    return
  }
  defer file.Close()</pre>			<p>Next, we <a id="_idIndexMarker217"/>should read the file metadata for using the <span class="No-Break"><strong class="source-inline">mmap</strong></span><span class="No-Break"> syscall:</span></p>
			<pre class="source-code">
  fileInfo, err := file.Stat()
  if err != nil {
    fmt.Printf("Failed to get file info: %v\n", err)
    return
  }
  fileSize := fileInfo.Size()</pre>			<p>Now we can use the <span class="No-Break">memory mapping:</span></p>
			<pre class="source-code">
data, err := syscall.Mmap(int(file.Fd()), 0, int(fileSize), syscall.PROT_READ|syscall.PROT_WRITE, syscall.MAP_SHARED)
  if err != nil {
    fmt.Printf("Failed to mmap file: %v\n", err)
    return
  }
  defer syscall.Munmap(data)</pre>			<p>Let’s take the following line from the preceding <span class="No-Break">code block:</span></p>
			<p><strong class="source-inline">data, err := syscall.Mmap(int(file.Fd()), 0, int(fileSize), syscall.PROT_READ|syscall.PROT_WRITE, syscall.MAP_SHARED)</strong>. There are two main areas of this code to pay <span class="No-Break">attention to:</span></p>
			<ul>
				<li><strong class="source-inline">syscall.Mmap</strong> is used<a id="_idIndexMarker218"/> to map the file into memory. It takes the <span class="No-Break">following arguments:</span></li>
				<li><strong class="source-inline">int(file.Fd())</strong>: This extracts the file descriptor (an integer representing the opened file) from the file object. The <strong class="source-inline">file.Fd()</strong> method returns the <span class="No-Break">file descriptor.</span></li>
				<li><strong class="source-inline">0</strong>: This represents the offset within the file where the mapping should begin. In this case, it starts at the beginning of the file (offset <strong class="source-inline">0</strong>).<strong class="source-inline">int(fileSize)</strong>: The length of the mapping, specified as an integer representing the size of the file (<strong class="source-inline">fileSize</strong>). This determines how much of the file will be mapped <span class="No-Break">into memory.</span></li>
				<li><strong class="source-inline">syscall.PROT_READ|syscall.PROT_WRITE</strong>: This sets the protection modes for the mapped memory. <strong class="source-inline">PROT_READ</strong> allows read access, and <strong class="source-inline">PROT_WRITE</strong> allows <span class="No-Break">write access.</span></li>
				<li><strong class="source-inline">syscall.MAP_SHARED</strong>: This specifies that the mapped memory is shared among multiple processes. Changes made to the memory will be reflected in the file, and <span class="No-Break">vice versa.</span></li>
				<li><span class="No-Break"><strong class="source-inline">defer syscall.Munmap(data)</strong></span><span class="No-Break">:</span><ul><li>Assuming<a id="_idIndexMarker219"/> the memory mapping operation was successful (i.e., no error occurred), this <strong class="source-inline">defer</strong> statement schedules the <strong class="source-inline">syscall.Munmap</strong> function to be called when the surrounding <span class="No-Break">function returns.</span></li><li><strong class="source-inline">syscall.Munmap</strong> is used to unmap the memory region previously mapped with <strong class="source-inline">syscall.Mmap</strong>. It ensures that the mapped memory is released properly when it is no <span class="No-Break">longer needed.</span></li></ul></li>
			</ul>
			<p>Once the data is memory mapped, we can modify <span class="No-Break">the data:</span></p>
			<pre class="source-code">
  fmt.Printf("Initial content: %s\n", string(data))
  // Modify the content in memory
  newContent := []byte("Hello, mmap!")
  copy(data, newContent)
  fmt.Println("Content updated successfully.")</pre>			<p>With this knowledge available, we can interact with large files practically with no concerns<a id="_idIndexMarker220"/> about <span class="No-Break">memory availability.</span></p>
			<p class="callout-heading">Out-of-memory safety</p>
			<p class="callout">It’s important to note that using a<a id="_idIndexMarker221"/> file-backed mapping is the appropriate choice for mmap, as opposed to an anonymous mapping. If you intend to make modifications to the mapped memory and have those changes written back to the file, then a shared mapping is necessary. With a file-backed, shared mapping, concerns about the Out-of-Memory (OOM) killer are alleviated, if your process operates in a 64-bit environment. Even in a non-64-bit environment, the issue would be related to addressing space limitations rather than RAM constraints, so the OOM killer would not be a concern; instead, your mmap operation would simply <span class="No-Break">fail gracefully.</span></p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor125"/>Summary</h1>
			<p>Congratulations on completing <a href="B21662_04.xhtml#_idTextAnchor110"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>! In this chapter, we explored file and directory operations in Go. We covered essential topics, from identifying unsafe files and directory permissions to optimizing <span class="No-Break">filesystem operations.</span></p>
			<p> As we close this chapter, you now have a solid foundation in handling files and directories in Go, equipped with the knowledge and skills to build secure and efficient file-related applications. You’ve learned not just the theory but also the practical coding techniques that you can apply directly to <span class="No-Break">your projects.</span></p>
			<p>Moving forward, in the next chapter, we advance even more on system programming concepts, covering <span class="No-Break">inter-process communication.</span></p>
		</div>
	</div>
</div>
</body></html>