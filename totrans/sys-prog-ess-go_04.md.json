["```go\nfunc Stat(name string) (FileInfo, error)\n```", "```go\npackage main\nimport (\n     \"fmt\"\n     \"os\"\n)\nfunc main() {\n     info, err := os.Stat(\"example.txt\")\n     if err != nil {\n          panic(err)\n     }\n     fmt.Printf(\"File name: %s\\n\", info.Name())\n     fmt.Printf(\"File size: %d\\n\", info.Size())\n     fmt.Printf(\"File permissions: %s\\n\", info.Mode())\n     fmt.Printf(\"Last modified: %s\\n\", info.ModTime())\n}\n```", "```go\ninfo, err := os.Stat(\"example.txt\")\nif err != nil {\n     if os.IsNotExist(err) {\n          fmt.Println(\"File does not exist\")\n     } else {\n          panic(err)\n     }\n}\n```", "```go\n-rw-r--r-- 1 user group  0 Oct 25 10:00 file1.txt\n-rw-r--r-- 1 user group  0 Oct 25 10:01 file2.txt\ndrwxr-xr-x 2 user group 4096 Oct 25 10:02 directory1\n```", "```go\npackage main\nimport (\n    \"fmt\"\n    \"os\"\n)\nfunc main() {\n    // Stat the file to get its information\n    fileInfo, err := os.Stat(\"example.txt\")\n    if err != nil {\n         fmt.Println(\"Error:\", err)\n         return\n    }\n    // Get file permissions\n    permissions := fileInfo.Mode().Perm()\n    permissionString := fmt.Sprintf(\"%o\", permissions)\n    fmt.Printf(\"Permissions: %s\\n\", permissionString)\n}\n```", "```go\npackage main\nimport (\n     \"fmt\"\n     \"path/filepath\"\n)\nfunc main() {\n     dir := \"/home/user\"\n     file := \"document.txt\"\n     fullPath := filepath.Join(dir, file)\n     fmt.Println(\"Full path:\", fullPath)\n}\n```", "```go\nFull path: /home/user/document.txt\n```", "```go\npackage main\nimport (\n     \"fmt\"\n     \"path/filepath\"\n)\nfunc main() {\n     uncleanPath := \"/home/user/../documents/file.txt\"\n     cleanPath := filepath.Clean(uncleanPath)\n     fmt.Println(\"Cleaned path:\", cleanPath)\n}\n```", "```go\nCleaned path: /home/documents/file.txt\n```", "```go\npackage main\nimport (\n     \"fmt\"\n     \"path/filepath\"\n)\nfunc main() {\n     path := \"/home/user/documents/myfile.txt\"\n     dir, file := filepath.Split(path)\n     fmt.Println(\"Directory:\", dir)\n     fmt.Println(\"File:\", file)\n}\n```", "```go\nDirectory: /home/user/documents/\nFile: myfile.txt\n```", "```go\nfunc WalkDir(root string, fn fs.WalkDirFunc) error\n```", "```go\ntype WalkDirFunc func(path string, d DirEntry, err error) error\n```", "```go\nvar outputFileName string\nflag.StringVar(&outputFileName, \"f\", \"\", \"Output file (default: stdout)\")\nflag.Parse()\n```", "```go\nfunc NewCliConfig(opts ...Option) (CliConfig, error) {\n  c := CliConfig{\n    OutputFile: \"\", // empty means only OutStream is used\n    ErrStream:  os.Stderr,\n    OutStream:  os.Stdout,\n  }\n  // other lines omitted for brevity\n}\n```", "```go\nvar outputWriter io.Writer\n  if cfg.OutputFile != \"\" {\n    outputFile, err := os.Create(cfg.OutputFile)\n    if err != nil {\n      fmt.Fprintf(cfg.ErrStream, \"Error creating output file: %v\\n\", err)\n      os.Exit(1)\n    }\n    defer outputFile.Close()\n    outputWriter = io.MultiWriter(cfg.OutStream, outputFile)\n  } else {\n    outputWriter = cfg.OutStream\n  }\n```", "```go\nfor _, directory := range directories {\n    err := filepath.WalkDir(directory, func(path string, d os.DirEntry, err error) error {\n      if path == \".git\" {\n        return filepath.SkipDir\n      }\n      if d.IsDir() {\n        fmt.Fprintf(outputWriter, \"%s\\n\", path)\n      }\n      return nil\n    })\n    if err != nil {\n      fmt.Fprintf(cfg.ErrStream, \"Error walking the path %q: %v\\n\", directory, err)\n      continue\n    }\n  }\n```", "```go\nln -s /home/user/documents/important_document.txt /home/user/desktop/shortcut_to_document.txt\n```", "```go\npackage main\nimport (\n  \"fmt\"\n  \"os\"\n)\nfunc main() {\n  // Define the source file path.\n  sourcePath := \"/home/user/Documents/important_document.txt\"\n  // Define the symlink path.\n  symlinkPath := \"/home/user/Desktop/shortcut_to_document.txt\"\n  // Create the symlink.\n  err := os.Symlink(sourcePath, symlinkPath)\n  if err != nil {\n    fmt.Printf(\"Error creating symlink: %v\\n\", err)\n    return\n  }\n  fmt.Printf(\"Symlink created: %s -> %s\\n\", symlinkPath, sourcePath)\n}\n```", "```go\nlrwxrwxrwx 1 user user 44 Oct 29 21:44 shortcut_to_document.txt -> /home/alexr/documents/important_document.txt\n```", "```go\nunlink /home/user/desktop/shortcut_to_document.txt\n```", "```go\nrm /home/user/desktop/shortcut_to_document.txt\n```", "```go\npackage main\nimport (\n     \"fmt\"\n     \"os\"\n)\nfunc main() {\n     // Define the path to the file or symlink you want to remove.\n     filePath := \"/path/to/your/file-or-symlink.txt\"\n     // Attempt to remove the file.\n     err := os.Remove(filePath)\n     if err != nil {\n          fmt.Printf(\"Error removing the file: %v\\n\", err)\n          return\n     }\n     fmt.Printf(\"File removed: %s\\n\", filePath)\n}\n```", "```go\nfor _, directory := range directories {\n    err := filepath.Walk(directory, func(path string, info os.FileInfo, err error) error {\n      if err != nil {\n        fmt.Fprintf(cfg.ErrStream, \"Error accessing path %s: %v\\n\", path, err)\n        return nil\n      }\n      // Check if the current file is a symbolic link.\n      if info.Mode()&os.ModeSymlink != 0 {\n        // Resolve the symbolic link.\n        target, err := os.Readlink(path)\n        if err != nil {\n          fmt.Fprintf(cfg.ErrStream, \"Error reading symlink %s: %v\\n\", path, err)\n        } else {\n          // Check if the target of the symlink exists.\n          _, err := os.Stat(target)\n          if err != nil {\n            if os.IsNotExist(err) {\n              fmt.Fprintf(outputWriter, \"Broken symlink found: %s -> %s\\n\", path, target)\n            } else {\n              fmt.Fprintf(cfg.ErrStream, \"Error checking symlink target %s: %v\\n\", target, err)\n            }\n          }\n        }\n      }\n    })\n    if err != nil {\n      fmt.Fprintf(cfg.ErrStream, \"Error walking directory %s: %v\\n\", directory, err)\n    }\n  }\n```", "```go\nfunc calculateDirSize(path string) (int64, error) {\n  var size int64\n  err := filepath.Walk(path, func(filePath string, fileInfo os.FileInfo, err error) error {\n    if err != nil {\n      return err\n    }\n    if !fileInfo.IsDir() {\n      size += fileInfo.Size()\n    }\n    return nil\n  })\n  if err != nil {\n    return 0, err\n  }\n  return size, nil\n}\n```", "```go\n  m := map[string]int64{}\n  for _, directory := range directories {\n    dirSize, err := calculateDirSize(directory)\n    if err != nil {\n      fmt.Fprintf(cfg.ErrStream, \"Error calculating size of %s: %v\\n\", directory, err)\n      continue\n    }\n    // Convert to MB\n    m[directory] = dirSize\n  }\n  for dir, size := range m {\n    var unit string\n    switch {\n    case size < 1024:\n      unit = \"B\"\n    case size < 1024*1024:\n      size /= 1024\n      unit = \"KB\"\n    case size < 1024*1024*1024:\n      size /= 1024 * 1024\n      unit = \"MB\"\n    default:\n      size /= 1024 * 1024 * 1024\n      unit = \"GB\"\n    }\n    fmt.Fprintf(outputWriter, \"%s - %d%s\\n\", dir, size, unit)\n  }\n```", "```go\nfunc findDuplicateFiles(rootDir string) (map[string][]string, error) {\n  duplicates := make(map[string][]string)\n  err := filepath.Walk(rootDir, func(path string, info os.FileInfo, err error) error {\n    if err != nil {\n      return err\n    }\n    if !info.IsDir() {\n      hash, err := computeFileHash(path)\n      if err != nil {\n        return err\n      }\n      duplicates[hash] = append(duplicates[hash], path)\n    }\n    return nil\n  })\n  return duplicates, err\n}\n```", "```go\nfor _, directory := range directories {\n  duplicates, err := findDuplicateFiles(directory)\n  if err != nil {\n    fmt.Fprintf(cfg.ErrStream, \"Error finding duplicate files: %v\\n\", err)\n    continue\n  }\n  // Display Duplicate Files\n  for hash, files := range duplicates {\n    if len(files) > 1 {\n      fmt.Printf(\"Duplicate Hash: %s\\n\", hash)\n      for _, file := range files {\n        fmt.Fprintln(outputWriter, \"  -\", file)\n      }\n    }\n  }\n}\n```", "```go\nfunc computeFileHash(filePath string) (string, error) {\n  // Attempt to open the file for reading\n  file, err := os.Open(filePath)\n  if err != nil {\n    return \"\", err\n  }\n  // Ensure that the file is closed when the function exits\n  defer file.Close()\n  // Create an MD5 hash object\n  hash := md5.New()\n  // Copy the contents of the file into the hash object\n  if _, err := io.Copy(hash, file); err != nil {\n    return \"\", err\n  }\n  // Generate a hexadecimal representation of the MD5 hash and return it\n  return fmt.Sprintf(\"%x\", hash.Sum(nil)), nil\n}\n```", "```go\n  filePath := \"example.txt\"\n  file, err := os.OpenFile(filePath, os.O_RDWR|os.O_CREATE, 0644)\n  if err != nil {\n    fmt.Printf(\"Failed to open file: %v\\n\", err)\n    return\n  }\n  defer file.Close()\n```", "```go\n  fileInfo, err := file.Stat()\n  if err != nil {\n    fmt.Printf(\"Failed to get file info: %v\\n\", err)\n    return\n  }\n  fileSize := fileInfo.Size()\n```", "```go\ndata, err := syscall.Mmap(int(file.Fd()), 0, int(fileSize), syscall.PROT_READ|syscall.PROT_WRITE, syscall.MAP_SHARED)\n  if err != nil {\n    fmt.Printf(\"Failed to mmap file: %v\\n\", err)\n    return\n  }\n  defer syscall.Munmap(data)\n```", "```go\n  fmt.Printf(\"Initial content: %s\\n\", string(data))\n  // Modify the content in memory\n  newContent := []byte(\"Hello, mmap!\")\n  copy(data, newContent)\n  fmt.Println(\"Content updated successfully.\")\n```"]