- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: File and Directory Operations
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件和目录操作
- en: In this chapter, we will learn how to work with files and folders using Go.
    We will explore many valuable topics including checking file and folder permissions,
    working with links, and finding the size of folders.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用 Go 处理文件和文件夹。我们将探讨许多有价值的主题，包括检查文件和文件夹权限、处理链接以及查找文件夹的大小。
- en: In this chapter, you will do hands-on activities. You will write and run code
    that works with files and folders. This way, you will learn practical skills for
    real-world programming tasks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将进行实际操作。你将编写并运行与文件和文件夹交互的代码。这样，你将学会实际编程任务中的实用技能。
- en: By the end of this chapter, you will know how to manage files and folders in
    Go. You can check and fix file and folder permissions, find and manage files and
    folders, and do many other practical tasks. This knowledge will help you create
    secure and effective file-related programs in Go.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将知道如何在 Go 中管理文件和文件夹。你可以检查和修复文件和文件夹权限，查找和管理文件和文件夹，以及执行许多其他实用任务。这些知识将帮助你创建安全有效的
    Go 相关程序。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主要内容：
- en: Identifying unsafe file and directory permissions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别不安全的文件和目录权限
- en: Scanning directories in Go
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Go 中扫描目录
- en: Symbolic links and unlinking files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号链接和解除文件链接
- en: Calculating directory size
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算目录大小
- en: Finding duplicate files
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找重复文件
- en: Optimizing filesystem operations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化文件系统操作
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find this chapter source code at [https://github.com/PacktPublishing/System-Programming-Essentials-with-Go/tree/main/ch4](https://github.com/PacktPublishing/System-Programming-Essentials-with-Go/tree/main/ch4)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/PacktPublishing/System-Programming-Essentials-with-Go/tree/main/ch4](https://github.com/PacktPublishing/System-Programming-Essentials-with-Go/tree/main/ch4)
    找到本章的源代码。
- en: Identifying unsafe file and directory permissions
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别不安全的文件和目录权限
- en: Retrieving information about a file or directory is a common task in programming
    and Go provides a platform-independent way to perform this operation. The `os.Stat`
    function is an essential part of the `os` package, which acts as an interface
    to operating system functionality. When called, the `os.Stat` function returns
    a `FileInfo` interface and an error. The `FileInfo` interface contains various
    file metadata, such as its name, size, permissions, and modification times.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中检索有关文件或目录的信息是一项常见任务，Go 提供了一种平台无关的方式来执行此操作。`os.Stat` 函数是 `os` 包的一个基本部分，它作为操作系统功能的一个接口。当调用时，`os.Stat`
    函数返回一个 `FileInfo` 接口和一个错误。`FileInfo` 接口包含各种文件元数据，例如其名称、大小、权限和修改时间。
- en: 'Here’s the signature of the `os.Stat` function:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `os.Stat` 函数的签名：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The name parameter is the path to the file or directory you want to obtain information
    about.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 名称参数是你想要获取信息的文件或目录的路径。
- en: 'Let’s discover how we could use `os.Stat` to get information about a file:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何使用 `os.Stat` 获取有关文件的信息：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, in the main function, we call `os.Stat` with the path to a
    file named `example.txt`. When `os.Stat` returns an error, we “panic” the error
    and exit the program. Otherwise, we use the `FileInfo` methods (`Name`, `Size`,
    `Mode`, and `ModTime`) to print out some information about the file.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，在主函数中，我们使用名为 `example.txt` 的文件的路径调用 `os.Stat`。当 `os.Stat` 返回错误时，我们“恐慌”错误并退出程序。否则，我们使用
    `FileInfo` 方法（`Name`、`Size`、`Mode` 和 `ModTime`）打印出有关文件的一些信息。
- en: 'It’s important to check the error returned by `os.Stat`. If the error is non-nil,
    it’s likely because the file doesn’t exist or there’s a permission problem. A
    common way to check for a non-existent file is to use the `os.IsNotExist` function:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 `os.Stat` 返回的错误是很重要的。如果错误非空，很可能是由于文件不存在或存在权限问题。检查不存在文件的一种常见方法是使用 `os.IsNotExist`
    函数：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this code, we first call the `os.Stat` function to check the status of a
    file. If an error occurs during this operation, we check whether the error is
    because the file doesn’t exist by using the `os.IsNotExist` function. If it is
    due to the file not existing, we display a message. However, if the error is for
    some other reason, we panic it and terminate the program. Once we know how to
    read file metadata, we can start to explore and understand files and their permissions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们首先调用 `os.Stat` 函数来检查文件的状态。如果在操作过程中发生错误，我们使用 `os.IsNotExist` 函数检查错误是否是因为文件不存在。如果是由于文件不存在，我们显示一条消息。然而，如果错误是由于其他原因，我们将引发恐慌并终止程序。一旦我们知道了如何读取文件元数据，我们就可以开始探索和理解文件及其权限。
- en: Files and permissions
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件和权限
- en: In Linux, files are categorized into various types, each serving a unique purpose.
    Here’s a rundown of common Linux file types along with their correlation to the
    `FileMode` bits returned from `FileInfo.Mode()` call.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，文件被分类为各种类型，每种类型都有其独特的作用。以下是常见Linux文件类型及其与`FileInfo.Mode()`调用返回的`FileMode`位的关联概述。
- en: Regular files
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 普通文件
- en: Regular files contain data such as text, images, or programs. They are denoted
    by `-` in the first character of the file listing. In Go, a regular file is represented
    by the absence of other file-type bits. You can check whether a file is a regular
    file using the `IsRegular` method on `FileMode`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 普通文件包含文本、图像或程序等数据。它们在文件列表的第一个字符中用`-`表示。在Go中，普通文件通过没有其他文件类型位来表示。您可以使用`FileMode`上的`IsRegular`方法检查文件是否为普通文件。
- en: Directories
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目录
- en: Directories hold other files and directories. They are denoted by `d` in the
    first character of the file listing. The `os.ModeDir` bit represents a directory.
    You can check whether a file is a directory using the `IsDir()` method.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 目录包含其他文件和目录。它们在文件列表的第一个字符中用`d`表示。`os.ModeDir`位表示目录。您可以使用`IsDir()`方法检查一个文件是否是目录。
- en: Symbolic links
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 符号链接
- en: Symbolic links are pointers to other files. They are denoted by `l` in the first
    character of the file listing. The `os.ModeSymlink` bit represents a symbolic
    link. Unfortunately, `FileMode` in Go does not directly expose a method to check
    for symbolic links, but we can check whether `FileMode&os.ModeSymlink` is non-zero.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 符号链接是指向其他文件的指针。它们在文件列表的第一个字符中用`l`表示。`os.ModeSymlink`位表示符号链接。不幸的是，Go中的`FileMode`没有直接暴露用于检查符号链接的方法，但我们可以检查`FileMode&os.ModeSymlink`是否非零。
- en: Named pipes (FIFOs)
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名管道（FIFOs）
- en: Named pipes are mechanisms for inter-process communication, denoted by `p` in
    the first character of the file listing. The `os.ModeNamedPipe` bit represents
    a named pipe.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 命名管道是进程间通信的机制，在文件列表的第一个字符中用`p`表示。`os.ModeNamedPipe`位表示命名管道。
- en: Character devices
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符设备
- en: Character devices provide unbuffered, direct access to hardware devices, and
    are denoted by `c` in the first character of the file listing. The `os.ModeCharDevice`
    bit represents a character device.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 字符设备提供对硬件设备的无缓冲、直接访问，在文件列表的第一个字符中用`c`表示。`os.ModeCharDevice`位表示字符设备。
- en: Block devices
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 块设备
- en: Block devices provide buffered access to hardware devices and are denoted by
    `b` in the first character of the file listing. Go does not have a direct `FileMode`
    bit for block devices. However, you might still be able to work with block devices
    using the `os` package’s file operations.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 块设备提供对硬件设备的缓冲访问，在文件列表的第一个字符中用`b`表示。Go没有直接为块设备提供`FileMode`位。但是，您可能仍然可以使用`os`包的文件操作来处理块设备。
- en: Sockets
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 套接字
- en: Sockets are endpoints for communication, denoted by `s` in the first character
    of the file listing. The `os.ModeSocket` bit represents a socket.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字是通信的端点，在文件列表的第一个字符中用`s`表示。`os.ModeSocket`位表示套接字。
- en: The `FileMode` type in Go encapsulates these bits and provides methods and constants
    for working with file types and permissions, making it easier to perform file
    operations in a cross-platform way.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的`FileMode`类型封装了这些位，并提供用于处理文件类型和权限的方法和常量，这使得跨平台执行文件操作变得更容易。
- en: 'In Linux, the permissions system is a crucial aspect of file and directory
    security. It determines who can access, modify, or execute files and directories.
    Permissions are represented by a combination of read (`r`), write (`w`), and execute
    (`x`) permissions for three categories of users: owner, group, and others.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，权限系统是文件和目录安全的一个关键方面。它决定了谁可以访问、修改或执行文件和目录。权限由对三个用户类别的读（`r`）、写（`w`）和执行（`x`）权限的组合表示：所有者、组和其他人。
- en: 'Let’s refresh what these permissions represent:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这些权限代表什么：
- en: '**Read (r)**: Allows reading or viewing the file’s contents or listing a directory’s
    contents'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读取（r）**：允许读取或查看文件内容或列出目录内容'
- en: '**Write (w)**: Allows modifying or deleting a file’s contents or adding/removing
    files in a directory'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**写入（w）**：允许修改或删除文件内容，或在目录中添加/删除文件'
- en: '**Execute (x)**: Allows executing a file or accessing the contents of a directory
    (if you have execute permission on the directory itself)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行（x）**：允许执行文件或访问目录的内容（如果您对目录本身有执行权限）'
- en: Linux file permissions are typically displayed in the form of a 9-character
    string, such as `rwxr-xr—`, where the first three characters represent permissions
    for the owner, the next three for the group, and the last three for others.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 文件权限通常以一个9字符的字符串形式显示，例如 `rwxr-xr—`，其中前三个字符代表所有者的权限，接下来的三个字符代表组的权限，最后的三个字符代表其他用户的权限。
- en: 'When we combine the file type and its permissions, we form the 10-character
    string that the `ls -l` command returns in the first column of the following example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将文件类型和其权限结合起来时，我们形成了一个10字符的字符串，这是 `ls -l` 命令在以下示例的第一列返回的权限。
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we take a closer look at `directory1`, we can determine the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细观察 `directory1`，我们可以确定以下内容：
- en: It’s a directory because of the first letter `d`
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于第一个字母是 `d`，所以它是一个目录。
- en: The owner has permission to read, write, and execute, given the first triplet
    `rwx`
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有者拥有读取、写入和执行权限，这是由第一个三元组 `rwx` 给出的。
- en: The group and the user can read and execute, given the same string `r-x`
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组和用户拥有相同的字符串 `r-x` 的读取和执行权限。
- en: 'To check file permissions in Go, you can use the `os` package to inspect file
    and directory properties. Here’s a simple example of how to check file permissions
    using Go:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Go 中检查文件权限，可以使用 `os` 包来检查文件和目录属性。以下是一个使用 Go 检查文件权限的简单示例：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, we use the `os.Stat` to retrieve file information, and then
    we extract the permissions using `fileInfo.Mode().Perm()`. The `Perm()` method
    returns a `os.FileMode` value, which we format as an octal string using `fmt.Sprintf`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `os.Stat` 来检索文件信息，然后使用 `fileInfo.Mode().Perm()` 提取权限。`Perm()` 方法返回一个
    `os.FileMode` 值，我们使用 `fmt.Sprintf` 将其格式化为八进制字符串。
- en: You may ask yourself, *why an* *octal string?*
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问自己，*为什么是* *八进制字符串*？
- en: Octal notation provides a compact and human-readable way to represent file permissions.
    The octal digit is the sum of the values for read (4), write (2), and execute
    (1). For example, `rwx` (read, write, execute) is 7 (4+2+1), `r-x` (read, no write,
    execute) is 5 (4+0+1), and so on.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 八进制表示法提供了一种紧凑且易于阅读的方式来表示文件权限。八进制数字是读取（4）、写入（2）和执行（1）值的总和。例如，`rwx`（读取、写入、执行）是
    7（4+2+1），`r-x`（读取、无写入、执行）是 5（4+0+1），依此类推。
- en: So, for example, the permissions `-rwxr-xr--` can be succinctly represented
    as 755 in octal.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，权限 `-rwxr-xr--` 可以简洁地表示为八进制的 755。
- en: Note
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The convention of using octal representation for permissions dates to the early
    days of Unix. Over the decades, this convention has been retained for consistency
    and compatibility with older scripts and utilities.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用八进制表示权限的惯例可以追溯到 Unix 的早期。几十年来，这一惯例被保留下来以保持一致性和与旧脚本和工具的兼容性。
- en: Scanning directories in Go
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Go 中扫描目录
- en: Go provides a robust and platform-independent way to work with file and directory
    paths, making it an excellent choice for building file-related applications. We
    will cover topics such as fil- path joining, cleaning, and traversal, along with
    some best practices for handling file paths effectively.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了一种健壮且与平台无关的方式来处理文件和目录路径，使其成为构建文件相关应用程序的绝佳选择。我们将涵盖诸如路径连接、清理和遍历等主题，以及一些有效处理文件路径的最佳实践。
- en: Understanding file paths
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解文件路径
- en: Before we dive into manipulating file paths in Go, it’s important to understand
    the basics. A file path is a string representation of a file or directory’s location
    within a filesystem. File paths typically consist of one or more directory names
    separated by a path separator, which varies between operating systems.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨在 Go 中操作文件路径之前，了解基础知识非常重要。文件路径是文件或目录在文件系统中的位置字符串表示。文件路径通常由一个或多个目录名组成，这些目录名由路径分隔符分隔，路径分隔符在不同的操作系统之间有所不同。
- en: For example, on Unix-like systems (Linux, macOS), the path separator is `/`,
    such as `/home/user/documents/myfile.txt`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在类 Unix 系统（Linux、macOS）中，路径分隔符是 `/`，例如 `/home/user/documents/myfile.txt`。
- en: On Windows systems, the path separator is `\`, such as `C:\Users\User\Documents\myfile.txt`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 系统中，路径分隔符是 `\`，例如 `C:\Users\User\Documents\myfile.txt`。
- en: Go provides a convenient way to work with file paths independently of the underlying
    operating system, ensuring cross-platform compatibility.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了一种方便的方式来处理文件路径，与底层操作系统无关，确保跨平台兼容性。
- en: Using the path/filepath package
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 path/filepath 包
- en: Go’s standard library includes the `path/filepath` package, which provides functions
    for manipulating file paths in a platform-independent manner. Let’s explore some
    common operations you can perform with this package.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的标准库包括 `path/filepath` 包，它提供了一组以平台无关的方式操作文件路径的函数。让我们探索一些可以使用此包执行的一些常见操作。
- en: Joining file paths
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接文件路径
- en: 'To join multiple parts of a file path into a single, correctly formatted path,
    we can use the `filepath.Join` function. It takes any number of arguments, concatenates
    them with the appropriate path separator, and returns the resulting file path:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要将文件路径的多个部分连接成一个单独的、正确格式的路径，我们可以使用 `filepath.Join` 函数。它接受任意数量的参数，使用适当的路径分隔符将它们连接起来，并返回结果文件路径：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this example, `filepath.Join` correctly handles the path separator based
    on the operating system. When we run this program, we should see this output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`filepath.Join` 正确处理了基于操作系统的路径分隔符。当我们运行此程序时，我们应该看到以下输出：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Cleaning file paths
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清理文件路径
- en: File paths can become messy over time due to concatenation or user input. The
    `filepath.Clean` function helps clean up and simplify file paths by removing redundant
    separators and references to the current directory (`.`) and the parent directory
    (`..`).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于连接或用户输入，文件路径可能会随着时间的推移而变得混乱。`filepath.Clean` 函数通过删除多余的分隔符和对当前目录（`.`）以及父目录（`..`）的引用来帮助清理和简化文件路径。
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this example, `filepath.Clean` transforms the unclean path into a cleaner
    and more readable path. When we run this program, we should see this output:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`filepath.Clean` 将不干净的路径转换为更干净、更易读的路径。当我们运行此程序时，我们应该看到以下输出：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Splitting file paths
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分割文件路径
- en: 'To extract directory and file components from a file path, we can use `filepath.Split`.
    In this example, `filepath.Split` separates the directory and file parts of a
    file path:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要从文件路径中提取目录和文件组件，我们可以使用 `filepath.Split`。在此示例中，`filepath.Split` 将文件路径的目录和文件部分分开：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When we run this program, we should see this output:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行此程序时，我们应该看到以下输出：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Traversing directories
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历目录
- en: You can use the `filepath.WalkDir` function to traverse directories and perform
    actions on files and directories within them. This function recursively explores
    the directory tree.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `filepath.WalkDir` 函数遍历目录并在其中对文件和目录执行操作。此函数递归地探索目录树。
- en: 'Let’s analyze the signature of this function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析这个函数的签名：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The first parameter is the root of a file tree we want to traverse. The second
    parameter is WalkdirFunc, which is a function type. When we look further, we can
    see what this type determines:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是我们想要遍历的文件树根。第二个参数是 WalkdirFunc，它是一个函数类型。当我们进一步查看时，我们可以看到这个类型决定了什么：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`path` is the argument containing the argument of `WalkDir` as a prefix. In
    other words, if `root` is `/home` and the current iteration is over the `Documents`
    directory, then `path` will contain the `/``home/Documents` string.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`path` 是包含 `WalkDir` 参数的参数，作为前缀。换句话说，如果 `root` 是 `/home` 并且当前迭代是在 `Documents`
    目录中，那么 `path` 将包含 `/home/Documents` 字符串。'
- en: The second parameter is a `DirEntry` interface. This interface is defined by
    four methods.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是 `DirEntry` 接口。此接口由四个方法定义。
- en: The `Name()` function returns the base name of the file or subdirectory, not
    the full path.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Name()` 函数返回文件或子目录的基本名称，而不是完整路径。'
- en: For instance, it would only return the file name `hello.go` and not the entire
    file path, such as `home/gopher/hello.go`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，它只会返回文件名 `hello.go`，而不会返回整个文件路径，例如 `home/gopher/hello.go`。
- en: The `IsDir()` function checks whether the given entry refers to a directory.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsDir()` 函数检查给定的条目是否指向一个目录。'
- en: The `Type()` method returns the type bits for the given entry, which is a subset
    of `FileMode` bits returned by the `FileMode.Type` method.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Type()` 方法返回给定条目的类型位，这是 `FileMode.Type` 方法返回的 `FileMode` 位的一个子集。'
- en: To get information about a file or directory, you can use the `Info()` function.
    It returns a `FileInfo` object that describes the file or directory. Keep in mind
    that the returned object may represent the file or directory as it was when the
    original directory was read, or as it is at the time of the call to `Info()`.
    If the file or directory has been deleted or renamed since the directory was read,
    Info may return an error `ErrNotExist`. If the entry you’re examining is a symbolic
    link, `Info()` will provide information about the link itself, rather than its
    target.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取文件或目录的信息，您可以使用`Info()`函数。它返回一个`FileInfo`对象，描述文件或目录。请注意，返回的对象可能代表原始目录读取时的文件或目录，或者是在调用`Info()`时的状态。如果文件或目录在读取目录后被删除或重命名，`Info`可能返回错误`ErrNotExist`。如果您正在检查的条目是一个符号链接，`Info()`将提供有关链接本身的信息，而不是其目标。
- en: When using the `WalkDir` function, the result returned by the function determines
    the behavior of the function. If the function returns the `SkipDir` value, `WalkDir`
    will skip the current directory (or path if it is a directory) and move on to
    the next one. If the function returns the `SkipAll` value, `WalkDir` will skip
    all remaining directories and files, and stop walking the tree. In case the function
    returns a non-nil error, `WalkDir` will stop entirely and return that error. The
    `err` argument reports an error related to the path, which signals that `WalkDir`
    will not walk into that directory. The function using the `WalkDir` can decide
    how to handle that error. As mentioned earlier, returning the error will cause
    `WalkDir` to stop walking the entire tree.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`WalkDir`函数时，函数返回的结果决定了函数的行为。如果函数返回`SkipDir`值，`WalkDir`将跳过当前目录（或路径，如果它是目录）并继续下一个。如果函数返回`SkipAll`值，`WalkDir`将跳过所有剩余的目录和文件，并停止遍历树。如果函数返回非空错误，`WalkDir`将完全停止并返回该错误。`err`参数报告与路径相关的错误，这表示`WalkDir`将不会进入该目录。使用`WalkDir`的函数可以决定如何处理该错误。如前所述，返回错误将导致`WalkDir`停止遍历整个树。
- en: To make it all clear, let’s expand the application of [*Chapter 3*](B21662_03.xhtml#_idTextAnchor089).
    Instead of just classifying the inputs as odd or even, this program will traverse
    a directory tree up to a maximum depth specified, and as a bonus feature, we will
    permit the user to redirect the output to a file.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使一切更加清晰，让我们扩展[*第3章*](B21662_03.xhtml#_idTextAnchor089)的应用。这个程序不仅将输入分类为奇数或偶数，它将遍历一个目录树，直到达到指定的最大深度，并且作为一个附加功能，我们将允许用户将输出重定向到文件。
- en: 'First of all, we need to add two new flags to our program in the `main` function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在`main`函数中为我们的程序添加两个新的标志：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code sets up the command-line flag (`-f`) with the default value and description,
    associates it with a variable (`outputFileName`), and then parses the command-line
    arguments to populate this variable with user-provided values. This allows the
    program to accept specific options when running from the command line.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码设置了命令行标志（`-f`）的默认值和描述，将其与一个变量（`outputFileName`）关联，然后解析命令行参数以用用户提供的值填充此变量。这允许程序在从命令行运行时接受特定选项。
- en: 'Now, let’s change the `NewCliConfig` function to set the default values for
    these two new variables:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将`NewCliConfig`函数更改为设置这两个新变量的默认值：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we should update our function app to this new output option:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该更新我们的函数app以使用这个新的输出选项：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This first part of the function app determines whether to create an output file
    based on the `cfg.OutputFile` configuration variable. If an output file is created
    successfully, it sets up `MultiWriter` to write to both the standard output and
    the file. If no output file is specified, it simply uses the standard output as
    `outputWriter`. This design allows for flexible output handling in a program.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 函数app的这一部分首先确定是否基于`cfg.OutputFile`配置变量创建输出文件。如果成功创建输出文件，它将设置`MultiWriter`以同时写入标准输出和文件。如果没有指定输出文件，它简单地使用标准输出作为`outputWriter`。这种设计允许程序灵活地处理输出。
- en: 'Lastly, we will traverse all directories. To exemplify how to skip directories,
    let’s assume that we want to always skip the `.``git` directory:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将遍历所有目录。为了说明如何跳过目录，让我们假设我们总是想跳过`.git`目录：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This part of the code iterates through a list of directories and recursively
    walks through each directory’s contents. For each directory it encounters, it
    prints the directory’s path to the specified output stream and handles errors
    that may occur during the walking process. As mentioned before, it skips processing
    the `.git` directories to avoid including version control metadata in the output.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分代码遍历一个目录列表，并递归地遍历每个目录的内容。对于它遇到的每个目录，它将目录的路径打印到指定的输出流，并处理在遍历过程中可能发生的错误。如前所述，它跳过处理`.git`目录，以避免将版本控制元数据包含在输出中。
- en: Once we know how to traverse our filesystem, we must explore more examples in
    different contexts.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道了如何遍历我们的文件系统，我们必须在不同的上下文中探索更多的例子。
- en: Symbolic links and unlinking files
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 符号链接和解除链接文件
- en: Oh, the good old Unix system, where names such as `link` and `unlink` provide
    that poetic sense of symmetry, luring you into a false sense of simplistic understanding,
    only to have you stumbling down a rabbit hole of system calls.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，那个古老的Unix系统，其中像`link`和`unlink`这样的名字提供了那种诗意的对称感，诱使你陷入一种简单化的理解错觉，结果却让你陷入系统调用的兔子洞。
- en: So, link and unlink should be as related as two peas in a pod, right? Well,
    they are... to a certain extent.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，链接和解除链接应该像豆荚里的两颗豌豆一样相关，对吧？嗯，它们确实如此...在某种程度上。
- en: Symbolic links – the shortcut of the file world
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 符号链接 – 文件世界的快捷方式
- en: Symbolic links are like the shortcuts on your desktop, only for files in the
    digital realm. Imagine your computer’s filesystem as a vast library filled with
    books (files), and you want a convenient way to access your favorite book (file)
    from multiple shelves (directories). Instead of running around the library, you
    put up a “shortcut” sign that says, *“Hey, the book you’re looking for is on that
    shelf!”* That’s a symbolic link! It’s like having a teleportation spell for your
    files, allowing you to instantly jump from one location to another without the
    need for a magic broomstick.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 符号链接就像你的桌面上的快捷方式，只是针对数字世界中的文件。想象一下，你的计算机文件系统就像一个装满了书籍（文件）的庞大图书馆，你想要一个方便的方法从多个书架（目录）中访问你最喜欢的书籍（文件）。你不需要在图书馆里四处跑，你只需挂上一个“快捷方式”标志，上面写着：“嘿，你正在寻找的书籍就在那个书架上！”那就是符号链接！它就像给你的文件施了一个传送咒语，让你能够瞬间从一个位置跳到另一个位置，而不需要一根魔法扫帚。
- en: Imagine you have a file called `important_document.txt` located in a directory
    called `/home/user/document`. You want to create a shortcut to this file in another
    directory called `/home/user/desktop` so you can access it quickly.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个名为`important_document.txt`的文件位于名为`/home/user/document`的目录中。你想要在另一个名为`/home/user/desktop`的目录中创建这个文件的快捷方式，以便你可以快速访问它。
- en: 'In the Linux command line, you can create a symbolic link using the `ln` command
    with the `-``s` option:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux命令行中，你可以使用带有`-s`选项的`ln`命令创建符号链接：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here’s what’s happening:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是发生的事情：
- en: '`ln`: This is the command for creating links'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ln`：这是创建链接的命令'
- en: '`-s`: This option specifies that we’re creating a symbolic link (symlink)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-s`：此选项指定我们正在创建一个符号链接（symlink）'
- en: '`/home/user/documents/important_document.txt`: This is the source file you
    want to link to'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/home/user/documents/important_document.txt`：这是你想要链接的源文件'
- en: '`/home/user/desktop/shortcut_to_document.txt`: This is the destination where
    you want to create the symbolic link'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/home/user/desktop/shortcut_to_document.txt`：这是你想要创建符号链接的目标位置'
- en: Now, when you open `/home/user/desktop/shortcut_to_document.txt`, it’s like
    clicking on a shortcut on your computer’s desktop, and it takes you straight to
    `important_document.txt`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你打开`/home/user/desktop/shortcut_to_document.txt`时，就像点击电脑桌面的快捷方式一样，它会直接带你到`important_document.txt`。
- en: 'We can achieve the same result in Go:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Go中可以取得相同的结果：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `os.Symlink` function is used to create the symlink. After running the
    `ls -l` command on the terminal, we should see something like the following output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.Symlink`函数用于创建符号链接。在终端上运行`ls -l`命令后，我们应该看到以下类似的输出：'
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As we discussed before, the first letter in the string `lrwxrwxrwx` denotes
    this file as a symlink.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，字符串`lrwxrwxrwx`中的第一个字母表示此文件是一个符号链接。
- en: Unlinking files – the great escape act
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解除链接文件 – 伟大的逃脱表演
- en: Unlinking files is like being a magician with a flair for dramatic exits. You’ve
    got a file that’s overstayed its welcome, and you want it to vanish in a puff
    of smoke. So, you grab your magician’s wand (the `unlink` command) and with a
    flick of your wrist, you shout, “Abracadabra, Hocus Pocus, Be Gone!” And just
    like that, the file disappears into thin air. It’s the ultimate disappearance
    act in the world of computing, leaving no trace behind. Now, if only you could
    do that with your laundry!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 删除文件就像是一个有戏剧性退出风格的魔术师。你有一个已经超时的文件，你希望它在一阵烟雾中消失。所以，你拿起你的魔术师的魔杖（`unlink` 命令），一挥手腕，大喊，“阿布拉卡达布拉，呼呼，消失吧！”
    就这样，文件就像空气一样消失了。这是计算世界中消失得无影无踪的终极表演，不留任何痕迹。现在，如果你能对你的洗衣物也这样做就好了！
- en: But remember, just like magic, unlinking files can be powerful, so use it wisely.
    You wouldn’t want to accidentally make your important documents vanish into the
    digital ether!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 但记住，就像魔法一样，删除文件可以是强大的，所以要明智地使用它。你不想不小心让你的重要文件消失在数字虚空中！
- en: 'Now, let’s say you want to perform the great vanishing act and remove that
    symbolic link you created earlier. You can use the `unlink` command (or rm for
    removing regular files):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你想执行伟大的消失魔法，并删除你之前创建的符号链接。你可以使用 `unlink` 命令（或用于删除常规文件的 `rm`）：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`rm` is used as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`rm` 的用法如下：'
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here’s what’s happening:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是发生的事情：
- en: '`unlink` or `rm`: These commands are used to remove files'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unlink` 或 `rm`：这些命令用于删除文件'
- en: '`/home/user/desktop/shortcut_to_document.txt`: This is the path to the symbolic
    link (or file) you want to remove'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/home/user/desktop/shortcut_to_document.txt`：这是你要删除的符号链接（或文件）的路径'
- en: 'We can achieve the same result using the `Remove` function from the `os` package:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `os` 包中的 `Remove` 函数达到相同的效果：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When we execute this program, the symbolic link disappears, just like magic!
    However, it’s important to note that if you used `os.Remove` to delete the link,
    it won’t affect the file the links refer to. It’s just removing the shortcut.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行这个程序时，符号链接就像魔法一样消失了！然而，重要的是要注意，如果你使用了 `os.Remove` 来删除链接，它不会影响链接指向的文件。它只是删除了快捷方式。
- en: Let’s create a CLI to check whether a symbolic link is dangling; in other words,
    the file it points to does not exist anymore.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个命令行界面（CLI）来检查符号链接是否悬空；换句话说，它指向的文件已经不再存在。
- en: 'We can do everything the same as we did in the last CLI app, with just a few
    changes:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像在最后一个 CLI 应用程序中做的那样做所有的事情，只需做几个改动：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let’s break down the most important parts:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解最重要的部分：
- en: '`if info.Mode()&os.ModeSymlink != 0 { ... }`: This checks whether the current
    file is a symbolic link. If it is, it enters this block to resolve and check the
    validity of the symlink.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if info.Mode()&os.ModeSymlink != 0 { ... }`: 这检查当前文件是否是符号链接。如果是，它进入这个块来解析和检查符号链接的有效性。'
- en: '`target, err := os.Readlink(path)`: This attempts to read the target of the
    symbolic link using `os.Readlink`. If an error occurs, it prints an error message
    indicating that reading the symlink failed.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target, err := os.Readlink(path)`: 这尝试使用 `os.Readlink` 读取符号链接的目标。如果发生错误，它将打印一条错误消息，表明读取符号链接失败。'
- en: 'It checks if the target of the symlink exists by using `os.Stat(target)`. If
    an error occurs during this check, it distinguishes between different types of
    errors:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过使用 `os.Stat(target)` 来检查符号链接的目标是否存在。如果在检查过程中发生错误，它将区分不同类型的错误：
- en: If the error indicates that the target does not exist (`os.IsNotExist(err)`),
    it prints a message indicating a broken symlink.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果错误表明目标不存在（`os.IsNotExist(err)`），它将打印一条消息，表明存在断开的符号链接。
- en: If the error is of another type, it prints an error message indicating that
    checking the symlink target failed.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果错误是其他类型，它将打印一条错误消息，表明检查符号链接目标失败。
- en: In a nutshell, `link` and `unlink` are the social coordinators of the UNIX filesystem
    world. `link` helps make new associations by adding a new name to a file, while
    `unlink` sends the file into the oblivion of deletion. They may seem like opposite
    sides of the same coin, but `unlink` is the harsh reality check to the merry matchmaking
    of `link`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`link` 和 `unlink` 是 UNIX 文件系统世界的社交协调者。`link` 通过给文件添加一个新名称来帮助建立新的关联，而 `unlink`
    则将文件送入删除的遗忘之地。它们可能看起来像是同一枚硬币的两面，但 `unlink` 是对 `link` 欢乐配对的残酷现实检查。
- en: Calculating directory size
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算目录大小
- en: 'One of the most common things to be done is to check the size of directories.
    How can we do it using all our knowledge in Go? We first need to create a function
    to calculate the size of a directory:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的事情之一是检查目录的大小。我们如何使用我们所有的 Go 知识来完成它？我们首先需要创建一个函数来计算目录的大小：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This function calculates the total size of all files within a given directory,
    including its subdirectories. Let’s understand how this function works:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数计算给定目录及其子目录中所有文件的总大小。让我们了解这个函数是如何工作的：
- en: '`func calculateDirSize(path string) (int64, error)`: This function takes a
    single argument path, which is the path to the directory for which you want to
    calculate the size. It returns two values: an `int64` value representing the size
    in bytes and an `error` value indicating whether any errors occurred during the
    calculation.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func calculateDirSize(path string) (int64, error)`：这个函数接受一个参数 path，它是你想要计算大小的目录的路径。它返回两个值：一个表示字节数的
    `int64` 值和一个表示在计算过程中是否发生错误的 `error` 值。'
- en: It uses the `filepath.Walk` function to traverse the directory tree starting
    from the specified path. For each file or directory encountered during the walk,
    the provided callback function is called.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用 `filepath.Walk` 函数从指定的路径开始遍历目录树。在遍历过程中遇到的每个文件或目录，都会调用提供的回调函数。
- en: '`if !fileInfo.IsDir() { size += fileInfo.Size() }`: This checks whether the
    current item is not a directory (i.e., it’s a file). If it’s a file, it adds the
    size of the file (`fileInfo.Size()`) to the `size` variable. This is how it accumulates
    the total size of all files.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if !fileInfo.IsDir() { size += fileInfo.Size() }`：这检查当前项是否不是目录（即，它是一个文件）。如果是文件，它将文件的大小（`fileInfo.Size()`）添加到
    `size` 变量中。这就是它如何累积所有文件的总大小。'
- en: After the `filepath.Walk` function completes its traversal, it checks if there
    was any error during the walk (`if err != nil { return 0, err }`) and returns
    the accumulated size if there were no errors.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `filepath.Walk` 函数完成遍历后，它会检查遍历过程中是否有错误（`if err != nil { return 0, err }`），如果没有错误，则返回累积的大小。
- en: The `calculateDirSize` could act as an invaluable part of a more general application
    where it is employed to compute the sizes of various directories listed within
    the `directories` slice. In the process, these sizes are converted into different
    units such as bytes, kilobytes, megabytes, or gigabytes, offering a more human-readable
    representation. The results are then presented to the user through an output stream.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculateDirSize` 可以作为一个更通用应用程序中不可或缺的部分，在该应用程序中，它被用来计算 `directories` 切片中列出的各种目录的大小。在这个过程中，这些大小被转换为不同的单位，如字节、千字节、兆字节或吉字节，提供更易于阅读的表示。然后，这些结果通过输出流呈现给用户。'
- en: 'Here’s a snapshot of how this function is applied within the larger context
    of the application:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何在应用程序的更大上下文中应用这个函数的一个快照：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding code calculates the sizes of directories listed in the `directories`
    slice, converts those sizes to different units (bytes, kilobytes, megabytes, or
    gigabytes), and then prints the results.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码计算了 `directories` 切片中列出的目录的大小，将这些大小转换为不同的单位（字节、千字节、兆字节或吉字节），然后打印结果。
- en: Finding duplicate files
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找重复文件
- en: 'In the realm of data management, a common challenge is identifying and managing
    duplicate files. In our example, the `findDuplicateFiles` function became a tool
    of choice for this task. Its purpose was straightforward: to locate and catalog
    duplicate files within a given directory. Let’s investigate how this function
    operates:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据管理领域，一个常见的挑战是识别和管理重复文件。在我们的例子中，`findDuplicateFiles` 函数成为了这项任务的优选工具。其目的是直接的：在给定的目录中定位和编目重复文件。让我们来探究这个函数是如何工作的：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can observe the following key features:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以观察到以下关键特性：
- en: '`filepath.Walk`: The function uses `filepath.Walk` to systematically explore
    all files within the specified directory (`rootDir`) and its subdirectories. This
    traversal covers every nook and cranny of the filesystem.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filepath.Walk`：该函数使用 `filepath.Walk` 来系统地遍历指定目录（`rootDir`）及其子目录中的所有文件。这种遍历覆盖了文件系统的每一个角落。'
- en: '**File hashing**: To identify duplicates, each file is hashed. This hashing
    process transforms file contents into unique hash values. Identical files will
    yield the same hash, allowing for easy identification.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件哈希**：为了识别重复文件，每个文件都会进行哈希处理。这个哈希过程将文件内容转换为唯一的哈希值。相同的文件将产生相同的哈希值，这使得识别变得容易。'
- en: '`duplicates` is employed to keep track of the duplicate files. The map associates
    each unique hash with an array of file paths that share the same hash. Files with
    distinct hashes are not considered duplicates.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`duplicates`用于跟踪重复文件。该映射将每个唯一的哈希值与具有相同哈希值的文件路径数组关联起来。具有不同哈希值的文件不被视为重复文件。'
- en: 'To apply this function in practice, let’s utilize it to scan multiple directories
    for duplicate files. Here’s an overview of the process:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在实际中应用这个函数，让我们利用它来扫描多个目录以查找重复文件。以下是过程的概述：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `findDuplicateFiles` function recursively explores a directory and its subdirectories,
    hashes non-directory files, and organizes them into groups based on their hash
    values. This allows for the efficient identification of duplicate files within
    the specified directory structure.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`findDuplicateFiles`函数递归地探索目录及其子目录，对非目录文件进行哈希处理，并根据它们的哈希值将它们组织成组。这允许在指定的目录结构中有效地识别重复文件。'
- en: 'This is the code for the `computeFileHash` function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`computeFileHash`函数的代码：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `computeFileHash` function opens a file, calculates the MD5 hash of its
    contents, converts the hash to a hexadecimal string, and returns it. This function
    is useful for generating unique identifiers (hashes) for files, which can be used
    for various purposes, including identifying duplicate files, verifying data integrity,
    or indexing files based on their content. In the last section, we will explore
    advanced optimization when we’re working with files.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`computeFileHash`函数打开一个文件，计算其内容的MD5哈希值，将哈希值转换为十六进制字符串，并返回它。这个函数对于生成文件的唯一标识符（哈希值）非常有用，可用于各种目的，包括识别重复文件、验证数据完整性或根据内容索引文件。在最后一节中，我们将探讨在处理文件时的高级优化。'
- en: Optimizing filesystem operations
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化文件系统操作
- en: System programming often faces challenges when it comes to optimizing file operations,
    especially when dealing with data that exceeds the available memory capacity.
    One effective solution to this problem is the use of memory-mapped files (mmap),
    which, when utilized properly, can significantly enhance the efficiency of file
    operations.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 系统编程在优化文件操作时经常面临挑战，尤其是在处理超出可用内存容量的数据时。解决这个问题的一个有效方法是使用内存映射文件（mmap），如果正确使用，可以显著提高文件操作的效率。
- en: Memory-mapped files (`mmap`) provide a viable approach to address this issue.
    By directly mapping files into memory, mmap simplifies the process of working
    with files. Essentially, the operating system manages the disk writes, while the
    program interacts with the data in memory.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 内存映射文件（`mmap`）提供了一种解决此问题的可行方法。通过直接将文件映射到内存中，mmap简化了与文件一起工作的过程。本质上，操作系统管理磁盘写入，而程序与内存中的数据交互。
- en: A straightforward demonstration in the Go programming language illustrates how
    mmap can efficiently handle file operations, even when dealing with large files.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Go编程语言的一个简单示例演示了mmap如何有效地处理文件操作，即使处理大文件时也是如此。
- en: 'First, we need to open a large file:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要打开一个大文件：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we should read the file metadata for using the `mmap` syscall:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该读取文件的元数据以使用`mmap`系统调用：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we can use the memory mapping:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用内存映射：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let’s take the following line from the preceding code block:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从前面的代码块中取出以下一行：
- en: '`data, err := syscall.Mmap(int(file.Fd()), 0, int(fileSize), syscall.PROT_READ|syscall.PROT_WRITE,
    syscall.MAP_SHARED)`. There are two main areas of this code to pay attention to:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`data, err := syscall.Mmap(int(file.Fd()), 0, int(fileSize), syscall.PROT_READ|syscall.PROT_WRITE,
    syscall.MAP_SHARED)`. 这段代码有两个主要需要注意的区域：'
- en: '`syscall.Mmap` is used to map the file into memory. It takes the following
    arguments:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syscall.Mmap`用于将文件映射到内存中。它接受以下参数：'
- en: '`int(file.Fd())`: This extracts the file descriptor (an integer representing
    the opened file) from the file object. The `file.Fd()` method returns the file
    descriptor.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int(file.Fd())`：这从文件对象中提取文件描述符（表示打开文件的整数）。`file.Fd()`方法返回文件描述符。'
- en: '`0`: This represents the offset within the file where the mapping should begin.
    In this case, it starts at the beginning of the file (offset `0`).`int(fileSize)`:
    The length of the mapping, specified as an integer representing the size of the
    file (`fileSize`). This determines how much of the file will be mapped into memory.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`：这表示映射应开始的文件内的偏移量。在这种情况下，它从文件开始（偏移量`0`）。`int(fileSize)`：映射的长度，指定为表示文件大小的整数（`fileSize`）。这决定了将映射到内存中的文件部分。'
- en: '`syscall.PROT_READ|syscall.PROT_WRITE`: This sets the protection modes for
    the mapped memory. `PROT_READ` allows read access, and `PROT_WRITE` allows write
    access.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syscall.PROT_READ|syscall.PROT_WRITE`：这设置了映射内存的保护模式。`PROT_READ`允许读取访问，而`PROT_WRITE`允许写入访问。'
- en: '`syscall.MAP_SHARED`: This specifies that the mapped memory is shared among
    multiple processes. Changes made to the memory will be reflected in the file,
    and vice versa.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syscall.MAP_SHARED`：这指定了映射的内存被多个进程共享。对内存的更改将在文件中反映出来，反之亦然。'
- en: '`defer syscall.Munmap(data)`:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defer syscall.Munmap(data)`：'
- en: Assuming the memory mapping operation was successful (i.e., no error occurred),
    this `defer` statement schedules the `syscall.Munmap` function to be called when
    the surrounding function returns.
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设内存映射操作成功（即没有发生错误），这个`defer`语句安排在周围函数返回时调用`syscall.Munmap`函数。
- en: '`syscall.Munmap` is used to unmap the memory region previously mapped with
    `syscall.Mmap`. It ensures that the mapped memory is released properly when it
    is no longer needed.'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syscall.Munmap`用于取消映射之前使用`syscall.Mmap`映射的内存区域。它确保在不再需要映射的内存时，映射的内存被正确释放。'
- en: 'Once the data is memory mapped, we can modify the data:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据被内存映射，我们就可以修改数据：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With this knowledge available, we can interact with large files practically
    with no concerns about memory availability.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在拥有这些知识的情况下，我们可以毫无顾虑地与大型文件进行交互，无需担心内存的可用性。
- en: Out-of-memory safety
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 内存不足安全性
- en: It’s important to note that using a file-backed mapping is the appropriate choice
    for mmap, as opposed to an anonymous mapping. If you intend to make modifications
    to the mapped memory and have those changes written back to the file, then a shared
    mapping is necessary. With a file-backed, shared mapping, concerns about the Out-of-Memory
    (OOM) killer are alleviated, if your process operates in a 64-bit environment.
    Even in a non-64-bit environment, the issue would be related to addressing space
    limitations rather than RAM constraints, so the OOM killer would not be a concern;
    instead, your mmap operation would simply fail gracefully.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，对于mmap来说，使用基于文件的映射是合适的选择，而不是匿名映射。如果你打算修改映射的内存并将这些更改写回文件，那么就需要一个共享映射。在64位环境中，使用基于文件的共享映射可以减轻对内存不足（OOM）杀手的担忧。即使在非64位环境中，问题也会与地址空间限制有关，而不是RAM限制，因此OOM杀手不会成为问题；相反，你的mmap操作将简单地优雅失败。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Congratulations on completing [*Chapter 4*](B21662_04.xhtml#_idTextAnchor110)!
    In this chapter, we explored file and directory operations in Go. We covered essential
    topics, from identifying unsafe files and directory permissions to optimizing
    filesystem operations.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你完成[*第4章*](B21662_04.xhtml#_idTextAnchor110)！在本章中，我们探讨了Go中的文件和目录操作。我们涵盖了从识别不安全文件和目录权限到优化文件系统操作的基本主题。
- en: As we close this chapter, you now have a solid foundation in handling files
    and directories in Go, equipped with the knowledge and skills to build secure
    and efficient file-related applications. You’ve learned not just the theory but
    also the practical coding techniques that you can apply directly to your projects.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本章的结束，你现在在Go中处理文件和目录方面有了坚实的基础，拥有了构建安全高效文件相关应用程序的知识和技能。你不仅学到了理论，还学到了可以直接应用于你项目的实际编码技巧。
- en: Moving forward, in the next chapter, we advance even more on system programming
    concepts, covering inter-process communication.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将进一步探讨系统编程概念，涵盖进程间通信。
