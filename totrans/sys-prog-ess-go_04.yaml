- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File and Directory Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to work with files and folders using Go.
    We will explore many valuable topics including checking file and folder permissions,
    working with links, and finding the size of folders.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will do hands-on activities. You will write and run code
    that works with files and folders. This way, you will learn practical skills for
    real-world programming tasks.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will know how to manage files and folders in
    Go. You can check and fix file and folder permissions, find and manage files and
    folders, and do many other practical tasks. This knowledge will help you create
    secure and effective file-related programs in Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying unsafe file and directory permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning directories in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symbolic links and unlinking files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating directory size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding duplicate files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing filesystem operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find this chapter source code at [https://github.com/PacktPublishing/System-Programming-Essentials-with-Go/tree/main/ch4](https://github.com/PacktPublishing/System-Programming-Essentials-with-Go/tree/main/ch4)
  prefs: []
  type: TYPE_NORMAL
- en: Identifying unsafe file and directory permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Retrieving information about a file or directory is a common task in programming
    and Go provides a platform-independent way to perform this operation. The `os.Stat`
    function is an essential part of the `os` package, which acts as an interface
    to operating system functionality. When called, the `os.Stat` function returns
    a `FileInfo` interface and an error. The `FileInfo` interface contains various
    file metadata, such as its name, size, permissions, and modification times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the signature of the `os.Stat` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The name parameter is the path to the file or directory you want to obtain information
    about.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s discover how we could use `os.Stat` to get information about a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, in the main function, we call `os.Stat` with the path to a
    file named `example.txt`. When `os.Stat` returns an error, we “panic” the error
    and exit the program. Otherwise, we use the `FileInfo` methods (`Name`, `Size`,
    `Mode`, and `ModTime`) to print out some information about the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to check the error returned by `os.Stat`. If the error is non-nil,
    it’s likely because the file doesn’t exist or there’s a permission problem. A
    common way to check for a non-existent file is to use the `os.IsNotExist` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we first call the `os.Stat` function to check the status of a
    file. If an error occurs during this operation, we check whether the error is
    because the file doesn’t exist by using the `os.IsNotExist` function. If it is
    due to the file not existing, we display a message. However, if the error is for
    some other reason, we panic it and terminate the program. Once we know how to
    read file metadata, we can start to explore and understand files and their permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Files and permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Linux, files are categorized into various types, each serving a unique purpose.
    Here’s a rundown of common Linux file types along with their correlation to the
    `FileMode` bits returned from `FileInfo.Mode()` call.
  prefs: []
  type: TYPE_NORMAL
- en: Regular files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Regular files contain data such as text, images, or programs. They are denoted
    by `-` in the first character of the file listing. In Go, a regular file is represented
    by the absence of other file-type bits. You can check whether a file is a regular
    file using the `IsRegular` method on `FileMode`.
  prefs: []
  type: TYPE_NORMAL
- en: Directories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Directories hold other files and directories. They are denoted by `d` in the
    first character of the file listing. The `os.ModeDir` bit represents a directory.
    You can check whether a file is a directory using the `IsDir()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic links
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Symbolic links are pointers to other files. They are denoted by `l` in the first
    character of the file listing. The `os.ModeSymlink` bit represents a symbolic
    link. Unfortunately, `FileMode` in Go does not directly expose a method to check
    for symbolic links, but we can check whether `FileMode&os.ModeSymlink` is non-zero.
  prefs: []
  type: TYPE_NORMAL
- en: Named pipes (FIFOs)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Named pipes are mechanisms for inter-process communication, denoted by `p` in
    the first character of the file listing. The `os.ModeNamedPipe` bit represents
    a named pipe.
  prefs: []
  type: TYPE_NORMAL
- en: Character devices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Character devices provide unbuffered, direct access to hardware devices, and
    are denoted by `c` in the first character of the file listing. The `os.ModeCharDevice`
    bit represents a character device.
  prefs: []
  type: TYPE_NORMAL
- en: Block devices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Block devices provide buffered access to hardware devices and are denoted by
    `b` in the first character of the file listing. Go does not have a direct `FileMode`
    bit for block devices. However, you might still be able to work with block devices
    using the `os` package’s file operations.
  prefs: []
  type: TYPE_NORMAL
- en: Sockets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sockets are endpoints for communication, denoted by `s` in the first character
    of the file listing. The `os.ModeSocket` bit represents a socket.
  prefs: []
  type: TYPE_NORMAL
- en: The `FileMode` type in Go encapsulates these bits and provides methods and constants
    for working with file types and permissions, making it easier to perform file
    operations in a cross-platform way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Linux, the permissions system is a crucial aspect of file and directory
    security. It determines who can access, modify, or execute files and directories.
    Permissions are represented by a combination of read (`r`), write (`w`), and execute
    (`x`) permissions for three categories of users: owner, group, and others.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s refresh what these permissions represent:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Read (r)**: Allows reading or viewing the file’s contents or listing a directory’s
    contents'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Write (w)**: Allows modifying or deleting a file’s contents or adding/removing
    files in a directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Execute (x)**: Allows executing a file or accessing the contents of a directory
    (if you have execute permission on the directory itself)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux file permissions are typically displayed in the form of a 9-character
    string, such as `rwxr-xr—`, where the first three characters represent permissions
    for the owner, the next three for the group, and the last three for others.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we combine the file type and its permissions, we form the 10-character
    string that the `ls -l` command returns in the first column of the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we take a closer look at `directory1`, we can determine the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It’s a directory because of the first letter `d`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The owner has permission to read, write, and execute, given the first triplet
    `rwx`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The group and the user can read and execute, given the same string `r-x`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To check file permissions in Go, you can use the `os` package to inspect file
    and directory properties. Here’s a simple example of how to check file permissions
    using Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use the `os.Stat` to retrieve file information, and then
    we extract the permissions using `fileInfo.Mode().Perm()`. The `Perm()` method
    returns a `os.FileMode` value, which we format as an octal string using `fmt.Sprintf`.
  prefs: []
  type: TYPE_NORMAL
- en: You may ask yourself, *why an* *octal string?*
  prefs: []
  type: TYPE_NORMAL
- en: Octal notation provides a compact and human-readable way to represent file permissions.
    The octal digit is the sum of the values for read (4), write (2), and execute
    (1). For example, `rwx` (read, write, execute) is 7 (4+2+1), `r-x` (read, no write,
    execute) is 5 (4+0+1), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: So, for example, the permissions `-rwxr-xr--` can be succinctly represented
    as 755 in octal.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The convention of using octal representation for permissions dates to the early
    days of Unix. Over the decades, this convention has been retained for consistency
    and compatibility with older scripts and utilities.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning directories in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go provides a robust and platform-independent way to work with file and directory
    paths, making it an excellent choice for building file-related applications. We
    will cover topics such as fil- path joining, cleaning, and traversal, along with
    some best practices for handling file paths effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding file paths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we dive into manipulating file paths in Go, it’s important to understand
    the basics. A file path is a string representation of a file or directory’s location
    within a filesystem. File paths typically consist of one or more directory names
    separated by a path separator, which varies between operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: For example, on Unix-like systems (Linux, macOS), the path separator is `/`,
    such as `/home/user/documents/myfile.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: On Windows systems, the path separator is `\`, such as `C:\Users\User\Documents\myfile.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: Go provides a convenient way to work with file paths independently of the underlying
    operating system, ensuring cross-platform compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Using the path/filepath package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go’s standard library includes the `path/filepath` package, which provides functions
    for manipulating file paths in a platform-independent manner. Let’s explore some
    common operations you can perform with this package.
  prefs: []
  type: TYPE_NORMAL
- en: Joining file paths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To join multiple parts of a file path into a single, correctly formatted path,
    we can use the `filepath.Join` function. It takes any number of arguments, concatenates
    them with the appropriate path separator, and returns the resulting file path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `filepath.Join` correctly handles the path separator based
    on the operating system. When we run this program, we should see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Cleaning file paths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: File paths can become messy over time due to concatenation or user input. The
    `filepath.Clean` function helps clean up and simplify file paths by removing redundant
    separators and references to the current directory (`.`) and the parent directory
    (`..`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `filepath.Clean` transforms the unclean path into a cleaner
    and more readable path. When we run this program, we should see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Splitting file paths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To extract directory and file components from a file path, we can use `filepath.Split`.
    In this example, `filepath.Split` separates the directory and file parts of a
    file path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this program, we should see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Traversing directories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use the `filepath.WalkDir` function to traverse directories and perform
    actions on files and directories within them. This function recursively explores
    the directory tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s analyze the signature of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter is the root of a file tree we want to traverse. The second
    parameter is WalkdirFunc, which is a function type. When we look further, we can
    see what this type determines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`path` is the argument containing the argument of `WalkDir` as a prefix. In
    other words, if `root` is `/home` and the current iteration is over the `Documents`
    directory, then `path` will contain the `/``home/Documents` string.'
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter is a `DirEntry` interface. This interface is defined by
    four methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `Name()` function returns the base name of the file or subdirectory, not
    the full path.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, it would only return the file name `hello.go` and not the entire
    file path, such as `home/gopher/hello.go`.
  prefs: []
  type: TYPE_NORMAL
- en: The `IsDir()` function checks whether the given entry refers to a directory.
  prefs: []
  type: TYPE_NORMAL
- en: The `Type()` method returns the type bits for the given entry, which is a subset
    of `FileMode` bits returned by the `FileMode.Type` method.
  prefs: []
  type: TYPE_NORMAL
- en: To get information about a file or directory, you can use the `Info()` function.
    It returns a `FileInfo` object that describes the file or directory. Keep in mind
    that the returned object may represent the file or directory as it was when the
    original directory was read, or as it is at the time of the call to `Info()`.
    If the file or directory has been deleted or renamed since the directory was read,
    Info may return an error `ErrNotExist`. If the entry you’re examining is a symbolic
    link, `Info()` will provide information about the link itself, rather than its
    target.
  prefs: []
  type: TYPE_NORMAL
- en: When using the `WalkDir` function, the result returned by the function determines
    the behavior of the function. If the function returns the `SkipDir` value, `WalkDir`
    will skip the current directory (or path if it is a directory) and move on to
    the next one. If the function returns the `SkipAll` value, `WalkDir` will skip
    all remaining directories and files, and stop walking the tree. In case the function
    returns a non-nil error, `WalkDir` will stop entirely and return that error. The
    `err` argument reports an error related to the path, which signals that `WalkDir`
    will not walk into that directory. The function using the `WalkDir` can decide
    how to handle that error. As mentioned earlier, returning the error will cause
    `WalkDir` to stop walking the entire tree.
  prefs: []
  type: TYPE_NORMAL
- en: To make it all clear, let’s expand the application of [*Chapter 3*](B21662_03.xhtml#_idTextAnchor089).
    Instead of just classifying the inputs as odd or even, this program will traverse
    a directory tree up to a maximum depth specified, and as a bonus feature, we will
    permit the user to redirect the output to a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to add two new flags to our program in the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This code sets up the command-line flag (`-f`) with the default value and description,
    associates it with a variable (`outputFileName`), and then parses the command-line
    arguments to populate this variable with user-provided values. This allows the
    program to accept specific options when running from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s change the `NewCliConfig` function to set the default values for
    these two new variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we should update our function app to this new output option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This first part of the function app determines whether to create an output file
    based on the `cfg.OutputFile` configuration variable. If an output file is created
    successfully, it sets up `MultiWriter` to write to both the standard output and
    the file. If no output file is specified, it simply uses the standard output as
    `outputWriter`. This design allows for flexible output handling in a program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we will traverse all directories. To exemplify how to skip directories,
    let’s assume that we want to always skip the `.``git` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This part of the code iterates through a list of directories and recursively
    walks through each directory’s contents. For each directory it encounters, it
    prints the directory’s path to the specified output stream and handles errors
    that may occur during the walking process. As mentioned before, it skips processing
    the `.git` directories to avoid including version control metadata in the output.
  prefs: []
  type: TYPE_NORMAL
- en: Once we know how to traverse our filesystem, we must explore more examples in
    different contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic links and unlinking files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Oh, the good old Unix system, where names such as `link` and `unlink` provide
    that poetic sense of symmetry, luring you into a false sense of simplistic understanding,
    only to have you stumbling down a rabbit hole of system calls.
  prefs: []
  type: TYPE_NORMAL
- en: So, link and unlink should be as related as two peas in a pod, right? Well,
    they are... to a certain extent.
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic links – the shortcut of the file world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Symbolic links are like the shortcuts on your desktop, only for files in the
    digital realm. Imagine your computer’s filesystem as a vast library filled with
    books (files), and you want a convenient way to access your favorite book (file)
    from multiple shelves (directories). Instead of running around the library, you
    put up a “shortcut” sign that says, *“Hey, the book you’re looking for is on that
    shelf!”* That’s a symbolic link! It’s like having a teleportation spell for your
    files, allowing you to instantly jump from one location to another without the
    need for a magic broomstick.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you have a file called `important_document.txt` located in a directory
    called `/home/user/document`. You want to create a shortcut to this file in another
    directory called `/home/user/desktop` so you can access it quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Linux command line, you can create a symbolic link using the `ln` command
    with the `-``s` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s what’s happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ln`: This is the command for creating links'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-s`: This option specifies that we’re creating a symbolic link (symlink)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/home/user/documents/important_document.txt`: This is the source file you
    want to link to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/home/user/desktop/shortcut_to_document.txt`: This is the destination where
    you want to create the symbolic link'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, when you open `/home/user/desktop/shortcut_to_document.txt`, it’s like
    clicking on a shortcut on your computer’s desktop, and it takes you straight to
    `important_document.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can achieve the same result in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `os.Symlink` function is used to create the symlink. After running the
    `ls -l` command on the terminal, we should see something like the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As we discussed before, the first letter in the string `lrwxrwxrwx` denotes
    this file as a symlink.
  prefs: []
  type: TYPE_NORMAL
- en: Unlinking files – the great escape act
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlinking files is like being a magician with a flair for dramatic exits. You’ve
    got a file that’s overstayed its welcome, and you want it to vanish in a puff
    of smoke. So, you grab your magician’s wand (the `unlink` command) and with a
    flick of your wrist, you shout, “Abracadabra, Hocus Pocus, Be Gone!” And just
    like that, the file disappears into thin air. It’s the ultimate disappearance
    act in the world of computing, leaving no trace behind. Now, if only you could
    do that with your laundry!
  prefs: []
  type: TYPE_NORMAL
- en: But remember, just like magic, unlinking files can be powerful, so use it wisely.
    You wouldn’t want to accidentally make your important documents vanish into the
    digital ether!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s say you want to perform the great vanishing act and remove that
    symbolic link you created earlier. You can use the `unlink` command (or rm for
    removing regular files):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`rm` is used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s what’s happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '`unlink` or `rm`: These commands are used to remove files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/home/user/desktop/shortcut_to_document.txt`: This is the path to the symbolic
    link (or file) you want to remove'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can achieve the same result using the `Remove` function from the `os` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When we execute this program, the symbolic link disappears, just like magic!
    However, it’s important to note that if you used `os.Remove` to delete the link,
    it won’t affect the file the links refer to. It’s just removing the shortcut.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a CLI to check whether a symbolic link is dangling; in other words,
    the file it points to does not exist anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do everything the same as we did in the last CLI app, with just a few
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down the most important parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if info.Mode()&os.ModeSymlink != 0 { ... }`: This checks whether the current
    file is a symbolic link. If it is, it enters this block to resolve and check the
    validity of the symlink.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`target, err := os.Readlink(path)`: This attempts to read the target of the
    symbolic link using `os.Readlink`. If an error occurs, it prints an error message
    indicating that reading the symlink failed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It checks if the target of the symlink exists by using `os.Stat(target)`. If
    an error occurs during this check, it distinguishes between different types of
    errors:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the error indicates that the target does not exist (`os.IsNotExist(err)`),
    it prints a message indicating a broken symlink.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the error is of another type, it prints an error message indicating that
    checking the symlink target failed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a nutshell, `link` and `unlink` are the social coordinators of the UNIX filesystem
    world. `link` helps make new associations by adding a new name to a file, while
    `unlink` sends the file into the oblivion of deletion. They may seem like opposite
    sides of the same coin, but `unlink` is the harsh reality check to the merry matchmaking
    of `link`.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating directory size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most common things to be done is to check the size of directories.
    How can we do it using all our knowledge in Go? We first need to create a function
    to calculate the size of a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This function calculates the total size of all files within a given directory,
    including its subdirectories. Let’s understand how this function works:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func calculateDirSize(path string) (int64, error)`: This function takes a
    single argument path, which is the path to the directory for which you want to
    calculate the size. It returns two values: an `int64` value representing the size
    in bytes and an `error` value indicating whether any errors occurred during the
    calculation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses the `filepath.Walk` function to traverse the directory tree starting
    from the specified path. For each file or directory encountered during the walk,
    the provided callback function is called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if !fileInfo.IsDir() { size += fileInfo.Size() }`: This checks whether the
    current item is not a directory (i.e., it’s a file). If it’s a file, it adds the
    size of the file (`fileInfo.Size()`) to the `size` variable. This is how it accumulates
    the total size of all files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the `filepath.Walk` function completes its traversal, it checks if there
    was any error during the walk (`if err != nil { return 0, err }`) and returns
    the accumulated size if there were no errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `calculateDirSize` could act as an invaluable part of a more general application
    where it is employed to compute the sizes of various directories listed within
    the `directories` slice. In the process, these sizes are converted into different
    units such as bytes, kilobytes, megabytes, or gigabytes, offering a more human-readable
    representation. The results are then presented to the user through an output stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a snapshot of how this function is applied within the larger context
    of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code calculates the sizes of directories listed in the `directories`
    slice, converts those sizes to different units (bytes, kilobytes, megabytes, or
    gigabytes), and then prints the results.
  prefs: []
  type: TYPE_NORMAL
- en: Finding duplicate files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the realm of data management, a common challenge is identifying and managing
    duplicate files. In our example, the `findDuplicateFiles` function became a tool
    of choice for this task. Its purpose was straightforward: to locate and catalog
    duplicate files within a given directory. Let’s investigate how this function
    operates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can observe the following key features:'
  prefs: []
  type: TYPE_NORMAL
- en: '`filepath.Walk`: The function uses `filepath.Walk` to systematically explore
    all files within the specified directory (`rootDir`) and its subdirectories. This
    traversal covers every nook and cranny of the filesystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File hashing**: To identify duplicates, each file is hashed. This hashing
    process transforms file contents into unique hash values. Identical files will
    yield the same hash, allowing for easy identification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`duplicates` is employed to keep track of the duplicate files. The map associates
    each unique hash with an array of file paths that share the same hash. Files with
    distinct hashes are not considered duplicates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To apply this function in practice, let’s utilize it to scan multiple directories
    for duplicate files. Here’s an overview of the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `findDuplicateFiles` function recursively explores a directory and its subdirectories,
    hashes non-directory files, and organizes them into groups based on their hash
    values. This allows for the efficient identification of duplicate files within
    the specified directory structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the code for the `computeFileHash` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `computeFileHash` function opens a file, calculates the MD5 hash of its
    contents, converts the hash to a hexadecimal string, and returns it. This function
    is useful for generating unique identifiers (hashes) for files, which can be used
    for various purposes, including identifying duplicate files, verifying data integrity,
    or indexing files based on their content. In the last section, we will explore
    advanced optimization when we’re working with files.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing filesystem operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: System programming often faces challenges when it comes to optimizing file operations,
    especially when dealing with data that exceeds the available memory capacity.
    One effective solution to this problem is the use of memory-mapped files (mmap),
    which, when utilized properly, can significantly enhance the efficiency of file
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: Memory-mapped files (`mmap`) provide a viable approach to address this issue.
    By directly mapping files into memory, mmap simplifies the process of working
    with files. Essentially, the operating system manages the disk writes, while the
    program interacts with the data in memory.
  prefs: []
  type: TYPE_NORMAL
- en: A straightforward demonstration in the Go programming language illustrates how
    mmap can efficiently handle file operations, even when dealing with large files.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to open a large file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we should read the file metadata for using the `mmap` syscall:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use the memory mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take the following line from the preceding code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data, err := syscall.Mmap(int(file.Fd()), 0, int(fileSize), syscall.PROT_READ|syscall.PROT_WRITE,
    syscall.MAP_SHARED)`. There are two main areas of this code to pay attention to:'
  prefs: []
  type: TYPE_NORMAL
- en: '`syscall.Mmap` is used to map the file into memory. It takes the following
    arguments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int(file.Fd())`: This extracts the file descriptor (an integer representing
    the opened file) from the file object. The `file.Fd()` method returns the file
    descriptor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0`: This represents the offset within the file where the mapping should begin.
    In this case, it starts at the beginning of the file (offset `0`).`int(fileSize)`:
    The length of the mapping, specified as an integer representing the size of the
    file (`fileSize`). This determines how much of the file will be mapped into memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`syscall.PROT_READ|syscall.PROT_WRITE`: This sets the protection modes for
    the mapped memory. `PROT_READ` allows read access, and `PROT_WRITE` allows write
    access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`syscall.MAP_SHARED`: This specifies that the mapped memory is shared among
    multiple processes. Changes made to the memory will be reflected in the file,
    and vice versa.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defer syscall.Munmap(data)`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assuming the memory mapping operation was successful (i.e., no error occurred),
    this `defer` statement schedules the `syscall.Munmap` function to be called when
    the surrounding function returns.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`syscall.Munmap` is used to unmap the memory region previously mapped with
    `syscall.Mmap`. It ensures that the mapped memory is released properly when it
    is no longer needed.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the data is memory mapped, we can modify the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: With this knowledge available, we can interact with large files practically
    with no concerns about memory availability.
  prefs: []
  type: TYPE_NORMAL
- en: Out-of-memory safety
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that using a file-backed mapping is the appropriate choice
    for mmap, as opposed to an anonymous mapping. If you intend to make modifications
    to the mapped memory and have those changes written back to the file, then a shared
    mapping is necessary. With a file-backed, shared mapping, concerns about the Out-of-Memory
    (OOM) killer are alleviated, if your process operates in a 64-bit environment.
    Even in a non-64-bit environment, the issue would be related to addressing space
    limitations rather than RAM constraints, so the OOM killer would not be a concern;
    instead, your mmap operation would simply fail gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations on completing [*Chapter 4*](B21662_04.xhtml#_idTextAnchor110)!
    In this chapter, we explored file and directory operations in Go. We covered essential
    topics, from identifying unsafe files and directory permissions to optimizing
    filesystem operations.
  prefs: []
  type: TYPE_NORMAL
- en: As we close this chapter, you now have a solid foundation in handling files
    and directories in Go, equipped with the knowledge and skills to build secure
    and efficient file-related applications. You’ve learned not just the theory but
    also the practical coding techniques that you can apply directly to your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, in the next chapter, we advance even more on system programming
    concepts, covering inter-process communication.
  prefs: []
  type: TYPE_NORMAL
