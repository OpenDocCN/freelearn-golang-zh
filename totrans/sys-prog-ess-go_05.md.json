["```go\npackage main\nimport (\n  \"fmt\"\n  \"os\"\n  \"os/signal\"\n)\nfunc main() {\n  signals := make(chan os.Signal, 1)\n  done := make(chan struct{}, 1)\n  signal.Notify(signals, os.Interrupt, )\n  go func() {\n    for {\n      s := <-signals\n      switch s {\n      case os.Interrupt:\n        fmt.Println(\"INTERRUPT\")\n        done <- struct{}{}\n      default:\n        fmt.Println(\"OTHER\")\n      }\n    }\n  }()\n  fmt.Println(\"awaiting signal\")\n  <-done\n  fmt.Println(\"exiting\")\n}\n```", "```go\n// Job represents a task to be executed\ntype Job func()\n```", "```go\n// Scheduler holds the jobs and the timer for execution\ntype Scheduler struct {\n    jobQueue chan Job\n}\n```", "```go\n// NewScheduler creates a new Scheduler\nfunc NewScheduler(size int) *Scheduler {\n    return &Scheduler{\n         jobQueue: make(chan Job, size),\n    }\n}\n```", "```go\n// Start the scheduler to listen for and execute jobs\nfunc (s *Scheduler) Start() {\n    for job := range s.jobQueue {\n         go job() // Run the job in a new goroutine\n    }\n}\n```", "```go\n// Schedule a job to be executed after a delay\nfunc (s *Scheduler) Schedule(job Job, delay time.Duration) {\n    go func() {\n         time.Sleep(delay)\n         s.jobQueue <- job\n    }()\n}\n```", "```go\nfunc main() {\n    scheduler := NewScheduler(10) // Buffer size of 10\n    // Schedule a job to run after 5 seconds\n    scheduler.Schedule(func() {\n         fmt.Println(\"Job executed at\", time.Now())\n    }, 5*time.Second)\n    // Start the scheduler\n    go scheduler.Start()\n    // Wait for input to exit\n    fmt.Println(\"Scheduler started. Press Enter to exit.\")\n    fmt.Scanln()\n}\n```", "```go\npackage main\nimport (\n    \"fmt\"\n    \"time\"\n)\nfunc main() {\n    // Create a ticker that ticks every second\n    ticker := time.NewTicker(1 * time.Second)\n    defer ticker.Stop()\n    // Create a timer that fires after 10 seconds\n    timer := time.NewTimer(10 * time.Second)\n    defer timer.Stop()\n    // Use a select statement to handle the signals from ticker and timer\n    for {\n         select {\n         case tick := <-ticker.C:\n              fmt.Println(\"Tick at\", tick)\n         case <-timer.C:\n              fmt.Println(\"Timer expired\")\n              return\n         }\n    }\n}\n```", "```go\nimport (\n    \"fmt\"\n    \"os\"\n    \"golang.org/x/sys/unix\"\n)\n```", "```go\nfd, err := unix.InotifyInit()\nif err != nil {\n    fmt.Println(\"Error initializing inotify:\", err)\n    return\n}\ndefer unix.Close(fd)\n```", "```go\nwatchPath := \"/path/to/your/directory\" // Change this to the directory you want to watch\n    watchDescriptor, err := unix.InotifyAddWatch(fd, watchPath, unix.IN_MODIFY|unix.IN_CREATE|unix.IN_DELETE)\n    if err != nil {\n        fmt.Println(\"Error adding watch:\", err)\n        return\n    }\n    defer unix.InotifyRmWatch(fd, uint32(watchDescriptor))\n```", "```go\nconst bufferSize = (unix.SizeofInotifyEvent + unix.NAME_MAX + 1)\nbuf := make([]byte, bufferSize)\nfor {\n        n, err := unix.Read(fd, buf[:])\n        if err != nil {\n            fmt.Println(\"Error reading from inotify:\", err)\n            return\n        }\n        // Parse the inotify events and handle them\n        var offset uint32\n        for offset < uint32(n) {\n            event := (*unix.InotifyEvent)(unsafe.Pointer(&buf[offset]))\n            nameBytes := buf[offset+unix.SizeofInotifyEvent : offset+unix.SizeofInotifyEvent+uint32(event.Len)]\n            name := string(nameBytes)\n            // Trim the NUL bytes from the name\n            name = string(nameBytes[:clen(nameBytes)])\n            // Process the event\n            fmt.Printf(\"Event: %s/%s\\n\", watchPath, name)\n            offset += unix.SizeofInotifyEvent + uint32(event.Len)\n        }\n    }\n}\nfunc clen(n []byte) int {\n    for i, b := range n {\n        if b == 0 {\n            return i\n        }\n    }\n    return len(n)\n}\n```", "```go\nconst bufferSize = (unix.SizeofInotifyEvent + unix.NAME_MAX + 1)\nbuf := make([]byte, bufferSize)\n```", "```go\nvar offset uint32\n```", "```go\nevent := (*unix.InotifyEvent)(unsafe.Pointer(&buf[offset]))\n```", "```go\nnameBytes := buf[offset+unix.SizeofInotifyEvent : offset+unix.SizeofInotifyEvent+uint32(event.Len)]\nname := string(nameBytes[:clen(nameBytes)])\n```", "```go\noffset += unix.SizeofInotifyEvent + uint32(event.Len)\n```", "```go\nimport \"github.com/fsnotify/fsnotify\"\n```", "```go\npackage main\nimport (\n     \"fmt\"\n     \"log\"\n     \"os\"\n     \"os/signal\"\n     \"syscall\"\n     \"github.com/fsnotify/fsnotify\"\n)\nfunc main() {\n     watchPath := \"/path/to/your/directory\"\n     watcher, err := fsnotify.NewWatcher()\n     if err != nil {\n          log.Fatal(\"Error creating watcher:\", err)\n     }\n     defer watcher.Close()\n     err = watcher.Add(watchPath)\n     if err != nil {\n          log.Fatal(\"Error adding watch:\", err)\n     }\n     go func() {\n          for {\n               select {\n               case event := <-watcher.Events:\n                    // Handle the event\n                    fmt.Printf(\"Event: %s\\n\", event.Name)\n               case err := <-watcher.Errors:\n                    log.Println(\"Error:\", err)\n               }\n          }\n     }()\n     // Create a channel to receive signals\n     signalCh := make(chan os.Signal, 1)\n     signal.Notify(signalCh, os.Interrupt, syscall.SIGINT)\n     // Block until a SIGINT signal is received\n     <-signalCh\n     fmt.Println(\"Received SIGINT. Exiting...\")\n}\n```", "```go\npackage main\nimport (\n    \"fmt\"\n    \"io\"\n    \"os\"\n    \"path/filepath\"\n    \"sync\"\n    \"time\"\n    \"github.com/fsnotify/fsnotify\"\n)\n```", "```go\nconst (\n    logFilePath = \"your_log_file.log\"\n    maxFileSize = 1024 * 1024 * 10    // 10 MB (adjust as needed)\n)\n```", "```go\n    // Initialize fsnotify\n    watcher, err := fsnotify.NewWatcher()\n    if err != nil {\n        fmt.Println(\"Error creating watcher:\", err)\n        return\n    }\n    defer watcher.Close()\n```", "```go\n    // Add the log file to be watched\n    err = watcher.Add(logFilePath)\n    if err != nil {\n        fmt.Println(\"Error adding log file to watcher:\", err)\n        return\n    }\n```", "```go\n    // Initialize a mutex to synchronize file access\n    var mu sync.Mutex\n```", "```go\n    // Watch for events (create, write) on the log file\n    go func() {\n        for {\n            select {\n            case event, ok := <-watcher.Events:\n                if !ok {\n                    return\n                }\n                if event.Op&fsnotify.Write == fsnotify.Write {\n                    // Check the file size\n                    fi, err := os.Stat(logFilePath)\n                    if err != nil {\n                        fmt.Println(\"Error getting file info:\", err)\n                        continue\n                    }\n                    fileSize := fi.Size()\n                    if fileSize >= maxFileSize {\n                        mu.Lock()\n                        rotateLogFile()\n                        mu.Unlock()\n                    }\n                }\n            case err, ok := <-watcher.Errors:\n                if !ok {\n                    return\n                }\n                fmt.Println(\"Error watching file:\", err)\n            }\n        }\n    }()\n```", "```go\n// Create a channel to receive signals\nsignalCh := make(chan os.Signal, 1)\nsignal.Notify(signalCh, os.Interrupt, syscall.SIGINT)\n// Block until a SIGINT signal is received\n<-signalCh\nfmt.Println(\"Received SIGINT. Exiting...\")\n```", "```go\nfunc rotateLogFile() {\n    // Close the current log file\n    err := closeLogFile()\n    if err != nil {\n        fmt.Println(\"Error closing log file:\", err)\n        return\n    }\n    // Rename the current log file with a timestamp\n    timestamp := time.Now().Format(\"20060102150405\")\n    newLogFilePath := fmt.Sprintf(\"your_log_file_%s.log\", timestamp) // Replace with your desired naming convention\n    err = os.Rename(logFilePath, newLogFilePath)\n    if err != nil {\n        fmt.Println(\"Error renaming log file:\", err)\n        return\n    }\n    // Create a new log file\n    err = createLogFile()\n    if err != nil {\n        fmt.Println(\"Error creating new log file:\", err)\n        return\n    }\n    fmt.Println(\"Log rotated.\")\n}\n```", "```go\nfunc closeLogFile() error {\n    // Assuming you have a global log file variable\n    if logFile != nil {\n        return logFile.Close()\n    }\n    return nil\n}\n```", "```go\nfunc createLogFile() error {\n    // Replace \"your_log_file.log\" with the desired log file path\n    logFile, err := os.Create(\"your_log_file.log\")\n    if err != nil {\n        return err\n    }\n    log.SetOutput(logFile) // Set the new log file as the output\n    return nil\n}\n```", "```go\npackage main\nimport (\n    «context»\n    «fmt»\n    «os/exec»\n    \"time\"\n)\nfunc main() {\n    // Define the command and the timeout duration.\n    cmd := exec.Command(«sleep», «2») // Replace «sleep» «2» with your command and arguments\n    timeout := 3 * time.Second         // Set your timeout duration\n    // Create a context that is canceled after the timeout duration.\n    ctx, cancel := context.WithTimeout(context.Background(), timeout)\n    defer cancel()\n    // Start the command.\n    if err := cmd.Start(); err != nil {\n         fmt.Println(\"Error starting command:\", err)\n         return\n    }\n    // Wait for the command to finish or for the timeout context to be canceled.\n    done := make(chan error, 1)\n    go func() {\n         done <- cmd.Wait()\n    }()\n    select {\n    case <-ctx.Done():\n         // The context's deadline was reached; kill the process.\n         if err := cmd.Process.Kill(); err != nil {\n              fmt.Println(\"Failed to kill process:\", err)\n         }\n         fmt.Println(\"Process killed as timeout reached\")\n    case err := <-done:\n         // The process finished before the timeout.\n         if err != nil {\n              fmt.Println(\"Process finished with error:\", err)\n         } else {\n              fmt.Println(\"Process finished successfully\")\n         }\n    }\n}\n```", "```go\nfile, err := os.Open(\"yourfile.txt\")\nif err != nil {\n    // Handle error\n}\ndefer file.Close()\n```", "```go\nlock := syscall.Flock_t{\n    Type:   syscall.F_WRLCK, // Lock type (F_RDLCK for read lock, F_WRLCK for write lock)\n    Whence: io.SeekStart,               // Offset base (0 for the start of the file)\n    Start:  0,               // Start offset\n    Len:    0,               // Length of the locked region (0 for entire file)\n}\nif err := syscall.FcntlFlock(file.Fd(), syscall.F_SETLK, &lock); err != nil {\n    // Handle error\n}\n```", "```go\nlock.Type = syscall.F_UNLCK\nif err := syscall.FcntlFlock(file.Fd(), syscall.F_SETLK, &lock); err != nil {\n    // Handle error\n}\n```"]