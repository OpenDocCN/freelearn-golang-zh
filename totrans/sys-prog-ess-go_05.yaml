- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with System Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: System events are an essential aspect of software development, and knowing how
    to manage and respond to them is crucial for creating robust and responsive applications.
    This chapter is designed to equip you with the knowledge and skills to effectively
    manage and respond to system events, a critical aspect of robust and responsive
    software development. By the end of this chapter, you will have gained practical
    experience in handling various types of system signals, scheduling tasks, and
    monitoring filesystem events using Go’s powerful features and libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding system events and signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task scheduling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File monitoring with Inotify
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a distributed lock manager in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing system events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing system events involves understanding and responding to various signals
    that can impact a process’s execution. We need to get a better understanding of
    what signals are and how they can be handled in our programs.
  prefs: []
  type: TYPE_NORMAL
- en: What are signals?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A signal serves as a notification to a process that a specific event has occurred.
    Signals are sometimes equated to software interrupts, resembling hardware interrupts
    in their capacity to disrupt a program’s normal execution flow. It’s typically
    impossible to predict precisely when a signal will be triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the kernel generates a signal for a process, it is usually due to an event
    occurring in one of these three categories: hardware-triggered events, user-triggered
    events, and software events.'
  prefs: []
  type: TYPE_NORMAL
- en: The first category occurs when the hardware detects a fault condition, notifying
    the kernel and dispatching a corresponding signal to the affected process.
  prefs: []
  type: TYPE_NORMAL
- en: The second category involves special characters in the terminal, such as the
    interrupt character (typically *Ctrl + C*), resulting in generated signals.
  prefs: []
  type: TYPE_NORMAL
- en: The last category includes for example the termination of a child process associated
    with the main process.
  prefs: []
  type: TYPE_NORMAL
- en: Process termination
  prefs: []
  type: TYPE_NORMAL
- en: A program may not catch `SIGKILL` and `SIGSTOP` signals and, therefore, cannot
    be affected by the `os/signal` package.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll explore how to handle incoming signals with the `os/signal`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: The os/signal package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `os/signal` package differentiates signals into two types: synchronous
    and asynchronous.'
  prefs: []
  type: TYPE_NORMAL
- en: Errors in program execution trigger synchronous signals such as `SIGBUS`, `SIGFPE`,
    and `SIGSEGV`. By default, Go programs convert these signals into a runtime panic.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining signals are asynchronous, meaning that they are not triggered
    by program errors, but are instead sent from the kernel or some other program.
  prefs: []
  type: TYPE_NORMAL
- en: The `SIGINT` signal is sent to a process in response to the user pressing the
    interrupt character on the controlling terminal. The default interrupt character
    is `^C` (*Ctrl + C*). Similarly, the `SIGQUIT` signal is sent to a process when
    the user presses the quit character on the controlling terminal. The default quit
    character is `^\` (*Crl + \*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let’s break down the code step by step.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code starts by importing necessary packages: `fmt` for formatting and printing,
    `os` for interacting with the operating system, and `os/signal` for handling signals.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`signals := make(chan os.Signal, 1)` creates a buffered channel called signals
    of type `os.Signal`. It’s used to receive signals from the operating system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`done := make(chan struct{}, 1)` creates another buffered channel called done
    of type `struct{}`. This channel is used to signal when the program should exit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`signal.Notify(signals, os.Interrupt)` registers the `os.Interrupt` signal
    (usually generated by pressing *Ctrl* + *C*) with the signals channel. This means
    that when the program receives an interrupt signal, it will be sent to the signals
    channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A goroutine is started with `go func() {...}()`. This goroutine runs concurrently
    with the main program. Inside this goroutine, there’s an infinite loop that listens
    for signals from the signals channel using `s := <-``signals`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a signal is received, if the signal is `os.Interrupt`, it prints `INTERRUPT`
    and sends an empty `struct{}` value to the done channel to indicate that the program
    should exit. Otherwise, it prints `OTHER`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After setting up the signal handling goroutine, the main program prints `awaiting
    signal`.
  prefs: []
  type: TYPE_NORMAL
- en: '`<-done` blocks until a value is received from the done channel, which happens
    when an interrupt signal is received and the goroutine sends an empty `struct{}`
    value to `done`. This effectively waits for the program to be interrupted.'
  prefs: []
  type: TYPE_NORMAL
- en: After receiving the value from done, the program prints `exiting` and then exits.
  prefs: []
  type: TYPE_NORMAL
- en: 'System signals are a form of inter-process communication in Unix and Unix-like
    operating systems. They are used to notify a process that a particular event has
    occurred. Signal handling is crucial for several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SIGTERM` or `SIGINT` is sent to a process, it’s a request for the process
    to terminate. Proper handling of these signals allows an application to close
    resources, save state, and exit cleanly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGUSR1` and `SIGUSR2` can be used to trigger the application to release or
    rotate logs, reload configurations without downtime, or perform other housekeeping
    tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGSTOP`) or resuming (`SIGCONT`) its operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGKILL` or `SIGABRT` can be used to stop a process immediately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, we need to initiate a task without a system trigger but from a recurring
    or specific point in time.
  prefs: []
  type: TYPE_NORMAL
- en: Task scheduling in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Task scheduling is the act of planning tasks to be executed by a system at certain
    times or under certain conditions. It’s a fundamental concept in computer science,
    used in operating systems, databases, networks, and application development.
  prefs: []
  type: TYPE_NORMAL
- en: Why schedule?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several reasons to schedule a task, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Efficiency**: It allows for the optimal use of resources by running tasks
    during off-peak hours or when certain conditions are met.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reliability**: Scheduled tasks can be used for routine backups, updates,
    and maintenance, ensuring these critical operations are not overlooked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency**: In multi-threaded and distributed systems, scheduling is essential
    for managing when and how tasks are executed in parallel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Predictability**: It provides a way to ensure that tasks are performed at
    regular intervals, which is important for tasks such as polling, monitoring, and
    reporting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic scheduling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go’s standard library provides several features that can be used to create a
    job scheduler, such as goroutines for concurrency and the `time` package for timing
    events.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example of a job scheduler, we’ll define two main types, `Job` and
    `Scheduler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`Job` is a type alias for a function that takes no arguments and returns nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`Scheduler` is a struct that holds a channel named `jobQueue` to store and
    manage scheduled jobs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we’ll need a factory for our `Scheduler` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `NewScheduler` function creates and returns a new `Scheduler` instance with
    a specified buffer size for the `jobQueue` channel. The buffer size allows a certain
    number of jobs to be scheduled and executed concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: Since we can create our scheduler, let’s attribute to them an action for scheduling
    and another to start the job itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be used to schedule a job for execution after a specified
    delay. It creates a new goroutine that sleeps for the specified duration and then
    sends the job to the `jobQueue` channel when the time is up. This means that the
    job will be executed asynchronously after the specified delay:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This method starts listening for jobs in the `jobQueue` channel and runs them
    in separate goroutines. It continuously loops and executes any jobs that are sent
    to the channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all components ready to be used, let’s create our `main` function to utilize
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the following in the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: A new `Scheduler` instance has been created with a buffer size of 10 for the
    `jobQueue` channel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A job is scheduled to print a message along with the current time after a delay
    of 5 seconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Start` method of the scheduler is called in a new goroutine to start processing
    scheduled jobs concurrently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The program waits for user input (a newline) to exit, providing a message to
    indicate that the scheduler is running and waiting for input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling timer signals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Go, the `time` package provides functionality for measuring and displaying
    time and scheduling events with `Timer` and `Ticker`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we can handle timer signals and implement system tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a ticker is used to perform a task every second, and a timer
    is used to stop the loop after 10 seconds. The `select` statement is used to wait
    on multiple channel operations, making it easy to handle different timing events.
  prefs: []
  type: TYPE_NORMAL
- en: Combining these concepts allows you to schedule tasks at regular intervals,
    after delays, or at specific times, which is essential for many system-level applications.
  prefs: []
  type: TYPE_NORMAL
- en: File monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File monitoring is a crucial aspect of system programming because it enables
    developers and administrators to stay informed about changes and activities within
    a filesystem. This real-time awareness of filesystem events is essential for maintaining
    a system’s integrity, security, and functionality. Without effective file monitoring,
    system programming tasks become significantly more challenging, as you cannot
    respond promptly to file-related events that can impact the overall operation
    of the system.
  prefs: []
  type: TYPE_NORMAL
- en: One powerful tool for file monitoring in the Linux environment is Inotify.
  prefs: []
  type: TYPE_NORMAL
- en: Inotify
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inotify is a Linux kernel subsystem that provides a mechanism for monitoring
    filesystem events. It allows you to receive notifications when certain events
    occur on files or directories, such as when a file is created, modified, or deleted,
    or when a directory is moved or renamed. In Go, you can use the standard library’s
    `os` and `syscall` packages to interact with Inotify and handle filesystem events.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a basic introduction to working with Inotify and filesystem events in
    Go using the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import the necessary packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we create an `Inotify` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to add watches to monitor specific files or directories for events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we’re monitoring the specified directory for file modification
    (`IN_MODIFY`), file creation (`IN_CREATE`), and file deletion (`IN_DELETE`) events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we can start an event loop to listen for filesystem events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This loop continuously reads and processes inotify events until an error occurs,
    such as when the file descriptor is closed, or an unexpected error happens. It’s
    a common pattern for monitoring filesystem events on Linux using the `golang.org/x/sys/unix`
    package for inotify system calls. Here’s a detailed breakdown of the loop’s operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This line initializes a byte slice (`buf`) with a size that’s sufficient to
    hold an inotify event and the maximum length of a filename. `unix.SizeofInotifyEvent`
    represents the size of an Inotify event structure and `unix.NAME_MAX` is the maximum
    length of a filename, ensuring that the buffer can accommodate the event data
    and the name of the file triggering the event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the loop, the code processes each inotify event as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'An `offset` variable is initialized to track the start of the next event in
    the buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This converts the bytes at the current offset into an InotifyEvent struct by
    using `unsafe.Pointer` and a type cast, allowing direct access to the event data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This extracts the filename associated with the inotify event. The filename
    is appended to the event struct in the buffer, and `event.Len` includes the length
    of this name. The `clen` function trims any NUL bytes used as padding, and the
    resulting byte slice is converted to a Go string representing the name of the
    file. Finally, the offset is updated to point to the start of the next Inotify
    event in the buffer, preparing for the next iteration of the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This approach efficiently processes multiple inotify events that may be read
    in a single `unix.Read` call, ensuring that each event and its associated filename
    is handled correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Working directly with inotify using the `os` and `syscall` packages versus using
    a higher-level library such as `fsnotify` involves several trade-offs in terms
    of complexity, portability, and abstraction level. Each approach has its advantages
    and disadvantages, depending on the specific requirements of your project and
    your familiarity with the underlying system calls.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore the `fsnotify` package.
  prefs: []
  type: TYPE_NORMAL
- en: fsnotify
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `fsnotify` package provides several advantages. The `fsnotify` package abstracts
    away platform-specific details and provides a consistent API for handling filesystem
    events on different operating systems, such as Windows, macOS, and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: It also simplifies the process of setting up watches and handling events, making
    it easier to work with filesystem events in a cross-platform manner.
  prefs: []
  type: TYPE_NORMAL
- en: From the robustness perspective, this package handles edge cases and corner
    scenarios that may not be evident when working directly with inotify or other
    platform-specific mechanisms. This property results in a more stable and reliable
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: Last, but not least, `fsnotify` is actively maintained by the Go community,
    which means you can expect updates, bug fixes, and improvements over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can import it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how we can achieve the same functionality using the `fsnotify` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this program, we created a goroutine that listens for events from the `fsnotify`
    watcher. It handles both events and errors that occur during the monitoring process.
  prefs: []
  type: TYPE_NORMAL
- en: Now, your program will continuously monitor the specified directory for filesystem
    events and print them as they occur or until an interrupt signal is received.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, using the `fsnotify` package simplifies working with filesystem events
    in Go and ensures your code is more portable across different operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: File rotation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: File rotation is a critical process used in computer systems to manage and maintain
    log files, backups, and other types of data files. It involves periodically renaming,
    archiving, and deleting old files and creating new ones to ensure efficient and
    organized storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Common use cases for file rotation are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**System logs**: Operating systems and applications generate log files to record
    events and errors. Rotating these logs ensures that they don’t become too large
    and that historical data is available for analysis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backup files**: Regularly rotating backup files helps ensure that you have
    recent and historical copies of your data in case of data loss or system failures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compliance logs**: Industries and organizations often need to maintain detailed
    records for compliance and auditing purposes. File rotation ensures these records
    are retained and organized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application-specific data**: Some applications generate data files, such
    as transaction logs or user-generated content, which should be rotated to manage
    storage efficiently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web server logs**: Web servers often generate access logs containing information
    about website visitors. Rotating these logs helps manage web traffic data and
    aids in analysis and security monitoring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sensor data and IoT devices**: IoT devices and sensors frequently generate
    data. File rotation enables the efficient management and storage of this data,
    especially in scenarios where continuous data collection is essential.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing log rotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create a Go program that implements log rotation based on the `fsnotify`
    package, you’ll first need to import the packages that we’re using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we define two constants. `logFilePath` is a string constant representing
    the path to the log file that will be monitored and rotated. `maxFileSize` is
    an integer constant representing the maximum size (in bytes) that the log file
    can reach before rotation occurs (you should replace `your_log_file.log` with
    the actual path to your log file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We initialize the `fsnotify` watcher, check for any errors during initialization,
    and defer the closure of the watcher to ensure it closes properly when the program
    exits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the log file specified by `logFilePath` to the list of files monitored
    by the `fsnotify` watcher. If an error occurs during this operation, we print
    an error message and exit the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a `sync.Mutex` named `mu` to synchronize access to shared resources
    (in this case, the log file) to prevent concurrent access issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The next section starts a goroutine to listen for filesystem events (such as
    file writes) on the monitored log file. When a file write event is detected, the
    code checks whether the file size exceeds the `maxFileSize`. If it does, it locks
    the mutex (`mu`), calls the `rotateLogFile` function to perform log rotation,
    and then unlocks the mutex. Also, it listens for errors from the `fsnotify` watcher
    and prints any errors that occur while watching the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to set up a channel to receive signals, register the `SIGINT` signal
    (*Ctrl* + *C*) and a corresponding signal, and then wait until one of these signals
    is received. Once a signal is received, it will print a message and exit the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We still need to declare the function that rotates the log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `rotateLogFile` function is responsible for performing log rotation. It
    does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Calls `closeLogFile` to close the current log file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generates a timestamp to be used in the new log filename
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rename the current log file to include the timestamp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calls `createLogFile` to create a new log file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prints a message indicating that the log has been rotated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This function is responsible for closing the current log file. If you’re using
    the standard Go `log` package to log messages to a file, you can close the log
    file using the `logFile.Close()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This function is responsible for creating a new log file. If you’re using the
    standard Go log package, you can create a new log file by opening it with `os.Create`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The choice between using inotify directly and using `fsnotify` depends on your
    specific needs. If you require portability and simplicity, and your filesystem
    monitoring needs are relatively standard, fsnotify is likely the better choice.
    On the other hand, if you need very specific functionality that fsnotify does
    not support, or if you are working on an educational project to learn more about
    system calls and filesystem events at a low level, you might opt for the direct
    use of inotify with the `os` and `syscall` packages.
  prefs: []
  type: TYPE_NORMAL
- en: We can manage signals and file events, but sometimes, we want to manage another
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Process management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Process management involves starting, stopping, and managing the state of processes.
    It’s a critical aspect of operating systems and applications that are needed to
    control child processes.
  prefs: []
  type: TYPE_NORMAL
- en: Execution and timeouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Timeout control is particularly important for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource management**: Processes that hang or take too long can consume system
    resources, leading to inefficiency'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reliability**: Ensuring that a process is completed within a given timeframe
    can be crucial for time-sensitive operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deadlock prevention**: In a system with interdependent processes, timeouts
    can prevent deadlocks by ensuring that no process waits indefinitely for a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute and control process execution time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Go, you can use the `os/exec` package to start external processes. Combined
    with channels and `select` statements, you can effectively manage process execution
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how to create a utility that executes a process and kills
    it if it doesn’t finish within a certain timeframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`context.WithTimeout` is used to create a context that automatically cancels
    after a specified duration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd.Start()` begins the execution of the command, and `cmd.Wait()` waits for
    it to finish'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `select` statement waits for either the command to finish or the timeout
    to occur, whichever comes first
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the timeout occurs, the process is killed using `cmd.Process.Kill()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: By deferring the `cancel` function, you are explicitly communicating your intent
    to cancel the operation when the surrounding function exits. This makes your code
    more self-documenting and easier to understand for other developers who may work
    on the code later.
  prefs: []
  type: TYPE_NORMAL
- en: Building a distributed lock manager in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unix provides file locks as a mechanism for coordinating access to shared files
    among multiple processes. File locks are used to prevent multiple processes from
    concurrently modifying the same file or region of a file, ensuring data consistency
    and preventing race conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `fcntl` system call to work with file locks. There are two main
    types of file locks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Advisory locks**: Advisory locks are set by the processes themselves, and
    it’s up to the processes to cooperate and respect the locks. Processes that don’t
    cooperate can still access the locked resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mandatory locks**: Mandatory locks are enforced by the operating system,
    and processes cannot override them. If a process attempts to access a file region
    subject to a mandatory lock, the operating system will block the access until
    the lock is released.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s explore how we can use file locks.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open the file you want to apply locks to using the `os.Open` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To lock the file, you can use the `syscall.FcntlFlock` function in Go. This
    function allows you to set advisory locks on a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We set an advisory write lock on the entire file. Other processes can still
    read or write to the file, but if they attempt to acquire a conflicting write
    lock, they will block until the lock is released.
  prefs: []
  type: TYPE_NORMAL
- en: 'To release the lock, you can use the same `syscall.FcntlFlock` function with
    the `F_UNLCK` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several use cases for using file locks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Preventing data corruption**: File locks are used to prevent multiple processes
    or threads from concurrently writing to the same file. This is crucial for preventing
    data corruption when multiple entities need to update a shared file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database management**: Many database systems use file locks to ensure that
    only one instance of the database server can access the database files at a time.
    This prevents race conditions and maintains database integrity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File synchronization**: File locks are used in scenarios where multiple processes
    or threads are needed to access shared files in a coordinated manner. For example,
    log files or configuration files might be accessed by multiple processes, and
    file locks help to prevent conflicts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource allocation**: File locks can be used to allocate resources in a
    mutually exclusive manner. For example, a cluster of machines might use file locks
    to coordinate which machine has access to a shared resource at any given time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message queues**: In some message queue implementations, file locks are used
    to ensure that only one consumer process can dequeue and process a message from
    the queue at a time, preventing message duplication or processing conflicts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caching and shared memory**: File locks can be used to coordinate access
    to shared memory or cache files among multiple processes to prevent data corruption
    and race conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File editors and file-sharing applications**: Text editors and file-sharing
    applications often use file locks to ensure that only one user can edit a file
    at a time, preventing conflicts and data loss.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backup and restore operations**: Backup and restore utilities often use file
    locks to ensure that a file is not modified while it is being backed up or restored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simultaneous access control**: In scenarios where processes need to ensure
    exclusive access to a shared resource, such as a hardware device or a network
    socket, file locks can be used to coordinate access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that while file locks are a useful mechanism for coordinating
    access to shared resources, they are advisory by default. This means that processes
    must cooperate and respect the locks; there is no enforcement by the operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations on completing this detailed and informative chapter on working
    with system events in Go! This chapter has explored the crucial aspects of system
    events and signals, equipping you with the knowledge and skills required for effective
    management and response within Go programming.
  prefs: []
  type: TYPE_NORMAL
- en: We began by exploring the fundamental concepts of system events and signals.
    You learned about their various types and their significant role in software execution
    and inter-process communication.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we looked at handling signals in Go using the `os/signal` package. You
    now understand the difference between synchronous and asynchronous signals and
    how they impact your Go applications.
  prefs: []
  type: TYPE_NORMAL
- en: You gained insights into task scheduling principles and practical implementation
    skills using Go’s goroutines and the time package.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we explored file monitoring with Inotify. You learned about this Linux
    kernel subsystem and how to implement it in Go to monitor filesystem events.
  prefs: []
  type: TYPE_NORMAL
- en: As we wrap up this chapter, you are now equipped with a solid set of skills
    to gracefully handle interruptions and unforeseen events, schedule tasks effectively,
    and monitor filesystem events proficiently. In the next chapter, we will explore
    pipes in **Inter-Process** **Communication** (**IPC**).
  prefs: []
  type: TYPE_NORMAL
