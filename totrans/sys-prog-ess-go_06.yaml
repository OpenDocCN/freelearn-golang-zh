- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding Pipes in Inter-Process Communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pipes are fundamental tools in **inter-process communication** (**IPC**), allowing
    for efficient data transfer between system processes. This chapter provides a
    comprehensive understanding of pipes, their functionality, and their application
    in various programming scenarios, particularly focusing on their use in Go.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a clear understanding of how pipes
    function in IPC, their significance in system programming, and how to effectively
    implement them in Go. The chapter aims to equip readers with the knowledge to
    utilize pipes for efficient process communication in their programming projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover these main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are pipes in IPC?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mechanics of anonymous pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating named pipes (`Mkfifo()`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices – guidelines for using pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a log processing tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use some system dependencies to execute this chapter’s examples. So,
    make sure you have these programs available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`grep`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`echo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are pipes in IPC?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In system programming, we can envision a pipe as a conduit within memory designed
    for transporting data between two or more processes. This conduit adheres to the
    producer-consumer model: one process, the producer, funnels data into the pipe,
    while another, the consumer, taps into this stream to read the data. As a pivotal
    element of IPC, pipes establish a unidirectional flow of information. This setup
    ensures that data consistently moves in one direction – from the “write end” to
    the “read end” of the pipe. This mechanism allows processes to communicate in
    a streamlined and efficient manner, much like water flowing through a pipe, with
    one process smoothly passing information down the line to the next.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pipes are used in a variety of system-level programming tasks. The most common
    applications include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Command-line utilities**: Pipes are often used to connect the output of one
    command-line utility to the input of another, enabling the creation of powerful
    command chains'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data streaming**: When data needs to be streamed from one process to another,
    pipes offer a simple and effective solution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inter-process data exchange**: Pipes facilitate data exchange between processes,
    essential in many multi-process applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why are pipes important?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pipes allow modular software creation where different processes specialize in
    specific tasks and communicate efficiently. They facilitate efficient use of system
    resources by enabling direct communication between processes without needing intermediate
    storage. Also, they provide a simple yet powerful interface for data exchange,
    making complex operations more manageable.
  prefs: []
  type: TYPE_NORMAL
- en: Since pipes are designed to allow data to move in a single direction, two pipes
    are often used for two-way communication. They operate buffering data until another
    process reads the data. This mechanism is especially useful for handling cases
    where the reader and the writer operate at different speeds.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should have been scratching your head and asking yourself
    *Are they Go’s channel-like structures?* And the answer is *Yes, in* *some sort*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are similarities between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Communication mechanisms**: Both pipes and channels are primarily used for
    communication. Pipes facilitate IPC, while channels are used for communication
    between goroutines within a Go program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data transfer**: At a basic level, both pipes and channels transfer data.
    In pipes, data flows from one process to another, while data is passed between
    goroutines in channels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Synchronization**: Both provide a level of synchronization. Writing to a
    full pipe or reading from an empty pipe will block the process until the pipe
    is read from or written to, respectively. Similarly, sending to a full channel
    or receiving from an empty channel in Go will block the goroutine until the channel
    is ready for more data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Buffering**: Pipes and channels can be buffered. A buffered pipe has a defined
    capacity before it blocks or overflows, and similarly, Go channels can be created
    with a capacity, allowing a certain number of values to be held without immediate
    receiver readiness.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But more importantly, there are differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Direction of communication**: Standard pipes are unidirectional, meaning
    they only allow data flow in one direction. Channels in Go are bidirectional by
    default, allowing data to be sent and received on the same channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ease of use in context**: Channels are a native feature of Go, offering integration
    and ease of use within Go programs that pipes cannot match. As a system-level
    feature, pipes require more setup and handling when used in Go.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, before we create our first Go programs using pipes, keep the following guidelines
    in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use pipes in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: You must facilitate communication between different processes, possibly across
    different programming languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your application involves separate executables that need to communicate with
    each other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You work in a Unix-like environment and can leverage robust IPC mechanisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use Go channels when the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: You are developing concurrent applications in Go and need to synchronize and
    communicate between goroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You require a straightforward and safe way to handle concurrency within a single
    Go program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must implement complex concurrency patterns, such as fan-in, fan-out, or
    worker pools, which Go’s channel and goroutine model elegantly handle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our development routine, we are used to using pipes every time on the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned before, pipes pass the output of one command as the input to another.
    Here’s a simple example in `bash`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this command, `cat file.txt` reads the content of `file.txt`, and then the
    pipe (`|`) passes this content as input to `grep "flower"`, which searches for
    lines containing `"flower"`.
  prefs: []
  type: TYPE_NORMAL
- en: To replicate this whole sequence of steps in Go, we need to read the contents
    of a file and then process these contents to find the desired string.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We don’t need to use pipes to achieve the same result since Go doesn’t use Unix-like
    pipes similarly; we typically read and process the data using Go’s file handling
    and string processing capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Pipes in Golang
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go’s standard library provides the necessary functions to create and manage
    pipes. The `io.Pipe()` function is commonly used to create a synchronous, in-memory
    pipe. This function is relevant to keep in mind when you only need to achieve
    this flow of control over the data but not execute any system call.
  prefs: []
  type: TYPE_NORMAL
- en: Also, for using OS pipes, we can call the `os.Pipe()` function This function
    internally uses the `SYS_PIPE2` syscall, and the Go `stdlib` package handles all
    the complexity for us, returning a connected pair of files.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, data is written to the write end of the pipe using standard write
    operations and read from the read end using standard read operations. It’s crucial
    to ensure that any issues during data transfer, such as broken pipes or data integrity
    problems, are effectively managed.
  prefs: []
  type: TYPE_NORMAL
- en: The mechanics of anonymous pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Anonymous pipes are the most basic form of pipes. They are used for communication
    between parent and child processes. Let’s explore how we can replicate the simple
    script beforementioned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This program manually creates pipes for IPC. Here’s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `echo` command and a pipe for its output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: echoCmd := exec.Command("echo", "Hello, world!")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pipe, err := echoCmd.StdoutPipe()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This sets up an `echo` command for`"Hello, world!"` and creates a pipe for its
    standard output.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `grep` command and set its standard input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: grepCmd := exec.Command("grep", "-i", "HELLO")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: grepCmd.Stdin = pipe
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `grep` command is set up to read from the output pipe of `echoCmd`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a pipe for the `grepCmd` output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: grepOut, err := grepCmd.StdoutPipe()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This creates a pipe to capture the standard output of `grepCmd`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start `grepCmd`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: if err := grepCmd.Start(); err != nil {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // handle error
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This starts `grepCmd` but doesn’t wait for it to finish. It’s ready to read
    from its standard input (connected to the `echoCmd` output).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run `echoCmd`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: if err := echoCmd.Run(); err != nil {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // handle error
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running `echoCmd` sends its output to `grepCmd`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Read and print the `grepCmd` output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: scanner := bufio.NewScanner(grepOut)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for scanner.Scan() {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: fmt.Println(scanner.Text())
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code reads the output of `grepCmd` line by line and prints it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Wait for `grepCmd` to finish:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: if err := grepCmd.Wait(); err != nil {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // handle error
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lastly, it waits for `grepCmd` to finish processing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We have a simpler way to achieve the same result, as per the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This program uses the `Output()` method to execute commands and capture their
    output directly. Here’s a step-by-step explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `echo` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: echoCmd := exec.Command("echo", "Hello, world!")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This line creates an `exec.Cmd` struct to represent the `"Hello, world!"` `echo`
    command.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run `echoCmd` and capture its output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: echoOutput, err := echoCmd.Output()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Output()` method runs `echoCmd`, waits for it to finish, and captures its
    standard output. If there’s an error (such as if the command doesn’t exist), it’s
    captured in `err`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `grep` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: grepCmd := exec.Command("grep", "Hello")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This creates another `exec.Cmd` struct for the `"HELLO"` `grep -i` command.
    The `-i` flag makes the search case-insensitive.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Set the standard input for `grepCmd`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: grepCmd.Stdin = strings.NewReader(string(echoOutput))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output of `echoCmd` is used as the standard input for `grepCmd`. This mimics
    the piping behavior in a shell.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run `grepCmd` and capture its output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: grepOutput, err := grepCmd.Output()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This executes `grepCmd` and captures its output. If `grepCmd` encounters an
    error (such as no match found), it will be captured in `err`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Print the output of `grepCmd`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'fmt.Printf("Output of grep: %s", grepOutput)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As the last step, the output of `grepCmd` is printed to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This approach using the `Output()` method is convenient. It works well in many
    scenarios, especially when dealing with straightforward command execution where
    you just need to capture the output of a command.
  prefs: []
  type: TYPE_NORMAL
- en: There are limitations to anonymous pipes since they are only useful for communication
    if the creating process or its descendants are alive. Also, we have a unidirectional
    data flow. To address these issues, we can use named pipes.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating named pipes (Mkfifo())
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Named pipes are not limited to live processes, unlike anonymous pipes. They
    can be used between any processes and persist in the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'IPC can sometimes be an abstract concept, challenging to grasp for those new
    to system programming. Let’s use a simple, relatable analogy to make this easier:
    the “task mailbox” in an office setting.'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you’re in an office where every team member has a specific set of tasks.
    Communication and task delegation are key to the smooth operation of this office.
    How do team members efficiently exchange tasks and information? This is where
    the idea of a “task mailbox” comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: In our analogy, a task mailbox is a special mailbox in the office where team
    members drop off tasks for others. Once a task is in the mailbox, the designated
    team member can pick it up, process it, and move on to the next one. This system
    ensures that tasks are communicated and handled efficiently, without direct interaction
    between team members, every time a task needs to be passed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s translate this analogy into our program. Since processes often need
    to communicate with each other, just like team members in an office, this is where
    named pipes come into play. It acts like our task mailbox, serving as a conduit
    through which different processes can exchange information. One process can drop
    information into the pipe, and another can pick it up for processing. It’s a simple
    yet effective way to facilitate communication between processes.
  prefs: []
  type: TYPE_NORMAL
- en: To bring this analogy to life, let’s create this program. We’ll create a virtual
    “task mailbox” (a named pipe) and demonstrate how one can use it to pass messages
    (tasks) between different parts of a program. This example will illustrate the
    concept of named pipes and make the abstract idea of IPC more tangible and easier
    to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s handle the creation of our named pipe. We need to verify whether
    the named pipe exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `main()` function, we make sure we are creating a named pipe when it
    does not exist. The `Mkfifo()` function creates a named pipe in the filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Once created, `os.OpenFile` with `os.O_RDWR` is used to open the pipe for reading.
    This way, the data sent is read from the pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our main logic resides in one goroutine sending tasks over the pipe while
    another reads them. Once we’re using a scanner, we stop reading for new tasks
    when the sender sends an `"EOD"` (end of day) string instance. To synchronize
    these goroutines, we’re using `sync.WaitGroup`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The sending logic in the `writer.go` file is simply pushing data over the pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Receiving tasks is the responsibility of the `ReadTask()` function in the `reader.go`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Running our program, we should see an output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: There are a few important characteristics of using named pipes. For example,
    they can be used between any processes. They exist independently of the process
    and can be found in the filesystem. Also, although a single named pipe is unidirectional,
    two named pipes can be used for bidirectional communication.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices – guidelines for using pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having explored practical aspects of using pipes in IPC, discussing best practices
    and guidelines is crucial. Adhering to these principles ensures that your implementation
    is efficient but also secure and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Efficient data handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the context of efficient data handling, especially when minimizing data
    in transit, two key strategies are employed: chunking and compression.'
  prefs: []
  type: TYPE_NORMAL
- en: Chunking involves breaking down large datasets into smaller, more manageable
    pieces. The primary advantage of chunking is that it prevents the overfilling
    of pipe buffers, which can lead to bottlenecks in data transmission. By segmenting
    the data, each chunk can be processed and transmitted sequentially, ensuring a
    smoother and more efficient flow of data. This technique is particularly useful
    in scenarios where data is streamed or processed in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Example – Chunking data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this snippet, the idea is the writer sends data by chunk size and the reader
    receives the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code on the writer’s side looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'And on the reader’s side, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Compression is the process of reducing the size of data before it is sent. This
    is especially beneficial when the data is highly compressible, such as text files
    or certain types of image and video files. By compressing data, the volume of
    information that needs to be transmitted is significantly reduced, leading to
    faster transmission times and potentially lower bandwidth usage. However, it’s
    important to consider the computational overhead of compressing and decompressing
    data, as well as the nature of the data itself (some data may not compress well).
  prefs: []
  type: TYPE_NORMAL
- en: Example – Compressing data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For compression, you can use a library such as `compress/gzip` to compress and
    decompress data.
  prefs: []
  type: TYPE_NORMAL
- en: In these snippets, the writer compresses the data while the reader decompresses
    it to read it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, we’re compressing and sending the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'So, for reading, we’ll decompress the data, as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Error handling and resource management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We must handle errors and properly save resources to create maintainable and
    robust software. Let’s explore how we can approach these two dimensions of robustness.
  prefs: []
  type: TYPE_NORMAL
- en: Robust error handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always check for errors after pipe operations. This includes read, write, and
    close operations. Also, implement timeouts for read/write operations to avoid
    deadlocks.
  prefs: []
  type: TYPE_NORMAL
- en: Example – Reading pipes with timeout
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this snippet, we have a boilerplate to read pipes leveraging in-context
    timeouts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Proper resource management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ensure pipes are properly closed after use. Use `defer` for closing file descriptors
    in Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, we can observe that we can avoid resource leakage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Handling leaks
  prefs: []
  type: TYPE_NORMAL
- en: Monitor for any resource leaks. Left open, pipes can lead to file descriptor
    exhaustion.
  prefs: []
  type: TYPE_NORMAL
- en: Security considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we’re transmitting sensitive data, we should consider encrypting it before
    sending it through a pipe. After receiving data through pipes, we need to ensure
    the validation of this data, especially if used in critical parts of our programs.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to be cautious with permissions when creating named pipes. Restrict
    access to trusted users. Also, use randomized or unpredictable names to prevent
    name squatting attacks for named pipes.
  prefs: []
  type: TYPE_NORMAL
- en: Example – Securing named pipe creation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the following snippet, the pipe name receives a random factor and restricts
    access to the pipe owner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Name squatting attack
  prefs: []
  type: TYPE_NORMAL
- en: In a name squatting attack, an attacker creates a named pipe with a name that
    is expected to be used by a legitimate application or service. This attack typically
    targets applications or services that dynamically create named pipes for IPC but
    do not adequately verify the identity of the pipe’s creator.
  prefs: []
  type: TYPE_NORMAL
- en: Performance optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adjust buffer sizes by tuning them based on your application’s needs. Smaller
    buffers can reduce memory usage, while larger ones can improve throughput.
  prefs: []
  type: TYPE_NORMAL
- en: 'This next practice is crucial for achieving good performance: use non-blocking
    I/O operations to improve performance, especially in applications that require
    high responsiveness.'
  prefs: []
  type: TYPE_NORMAL
- en: By following these best practices, you can ensure that your use of named pipes
    in Go is not only effective but also secure and maintainable. Named pipes are
    a powerful tool in system programming, and with careful consideration of these
    guidelines, you can harness their full potential to build robust and efficient
    applications. As you continue to develop your skills in Go and system programming,
    keep these practices in mind to enhance the quality of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a log processing tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having covered the fundamentals of pipes in IPC and best practices for their
    use in Go, let’s explore more advanced topics. We will explore a scenario where
    pipes can be effectively utilized and see how Go’s concurrency model complements
    these use cases. This section aims to give you practical insights into leveraging
    pipes for sophisticated system programming tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In the next example, we’ll develop a simple real-time log processing tool. This
    tool will read log data from a file (simulating a log file being written by another
    process), process the log entries (for example, filtering based on severity),
    and then output the results to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a `filterLogs()` function that reads logs from the reader,
    filters them, and writes to the writer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the function reads from a reader (our named pipe), filters the log
    entries only to include those containing `"ERROR"`, and writes them to a writer
    (we’re sending to standard output):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the `main()` function, a named pipe is created to simulate a log file. This
    pipe acts as the source of log data. The pipe is opened for reading. Concurrently,
    a goroutine is started to simulate writing log entries to this pipe, including
    both `"INFO"` and `"ERROR"` messages. The `filterLogs()` function is called to
    process incoming log data. It filters and outputs error messages.
  prefs: []
  type: TYPE_NORMAL
- en: Although simple, this code demonstrates a practical application of pipes in
    Go for real-time log processing. It shows how to set up a pipeline for continuous
    data processing, simulating a common scenario in system monitoring and log analysis
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we conclude this chapter, let’s reflect on the key insights and knowledge
    we’ve gained about IPC in system programming, especially in the context of Go.
  prefs: []
  type: TYPE_NORMAL
- en: We explored their fundamental role in facilitating data exchange between processes,
    emphasizing their importance in system-level programming. These pipes have versatile
    applications, including command-line utilities, data streaming, and inter-process
    data exchange. We also compared pipes to channels, highlighting differences in
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we’re going to apply the knowledge gained to create
    automation.
  prefs: []
  type: TYPE_NORMAL
