<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer015">
			<h1 id="_idParaDest-123" class="chapter-number"><a id="_idTextAnchor160"/>7</h1>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor161"/>Unix Sockets</h1>
			<p>In this chapter, you will learn about socket programming, but this time focusing on UNIX sockets. The chapter provides an understanding of how UNIX sockets function, their types, and their<a id="_idIndexMarker330"/> role in <strong class="bold">inter-process communication</strong> (<strong class="bold">IPC</strong>) on UNIX and UNIX-like operating systems such as Linux. You will gain practical knowledge through examples, particularly in creating a UNIX socket server and client using the Go <span class="No-Break">programming language.</span></p>
			<p>This information is crucial for programmers who are interested in developing advanced software systems, particularly those that require efficient IPC mechanisms. Understanding UNIX sockets is essential for system and network programmers, as it allows for the creation of more efficient and <span class="No-Break">secure applications.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li><span class="No-Break">Unix sockets</span></li>
				<li>Building a <span class="No-Break">chat server</span></li>
				<li>Serving HTTP under <span class="No-Break">Unix sockets</span></li>
			</ul>
			<p>By the end of the chapter, you should be able to create and manage UNIX sockets and understand their efficiency, security, and how they are integrated into the <span class="No-Break">filesystem namespace.</span></p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor162"/>Introduction to Unix sockets</h1>
			<p>UNIX sockets, also known <a id="_idIndexMarker331"/>as UNIX domain sockets, provide a way for processes to communicate with each other on the same machine quickly and efficiently, offering a local alternative to TCP/IP sockets for IPC. This feature is unique to UNIX and UNIX-like operating systems such <span class="No-Break">as Linux.</span></p>
			<p>UNIX sockets can be either stream-oriented (such as TCP) or datagram-oriented (such as UDP). They are represented as filesystem nodes, such as files and directories. However, they are not regular files but special <span class="No-Break">IPC mechanisms.</span></p>
			<p>There are three <a id="_idIndexMarker332"/><span class="No-Break">key features:</span></p>
			<ul>
				<li><strong class="bold">Efficiency</strong>: Data is transferred directly between processes without the need for network <span class="No-Break">protocol overhead.</span></li>
				<li><strong class="bold">Filesystem namespace</strong>: UNIX sockets are referenced by filesystem paths. This makes them easy to locate and use but also means they persist in the filesystem until <span class="No-Break">explicitly removed.</span></li>
				<li><strong class="bold">Security</strong>: Access to UNIX sockets can be controlled using filesystem permissions, providing a level of security based on user and <span class="No-Break">group IDs.</span></li>
			</ul>
			<p>Moving forward, let’s see how we can actually create a <span class="No-Break">UNIX socket.</span></p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor163"/>Creating a Unix socket</h1>
			<p>Let’s go through a step-by-step <a id="_idIndexMarker333"/>example in Go for creating a UNIX socket server and client. After that, we’ll understand how to use <strong class="source-inline">lsof</strong> to inspect <span class="No-Break">the socket:</span></p>
			<ol>
				<li>For socket path and cleanup, perform <span class="No-Break">the following:</span><pre class="source-code">
socketPath := "/tmp/example.sock"
if err := os.Remove(socketPath); err != nil &amp;&amp; !os.IsNotExist(err) {
    log.Printf("Error removing socket file: %v", err)
    return
}</pre><ul><li><strong class="bold">Path definition</strong>: <strong class="source-inline">socketPath := "/tmp/example.sock"</strong> sets the location for the <span class="No-Break">UNIX socket</span></li><li><strong class="bold">Cleanup logic</strong>: <strong class="source-inline">os.Remove(socketPath)</strong> attempts to delete any existing socket file at this location to avoid conflicts when starting <span class="No-Break">the server</span></li></ul></li>				<li>For creating and listening on the <span class="No-Break">UNIX socket:</span><pre class="source-code">
listener, err := net.Listen("unix", socketPath)
if err != nil {
    log.Printf("Error listening: %v", err)
    return
}
defer listener.Close()
fmt.Println("Listening on", socketPath)</pre><ul><li><strong class="bold">Listen function</strong>: <strong class="source-inline">net.Listen("unix", socketPath)</strong> creates the UNIX socket at the given path and starts listening for <span class="No-Break">incoming connections</span></li><li><strong class="bold">Defer statement</strong>: <strong class="source-inline">defer listener.Close()</strong> ensures that the socket is closed when the main function exits, releasing <span class="No-Break">system resources</span></li></ul></li>				<li>For<a id="_idIndexMarker334"/> graceful <span class="No-Break">shutdown setup:</span><pre class="source-code">
signals := make(chan os.Signal, 1)
signal.Notify(signals, syscall.SIGINT, syscall.SIGTERM)
go func() {
    &lt;-signals
    fmt.Println("Received termination signal. Shutting down gracefully...")
    listener.Close()
    os.Remove(socketPath)
    os.Exit(0)
}()</pre><ul><li><strong class="bold">Signal channel</strong>: <strong class="source-inline">signals := make(chan os.Signal, 1)</strong> sets up a channel to receive operating <span class="No-Break">system signals.</span></li><li><strong class="bold">Signal registration</strong>: <strong class="source-inline">signal.Notify(signals, syscall.SIGINT, syscall.SIGTERM)</strong> configures the program to intercept <strong class="source-inline">SIGINT</strong> and <strong class="source-inline">SIGTERM</strong> signals for <span class="No-Break">graceful shutdown.</span></li><li><strong class="bold">Goroutine for signal handling</strong>: The anonymous <strong class="source-inline">go func() { ... }()</strong> goroutine waits for a signal. Upon receiving one, it closes the listener and removes the socket file, then exits <span class="No-Break">the program.</span></li></ul></li>				<li>For<a id="_idIndexMarker335"/> connection <span class="No-Break">acceptance loop:</span><pre class="source-code">
for {
    conn, err := listener.Accept()
    if err != nil {
       log.Printf("Error accepting connection: %v", err)
       continue
    }
    go handleConnection(conn)
}</pre><ul><li><strong class="bold">Infinite loop</strong>: The <strong class="source-inline">for { ... }</strong> loop continuously waits for and accepts <span class="No-Break">new connections</span></li><li><strong class="bold">Error handling in acceptance</strong>: If <strong class="source-inline">listener.Accept()</strong> encounters an error (such as during server shutdown), it logs the error and continues to the next iteration, avoiding <span class="No-Break">a crash</span></li></ul></li>				<li>For <span class="No-Break">connection management:</span><pre class="source-code">
func handleConnection(conn net.Conn) {
    defer conn.Close()
    buffer := make([]byte, 1024)
    n, err := conn.Read(buffer)
    if err != nil {
       log.Printf("Error reading from connection: %v", err)
       return
    }
    fmt.Println("Received:", string(buffer[:n]))
    // Simulate a response back to the client
    response := []byte("Message received successfully\n")
    _, err = conn.Write(response)
    if err != nil {
       log.Printf("Error writing response to connection: %v", err)
       return
    }
}</pre><ul><li>Utilizes <strong class="source-inline">defer conn.Close()</strong> to ensure <a id="_idIndexMarker336"/>the connection is closed after function execution, <span class="No-Break">releasing resources</span></li><li>Allocates a byte buffer with <strong class="source-inline">buffer := make([]byte, 1024)</strong> for <span class="No-Break">incoming data</span></li><li>Reads incoming data using <strong class="source-inline">n, err := conn.Read(buffer)</strong>, handling errors and exiting if <span class="No-Break">any occur</span></li><li>Displays the received message with <strong class="source-inline">fmt.Println("Received:"</strong>, <strong class="source-inline">string(buffer[:n]))</strong>, showing only the read portion of <span class="No-Break">the buffer</span></li><li>Constructs a response with <strong class="source-inline">response := []byte("Message received successfully\n")</strong> to acknowledge the <span class="No-Break">received message</span></li><li>Sends the response back to the client via <strong class="source-inline">conn.Write(response)</strong>, logging <a id="_idIndexMarker337"/>errors if the write <span class="No-Break">operation fails</span></li></ul></li>			</ol>
			<p>We now can run this code by executing <span class="No-Break">the following:</span></p>
			<pre class="console">
go run main.go</pre>			<p>The output should be <span class="No-Break">as follows:</span></p>
			<pre class="console">
Listening on /tmp/example.sock</pre>			<h2 id="_idParaDest-127"><a id="_idTextAnchor164"/>Going a little deeper into socket creation</h2>
			<p>When we call <strong class="source-inline">net.Listen</strong> with a UNIX socket type and a file path, the Go runtime performs two actions under the hood: the socket file descriptor is created in the operating system and Go’s runtime binds the socket to the specified <span class="No-Break">file path.</span></p>
			<h3>From an operating system perspective</h3>
			<p>When I say, “A socket is created in the operating system,” I’m referring to the creation of a socket as an<a id="_idIndexMarker338"/> internal resource within the operating system’s kernel. This action is like the operating system setting up a communication endpoint. The socket at this stage is an abstraction managed by the operating system, allowing processes to send and receive data. Note that this socket is not yet associated with a file in the filesystem. It’s an entity that exists in the system’s memory, managed by the kernel’s networking or <span class="No-Break">IPC subsystem.</span></p>
			<h3>From a filesystem perspective</h3>
			<p>Binding in this<a id="_idIndexMarker339"/> context is associating the socket with a specific path in the filesystem. This binding creates a socket file, a special type of file that serves as an entry point or an endpoint <span class="No-Break">for IPC.</span></p>
			<p>The “socket file” created in the filesystem is not a regular file that stores data such as text or binary content. Instead, it’s a special type of file (often appearing as a file in directory listings) that represents the socket and provides a way for processes to reference and use it. It’s the point where the abstract socket created by the operating system gets a named representation in <span class="No-Break">the filesystem.</span></p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor165"/>Creating the client</h2>
			<p>Our client’s primary <a id="_idIndexMarker340"/>functions are to connect to a UNIX socket server, send a message, and then close <span class="No-Break">the connection.</span></p>
			<p>To achieve this goal, let’s use the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
package main
import (
   "fmt"
   "net"
)
func main() {
   // Connect to the server at the UNIX socket
   conn, err := net.Dial("unix", "/tmp/example.sock")
   if err != nil {
      fmt.Println("Error dialing:", err)
      return
   }
   defer conn.Close()
   // Send a message
   _, err = conn.Write([]byte("Hello UNIX socket!\n"))
   if err != nil {
      fmt.Println("Error writing to socket:", err)
      return
   }
   buffer := make([]byte, 1024)
   n, err := conn.Read(buffer)
   if err != nil {
      fmt.Println("Error reading from socket:", err)
      return
   }
   fmt.Println("Server response:", string(buffer[:n]))
}</pre>			<p>Let’s examine this <a id="_idIndexMarker341"/>client code <span class="No-Break">in detail:</span></p>
			<ul>
				<li><strong class="source-inline">net.Dial("unix", "/tmp/example.sock")</strong> attempts to establish a connection to a UNIX <span class="No-Break">socket server.</span></li>
				<li><strong class="source-inline">"unix"</strong> specifies the connection type, indicating a <span class="No-Break">UNIX socket.</span></li>
				<li><strong class="source-inline">"/tmp/example.sock"</strong> is the path to the socket file where the server is expected to <span class="No-Break">be listening.</span></li>
				<li>If there’s an error in connecting (such as if the server isn’t running or the socket file doesn’t exist), the error is printed and the <span class="No-Break">program exits.</span></li>
				<li><strong class="source-inline">defer conn.Close()</strong> ensures that the connection to the socket is closed when the main function exits, irrespective of how it exists. It’s a deferred call, which means it will execute at the end of the <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> function.</span></li>
				<li><strong class="source-inline">conn.Write([]byte("Hello UNIX socket!\n"))</strong> sends a message to <span class="No-Break">the server.</span></li>
				<li>The <strong class="source-inline">"Hello UNIX socket!\n"</strong> string is converted into a byte slice as the <strong class="source-inline">Write</strong> method requires a byte slice <span class="No-Break">as input.</span></li>
				<li>The <strong class="source-inline">_</strong> character is used to ignore the first return value, which is the number of <span class="No-Break">bytes written.</span></li>
				<li>If there’s an error in writing to the socket, the error is printed and the <span class="No-Break">program exits.</span></li>
				<li>Buffer creation: <strong class="source-inline">buffer := make([]byte, 1024)</strong> initializes a byte slice with a length of 1,024 bytes to store the response from <span class="No-Break">the server.</span></li>
				<li>Read operation: <strong class="source-inline">n, err := conn.Read(buffer)</strong> reads the response from the server into the buffer, where <strong class="source-inline">n</strong> is the number of bytes read and <strong class="source-inline">err</strong> captures any error during the <span class="No-Break">read operation.</span></li>
				<li>If there’s an error in reading from the socket, the error is printed and the <span class="No-Break">program exits.</span></li>
				<li><strong class="source-inline">fmt.Println("Server response:", string(buffer[:n]))</strong> prints the<a id="_idIndexMarker342"/> response received from the server. <strong class="source-inline">buffer[:n]</strong> converts the read bytes back into a string <span class="No-Break">for display.</span></li>
			</ul>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor166"/>Inspecting the socket with lsof</h2>
			<p>On Unix-like <a id="_idIndexMarker343"/>systems, the <strong class="bold">List Open Files</strong> (<strong class="bold">lsof</strong>) command<a id="_idIndexMarker344"/> offers insights into files accessed by processes. UNIX sockets, treated as a file, can be examined using <strong class="source-inline">lsof</strong> to gather <span class="No-Break">relevant information.</span></p>
			<p>To use <strong class="source-inline">lsof</strong> to inspect the socket, we should start the server program so that it creates and listens on the UNIX socket. In the terminal, you can run <strong class="source-inline">lsof</strong> with the <strong class="source-inline">-U</strong> flag (which stands for UNIX sockets) and the <strong class="source-inline">-a</strong> flag to combine the conditions. You can also specify the path to the <span class="No-Break">socket file:</span></p>
			<pre class="console">
lsof -Ua /tmp/example.sock</pre>			<p>This command <a id="_idIndexMarker345"/>will show you details about the UNIX socket, including <a id="_idIndexMarker346"/>the <strong class="bold">process ID</strong> (<strong class="bold">PID</strong>) of the<a id="_idIndexMarker347"/> server that’s listening to it. If the client is connected when running <strong class="source-inline">lsof</strong>, you’ll see entries for both the server and <span class="No-Break">the client.</span></p>
			<p>The full version of the client and server can be found in the <strong class="source-inline">ch7/example1</strong> directory of our <span class="No-Break">Git repository.</span></p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor167"/>Building a chat server</h1>
			<p>Before writing any code, we should state our goals for creating this <span class="No-Break">chat system.</span></p>
			<p>The <a id="_idIndexMarker348"/>chat server is designed to listen on a UNIX socket at <strong class="source-inline">/tmp/chat.sock</strong>. The code should handle creating and managing this socket, ensuring any existing socket file is removed before starting, thereby <span class="No-Break">avoiding conflicts.</span></p>
			<p>Upon launching, the server should maintain a continuous loop, perpetually waiting for new client connections. Each successful connection is handled in a separate goroutine, allowing the server to manage multiple <span class="No-Break">clients concurrently.</span></p>
			<p>One of the key features of this server is its ability to manage multiple client connections simultaneously. To achieve this, combining slices to store client connections and a mutex for concurrent access control seems like a good idea, ensuring thread-safe operations on <span class="No-Break">shared data.</span></p>
			<p>Whenever a new client connects, the server should send them the entire history of messages, providing a context-rich experience. This historical context is vital in a chat application, allowing newly joined users to catch up on <span class="No-Break">the conversation.</span></p>
			<p>Does it seem like there are too many concerns to handle at once? Don’t worry! We’ll expand the feature in baby steps until we get to the final version of <span class="No-Break">our server.</span></p>
			<p>To help you understand the development of the chat server using UNIX sockets in Go, it’s effective to decompose the final version into simpler, preliminary stages. Each stage will introduce a key<a id="_idIndexMarker349"/> feature or concept, building toward the final version. Here’s a <span class="No-Break">step-by-step guide:</span></p>
			<ol>
				<li><strong class="bold">Basic UNIX </strong><span class="No-Break"><strong class="bold">socket server</strong></span><span class="No-Break">:</span><p class="list-inset">Create a simple server that listens on a UNIX socket and can accept <span class="No-Break">a connection:</span></p><pre class="source-code">
package main
import (
     "fmt"
     "net"
     "os"
)
const socketPath = "/tmp/example.sock"
func main() {
     os.Remove(socketPath)
     listener, err := net.Listen("unix", socketPath)
     if err != nil {
          fmt.Println("Error creating listener:", err)
          return
     }
     defer listener.Close()
     fmt.Println("Server is listening...")
     conn, err := listener.Accept()
     if err != nil {
          fmt.Println("Error accepting connection:", err)
          return
     }
     conn.Close()
}</pre></li>				<li><strong class="bold">Handling a </strong><span class="No-Break"><strong class="bold">single client</strong></span><span class="No-Break">:</span><p class="list-inset">Extend the <a id="_idIndexMarker350"/>server to read a message from one client and print it to <span class="No-Break">the console:</span></p><pre class="source-code">
// ... (previous imports)
func main() {
     // ... (existing setup and listener code)
     for {
          conn, err := listener.Accept()
          if err != nil {
               fmt.Println("Error accepting connection:", err)
               continue
          }
          handleConnection(conn)
     }
}
func handleConnection(conn net.Conn) {
     defer conn.Close()
     buffer := make([]byte, 1024)
     n, err := conn.Read(buffer)
     if err != nil {
          fmt.Println("Error reading from connection:", err)
          return
     }
     fmt.Println("Received:", string(buffer[:n]))
}</pre></li>				<li><strong class="bold">Handling </strong><span class="No-Break"><strong class="bold">multiple clients</strong></span><span class="No-Break">:</span><p class="list-inset">Modify the <a id="_idIndexMarker351"/>server to handle multiple client <span class="No-Break">connections concurrently:</span></p><pre class="source-code">
// ... (previous imports)
var (
     clients []net.Conn
     mutex   sync.Mutex
)
func main() {
     // ... (existing setup and listener code)
     for {
          conn, err := listener.Accept()
          if err != nil {
               fmt.Println("Error accepting connection:", err)
               continue
          }
          mutex.Lock()
          clients = append(clients, conn)
          mutex.Unlock()
          go handleConnection(conn)
     }
}
// ... (existing handleConnection function)</pre></li>				<li><strong class="bold">Broadcasting messages to </strong><span class="No-Break"><strong class="bold">all clients</strong></span><span class="No-Break">:</span><p class="list-inset">Implement a <a id="_idIndexMarker352"/>feature to broadcast received messages to all <span class="No-Break">connected clients:</span></p><pre class="source-code">
// ... (previous imports and global variables)
func main() {
     // ... (existing setup and listener code)
     for {
          // ... (existing connection acceptance code)
     }
}
func handleConnection(conn net.Conn) {
     defer conn.Close()
     buffer := make([]byte, 1024)
     for {
          n, err := conn.Read(buffer)
          if err != nil {
               removeClient(conn)
               break
          }
          message := string(buffer[:n])
          broadcastMessage(message)
     }
}
func broadcastMessage(message string) {
     mutex.Lock()
     defer mutex.Unlock()
     for _, client := range clients {
          client.Write([]byte(message + "\n"))
     }
}
func removeClient(conn net.Conn) {
     // ... (client removal logic)
}</pre></li>				<li><strong class="bold">Adding </strong><span class="No-Break"><strong class="bold">message history</strong></span><span class="No-Break">:</span><p class="list-inset">Store a <a id="_idIndexMarker353"/>history of messages and send it to new clients <span class="No-Break">upon connection:</span></p><pre class="source-code">
// ... (previous imports, global variables, and main function)
func handleConnection(conn net.Conn) {
     // Send message history to the new client
     for _, msg := range messageHistory {
          conn.Write([]byte(msg + "\n"))
     }
     // ... (existing reading and broadcasting code)
}
// ... (existing broadcastMessage and removeClient functions)</pre></li>			</ol>
			<p>Nice! We’ve <a id="_idIndexMarker354"/>completed the chat server with all the features. Now, it’s time to create <span class="No-Break">our client.</span></p>
			<p>The client should establish a connection to a server listening on a specific UNIX socket (<strong class="source-inline">/tmp/chat.sock</strong>). After establishing a connection, the client will send a message to the server. Also, the client should handle the response from the server, read it, and display it on the console. Throughout its operations (connecting, sending, and receiving), the client should handle any potential errors, printing them out if they occur. Lastly, the client must ensure that the socket connection is properly closed before exiting, regardless of whether it exits normally or due to <span class="No-Break">an error.</span></p>
			<p>Now, let’s break down the development of this client into <span class="No-Break">simpler stages:</span></p>
			<ol>
				<li><strong class="bold">Establishing a connection to </strong><span class="No-Break"><strong class="bold">the server</strong></span><span class="No-Break">:</span><p class="list-inset">Create a client that connects to a UNIX <span class="No-Break">socket server:</span></p><pre class="source-code">
package main
import (
     "fmt"
     "net"
)
const socketPath = "/tmp/chat.sock"
func main() {
     conn, err := net.Dial("unix", socketPath)
     if err != nil {
          fmt.Println("Failed to connect to server:", err)
          return
     }
     defer conn.Close()
     fmt.Println("Connected to server.")
}</pre></li>				<li><strong class="bold">Listening for messages from </strong><span class="No-Break"><strong class="bold">the server</strong></span><span class="No-Break">:</span><p class="list-inset">Add<a id="_idIndexMarker355"/> functionality to listen and print messages from <span class="No-Break">the server:</span></p><pre class="source-code">
// ... (previous imports)
func main() {
     // ... (existing connection code)
     go func() {
          scanner := bufio.NewScanner(conn)
          for scanner.Scan() {
               fmt.Println("Message from server:", scanner.Text())
          }
     }()
     // Prevent the main goroutine from exiting immediately
     fmt.Println("Connected. Press Ctrl+C to exit.")
     select {} // Blocks forever
}</pre></li>				<li><strong class="bold">Sending messages to </strong><span class="No-Break"><strong class="bold">the server</strong></span><span class="No-Break">:</span><p class="list-inset">Enable the<a id="_idIndexMarker356"/> client to send messages to <span class="No-Break">the server:</span></p><pre class="source-code">
// ... (previous imports)
func main() {
     // ... (existing connection and server listening code)
     scanner := bufio.NewScanner(os.Stdin)
     fmt.Println("Enter message:")
     for scanner.Scan() {
          message := scanner.Text()
          conn.Write([]byte(message))
     }
}</pre></li>				<li><strong class="bold">Proper synchronization </strong><span class="No-Break"><strong class="bold">with WaitGroup</strong></span><span class="No-Break">:</span><p class="list-inset">Use <strong class="source-inline">sync.WaitGroup</strong> to manage goroutine synchronization and prevent premature <span class="No-Break">program termination:</span></p><pre class="source-code">
// ... (previous imports)
func main() {
     // ... (existing connection code)
     var wg sync.WaitGroup
     wg.Add(1)
     go func() {
          defer wg.Done()
          // ... (existing server message handling code)
     }()
     // ... (existing message sending code)
     wg.Wait() // Wait for the goroutine to finish
}</pre></li>			</ol>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor168"/>The complete chat client</h2>
			<p>Since we’re familiar with the<a id="_idIndexMarker357"/> details, let’s look at the complete <span class="No-Break">client code:</span></p>
			<pre class="source-code">
package main
import (
   «bufio»
   «fmt»
   «net»
   «os»
   «sync»
)
const socketPath = "/tmp/chat.sock"
func main() {
   conn, err := net.Dial("unix", socketPath)
   if err != nil {
      fmt.Println("Failed to connect to server:", err)
      return
   }
   defer conn.Close()
   var wg sync.WaitGroup
   wg.Add(1)
   // Ouve mensagens do servidor
   go func() {
      defer wg.Done()
      scanner := bufio.NewScanner(conn)
      for scanner.Scan() {
         fmt.Println("Message from server:", scanner.Text())
      }
   }()
   // Envia mensagens para o servidor
   scanner := bufio.NewScanner(os.Stdin)
   fmt.Println("message:")
   for scanner.Scan() {
      message := scanner.Text()
      conn.Write([]byte(message))
   }
   wg.Wait()
}</pre>			<p>Approaching the<a id="_idIndexMarker358"/> development as a step-by-step process is helpful in understanding each component’s role in the final program as the <span class="No-Break">complexity increases.</span></p>
			<p>Now it’s your turn! Spin the server to a couple of clients and play with our <span class="No-Break">chat system.</span></p>
			<p>The full version of the client and server can be found in the <strong class="source-inline">ch7/chat</strong> directory of our <span class="No-Break">GitHub repository.</span></p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor169"/>Serving HTTP under UNIX domain sockets</h1>
			<p>Exposing HTTP APIs under a<a id="_idIndexMarker359"/> Unix domain socket? Well, that’s one way to keep things interesting in networking. Let’s explore the benefits of this <span class="No-Break">unconventional approach.</span></p>
			<p>Unix domain sockets are a secure choice for services that should remain confined to a specific machine. They offer fine-grained access control through filesystem permissions, making managing who can interact with your HTTP <span class="No-Break">API easier.</span></p>
			<p>Why settle for regular old networking when you can have the luxury of lower latency and fewer context switches? This can be especially useful in <span class="No-Break">high-throughput environments.</span></p>
			<p>By utilizing Unix domain sockets, you can avoid consuming TCP ports, which may be a limited resource on <span class="No-Break">some systems.</span></p>
			<p>Unix domain sockets eliminate the need to manage IP addresses and port numbers, simplifying setup and configuration, especially for local communication. Also, they seamlessly integrate with the Unix/Linux ecosystem, making them a natural choice for applications deeply embedded in <span class="No-Break">this environment.</span></p>
			<p>For legacy systems or applications with specific protocol requirements, Unix domain sockets may be the best or only option for <span class="No-Break">efficient communication.</span></p>
			<p>To create an HTTP server listening on a Unix domain socket in Go, you can use the <strong class="source-inline">net</strong> and <span class="No-Break"><strong class="source-inline">net/http</strong></span><span class="No-Break"> packages.</span></p>
			<p>Let’s take a <a id="_idIndexMarker360"/>step-by-step approach to explore <span class="No-Break">the server:</span></p>
			<ol>
				<li>HTTP <span class="No-Break">handler function:</span><pre class="source-code">
http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
    _, err := w.Write([]byte("Hello, world!"))
    if err != nil {
       http.Error(w, "Internal Server Error", http.StatusInternalServerError)
       log.Println("Error writing response:", err)
    }
})</pre><ul><li>We start by defining an HTTP handler function using <strong class="source-inline">http.HandleFunc</strong>. This function handles all incoming HTTP requests to the root path (<strong class="source-inline">"/"</strong>) and responds with <strong class="source-inline">"Hello, world!"</strong> using the <span class="No-Break">response writer.</span></li></ul></li>				<li>Unix socket and <span class="No-Break">listener setup:</span><pre class="source-code">
socketPath := "/tmp/go-server.sock"
listener, err := net.Listen("unix", socketPath)
if err != nil {
    log.Fatal("Listen (UNIX socket):", err)
}
log.Println("Server is listening on", socketPath)</pre><ul><li>We specify the Unix socket path as <strong class="source-inline">socketPath</strong>, which is set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">"/tmp/go-server.sock"</strong></span><span class="No-Break">.</span></li><li><strong class="source-inline">net.Listen("unix", socketPath)</strong> sets up a Unix socket server to accept incoming connections on the <span class="No-Break">specified path.</span></li><li>We use the standard Go <strong class="source-inline">log</strong> package for basic logging. We log a message when the server is listening on the specified <span class="No-Break">socket path.</span></li></ul></li>				<li><span class="No-Break">Graceful shutdown:</span><pre class="source-code">
sigCh := make(chan os.Signal, 1)
signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)</pre><ul><li>We created a signal channel, <strong class="source-inline">sigCh</strong>, to capture <strong class="source-inline">SIGINT</strong> (<em class="italic">Ctrl</em> + <em class="italic">C</em>) and <strong class="source-inline">SIGTERM</strong> (termination signal) signals for graceful <span class="No-Break">server shutdown</span></li><li>We use <strong class="source-inline">signal.Notify</strong> to notify the channel when these signals <span class="No-Break">are received</span></li></ul></li>				<li>Goroutine <a id="_idIndexMarker361"/><span class="No-Break">for shutdown:</span><pre class="source-code">
go func() {
    &lt;-sigCh
    log.Println("Shutting down gracefully...")
    listener.Close()
    os.Remove(socketPath)
    os.Exit(0)
}()</pre><ul><li>We launch a goroutine to handle graceful shutdown. The goroutine waits for signals <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">sigCh</strong></span><span class="No-Break">.</span></li><li>When a signal is received, it logs a message, closes the Unix socket listener using <strong class="source-inline">listener.Close()</strong>, removes the Unix socket file using <strong class="source-inline">os.Remove(socketPath)</strong>, and exits the program <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">os.Exit(0)</strong></span><span class="No-Break">.</span></li></ul></li>				<li>HTTP <span class="No-Break">server start:</span><pre class="source-code">
err = http.Serve(listener, nil)
if err != nil &amp;&amp; err != http.ErrServerClosed {
    log.Fatal("HTTP server error:", err)
}</pre><ul><li>We start the HTTP server using <strong class="source-inline">http.Serve(listener, nil)</strong>. It listens for incoming HTTP requests on the Unix socket listener we <span class="No-Break">created earlier.</span></li><li>We <a id="_idIndexMarker362"/>handle any errors returned by <strong class="source-inline">http.Serve</strong> and log them if necessary. We also check for the special case <strong class="source-inline">http.ErrServerClosed</strong> to determine whether the server was gracefully <span class="No-Break">shut down.</span></li></ul></li>			</ol>
			<p>Now, let’s tackle the client-side setup after covering the <span class="No-Break">server intricacies.</span></p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor170"/>Client</h2>
			<p>When creating a<a id="_idIndexMarker363"/> client for this situation, we can assume the HTTP response body is text-based (<span class="No-Break">plain text).</span></p>
			<p class="callout-heading">Note:</p>
			<p class="callout">If you’re dealing with binary data, you must handle <span class="No-Break">it differently.</span></p>
			<p>Let’s progressively create <span class="No-Break">our client:</span></p>
			<pre class="source-code">
package main
import (
     "bufio"
     "fmt"
     "net"
     "net/http"
     "net/textproto"
     "strings"
)
const socketPath = "/tmp/go-server.sock"
func main() {
     // Dial the Unix socket
     conn, err := net.Dial("unix", socketPath)
     if err != nil {
          fmt.Println("Error connecting to the Unix socket:", err)
          return
     }
     defer conn.Close()
     // Make an HTTP request
     request := "GET / HTTP/1.1\r\n" +
          "Host: localhost\r\n" +
          "\r\n"
     _, err = conn.Write([]byte(request))
     if err != nil {
          fmt.Println("Error sending the request:", err)
          return
     }
     // Read the response
     reader := bufio.NewReader(conn)
     tp := textproto.NewReader(reader)
     // Read and print the status line
     statusLine, err := tp.ReadLine()
     if err != nil {
          fmt.Println("Error reading the status line:", err)
          return
     }
     fmt.Println("Status Line:", statusLine)
     // Read and print headers
     headers, err := tp.ReadMIMEHeader()
     if err != nil {
          fmt.Println("Error reading headers:", err)
          return
     }
     for key, values := range headers {
          for _, value := range values {
               fmt.Printf("%s: %s\n", key, value)
          }
     }
     // Read and print the body (assuming it's text-based)
     for {
          line, err := reader.ReadString('\n')
          if err != nil {
               if err.Error() != "EOF" {
                    fmt.Println("Error reading the response body:", err)
               }
               break
          }
          fmt.Print(line)
     }
}</pre>			<p>The three main <a id="_idIndexMarker364"/>parts of the code are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Connects to the Unix socket</strong>: It uses <strong class="source-inline">net.Dial</strong> to connect to the Unix socket <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">/tmp/go-server.sock</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Sends an HTTP request</strong>: It sends a simple HTTP GET request to the root path (<strong class="source-inline">/</strong>). The <strong class="source-inline">Host: localhost</strong> header is included to conform to <span class="No-Break">HTTP/1.1 standards.</span></li>
				<li><strong class="bold">Reads the response</strong>: It reads the response from the server using <strong class="source-inline">bufio.Reader</strong>. The status line and headers are parsed and printed out. The body of the <a id="_idIndexMarker365"/>response is then printed out <span class="No-Break">as well.</span></li>
			</ul>
			<p>Now we should explore some of the choices and <span class="No-Break">their details.</span></p>
			<p>The request is intended to be sent over a network connection, such as a Unix domain socket, to an HTTP server. Let’s break down this request into its <span class="No-Break">individual components.</span></p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor171"/>HTTP request line</h2>
			<p><strong class="source-inline">GET / </strong><span class="No-Break"><strong class="source-inline">HTTP/1.1\r\n</strong></span></p>
			<ul>
				<li><strong class="bold">Method</strong>: GET – This is the <a id="_idIndexMarker366"/>HTTP method being used. GET is used to request data from a specified resource. In this case, it’s asking the server to send the data located at the root <span class="No-Break">URL (</span><span class="No-Break"><strong class="source-inline">/</strong></span><span class="No-Break">).</span></li>
				<li><strong class="bold">Path</strong>: <strong class="source-inline">/</strong> – This is the path of the resource being requested. <strong class="source-inline">/</strong> signifies the root path, which usually corresponds to the home page or main page of a website <span class="No-Break">or API.</span></li>
				<li><strong class="bold">Protocol version</strong>: <strong class="source-inline">HTTP/1.1</strong> – This specifies the version of the HTTP protocol being used. HTTP/1.1 is a common version that introduces several improvements over HTTP/1.0, such as <span class="No-Break">persistent connections.</span></li>
				<li><strong class="bold">Line ending</strong>: <strong class="source-inline">\r\n</strong> – This is a carriage return (<strong class="source-inline">\r</strong>) followed by a line feed (<strong class="source-inline">\n</strong>), which together signify the end of a line in<a id="_idIndexMarker367"/> the HTTP protocol. HTTP headers must end <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">\r\n</strong></span><span class="No-Break">.</span></li>
			</ul>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor172"/>HTTP request header</h2>
			<p><span class="No-Break"><strong class="source-inline">Host: localhost\r\n</strong></span></p>
			<ul>
				<li><strong class="bold">Host header</strong>: <strong class="source-inline">Host: localhost</strong> – The host<a id="_idIndexMarker368"/> header specifies the server’s domain name (the host) to which the request is being sent. This is mandatory in HTTP/1.1 and is used to distinguish between different domains hosted on the same server (virtual hosting). Here, <strong class="source-inline">localhost</strong> is used as <span class="No-Break">the host.</span></li>
				<li><strong class="bold">Header line ending</strong>: <strong class="source-inline">\r\n</strong> – Again, the carriage return and line feed signify the end of the <span class="No-Break">header line.</span></li>
			</ul>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor173"/>Empty line signifying end of headers</h2>
			<p><strong class="source-inline">\</strong><span class="No-Break"><strong class="source-inline">r\n</strong></span></p>
			<p>This empty line (just <strong class="source-inline">\r\n</strong>) indicates<a id="_idIndexMarker369"/> the end of the header section and the beginning of the body section of the HTTP request. Since a GET request does not typically include a body, this line signifies the end of <span class="No-Break">the request.</span></p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor174"/>The textproto package</h2>
			<p>In our program, the <strong class="source-inline">textproto</strong> package <a id="_idIndexMarker370"/>is utilized <a id="_idIndexMarker371"/>to read and parse the response headers from the HTTP server, <span class="No-Break">but why?</span></p>
			<p>The first motivation is convenience: <strong class="source-inline">textproto</strong> simplifies the process of reading and parsing text-based protocols. Without it, you’d have to manually parse the response, which could be error-prone <span class="No-Break">and inefficient.</span></p>
			<p>Moreover, <strong class="source-inline">textproto</strong> ensures compliance with the text-based protocol’s specifications. It correctly handles nuances such as line endings (<strong class="source-inline">\r\n</strong>) and the format <span class="No-Break">of headers.</span></p>
			<p>It integrates well with <a id="_idIndexMarker372"/>Go’s <strong class="bold">buffered I/O</strong> (<strong class="bold">bufio</strong>), making it efficient for network communication where data may arrive <span class="No-Break">in bursts.</span></p>
			<p>While <a id="_idIndexMarker373"/>designed with HTTP in mind, <strong class="source-inline">textproto</strong> is versatile <a id="_idIndexMarker374"/>enough to be used with other text-based protocols, making it a useful tool in the Go standard library for network programming <span class="No-Break">in general.</span></p>
			<p>Now that we’ve explored our application using UNIX sockets over HTTP, let’s take a look into some important performance considerations to optimize our socket-based applications and the most common <span class="No-Break">use cases.</span></p>
			<p>The full version of the client and server communicating over HTTP can be found in the <strong class="source-inline">ch7/http2unix</strong> directory of our <span class="No-Break">Git repository.</span></p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor175"/>Performance</h2>
			<p>Unix domain sockets don’t <a id="_idIndexMarker375"/>require the network stack’s overhead, as there’s no need to route data through the network layers. This reduces the CPU cycles spent on processing network protocols. Unix domain sockets often allow for more efficient data transfer mechanisms within the kernel, such as sending a file, which can reduce the amount of data copying between the kernel and user spaces. They communicate within the same host, so the latency is typically lower than TCP sockets, which may involve more complex routing even when communicating between processes on the <span class="No-Break">same machine.</span></p>
			<p>You might ask yourself: <em class="italic">Is it faster than calling the loopback </em><span class="No-Break"><em class="italic">interface (localhost)?</em></span></p>
			<p><em class="italic">Yes!</em> The loopback interface still goes through the TCP/IP stack, even though it doesn’t leave the machine. This involves more processing, such as packaging data into TCP segments and <span class="No-Break">IP packets.</span></p>
			<p>They can be more efficient regarding data copying between the kernel and user spaces. Some Unix domain socket implementations allow for zero-copy operations, where data is directly passed between the client and server without redundant copying. This is not possible using TCP/IP since its communication typically involves more data copying between the kernel and <span class="No-Break">user spaces.</span></p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor176"/>Other common use cases</h2>
			<p>Several systems rely on<a id="_idIndexMarker376"/> the benefits of Unix domain sockets, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">System V IPC</strong>: This is a category of mechanisms in Unix-like operating systems, including <a id="_idIndexMarker377"/>UNIX domain sockets, message queues, semaphore sets, and shared memory. UNIX domain sockets are often used for efficient and fast communication between processes within the <span class="No-Break">same system.</span></li>
				<li><strong class="bold">X Window System (X11)</strong>: X11, the graphical windowing system used in Unix-like operating systems, can <a id="_idIndexMarker378"/>use UNIX domain sockets for communication between the X server and client applications. This allows for display and <span class="No-Break">input management.</span></li>
				<li><strong class="bold">D-Bus</strong>: D-Bus<a id="_idIndexMarker379"/> is a message bus system used for communication between applications. It is widely used on Linux systems and relies heavily on UNIX domain sockets for local communication <span class="No-Break">between processes.</span></li>
				<li><strong class="bold">Systemd</strong>: Systemd, the init <a id="_idIndexMarker380"/>system and service manager for Linux, uses UNIX domain sockets for communication between its various components and services. It is integral to the boot process and <span class="No-Break">system management.</span></li>
				<li><strong class="bold">MySQL and PostgreSQL</strong>: These popular relational database management systems can use <a id="_idIndexMarker381"/>UNIX domain<a id="_idIndexMarker382"/> sockets for local client-server communication. This provides a fast and secure way for applications to connect to the <span class="No-Break">database server.</span></li>
				<li><strong class="bold">Redis</strong>: Redis, an<a id="_idIndexMarker383"/> in-memory key-value store, can use UNIX domain sockets for local client-server communication. This provides low-latency and high-throughput <span class="No-Break">data access.</span></li>
				<li><strong class="bold">Nginx and Apache</strong>: These <a id="_idIndexMarker384"/>web servers can use UNIX domain sockets to communicate with backend application<a id="_idIndexMarker385"/> servers or<a id="_idIndexMarker386"/> FastCGI processes. It’s a more efficient way to proxy requests than TCP/IP sockets when both processes are on the <span class="No-Break">same machine.</span></li>
			</ul>
			<p>With an understanding of UNIX socket use cases, let’s zoom out and summarize what <span class="No-Break">we’ve learned.</span></p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor177"/>Summary</h1>
			<p>In this chapter, we have explored the fundamental concepts and practical applications of UNIX sockets. We learned about UNIX sockets and their role in IPC on UNIX and UNIX-like systems. The chapter provided insights into how UNIX sockets differ from TCP/IP sockets, emphasizing their use for local, <span class="No-Break">efficient IPC.</span></p>
			<p>Through examples, you gained hands-on experience in creating and managing a UNIX socket server and client. Also, this chapter highlighted the efficiency of UNIX sockets in data transfer without network protocol overhead and their security aspects controlled by <span class="No-Break">filesystem permissions.</span></p>
			<p>This knowledge is vital for developing efficient and secure software systems, enhancing the reader’s ability to design and implement robust networked applications in <span class="No-Break">IPC scenarios.</span></p>
			<p>Looking ahead, the next chapter, <a href="B21662_08.xhtml#_idTextAnchor179"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Memory Management</em>, shifts our focus from IPC to the internal workings of the Go runtime and its garbage collector. We will explore how memory is allocated, managed, <span class="No-Break">and optimized.</span></p>
		</div>
	</div>
</div>


<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer016" class="Content">
			<h1 id="_idParaDest-141" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor178"/>Part 3: Performance</h1>
			<p>In this part, we will take a tour on advanced topics that are crucial for developing high-performance, efficient, and reliable Go applications. This section focuses on memory management, performance analysis. By understanding these concepts, you’ll be better equipped to optimize your Go applications and manage system <span class="No-Break">resources effectively.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B21662_08.xhtml#_idTextAnchor179"><em class="italic">Chapter 8</em></a>, <em class="italic">Memory Management</em></li>
				<li><a href="B21662_09.xhtml#_idTextAnchor193"><em class="italic">Chapter 9</em></a>, <em class="italic">Analysing Performance</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer017">
			</div>
		</div>
	</div>
</div>
</body></html>