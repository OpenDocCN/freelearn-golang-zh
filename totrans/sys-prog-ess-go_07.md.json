["```go\n    socketPath := \"/tmp/example.sock\"\n    if err := os.Remove(socketPath); err != nil && !os.IsNotExist(err) {\n        log.Printf(\"Error removing socket file: %v\", err)\n        return\n    }\n    ```", "```go\n    listener, err := net.Listen(\"unix\", socketPath)\n    if err != nil {\n        log.Printf(\"Error listening: %v\", err)\n        return\n    }\n    defer listener.Close()\n    fmt.Println(\"Listening on\", socketPath)\n    ```", "```go\n    signals := make(chan os.Signal, 1)\n    signal.Notify(signals, syscall.SIGINT, syscall.SIGTERM)\n    go func() {\n        <-signals\n        fmt.Println(\"Received termination signal. Shutting down gracefully...\")\n        listener.Close()\n        os.Remove(socketPath)\n        os.Exit(0)\n    }()\n    ```", "```go\n    for {\n        conn, err := listener.Accept()\n        if err != nil {\n           log.Printf(\"Error accepting connection: %v\", err)\n           continue\n        }\n        go handleConnection(conn)\n    }\n    ```", "```go\n    func handleConnection(conn net.Conn) {\n        defer conn.Close()\n        buffer := make([]byte, 1024)\n        n, err := conn.Read(buffer)\n        if err != nil {\n           log.Printf(\"Error reading from connection: %v\", err)\n           return\n        }\n        fmt.Println(\"Received:\", string(buffer[:n]))\n        // Simulate a response back to the client\n        response := []byte(\"Message received successfully\\n\")\n        _, err = conn.Write(response)\n        if err != nil {\n           log.Printf(\"Error writing response to connection: %v\", err)\n           return\n        }\n    }\n    ```", "```go\ngo run main.go\n```", "```go\nListening on /tmp/example.sock\n```", "```go\npackage main\nimport (\n   \"fmt\"\n   \"net\"\n)\nfunc main() {\n   // Connect to the server at the UNIX socket\n   conn, err := net.Dial(\"unix\", \"/tmp/example.sock\")\n   if err != nil {\n      fmt.Println(\"Error dialing:\", err)\n      return\n   }\n   defer conn.Close()\n   // Send a message\n   _, err = conn.Write([]byte(\"Hello UNIX socket!\\n\"))\n   if err != nil {\n      fmt.Println(\"Error writing to socket:\", err)\n      return\n   }\n   buffer := make([]byte, 1024)\n   n, err := conn.Read(buffer)\n   if err != nil {\n      fmt.Println(\"Error reading from socket:\", err)\n      return\n   }\n   fmt.Println(\"Server response:\", string(buffer[:n]))\n}\n```", "```go\nlsof -Ua /tmp/example.sock\n```", "```go\n    package main\n    import (\n         \"fmt\"\n         \"net\"\n         \"os\"\n    )\n    const socketPath = \"/tmp/example.sock\"\n    func main() {\n         os.Remove(socketPath)\n         listener, err := net.Listen(\"unix\", socketPath)\n         if err != nil {\n              fmt.Println(\"Error creating listener:\", err)\n              return\n         }\n         defer listener.Close()\n         fmt.Println(\"Server is listening...\")\n         conn, err := listener.Accept()\n         if err != nil {\n              fmt.Println(\"Error accepting connection:\", err)\n              return\n         }\n         conn.Close()\n    }\n    ```", "```go\n    // ... (previous imports)\n    func main() {\n         // ... (existing setup and listener code)\n         for {\n              conn, err := listener.Accept()\n              if err != nil {\n                   fmt.Println(\"Error accepting connection:\", err)\n                   continue\n              }\n              handleConnection(conn)\n         }\n    }\n    func handleConnection(conn net.Conn) {\n         defer conn.Close()\n         buffer := make([]byte, 1024)\n         n, err := conn.Read(buffer)\n         if err != nil {\n              fmt.Println(\"Error reading from connection:\", err)\n              return\n         }\n         fmt.Println(\"Received:\", string(buffer[:n]))\n    }\n    ```", "```go\n    // ... (previous imports)\n    var (\n         clients []net.Conn\n         mutex   sync.Mutex\n    )\n    func main() {\n         // ... (existing setup and listener code)\n         for {\n              conn, err := listener.Accept()\n              if err != nil {\n                   fmt.Println(\"Error accepting connection:\", err)\n                   continue\n              }\n              mutex.Lock()\n              clients = append(clients, conn)\n              mutex.Unlock()\n              go handleConnection(conn)\n         }\n    }\n    // ... (existing handleConnection function)\n    ```", "```go\n    // ... (previous imports and global variables)\n    func main() {\n         // ... (existing setup and listener code)\n         for {\n              // ... (existing connection acceptance code)\n         }\n    }\n    func handleConnection(conn net.Conn) {\n         defer conn.Close()\n         buffer := make([]byte, 1024)\n         for {\n              n, err := conn.Read(buffer)\n              if err != nil {\n                   removeClient(conn)\n                   break\n              }\n              message := string(buffer[:n])\n              broadcastMessage(message)\n         }\n    }\n    func broadcastMessage(message string) {\n         mutex.Lock()\n         defer mutex.Unlock()\n         for _, client := range clients {\n              client.Write([]byte(message + \"\\n\"))\n         }\n    }\n    func removeClient(conn net.Conn) {\n         // ... (client removal logic)\n    }\n    ```", "```go\n    // ... (previous imports, global variables, and main function)\n    func handleConnection(conn net.Conn) {\n         // Send message history to the new client\n         for _, msg := range messageHistory {\n              conn.Write([]byte(msg + \"\\n\"))\n         }\n         // ... (existing reading and broadcasting code)\n    }\n    // ... (existing broadcastMessage and removeClient functions)\n    ```", "```go\n    package main\n    import (\n         \"fmt\"\n         \"net\"\n    )\n    const socketPath = \"/tmp/chat.sock\"\n    func main() {\n         conn, err := net.Dial(\"unix\", socketPath)\n         if err != nil {\n              fmt.Println(\"Failed to connect to server:\", err)\n              return\n         }\n         defer conn.Close()\n         fmt.Println(\"Connected to server.\")\n    }\n    ```", "```go\n    // ... (previous imports)\n    func main() {\n         // ... (existing connection code)\n         go func() {\n              scanner := bufio.NewScanner(conn)\n              for scanner.Scan() {\n                   fmt.Println(\"Message from server:\", scanner.Text())\n              }\n         }()\n         // Prevent the main goroutine from exiting immediately\n         fmt.Println(\"Connected. Press Ctrl+C to exit.\")\n         select {} // Blocks forever\n    }\n    ```", "```go\n    // ... (previous imports)\n    func main() {\n         // ... (existing connection and server listening code)\n         scanner := bufio.NewScanner(os.Stdin)\n         fmt.Println(\"Enter message:\")\n         for scanner.Scan() {\n              message := scanner.Text()\n              conn.Write([]byte(message))\n         }\n    }\n    ```", "```go\n    // ... (previous imports)\n    func main() {\n         // ... (existing connection code)\n         var wg sync.WaitGroup\n         wg.Add(1)\n         go func() {\n              defer wg.Done()\n              // ... (existing server message handling code)\n         }()\n         // ... (existing message sending code)\n         wg.Wait() // Wait for the goroutine to finish\n    }\n    ```", "```go\npackage main\nimport (\n   «bufio»\n   «fmt»\n   «net»\n   «os»\n   «sync»\n)\nconst socketPath = \"/tmp/chat.sock\"\nfunc main() {\n   conn, err := net.Dial(\"unix\", socketPath)\n   if err != nil {\n      fmt.Println(\"Failed to connect to server:\", err)\n      return\n   }\n   defer conn.Close()\n   var wg sync.WaitGroup\n   wg.Add(1)\n   // Ouve mensagens do servidor\n   go func() {\n      defer wg.Done()\n      scanner := bufio.NewScanner(conn)\n      for scanner.Scan() {\n         fmt.Println(\"Message from server:\", scanner.Text())\n      }\n   }()\n   // Envia mensagens para o servidor\n   scanner := bufio.NewScanner(os.Stdin)\n   fmt.Println(\"message:\")\n   for scanner.Scan() {\n      message := scanner.Text()\n      conn.Write([]byte(message))\n   }\n   wg.Wait()\n}\n```", "```go\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        _, err := w.Write([]byte(\"Hello, world!\"))\n        if err != nil {\n           http.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n           log.Println(\"Error writing response:\", err)\n        }\n    })\n    ```", "```go\n    socketPath := \"/tmp/go-server.sock\"\n    listener, err := net.Listen(\"unix\", socketPath)\n    if err != nil {\n        log.Fatal(\"Listen (UNIX socket):\", err)\n    }\n    log.Println(\"Server is listening on\", socketPath)\n    ```", "```go\n    sigCh := make(chan os.Signal, 1)\n    signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)\n    ```", "```go\n    go func() {\n        <-sigCh\n        log.Println(\"Shutting down gracefully...\")\n        listener.Close()\n        os.Remove(socketPath)\n        os.Exit(0)\n    }()\n    ```", "```go\n    err = http.Serve(listener, nil)\n    if err != nil && err != http.ErrServerClosed {\n        log.Fatal(\"HTTP server error:\", err)\n    }\n    ```", "```go\npackage main\nimport (\n     \"bufio\"\n     \"fmt\"\n     \"net\"\n     \"net/http\"\n     \"net/textproto\"\n     \"strings\"\n)\nconst socketPath = \"/tmp/go-server.sock\"\nfunc main() {\n     // Dial the Unix socket\n     conn, err := net.Dial(\"unix\", socketPath)\n     if err != nil {\n          fmt.Println(\"Error connecting to the Unix socket:\", err)\n          return\n     }\n     defer conn.Close()\n     // Make an HTTP request\n     request := \"GET / HTTP/1.1\\r\\n\" +\n          \"Host: localhost\\r\\n\" +\n          \"\\r\\n\"\n     _, err = conn.Write([]byte(request))\n     if err != nil {\n          fmt.Println(\"Error sending the request:\", err)\n          return\n     }\n     // Read the response\n     reader := bufio.NewReader(conn)\n     tp := textproto.NewReader(reader)\n     // Read and print the status line\n     statusLine, err := tp.ReadLine()\n     if err != nil {\n          fmt.Println(\"Error reading the status line:\", err)\n          return\n     }\n     fmt.Println(\"Status Line:\", statusLine)\n     // Read and print headers\n     headers, err := tp.ReadMIMEHeader()\n     if err != nil {\n          fmt.Println(\"Error reading headers:\", err)\n          return\n     }\n     for key, values := range headers {\n          for _, value := range values {\n               fmt.Printf(\"%s: %s\\n\", key, value)\n          }\n     }\n     // Read and print the body (assuming it's text-based)\n     for {\n          line, err := reader.ReadString('\\n')\n          if err != nil {\n               if err.Error() != \"EOF\" {\n                    fmt.Println(\"Error reading the response body:\", err)\n               }\n               break\n          }\n          fmt.Print(line)\n     }\n}\n```"]