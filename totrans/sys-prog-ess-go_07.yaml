- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Unix Sockets
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unix Sockets
- en: In this chapter, you will learn about socket programming, but this time focusing
    on UNIX sockets. The chapter provides an understanding of how UNIX sockets function,
    their types, and their role in **inter-process communication** (**IPC**) on UNIX
    and UNIX-like operating systems such as Linux. You will gain practical knowledge
    through examples, particularly in creating a UNIX socket server and client using
    the Go programming language.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习关于套接字编程的知识，但这次将重点放在UNIX套接字上。本章提供了对UNIX套接字如何工作、它们的类型以及在UNIX和UNIX类似操作系统（如Linux）中的**进程间通信**（IPC）中作用的了解。你将通过示例获得实际知识，特别是使用Go编程语言创建UNIX套接字服务器和客户端。
- en: This information is crucial for programmers who are interested in developing
    advanced software systems, particularly those that require efficient IPC mechanisms.
    Understanding UNIX sockets is essential for system and network programmers, as
    it allows for the creation of more efficient and secure applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对开发高级软件系统感兴趣的程序员来说，这些信息至关重要，尤其是那些需要高效IPC机制的软件。理解UNIX套接字对于系统和网络程序员至关重要，因为它允许创建更高效、更安全的应用程序。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Unix sockets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unix套接字
- en: Building a chat server
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建聊天服务器
- en: Serving HTTP under Unix sockets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unix套接字下提供HTTP服务
- en: By the end of the chapter, you should be able to create and manage UNIX sockets
    and understand their efficiency, security, and how they are integrated into the
    filesystem namespace.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够创建和管理UNIX套接字，并了解它们的效率、安全性以及它们如何集成到文件系统命名空间中。
- en: Introduction to Unix sockets
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unix套接字简介
- en: UNIX sockets, also known as UNIX domain sockets, provide a way for processes
    to communicate with each other on the same machine quickly and efficiently, offering
    a local alternative to TCP/IP sockets for IPC. This feature is unique to UNIX
    and UNIX-like operating systems such as Linux.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX套接字，也称为UNIX域套接字，提供了一种快速高效地在同一台机器上进程之间进行通信的方式，为IPC提供了TCP/IP套接字的本地替代方案。这一特性是UNIX及其类似操作系统（如Linux）独有的。
- en: UNIX sockets can be either stream-oriented (such as TCP) or datagram-oriented
    (such as UDP). They are represented as filesystem nodes, such as files and directories.
    However, they are not regular files but special IPC mechanisms.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX套接字可以是面向流的（如TCP）或面向数据报的（如UDP）。它们表示为文件系统节点，如文件和目录。然而，它们不是常规文件，而是特殊的IPC机制。
- en: 'There are three key features:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个关键特性：
- en: '**Efficiency**: Data is transferred directly between processes without the
    need for network protocol overhead.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：数据在进程之间直接传输，无需网络协议开销。'
- en: '**Filesystem namespace**: UNIX sockets are referenced by filesystem paths.
    This makes them easy to locate and use but also means they persist in the filesystem
    until explicitly removed.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件系统命名空间**：UNIX套接字通过文件系统路径进行引用。这使得它们易于定位和使用，但也意味着它们在文件系统中持续存在，直到明确删除。'
- en: '**Security**: Access to UNIX sockets can be controlled using filesystem permissions,
    providing a level of security based on user and group IDs.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：可以使用文件系统权限控制对UNIX套接字的访问，提供基于用户和组ID的安全级别。'
- en: Moving forward, let’s see how we can actually create a UNIX socket.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们如何实际创建UNIX套接字。
- en: Creating a Unix socket
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Unix套接字
- en: 'Let’s go through a step-by-step example in Go for creating a UNIX socket server
    and client. After that, we’ll understand how to use `lsof` to inspect the socket:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个分步示例在Go中创建UNIX套接字服务器和客户端。之后，我们将了解如何使用`lsof`来检查套接字：
- en: 'For socket path and cleanup, perform the following:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于套接字路径和清理，执行以下操作：
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`socketPath := "/tmp/example.sock"` sets the location for the UNIX socket'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socketPath := "/tmp/example.sock"`设置UNIX套接字的位置'
- en: '`os.Remove(socketPath)` attempts to delete any existing socket file at this
    location to avoid conflicts when starting the server'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.Remove(socketPath)`尝试删除此位置上任何现有的套接字文件，以避免在启动服务器时发生冲突'
- en: 'For creating and listening on the UNIX socket:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于创建和监听UNIX套接字：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`net.Listen("unix", socketPath)` creates the UNIX socket at the given path
    and starts listening for incoming connections'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net.Listen("unix", socketPath)`在指定的路径上创建UNIX套接字并开始监听传入的连接'
- en: '`defer listener.Close()` ensures that the socket is closed when the main function
    exits, releasing system resources'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defer listener.Close()`确保在主函数退出时关闭套接字，释放系统资源'
- en: 'For graceful shutdown setup:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于优雅的关闭设置：
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`signals := make(chan os.Signal, 1)` sets up a channel to receive operating
    system signals.'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`signals := make(chan os.Signal, 1)` 设置了一个通道来接收操作系统信号。'
- en: '`signal.Notify(signals, syscall.SIGINT, syscall.SIGTERM)` configures the program
    to intercept `SIGINT` and `SIGTERM` signals for graceful shutdown.'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`signal.Notify(signals, syscall.SIGINT, syscall.SIGTERM)` 配置程序拦截 `SIGINT` 和
    `SIGTERM` 信号以实现优雅关闭。'
- en: '`go func() { ... }()` goroutine waits for a signal. Upon receiving one, it
    closes the listener and removes the socket file, then exits the program.'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go func() { ... }()` goroutine 等待信号。在接收到信号后，它关闭监听器并删除套接字文件，然后退出程序。'
- en: 'For connection acceptance loop:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于连接接受循环：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`for { ... }` loop continuously waits for and accepts new connections'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for { ... }` 循环持续等待并接受新的连接'
- en: '`listener.Accept()` encounters an error (such as during server shutdown), it
    logs the error and continues to the next iteration, avoiding a crash'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `listener.Accept()` 遇到错误（例如在服务器关闭期间），它将记录错误并继续到下一个迭代，避免崩溃
- en: 'For connection management:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于连接管理：
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Utilizes `defer conn.Close()` to ensure the connection is closed after function
    execution, releasing resources
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `defer conn.Close()` 确保在函数执行后关闭连接，释放资源
- en: Allocates a byte buffer with `buffer := make([]byte, 1024)` for incoming data
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `buffer := make([]byte, 1024)` 分配一个字节数组作为接收数据的缓冲区
- en: Reads incoming data using `n, err := conn.Read(buffer)`, handling errors and
    exiting if any occur
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `n, err := conn.Read(buffer)` 读取传入的数据，处理错误并在发生任何错误时退出
- en: Displays the received message with `fmt.Println("Received:"`, `string(buffer[:n]))`,
    showing only the read portion of the buffer
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `fmt.Println("Received:", string(buffer[:n]))` 显示接收到的消息，仅显示缓冲区中读取的部分
- en: Constructs a response with `response := []byte("Message received successfully\n")`
    to acknowledge the received message
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `response := []byte("Message received successfully\n")` 构建响应以确认接收到的消息
- en: Sends the response back to the client via `conn.Write(response)`, logging errors
    if the write operation fails
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `conn.Write(response)` 将响应发送回客户端，如果写入操作失败则记录错误
- en: 'We now can run this code by executing the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过执行以下代码来运行此代码：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output should be as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是以下内容：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Going a little deeper into socket creation
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入探讨套接字创建过程
- en: 'When we call `net.Listen` with a UNIX socket type and a file path, the Go runtime
    performs two actions under the hood: the socket file descriptor is created in
    the operating system and Go’s runtime binds the socket to the specified file path.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用UNIX套接字类型和文件路径调用 `net.Listen` 时，Go运行时在幕后执行两个操作：在操作系统中创建套接字文件描述符，并将Go的运行时绑定到指定的文件路径。
- en: From an operating system perspective
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从操作系统的角度来看
- en: When I say, “A socket is created in the operating system,” I’m referring to
    the creation of a socket as an internal resource within the operating system’s
    kernel. This action is like the operating system setting up a communication endpoint.
    The socket at this stage is an abstraction managed by the operating system, allowing
    processes to send and receive data. Note that this socket is not yet associated
    with a file in the filesystem. It’s an entity that exists in the system’s memory,
    managed by the kernel’s networking or IPC subsystem.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说“在操作系统中创建套接字”时，我指的是在操作系统内核内部创建套接字作为内部资源。这个动作就像操作系统设置一个通信端点。在这个阶段，套接字是操作系统管理的抽象，允许进程发送和接收数据。请注意，这个套接字尚未与文件系统中的文件关联。它是一个存在于系统内存中的实体，由内核的联网或IPC子系统管理。
- en: From a filesystem perspective
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从文件系统角度来看
- en: Binding in this context is associating the socket with a specific path in the
    filesystem. This binding creates a socket file, a special type of file that serves
    as an entry point or an endpoint for IPC.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在此上下文中，绑定是将套接字与文件系统中的特定路径关联起来。这种绑定创建了一个套接字文件，这是一种特殊类型的文件，作为IPC的入口点或端点。
- en: The “socket file” created in the filesystem is not a regular file that stores
    data such as text or binary content. Instead, it’s a special type of file (often
    appearing as a file in directory listings) that represents the socket and provides
    a way for processes to reference and use it. It’s the point where the abstract
    socket created by the operating system gets a named representation in the filesystem.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件系统中创建的“套接字文件”不是一个存储文本或二进制内容等数据的常规文件。相反，它是一种特殊类型的文件（通常在目录列表中显示为文件），代表套接字，并为进程提供了一种引用和使用它的方式。这是操作系统创建的抽象套接字在文件系统中获得命名表示的地方。
- en: Creating the client
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建客户端
- en: Our client’s primary functions are to connect to a UNIX socket server, send
    a message, and then close the connection.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们客户端的主要功能是连接到 UNIX 套接字服务器，发送消息，然后关闭连接。
- en: 'To achieve this goal, let’s use the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个目标，让我们使用以下代码：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s examine this client code in detail:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细检查这个客户端代码：
- en: '`net.Dial("unix", "/tmp/example.sock")` attempts to establish a connection
    to a UNIX socket server.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net.Dial("unix", "/tmp/example.sock")` 尝试连接到一个 UNIX 套接字服务器。'
- en: '`"unix"` specifies the connection type, indicating a UNIX socket.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"unix"` 指定连接类型，表示 UNIX 套接字。'
- en: '`"/tmp/example.sock"` is the path to the socket file where the server is expected
    to be listening.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"/tmp/example.sock"` 是服务器预期监听的套接字文件的路径。'
- en: If there’s an error in connecting (such as if the server isn’t running or the
    socket file doesn’t exist), the error is printed and the program exits.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果连接时发生错误（例如，如果服务器没有运行或套接字文件不存在），错误将被打印出来，并且程序退出。
- en: '`defer conn.Close()` ensures that the connection to the socket is closed when
    the main function exits, irrespective of how it exists. It’s a deferred call,
    which means it will execute at the end of the `main` function.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defer conn.Close()` 确保在主函数退出时关闭套接字连接，无论以何种方式退出。它是一个延迟调用，意味着它将在 `main` 函数的末尾执行。'
- en: '`conn.Write([]byte("Hello UNIX socket!\n"))` sends a message to the server.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conn.Write([]byte("Hello UNIX socket!\n"))` 向服务器发送消息。'
- en: The `"Hello UNIX socket!\n"` string is converted into a byte slice as the `Write`
    method requires a byte slice as input.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"Hello UNIX socket!\n"` 字符串被转换为字节切片，因为 `Write` 方法需要一个字节切片作为输入。'
- en: The `_` character is used to ignore the first return value, which is the number
    of bytes written.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_` 字符用于忽略第一个返回值，即写入的字节数。'
- en: If there’s an error in writing to the socket, the error is printed and the program
    exits.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在向套接字写入时发生错误，错误将被打印出来，并且程序退出。
- en: 'Buffer creation: `buffer := make([]byte, 1024)` initializes a byte slice with
    a length of 1,024 bytes to store the response from the server.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲区创建：`buffer := make([]byte, 1024)` 初始化一个长度为 1,024 字节的字节切片以存储来自服务器的响应。
- en: 'Read operation: `n, err := conn.Read(buffer)` reads the response from the server
    into the buffer, where `n` is the number of bytes read and `err` captures any
    error during the read operation.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取操作：`n, err := conn.Read(buffer)` 将服务器的响应读取到缓冲区中，其中 `n` 是读取的字节数，`err` 捕获读取操作期间发生的任何错误。
- en: If there’s an error in reading from the socket, the error is printed and the
    program exits.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果从套接字读取时发生错误，错误将被打印出来，并且程序退出。
- en: '`fmt.Println("Server response:", string(buffer[:n]))` prints the response received
    from the server. `buffer[:n]` converts the read bytes back into a string for display.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fmt.Println("Server response:", string(buffer[:n]))` 打印从服务器接收到的响应。`buffer[:n]`
    将读取的字节转换回字符串以进行显示。'
- en: Inspecting the socket with lsof
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 lsof 检查套接字
- en: On Unix-like systems, the `lsof` to gather relevant information.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在类 Unix 系统上，使用 `lsof` 来收集相关信息。
- en: 'To use `lsof` to inspect the socket, we should start the server program so
    that it creates and listens on the UNIX socket. In the terminal, you can run `lsof`
    with the `-U` flag (which stands for UNIX sockets) and the `-a` flag to combine
    the conditions. You can also specify the path to the socket file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `lsof` 检查套接字，我们应该启动服务器程序，使其创建并监听 UNIX 套接字。在终端中，你可以使用带有 `-U` 标志（代表 UNIX 套接字）和
    `-a` 标志的组合条件运行 `lsof`。你也可以指定套接字文件的路径：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This command will show you details about the UNIX socket, including the `lsof`,
    you’ll see entries for both the server and the client.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将显示关于 UNIX 套接字的详细信息，包括 `lsof`，你将看到服务器和客户端的条目。
- en: The full version of the client and server can be found in the `ch7/example1`
    directory of our Git repository.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器完整版本可以在我们的 Git 仓库的 `ch7/example1` 目录中找到。
- en: Building a chat server
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建聊天服务器
- en: Before writing any code, we should state our goals for creating this chat system.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写任何代码之前，我们应该明确创建此聊天系统的目标。
- en: The chat server is designed to listen on a UNIX socket at `/tmp/chat.sock`.
    The code should handle creating and managing this socket, ensuring any existing
    socket file is removed before starting, thereby avoiding conflicts.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天服务器被设计为在 `/tmp/chat.sock` 的 UNIX 套接字上监听。代码应该处理创建和管理此套接字，确保在启动之前删除任何现有的套接字文件，从而避免冲突。
- en: Upon launching, the server should maintain a continuous loop, perpetually waiting
    for new client connections. Each successful connection is handled in a separate
    goroutine, allowing the server to manage multiple clients concurrently.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 启动后，服务器应保持一个持续循环，永无止境地等待新的客户端连接。每个成功的连接都在一个单独的goroutine中处理，允许服务器同时管理多个客户端。
- en: One of the key features of this server is its ability to manage multiple client
    connections simultaneously. To achieve this, combining slices to store client
    connections and a mutex for concurrent access control seems like a good idea,
    ensuring thread-safe operations on shared data.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务器的一个关键特性是它能够同时管理多个客户端连接。为了实现这一点，结合切片来存储客户端连接和一个互斥锁以进行并发访问控制似乎是个好主意，确保对共享数据的线程安全操作。
- en: Whenever a new client connects, the server should send them the entire history
    of messages, providing a context-rich experience. This historical context is vital
    in a chat application, allowing newly joined users to catch up on the conversation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一个新的客户端连接时，服务器应向他们发送整个消息历史，提供丰富的上下文体验。这种历史上下文在聊天应用中至关重要，使得新加入的用户能够跟上对话。
- en: Does it seem like there are too many concerns to handle at once? Don’t worry!
    We’ll expand the feature in baby steps until we get to the final version of our
    server.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 是否感觉同时要处理太多关注点？别担心！我们将逐步扩展功能，直到达到我们服务器的最终版本。
- en: 'To help you understand the development of the chat server using UNIX sockets
    in Go, it’s effective to decompose the final version into simpler, preliminary
    stages. Each stage will introduce a key feature or concept, building toward the
    final version. Here’s a step-by-step guide:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您理解使用Go在UNIX套接字上开发聊天服务器的开发过程，将最终版本分解成更简单、初步的阶段是有效的。每个阶段将介绍一个关键特性或概念，逐步构建到最终版本。以下是一步一步的指南：
- en: '**Basic UNIX** **socket server**:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**基本的UNIX套接字服务器**：'
- en: 'Create a simple server that listens on a UNIX socket and can accept a connection:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个简单的服务器，它监听UNIX套接字并可以接受连接：
- en: '[PRE9]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Handling a** **single client**:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理单个客户端**：'
- en: 'Extend the server to read a message from one client and print it to the console:'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 扩展服务器以从客户端读取消息并在控制台上打印：
- en: '[PRE10]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Handling** **multiple clients**:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理多个客户端**：'
- en: 'Modify the server to handle multiple client connections concurrently:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 修改服务器以同时处理多个客户端连接：
- en: '[PRE11]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Broadcasting messages to** **all clients**:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**向所有客户端广播消息**：'
- en: 'Implement a feature to broadcast received messages to all connected clients:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现一个功能，将接收到的消息广播给所有已连接的客户端：
- en: '[PRE12]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Adding** **message history**:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加消息历史**：'
- en: 'Store a history of messages and send it to new clients upon connection:'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存储消息历史并在连接时发送给新客户端：
- en: '[PRE13]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Nice! We’ve completed the chat server with all the features. Now, it’s time
    to create our client.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们已经完成了具有所有功能的聊天服务器。现在，是时候创建我们的客户端了。
- en: The client should establish a connection to a server listening on a specific
    UNIX socket (`/tmp/chat.sock`). After establishing a connection, the client will
    send a message to the server. Also, the client should handle the response from
    the server, read it, and display it on the console. Throughout its operations
    (connecting, sending, and receiving), the client should handle any potential errors,
    printing them out if they occur. Lastly, the client must ensure that the socket
    connection is properly closed before exiting, regardless of whether it exits normally
    or due to an error.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应连接到监听特定UNIX套接字的服务器（`/tmp/chat.sock`）。建立连接后，客户端将向服务器发送一条消息。此外，客户端还应处理来自服务器的响应，读取它，并在控制台上显示。在整个操作过程中（连接、发送和接收），客户端应处理任何潜在的错误，并在发生时打印出来。最后，客户端必须确保在退出之前正确关闭套接字连接，无论它是正常退出还是由于错误而退出。
- en: 'Now, let’s break down the development of this client into simpler stages:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这个客户端的开发分解成更简单的阶段：
- en: '**Establishing a connection to** **the server**:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**建立与服务器连接**：'
- en: 'Create a client that connects to a UNIX socket server:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个连接到UNIX套接字服务器的客户端：
- en: '[PRE14]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Listening for messages from** **the server**:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**监听来自服务器的消息**：'
- en: 'Add functionality to listen and print messages from the server:'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加功能以监听并打印来自服务器的消息：
- en: '[PRE15]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Sending messages to** **the server**:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**向服务器发送消息**：'
- en: 'Enable the client to send messages to the server:'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 允许客户端向服务器发送消息：
- en: '[PRE16]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`sync.WaitGroup` to manage goroutine synchronization and prevent premature
    program termination:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`sync.WaitGroup`来管理goroutine同步并防止程序提前终止：
- en: '[PRE17]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The complete chat client
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完整的聊天客户端
- en: 'Since we’re familiar with the details, let’s look at the complete client code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们熟悉细节，让我们看看完整的客户端代码：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Approaching the development as a step-by-step process is helpful in understanding
    each component’s role in the final program as the complexity increases.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将开发作为一个逐步的过程来处理，有助于在复杂性增加时理解每个组件在最终程序中的作用。
- en: Now it’s your turn! Spin the server to a couple of clients and play with our
    chat system.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在轮到你了！将服务器旋转到几个客户端，并玩转我们的聊天系统。
- en: The full version of the client and server can be found in the `ch7/chat` directory
    of our GitHub repository.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器完整版本可以在我们GitHub仓库的`ch7/chat`目录中找到。
- en: Serving HTTP under UNIX domain sockets
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在UNIX域套接字下提供HTTP服务
- en: Exposing HTTP APIs under a Unix domain socket? Well, that’s one way to keep
    things interesting in networking. Let’s explore the benefits of this unconventional
    approach.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在UNIX域套接字下暴露HTTP API？嗯，这是在网络上保持事物有趣的一种方式。让我们探索这种非常规方法的好处。
- en: Unix domain sockets are a secure choice for services that should remain confined
    to a specific machine. They offer fine-grained access control through filesystem
    permissions, making managing who can interact with your HTTP API easier.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX域套接字是服务应该限制在特定机器上的安全选择。它们通过文件系统权限提供细粒度的访问控制，使得管理谁可以与你的HTTP API交互变得更容易。
- en: Why settle for regular old networking when you can have the luxury of lower
    latency and fewer context switches? This can be especially useful in high-throughput
    environments.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么满足于常规的旧式网络，当你可以享受更低延迟和更少的上下文切换的奢侈时？这在高吞吐量环境中尤其有用。
- en: By utilizing Unix domain sockets, you can avoid consuming TCP ports, which may
    be a limited resource on some systems.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用UNIX域套接字，你可以避免消耗TCP端口，这在某些系统上可能是一个有限的资源。
- en: Unix domain sockets eliminate the need to manage IP addresses and port numbers,
    simplifying setup and configuration, especially for local communication. Also,
    they seamlessly integrate with the Unix/Linux ecosystem, making them a natural
    choice for applications deeply embedded in this environment.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX域套接字消除了管理IP地址和端口号的需求，简化了设置和配置，尤其是在本地通信中。此外，它们与Unix/Linux生态系统无缝集成，使它们成为嵌入在此环境中的应用程序的自然选择。
- en: For legacy systems or applications with specific protocol requirements, Unix
    domain sockets may be the best or only option for efficient communication.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于旧系统或具有特定协议要求的应用程序，UNIX域套接字可能是最佳或唯一的高效通信选项。
- en: To create an HTTP server listening on a Unix domain socket in Go, you can use
    the `net` and `net/http` packages.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Go中创建监听UNIX域套接字的HTTP服务器，你可以使用`net`和`net/http`包。
- en: 'Let’s take a step-by-step approach to explore the server:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步地探索服务器：
- en: 'HTTP handler function:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTP处理函数：
- en: '[PRE19]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We start by defining an HTTP handler function using `http.HandleFunc`. This
    function handles all incoming HTTP requests to the root path (`"/"`) and responds
    with `"Hello, world!"` using the response writer.
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先使用`http.HandleFunc`定义一个HTTP处理函数。此函数处理所有进入根路径（`"/"`）的HTTP请求，并使用响应写入器响应`"Hello,
    world!"`。
- en: 'Unix socket and listener setup:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unix套接字和监听器设置：
- en: '[PRE20]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We specify the Unix socket path as `socketPath`, which is set to `"/tmp/go-server.sock"`.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们指定UNIX套接字路径为`socketPath`，设置为`"/tmp/go-server.sock"`。
- en: '`net.Listen("unix", socketPath)` sets up a Unix socket server to accept incoming
    connections on the specified path.'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net.Listen("unix", socketPath)`设置一个UNIX套接字服务器，在指定的路径上接受传入的连接。'
- en: We use the standard Go `log` package for basic logging. We log a message when
    the server is listening on the specified socket path.
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用标准的Go `log`包进行基本日志记录。当服务器在指定的套接字路径上监听时，我们记录一条消息。
- en: 'Graceful shutdown:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 优雅的关闭：
- en: '[PRE21]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We created a signal channel, `sigCh`, to capture `SIGINT` (*Ctrl* + *C*) and
    `SIGTERM` (termination signal) signals for graceful server shutdown
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个信号通道`sigCh`来捕获`SIGINT`（*Ctrl* + *C*）和`SIGTERM`（终止信号）信号，以便优雅地关闭服务器
- en: We use `signal.Notify` to notify the channel when these signals are received
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`signal.Notify`在接收到这些信号时通知通道。
- en: 'Goroutine for shutdown:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭goroutine：
- en: '[PRE22]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We launch a goroutine to handle graceful shutdown. The goroutine waits for signals
    on `sigCh`.
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们启动了一个goroutine来处理优雅的关闭。该goroutine等待`sigCh`上的信号。
- en: When a signal is received, it logs a message, closes the Unix socket listener
    using `listener.Close()`, removes the Unix socket file using `os.Remove(socketPath)`,
    and exits the program with `os.Exit(0)`.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当接收到信号时，它会记录一条消息，使用`listener.Close()`关闭UNIX套接字监听器，使用`os.Remove(socketPath)`删除UNIX套接字文件，并使用`os.Exit(0)`退出程序。
- en: 'HTTP server start:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTP服务器启动：
- en: '[PRE23]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We start the HTTP server using `http.Serve(listener, nil)`. It listens for incoming
    HTTP requests on the Unix socket listener we created earlier.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`http.Serve(listener, nil)`启动HTTP服务器。它监听我们之前创建的Unix套接字监听器上的传入HTTP请求。
- en: We handle any errors returned by `http.Serve` and log them if necessary. We
    also check for the special case `http.ErrServerClosed` to determine whether the
    server was gracefully shut down.
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们处理`http.Serve`返回的任何错误，并在必要时记录它们。我们还检查特殊情况`http.ErrServerClosed`以确定服务器是否已优雅地关闭。
- en: Now, let’s tackle the client-side setup after covering the server intricacies.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在覆盖服务器复杂性之后，让我们解决客户端设置。
- en: Client
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端
- en: When creating a client for this situation, we can assume the HTTP response body
    is text-based (plain text).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建此类客户端时，我们可以假设HTTP响应体是基于文本的（纯文本）。
- en: 'Note:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: If you’re dealing with binary data, you must handle it differently.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理二进制数据，你必须以不同的方式处理。
- en: 'Let’s progressively create our client:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步创建我们的客户端：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The three main parts of the code are as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的三个主要部分如下：
- en: '`net.Dial` to connect to the Unix socket at `/tmp/go-server.sock`.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`net.Dial`连接到`/tmp/go-server.sock`上的Unix套接字。
- en: '`/`). The `Host: localhost` header is included to conform to HTTP/1.1 standards.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`）。包含`Host: localhost`头是为了符合HTTP/1.1标准。'
- en: '`bufio.Reader`. The status line and headers are parsed and printed out. The
    body of the response is then printed out as well.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bufio.Reader`。解析并打印状态行和头信息。然后打印出响应体。'
- en: Now we should explore some of the choices and their details.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该探索一些选择及其细节。
- en: The request is intended to be sent over a network connection, such as a Unix
    domain socket, to an HTTP server. Let’s break down this request into its individual
    components.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请求旨在通过网络连接，例如Unix域套接字，发送到HTTP服务器。让我们将这个请求分解为其各个组成部分。
- en: HTTP request line
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP请求行
- en: '`GET /` `HTTP/1.1\r\n`'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET /` `HTTP/1.1\r\n`'
- en: '`/`).'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`）。'
- en: '`/` – This is the path of the resource being requested. `/` signifies the root
    path, which usually corresponds to the home page or main page of a website or
    API.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/` – 这是请求的资源路径。`/`表示根路径，通常对应于网站或API的主页或首页。'
- en: '`HTTP/1.1` – This specifies the version of the HTTP protocol being used. HTTP/1.1
    is a common version that introduces several improvements over HTTP/1.0, such as
    persistent connections.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP/1.1` – 这指定了正在使用的HTTP协议版本。HTTP/1.1是一个常见的版本，它在HTTP/1.0的基础上引入了几个改进，例如持久连接。'
- en: '`\r\n` – This is a carriage return (`\r`) followed by a line feed (`\n`), which
    together signify the end of a line in the HTTP protocol. HTTP headers must end
    with `\r\n`.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\r\n` – 这是一个回车符（`\r`）后面跟着一个换行符（`\n`），它们一起表示HTTP协议中行的结束。HTTP头必须以`\r\n`结束。'
- en: HTTP request header
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP请求头
- en: '`Host: localhost\r\n`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`Host: localhost\r\n`'
- en: '`Host: localhost` – The host header specifies the server’s domain name (the
    host) to which the request is being sent. This is mandatory in HTTP/1.1 and is
    used to distinguish between different domains hosted on the same server (virtual
    hosting). Here, `localhost` is used as the host.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Host: localhost` – 主机头指定了请求发送到的服务器域名（主机）。在HTTP/1.1中这是强制性的，用于区分同一服务器上托管的不同域名（虚拟主机）。在这里，使用`localhost`作为主机。'
- en: '`\r\n` – Again, the carriage return and line feed signify the end of the header
    line.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\r\n` – 再次，回车符和换行符表示头行的结束。'
- en: Empty line signifying end of headers
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表示头结束的空行
- en: '`\``r\n`'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`\``r\n`'
- en: This empty line (just `\r\n`) indicates the end of the header section and the
    beginning of the body section of the HTTP request. Since a GET request does not
    typically include a body, this line signifies the end of the request.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个空行（仅`\r\n`）表示头部分的结束和HTTP请求体部分的开始。由于GET请求通常不包含体，因此该行表示请求的结束。
- en: The textproto package
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: textproto包
- en: In our program, the `textproto` package is utilized to read and parse the response
    headers from the HTTP server, but why?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序中，使用`textproto`包来读取和解析HTTP服务器的响应头，但为什么？
- en: 'The first motivation is convenience: `textproto` simplifies the process of
    reading and parsing text-based protocols. Without it, you’d have to manually parse
    the response, which could be error-prone and inefficient.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个动机是便利性：`textproto`简化了读取和解析基于文本协议的过程。没有它，你将不得不手动解析响应，这可能会出错且效率低下。
- en: Moreover, `textproto` ensures compliance with the text-based protocol’s specifications.
    It correctly handles nuances such as line endings (`\r\n`) and the format of headers.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`textproto`确保符合基于文本协议的规范。它正确处理诸如行结束（`\r\n`）和头格式等细微差别。
- en: It integrates well with Go’s **buffered I/O** (**bufio**), making it efficient
    for network communication where data may arrive in bursts.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 它与Go的**缓冲I/O**（**bufio**）很好地集成，使其在网络通信中数据可能突发到达时效率更高。
- en: While designed with HTTP in mind, `textproto` is versatile enough to be used
    with other text-based protocols, making it a useful tool in the Go standard library
    for network programming in general.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`textproto`是为HTTP设计的，但它足够灵活，可以与其他基于文本的协议一起使用，使其成为Go标准库中网络编程的有用工具。
- en: Now that we’ve explored our application using UNIX sockets over HTTP, let’s
    take a look into some important performance considerations to optimize our socket-based
    applications and the most common use cases.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用UNIX套接字通过HTTP探索了我们的应用程序，让我们来看看一些重要的性能考虑因素，以优化我们的基于套接字的应用程序和最常见用例。
- en: The full version of the client and server communicating over HTTP can be found
    in the `ch7/http2unix` directory of our Git repository.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器通过HTTP通信的完整版本可以在我们的Git仓库的`ch7/http2unix`目录中找到。
- en: Performance
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: Unix domain sockets don’t require the network stack’s overhead, as there’s no
    need to route data through the network layers. This reduces the CPU cycles spent
    on processing network protocols. Unix domain sockets often allow for more efficient
    data transfer mechanisms within the kernel, such as sending a file, which can
    reduce the amount of data copying between the kernel and user spaces. They communicate
    within the same host, so the latency is typically lower than TCP sockets, which
    may involve more complex routing even when communicating between processes on
    the same machine.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Unix域套接字不需要网络堆栈的开销，因为不需要通过网络层路由数据。这减少了处理网络协议所消耗的CPU周期。Unix域套接字通常允许内核内部更高效的数据传输机制，例如发送文件，这可以减少内核和用户空间之间数据复制的数量。它们在同一主机内部进行通信，因此延迟通常低于TCP套接字，后者在相同机器上的进程之间通信时可能涉及更复杂的路由。
- en: 'You might ask yourself: *Is it faster than calling the loopback* *interface
    (localhost)?*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问自己：*这比调用回环接口（localhost）快吗？*
- en: '*Yes!* The loopback interface still goes through the TCP/IP stack, even though
    it doesn’t leave the machine. This involves more processing, such as packaging
    data into TCP segments and IP packets.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*是的！* 回环接口仍然会通过TCP/IP堆栈，即使它没有离开机器。这涉及到更多的处理，例如将数据打包成TCP段和IP数据包。'
- en: They can be more efficient regarding data copying between the kernel and user
    spaces. Some Unix domain socket implementations allow for zero-copy operations,
    where data is directly passed between the client and server without redundant
    copying. This is not possible using TCP/IP since its communication typically involves
    more data copying between the kernel and user spaces.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在内核和用户空间之间的数据复制方面可能更高效。一些Unix域套接字实现允许零拷贝操作，其中数据直接在客户端和服务器之间传递，无需冗余复制。使用TCP/IP是不可能的，因为其通信通常涉及内核和用户空间之间更多的数据复制。
- en: Other common use cases
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他常见用例
- en: 'Several systems rely on the benefits of Unix domain sockets, such as the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 几个系统依赖于Unix域套接字的好处，如下所示：
- en: '**System V IPC**: This is a category of mechanisms in Unix-like operating systems,
    including UNIX domain sockets, message queues, semaphore sets, and shared memory.
    UNIX domain sockets are often used for efficient and fast communication between
    processes within the same system.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**System V IPC**：这是Unix-like操作系统中的一类机制，包括UNIX域套接字、消息队列、信号量集和共享内存。UNIX域套接字通常用于同一系统内进程之间高效且快速的通信。'
- en: '**X Window System (X11)**: X11, the graphical windowing system used in Unix-like
    operating systems, can use UNIX domain sockets for communication between the X
    server and client applications. This allows for display and input management.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**X Window系统（X11）**：X11是Unix-like操作系统使用的图形窗口系统，可以使用UNIX域套接字在X服务器和客户端应用程序之间进行通信。这允许显示和输入管理。'
- en: '**D-Bus**: D-Bus is a message bus system used for communication between applications.
    It is widely used on Linux systems and relies heavily on UNIX domain sockets for
    local communication between processes.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D-Bus**：D-Bus是一个用于应用程序之间通信的消息总线系统。它在Linux系统上广泛使用，并且严重依赖于UNIX域套接字进行进程之间的本地通信。'
- en: '**Systemd**: Systemd, the init system and service manager for Linux, uses UNIX
    domain sockets for communication between its various components and services.
    It is integral to the boot process and system management.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Systemd**：Systemd是Linux的初始化系统和服务管理器，它使用UNIX域套接字在其各种组件和服务之间进行通信。它是启动过程和系统管理的重要组成部分。'
- en: '**MySQL and PostgreSQL**: These popular relational database management systems
    can use UNIX domain sockets for local client-server communication. This provides
    a fast and secure way for applications to connect to the database server.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MySQL和PostgreSQL**：这些流行的关系型数据库管理系统可以使用UNIX域套接字进行本地客户端-服务器通信。这为应用程序连接到数据库服务器提供了一种快速且安全的方式。'
- en: '**Redis**: Redis, an in-memory key-value store, can use UNIX domain sockets
    for local client-server communication. This provides low-latency and high-throughput
    data access.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Redis**：Redis，一个内存中的键值存储，可以使用UNIX域套接字进行本地客户端-服务器通信。这提供了低延迟和高吞吐量的数据访问。'
- en: '**Nginx and Apache**: These web servers can use UNIX domain sockets to communicate
    with backend application servers or FastCGI processes. It’s a more efficient way
    to proxy requests than TCP/IP sockets when both processes are on the same machine.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Nginx和Apache**：这些网络服务器可以使用UNIX域套接字与后端应用程序服务器或FastCGI进程进行通信。当这两个进程都在同一台机器上时，这是一种比TCP/IP套接字更高效的代理请求的方式。'
- en: With an understanding of UNIX socket use cases, let’s zoom out and summarize
    what we’ve learned.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解UNIX套接字用例的基础上，让我们扩展视野，总结我们已经学到的内容。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have explored the fundamental concepts and practical applications
    of UNIX sockets. We learned about UNIX sockets and their role in IPC on UNIX and
    UNIX-like systems. The chapter provided insights into how UNIX sockets differ
    from TCP/IP sockets, emphasizing their use for local, efficient IPC.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了UNIX套接字的基本概念和实际应用。我们学习了UNIX套接字及其在UNIX和类UNIX系统中的IPC作用。本章提供了UNIX套接字与TCP/IP套接字的区别，强调了它们在本地、高效IPC中的使用。
- en: Through examples, you gained hands-on experience in creating and managing a
    UNIX socket server and client. Also, this chapter highlighted the efficiency of
    UNIX sockets in data transfer without network protocol overhead and their security
    aspects controlled by filesystem permissions.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通过示例，您获得了创建和管理UNIX套接字服务器和客户端的实践经验。此外，本章突出了UNIX套接字在数据传输中的效率，没有网络协议开销，以及由文件系统权限控制的安全方面。
- en: This knowledge is vital for developing efficient and secure software systems,
    enhancing the reader’s ability to design and implement robust networked applications
    in IPC scenarios.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这项知识对于开发高效和安全的软件系统至关重要，增强了读者在进程间通信（IPC）场景中设计和实现健壮网络应用程序的能力。
- en: Looking ahead, the next chapter, [*Chapter 8*](B21662_08.xhtml#_idTextAnchor179),
    *Memory Management*, shifts our focus from IPC to the internal workings of the
    Go runtime and its garbage collector. We will explore how memory is allocated,
    managed, and optimized.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 展望未来，下一章[*第8章*](B21662_08.xhtml#_idTextAnchor179)，*内存管理*，将我们的关注点从进程间通信（IPC）转移到Go运行时及其垃圾回收器的内部工作。我们将探讨内存是如何分配、管理和优化的。
- en: 'Part 3: Performance'
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：性能
- en: In this part, we will take a tour on advanced topics that are crucial for developing
    high-performance, efficient, and reliable Go applications. This section focuses
    on memory management, performance analysis. By understanding these concepts, you’ll
    be better equipped to optimize your Go applications and manage system resources
    effectively.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，我们将探讨对开发高性能、高效和可靠的Go应用程序至关重要的高级主题。本节重点介绍内存管理、性能分析。通过理解这些概念，您将更好地装备自己以优化Go应用程序并有效地管理系统资源。
- en: 'This part has the following chapters:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 8*](B21662_08.xhtml#_idTextAnchor179), *Memory Management*'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B21662_08.xhtml#_idTextAnchor179)，*内存管理*'
- en: '[*Chapter 9*](B21662_09.xhtml#_idTextAnchor193), *Analysing Performance*'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B21662_09.xhtml#_idTextAnchor193)，*性能分析*'
