["```go\npackage main\nimport \"fmt\"\nfunc main() {\n    a := 42\n    b := &a\n    fmt.Println(a, *b) // Prints: 42 42\n    *b = 21\n    fmt.Println(a, *b) // Prints: 21 21\n}\n```", "```go\nvar p *int\n```", "```go\nvar x int = 10\np = &x\n```", "```go\nfmt.Println(*p)\n```", "```go\nfunc main() {\n    a := 42\n    b := &a\n    fmt.Println(*b)\n}\n```", "```go\npackage main\nimport \"fmt\"\ntype person struct {\n  name string\n  age  int\n}\nfunc main() {\n  p := createPerson()\n  fmt.Println(p)\n}\n//go:noinline\nfunc createPerson() *person {\n  p := person{name: \"Alex Rios\", age: 99}\n  return &p\n}\n```", "```go\nGo build -gcflags \"-m -m\" .\n```", "```go\n./main.go:16:6: cannot inline createPerson: marked go:noinline\n./main.go:10:6: cannot inline main: function too complex: cost 141 exceeds budget 80\n./main.go:12:13: inlining call to fmt.Println\n./main.go:17:2: p escapes to heap:\n./main.go:17:2:   flow: ~r0 = &p:\n./main.go:17:2:     from &p (address-of) at ./main.go:18:9\n./main.go:17:2:     from return &p (return) at ./main.go:18:2\n./main.go:17:2: moved to heap: p\n./main.go:12:13: ... argument does not escape\n```", "```go\n    ./main.go:16:6: cannot inline createPerson: marked go:noinline\n    ```", "```go\n    ./main.go:10:6: cannot inline main: function too complex: cost 141 exceeds budget 80\n    ```", "```go\n    ./main.go:12:13: inlining call to fmt.Println\n    ```", "```go\n    ./main.go:17:2: p escapes to heap\n    ```", "```go\npackage benchmark\nimport (\n    \"testing\"\n)\nfunc BenchmarkFib10(b *testing.B) {\n    // run the Fib function b.N times\n    for n := 0; n < b.N; n++ {\n        Fib(10)\n    }\n}\n```", "```go\npackage benchmark\nimport (\n \"testing\"\n)\nfunc BenchmarkSum(b *testing.B) {\n for i := 0; i < b.N; i++ {\n Sum(1, 2)\n }\n}\n```", "```go\ngo test -bench=.\n```", "```go\nBenchmarkSum-8    1000000000    0.277 ns/op\n```", "```go\nfunc BenchmarkSumSub(b *testing.B) {\n    cases := []struct {\n        name string\n        a, b int\n    }{\n        {\"small\", 1, 2},\n        {\"large\", 1000, 2000},\n    }\n    for _, c := range cases {\n        b.Run(c.name, func(b *testing.B) {\n            for i := 0; i < b.N; i++ {\n                Sum(c.a, c.b)\n            }\n        })\n    }\n}\n```", "```go\nBenchmarkSumSub/small-8           1000000000           0.3070 ns/op\nBenchmarkSumSub/large-8           1000000000           0.2970 ns/op\n```", "```go\nBenchmarkSum-8    1000000000    0.277 ns/op    16 B/op    2 allocs/op\n```", "```go\ngo install golang.org/x/perf/cmd/benchstat@latest\n```", "```go\n    go test -bench=. > old.txt\n    ```", "```go\n    go test -bench=. > new.txt\n    ```", "```go\n    benchstat old.txt new.txt\n    ```", "```go\nname            old time/op    new time/op    delta\nBenchmarkSum-8    200ns ± 1%     150ns ± 2%  -25.00%  (p=0.008 n=5+5)\n```", "```go\ngo test -bench=BenchmarkMultiply\n```", "```go\ngo test -bench=BenchmarkMultiply -benchtime=3s -count=5\n```", "```go\nfunc recursiveFibonacci(n int) int {\n     if n <= 1 {\n          return n\n     }\n     return recursiveFibonacci(b.N-1) + recursiveFibonacci(b.N-2) // Misusing b.N in the recursive call\n}\nfunc BenchmarkRecursiveFibonacci(b *testing.B) {\n     for i := 0; i < b.N; i++ {\n          _ = recursiveFibonacci(10)\n       }\n}\n```", "```go\ntype ComplexData struct {\n     // ...\n}\nvar data *ComplexData\nfunc setupComplexData() *ComplexData {\n     if data == nil {\n          data =  //Initialize complex data\n     }\n     return data\n}\nfunc BenchmarkComplexOperation(b *testing.B) {\n     // Misusing b.N for setup\n     for i := 0; i < b.N; i++ {\n          complexData := setupComplexData()\n          _ = performComplexOperation(complexData)\n     }\n}\n```", "```go\nfunc BenchmarkConditionalLogic(b *testing.B) {\n     for i := 0; i < b.N; i++ {\n          if i%2 == 0 {\n               // Misusing b.N to conditionally execute code\n               _ = performOperationA()\n          } else {\n               _ = performOperationB()\n          }\n     }\n}\n```", "```go\n    type FileInfo struct {\n        Name    string\n        ModTime time.Time\n        Size    int64\n    }\n    ```", "```go\n    func scanDirectory(dir string) (map[string]FileInfo, error) {\n        results := make(map[string]FileInfo)\n        err := filepath.WalkDir(dir, func(path string, d fs.DirEntry, err error) error {\n            if err != nil {\n                return err\n            }\n            info, err := d.Info()\n            if err != nil {\n                return err\n            }\n            results[path] = FileInfo{\n                Name:    info.Name(),\n                ModTime: info.ModTime(),\n                Size:    info.Size(),\n            }\n            return nil\n        })\n        return results, err\n    }\n    ```", "```go\n    func compareAndEmitEvents(oldState, newState map[string]FileInfo) {\n        for path, newInfo := range newState {\n            // ...\n            go sendAlert(fmt.Sprintf(\"File created: %s\", path))\n            // ...\n            go sendAlert(fmt.Sprintf(\"File modified: %s\", path))\n        }\n        for path := range oldState {\n            // ...\n            go sendAlert(fmt.Sprintf(\"File deleted: %s\", path))\n        }\n    }\n    ```", "```go\n    func sendAlert(event string) {\n        fmt.Println(\"Alert:\", event)\n    }\n    ```", "```go\n    func main() {\n        // ...\n        currentState, err := scanDirectory(dirToMonitor)\n        // ...\n        for {\n            // ...\n            newState, err := scanDirectory(dirToMonitor)\n            compareAndEmitEvents(currentState, newState)\n            currentState = newState\n            time.Sleep(interval)\n        }\n    }\n    ```", "```go\nimport (\n   ...\n   \"runtime/pprof\"\n)\n```", "```go\nfunc main() {\n   // ...\n   f, err := os.Create(\"cpuprofile.out\")\n   if err != nil {\n       // Handle error\n   }\n   defer f.Close()\n   pprof.StartCPUProfile(f)\n   defer pprof.StopCPUProfile()\n   // ... (Rest of your code)\n}\n```", "```go\ngo build monitor.go\n```", "```go\n./monitor\n```", "```go\ngo tool pprof cpuprofile.out\n```", "```go\nTotal: 10 samples\n      5  50.0% 50.0%        5  50.0% compareAndEmitEvents\n      3  30.0% 80.0%        3  30.0% scanDirectory\n      1  10.0% 90.0%        1  10.0% filepath.WalkDir\n      1  10.0% 100.0%        1  10.0% main\n```", "```go\ngo tool pprof -web cpuprofile.out\n```", "```go\nf, err := os.Create(\"memprofile.out\")\nif err != nil {\n    // Handle error\n}\ndefer f.Close()\nruntime.GC()\npprof.WriteHeapProfile(f)\n```", "```go\ngo tool pprof memprofile.out\n```", "```go\ngo tool pprof -web memprofile.out\n```", "```go\n    var cachedDirectoryState map[string]FileInfo // Global for simplicity\n    ```", "```go\n    if cachedDirectoryState != nil {\n        for path, fileInfo := range cachedDirectoryState {\n            results[path] = fileInfo\n        }\n    }\n    ```", "```go\n    err := filepath.WalkDir(dir, func(path string, d fs.DirEntry, err error) error {\n        // ... (Existing logic from scanDirectory remains) ...\n        // Update results and the cache\n        results[path] = FileInfo{\n            Name:    info.Name(),\n            ModTime: info.ModTime(),\n            Size:    info.Size(),\n        }\n        cachedDirectoryState = results\n        return nil\n    })\n    ```"]