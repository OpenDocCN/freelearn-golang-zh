- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Analyzing Performance
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析性能
- en: In this chapter, we will embark on a deep dive into the intricacies of performance
    analysis within the Go programming language, focusing on critical concepts such
    as escape analysis, stack and pointers, and the nuanced interplay between stack
    and heap memory allocations. By exploring these fundamental aspects, this chapter
    aims to equip you with the knowledge and skills necessary to optimize Go applications
    for maximum efficiency and performance.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨 Go 编程语言中性能分析的复杂性，重点关注逃逸分析、栈和指针以及栈和堆内存分配之间微妙互动等关键概念。通过探索这些基本方面，本章旨在为您提供优化
    Go 应用程序以实现最大效率和性能所需的知识和技能。
- en: Understanding these concepts is crucial for improving the performance of Go
    applications and gaining insight into system programming principles. This knowledge
    is invaluable in the real world, where efficient memory management and performance
    optimization can significantly impact the scalability, reliability, and overall
    success of software projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些概念对于提高 Go 应用程序的性能和深入了解系统编程原则至关重要。这种知识在现实世界中极为宝贵，高效的内存管理和性能优化可以显著影响软件项目的可扩展性、可靠性和整体成功。
- en: 'The chapter will cover the following key topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下关键主题：
- en: Escape analysis
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逃逸分析
- en: Benchmarking
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基准测试
- en: CPU profiling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU 分析
- en: Memory profiling
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存分析
- en: By the end of this chapter, you will have a solid foundation in analyzing and
    optimizing the performance of Go applications, preparing them for more advanced
    topics in system programming and application development.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将具备分析和优化 Go 应用程序性能的坚实基础，为系统编程和应用开发中的更高级主题做好准备。
- en: Escape analysis
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逃逸分析
- en: Escape analysis is a compiler optimization technique that’s used to determine
    whether a variable can be safely allocated on the stack or if it must “escape”
    to the heap. The primary goal of escape analysis is to improve memory usage and
    performance by allocating variables on the stack whenever possible since stack
    allocations are faster and more CPU cache-friendly than heap allocations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 逃逸分析是一种编译器优化技术，用于确定变量是否可以安全地分配在栈上，或者它必须“逃逸”到堆上。逃逸分析的主要目标是通过对栈分配进行变量分配来提高内存使用率和性能，因为栈分配比堆分配更快，并且对
    CPU 缓存更友好。
- en: Stack and pointers
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈和指针
- en: 'Ah, stacks and pointers in Go – the bread and butter of any self-respecting
    system programmer and yet, somehow, the source of an unending stream of confusion
    for many. Let’s be clear: if you think managing stacks and pointers is as easy
    as pie, you’re probably not baking it right.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 哎，Go 中的栈和指针——任何值得尊敬的系统程序员的日常必备，然而，对于许多人来说，它们似乎是无尽困惑的源泉。让我们明确一点：如果你认为管理栈和指针像做饼一样简单，那么你可能没有做对。
- en: 'Imagine a software development world where pointers are like those high-maintenance
    friends who need constant updates on where you are and what you’re doing. Except,
    in this world, failing to keep them in the loop doesn’t just hurt feelings; it
    crashes programs. This is the delightful quagmire of stacks and pointers in Go:
    a never-ending party where everyone needs to know exactly where to stand, or the
    whole thing comes tumbling down.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个软件开发的世界，其中指针就像那些需要不断了解你所在位置和所做事情的高维护性朋友。在这个世界里，未能让他们保持同步不仅会伤害感情，还会导致程序崩溃。这就是
    Go 中栈和指针的迷人泥潭：一个永无止境的派对，每个人都必须确切地知道自己的位置，否则整个事情就会崩溃。
- en: Now, let’s get down to brass tacks. The stack, in the context of Go, is a beautifully
    simple yet profoundly complex beast. It’s where all your local variables hang
    out, living their short, ephemeral lives before gracefully bowing out when their
    function calls end. It’s efficient, it’s tidy, and it’s mercilessly unforgiving
    if you don’t play by its rules.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们切入正题。在 Go 的上下文中，栈是一个既简单又复杂得令人惊叹的生物。它是所有局部变量的栖息地，在它们的生命短暂而短暂地生活后，在函数调用结束时优雅地退出。它是高效的，井然有序的，如果你不遵守它的规则，它将无情地不原谅你。
- en: Pointers, on the other hand, are the stack’s extroverted cousins. They don’t
    live on the stack; they thrive on pointing to values, wherever those values might
    reside. Whether it’s on the stack, the heap, or the twilight zone of memory management,
    pointers are your ticket to manipulating data directly, bypassing the pleasantries
    of value copying and embracing the raw power of memory access.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，指针是堆栈外向的表亲。它们不生活在堆栈上；它们在指向值中茁壮成长，无论这些值可能在哪里。无论是在堆栈上、堆上，还是在内存管理的黄昏地带，指针是直接操作数据的门票，绕过值复制的礼节，拥抱内存访问的原始力量。
- en: Understanding the interplay between the stack and pointers is crucial for any
    Go programmer. It’s about knowing when to let your variables live a carefree life
    on the stack and when to introduce a pointer into the mix, to point at something
    potentially far more enduring. It’s a dance of memory management, performance
    optimization, and avoiding the dreaded segmentation fault.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 理解堆栈和指针之间的相互作用对于任何Go程序员来说至关重要。这关乎知道何时让变量在堆栈上无忧无虑地生活，何时引入指针到混合中，指向可能更加持久的对象。这是一场内存管理、性能优化和避免可怕的段错误的舞蹈。
- en: 'Consider this simple Go code snippet:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个简单的Go代码片段：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, `a` lives on the stack, a happy local variable. `b` is a pointer to `a`,
    allowing us to manipulate the value of `a` directly through `b`. It’s a small
    window into the power of pointers and the stack, showing how they interact in
    a controlled environment.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`a`存在于堆栈上，是一个快乐的局部变量。`b`是`a`的指针，允许我们通过`b`直接操作`a`的值。这是指针和堆栈力量的一个小窗口，展示了它们在受控环境中的交互方式。
- en: Reflecting on my early days of wrestling with Go, I recall a project that was
    plagued with memory management issues. It felt like being lost in a forest, with
    pointers as my only compass. The breakthrough came when I realized that pointers
    and the stack were not just tools but the very fabric of Go’s memory management.
    It was like understanding that to navigate the forest, I didn’t just need to know
    where the trees were; I needed to understand how the forest grew. This moment
    of clarity came when I likened pointers to bookmarks in a novel, marking where
    the important parts of the story were, allowing me to jump back and forth without
    losing my place.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 回想起我早期与Go语言斗争的日子，我回忆起一个饱受内存管理问题困扰的项目。感觉就像是在森林中迷失，指针是我的唯一指南针。当我意识到指针和堆栈不仅仅是工具，而是Go语言内存管理的本质时，我有了突破。这就像理解了要导航森林，我不仅需要知道树木在哪里；我还需要了解森林是如何生长的。这一刻的清晰来自于我将指针比作小说中的书签，标记故事的重要部分，让我可以来回跳跃而不会失去位置。
- en: Think of the stack as a stack of dishes. When you’re cleaning up after dinner,
    you start piling dishes one on top of the other. The last dish you put on the
    stack is the first one you wash. The stack in Go works similarly with your function
    calls and local variables. When a function is called, Go throws everything it
    needs (such as variables) onto the stack. Once the function is done, Go clears
    those off, making room for the next function’s stuff. It’s a tidy way to handle
    memory that’s super-fast because it’s all automatic. You don’t need to tell Go
    to clean up; it just does.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将堆栈想象成一堆盘子。当你晚餐后收拾餐具时，你会将盘子一个叠一个地堆放起来。你最后放在堆栈上的盘子是第一个被清洗的。在Go语言中，堆栈的工作方式与你的函数调用和局部变量类似。当一个函数被调用时，Go会将它需要的所有东西（如变量）扔到堆栈上。一旦函数执行完毕，Go就会清理这些内容，为下一个函数的东西腾出空间。这是一种处理内存的整洁方式，因为它非常快，因为一切都是自动的。你不需要告诉Go去清理；它只是自动完成。
- en: Now, onto pointers. If the stack is about organization, pointers are about connections.
    A pointer in Go is like having the address of a friend’s house. You don’t have
    a house, but you know where to find it. In Go, pointers hold the memory address
    of a variable. This means you can directly change the value of a variable somewhere
    else in your program without needing to pass around the variable itself. It’s
    like texting your friend to turn on their porch light instead of walking over
    to do it yourself. Pointers are powerful because they let you manipulate data
    efficiently. However, with great power comes great responsibility. Misusing pointers
    can lead to bugs that are hard to track down.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈指针。如果栈是关于组织，那么指针就是关于连接。在 Go 中，指针就像拥有一个朋友的家的地址。你没有房子，但你知道在哪里可以找到它。在 Go
    中，指针持有变量的内存地址。这意味着你可以在程序的其他地方直接更改变量的值，而无需传递变量本身。这就像给朋友发短信让他们打开门廊的灯，而不是亲自过去做这件事。指针之所以强大，是因为它们让你能够高效地操作数据。然而，权力越大，责任越大。滥用指针可能导致难以追踪的bug。
- en: In system programming, you’re often working closer to the hardware, where efficiency
    and control over memory are critical. Understanding how the stack works helps
    you write efficient functions that don’t waste memory. Pointers give you the control
    you need to interact with memory locations directly, which is essential for tasks
    such as handling resources or working with low-level system structures.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统编程中，你通常更接近硬件，效率和对内存的控制至关重要。了解栈的工作原理有助于你编写高效的函数，这些函数不会浪费内存。指针为你提供了直接与内存位置交互所需的控制，这对于处理资源或与底层系统结构一起工作等任务至关重要。
- en: These concepts are fundamental in Go because they are designed to be simple
    yet powerful. It manages memory automatically in many cases, but knowing how and
    why it does this gives you the edge in writing high-performance applications.
    Whether you’re managing resources, optimizing performance, or just trying to debug
    your program, a solid grasp of stacks and pointers will make your life much easier.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念在 Go 中是基本的，因为它们旨在简单而强大。在许多情况下，它会自动管理内存，但了解它是如何以及为什么这样做，将使你在编写高性能应用程序时更具优势。无论你是管理资源、优化性能，还是只是尝试调试你的程序，对栈和指针的扎实掌握将使你的生活变得更加容易。
- en: 'So, as we dive deeper into the mechanics of Go, remember: understanding stacks
    and pointers is not just about memorizing definitions. It’s about getting to know
    the very fabric of system programming in Go, enabling you to write cleaner, faster,
    and more efficient code.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们深入 Go 的机制时，请记住：理解栈和指针不仅仅是记住定义。这是了解 Go 中系统编程的实质，使你能够编写更干净、更快、更高效的代码。
- en: Pointers
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针
- en: Pointers are your Swiss Army knife. They’re not just a feature; they’re a fundamental
    concept that can make or break your code’s efficiency and simplicity. Let’s demystify
    pointers and learn how to wield them with precision.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 指针是你的瑞士军刀。它们不仅仅是一个特性；它们是一个基本概念，可以决定你的代码的效率和简洁性。让我们揭开指针的神秘面纱，学习如何精确地使用它们。
- en: Simply put, a pointer is a variable that holds the address of another variable.
    Instead of carrying around the value itself, it points to where the value lives
    in memory. Imagine that you’re at a huge music festival. A pointer is not the
    stage where the band is playing; it’s the map that shows you where the stage is.
    In Go, this concept allows you to directly interact with the memory location of
    data.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，指针是一个变量，它持有另一个变量的地址。它不是携带值本身，而是指向值在内存中的位置。想象一下，你在一个巨大的音乐节上。指针不是乐队演奏的舞台；它是显示舞台位置的地图。在
    Go 中，这个概念允许你直接与数据内存位置交互。
- en: 'To declare a pointer in Go, you use an asterisk (`*`) before the type. This
    tells Go, “This variable is going to hold a memory address, not a direct value.”
    Here’s how it looks:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中声明指针时，你在类型前使用一个星号（`*`）。这告诉 Go，“这个变量将持有内存地址，而不是直接值。”下面是如何看起来：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This line declares a pointer, `p`, that will point to an integer. But right
    now, `p` doesn’t point to anything. It’s like having a map with no marked locations.
    To point it at an actual integer, you must use the address-of operator (`&`):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行声明了一个指针，`p`，它将指向一个整数。但到目前为止，`p` 没有指向任何东西。这就像拥有一张没有标记位置的地图。要让它指向一个实际的整数，你必须使用取地址运算符（`&`）：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, `p` holds the address of `x`. You’ve marked your stage on the festival
    map.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`p` 持有 `x` 的地址。你在音乐节的地图上标记了你的舞台。
- en: 'Dereferencing is how you access the value at the memory address the pointer
    is holding. You can do this with the same asterisk (`*`) you used to declare a
    pointer, but in a different context:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 解引用是通过访问指针所持有的内存地址中的值来实现的。你可以使用与声明指针时相同的星号（`*`）来完成这个操作，但处于不同的上下文中：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This line doesn’t print the memory address stored in `p`; it prints the value
    of `x` that `p` points to, thanks to dereferencing. You’ve gone from looking at
    the map to standing in front of the stage, enjoying the music.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码并没有打印出存储在`p`中的内存地址；它打印的是`p`指向的`x`的值，这是由于解引用的结果。你已经从查看地图转变为站在舞台前，享受音乐。
- en: With pointers, you can manipulate data without copying it around, saving time
    and memory – a critical advantage when resources are tight, or speed is paramount.
    They also allow you to interact with hardware, perform low-level system calls,
    or handle data structures in the most efficient way possible.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用指针，你可以操作数据而不需要复制它，节省时间和内存——这在资源紧张或速度至关重要的场合是一个关键优势。它们还允许你与硬件交互，执行低级系统调用，或以最有效的方式处理数据结构。
- en: 'Here are some best practices concerning pointers:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于指针的最佳实践：
- en: '**Keep it simple**: Only use pointers when necessary. Go’s garbage collector
    works wonders with memory management, but pointers, when used wisely, can enhance
    performance.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持简单**：仅在必要时使用指针。Go的垃圾回收器在内存管理方面表现出色，但指针如果使用得当，可以提升性能。'
- en: '`nil` before dereferencing to avoid runtime panics.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在解引用之前使用`nil`以避免运行时崩溃。
- en: '**Pointer passing**: When passing large structs to functions, use pointers
    to avoid copying the entire structure. It’s faster and more memory-efficient.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指针传递**：当将大型结构体传递给函数时，使用指针以避免复制整个结构体。这更快，也更节省内存。'
- en: Pointers are a gateway to mastering Go, especially for system programming, where
    direct memory access and manipulation are often required. By understanding and
    applying pointers effectively, you unlock a deeper level of control over your
    programs, paving the way for writing more efficient, powerful, and sophisticated
    system-level applications.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 指针是掌握Go语言的关键，尤其是在系统编程中，那里经常需要直接访问和操作内存。通过理解和有效应用指针，你可以解锁对程序更深层次的掌控，为编写更高效、强大和复杂的系统级应用铺平道路。
- en: Stack
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆栈
- en: The stack plays a crucial role and acts as the backbone of memory management.
    It’s where the magic happens for managing function calls and local variables.
    Let’s dive into the stack and why it’s a big deal in system programming.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈在内存管理中扮演着至关重要的角色，它是内存管理的骨干。它是管理函数调用和局部变量的魔法发生地。让我们深入堆栈，了解为什么它在系统编程中如此重要。
- en: Imagine the stack as a stack of trays in a cafeteria. Each tray represents a
    function call with its own set of dishes (local variables). When a new function
    is called, a tray is added to the top. When the function returns, the tray is
    removed, leaving no mess behind. This last-in, first-out mechanism ensures that
    the most recent function call is always on top, ready to be cleaned up as soon
    as it’s done.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 想象堆栈就像自助餐厅里的一摞托盘。每个托盘代表一个带有自己一套菜肴（局部变量）的函数调用。当一个新的函数被调用时，一个托盘被添加到顶部。当函数返回时，托盘被移除，不会留下任何混乱。这种后进先出的机制确保了最新的函数调用始终位于顶部，一旦完成就可以立即清理。
- en: Go leverages the stack to manage the life cycle of function calls and their
    local variables. When a function is called, Go automatically allocates space on
    the stack for its local variables. This space is efficiently managed by Go, freeing
    up the memory once the function call is complete. This automatic handling is a
    boon for system programmers as it simplifies memory management and enhances performance.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Go利用堆栈来管理函数调用及其局部变量的生命周期。当一个函数被调用时，Go会自动在堆栈上为其局部变量分配空间。这个空间由Go高效管理，一旦函数调用完成，就会释放内存。这种自动处理对系统程序员来说是一大福音，因为它简化了内存管理并提升了性能。
- en: Each function call creates what’s known as a “stack frame” on the stack. This
    frame contains all the necessary information for the function, including its local
    variables, arguments, and the return address. The stack frame is critical for
    the function’s execution, providing a self-contained block of memory that’s efficiently
    managed by the Go runtime.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数调用在堆栈上创建一个所谓的“堆栈帧”。这个帧包含了函数所需的所有信息，包括其局部变量、参数和返回地址。堆栈帧对于函数的执行至关重要，它提供了一个由Go运行时高效管理的自包含内存块。
- en: While the stack is efficient, it’s not limitless. Each Go program has a fixed
    stack size, which means you need to be mindful of how much memory your function
    calls and local variables are using. Deep recursion or large local variables can
    lead to a stack overflow, crashing your program. However, Go’s runtime tries to
    mitigate this by using a dynamically resizing stack, which grows and shrinks as
    needed, within limits.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然栈很高效，但它并非无限。每个 Go 程序都有一个固定的栈大小，这意味着你需要注意你的函数调用和局部变量使用了多少内存。深度递归或大型局部变量可能导致栈溢出，使你的程序崩溃。然而，Go
    的运行时试图通过使用动态调整大小的栈来减轻这种情况，栈根据需要增长和缩小，但有一定的限制。
- en: Heap
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆
- en: Think back to our cafeteria analogy. The stack, with its trays, is great for
    quick meals where items are neatly contained on a single tray. But what about
    a buffet-style situation or an elaborate dinner party? You’d need a much larger,
    more flexible space to lay everything out. This is where the heap comes in.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们的自助餐类比。栈，由于其托盘，非常适合快速用餐，其中物品整齐地放在单个托盘上。但如果是自助餐式的场合或一场复杂的晚宴呢？你需要一个更大、更灵活的空间来摆放所有东西。这就是堆的作用所在。
- en: The heap is a less structured area of memory. It’s like a giant storage room
    where Go can store data of varying sizes as needed. When you need to hold a big
    array that expands and contracts over time or create complex objects with lots
    of interconnected pieces, the heap is your go-to place.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是内存中一个结构较松散的区域。它就像一个巨大的储藏室，Go 可以根据需要存储不同大小的数据。当你需要存储一个随时间扩展和收缩的大数组或创建具有许多相互连接部分的复杂对象时，堆是你的首选之地。
- en: The cost of this flexibility is a slight loss in speed. The system needs to
    keep track of what’s on the heap, where free space is available, and when memory
    is no longer in use. This bookkeeping makes things a tad slower than the stack’s
    streamlined operation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性的代价是略微损失速度。系统需要跟踪堆上的内容、可用空闲空间以及内存何时不再使用。这种账目使得操作比栈的简化操作慢一些。
- en: The stack and the heap – partners in memory
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 栈和堆——内存的合作伙伴
- en: 'In Go, the stack and the heap work together seamlessly. Imagine the following
    scenario:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，栈和堆无缝协作。想象以下场景：
- en: You write a function that creates a large data structure, let’s say a linked
    list. The function itself gets a tidy spot on the stack (its stack frame).
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你编写一个函数来创建一个大型数据结构，比如说一个链表。函数本身在栈上（其栈帧）获得一个整洁的位置。
- en: The linked list itself, with its nodes and data, gets space on the heap, where
    it can grow and shrink as needed.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链表本身，包括其节点和数据，在堆上获得空间，它可以根据需要增长和缩小。
- en: Inside your function’s stack frame, there’s a pointer referencing the start
    of your linked list on the heap. This way, the function can find and manipulate
    the data structure living in the flexible heap space.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的函数栈帧内部，有一个指针指向堆上你的链表的开头。这样，函数就可以找到并操作存在于灵活的堆空间中的数据结构。
- en: The heap, while powerful, requires careful attention from system programmers.
    If you constantly allocate and deallocate varying-sized chunks of memory from
    the heap, it can become fragmented over time, making it harder to find large,
    contiguous spaces. It’s commonly referenced as memory fragmentation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然堆功能强大，但需要系统程序员仔细关注。如果你经常从堆中分配和释放不同大小的内存块，随着时间的推移，它可能会变得碎片化，使得找到大块连续空间变得更加困难。这通常被称为内存碎片化。
- en: 'Here are some best practices concerning allocation:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于分配的最佳实践：
- en: '**Minimize large local variables**: Consider using the heap for large data
    structures to avoid consuming too much stack space'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小化大型局部变量**：考虑使用堆来存储大型数据结构，以避免消耗过多的栈空间'
- en: '**Be cautious with recursion**: Ensure recursive functions have a clear termination
    condition to prevent stack overflow'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**谨慎使用递归**：确保递归函数有一个明确的终止条件，以防止栈溢出'
- en: '**Understand stack versus heap allocation**: Use the stack for short-lived
    variables and the heap for variables that need to outlive the function call'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解栈与堆的分配**：使用栈来存储短期变量，而使用堆来存储需要超出函数调用生命周期的变量'
- en: We can make sure where our variables live using escape analysis.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过逃逸分析来确保变量的存储位置。
- en: How can we analyze?
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们该如何分析？
- en: Escape analysis in Go is the dark art that even seasoned developers pretend
    to understand while secretly googling it during code reviews. It’s like claiming
    you enjoy free jazz; it sounds sophisticated until someone asks you to explain
    it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的逃逸分析是一种连经验丰富的开发者都假装理解，而在代码审查期间秘密在 Google 上搜索的神秘技术。这就像声称你喜欢免费爵士乐；听起来很复杂，直到有人要求你解释它。
- en: Imagine you’re at a party, and someone decides to explain quantum mechanics,
    but every explanation somehow loops back to their sourdough starter. That’s the
    equivalent of trying to wrap your head around escape analysis without getting
    your hands dirty in the code. It’s complex and slightly pretentious, and everyone
    nods along without really getting it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你在一个聚会上，有人决定解释量子力学，但每一次解释都似乎回到了他们的酸面包酵母。这就是试图在没有在代码中动手的情况下理解逃逸分析的样子。它很复杂，有点自命不凡，每个人都点头附和，但实际上并没有真正理解。
- en: Escape analysis, at its core, is the compiler’s way of deciding where variables
    live in your Go programs. It’s like a strict landlord deciding whether your variable
    is trustworthy enough to rent space on the stack or if it’s too sketchy and needs
    to be kicked out of the heap. The goal here is efficiency and speed. Variables
    on the stack are like friends crashing on your couch for the night; they’re easy
    to manage and leave quickly. Variables on the heap are more like signing a lease;
    more commitment is required, and the process is slower.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 逃逸分析，从本质上讲，是编译器决定你的Go程序中变量存放位置的方式。它就像一个严格的房东决定你的变量是否足够可靠，可以在栈上租用空间，或者它是否太可疑，需要从堆中踢出去。这里的目的是效率和速度。栈上的变量就像朋友在你沙发上过夜；它们容易管理，离开得也快。堆上的变量更像是签署一份租约；需要更多的承诺，过程也更慢。
- en: The compiler performs this analysis during the compilation phase, scrutinizing
    your code to predict how variables are used and whether they escape the function
    they’re created in. If a variable is passed back to the caller, it’s considered
    to have “escaped.” This decision impacts performance significantly. Stack allocation
    is faster and more CPU cache-friendly than heap allocation, which is slower and
    requires garbage collection.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器在编译阶段执行此分析，仔细检查你的代码以预测变量如何使用以及它们是否从创建它们的函数中“逃逸”。如果一个变量被传回调用者，它被认为“逃逸”了。这个决定对性能有重大影响。栈分配比堆分配更快，且更符合CPU缓存，而堆分配较慢且需要垃圾回收。
- en: 'To understand this, let’s dive into a simple code example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这一点，让我们深入一个简单的代码示例：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this snippet, `a` is an integer that, in a simpler world, would happily live
    on the stack. However, because we take its address and assign it to `b`, the compiler
    fears `a` might escape the confines of `main()`. Thus, it might decide to allocate
    `a` on the heap to be safe, even though, in this case, it doesn’t escape.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，`a`是一个整数，在一个更简单的世界中，它会很乐意生活在栈上。然而，因为我们取了它的地址并将其分配给`b`，编译器担心`a`可能会逃出`main()`函数的界限。因此，它可能会决定在堆上分配`a`以确保安全，尽管在这种情况下，它并没有逃逸。
- en: Recalling the hurdles of my early days of learning Go, I recall a project where
    optimizing a critical path led me down the rabbit hole of escape analysis. After
    hours of profiling and tweaking, the breakthrough came when I realized a variable,
    innocuously passed by reference to several functions, was the culprit of my heap
    allocation woes. By adjusting the code to keep this variable on the stack, the
    performance gains were akin to switching from a tricycle to a sports car on an
    open highway.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 回想起我学习Go语言初期的困难，我回忆起一个项目，其中优化关键路径让我陷入了逃逸分析的兔子洞。经过数小时的性能分析和调整，当我意识到一个变量，虽然无害地通过引用传递给几个函数，却是我堆分配问题的罪魁祸首时，我有了突破。通过调整代码以保持这个变量在栈上，性能提升就像是把一辆三轮车换成在开放式高速公路上的跑车。
- en: In Go, a goroutine’s stack memory is strictly its own; *no goroutine can have
    a pointer to another goroutine’s stack*. This isolation ensures that the runtime
    does not need to manage complex pointer references across goroutines, simplifying
    memory management and avoiding potential latency issues from stack resizing.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go语言中，goroutine的栈内存严格属于它自己；*没有goroutine可以拥有另一个goroutine的栈的指针*。这种隔离确保运行时不需要在goroutine之间管理复杂的指针引用，简化了内存管理并避免了栈大小调整可能带来的潜在延迟问题。
- en: When a value is passed outside its function’s stack frame, it may need to be
    allocated on the heap to ensure its persistence beyond the function call. This
    determination is made by the compiler through escape analysis. The compiler analyzes
    function calls and variable references to decide whether a variable’s lifetime
    extends beyond its current stack frame, necessitating heap allocation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个值被传递出其函数的栈帧之外时，可能需要在堆上分配以确保其在函数调用之后持续存在。这个决定是通过编译器的逃逸分析来进行的。编译器分析函数调用和变量引用，以决定一个变量的生命周期是否超出其当前的栈帧，从而需要堆分配。
- en: 'Consider the following example, which illustrates escape analysis in action:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例，它说明了逃逸分析的实际应用：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, the `createPerson` function creates a `person` struct and returns
    a pointer to it. Due to the `return &p` statement, the `person` struct “escapes”
    to the heap because its reference is passed back to the caller, extending its
    lifetime beyond the `createPerson` function’s stack frame.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`createPerson`函数创建了一个`person`结构体并返回对其的指针。由于`return &p`语句，`person`结构体“逃逸”到堆上，因为它的引用被传递回调用者，延长了其生命周期，超出了`createPerson`函数的栈帧。
- en: To see how the Go compiler performs escape analysis, you can compile your Go
    program with the `-gcflags "-m -``m"` option.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看Go编译器如何执行逃逸分析，您可以使用带有`-gcflags "-m -m"`选项的编译您的Go程序。
- en: 'In the `ch9/escape-analysis` directory, execute the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ch9/escape-analysis`目录中，执行以下命令：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should see an output similar to the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下输出的结果：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This command prints detailed information about the compiler’s decisions on variable
    allocations. Understanding these reports can help you write more efficient Go
    code by minimizing unnecessary heap allocations.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令打印有关编译器在变量分配上的决策的详细信息。理解这些报告可以帮助您通过最小化不必要的堆分配来编写更高效的Go代码。
- en: 'Let’s dive a little deeper into this sequence brought by escape analysis:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地探讨由逃逸分析带来的这个序列：
- en: 'Inlining and `go:noinline`:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内联和`go:noinline`：
- en: '[PRE8]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`createPerson` function. This is sometimes necessary for complex functions
    or if inlining introduces unwanted side effects.'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createPerson`函数。这在处理复杂函数或内联引入不希望的副作用时有时是必要的。'
- en: 'Complexity cost and budget:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复杂度成本和预算：
- en: '[PRE9]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`80`, in this case). Exceeding this budget means the compiler decides the function
    is too complex to benefit from inlining.'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，`80`。超出此预算意味着编译器决定函数过于复杂，无法从内联中受益。
- en: 'Informational:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 信息性：
- en: '[PRE10]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is informational. The compiler is successfully inlining a call to the `fmt.Println`
    function. It’s good practice to keep `fmt.Println` usage simple, ensuring it doesn’t
    impede inlining.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一条信息性消息。编译器正在成功内联对`fmt.Println`函数的调用。保持`fmt.Println`使用简单是良好的实践，确保它不会妨碍内联。
- en: 'Escape:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逃逸：
- en: '[PRE11]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Escape analysis**: Go analyzes whether variables “escape” their current function’s
    scope. If a variable escapes, it must be allocated on the heap (for a longer lifetime)
    instead of the stack.'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逃逸分析**：Go分析变量是否“逃逸”出当前函数的作用域。如果一个变量逃逸，它必须在堆上（对于更长的生命周期）而不是栈上分配。'
- en: We have a variable, `p`, whose address is being returned on line 18\. Since
    this address can be used outside the current function, `p` must live on the heap.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个变量`p`，其地址在18行被返回。由于这个地址可以在当前函数之外使用，`p`必须在堆上生存。
- en: Escape analysis is a powerful feature of the Go compiler that helps manage memory
    efficiently by determining the most appropriate location for variable allocation.
    By understanding how and why variables escape to the heap, you can write more
    efficient Go programs that make better use of system resources.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 逃逸分析是Go编译器的一个强大功能，它通过确定变量分配的最合适位置来帮助有效地管理内存。通过了解变量如何以及为什么逃逸到堆上，您可以编写更高效的Go程序，更好地利用系统资源。
- en: As you continue to develop in Go, keep escape analysis in mind, especially when
    working with pointers and function returns. Remember, the goal is to allow the
    compiler to optimize memory usage, improving the performance of your Go applications.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在您继续使用Go进行开发时，请记住逃逸分析，尤其是在处理指针和函数返回时。记住，目标是允许编译器优化内存使用，提高您的Go应用程序的性能。
- en: Although we can check where our allocations go, how do we determine if the performance
    has improved? A good start is to benchmark our code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以检查我们的分配去向，但我们如何确定性能是否有所提升？一个好的开始是对我们的代码进行基准测试。
- en: Benchmarking your code
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对您的代码进行基准测试
- en: Benchmarking in Go is the sacred ritual where developers often embark on a quest
    for performance enlightenment, only to find themselves lost in a maze of micro-optimizations.
    It’s like preparing for a marathon by obsessively timing how fast you can tie
    your shoelaces, completely missing the point of the broader training regimen.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的基准测试是一种神圣的仪式，开发者们常常踏上追求性能启迪的旅程，结果却发现自己在微观优化的迷宫中迷失方向。这就像通过痴迷地计时系鞋带的速度来为马拉松做准备，完全忽略了更广泛的训练计划的重点。
- en: Imagine, if you will, a seasoned software developer likened to a master chef,
    meticulously selecting each ingredient for the perfect dish. In this culinary
    quest, the chef knows that the choice between Himalayan pink salt and sea salt
    isn’t just about taste – it’s about the subtle nuances that can elevate a dish
    from good to sublime. Similarly, in software development, the choice between different
    algorithms or data structures isn’t just about speed or memory usage on paper;
    it’s about understanding the intricate dance of cache misses, branch prediction,
    and execution pipelines. It’s an art form where brushstrokes matter as much as
    the canvas.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，一位经验丰富的软件开发者就像一位大师级厨师，精心挑选每一份食材以制作完美的菜肴。在这个烹饪探索中，厨师知道选择喜马拉雅粉盐和海盐不仅仅是关于味道——它关乎那些可以使菜肴从好到卓越的微妙差别。同样，在软件开发中，选择不同的算法或数据结构不仅仅是关于纸面上的速度或内存使用；它关乎理解缓存未命中、分支预测和执行流水线的复杂舞蹈。这是一种艺术形式，其中笔触与画布一样重要。
- en: Now, let’s get into the meat of the matter – benchmarks in Go. At its core,
    benchmarking is a systematic method of measuring and comparing the performance
    of software. It’s not just about running a piece of code and seeing how fast it
    goes; it’s about creating a controlled environment where you can understand the
    impact of changes in code, algorithms, or system architecture. The goal is to
    provide actionable insights that guide optimization efforts, ensuring that they’re
    not just shots in the dark.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入探讨Go中的基准测试。在本质上，基准测试是一种系统性的测量和比较软件性能的方法。它不仅仅是运行一段代码并查看其运行速度；它是在一个受控环境中创建，以便您可以了解代码、算法或系统架构变化的影响。目标是提供可操作的见解，以指导优化工作，确保它们不是盲目的尝试。
- en: Go, with its rich standard library and tooling, offers a robust framework for
    benchmarking. The `testing` package is a jewel in the crown, allowing developers
    to write benchmark tests that are as straightforward as their unit tests. These
    benchmarks can then be executed with the `go test` command, providing detailed
    performance metrics that can be used to identify bottlenecks or validate efficiency
    improvements.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Go凭借其丰富的标准库和工具，提供了一个强大的基准测试框架。`testing`包是其中的瑰宝，允许开发者编写与单元测试一样简单的基准测试。然后可以使用`go
    test`命令执行这些基准测试，提供详细性能指标，可用于识别瓶颈或验证效率改进。
- en: 'Let’s assume that `Fib` is a function that calculates the nth Fibonacci number.
    To create a benchmark, you must write a function in a `_test.go` file that starts
    with `Benchmark` and takes a `*testing.B` parameter. The `go test` command is
    used to run these benchmark functions:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`Fib`是一个计算第n个斐波那契数的函数。为了创建基准测试，您必须在`_test.go`文件中编写一个以`Benchmark`开头并接受一个`*testing.B`参数的函数。使用`go
    test`命令来运行这些基准测试函数：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This snippet illustrates the essence of Go’s benchmarking approach: concise,
    readable, and focused on measuring the performance of a specific piece of code
    under repeatable conditions. The `b.N` loop allows the benchmarking framework
    to adjust the number of iterations dynamically, ensuring that the measurements
    are both accurate and reliable.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了Go基准测试方法的精髓：简洁、易读，并专注于在可重复条件下测量特定代码片段的性能。`b.N`循环允许基准测试框架动态调整迭代次数，确保测量既准确又可靠。
- en: Writing your first benchmark
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写您的第一个基准测试
- en: For your first benchmark, you’ll create a function called `Sum` that adds two
    integers. The benchmark function, `BenchmarkSum`, measures how long it takes to
    execute `Sum(1, 2)`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您的第一个基准测试，您将创建一个名为`Sum`的函数，该函数用于将两个整数相加。基准测试函数`BenchmarkSum`测量执行`Sum(1, 2)`所需的时间。
- en: 'Here’s how you can achieve this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您如何实现这一点的：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `*testing.B` parameter provides control and reporting facilities for the
    benchmark. The most important field in `*testing.B` is `N`, which represents the
    number of iterations the benchmark function should execute the code under test.
    The Go testing framework automatically determines the best value of `N` to get
    a reliable measurement.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`*testing.B`参数为基准测试提供了控制和报告功能。在`*testing.B`中最重要的字段是`N`，它表示基准测试函数应该在测试代码下执行多少次迭代。Go测试框架会自动确定`N`的最佳值以获得可靠的测量结果。'
- en: 'To run benchmarks, use the `go test` command with the `-bench` flag, specifying
    a regular expression as an argument to match the benchmark functions you want
    to run. For example, to run all benchmarks, you can use the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行基准测试，请使用带有`-bench`标志的`go test`命令，将正则表达式作为参数指定以匹配您想要运行的基准函数。例如，要运行所有基准测试，可以使用以下命令：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output of a benchmark run provides several pieces of information:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试运行的输出提供了几条信息：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we have the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有以下内容：
- en: '`BenchmarkSum-8`: The name of the benchmark function, with -8 indicating the
    value of `GOMAXPROCS`, which shows the benchmark was run with parallelism set
    to 8'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BenchmarkSum-8`：基准函数的名称，其中-8表示`GOMAXPROCS`的值，这表明基准测试是在并行设置为8的情况下运行的'
- en: '`1000000000`: The number of iterations determined by the testing framework'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1000000000`：由测试框架确定的迭代次数'
- en: '`0.277 ns/op`: The average time taken per operation (in this case, nanoseconds
    per operation)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.277 ns/op`：每次操作的平均耗时（在这种情况下，每次操作的纳秒数）'
- en: 'Go allows you to define sub-benchmarks within a benchmark function, enabling
    you to test different scenarios or inputs systematically. Here’s how you can use
    sub-benchmarks:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Go允许你在基准测试函数中定义子基准测试，使你能够系统地测试不同的场景或输入。以下是使用子基准测试的方法：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this example, we have the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有以下内容：
- en: '`a` and `b`. These structs are used to provide different inputs to the `Sum`
    function, allowing us to benchmark its performance across different scenarios.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a`和`b`。这些结构体用于向`Sum`函数提供不同的输入，使我们能够跨不同场景基准测试其性能。'
- en: '`for` loop. For each case, it calls `b.Run()` to execute a sub-benchmark.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`循环。对于每个情况，它调用`b.Run()`来执行子基准测试。'
- en: '`b.Run()` function takes two parameters: the name of the sub-benchmark (derived
    from the test case) and a function that contains the actual benchmark code. This
    allows the Go testing framework to treat each set of inputs as a separate benchmark,
    providing individual performance metrics for each.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b.Run()`函数接受两个参数：子基准测试的名称（从测试用例派生而来）和包含实际基准代码的函数。这允许Go测试框架将每组输入视为一个单独的基准测试，为每个提供单独的性能指标。'
- en: '`b.N` times, calling the `Sum` function with the test case’s inputs. This measures
    the performance of `Sum` under the specific conditions defined by the inputs.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b.N`次，使用测试用例的输入调用`Sum`函数。这测量了`Sum`在特定输入定义的条件下的性能。'
- en: 'When we run the tests with the benchmark flag again, the result should be something
    like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们再次使用基准标志运行测试时，结果应该类似于以下内容：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: That’s great! Now, we can explore how much memory our program parts are using
    so that we can get a better understanding of their behavior.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在，我们可以探索程序各部分使用多少内存，以便更好地理解其行为。
- en: Memory allocations
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存分配
- en: To measure memory allocations, you can use the `-benchmem` flag when running
    benchmarks.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要测量内存分配，可以在运行基准测试时使用`-benchmem`标志。
- en: 'This flag adds two more columns to the output: `allocs/op`, which specifies
    the number of memory allocations per operation, and `B/op`, which specifies the
    number of bytes allocated per operation.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此标志向输出中添加了两列：`allocs/op`，指定每操作内存分配的数量，以及`B/op`，指定每操作分配的字节数。
- en: 'Here’s some example output when using `-benchmem`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-benchmem`时的一些示例输出如下：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, we have the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有以下内容：
- en: '`16 B/op`: This indicates that each operation (in this case, each call to `Sum`)
    allocates 16 bytes of memory. This metric helps identify how changes to your code
    affect its memory footprint.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`16 B/op`：这表明每次操作（在这种情况下，每次调用`Sum`）分配了16字节内存。这个指标有助于识别代码更改如何影响其内存占用。'
- en: '`2 allocs/op`: This shows the number of memory allocations that occur per operation.
    In this example, each call to `Sum` results in two memory allocations. Reducing
    the number of allocations can often improve performance, especially in tight loops
    or performance-critical sections of code.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2 allocs/op`：这显示了每次操作发生的内存分配数量。在这个例子中，每次调用`Sum`都会导致两次内存分配。减少分配次数通常可以提高性能，尤其是在紧密循环或代码的性能关键部分。'
- en: We are doing very well at this point, but how can we identify if our code changes
    were effective? In this case, we should rely on comparing the benchmark results.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前做得很好，但如何确定我们的代码更改是否有效？在这种情况下，我们应该依赖于比较基准测试结果。
- en: Comparing benchmarks
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较基准测试
- en: To compare benchmarks, we’ll use a Go tool called `benchstat`, which provides
    a statistical analysis of benchmark results. It is particularly useful for comparing
    benchmark outputs from different test runs, making it easier to understand the
    performance changes between different versions of your code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较基准测试，我们将使用一个名为`benchstat`的Go工具，它提供了基准测试结果的分析。它特别适用于比较不同测试运行中的基准输出，使得理解代码不同版本之间的性能变化更加容易。
- en: 'First, you need to install `benchstat`. Assuming you have Go installed on your
    system, you can install `benchstat` using the `go install` command. Since Go 1.16,
    it’s recommended to use this command with a version suffix:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要安装`benchstat`。假设你的系统已安装Go，你可以使用`go install`命令安装`benchstat`。从Go 1.16开始，建议使用带有版本后缀的此命令：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This command downloads and installs the `benchstat` binary in your Go binary
    directory (usually `$GOPATH/bin` or `$HOME/go/bin`). Ensure this directory is
    in your system’s `PATH` so that you can run `benchstat` from any terminal.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将`benchstat`二进制文件下载并安装到你的Go二进制目录中（通常是`$GOPATH/bin`或`$HOME/go/bin`）。请确保此目录已添加到系统的`PATH`中，这样你就可以在任何终端中运行`benchstat`。
- en: 'First, we need to run benchmarks and save their outputs to files. You can run
    your benchmarks using the `go test -bench` command, redirecting the output to
    a file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要运行基准测试并将它们的输出保存到文件中。你可以使用`go test -bench`命令运行基准测试，将输出重定向到文件：
- en: 'Run the first benchmark:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行第一个基准测试：
- en: '[PRE20]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Make changes to your code and run the following command:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改你的代码并运行以下命令：
- en: '[PRE21]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With the benchmark results saved in `old.txt` and `new.txt`, you can use `benchstat`
    to compare these results and analyze the performance differences:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将基准测试结果保存到`old.txt`和`new.txt`后，你可以使用`benchstat`来比较这些结果并分析性能差异：
- en: '[PRE22]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Interprete the output of `benchstat`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释`benchstat`的输出。
- en: 'Our new tool provides a tabulated output with several columns. Here’s an example
    of what the output might look like:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新工具提供了一种表格化的输出，包含多个列。以下是一个输出示例可能的样子：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let’s take a closer look:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看：
- en: '`name`: The name of the benchmark.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：基准测试的名称。'
- en: '`old time/op`: The average time per operation for the first set of benchmarks
    (from `old.txt`).'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`old time/op`：第一组基准测试（来自`old.txt`）的平均操作时间。'
- en: '`new time/op`: The average time per operation for the second set of benchmarks
    (from `new.txt`).'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new time/op`：第二组基准测试（来自`new.txt`）的平均操作时间。'
- en: '`delta`: The percentage change in time per operation from the old to the new
    benchmarks. A negative delta indicates an improvement (faster code), while a positive
    delta indicates a regression (slower code).'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delta`：从旧基准到新基准的操作时间的百分比变化。负delta表示改进（代码更快），而正delta表示回归（代码更慢）。'
- en: '`p`: The p-value from a statistical test (usually a t-test) compares the old
    and new benchmarks. A low p-value (typically <0.05) suggests that the observed
    performance difference is statistically significant.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p`：来自统计测试（通常是t检验）的p值，比较旧基准和新基准。低p值（通常小于0.05）表明观察到的性能差异在统计上具有显著性。'
- en: '`n`: The number of samples used to compute the average time per operation for
    both the old and new benchmarks.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n`：用于计算旧基准和新基准的平均操作时间的样本数量。'
- en: Statistical terms
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 统计术语
- en: The `±` symbol, when followed by a percentage, indicates the margin of error
    around the average time per operation. It gives you an idea of the variability
    of your benchmark results.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当`±`符号后面跟着一个百分比时，表示平均操作时间的误差范围。这让你对基准测试结果的可变性有一个概念。
- en: The `benchstat` binary is a powerful tool for analyzing the performance of your
    Go code, offering a clear, statistical comparison of benchmark results. Remember,
    while `benchstat` can highlight significant changes, it’s also important to consider
    the context of your benchmarks and the real-world implications of any performance
    differences.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`benchstat`二进制文件是一个强大的工具，用于分析Go代码的性能，提供了基准结果的清晰、统计比较。记住，虽然`benchstat`可以突出显著变化，但考虑基准测试的上下文以及任何性能差异的现实世界影响也同样重要。'
- en: Extra arguments
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 额外参数
- en: When running benchmarks in Go, you have the flexibility to control not only
    how long and how many times the benchmarks are run but also which specific benchmarks
    to execute. This is particularly useful when you’re working on optimizing or debugging
    a specific part of your code and you only want to run benchmarks related to that
    code. The `-benchtime=`, `-count`, and `-bench=` flags can be combined effectively
    to run benchmarks selectively and with precise control over their execution parameters.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 Go 中的基准测试时，你可以控制基准测试的运行时间和次数，以及要执行的特定基准测试。当你正在优化或调试代码的特定部分，并且只想运行与该代码相关的基准测试时，这特别有用。`-benchtime=`、`-count`
    和 `-bench=` 标志可以有效地结合使用，以选择性地运行基准测试并对它们的执行参数进行精确控制。
- en: Using the -bench= flag to filter benchmarks
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 `-bench=` 标志来过滤基准测试
- en: The `-bench=` flag allows you to specify a **regular expression** (**regex**)
    that matches the names of the benchmarks you want to run. Only benchmarks whose
    names match the regex will be executed. This is incredibly useful for selectively
    running benchmarks without having to run your entire suite.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`-bench=` 标志允许你指定一个 **正则表达式**（**regex**），该表达式匹配你想要运行的基准测试的名称。只有名称与正则表达式匹配的基准测试才会被执行。这在选择性地运行基准测试而不必运行整个套件时非常有用。'
- en: 'For example, let’s say you have several benchmarks in your package: `BenchmarkSum`,
    `BenchmarkMultiply`, and `BenchmarkDivide`.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你的包中有几个基准测试：`BenchmarkSum`、`BenchmarkMultiply` 和 `BenchmarkDivide`。
- en: 'If you only want to run `BenchmarkMultiply`, you can use the `-bench=` flag
    like so:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想运行 `BenchmarkMultiply`，你可以这样使用 `-bench=` 标志：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This command tells the Go test runner to only execute benchmarks whose names
    match `BenchmarkMultiply`. The matching is case-sensitive and based on Go’s regular
    expression syntax, giving you a lot of flexibility in specifying which benchmarks
    to run.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令指示 Go 测试运行器仅执行名称匹配 `BenchmarkMultiply` 的基准测试。匹配区分大小写，并基于 Go 的正则表达式语法，这为你指定要运行的基准测试提供了很大的灵活性。
- en: Combining all of them
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结合所有这些
- en: 'You can combine `-bench=` with `-benchtime=` and `-count` to finely control
    the execution of specific benchmarks. For instance, if you want to run `BenchmarkMultiply`
    for a longer duration and repeat the benchmark multiple times to get a more reliable
    measurement, you could use the following command:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `-bench=` 与 `-benchtime=` 和 `-count` 结合使用，以精细控制特定基准测试的执行。例如，如果你想运行 `BenchmarkMultiply`
    更长时间，并多次重复基准测试以获得更可靠的测量结果，你可以使用以下命令：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This command will run the `BenchmarkMultiply` benchmark for at least 3 seconds
    each time and repeat the whole benchmark five times. This approach is beneficial
    when you’re trying to measure the impact of performance optimizations or ensure
    that changes haven’t introduced performance regressions.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将每次运行 `BenchmarkMultiply` 基准测试至少 3 秒钟，并重复整个基准测试五次。当你试图衡量性能优化的影响或确保更改没有引入性能退步时，这种方法很有益。
- en: Tips for filtering benchmarks
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤基准测试的提示
- en: There are three main tips for filtering benchmarks. The first is often called
    `-bench=.` will run all benchmarks in the package, while `-bench=Benchmark` will
    run any benchmark that starts with `Benchmark`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤基准测试有三个主要提示。第一个通常称为 `-bench=.` 将运行包中的所有基准测试，而 `-bench=Benchmark` 将运行任何以 `Benchmark`
    开头的基准测试。
- en: The second is `-bench=` flag. For example, if you have sub-benchmarks named
    `BenchmarkMultiply/small` and `BenchmarkMultiply/large`, you can run just the
    “large” sub-benchmarks with `-bench=BenchmarkMultiply/large`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是 `-bench=` 标志。例如，如果你有名为 `BenchmarkMultiply/small` 和 `BenchmarkMultiply/large`
    的子基准测试，你可以仅运行“large”子基准测试，使用 `-bench=BenchmarkMultiply/large`。
- en: The last one is making sure you avoid `-bench=Multiply` would match `BenchmarkMultiply`
    but could also match `BenchmarkComplexMultiply` if such a benchmark exists. Use
    more specific patterns to narrow down the benchmarks you want to run.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个是确保你避免使用 `-bench=Multiply`，它会匹配 `BenchmarkMultiply`，但如果存在这样的基准测试，它也可能匹配
    `BenchmarkComplexMultiply`。使用更具体的模式来缩小你想要运行的基准测试范围。
- en: The ability to filter benchmarks with `-bench=`, control the benchmark time
    with `-benchtime=`, and specify the number of runs with `-count` provides a powerful
    set of tools for Go developers looking to optimize their code. By running only
    the benchmarks you’re interested in, for the duration and number of times that
    provide meaningful data, you can focus your optimization efforts more effectively
    and understand the performance characteristics of your code with greater clarity.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-bench=` 过滤基准测试，使用 `-benchtime=` 控制基准测试时间，以及使用 `-count` 指定运行次数，为寻求优化代码的
    Go 开发者提供了一套强大的工具。通过仅运行感兴趣的基准测试，并在提供有意义数据的时间长度和次数下运行，你可以更有效地集中优化努力，并更清晰地理解代码的性能特征。
- en: Common pitfalls
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见陷阱
- en: There are a lot of common pitfalls during benchmarking. Let’s explore the most
    common ones.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在基准测试过程中存在许多常见陷阱。让我们来探讨其中最常见的一些。
- en: '**Pitfall 1 – benchmarking the** **wrong thing**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**陷阱1 –** 基准测试**错误的内容**'
- en: One of the most fundamental mistakes is to benchmark the wrong aspect of your
    code. For instance, when benchmarking a function that sorts a slice, if the slice
    is sorted only once and then reused across benchmark iterations without re-initialization,
    subsequent iterations will operate on already sorted data, skewing the results.
    This mistake highlights the importance of setting up the benchmark’s state correctly
    for each iteration to ensure that you’re measuring the intended operation.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的错误之一是对代码的错误方面进行基准测试。例如，当基准测试一个对切片进行排序的函数时，如果切片只排序一次并在基准测试迭代中重复使用而不重新初始化，后续迭代将操作已排序的数据，从而歪曲结果。这个错误强调了正确设置每个迭代的基准测试状态的重要性，以确保你正在测量预期的操作。
- en: '`b.ResetTimer()` and properly initialize the state within the benchmark loop,
    ensuring each iteration benchmarks the operation under the same conditions.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在基准测试循环中正确初始化状态，并使用 `b.ResetTimer()`，确保每个迭代都在相同的条件下进行操作。
- en: '**Pitfall 2 –** **compiler optimizations**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**陷阱2 –** **编译器优化**'
- en: The Go compiler, like many others, optimizes code, which can lead to misleading
    benchmark results. For example, if the result of a function call is not used,
    the compiler might optimize away the call entirely. Similarly, constant propagation
    can lead to the compiler replacing a function call with a pre-computed result.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Go 编译器，像许多其他编译器一样，会优化代码，这可能导致误导性的基准测试结果。例如，如果函数调用的结果没有被使用，编译器可能会完全优化掉这个调用。同样，常量传播可能导致编译器用预计算的值替换函数调用。
- en: '`runtime.KeepAlive` to ensure the compiler treats the result as needed at runtime.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `runtime.KeepAlive` 确保编译器在运行时将结果视为所需。
- en: '**Pitfall 3 –** **warmup**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**陷阱3 –** **预热**'
- en: Modern CPUs and systems have various levels of caches and optimizations that
    “warm up” over time. Starting measurements too early before the system reaches
    a steady state can lead to inaccurate results that do not reflect typical performance.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现代CPU和系统具有各种级别的缓存和优化，这些优化会随着时间的推移而“预热”。在系统达到稳定状态之前过早地开始测量可能会导致不准确的结果，这些结果并不能反映典型的性能。
- en: '`b.ResetTimer()` in Go benchmarks to start timing after the initial setup or
    warmup phase.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 基准测试中使用 `b.ResetTimer()` 在初始设置或预热阶段之后开始计时。
- en: '**Pitfall 4 –** **environment**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**陷阱4 –** **环境**'
- en: Running benchmarks in environments that differ significantly from production
    can lead to results that are not representative of real-world performance. Differences
    in hardware, operating system, network conditions, and even the load under which
    the benchmark is run can all affect the outcome.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在与生产环境显著不同的环境中运行基准测试可能会导致结果不能代表真实世界的性能。硬件、操作系统、网络条件以及基准测试运行时的负载差异都可能影响结果。
- en: '**Solution**: As much as possible, run benchmarks under conditions that closely
    mimic production environments. This includes using similar hardware, running the
    same version of the Go runtime, and simulating realistic load and usage patterns.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：尽可能在尽可能接近生产环境条件下运行基准测试。这包括使用类似的硬件，运行相同的 Go 运行时版本，并模拟真实的负载和用法模式。'
- en: '**Pitfall 5 – ignoring garbage collection and other** **runtime costs**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**陷阱5 –** 忽略垃圾回收和其他**运行时成本**'
- en: Go’s runtime, including garbage collection, can significantly impact performance.
    Benchmarks that do not take these costs into account may not accurately reflect
    the performance users will experience.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的运行时，包括垃圾回收，可以显著影响性能。不考虑这些成本的基准测试可能无法准确反映用户将体验到的性能。
- en: '**Solution**: Be mindful of the impact of garbage collection and other runtime
    behaviors on your benchmarks. Use runtime metrics and profiling to understand
    how these factors affect your benchmarks. Consider running longer benchmarks to
    capture the impact of garbage collection cycles.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：注意垃圾收集和其他运行时行为对基准测试的影响。使用运行时指标和性能分析来了解这些因素如何影响基准测试。考虑运行更长时间的基准测试以捕捉垃圾收集周期的影响。'
- en: '**Pitfall 6 – using** **b.N incorrectly**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**陷阱 6 – 错误地使用** **b.N**'
- en: The misuse of the `b.N` argument in Go benchmarks can lead to inaccurate results
    and misinterpretations. There are at least two common scenarios where `b.N` is
    misused, each with its pitfalls. Let’s explore them in detail.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Go 基准测试中 `b.N` 的误用可能导致不准确的结果和误解。至少有两种常见的场景中 `b.N` 被误用，每种都有其陷阱。让我们详细探讨它们。
- en: 'In some cases, developers might attempt to misuse `b.N` within a recursive
    function in a benchmark. This can lead to unexpected behavior and inaccurate measurements.
    Here’s an example:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，开发者可能会尝试在基准测试中的递归函数内误用 `b.N`。这可能导致意外的行为和不准确的测量。以下是一个例子：
- en: '[PRE26]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this case, `b.N` is misused as an argument to the `recursiveFibonacci` recursive
    function. This misuse can lead to unexpected behavior and incorrect benchmark
    results.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`b.N` 被误用为 `recursiveFibonacci` 递归函数的参数。这种误用可能导致意外的行为和不正确的基准测试结果。
- en: 'Also, developers might misuse `b.N` when their benchmark code involves complex
    setup or initialization that should not be repeated for each iteration. Here’s
    an example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当基准测试代码涉及复杂的设置或初始化，而这些设置或初始化不应该为每个迭代重复时，开发者可能会误用 `b.N`。以下是一个例子：
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this scenario, `b.N` is misused to repeatedly execute the setup code within
    the benchmark loop. This can skew benchmark results if the setup is intended to
    be performed only once.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`b.N` 被误用来在基准测试循环中重复执行设置代码。如果设置只打算执行一次，这可能会扭曲基准测试结果。
- en: 'Lastly, developers might misuse `b.N` within benchmarks that involve conditional
    logic based on the iteration count. Let’s look at an example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，开发者可能会在涉及迭代计数条件逻辑的基准测试中误用 `b.N`。让我们来看一个例子：
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this case, `b.N` is misused to conditionally execute different code paths
    based on the iteration count. This can lead to inconsistent benchmark results
    and make it challenging to interpret performance measurements.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`b.N` 被误用来根据迭代次数有条件地执行不同的代码路径。这可能导致基准测试结果不一致，并使性能测量难以解释。
- en: In conclusion, benchmarking in Go – or any language, for that matter – is less
    about the raw pursuit of speed and more about the art of making informed decisions.
    It’s like navigating a ship through treacherous waters; without a compass (benchmarks)
    and a skilled navigator (the developer), you’re just drifting, hoping to reach
    your destination.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，在 Go 中进行基准测试——或者任何语言，实际上——更多的是关于做出明智决策的艺术，而不是对速度的原始追求。这就像在危险水域中驾驶船只；没有指南针（基准测试）和熟练的领航员（开发者），你只是在漂泊，希望到达目的地。
- en: The real skill lies not in how fast you can go, but in knowing where to make
    the turns.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的技巧不在于你能多快，而在于知道在哪里转弯。
- en: CPU profiling
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CPU 性能分析
- en: 'CPU profiling is the process of analyzing how much CPU time is consumed by
    different sections of your Go program. This analysis helps you identify the following
    aspects:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 性能分析是分析你的 Go 程序不同部分消耗了多少 CPU 时间的流程。这种分析帮助你识别以下方面：
- en: '**Bottlenecks**: Code areas using excessive CPU time, slowing down your application'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**瓶颈**：使用过多 CPU 时间、减慢应用程序速度的代码区域'
- en: '**Inefficiencies**: Functions or code blocks that can be optimized to use less
    CPU resources'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低效之处**：可以优化以使用更少 CPU 资源的函数或代码块'
- en: '**Hotspots**: The most frequently executed parts of your program, the prime
    focus for optimization'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**热点**：程序中最频繁执行的部分，优化的主要焦点'
- en: To exercise profiling, we’ll create a **file change monitor**. The program will
    monitor a specified directory for file changes. To make the scope concise, our
    program will detect file creation, deletion, and modification. Also, upon detecting
    changes, it sends alerts (printed to the console).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习性能分析，我们将创建一个 **文件更改监控器**。程序将监控指定的目录以检测文件更改。为了使范围简洁，我们的程序将检测文件创建、删除和修改。此外，在检测到更改时，它还会发送警报（打印到控制台）。
- en: 'The complete code can be found in this book’s GitHub repository. For now, we
    are exploring the core features and the corresponding code sections so that we
    have a clearer understanding of how it operates:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在本书的 GitHub 仓库中找到。目前，我们正在探索核心功能和相应的代码部分，以便我们更清楚地了解其工作原理：
- en: 'First, define the file metadata structure:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，定义文件元数据结构：
- en: '[PRE29]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This struct defines the simplified file metadata the program will track, including
    the file’s name, modification time, and size. This is crucial for comparing the
    current state of the filesystem to a previous state to detect changes.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个结构定义了程序将跟踪的简化文件元数据，包括文件的名称、修改时间和大小。这对于将文件系统的当前状态与之前的状态进行比较以检测更改至关重要。
- en: 'Scan the directory:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扫描目录：
- en: '[PRE30]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `scanDirectory` function uses `filepath.WalkDir` to traverse the directory
    and subdirectories, collecting metadata for each file and storing it in a map.
    This map serves as a snapshot of the directory’s state at the time of scanning.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`scanDirectory` 函数使用 `filepath.WalkDir` 遍历目录及其子目录，收集每个文件的元数据并将其存储在一个映射中。这个映射充当了扫描时目录状态的快照。'
- en: 'Compare directory states:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较目录状态：
- en: '[PRE31]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `compareAndEmitEvents` function iterates through the new and old state maps
    to find differences, which indicate file creations, deletions, or modifications.
    For each detected change, it calls `sendAlert` using a goroutine, which allows
    these alerts to be processed asynchronously.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`compareAndEmitEvents` 函数遍历新旧状态映射以查找差异，这些差异表明文件创建、删除或修改。对于每个检测到的更改，它使用 goroutine
    调用 `sendAlert`，这允许这些警报异步处理。'
- en: 'Emit alerts:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送警报：
- en: '[PRE32]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This function is responsible for handling the alerts. In the current implementation,
    it simply prints the alert to the console. Running this in a separate goroutine
    for each alert ensures that the directory scanning and comparison process is not
    blocked by the alerting mechanism.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个函数负责处理警报。在当前实现中，它只是将警报打印到控制台。为每个警报在单独的 goroutine 中运行确保目录扫描和比较过程不会被警报机制阻塞。
- en: 'Main monitoring loop:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主要监控循环：
- en: '[PRE33]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the `main()` function, the directory is initially scanned to establish a
    baseline state. The program then enters a loop, rescanning the directory at specified
    intervals, comparing the new scan results to the previous state, and updating
    the state for the next iteration. This loop continues indefinitely until the program
    is stopped.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，目录最初被扫描以建立基线状态。然后程序进入一个循环，在指定的时间间隔内重新扫描目录，将新的扫描结果与之前的状态进行比较，并为下一次迭代更新状态。这个循环无限期地继续，直到程序被停止。
- en: 'Goroutine usage for alerts: The asynchronous execution of `sendAlert` via go
    `sendAlert(...)` inside `compareAndEmitEvents` ensures that the program remains
    responsive and that the monitoring interval is consistent, even if the alerting
    process has latency.'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Goroutine 用于警报：通过在 `compareAndEmitEvents` 中的 go `sendAlert(...)` 内异步执行 `sendAlert`，确保程序保持响应性，监控间隔保持一致，即使警报过程有延迟。
- en: 'Error handling: Error handling is demonstrated in both the scanning and main
    loop portions of the code, ensuring that the program can gracefully handle issues
    that are encountered during directory scanning. However, detailed error handling
    (especially for real-world applications) would involve more comprehensive checks
    and responses to various error conditions.'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误处理：代码的扫描和主要循环部分都展示了错误处理，确保程序能够优雅地处理在目录扫描过程中遇到的问题。然而，详细的错误处理（尤其是对于实际应用）将涉及更全面的检查和对各种错误条件的响应。
- en: 'To enable CPU profiling, we need to change our program. First, add the following
    import:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用CPU分析，我们需要更改我们的程序。首先，添加以下导入：
- en: '[PRE34]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This imports the `pprof` package from the Go runtime, which provides functions
    for collecting and writing profiling data.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这从 Go 运行时导入 `pprof` 包，该包提供了收集和写入配置文件数据的函数。
- en: 'Now, we can use the package:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这个包：
- en: '[PRE35]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here’s what each line does:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是每行的作用：
- en: '`os.Create("cpuprofile.out")`: This line creates a file named `cpuprofile.out`
    where the CPU profile data will be written. This file is created in the current
    working directory of the application.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.Create("cpuprofile.out")`：这一行创建了一个名为 `cpuprofile.out` 的文件，CPU配置文件数据将被写入该文件。该文件在应用程序的当前工作目录中创建。'
- en: '`defer f.Close()`: This line ensures that the file is closed when the function
    returns. This is important to guarantee that all data is flushed to disk and the
    file is closed properly. Here, `defer` is used to schedule the close operation
    to run after the function completes, which includes normal completion or if an
    error causes an early return.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defer f.Close()`: 这行代码确保在函数返回时关闭文件。这很重要，以保证所有数据都刷新到磁盘，并且文件被正确关闭。在这里，`defer`用于安排关闭操作在函数完成后运行，包括正常完成或由于错误导致提前返回。'
- en: '`pprof.StartCPUProfile(f)`: This line starts the CPU profiling process. It
    takes `io.Writer` as an argument (in this case, the file we created earlier) and
    begins recording CPU profile data. All the CPU that’s used by your application
    from this point until `pprof.StopCPUProfile()` is called will be recorded.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pprof.StartCPUProfile(f)`: 这行代码启动CPU分析过程。它接受`io.Writer`作为参数（在这种情况下，我们之前创建的文件）并开始记录CPU分析数据。从这一点开始直到调用`pprof.StopCPUProfile()`，应用程序使用的所有CPU都将被记录。'
- en: '`defer pprof.StopCPUProfile()`: This line schedules when CPU profiling should
    stop – that is, when the function returns. This ensures that profiling is concluded
    properly, and all collected data is written to the specified file before the application
    exits or moves on to subsequent operations. The use of `defer` is critical here
    to ensure that profiling is stopped even if an error occurs, or a return is triggered
    earlier in your code.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defer pprof.StopCPUProfile()`: 这行代码安排了CPU分析何时停止——即函数返回时。这确保了分析能够正确完成，并且所有收集到的数据在应用程序退出或进行后续操作之前都写入指定的文件。在这里使用`defer`是至关重要的，以确保即使在代码中发生错误或提前触发返回时，分析也能停止。'
- en: 'Now, we can build the program by executing the following command:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过执行以下命令来构建程序：
- en: '[PRE36]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Execute the program, ensuring it monitors an active directory (where you’ll
    simulate file changes):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 执行程序，确保它监控一个活动目录（你将在其中模拟文件更改）：
- en: '[PRE37]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'While the program runs, introduce changes in the monitored directory: create
    files, delete files, and modify content within those files. This creates a realistic
    workload for profiling.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，在监控的目录中引入更改：创建文件、删除文件，以及修改这些文件中的内容。这为分析创建了一个现实的工作负载。
- en: After running your program with CPU profiling enabled, you can analyze the `cpuprofile.out`
    file using Go’s `pprof` tool to view the profiling results and identify hotspots
    in your code. This step is crucial for performance tuning and ensuring your application
    runs efficiently.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用CPU分析后运行你的程序，你可以使用Go的`pprof`工具来分析`cpuprofile.out`文件，查看分析结果并识别代码中的热点。这一步对于性能调整和确保应用程序高效运行至关重要。
- en: 'There are two main options on how to analyze the `cpuprofile.out` file: textually
    and via a flame graph.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 分析`cpuprofile.out`文件有两种主要方法：文本方式和火焰图。
- en: 'To analyze the profile textually, run the following command:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要以文本方式分析配置文件，请运行以下命令：
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You should see an output similar to the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下类似的输出：
- en: '[PRE39]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This result lists functions sorted in descending order of CPU time consumed.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此结果按CPU消耗时间降序排列函数。
- en: From this, we can interpret that we can focus on the top few entries. These
    are the primary candidates for optimization. Also, examine call stacks. They show
    how those expensive functions are reached within your program’s logic.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以解读出我们可以关注前几个条目。这些是优化的主要候选者。同时，检查调用栈。它们显示了那些昂贵的函数是如何在程序逻辑中达到的。
- en: 'To analyze the profile using a flame graph, run the following command:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用火焰图分析配置文件，请运行以下命令：
- en: '[PRE40]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This method provides a visual way to pinpoint hotspots. Wider bars represent
    functions that use more CPU time.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法提供了一种视觉化的方式来定位热点。较宽的柱状图代表使用更多CPU时间的函数。
- en: 'You should keep the following points in mind:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意以下要点：
- en: '**Width of bars**: This represents the proportion of CPU time spent within
    a function. Wider bars mean more time consumed.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**柱状图的宽度**：这表示在函数内花费的CPU时间的比例。较宽的柱状图意味着消耗了更多的时间。'
- en: '**Hierarchy**: This shows the call stacks. Functions that call other functions
    are stacked on top.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层次结构**：这显示了调用栈。调用其他函数的函数堆叠在顶部。'
- en: '**Top-down**: Start analyzing from the top of the graph, following the paths
    where the bars are widest.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自上而下**：从图表的顶部开始分析，沿着柱状图最宽的路径进行。'
- en: Before we start to change the program to see the results in the profile, let’s
    learn how to memory profile this program to make the trade-offs between memory
    and CPU clear after making future improvements.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始更改程序以在配置文件中查看结果之前，让我们学习如何对程序进行内存分析，以便在未来的改进后明确内存和CPU之间的权衡。
- en: Memory profiling
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存分析
- en: 'Memory profiling helps you analyze how your Go program allocates and uses memory.
    It’s critical in systems programming. where you frequently deal with constrained
    resources and performance-sensitive operations. Here are some key questions it
    helps answer:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分析有助于你分析你的Go程序如何分配和使用内存。在系统编程中至关重要，因为你经常处理受限的资源和高性能操作。以下是一些它帮助回答的关键问题：
- en: '**Memory leaks**: Are you unintentionally holding on to memory that’s no longer
    needed?'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存泄漏**：你是否无意中保留了不再需要的内存？'
- en: '**Allocation hotspots**: Which functions or code blocks are responsible for
    most allocations?'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存分配热点**：哪些函数或代码块负责了大部分的内存分配？'
- en: '**Memory usage patterns**: How does memory use change over time, especially
    under different load conditions?'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存使用模式**：内存使用是如何随时间变化的，尤其是在不同的负载条件下？'
- en: '**Object sizes**: How can you understand the memory footprint of key data structures?'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象大小**：你如何理解关键数据结构的内存占用？'
- en: 'Let’s learn how to set up memory profiling for our monitoring program based
    on the following snippet:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们根据以下片段学习如何为我们的监控程序设置内存分析：
- en: '[PRE41]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let’s understand what’s happening here:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解这里发生了什么：
- en: '`os.Create("memprofile.out")`: This line creates a file named `memprofile.out`
    in the current working directory. This file is designated to store the memory
    profile data.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.Create("memprofile.out")`: 这行代码在当前工作目录中创建了一个名为`memprofile.out`的文件。这个文件被指定用于存储内存配置文件数据。'
- en: '`defer f.Close()`: This line schedules the `Close` method on `f` to be called
    once the surrounding function (main) returns. This is to ensure the file is closed
    properly and all data written to it is flushed to disk, regardless of how the
    function exits (normally or due to an error).'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defer f.Close()`: 这行代码安排在周围函数（main）返回时调用`f`的`Close`方法。这是为了确保文件被正确关闭，并且所有写入的数据都被刷新到磁盘，无论函数是如何退出的（正常或由于错误）。'
- en: '`runtime.GC()`: This line is optional and triggers garbage collection before
    writing the heap profile. Its purpose is to clean up unused memory and provide
    a more accurate view of what memory is actively in use by your program at the
    time of profiling. It helps in identifying memory that is truly needed by your
    program as opposed to memory that is ready to be collected but hasn’t been yet.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runtime.GC()`: 这行代码是可选的，并在写入堆配置文件之前触发垃圾回收。其目的是清理未使用的内存，并提供一个更准确的视图，显示在分析时程序正在积极使用的内存。它有助于识别程序真正需要的内存，而不是那些准备被回收但尚未回收的内存。'
- en: '`pprof.WriteHeapProfile(f)`: This line writes the memory profile data to the
    previously created file. This profile includes information about memory allocation
    by your program, which can be analyzed to understand memory usage patterns and
    identify potential issues, such as memory leaks.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pprof.WriteHeapProfile(f)`: 这行代码将内存配置文件数据写入之前创建的文件。这个配置文件包括关于程序内存分配的信息，可以分析以了解内存使用模式并识别潜在问题，如内存泄漏。'
- en: 'We can build and run the program again, but this time, after simulating the
    workload, we’ll have a new file: `memprofile.out`.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次构建和运行程序，但这次，在模拟工作负载之后，我们将有一个新的文件：`memprofile.out`。
- en: 'We can analyze this file textually by executing the following command:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行以下命令来对文件文本进行分析：
- en: '[PRE42]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Focus on functions that are allocating large amounts of memory or holding on
    to it for extended periods.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 关注分配大量内存或长时间持有内存的函数。
- en: 'We can also use the web-based view by executing the following command:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过执行以下命令来使用基于网页的查看：
- en: '[PRE43]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that we now have a flame graph variant. Like CPU flame graphs, instead
    of bar width representing time, it represents memory allocation.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们现在有一个火焰图变体。像CPU火焰图一样，火焰图的宽度不是代表时间，而是代表内存分配。
- en: It’s recommended to start from the top and identify areas with heavy memory
    usage.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 建议从顶部开始，识别内存使用量大的区域。
- en: 'In our program, we have key areas to watch:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序中，我们有几个关键区域需要关注：
- en: '`scanDirectory`: How much memory is allocated to build `map[string]FileInfo`?
    This grows with directory size.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scanDirectory`: 构建用于存储`map[string]FileInfo`的内存分配了多少？这会随着目录大小的增加而增长。'
- en: '`compareAndEmitEvents`: Is memory usage heavily affected by the frequency of
    file changes, or is the memory footprint of the comparison logic itself a concern?'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compareAndEmitEvents`：内存使用是否受到文件更改频率的严重影响，或者比较逻辑本身的内存占用是否是一个问题？'
- en: '`FileInfo`: If you deal with very large files or long file paths, the size
    of your `FileInfo` struct might matter.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileInfo`：如果您处理非常大的文件或很长的文件路径，您的 `FileInfo` 结构的大小可能很重要。'
- en: Profiling memory over time
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随时间分析内存
- en: 'To get a better picture of potential memory leaks or growth, do the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解潜在的内存泄漏或增长，请执行以下操作：
- en: Modify your code so that you can write heap profiles at intervals within the
    monitoring loop
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改您的代码，以便您可以在监控循环中每隔一段时间写入堆配置文件
- en: Compare profiles to see if objects remain allocated unexpectedly, implying a
    potential leak-like scenario
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较配置文件以查看是否有对象意外保留分配，这暗示了潜在的泄漏场景
- en: Preparing to explore the trade-offs
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备探索权衡
- en: To explore the results of our profiling techniques, let’s introduce a simple
    caching feature.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索我们的分析技术结果，让我们引入一个简单的缓存功能。
- en: 'We should capture this before introducing any caching. After that, we can design
    our caching mechanism. Let’s consider the following aspects:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入任何缓存之前，我们应该捕捉这一点。之后，我们可以设计我们的缓存机制。让我们考虑以下方面：
- en: '**Eviction policy**: How do you remove old data when the cache reaches a size
    limit?'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**驱逐策略**：当缓存达到大小限制时，您如何删除旧数据？'
- en: '**Profile with caching**: Analyze the new memory profile.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**带有缓存的配置文件**：分析新的内存配置文件。'
- en: '`scanDirectory` decrease?'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scanDirectory` 减少？'
- en: '**New bottlenecks**: Did the cache itself become a significant memory consumer?'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**新的瓶颈**：缓存本身是否成为了一个重要的内存消费者？'
- en: Simple caching
  id: totrans-305
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 简单缓存
- en: 'Here’s our implementation of the simple caching mechanism, step by step:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们对简单缓存机制的实现，一步一步来：
- en: 'Global cache declaration:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 全局缓存声明：
- en: '[PRE44]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: A global variable called `cachedDirectoryState` is declared to store the cached
    state of the directory. This map holds `FileInfo` structures indexed by their
    file paths. Declaring it globally allows the cache to persist across multiple
    calls to the `scanDirectory` function, enabling reuse of previously gathered data.
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 声明了一个名为 `cachedDirectoryState` 的全局变量来存储目录的缓存状态。这个映射以文件路径为索引，持有 `FileInfo` 结构。将其声明为全局变量允许缓存在多次调用
    `scanDirectory` 函数之间持续存在，从而实现之前收集数据的重用。
- en: 'Cache check in `scanDirectory`:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `scanDirectory` 中的缓存检查：
- en: '[PRE45]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Before performing the filesystem walk, the function checks if there is an existing
    cache (`cachedDirectoryState`). If the cache is not `nil`, meaning it has been
    populated from a previous scan, it copies the cached `FileInfo` entries into the
    results map. This step ensures that the function starts with data from the last
    scan, potentially reducing the amount of work needed if many files remain unchanged.
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在执行文件系统遍历之前，该函数检查是否存在现有的缓存（`cachedDirectoryState`）。如果缓存不是 `nil`，这意味着它已经从之前的扫描中被填充，它将缓存的
    `FileInfo` 条目复制到结果映射中。这一步确保函数从上一次扫描的数据开始，如果许多文件保持不变，可能会减少所需的工作量。
- en: 'Cache update after scanning:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扫描后的缓存更新：
- en: '[PRE46]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As the directory is walked and each file is processed, the `results` map is
    updated with the latest `FileInfo` for each path. Unlike the initial cache check,
    this update occurs inside the `filepath.WalkDir` call, ensuring that the most
    current information is captured. After processing each file, the entire `cachedDirectoryState`
    is replaced with the current results. This means the cache is always reflective
    of the most recent state of the directory, as determined by the last scan.
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在遍历目录并处理每个文件时，`results` 映射会更新为每个路径的最新 `FileInfo`。与初始缓存检查不同，此更新发生在 `filepath.WalkDir`
    调用内部，确保捕获最当前的信息。处理完每个文件后，整个 `cachedDirectoryState` 被替换为当前结果。这意味着缓存始终反映了目录的最新状态，这是由最后一次扫描确定的。
- en: Caveat
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项
- en: This caching strategy might introduce stale data issues if files are changed,
    added, or removed between scans, and the program relies on the cache without revalidating
    it. To mitigate this, you might consider strategies for invalidating or updating
    the cache based on certain triggers or after a predefined interval.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在扫描之间文件被更改、添加或删除，并且程序依赖于缓存而不重新验证它，这种缓存策略可能会引入过时数据问题。为了减轻这个问题，你可能需要考虑基于某些触发器或在预定义间隔后使缓存无效或更新的策略。
- en: A production-ready cache likely would need a size limit and an eviction strategy
    (such as **least recently** **used** (**LRU**).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 一个生产就绪的缓存可能需要一个大小限制和驱逐策略（例如**最近最少使用**（LRU））。
- en: Now, it’s time for you to repeat the memory and CPU analyses to identify how
    the program’s behavior changed. Ensure you provide another name for the profile
    results so that you don’t override them!
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是你重复进行内存和CPU分析以确定程序行为如何变化的时候了。确保你为配置文件结果提供另一个名称，以免覆盖它们！
- en: From a CPU perspective, have you noticed the top CPU-consuming functions change
    their order? Also, did specific functions see significant increases or decreases
    in CPU time percentage?
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 从CPU的角度来看，你是否注意到消耗CPU最多的函数的顺序发生了变化？此外，是否有特定的函数在CPU时间百分比上出现了显著的增加或减少？
- en: Hopefully, you should see reduced CPU time within `scanDirectory`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你在`scanDirectory`中看到CPU时间有所减少。
- en: From a memory perspective, have you noticed the top-allocating functions change?
    Did specific functions increase or decrease their allocation volume significantly?
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 从内存的角度来看，你是否注意到分配最多的函数发生了变化？是否有特定的函数显著增加了或减少了它们的分配量？
- en: Expect increased memory usage due to the cache itself. Analyze whether this
    trade-off is acceptable for the performance gains. The core idea of profiling
    your programs is to ideally change only one aspect of your code or workload at
    a time for a clearer comparison.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缓存本身，预期内存使用量会增加。分析这种权衡是否值得为了性能提升。对程序进行性能分析的核心思想是理想情况下一次只改变代码或工作负载的一个方面，以便进行更清晰的比较。
- en: With that, we’ve evaluated our application through CPU and memory profile data.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 通过CPU和内存配置文件数据，我们已经评估了我们的应用程序。
- en: Summary
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we have explored the core aspects of performance analysis
    within Go, providing an understanding of how Go’s memory management mechanisms
    work and how they can be optimized for better application performance. Key concepts
    such as escape analysis, the roles of stack and pointers, and the distinctions
    between stack and heap memory allocations were thoroughly examined.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Go语言中性能分析的核心方面，提供了对Go语言内存管理机制如何工作以及如何优化以获得更好的应用程序性能的理解。关键概念，如逃逸分析、栈和指针的作用，以及栈和堆内存分配的区别都得到了彻底的考察。
- en: As we turn the page from the intricacies of memory management and performance
    optimization, the next chapter invites us into the expansive world of networking
    in Go.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们翻过内存管理和性能优化的复杂性，下一章将引领我们进入Go语言中广阔的网络世界。
- en: 'Part 4: Connected Apps'
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四部分：连接的应用程序
- en: In this part, we will explore other topics in the Go programming development
    ecosystem, focusing on networking, telemetry, and application distribution. This
    section will equip you with in-depth knowledge and practical skills to enhance
    your Go applications’ observability, connectivity, and distribution.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们将探讨Go编程开发生态系统中的一些其他主题，重点关注网络、遥测和应用分发。本节将为你提供深入的知识和实用的技能，以增强你的Go应用程序的可观察性、连接性和分发能力。
- en: 'This part has the following chapters:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 10*](B21662_10.xhtml#_idTextAnchor211), *Networking*'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B21662_10.xhtml#_idTextAnchor211), *网络*'
- en: '[*Chapter 11*](B21662_11.xhtml#_idTextAnchor224), *Telemetry*'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B21662_11.xhtml#_idTextAnchor224), *遥测*'
- en: '[*Chapter 12*](B21662_12.xhtml#_idTextAnchor240), *Distributing Apps*'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B21662_12.xhtml#_idTextAnchor240), *分发应用程序*'
