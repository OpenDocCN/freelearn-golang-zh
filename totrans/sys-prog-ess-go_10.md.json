["```go\npackage main\nimport (\n  \"fmt\"\n  \"io\"\n  \"net/http\"\n)\nfunc main() {\n  url := \"https://pokeapi.co/api/v2/pokemon/ditto\"\n  client := &http.Client{}\n  resp, err := client.Get(url)\n  if err != nil {\n    fmt.Printf(\"Error: %v\\n\", err)\n  }\n  defer resp.Body.Close()\n  body, err := io.ReadAll(resp.Body)\n  if err != nil {\n    fmt.Printf(\"Error: %v\\n\", err)\n  }\n  fmt.Println(resp.StatusCode)\n  fmt.Println(string(body))\n}\n```", "```go\npackage main\nimport (\n  \"fmt\"\n  \"net\"\n)\nfunc main() {\n  // Start listening for connections\n  listener, err := net.Listen(\"tcp\", \":8080\")\n  if err != nil {\n    fmt.Printf(\"Error: %v\\n\", err)\n  }\n  // Accept connections in a loop\n  for {\n    conn, err := listener.Accept()\n    if err != nil {\n      continue\n    }\n    go handleConnection(conn)\n  }\n}\nfunc handleConnection(conn net.Conn) {\n  defer conn.Close()\n  buf := make([]byte, 1024)\n  for {\n    n, err := conn.Read(buf)\n    if err != nil {\n      break\n    }\n    _, err = conn.Write(buf[:n])\n    if err != nil {\n      fmt.Printf(\"write error: %v\\n\", err)\n    }\n  }\n}\n```", "```go\npackage main\nimport (\n     \"fmt\"\n     \"net/http\"\n)\nfunc handler(w http.ResponseWriter, r *http.Request) {\n     fmt.Fprintf(w, \"Hello, you've requested: %s\\n\", r.URL.Path)\n}\nfunc main() {\n     http.HandleFunc(\"/\", handler)\n     http.ListenAndServe(\":8080\", nil)\n}\n```", "```go\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    switch r.Method {\n    case http.MethodGet:\n        fmt.Fprintf(w, \"Handling a GET request\\n\")\n    case http.MethodPost:\n        fmt.Fprintf(w, \"Handling a POST request\\n\")\n    case http.MethodPut:\n        fmt.Fprintf(w, \"Handling a PUT request\\n\")\n    case http.MethodDelete:\n        fmt.Fprintf(w, \"Handling a DELETE request\\n\")\n    default:\n        http.Error(w, \"Unsupported HTTP method\", http.StatusMethodNotAllowed)\n    }\n}\n```", "```go\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    if r.URL.Path != \"/\" {\n        http.Error(w, \"404 Not Found\", http.StatusNotFound)\n        return\n    }\n    if r.Method != http.MethodGet {\n        http.Error(w, \"Method is not supported.\", http.StatusMethodNotAllowed)\n        return\n    }\n    fmt.Fprintf(w, \"Hello, World!\")\n}\n```", "```go\npackage main\nimport (\n     \"fmt\"\n     \"net/http\"\n)\nfunc main() {\n     http.HandleFunc(\"/\", homeHandler)\n     http.HandleFunc(\"/resource\", resourceHandler)\n     fmt.Println(\"Server starting on port 8080...\")\n     http.ListenAndServe(\":8080\", nil)\n}\nfunc homeHandler(w http.ResponseWriter, r *http.Request) {\n     fmt.Fprintf(w, \"Welcome to the HTTP verbs and status codes example!\")\n}\nfunc resourceHandler(w http.ResponseWriter, r *http.Request) {\n     switch r.Method {\n     case \"GET\":\n          // Handle GET request\n          w.WriteHeader(http.StatusOK) // 200\n          fmt.Fprintf(w, \"Resource fetched successfully\")\n     case \"POST\":\n          // Handle POST request\n          w.WriteHeader(http.StatusCreated) // 201\n          fmt.Fprintf(w, \"Resource created successfully\")\n     case \"PUT\":\n          // Handle PUT request\n          w.WriteHeader(http.StatusAccepted) // 202\n          fmt.Fprintf(w, \"Resource updated successfully\")\n     case \"DELETE\":\n          // Handle DELETE request\n          w.WriteHeader(http.StatusNoContent) // 204\n     default:\n          // Handle unknown methods\n          w.WriteHeader(http.StatusMethodNotAllowed) // 405\n          fmt.Fprintf(w, \"Method not allowed\")\n     }\n}\n```", "```go\n    openssl version\n    ```", "```go\n         choco install openssl\n        ```", "```go\n    openssl version\n    ```", "```go\n        /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n        ```", "```go\n         brew install openssl\n        ```", "```go\n        brew upgrade openssl\n        ```", "```go\n    openssl version\n    ```", "```go\n    sudo apt-get update\n    ```", "```go\n    sudo apt-get install openssl\n    ```", "```go\nopenssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365\n```", "```go\npackage main\nimport (\n     \"log\"\n     \"net/http\"\n)\nfunc handler(w http.ResponseWriter, r *http.Request) {\n     w.Write([]byte(\"Hello, TLS!\"))\n}\nfunc main() {\n     http.HandleFunc(\"/\", handler)\n     log.Println(\"Starting server on https://localhost:8443\")\n     err := http.ListenAndServeTLS(\":8443\", \"cert.pem\", \"key.pem\", nil)\n     if err != nil {\n          log.Fatalf(\"Failed to start server: %v\", err)\n     }\n}\n```", "```go\nopenssl genrsa -out mydomain.key 2048\n```", "```go\nopenssl req -new -key mydomain.key -out mydomain.csr\n```", "```go\nopenssl x509 -req -days 365 -in mydomain.csr -signkey mydomain.key -out mydomain.crt\n```", "```go\npackage main\nimport (\n    «crypto/tls\"\n    «net»\n)\nfunc main() {\n    cert, err := tls.LoadX509KeyPair(«server.crt», «server.key\")\n    if err != nil {\n        panic(err)\n    }\n    config := &tls.Config{Certificates: []tls.Certificate{cert}}\n    listener, err := tls.Listen(\"tcp\", \":8443\", config)\n    if err != nil {\n        panic(err)\n    }\n    // ... rest of our server logic\n}\n```", "```go\nimport (\n     \"encoding/binary\"\n     \"fmt\"\n     \"math/rand\"\n     \"net\"\n     \"os\"\n     \"time\"\n)\n```", "```go\nconst (\n     maxDatagramSize = 1024\n     packetLossRate  = 0.2\n)\ntype Packet struct {\n     SeqNum  uint32\n     Payload []byte\n}\n```", "```go\nfunc main() {\n     addr, err := net.ResolveUDPAddr(\"udp\", \":5000\")\n     ...\n     conn, err := net.ListenUDP(\"udp\", addr)\n     ...\n     defer conn.Close()\n     ...\n}\n```", "```go\ngo func() {\n     buf := make([]byte, maxDatagramSize)\n     for {\n          n, addr, err := conn.ReadFromUDP(buf)\n          ...\n          receivedSeq, _ := unpackUint32(buf[:4])\n          ...\n          sendAck(conn, clientAddr, receivedSeq)\n     }\n}()\n```", "```go\nfor {\n     packet := &Packet{\n          SeqNum:  nextSeqNum,\n          Payload: []byte(\"Test Payload\"),\n     }\n     sendPacket(conn, clientAddr, packet)\n     ...\n}\n```", "```go\nfunc sendPacket(conn *net.UDPConn, addr *net.UDPAddr, packet *Packet) {\n     if addr == nil || addr.IP == nil {\n          return // No client to send to yet\n     }\n     buf := make([]byte, 4+len(packet.Payload))\n     binary.BigEndian.PutUint32(buf[:4], packet.SeqNum)\n     copy(buf[4:], packet.Payload)\n     // Simulate packet loss\n     if rand.Float32() > packetLossRate {\n          _, err := conn.WriteToUDP(buf, addr)\n          if err != nil {\n               fmt.Println(\"Error sending packet:\", err)\n          } else {\n               fmt.Printf(\"Sent: %d to %s\\n\", packet.SeqNum, addr.String())\n          }\n     } else {\n          fmt.Printf(\"Simulated packet loss, seq: %d\\n\", packet.SeqNum)\n     }\n}\n```", "```go\n    func sendAck(conn *net.UDPConn, addr *net.UDPAddr, seqNum uint32) {\n         ackPacket := make([]byte, 4)\n         binary.BigEndian.PutUint32(ackPacket, seqNum)\n         _, err := conn.WriteToUDP(ackPacket, addr)\n         if err != nil {\n              fmt.Println(\"Error sending ACK:\", err)\n         }\n    }\n    ```", "```go\n    func unpackUint32(buf []byte) (uint32, error) {\n         if len(buf) < 4 {\n              return 0, fmt.Errorf(\"buffer too short\")\n         }\n         return binary.BigEndian.Uint32(buf), nil\n    }\n    ```", "```go\n    func init() {\n         rand.Seed(time.Now().UnixNano())\n    }\n    ```", "```go\ngo install github.com/gobwas/ws@latest\n```", "```go\npackage main\nimport (\n     \"net/http\"\n     \"github.com/gobwas/ws\"\n     \"github.com/gobwas/ws/wsutil\"\n)\nfunc main() {\n     http.ListenAndServe(\":8080\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n          conn, _, _, err := ws.UpgradeHTTP(r, w)\n           . . .\n          go func() {\n               defer conn.Close()\n               for {\n                    msg, op, err := wsutil.ReadClientData(conn)\n                    if err != nil {\n                         . . .\n                    }\n                    err = wsutil.WriteServerMessage(conn, op, msg)\n                    if err != nil {\n                         . . .\n                    }\n               }\n          }()\n     }))\n}\n```", "```go\npackage main\nimport (\n     \"bufio\"\n     \"fmt\"\n     \"net\"\n     \"os\"\n     \"github.com/gobwas/ws\"\n     \"github.com/gobwas/ws/wsutil\"\n)\nfunc main() {\n      ctx := contexto.Background()\n     // Connect to the WebSocket server\n     conn, _, _, err := ws.DefaultDialer.Dial(ctx, \"ws://localhost:8080\")\n     if err != nil {\n          fmt.Printf(\"Error connecting to WebSocket server: %v\\n\", err)\n          return\n     }\n     defer conn.Close()\n     // Send a message to the server\n     message := []byte(\"Hello, server!\")\n     err = wsutil.WriteClientMessage(conn, ws.OpText, message)\n     if err != nil {\n          fmt.Printf(\"Error sending message: %v\\n\", err)\n          return\n     }\n     // Read the server's response\n     response, _, err := wsutil.ReadServerData(conn)\n     if err != nil {\n          fmt.Printf(\"Error reading response: %v\\n\", err)\n          return\n     }\n     fmt.Printf(\"Received from server: %s\\n\", response)\n     // Keep the client running until the user decides to exit\n     fmt.Println(\"Press 'Enter' to exit...\")\n     bufio.NewReader(os.Stdin).ReadBytes('\\n')\n}\n```", "```go\n go run client.go\n```", "```go\n<!DOCTYPE html>\n<html>\n<head>\n    <title>WebSocket Test</title>\n</head>\n<body>\n    <script src=\"img/websocket.js\"></script>\n</body>\n</html>\n```", "```go\ndocument.addEventListener('DOMContentLoaded', function() {\n    // Replace 'ws://localhost:8080' with the appropriate URL if your server is running on a different host or port\n    var ws = new WebSocket('ws://localhost:8080');\n    ws.onopen = function() {\n        console.log('Connected to the WebSocket server');\n        // Example: Send a message to the server once the connection is open\n        ws.send('Hello, server!');\n    };\n    ws.onmessage = function(event) {\n        // Log messages received from the server\n        console.log('Message from server:', event.data);\n    };\n    ws.onerror = function(error) {\n        // Handle any errors that occur\n        console.log('WebSocket Error:', error);\n    };\n    ws.onclose = function(event) {\n        // Handle the connection closing\n        console.log('WebSocket connection closed:', event);\n    };\n});\n```"]