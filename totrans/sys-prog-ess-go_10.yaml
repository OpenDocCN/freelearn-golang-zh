- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Networking
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络
- en: In this chapter, we embark on a practical journey through the intricacies of
    network programming in Go. It’s a realm where the simplicity of syntax meets the
    complexity of network communications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始一段通过Go语言网络编程复杂性的实际旅程。这是一个语法简单与网络通信复杂度相遇的领域。
- en: As we progress, you’ll gain a comprehensive understanding of how to leverage
    Go’s powerful standard library, specifically the `net` package, to build robust
    network-driven applications. From establishing **Transmission Control Protocol**
    (**TCP**) and **User Datagram Protocol** (**UDP**) connections to crafting nimble
    web servers and constructing chatty clients, this chapter serves as your guide
    to mastering network interactions in Go, empowering you with practical skills.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们不断前进，你将全面了解如何利用Go语言强大的标准库，特别是`net`包，来构建稳健的网络驱动应用程序。从建立**传输控制协议**（**TCP**）和**用户数据报协议**（**UDP**）连接到构建敏捷的Web服务器和构建健谈的客户端，本章是你的指南，帮助你掌握Go语言中的网络交互，赋予你实用的技能。
- en: 'The chapter will cover the following key topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下关键主题：
- en: The `net` package
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net`包'
- en: TCP sockets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP套接字
- en: HTTP servers and clients
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP服务器和客户端
- en: Securing the connection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保连接安全
- en: Advanced networking
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级网络
- en: By the end of this chapter, you will have learned about network programming.
    The topics covered include TCP sockets, TCP communication challenges, reliability,
    creating and handling HTTP servers and clients, and the complexities of securing
    connections with **Transport Layer Security** (**TLS**). This exploration is designed
    to provide you with the necessary technical skills for network programming in
    Go and deepen your understanding of network communications’ underlying principles
    and challenges.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解网络编程。涵盖的主题包括TCP套接字、TCP通信挑战、可靠性、创建和处理HTTP服务器和客户端，以及使用**传输层安全性**（**TLS**）确保连接的复杂性。这次探索旨在为你提供Go语言网络编程所需的必要技术技能，并加深你对网络通信基本原理和挑战的理解。
- en: The net package
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: net包
- en: Network programming in Go. Surely it can’t be that different from spitting out
    a boring old “Hello, World,” right? Wrong. Just because Go boasts a clean syntax
    like a well-maintained garden doesn’t mean the underlying network plumbing isn’t
    a bowl of spaghetti code after a particularly enthusiastic college hackathon.
    Buckle up, because we’re diving into a realm where connection resets lurk around
    every corner, and timeouts feel more personal than a passive-aggressive email
    from your boss.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言中的网络编程。当然，它不可能和输出一个无聊的“Hello, World”有什么不同，对吧？错。尽管Go拥有像精心维护的花园一样干净的语法，但这并不意味着底层的网络管道在一场特别热情的大学黑客马拉松之后不会变成一团乱麻。系好安全带，因为我们将深入一个领域，在这里连接重置潜伏在每一个角落，超时感觉比老板发来的被动攻击性邮件还要个人化。
- en: But fear not, weary programmer! Beneath the surface complexity lies a surprisingly
    powerful and elegant set of tools. Go’s standard library, specifically the `net`
    package, provides a robust suite of functionalities for building all sorts of
    network-driven applications. From crafting nimble web servers to constructing
    chatty clients, the `net` package serves as the foundation for crafting robust
    network interactions in Go.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但别担心，疲惫的程序员！在表面的复杂性之下，隐藏着一组出人意料强大而优雅的工具。Go的标准库，特别是`net`包，提供了一套强大的功能，用于构建各种网络驱动应用程序。从构建敏捷的Web服务器到构建健谈的客户端，`net`包是构建Go语言中稳健网络交互的基础。
- en: You’ll find functions for establishing connections (both TCP and UDP flavors!),
    working with data streams, and parsing network addresses. It’s the network Swiss
    Army knife, ready to tackle any communication challenge you throw its way.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现用于建立连接（包括TCP和UDP版本）的函数、处理数据流和解析网络地址的函数。它是网络瑞士军刀，随时准备应对你抛向它的任何通信挑战。
- en: 'Let’s peek at a simple example to illustrate this point. Here’s a basic program
    that connects to an open Pokémon API and prints the status code and response body:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的例子来说明这一点。这是一个基本的程序，它连接到一个开放的宝可梦API，并打印状态码和响应体：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This program showcases the fundamental building blocks of network programming
    in Go. We utilize the `http` package (built on top of the `net` package), establish
    a connection to a remote server, retrieve data, and close the connection gracefully.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序展示了Go语言网络编程的基本构建块。我们利用`http`包（建立在`net`包之上），连接到远程服务器，检索数据，并优雅地关闭连接。
- en: 'You might be thinking: This doesn’t seem too bad. And you’d be right – for
    fundamental interactions. But trust me – the actual depth of network programming
    becomes apparent when you start venturing into asynchronous operations, handling
    errors gracefully across distributed systems, and dealing with the inevitable
    network gremlins.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想：这看起来并不太糟糕。你是对的——对于基本交互来说是这样。但相信我——当你开始尝试异步操作、优雅地处理分布式系统中的错误以及应对不可避免的网络小恶魔时，网络编程的实际深度才会显现出来。
- en: 'Think of it like this: network programming is like writing a complex symphony
    for a global orchestra. It would be best if you managed individual instruments
    (sockets), ensured they played in harmony (protocols), and accounted for occasional
    dropped notes (network errors) – all while conducting the entire performance from
    a distance. It takes practice, patience, and a healthy dose of humor (mostly dark)
    to master the art.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下：网络编程就像为全球乐团编写复杂的交响乐。你需要管理个别乐器（套接字），确保它们和谐演奏（协议），并考虑到偶尔出现的错误音符（网络错误）——所有这些都要在远处指挥整个表演。这需要练习、耐心和一大剂量的幽默（主要是黑色幽默）来掌握这门艺术。
- en: TCP sockets
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP 套接字
- en: TCP is the reliable workhorse of the internet, ensuring packets arrive in the
    proper order, like a particularly obsessive-compulsive mail carrier. Don’t be
    fooled by its reputation for stability – TCP socket programming in Go can have
    you pull out your hair quickly. Sure, it offers the comforting illusion of a constant,
    reliable data stream. Still, under the hood, it’s a chaotic mosh pit of retransmissions,
    flow control, and enough acronyms to keep a government agency happy.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 是互联网上可靠的劳力车，确保数据包按正确顺序到达，就像一个特别强迫症的邮递员。不要被其稳定性的声誉所迷惑——在 Go 中进行 TCP 套接字编程可能会让你迅速抓狂。当然，它提供了令人安慰的恒定、可靠的数据流幻觉。然而，在底层，它是一个混乱的拥挤的舞池，充满了重传、流量控制和足够多的首字母缩略词，足以让政府机构满意。
- en: 'Picture this: TCP is like trying to converse coherently during a loud heavy
    metal concert. You’re screaming messages at each other (sending packets), desperately
    hoping the other person gets the gist amid the noise (network congestion). Occasionally,
    whole phrases get lost in the roar (dropped packets), and you must repeat yourself
    (retransmissions). There can be a better recipe for efficient communication.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下：TCP 就像在一场嘈杂的重金属音乐会上进行有意义的对话。你们互相尖叫着信息（发送数据包），绝望地希望对方能在噪音（网络拥塞）中抓住要点。偶尔，整个短语会在喧嚣中丢失（数据包丢失），你必须重复自己（重传）。可能会有更有效的通信方法。
- en: That’s where Go’s `net` package comes to rescue us again. It provides the tools
    to establish and manage TCP connections. Think of functions such as `net.Dial()`
    and `net.Listen()` as your trusty walkie-talkies for setting up a communication
    channel in the middle of a mosh pit.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Go 的 `net` 包再次拯救我们的地方。它提供了建立和管理 TCP 连接的工具。将 `net.Dial()` 和 `net.Listen()`
    等函数视为你在拥挤的舞池中设置通信渠道的可靠对讲机。
- en: 'Go lets you communicate over TCP connections using two primary abstractions:
    `net.Conn` and `net.Listener`. A `net.Conn` object represents a single TCP connection,
    while `net.Listener` waits around for incoming connection requests like a seasoned
    bouncer at an exclusive club.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Go 允许你使用两种主要抽象来通过 TCP 连接进行通信：`net.Conn` 和 `net.Listener`。一个 `net.Conn` 对象代表一个单一的
    TCP 连接，而 `net.Listener` 就像在一家高级俱乐部里经验丰富的保安一样，等待 incoming 连接请求。
- en: 'Let’s illustrate this with a classic `echo` `server` example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个经典的 `echo` 服务器示例来说明这一点：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s take a closer look at what is happening in this snippet:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这个片段中发生了什么：
- en: 'In the `handleConnection()` function, we have the following:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `handleConnection()` 函数中，我们有以下内容：
- en: '`defer conn.Close()` ensures that the connection is closed once the function
    returns, which is crucial for freeing up resources.'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defer conn.Close()` 确保在函数返回时关闭连接，这对于释放资源至关重要。'
- en: '`buf := make([]byte, 1024)` allocates a buffer of 1024 bytes to read data from
    the connection.'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buf := make([]byte, 1024)` 分配了一个 1024 字节的缓冲区，用于从连接中读取数据。'
- en: The `for` loop continuously reads data into `buf` using `conn.Read(buf)`. The
    number of bytes read and any error encountered is returned.
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 循环使用 `conn.Read(buf)` 不断地将数据读取到 `buf` 中。返回读取的字节数和遇到的任何错误。'
- en: If an error occurs during reading (for example, the client closes the connection),
    the loop breaks, effectively ending the function and closing the connection.
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在读取过程中发生错误（例如，客户端关闭连接），循环会中断，有效地结束函数并关闭连接。
- en: '`conn.Write(buf[:n])` writes the data back to the client. `buf[:n]` ensures
    that only the portion of the buffer that was filled with data is sent back.'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conn.Write(buf[:n])` 将数据写回客户端。`buf[:n]` 确保只发送已填充数据的缓冲区部分。'
- en: 'In the `main()` function, we have the following:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，我们有以下内容：
- en: '`net.Listen("tcp", ":8080")` tells the server to listen for incoming TCP connections
    on port 8080\. The function returns a `Listener` instance that can accept connections.'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net.Listen("tcp", ":8080")` 告诉服务器在端口 8080 上监听传入的 TCP 连接。该函数返回一个 `Listener`
    实例，它可以接受连接。'
- en: The `for` loop then continuously accepts new connections with `listener.Accept()`.
    This function blocks until a new connection is received.
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后 `for` 循环通过 `listener.Accept()` 持续接受新的连接。此函数会阻塞，直到接收到新的连接。
- en: If an error occurs while accepting a connection (unlikely in normal circumstances),
    the `if err != nil { continue }` loop simply continues to the next iteration,
    effectively ignoring the failed attempt.
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在接收连接时发生错误（在正常情况下不太可能），则 `if err != nil { continue }` 循环简单地继续到下一次迭代，实际上忽略了失败的尝试。
- en: 'For each successful connection, the following happens:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个成功的连接，以下事情会发生：
- en: The `handleConnection()` function is called in a new goroutine.
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在新的 goroutine 中调用 `handleConnection()` 函数。
- en: This allows the server to handle multiple connections concurrently, as each
    call to `handleConnection()` can run independently.
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这使得服务器能够同时处理多个连接，因为每次对 `handleConnection()` 的调用都可以独立运行。
- en: This example scratches the surface of TCP communication in Go. Notice how we
    handle errors and ensure connections are properly closed. It’s the little things
    that often trip you up, such as forgetting to close a connection and watching
    your resources drain away like sand through your fingers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子只是触及了 Go 中 TCP 通信的表面。注意我们如何处理错误并确保连接得到适当关闭。往往是这些小事情让你绊倒，比如忘记关闭连接，看着你的资源像沙子一样从指缝中溜走。
- en: 'Reflecting on my journey with TCP sockets, I recall a project where the client-server
    model was more like a love-hate relationship. Connections would drop at the most
    inopportune moments, and data packets played hide and seek. Through trial and
    error, I learned the importance of robust error handling and the art of setting
    appropriate timeouts. It was a humbling experience that taught me TCP sockets
    are like a game of chess with the network: always be prepared for an unexpected
    move.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我的 TCP 套接字之旅，我想起了一个项目，其中客户端-服务器模型更像是一种爱恨交加的关系。连接会在最不合适的时候断开，数据包玩捉迷藏。通过试错，我学会了稳健的错误处理和设置适当超时的重要性。这是一次令人谦卑的经历，它教会了我
    TCP 套接字就像网络中的棋局：总是要为意外的走法做好准备。
- en: To wrap up, think of TCP communication in Golang as crafting a fine cocktail.
    The ingredients (TCP fundamentals) must be measured with precision, mixed with
    care (establishing and handling connections), and served with flair (implementing
    a server and client). And just as with bartending, practice and patience are key.
    Cheers to your journey into the world of TCP sockets. May your connections be
    stable and your data flow smoothly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，将 Golang 中的 TCP 通信想象成调制一杯美酒。配料（TCP 基础知识）必须精确测量，小心混合（建立和处理连接），并以风趣的方式上桌（实现服务器和客户端）。就像调酒师一样，实践和耐心是关键。祝您在
    TCP 套接字世界的旅程愉快。愿您的连接稳定，数据流畅。
- en: HTTP servers and clients
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 服务器和客户端
- en: HTTP, the protocol that powers the web, is responsible for all those charming
    cat videos and questionable social media rabbit holes. You might be tempted to
    assume building web servers and clients in Go is a walk in the park – after all,
    we’re not dealing with the mind-bending intricacies of TCP sockets anymore, are
    we? Oh, sweet summer child, prepare to be humbled.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP，推动网络的协议，负责所有那些迷人的猫咪视频和可疑的社交媒体兔子洞。您可能会觉得在 Go 中构建 Web 服务器和客户端就像散步一样简单——毕竟，我们不再处理
    TCP 套接字的令人费解的复杂性，对吧？哦，甜蜜的夏日孩子，准备好感到谦卑吧。
- en: 'Picture this: HTTP is like trying to navigate a labyrinthine bureaucracy. You
    have rigid forms to fill (requests), specific departments to address (URLs), and
    a baffling array of status codes that could mean anything from “Sure, here’s your
    thing” to “Your paperwork has been accidentally shredded.” And just when you think
    you’ve got the hang of it, some obscure rule change (such as a protocol update)
    sends you spiraling back to square one.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下：HTTP就像是在迷宫般的官僚机构中导航。你需要填写固定的表格（请求），向特定的部门发送（URL），还要面对一系列令人困惑的状态码，这些状态码可能意味着从“当然，这是你要的东西”到“你的文件不小心被撕毁了。”而且当你以为你已经掌握了它的时候，一些微妙的规则变化（比如协议更新）会让你重新回到起点。
- en: Thankfully, Go’s standard library comes equipped with the `net/http` package
    – your trusty compass for navigating this bureaucratic nightmare. This package
    offers convenient tools for crafting both web servers and clients, letting you
    speak the language of HTTP fluently.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Go的标准库配备了`net/http`包——这是你在官僚噩梦中的可靠指南针。这个包提供了方便的工具来构建Web服务器和客户端，让你能够流利地说HTTP语言。
- en: Creating an HTTP server in Go is deceptively straightforward, thanks to the
    powerful yet simple `net/http` package. This package abstracts away much of the
    complexity involved in handling HTTP requests, allowing developers to focus on
    the logic of their applications rather than the underlying protocol mechanics.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中创建HTTP服务器看似简单，多亏了强大而简单的`net/http`包。这个包抽象掉了处理HTTP请求所涉及的大部分复杂性，使得开发者可以专注于应用程序的逻辑，而不是底层的协议机制。
- en: 'A basic HTTP server in Go is surprisingly simple to set up. Let’s look at how
    to do it:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中设置基本的HTTP服务器非常简单。让我们看看如何做到这一点：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This snippet defines a simple web server that listens on port 8080 and responds
    to any request with a friendly greeting. Think of `http.HandleFunc` as registering
    a clerk at a specific office within your bureaucratic institution, ready to handle
    incoming requests.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段定义了一个简单的Web服务器，它在8080端口上监听并响应任何请求，提供一个友好的问候。将`http.HandleFunc`视为在你的官僚机构中注册一个特定办公室的职员，准备处理传入的请求。
- en: HTTP verbs
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP动词
- en: HTTP verbs (also known as methods) and status codes are fundamental components
    of the HTTP protocol, used to define the action to be performed on a given resource
    and to indicate the outcome of HTTP requests, respectively. The `net/http` package
    in Go provides support for handling these aspects of HTTP. Let’s explore how HTTP
    verbs and status codes are used within the context of Go’s `net/http` package.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP动词（也称为方法）和状态码是HTTP协议的基本组成部分，分别用于定义对给定资源要执行的操作以及指示HTTP请求的结果。Go中的`net/http`包提供了处理这些HTTP方面支持。让我们探索如何在Go的`net/http`包的上下文中使用HTTP动词和状态码。
- en: 'HTTP verbs tell the server what action to perform on a resource. The most used
    HTTP verbs are the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP动词告诉服务器在资源上执行什么操作。最常用的HTTP动词如下：
- en: '`GET`: Requests data from a specified resource'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：从指定的资源请求数据'
- en: '`POST`: Submits data to be processed to a specified resource'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：将数据提交给指定的资源进行处理'
- en: '`PUT`: Updates a specified resource with provided data'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：使用提供的数据更新指定的资源'
- en: '`DELETE`: Deletes a specified resource'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：删除指定的资源'
- en: '`PATCH`: Applies partial modifications to a resource'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`：对资源应用部分修改'
- en: 'In Go, you can handle different HTTP verbs by checking the `Method` field of
    the `http.Request` object. Here’s an example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，你可以通过检查`http.Request`对象的`Method`字段来处理不同的HTTP动词。以下是一个示例：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: HTTP status codes
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP状态码
- en: 'HTTP status codes are issued by a server in response to a client’s request.
    They are grouped into five classes:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP状态码是由服务器在响应客户端请求时发出的。它们被分为五个类别：
- en: '**1xx (Informational)**: The request was received, continuing process'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1xx（信息性）**：请求已接收，继续处理'
- en: '**2xx (Success)**: The request was successfully received, understood, and accepted'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2xx（成功）**：请求已成功接收、理解并被接受'
- en: '**3xx (Redirection)**: Further action needs to be taken in order to complete
    the request'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3xx（重定向）**：为了完成请求需要采取进一步的操作'
- en: '**4xx (Client Error)**: The request contains bad syntax or cannot be fulfilled'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4xx（客户端错误）**：请求包含错误的语法或无法满足'
- en: '**5xx (Server Error)**: The server failed to fulfill an apparently valid request'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**5xx（服务器错误）**：服务器未能满足显然有效的请求'
- en: 'The `net/http` package includes constants for many of these status codes, making
    your code more readable – for example, `http.StatusOK` for `200`, `http.StatusNotFound`
    for `404`, and `http.StatusInternalServerError` for `500`. Here’s how you might
    use them:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/http` 包包含许多这些状态码的常量，使你的代码更易读——例如，`http.StatusOK` 对应 `200`，`http.StatusNotFound`
    对应 `404`，以及 `http.StatusInternalServerError` 对应 `500`。以下是你可以如何使用它们的示例：'
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: HTTP verbs (also known as methods) and status codes are fundamental components
    of the HTTP protocol, used to define the action to be performed on a given resource
    and to indicate the outcome of HTTP requests, respectively. The `net/http` package
    in Go provides support for handling these aspects of HTTP. Let’s explore how HTTP
    verbs and status codes are used within the context of Go’s `net/http` package.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP动词（也称为方法）和状态码是HTTP协议的基本组成部分，分别用于定义对给定资源的操作以及指示HTTP请求的结果。Go中的`net/http`包提供了处理这些HTTP方面支持。让我们探索在Go的`net/http`包的上下文中如何使用HTTP动词和状态码。
- en: Putting it all together
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有这些放在一起
- en: Combining the handling of different HTTP verbs with appropriate status codes
    allows you to build more complex and robust web applications.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将不同HTTP动词的处理与适当的状态码结合起来，可以使你构建更复杂和健壮的Web应用程序。
- en: 'Next is an example Go server code that demonstrates handling multiple HTTP
    verbs and returning some of the most common HTTP status codes using the `net/http`
    package. This server will have different endpoints to showcase how to handle `GET`,
    `POST`, `PUT`, and `DELETE` requests, along with sending appropriate HTTP status
    codes in responses:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个示例Go服务器代码，它展示了如何使用`net/http`包处理多个HTTP动词并返回一些最常见的HTTP状态码。此服务器将具有不同的端点，以展示如何处理`GET`、`POST`、`PUT`和`DELETE`请求，并在响应中发送适当的HTTP状态码：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this code, we have different uses for the HTTP methods (verbs), such as
    the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们对HTTP方法（动词）有不同的用法，例如以下内容：
- en: '`GET`: Used to request data from a specified resource'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`: 用于从指定资源请求数据'
- en: '`POST`: Used to send data to a server to create/update a resource'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`: 用于向服务器发送数据以创建或更新资源'
- en: '`PUT`: Used to send data to a server to create or update a resource'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`: 用于向服务器发送数据以创建或更新资源'
- en: '`DELETE`: Used to delete the specified resource'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`: 用于删除指定的资源'
- en: 'Also, when we return HTTP status codes, there is a specific meaning to each
    code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当我们返回HTTP状态码时，每个代码都有特定的含义：
- en: '`200 OK`: The request has succeeded'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`200 OK`: 请求已成功'
- en: '`201 Created`: The request has succeeded, and a new resource has been created
    as a result'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`201 已创建`: 请求已成功，并因此创建了一个新的资源'
- en: '`202 Accepted`: The request has been accepted for processing, but the processing
    has not been completed'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`202 已接受`: 请求已被接受进行处理，但处理尚未完成'
- en: '`204 No Content`: The server successfully processed the request but is not
    returning any content'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`204 无内容`: 服务器成功处理了请求，但没有返回任何内容'
- en: '`405 Method Not Allowed`: The request method is known by the server but has
    been disabled and cannot be used'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`405 方法不允许`: 服务器知道请求方法，但已禁用且无法使用'
- en: This server listens on port 8080 and routes requests to the appropriate handler
    based on the URL path. The `resourceHandler()` function checks the HTTP method
    of the request and responds with the corresponding status code and message.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务器监听8080端口，并根据URL路径将请求路由到适当的处理程序。`resourceHandler()`函数检查请求的HTTP方法，并返回相应的状态码和消息。
- en: Back in my early days, I spent hours debugging an HTTP client that refused to
    authenticate with a particularly finicky API. Turns out, the server demanded a
    specific, non-standard capitalization of an authorization header. It was the software
    equivalent of being rejected by a snooty receptionist for wearing the wrong color
    tie.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的早期日子里，我花费数小时调试一个拒绝与一个特别挑剔的API进行身份验证的HTTP客户端。结果发现，服务器要求一个特定的、非标准的授权头的大写格式。这在软件上相当于因为佩戴了错误的领带颜色而被傲慢的接待员拒绝。
- en: HTTP, as with any well-established bureaucracy, is riddled with quirks and legacy
    conventions. Embrace them, and you’ll be building web applications in Go like
    a pro. Ignore them and prepare for a world of frustration and cryptic 400 errors.
    Remember – the devil is in the details, especially when it comes to the intricate
    dance of HTTP requests and responses.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何成熟的官僚机构一样，HTTP充满了怪癖和遗留约定。接受它们，你将像专业人士一样构建Go的Web应用程序。忽略它们，准备迎接一个充满挫败感和神秘的400错误的世界。记住——魔鬼在细节中，尤其是在HTTP请求和响应的复杂舞蹈中。
- en: Securing the connection
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护连接
- en: TLS is the savior of online privacy and a protector against snooping eyes. You
    might think that because Go makes so many things delightfully simple, setting
    up a secure channel with TLS will be equally breezy. Brace yourselves, my friends,
    for here lies a cryptographic labyrinth that rivals the tax codes of most industrialized
    nations.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 是在线隐私的救星，是防止窥探的眼睛的保护者。你可能认为 Go 使得许多事情都变得简单愉快，因此使用 TLS 设置安全通道也会同样轻松。朋友们，准备好吧，因为这里有一个与大多数工业化国家的税法相媲美的加密迷宫。
- en: Think of TLS as trying to encrypt your most embarrassing secrets by following
    a recipe written in ancient hieroglyphics, with half the instructions missing
    and a shadowy figure lurking nearby, gleefully attempting to decipher your scribbles.
    Certificates, key exchanges, cipher suites... TLS is an alphabet soup of acronyms
    designed to make your head spin.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将 TLS 想象成试图通过遵循古代象形文字写成的食谱来加密你最尴尬的秘密，其中一半的指令缺失，一个模糊的身影在附近潜伏，愉快地试图解读你的涂鸦。证书、密钥交换、加密套件...
    TLS 是一个首字母缩略词的字母汤，旨在让你头晕目眩。
- en: Certificates
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 证书
- en: TLS certificates are a fundamental aspect of secure communication over the internet,
    providing encryption, authentication, and integrity. In the context of Go, TLS
    certificates are used to secure communication between clients and servers, such
    as in HTTPS servers or clients that need to securely connect to other services.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 证书是互联网上安全通信的基本要素，提供加密、身份验证和完整性。在 Go 的上下文中，TLS 证书用于在客户端和服务器之间建立安全通信，例如在 HTTPS
    服务器或需要安全连接到其他服务的客户端。
- en: 'A TLS certificate, often simply called a **Secure Sockets Layer** (**SSL**)
    certificate, serves two main purposes:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 证书，通常简称为 **安全套接字层**（**SSL**）证书，有两个主要用途：
- en: '**Encryption**: Ensures that the data exchanged between the client and server
    is encrypted, protecting it from eavesdroppers'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加密**：确保客户端和服务器之间交换的数据被加密，从而保护其免受窃听者的侵害'
- en: '**Authentication**: Verifies the identity of the server to the client, ensuring
    that the client is talking to the legitimate server and not an imposter'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证**：验证服务器对客户端的身份，确保客户端正在与合法服务器交谈，而不是冒名顶替者'
- en: A TLS certificate contains the certificate holder’s public key and identity
    (domain name), and it is signed by a trusted **Certificate Authority** (**CA**).
    When a client connects to a TLS/SSL-secured server, the server presents its certificate.
    The client verifies the certificate’s validity, including the CA’s signature,
    the certificate’s expiration date, and the domain name.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 证书包含证书持有者的公钥和身份（域名），并由受信任的 **证书颁发机构**（**CA**）签名。当客户端连接到 TLS/SSL 加密的服务器时，服务器会展示其证书。客户端验证证书的有效性，包括
    CA 的签名、证书的到期日期和域名。
- en: .crt files versus .pem files
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .crt 文件与 .pem 文件的区别
- en: 'The difference between `.crt` and `.pem` files primarily lies in their naming
    conventions and the format they may contain, rather than the cryptographic functions
    they serve. Both are used in the context of SSL/TLS certificates and can contain
    certificates, private keys, or even intermediate certificates. The content within
    these files is what matters, and both `.crt` and `.pem` files can contain the
    same types of data, encoded in different ways. Let’s take a closer look at both:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`.crt` 文件和 `.pem` 文件之间的主要区别在于它们的命名约定和可能包含的格式，而不是它们所提供的加密功能。两者都在 SSL/TLS 证书的上下文中使用，可以包含证书、私钥甚至中间证书。这些文件中的内容才是关键，`.crt`
    和 `.pem` 文件可以包含相同类型的数据，但以不同的方式编码。让我们更详细地看看两者：'
- en: '`.``crt` files:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.crt` 文件：'
- en: The `.crt` extension is traditionally used for certificate files.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`.crt` 扩展名传统上用于证书文件。'
- en: These files are typically in a binary form, encoded in the `.crt` files are
    used to store certificates (public keys) that are used to verify the ownership
    of a public key with the identity of the certificate holder.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些文件通常是二进制形式，编码在 `.crt` 文件中的用于存储证书（公钥），这些证书用于验证公钥所有者与证书持有者身份的一致性。
- en: '`.``pem` files:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.pem` 文件：'
- en: The `.pem` extension stands for PEM, a file format originally used in email
    encryption. Over time, it has become a standard format for storing and exchanging
    cryptographic material such as certificates, private keys, and intermediate certificates.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`.pem` 扩展名代表 PEM，这是一种最初用于电子邮件加密的文件格式。随着时间的推移，它已成为存储和交换加密材料（如证书、私钥和中间证书）的标准格式。'
- en: PEM files are ASCII (text) encoded and use Base64 encoding between `"-----BEGIN
    CERTIFICATE-----"` and `"-----END CERTIFICATE-----"` markers, making them more
    human-readable than DER-encoded files. This format is very versatile and widely
    supported.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: PEM 文件是 ASCII（文本）编码的，并在 `"-----BEGIN CERTIFICATE-----"` 和 `"-----END CERTIFICATE-----"`
    标记之间使用 Base64 编码，这使得它们比 DER 编码的文件更易于阅读。这种格式非常灵活，并且得到了广泛的支持。
- en: '`.pem` files can contain multiple certificates and keys in the same file, making
    them suitable for various configurations, such as certificate chains.'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`.pem` 文件可以在同一文件中包含多个证书和密钥，这使得它们适合各种配置，如证书链。'
- en: 'The key differences are in the format and encoding: `.crt` files can be in
    binary (DER) or ASCII (PEM) format, whereas `.pem` files are always in ASCII format.
    While both can store similar types of data, `.pem` files are more versatile due
    to their ability to include multiple certificates and keys in a single file. Also,
    `.pem` files are widely supported across different platforms and software for
    SSL/TLS configurations, making them a more universally accepted format for certificates
    and keys.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的区别在于格式和编码：`.crt` 文件可以是二进制（DER）或 ASCII（PEM）格式，而 `.pem` 文件始终是 ASCII 格式。虽然两者都可以存储类似类型的数据，但由于
    `.pem` 文件能够在一个文件中包含多个证书和密钥，因此它们更灵活。此外，`.pem` 文件在跨不同平台和软件的 SSL/TLS 配置中得到广泛支持，使它们成为证书和密钥的更普遍接受的格式。
- en: In practice, the distinction between these extensions is often less important
    than ensuring that the file’s contents are in the correct format expected by the
    software or service using them. Tools and systems that work with SSL/TLS certificates
    usually specify the format they require (PEM or DER) and can sometimes work with
    either, regardless of the file extension. When configuring SSL/TLS, it’s crucial
    to follow the specific requirements of the software or service you’re using, including
    the expected file format and encoding.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这些扩展之间的区别通常不如确保文件的格式符合使用它们的软件或服务所期望的格式重要。使用 SSL/TLS 证书的工具和系统通常会指定它们所需的格式（PEM
    或 DER），有时可以与任一格式一起工作，而不管文件扩展名如何。在配置 SSL/TLS 时，遵循您所使用的软件或服务的具体要求至关重要，包括预期的文件格式和编码。
- en: Creating a TLS certificate for Go applications
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为 Go 应用程序创建 TLS 证书
- en: For development purposes, you can create a self-signed TLS certificate. **For
    production, you should obtain a certificate from a** **trusted CA**.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**为了开发目的，您可以创建一个自签名的 TLS 证书。****对于生产，您应该从受信任的 CA 获取证书**。'
- en: 'To achieve this, we’re using a tool called **OpenSSL**. OpenSSL is a robust,
    full-featured toolkit for the TLS and SSL protocols. It’s also a general-purpose
    cryptography library. Here’s how you can check if it’s installed and how to install
    it if it’s not, across various operating systems:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们使用了一个名为 **OpenSSL** 的工具。OpenSSL 是一个功能强大的 TLS 和 SSL 协议工具包。它也是一个通用的加密库。以下是您可以在各种操作系统上检查其是否已安装以及如果未安装如何安装它的方法：
- en: Windows
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Windows
- en: '**Check installation**:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查安装**：'
- en: 'Open Command Prompt and type the following:'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打开命令提示符并输入以下命令：
- en: '[PRE6]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If the tools are installed, you’ll see the version number. If not, you’ll receive
    an error message indicating that OpenSSL is not recognized.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果工具已安装，您将看到版本号。如果没有，您将收到一个错误消息，表明 OpenSSL 不可识别。
- en: '**Installation**:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安装**：'
- en: '**Using Chocolatey**: If you have Chocolatey installed, you can easily install
    it by running the following command:'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 Chocolatey**：如果您已安装 Chocolatey，可以通过运行以下命令轻松安装：'
- en: '[PRE7]'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`OpenSSL website` or from a trusted third-party provider. After downloading,
    extract the files and add the `bin` directory to your system’s `PATH` environment
    variable.'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `OpenSSL 网站` 或受信任的第三方提供商下载。下载后，提取文件并将 `bin` 目录添加到系统 `PATH` 环境变量中。
- en: macOS
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: macOS
- en: '**Check** **if installed**:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查是否已安装**：'
- en: 'Open a terminal and type the following:'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打开终端并输入以下命令：
- en: '[PRE8]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: macOS comes with OpenSSL pre-installed, but it might not be the latest version.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: macOS 预装了 OpenSSL，但可能不是最新版本。
- en: '**Installation/update**:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安装/更新**：'
- en: 'The best way to install or update OpenSSL on macOS is via Homebrew. If you
    don’t have Homebrew installed, you can install it by running the following command:'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 macOS 上安装或更新 OpenSSL 的最佳方式是通过 Homebrew。如果您尚未安装 Homebrew，可以通过运行以下命令进行安装：
- en: '[PRE9]'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once Homebrew is installed, you can install OpenSSL by running this command:'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Homebrew 后，可以通过运行此命令安装 OpenSSL：
- en: '[PRE10]'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If it’s already installed, make sure it’s linked correctly or update it using
    the following command:'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它已经安装，请确保它已正确链接或使用以下命令更新它：
- en: '[PRE11]'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Linux (Ubuntu/Debian-based distributions)
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Linux (基于 Ubuntu/Debian 的发行版)
- en: '**Check if installed**: Open a terminal and type the following:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查是否已安装**：打开终端并输入以下命令：'
- en: '[PRE12]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Most Linux distributions come with OpenSSL pre-installed.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 大多数Linux发行版都预装了OpenSSL。
- en: '**Installation/update**: You can install or update OpenSSL using the package
    manager. For Ubuntu/Debian-based systems, use the following to update your package
    list:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安装/更新**：您可以使用包管理器安装或更新OpenSSL。对于基于Ubuntu/Debian的系统，使用以下命令更新您的软件包列表：'
- en: '[PRE13]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Use the following to install OpenSSL:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用以下命令安装OpenSSL：
- en: '[PRE14]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: PEM
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: PEM
- en: 'We can use OpenSSL to generate a self-signed certificate:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用OpenSSL生成一个自签名证书：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This command generates a new 4096-bit RSA key and a certificate valid for 365
    days. The certificate is self-signed, meaning it’s signed with its own key. `key.pem`
    is the private key, and `cert.pem` is the public certificate.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令生成一个新的4096位RSA密钥和有效期为365天的证书。该证书是自签名的，意味着它使用自己的密钥签名。`key.pem`是私钥，`cert.pem`是公开证书。
- en: 'To use this certificate in a Go server, you can use the `http.ListenAndServeTLS()`
    function:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Go服务器中使用此证书，您可以使用`http.ListenAndServeTLS()`函数：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: CRT
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CRT
- en: 'The first step in generating a `.crt` file is to create a private key. This
    key will remain securely stored on your server and should never be shared:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 生成`.crt`文件的第一步是创建一个私钥。此密钥将安全地存储在您的服务器上，并且永远不应该共享：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This command generates a 2048-bit RSA private key and saves it to a file named
    `mydomain.key`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令生成一个2048位RSA私钥并将其保存到名为`mydomain.key`的文件中。
- en: 'Next, you’ll create a **certificate signing request** (**CSR**), which is a
    request to a CA to sign your public key and create a certificate. The CSR contains
    information about your domain and organization:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将创建一个**证书签名请求**（**CSR**），这是一个向CA请求签名您的公钥并创建证书的请求。CSR包含有关您的域名和组织的信息：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You will be prompted to enter details such as your country, state, organization
    name, and **Common Name** (**CN**; domain name). The CN is especially important
    because it’s the domain name that the certificate will be issued for.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被提示输入有关您的国家、州、组织名称和**通用名称**（**CN**；域名）的详细信息。CN特别重要，因为它是证书将签发的域名。
- en: 'When we’re setting up a certificate for development purposes or internal use,
    we might want to generate a self-signed certificate instead of getting one from
    a CA. This can be done by signing the CSR with your own private key:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为开发目的或内部使用设置证书时，我们可能希望生成一个自签名证书而不是从CA获取。这可以通过使用您的私钥签名CSR来完成：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This command creates a certificate (`mydomain.crt`) that is valid for 365 days.
    Note that browsers and clients will not trust this certificate since **it’s not
    signed by a** **recognized CA**.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令创建一个有效期为365天的证书（`mydomain.crt`）。请注意，由于**它未由** **受认可CA** **签名**，浏览器和客户端将不会信任此证书。
- en: But fear not! Go, in its elegant way, provides the tools to navigate this cryptographic
    maze. The `crypto/tls` package offers the building blocks you need to secure your
    network communications. Think of it as your trusty cryptography toolkit, complete
    with an industrial-grade cipher and a certificate generator for good measure.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 但不必担心！Go以其优雅的方式提供了导航这个加密迷宫的工具。`crypto/tls`包提供了您需要来保护您的网络通信的基本构建块。把它想象成您的可靠加密工具包，其中包含工业级加密算法和证书生成器。
- en: 'Let’s glimpse at the core idea of TLS with a basic example of securing a TCP
    connection:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个基本的示例来了解一下TLS的核心思想，即如何保护TCP连接：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this snippet, we load our server’s certificate and key, create a TLS configuration,
    and use `tls.Listen` to wrap our regular TCP listener in a secure TLS layer. It’s
    like adding bulletproof glass and an armed guard to your regular communication
    channel.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们加载服务器的证书和密钥，创建TLS配置，并使用`tls.Listen`将我们的常规TCP监听器包装在安全的TLS层中。这就像在您的常规通信渠道中添加了防弹玻璃和武装警卫。
- en: Think of TLS as securing a vault for your most precious data. It involves multiple
    layers of encryption, strict authentication mechanisms, and constant vigilance
    against evolving threats. Go makes it easier to implement TLS, but understanding
    the fundamentals of cryptography remains essential if you want to do it right!
    After all, in the world of network communication, complacency is a vulnerability
    waiting to be exploited.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 将TLS想象成为您最珍贵的数据建立一个保险库。它涉及多层加密、严格的身份验证机制以及对不断发展的威胁的持续警惕。Go使实现TLS变得更容易，但了解密码学的基本原理对于正确实现它仍然是必不可少的！毕竟，在网络通信的世界里，自满是一种等待被利用的漏洞。
- en: TLS is the successor to SSL. It’s the standard technology for keeping an internet
    connection secure and safeguarding any sensitive data that’s being sent between
    two systems. This prevents criminals from reading and modifying any information
    transferred, including potential personal details. The two systems can be anything
    from a server and client (in a browser-to-server scenario) to two servers communicating
    with each other.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: TLS是SSL的继任者。它是保持互联网连接安全并保护两个系统之间传输的任何敏感数据的标准技术。这阻止了犯罪分子读取和修改传输的任何信息，包括潜在的个人细节。这两个系统可以是服务器和客户端（在浏览器到服务器场景中）或相互通信的两个服务器。
- en: Understanding TLS is crucial for anyone involved in the development of applications
    that communicate over the internet. It’s not just about encrypting data; it’s
    about ensuring that entities at either end of the communication are who they claim
    to be. Without TLS, you’re essentially shouting your personal details through
    a megaphone in Times Square and hoping only the intended recipient is listening.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 理解TLS对于任何参与开发通过互联网通信的应用程序的人来说至关重要。这不仅仅关乎加密数据；这是确保通信两端的实体是其所声称的那样。没有TLS，你本质上是在时代广场的扩音器中大声喊出你的个人细节，并希望只有预期的收听者才能听到。
- en: TLS pitfalls
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TLS陷阱
- en: There is a list of pitfalls and things to keep in mind when we’re dealing with
    TLS in general.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们一般处理TLS时，有一份关于陷阱和需要注意的事项的清单。
- en: 'Let’s look at some of them:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看其中的一些：
- en: '**Validity**: Ensure your certificates are valid (not expired) and renew them
    as necessary. Using expired certificates can lead to service outages.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有效性**：确保您的证书有效（未过期），并在必要时进行更新。使用过期的证书可能导致服务中断。'
- en: '**Security**: Keep your private keys secure. If a private key is compromised,
    the corresponding certificate can be misused to intercept or tamper with secure
    communications.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全**：确保您的私钥安全。如果私钥受到损害，相应的证书可能会被滥用以拦截或篡改安全通信。'
- en: '**Trust**: For production environments, use certificates issued by a trusted
    CA. Browsers and clients trust these CAs and will show warnings or block connections
    to sites with self-signed or untrusted certificates.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信任**：对于生产环境，请使用由受信任的CA签发的证书。浏览器和客户端信任这些CA，并将显示警告或阻止连接到带有自签名或不受信任证书的网站。'
- en: '**Domain matching**: The domain name on the certificate must match the domain
    name that clients use to connect to your server. Mismatches can lead to security
    warnings.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**域名匹配**：证书上的域名必须与客户端用于连接您的服务器的域名匹配。不匹配可能导致安全警告。'
- en: '**Certificate chains**: Understand how to serve the full certificate chain
    (not just your server’s certificate) to ensure compatibility with clients.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**证书链**：了解如何提供完整的证书链（而不仅仅是您的服务器证书），以确保与客户端的兼容性。'
- en: '**Performance**: TLS/SSL has a performance impact due to the encryption and
    decryption process. Use efficient cipher suites and consider server and client
    capabilities.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：TLS/SSL由于加密和解密过程而具有性能影响。使用高效的密码套件，并考虑服务器和客户端的能力。'
- en: To wrap up, think of implementing TLS in your applications as crafting a fine
    suit of armor for a knight. The materials (TLS protocols) must be of the highest
    quality, the design (your implementation) must be meticulous, and the fit (integration
    with your application) must be perfect. Just as a knight trusts their armor to
    protect them in battle, so too must your users trust your application to protect
    their data. Forge your armor well, and you will not only secure your application
    but also earn the trust and respect of those who rely on it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，将TLS应用于您的应用程序就像为骑士打造一套精美的盔甲。材料（TLS协议）必须是最高质量的，设计（您的实现）必须细致入微，贴合度（与您的应用程序集成）必须完美。正如骑士信任他们的盔甲在战斗中保护他们一样，您的用户也必须信任您的应用程序来保护他们的数据。打造好您的盔甲，您不仅会保护您的应用程序，还会赢得依赖它的那些人的信任和尊重。
- en: Advanced networking
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级网络
- en: You’ve familiarized yourself with TCP sockets, conquered HTTP servers, and even
    wrapped your head around TLS. You might think that’s all there is to network programming
    in Go. How adorably naive. Now, prepare for a wild ride into the realm of UDP,
    WebSocket, and various techniques that will make you question your life choices.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经熟悉了TCP套接字，征服了HTTP服务器，甚至理解了TLS。您可能认为这就是Go网络编程的全部。多么天真可爱。现在，准备好进入UDP、WebSocket和让你质疑生活选择的技巧领域的狂野之旅。
- en: Think of network programming as an unfinished game with perpetually changing
    rules. Just when you think you’ve grasped the basics, the developers throw in
    a new gameplay mechanic (such as real-time communication protocols), introduce
    unpredictable bugs (network latency), and crank up the difficulty level (scalability
    issues). Oh, and don’t forget the delightful online community, where opinions
    on the “best” way to do things are as numerous and conflicting as JavaScript frameworks.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 将网络编程视为一个未完成的游戏，规则不断变化。当你认为你已经掌握了基础知识时，开发者会加入一个新的游戏玩法（如实时通信协议），引入不可预测的错误（网络延迟），并提高难度级别（可扩展性问题）。哦，别忘了那令人愉快的在线社区，关于“最佳”做事方式的意见就像JavaScript框架一样众多且相互冲突。
- en: Let’s start with the basics. UDP is the wild west of network protocols. It’s
    fast, unrelenting, and only cares if some data gets lost in the shuffle. It’s
    perfect for situations where speed is critical and a few lost bits here and there
    won’t cause a catastrophe, such as streaming video or online gaming.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基础知识开始。UDP 是网络协议的狂野西部。它快速、无情，只关心在混乱中是否有一些数据丢失。它非常适合速度至关重要的场合，一些丢失的比特不会造成灾难，例如流媒体视频或在线游戏。
- en: UDP versus TCP
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDP 与 TCP
- en: When we introduce UDP in our system, we can rely upon some advantages.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在系统中引入UDP时，我们可以依赖一些优势。
- en: 'A handful of them are the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些如下：
- en: '**Speed**: UDP is blazingly fast due to its minimal overhead. It doesn’t bother
    with establishing connections or ensuring packet order, making it ideal where
    speed is critical.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：UDP 由于开销最小而非常快。它不麻烦建立连接或确保数据包顺序，这使得它在速度至关重要的地方非常理想。'
- en: '**Low-latency applications**: Time-sensitive applications such as real-time
    gaming, video streaming, and **Voice over Internet Protocol** (**VoIP**) often
    favor UDP because they prioritize minimizing delay over reliability.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低延迟应用程序**：对时间敏感的应用程序，如实时游戏、视频流和 **互联网协议语音**（**VoIP**），通常优先考虑UDP，因为它们更重视最小化延迟而不是可靠性。'
- en: '**Broadcast and multicast**: UDP can easily send data packets to multiple recipients
    on a network, either to all devices in a broadcast or to a selective group in
    a multicast. This is useful for tasks such as service discovery and resource announcements.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**广播和多播**：UDP 可以轻松地将数据包发送到网络上的多个接收者，无论是广播到所有设备还是多播到选择性的组。这对于诸如服务发现和资源公告等任务非常有用。'
- en: '**Simple applications**: If your application needs a basic request-response
    structure without the complexity of handling a full connection, UDP offers a streamlined
    approach.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单应用程序**：如果您的应用程序需要基本的请求-响应结构，而不需要处理完整连接的复杂性，UDP 提供了一种简化的方法。'
- en: '**Custom reliability**: When you need fine-grained control over how your application
    handles errors and lost packets, UDP allows you to implement your own reliability
    mechanisms tailored to your specific use case.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义可靠性**：当您需要精细控制应用程序如何处理错误和丢失的数据包时，UDP 允许您实现针对特定用例的自定义可靠性机制。'
- en: UPD in Go
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UPD 在 Go
- en: 'Golang’s `net` package provides excellent support for UDP programming. Key
    functions/types include the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Golang 的 `net` 包为UDP编程提供了出色的支持。关键函数/类型包括以下内容：
- en: '`net.DialUDP()`: Establishes a UDP “connection” (more of a communication channel)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net.DialUDP()`: 建立UDP“连接”（更像是通信通道）'
- en: '`net.ListenUDP()`: Creates a UDP listener to receive incoming packets'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net.ListenUDP()`: 创建UDP监听器以接收传入的数据包'
- en: '`UDPConn`: Represents a UDP connection, providing methods such as the following:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UDPConn`: 表示UDP连接，提供以下方法：'
- en: '`ReadFromUDP()`'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadFromUDP()`'
- en: '`WriteToUDP()`'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WriteToUDP()`'
- en: 'Before creating our application using UDP, let’s keep in mind the trade-offs:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用UDP创建我们的应用程序之前，让我们记住权衡：
- en: '| **Feature** | **UDP** | **TCP** |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| **功能** | **UDP** | **TCP** |'
- en: '| Protocol type | Connectionless | Connection-oriented |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 协议类型 | 无连接 | 有连接 |'
- en: '| Reliability | Unreliable (no packet guarantees) | Reliable (ordered delivery,
    error correction) |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 可靠性 | 不可靠（无数据包保证） | 可靠（有序交付，错误纠正） |'
- en: '| Overhead | Low | High |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 开销 | 低 | 高 |'
- en: '| Speed | Faster | Slower |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 速度 | 更快 | 更慢 |'
- en: '| Use cases | Real-time, low-latency communication, broadcasts/multicast, applications
    with custom reliability | Applications requiring guaranteed data delivery, data
    integrity |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 用例 | 实时、低延迟通信，广播/多播，具有自定义可靠性的应用程序 | 需要保证数据交付、数据完整性的应用程序 |'
- en: 'Traditional reliability in TCP often used a method called **Go-Back-N**. In
    the event of a lost packet, the following would happen:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 中的传统可靠性通常使用一种称为 **Go-Back-N** 的方法。在发生数据包丢失的情况下，以下情况会发生：
- en: The sender would roll back and start retransmitting from the lost packet onward
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送者将回滚并从丢失的数据包开始重新传输
- en: This meant even correctly received packets after the lost one got sent again
    (inefficient)
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这意味着即使在丢失的数据包之后发送了正确接收的数据包（效率低下）
- en: This is fine for TCP due to its in-order delivery but wasteful for scenarios
    where order is less important.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于TCP来说很好，因为它的顺序交付，但在顺序不那么重要的情况下是浪费的。
- en: In UDP, we can apply a technique called **Selective Retransmissions** (also
    known as **Selective Acknowledgments**, or **SACK**).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在UDP中，我们可以应用一种称为**选择性重传**（也称为**选择性确认**，或**SACK**）的技术。
- en: Selective Retransmissions
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 选择性重传
- en: The whole idea is that the receiver keeps track of which packets have been received
    successfully, even if they arrive out of order, so that it can explicitly tell
    the sender which specific packets are missing, providing a list or range of missing
    sequence numbers. Lastly, the sender only retransmits packets the receiver marked
    as missing.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 整个想法是接收者跟踪哪些数据包已成功接收，即使它们顺序不正确，这样它就可以明确地告诉发送者哪些特定的数据包丢失，提供一个丢失序列号的列表或范围。最后，发送者只重新传输接收者标记为丢失的数据包。
- en: 'We can depict three major benefits of this strategy:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以描述这种策略的三个主要好处：
- en: Avoiding resending correctly received data, and improving bandwidth use in lossy
    conditions (particularly common over **point-of-sale** (**POS**) and edge connections)
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免重新发送正确接收的数据，并在有损耗条件下（尤其是在**销售点**（POS）和边缘连接中）提高带宽使用率
- en: Avoiding unnecessary stalls waiting for missing data before later packets can
    be processed
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在处理后续数据包之前等待丢失数据的不必要停滞
- en: Helps minimize delays when an occasional loss is tolerable, but maximizing the
    throughput of newer data is important
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当偶尔的丢失可以容忍时，有助于最小化延迟，但最大化新数据的吞吐量很重要
- en: 'Sounds nice, right? Let’s explore how we can implement this on the server side:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来不错，对吧？让我们探索我们如何在服务器端实现这一点：
- en: '[PRE21]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'First, we need to import all packages:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要导入所有包：
- en: '[PRE22]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let’s make these declarations easier to grasp. Here’s the intention of each
    one:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使这些声明更容易理解。以下是每个声明的意图：
- en: '`maxDatagramSize`: The maximum size of a UDP packet. This is set to 1024 bytes
    but can be adjusted based on network conditions or requirements.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxDatagramSize`：UDP数据包的最大大小。这设置为1024字节，但可以根据网络条件或要求进行调整。'
- en: '`packetLossRate`: A constant to simulate a 20% packet loss rate in the network.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`packetLossRate`：一个常数，用于在网络中模拟20%的数据包丢失率。'
- en: '`Packet`: A struct representing a packet with a sequence number (`SeqNum`)
    and data (`Payload`).'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Packet`：一个表示具有序列号（`SeqNum`）和数据（`Payload`）的数据包的结构体。'
- en: 'Once we set these initial variables, we can advance with our `main()` function:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了这些初始变量，我们就可以使用`main()`函数继续前进：
- en: '[PRE23]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, we initialize a UDP server listening on port 5000\. `net.ResolveUDPAddr`
    is used to resolve the address on which the server listens. `net.ListenUDP` starts
    listening for UDP packets on the resolved address. `defer conn.Close()` ensures
    the server’s connection is closed properly when the function exits:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们初始化一个监听端口5000的UDP服务器。`net.ResolveUDPAddr`用于解析服务器监听的地址。`net.ListenUDP`在解析的地址上开始监听UDP数据包。`defer
    conn.Close()`确保在函数退出时正确关闭服务器的连接：
- en: '[PRE24]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is a goroutine that continuously reads incoming packets. It reads the
    first 4 bytes of each packet to get the sequence number, assuming the sequence
    number is stored in the first 4 bytes. For each packet received, it sends an acknowledgment
    back to the sender using the `sendAck()` function:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个goroutine，它持续读取传入的数据包。它读取每个数据包的前4个字节以获取序列号，假设序列号存储在前4个字节中。对于每个接收到的数据包，它使用`sendAck()`函数向发送者发送一个确认：
- en: '[PRE25]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The main loop of the program creates packets with a sequence number and a test
    payload. `sendPacket()` attempts to send these packets to the client. Packet loss
    is simulated here; some packets are randomly dropped based on the `packetLossRate`
    value:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的主循环创建带有序列号和测试有效负载的数据包。`sendPacket()`尝试将这些数据包发送到客户端。在此处模拟数据包丢失；根据`packetLossRate`值随机丢弃一些数据包：
- en: '[PRE26]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let’s explore the `sendPacket()` function:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索`sendPacket()`函数：
- en: '`addr` (the client’s address) is `nil` or if `addr.IP` is `nil`. If either
    is `true`, it means there’s no valid client address to send the packet to, so
    the function returns immediately without doing anything.'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`addr`（客户端的地址）为`nil`或如果`addr.IP`为`nil`。如果任一为`true`，则表示没有有效的客户端地址来发送数据包，因此函数立即返回而不执行任何操作。'
- en: '`buf` byte slice with a size that can hold the packet’s sequence number (4
    bytes) plus the length of the packet’s payload. The sequence number is then placed
    at the beginning of this slice (`buf[:4]`) using `binary.BigEndian.PutUint32`,
    which ensures the number is stored in a big-endian format (network byte order).
    The payload is copied into the buffer right after the sequence number.'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将可以容纳包的序列号（4 个字节）加上包的有效负载长度的 `buf` 字节切片。然后使用 `binary.BigEndian.PutUint32` 将序列号放置在这个切片的开始位置（`buf[:4]`），这确保了数字以大端格式（网络字节顺序）存储。有效负载随后被复制到序列号之后的缓冲区中。
- en: '`rand.Float32()` and checking if this number is greater than the predefined
    `packetLossRate` value. If the condition is `true`, it proceeds to send the packet;
    otherwise, it simulates a packet loss by printing a message and not sending the
    packet.'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rand.Float32()` 并检查这个数字是否大于预定义的 `packetLossRate` 值。如果条件为 `true`，它将继续发送包；否则，它通过打印一条消息而不发送包来模拟包丢失。'
- en: '`conn.WriteToUDP(buf, addr)`, where `buf` is the prepared data and `addr` is
    the client’s address. If the packet is successfully sent, it prints a message
    indicating the sequence number of the sent packet and the client’s address. If
    there’s an error during sending, it prints an error message:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`conn.WriteToUDP(buf, addr)`，其中 `buf` 是准备好的数据，`addr` 是客户端的地址。如果包成功发送，它将打印一条消息，指示发送的包的序列号和客户端的地址。如果在发送过程中出现错误，它将打印一条错误消息：'
- en: '[PRE27]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `sendAck()` function is designed to send an **acknowledgment** (**ACK**)
    packet back to a client to confirm the receipt of a packet. Here’s a breakdown
    of its operations:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendAck()` 函数被设计用来向客户端发送一个确认（**ACK**）包以确认接收到了一个包。以下是其操作的分解：'
- en: '`ackPacket` with a size of 4 bytes. This size is chosen because the function
    only needs to send back the sequence number of the received packet, which is a
    `uint32` type and requires 4 bytes.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大小为 4 字节的 `ackPacket`。这个大小是选择的，因为函数只需要发送回接收到的包的序列号，这是一个 `uint32` 类型，需要 4 个字节。
- en: '`seqNum`) received as a parameter is encoded into the `ackPacket` byte slice
    using `binary.BigEndian.PutUint32`. This function call ensures that the sequenceencoding”
    number is stored in a big-endian format, which is a standard way of representing
    numbers in network communications. The big-endian format means the **most significant
    byte** (**MSB**) is stored first.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为参数接收到的 `seqNum` 使用 `binary.BigEndian.PutUint32` 编码到 `ackPacket` 字节切片中。这个函数调用确保序列号以大端格式存储，这是网络通信中表示数字的标准方式。大端格式意味着**最高有效字节**（**MSB**）首先存储。
- en: '`ackPacket` back to the client using the `conn.WriteToUDP()` method, specifying
    `ackPacket` as the data to send and `addr` as the destination address. The `addr`
    parameter is the address of the client that originally sent the packet being acknowledged.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `conn.WriteToUDP()` 方法将 `ackPacket` 返回给客户端，指定 `ackPacket` 作为要发送的数据，`addr`
    作为目标地址。`addr` 参数是原始发送被确认的包的客户端的地址。
- en: '**Error handling**: If there’s an error in sending the ACK packet, the function
    prints an error message, as shown in the previous code snippet, to the console.
    This could happen for various reasons, such as network issues or if the client’s
    address is no longer valid:'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理**：如果在发送 ACK 包时出现错误，函数将打印一条错误消息，如前一个代码片段所示，到控制台。这可能会因为各种原因发生，例如网络问题或客户端的地址不再有效：'
- en: '[PRE28]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `unpackUint32()` function is designed to extract a `uint32` value from
    a byte slice, ensuring that the byte slice is interpreted according to the big-endian
    byte order. Here’s a detailed explanation of its operations:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`unpackUint32()` 函数被设计用来从一个字节切片中提取一个 `uint32` 值，确保字节切片根据大端字节顺序被解释。以下是其操作的详细说明：'
- en: '`buf` input byte slice is at least 4 bytes. This check is necessary because
    a `uint32` value requires 4 bytes, and attempting to extract a `uint32` value
    from a smaller buffer would result in an error. If the buffer is shorter than
    4 bytes, the function returns 0 for the `uint32` value and a `"buffer too` `short"`
    error.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入的字节切片 `buf` 至少有 4 个字节。这个检查是必要的，因为 `uint32` 值需要 4 个字节，尝试从一个更小的缓冲区中提取 `uint32`
    值会导致错误。如果缓冲区小于 4 个字节，函数将返回 0 作为 `uint32` 值，并返回一个 `"buffer too short"` 错误。
- en: '`uint32` value from it. This is done using `binary.BigEndian.Uint32(buf)`,
    which reads the first 4 bytes of `buf` and interprets them as a `uint32` value
    in big-endian order. Big-endian order means that the byte slice is read with the
    MSB first. For example, if `buf` contains `[0x00, 0x00, 0x01, 0x02]` bytes, the
    resulting `uint32` value would be `258` because `0x00000102` in hexadecimal corresponds
    to `258` in decimal.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从它中读取 `uint32` 值。这是通过 `binary.BigEndian.Uint32(buf)` 实现的，它读取 `buf` 的前4个字节，并将它们解释为按大端序的大端
    `uint32` 值。大端序意味着字节切片以MSB（最高有效位）首先读取。例如，如果 `buf` 包含 `[0x00, 0x00, 0x01, 0x02]`
    字节，则得到的 `uint32` 值将是 `258`，因为十六进制的 `0x00000102` 对应于十进制的 `258`。
- en: '`uint32` value is returned along with `nil` for the error, indicating successful
    extraction:'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个 `uint32` 值和 `nil` 错误，表示成功提取：
- en: '[PRE29]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`rand.Seed()` seeds the random number generator to ensure that the simulated
    packet loss is unpredictable.'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `rand.Seed()` 为随机数生成器设置种子，以确保模拟的包丢失是不可预测的。
- en: The complete source code can be found in the `ch10` folder of the GitHub repository.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可以在GitHub仓库的 `ch10` 文件夹中找到。
- en: Production scenario
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 生产场景
- en: Keep in mind that a production-ready implementation would require more robust
    error handling and potentially more sophisticated data structures.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，一个生产就绪的实现需要更健壮的错误处理和可能更复杂的数据结构。
- en: 'The decision between UDP and TCP often hinges on these trade-offs:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: UDP和TCP之间的选择通常取决于这些权衡：
- en: '**Reliability versus speed**: If guaranteed delivery of all data is essential,
    TCP is the way to go. If minimizing latency and tolerating some packet loss is
    acceptable, UDP is a stronger choice.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠性与速度**：如果保证所有数据的交付是必要的，TCP是最佳选择。如果最小化延迟并容忍一些数据包丢失是可以接受的，UDP是一个更强的选择。'
- en: '**Connection overhead**: If you need to transfer large volumes of data with
    a persistent connection, TCP excels. For simple message-oriented exchanges, UDP’s
    reduced overhead is appealing.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接开销**：如果您需要通过持久连接传输大量数据，TCP表现卓越。对于简单的消息交换，UDP的降低开销更具吸引力。'
- en: '**Complexity**: Techniques such as Selective Retransmissions add complexity
    on both the sender and receiver sides compared to simple retransmission.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂性**：与简单的重传相比，选择性重传等技术增加了发送方和接收方的复杂性。'
- en: WebSocket
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WebSocket
- en: Then there’s WebSocket, a protocol for real-time communication between a client
    and a server. It’s like having a direct phone line between two parties, allowing
    continuous, two-way communication. This starkly contrasts with the traditional
    request/response model of HTTP, making WebSocket ideal for applications that require
    instant updates, such as live chat applications or financial tickers. In other
    words, both client and server can send data spontaneously, unlike the request-response
    model of traditional HTTP.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是WebSocket，这是一个客户端和服务器之间实时通信的协议。它就像在双方之间有一条直接的电话线，允许持续的、双向通信。这与HTTP的传统请求/响应模型形成鲜明对比，使得WebSocket非常适合需要即时更新的应用程序，如实时聊天应用或金融行情。换句话说，客户端和服务器都可以自发地发送数据，这与传统HTTP的请求-响应模型不同。
- en: Also, the connection is established through a handshake over HTTP but then upgraded
    to a long-lived TCP connection. Once established, it has minimal message framing
    overhead, making it suitable for real-time scenarios.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，连接是通过HTTP握手建立的，但随后升级为长连接的TCP连接。一旦建立，它具有最小的消息帧头开销，使其适合实时场景。
- en: 'Now, let’s look at a simple example of setting up a WebSocket server. For this
    example, we will be using the `gobwas/ws` library. So, we need to get the library
    by executing the following command in the terminal:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看设置WebSocket服务器的一个简单示例。在这个例子中，我们将使用 `gobwas/ws` 库。因此，我们需要在终端中执行以下命令来获取库：
- en: '[PRE30]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once we have it, we can try to use the library as shown in the repository:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了它，我们就可以像在仓库中展示的那样尝试使用这个库：
- en: '[PRE31]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The key sections are the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 关键部分如下：
- en: '**Imports**: It imports necessary packages for HTTP and WebSocket handling'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导入**：它导入了处理HTTP和WebSocket所需的必要包'
- en: '`http.ListenAndServe` to start an HTTP server on port 8080'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `http.ListenAndServe` 在8080端口启动一个HTTP服务器
- en: '`ws.UpgradeHTTP`'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ws.UpgradeHTTP`'
- en: '**Handle WebSocket connection**: For each connection, it launches a goroutine
    to handle messages'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理WebSocket连接**：对于每个连接，它启动一个goroutine来处理消息'
- en: '`wsutil.ReadClientData`'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wsutil.ReadClientData`'
- en: '`wsutil.WriteServerMessage`'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wsutil.WriteServerMessage`'
- en: '**Close connection**: Ensures the WebSocket connection is closed after handling
    messages or encountering an error'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关闭连接**：确保在处理消息或遇到错误后关闭WebSocket连接'
- en: Since it is an HTTP server at the end of the day, we can explore how to call
    it from another Go client and even from your browser.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它最终是一个 HTTP 服务器，我们可以探索如何从另一个 Go 客户端甚至从您的浏览器中调用它。
- en: 'In the following snippet, we have our Go client:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们有我们的 Go 客户端：
- en: '[PRE32]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let’s see how it works:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的：
- en: '`ws.DefaultDialer.Dial` to establish a WebSocket connection to the server at
    `ws://localhost:8080`'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ws.DefaultDialer.Dial` 建立到 `ws://localhost:8080` 服务器上的 WebSocket 连接
- en: '`"Hello, server!"` message using `wsutil.WriteClientMessage`'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `wsutil.WriteClientMessage` 发送 `"Hello, server!"` 消息
- en: '`wsutil.ReadServerData`'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`wsutil.ReadServerData`'
- en: '**Close connection**: After receiving the response,'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**关闭连接**：在收到响应后'
- en: he connection is closed gracefully with `defer conn.Close()`
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `defer conn.Close()` 优雅地关闭连接
- en: '**Wait for user input**: Finally, the client waits for the user to press *Enter*
    before exiting, to ensure that the user has time to see the server’s response'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**等待用户输入**：最后，客户端等待用户按下 *Enter* 键后再退出，以确保用户有时间看到服务器的响应'
- en: 'Make sure your WebSocket server is running, and run your client by executing
    the following command in the terminal:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的 WebSocket 服务器正在运行，并在终端中执行以下命令来运行您的客户端：
- en: '[PRE33]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The client will connect to the server, send a message, display the server’s
    response, and wait for you to press *Enter* before exiting.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端将连接到服务器，发送一条消息，显示服务器的响应，并在退出前等待您按下 *Enter* 键。
- en: 'To connect to the WebSocket server from a browser, you can use the WebSocket
    API available in modern web browsers. First, create an HTML file (for example,
    `index.html`) that will import the `websocket.js` script:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要从浏览器连接到 WebSocket 服务器，您可以使用现代网络浏览器中可用的 WebSocket API。首先，创建一个 HTML 文件（例如，`index.html`），该文件将导入
    `websocket.js` 脚本：
- en: '[PRE34]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we can create a JavaScript file (for example, `websocket.js`) that includes
    the code to connect to the WebSocket server, send messages, and receive messages:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个 JavaScript 文件（例如，`websocket.js`），其中包含连接到 WebSocket 服务器、发送消息和接收消息的代码：
- en: '[PRE35]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Running the example, open the `index.html` file in a web browser. This establishes
    a WebSocket connection to the server running on `localhost:8080`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例，在网页浏览器中打开 `index.html` 文件。这将在 `localhost:8080` 上运行的服务器上建立 WebSocket 连接。
- en: The JavaScript code connects to the WebSocket server, sends a `"Hello, server!"`
    message upon connection, and logs any messages received from the server to the
    console.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 代码连接到 WebSocket 服务器，在连接时发送一条 `"Hello, server!"` 消息，并将从服务器接收到的任何消息记录到控制台。
- en: You can expand upon this by adding UI elements to send messages dynamically
    and display responses from the server.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过添加 UI 元素来动态发送消息并显示来自服务器的响应来扩展它。
- en: There are many more combinations, designs, and options regarding networking
    programming with Go. In addition to these building blocks, we can choose an architecture
    pattern such as REST, whichever kind of messaging system makes sense to your use
    case, or even a **Remote Procedure Call** (**RPC**) framework such as gRPC. It’s
    crucial to make this decision to understand this base component of networking
    to grant us leverage on our choices and clear mental maps during troubleshooting
    sessions.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用 Go 进行网络编程的组合、设计和选项还有很多。除了这些构建块，我们还可以选择一种架构模式，如 REST，或者任何适合您用例的消息系统，甚至是一个
    **远程过程调用**（RPC）框架，例如 gRPC。做出这个决定对于理解网络的基础组件至关重要，这样我们才能在故障排除会话中获得选择的杠杆作用和清晰的思维导图。
- en: 'Reflecting on the labyrinth of advanced networking in Go, I recall a project
    that was as ambitious as it was fraught with peril. The requirements were simple
    on paper but complex in execution: real-time data synchronization across a distributed
    system with high reliability and low latency. It was a trial by fire, teaching
    me the importance of choosing the right tool for the job, the intricacies of connection
    pooling, and the delicate art of optimizing network performance.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 反思 Go 中高级网络迷宫，我想起了一个既雄心勃勃又充满危险的项目。在纸上要求很简单，但在执行上很复杂：在分布式系统中实现具有高可靠性和低延迟的实时数据同步。这是一次火与血的考验，教会了我选择正确工具的重要性、连接池的复杂性以及优化网络性能的微妙艺术。
- en: To sum up, mastering advanced networking in Go is like assembling a high-performance
    engine. Each part, whether it’s UDP, WebSocket, or further options, plays a critical
    role in the machine’s overall performance. Connection pooling and network optimization
    are the fine-tuning that ensures peak efficiency. Just as a well-oiled engine
    powers a car to victory in a race, a well-architected network drives an application
    to success in the digital realm. So, gear up, dive deep into the documentation,
    and may your network connections be fast, reliable, and secure.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，掌握 Go 的高级网络编程就像组装一台高性能引擎。每个部分，无论是 UDP、WebSocket 还是其他选项，都在机器的整体性能中扮演着关键角色。连接池和网络优化是确保峰值效率的微调。正如一台运转良好的引擎能够使汽车在比赛中获胜一样，一个精心设计的网络能够使应用程序在数字领域取得成功。所以，准备好，深入文档，愿你的网络连接快速、可靠且安全。
- en: Summary
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We demystified network programming in Go. Starting with an overview of Go’s
    `net` package, the chapter introduced the fundamental building blocks of network
    programming, including establishing connections, handling data streams, and parsing
    network addresses. Through engaging examples and detailed explanations, readers
    learned to navigate the challenges of TCP socket programming, understand the nuances
    of HTTP servers and clients, and secure their applications with TLS.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们揭开了 Go 中网络编程的神秘面纱。从对 Go 的 `net` 包的概述开始，本章介绍了网络编程的基本构建块，包括建立连接、处理数据流和解析网络地址。通过引人入胜的示例和详细的解释，读者学会了如何应对
    TCP 套接字编程的挑战，理解 HTTP 服务器和客户端的细微差别，并使用 TLS 保护他们的应用程序。
- en: By exploring both the theoretical aspects and practical implementations of network
    communication in Go, you gained a well-rounded understanding of how to build efficient,
    reliable, and secure networked applications. This knowledge not only enhances
    your Go programming skills but also prepares you for tackling complex networking
    challenges in real-world scenarios.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 通过探索 Go 中网络通信的理论方面和实践实现，你获得了全面理解如何构建高效、可靠和安全的网络应用程序。这种知识不仅增强了你的 Go 编程技能，而且为你应对现实场景中的复杂网络挑战做好了准备。
- en: In the next chapter, we’ll examine how to observe our programs’ behavior using
    telemetry techniques, such as logging, tracing, and metrics.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用遥测技术，如日志记录、跟踪和指标，来观察我们程序的运行行为。
