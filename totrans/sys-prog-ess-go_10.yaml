- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we embark on a practical journey through the intricacies of
    network programming in Go. It’s a realm where the simplicity of syntax meets the
    complexity of network communications.
  prefs: []
  type: TYPE_NORMAL
- en: As we progress, you’ll gain a comprehensive understanding of how to leverage
    Go’s powerful standard library, specifically the `net` package, to build robust
    network-driven applications. From establishing **Transmission Control Protocol**
    (**TCP**) and **User Datagram Protocol** (**UDP**) connections to crafting nimble
    web servers and constructing chatty clients, this chapter serves as your guide
    to mastering network interactions in Go, empowering you with practical skills.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter will cover the following key topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The `net` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP servers and clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing the connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced networking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned about network programming.
    The topics covered include TCP sockets, TCP communication challenges, reliability,
    creating and handling HTTP servers and clients, and the complexities of securing
    connections with **Transport Layer Security** (**TLS**). This exploration is designed
    to provide you with the necessary technical skills for network programming in
    Go and deepen your understanding of network communications’ underlying principles
    and challenges.
  prefs: []
  type: TYPE_NORMAL
- en: The net package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network programming in Go. Surely it can’t be that different from spitting out
    a boring old “Hello, World,” right? Wrong. Just because Go boasts a clean syntax
    like a well-maintained garden doesn’t mean the underlying network plumbing isn’t
    a bowl of spaghetti code after a particularly enthusiastic college hackathon.
    Buckle up, because we’re diving into a realm where connection resets lurk around
    every corner, and timeouts feel more personal than a passive-aggressive email
    from your boss.
  prefs: []
  type: TYPE_NORMAL
- en: But fear not, weary programmer! Beneath the surface complexity lies a surprisingly
    powerful and elegant set of tools. Go’s standard library, specifically the `net`
    package, provides a robust suite of functionalities for building all sorts of
    network-driven applications. From crafting nimble web servers to constructing
    chatty clients, the `net` package serves as the foundation for crafting robust
    network interactions in Go.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find functions for establishing connections (both TCP and UDP flavors!),
    working with data streams, and parsing network addresses. It’s the network Swiss
    Army knife, ready to tackle any communication challenge you throw its way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s peek at a simple example to illustrate this point. Here’s a basic program
    that connects to an open Pokémon API and prints the status code and response body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This program showcases the fundamental building blocks of network programming
    in Go. We utilize the `http` package (built on top of the `net` package), establish
    a connection to a remote server, retrieve data, and close the connection gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be thinking: This doesn’t seem too bad. And you’d be right – for
    fundamental interactions. But trust me – the actual depth of network programming
    becomes apparent when you start venturing into asynchronous operations, handling
    errors gracefully across distributed systems, and dealing with the inevitable
    network gremlins.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of it like this: network programming is like writing a complex symphony
    for a global orchestra. It would be best if you managed individual instruments
    (sockets), ensured they played in harmony (protocols), and accounted for occasional
    dropped notes (network errors) – all while conducting the entire performance from
    a distance. It takes practice, patience, and a healthy dose of humor (mostly dark)
    to master the art.'
  prefs: []
  type: TYPE_NORMAL
- en: TCP sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TCP is the reliable workhorse of the internet, ensuring packets arrive in the
    proper order, like a particularly obsessive-compulsive mail carrier. Don’t be
    fooled by its reputation for stability – TCP socket programming in Go can have
    you pull out your hair quickly. Sure, it offers the comforting illusion of a constant,
    reliable data stream. Still, under the hood, it’s a chaotic mosh pit of retransmissions,
    flow control, and enough acronyms to keep a government agency happy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Picture this: TCP is like trying to converse coherently during a loud heavy
    metal concert. You’re screaming messages at each other (sending packets), desperately
    hoping the other person gets the gist amid the noise (network congestion). Occasionally,
    whole phrases get lost in the roar (dropped packets), and you must repeat yourself
    (retransmissions). There can be a better recipe for efficient communication.'
  prefs: []
  type: TYPE_NORMAL
- en: That’s where Go’s `net` package comes to rescue us again. It provides the tools
    to establish and manage TCP connections. Think of functions such as `net.Dial()`
    and `net.Listen()` as your trusty walkie-talkies for setting up a communication
    channel in the middle of a mosh pit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go lets you communicate over TCP connections using two primary abstractions:
    `net.Conn` and `net.Listener`. A `net.Conn` object represents a single TCP connection,
    while `net.Listener` waits around for incoming connection requests like a seasoned
    bouncer at an exclusive club.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s illustrate this with a classic `echo` `server` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look at what is happening in this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `handleConnection()` function, we have the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defer conn.Close()` ensures that the connection is closed once the function
    returns, which is crucial for freeing up resources.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`buf := make([]byte, 1024)` allocates a buffer of 1024 bytes to read data from
    the connection.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `for` loop continuously reads data into `buf` using `conn.Read(buf)`. The
    number of bytes read and any error encountered is returned.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If an error occurs during reading (for example, the client closes the connection),
    the loop breaks, effectively ending the function and closing the connection.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`conn.Write(buf[:n])` writes the data back to the client. `buf[:n]` ensures
    that only the portion of the buffer that was filled with data is sent back.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `main()` function, we have the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`net.Listen("tcp", ":8080")` tells the server to listen for incoming TCP connections
    on port 8080\. The function returns a `Listener` instance that can accept connections.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `for` loop then continuously accepts new connections with `listener.Accept()`.
    This function blocks until a new connection is received.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If an error occurs while accepting a connection (unlikely in normal circumstances),
    the `if err != nil { continue }` loop simply continues to the next iteration,
    effectively ignoring the failed attempt.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For each successful connection, the following happens:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `handleConnection()` function is called in a new goroutine.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This allows the server to handle multiple connections concurrently, as each
    call to `handleConnection()` can run independently.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This example scratches the surface of TCP communication in Go. Notice how we
    handle errors and ensure connections are properly closed. It’s the little things
    that often trip you up, such as forgetting to close a connection and watching
    your resources drain away like sand through your fingers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reflecting on my journey with TCP sockets, I recall a project where the client-server
    model was more like a love-hate relationship. Connections would drop at the most
    inopportune moments, and data packets played hide and seek. Through trial and
    error, I learned the importance of robust error handling and the art of setting
    appropriate timeouts. It was a humbling experience that taught me TCP sockets
    are like a game of chess with the network: always be prepared for an unexpected
    move.'
  prefs: []
  type: TYPE_NORMAL
- en: To wrap up, think of TCP communication in Golang as crafting a fine cocktail.
    The ingredients (TCP fundamentals) must be measured with precision, mixed with
    care (establishing and handling connections), and served with flair (implementing
    a server and client). And just as with bartending, practice and patience are key.
    Cheers to your journey into the world of TCP sockets. May your connections be
    stable and your data flow smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP servers and clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP, the protocol that powers the web, is responsible for all those charming
    cat videos and questionable social media rabbit holes. You might be tempted to
    assume building web servers and clients in Go is a walk in the park – after all,
    we’re not dealing with the mind-bending intricacies of TCP sockets anymore, are
    we? Oh, sweet summer child, prepare to be humbled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Picture this: HTTP is like trying to navigate a labyrinthine bureaucracy. You
    have rigid forms to fill (requests), specific departments to address (URLs), and
    a baffling array of status codes that could mean anything from “Sure, here’s your
    thing” to “Your paperwork has been accidentally shredded.” And just when you think
    you’ve got the hang of it, some obscure rule change (such as a protocol update)
    sends you spiraling back to square one.'
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, Go’s standard library comes equipped with the `net/http` package
    – your trusty compass for navigating this bureaucratic nightmare. This package
    offers convenient tools for crafting both web servers and clients, letting you
    speak the language of HTTP fluently.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an HTTP server in Go is deceptively straightforward, thanks to the
    powerful yet simple `net/http` package. This package abstracts away much of the
    complexity involved in handling HTTP requests, allowing developers to focus on
    the logic of their applications rather than the underlying protocol mechanics.
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic HTTP server in Go is surprisingly simple to set up. Let’s look at how
    to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This snippet defines a simple web server that listens on port 8080 and responds
    to any request with a friendly greeting. Think of `http.HandleFunc` as registering
    a clerk at a specific office within your bureaucratic institution, ready to handle
    incoming requests.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP verbs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTP verbs (also known as methods) and status codes are fundamental components
    of the HTTP protocol, used to define the action to be performed on a given resource
    and to indicate the outcome of HTTP requests, respectively. The `net/http` package
    in Go provides support for handling these aspects of HTTP. Let’s explore how HTTP
    verbs and status codes are used within the context of Go’s `net/http` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP verbs tell the server what action to perform on a resource. The most used
    HTTP verbs are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: Requests data from a specified resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: Submits data to be processed to a specified resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: Updates a specified resource with provided data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: Deletes a specified resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH`: Applies partial modifications to a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Go, you can handle different HTTP verbs by checking the `Method` field of
    the `http.Request` object. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: HTTP status codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'HTTP status codes are issued by a server in response to a client’s request.
    They are grouped into five classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**1xx (Informational)**: The request was received, continuing process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2xx (Success)**: The request was successfully received, understood, and accepted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3xx (Redirection)**: Further action needs to be taken in order to complete
    the request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**4xx (Client Error)**: The request contains bad syntax or cannot be fulfilled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**5xx (Server Error)**: The server failed to fulfill an apparently valid request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `net/http` package includes constants for many of these status codes, making
    your code more readable – for example, `http.StatusOK` for `200`, `http.StatusNotFound`
    for `404`, and `http.StatusInternalServerError` for `500`. Here’s how you might
    use them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: HTTP verbs (also known as methods) and status codes are fundamental components
    of the HTTP protocol, used to define the action to be performed on a given resource
    and to indicate the outcome of HTTP requests, respectively. The `net/http` package
    in Go provides support for handling these aspects of HTTP. Let’s explore how HTTP
    verbs and status codes are used within the context of Go’s `net/http` package.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Combining the handling of different HTTP verbs with appropriate status codes
    allows you to build more complex and robust web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is an example Go server code that demonstrates handling multiple HTTP
    verbs and returning some of the most common HTTP status codes using the `net/http`
    package. This server will have different endpoints to showcase how to handle `GET`,
    `POST`, `PUT`, and `DELETE` requests, along with sending appropriate HTTP status
    codes in responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we have different uses for the HTTP methods (verbs), such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: Used to request data from a specified resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: Used to send data to a server to create/update a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: Used to send data to a server to create or update a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: Used to delete the specified resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, when we return HTTP status codes, there is a specific meaning to each
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`200 OK`: The request has succeeded'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`201 Created`: The request has succeeded, and a new resource has been created
    as a result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`202 Accepted`: The request has been accepted for processing, but the processing
    has not been completed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`204 No Content`: The server successfully processed the request but is not
    returning any content'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`405 Method Not Allowed`: The request method is known by the server but has
    been disabled and cannot be used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This server listens on port 8080 and routes requests to the appropriate handler
    based on the URL path. The `resourceHandler()` function checks the HTTP method
    of the request and responds with the corresponding status code and message.
  prefs: []
  type: TYPE_NORMAL
- en: Back in my early days, I spent hours debugging an HTTP client that refused to
    authenticate with a particularly finicky API. Turns out, the server demanded a
    specific, non-standard capitalization of an authorization header. It was the software
    equivalent of being rejected by a snooty receptionist for wearing the wrong color
    tie.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP, as with any well-established bureaucracy, is riddled with quirks and legacy
    conventions. Embrace them, and you’ll be building web applications in Go like
    a pro. Ignore them and prepare for a world of frustration and cryptic 400 errors.
    Remember – the devil is in the details, especially when it comes to the intricate
    dance of HTTP requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TLS is the savior of online privacy and a protector against snooping eyes. You
    might think that because Go makes so many things delightfully simple, setting
    up a secure channel with TLS will be equally breezy. Brace yourselves, my friends,
    for here lies a cryptographic labyrinth that rivals the tax codes of most industrialized
    nations.
  prefs: []
  type: TYPE_NORMAL
- en: Think of TLS as trying to encrypt your most embarrassing secrets by following
    a recipe written in ancient hieroglyphics, with half the instructions missing
    and a shadowy figure lurking nearby, gleefully attempting to decipher your scribbles.
    Certificates, key exchanges, cipher suites... TLS is an alphabet soup of acronyms
    designed to make your head spin.
  prefs: []
  type: TYPE_NORMAL
- en: Certificates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TLS certificates are a fundamental aspect of secure communication over the internet,
    providing encryption, authentication, and integrity. In the context of Go, TLS
    certificates are used to secure communication between clients and servers, such
    as in HTTPS servers or clients that need to securely connect to other services.
  prefs: []
  type: TYPE_NORMAL
- en: 'A TLS certificate, often simply called a **Secure Sockets Layer** (**SSL**)
    certificate, serves two main purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encryption**: Ensures that the data exchanged between the client and server
    is encrypted, protecting it from eavesdroppers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authentication**: Verifies the identity of the server to the client, ensuring
    that the client is talking to the legitimate server and not an imposter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A TLS certificate contains the certificate holder’s public key and identity
    (domain name), and it is signed by a trusted **Certificate Authority** (**CA**).
    When a client connects to a TLS/SSL-secured server, the server presents its certificate.
    The client verifies the certificate’s validity, including the CA’s signature,
    the certificate’s expiration date, and the domain name.
  prefs: []
  type: TYPE_NORMAL
- en: .crt files versus .pem files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The difference between `.crt` and `.pem` files primarily lies in their naming
    conventions and the format they may contain, rather than the cryptographic functions
    they serve. Both are used in the context of SSL/TLS certificates and can contain
    certificates, private keys, or even intermediate certificates. The content within
    these files is what matters, and both `.crt` and `.pem` files can contain the
    same types of data, encoded in different ways. Let’s take a closer look at both:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.``crt` files:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `.crt` extension is traditionally used for certificate files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These files are typically in a binary form, encoded in the `.crt` files are
    used to store certificates (public keys) that are used to verify the ownership
    of a public key with the identity of the certificate holder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.``pem` files:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `.pem` extension stands for PEM, a file format originally used in email
    encryption. Over time, it has become a standard format for storing and exchanging
    cryptographic material such as certificates, private keys, and intermediate certificates.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: PEM files are ASCII (text) encoded and use Base64 encoding between `"-----BEGIN
    CERTIFICATE-----"` and `"-----END CERTIFICATE-----"` markers, making them more
    human-readable than DER-encoded files. This format is very versatile and widely
    supported.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.pem` files can contain multiple certificates and keys in the same file, making
    them suitable for various configurations, such as certificate chains.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The key differences are in the format and encoding: `.crt` files can be in
    binary (DER) or ASCII (PEM) format, whereas `.pem` files are always in ASCII format.
    While both can store similar types of data, `.pem` files are more versatile due
    to their ability to include multiple certificates and keys in a single file. Also,
    `.pem` files are widely supported across different platforms and software for
    SSL/TLS configurations, making them a more universally accepted format for certificates
    and keys.'
  prefs: []
  type: TYPE_NORMAL
- en: In practice, the distinction between these extensions is often less important
    than ensuring that the file’s contents are in the correct format expected by the
    software or service using them. Tools and systems that work with SSL/TLS certificates
    usually specify the format they require (PEM or DER) and can sometimes work with
    either, regardless of the file extension. When configuring SSL/TLS, it’s crucial
    to follow the specific requirements of the software or service you’re using, including
    the expected file format and encoding.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a TLS certificate for Go applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For development purposes, you can create a self-signed TLS certificate. **For
    production, you should obtain a certificate from a** **trusted CA**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, we’re using a tool called **OpenSSL**. OpenSSL is a robust,
    full-featured toolkit for the TLS and SSL protocols. It’s also a general-purpose
    cryptography library. Here’s how you can check if it’s installed and how to install
    it if it’s not, across various operating systems:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Check installation**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open Command Prompt and type the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the tools are installed, you’ll see the version number. If not, you’ll receive
    an error message indicating that OpenSSL is not recognized.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Installation**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using Chocolatey**: If you have Chocolatey installed, you can easily install
    it by running the following command:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`OpenSSL website` or from a trusted third-party provider. After downloading,
    extract the files and add the `bin` directory to your system’s `PATH` environment
    variable.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: macOS
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Check** **if installed**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open a terminal and type the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: macOS comes with OpenSSL pre-installed, but it might not be the latest version.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Installation/update**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The best way to install or update OpenSSL on macOS is via Homebrew. If you
    don’t have Homebrew installed, you can install it by running the following command:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Once Homebrew is installed, you can install OpenSSL by running this command:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'If it’s already installed, make sure it’s linked correctly or update it using
    the following command:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Linux (Ubuntu/Debian-based distributions)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Check if installed**: Open a terminal and type the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Most Linux distributions come with OpenSSL pre-installed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Installation/update**: You can install or update OpenSSL using the package
    manager. For Ubuntu/Debian-based systems, use the following to update your package
    list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the following to install OpenSSL:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: PEM
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can use OpenSSL to generate a self-signed certificate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This command generates a new 4096-bit RSA key and a certificate valid for 365
    days. The certificate is self-signed, meaning it’s signed with its own key. `key.pem`
    is the private key, and `cert.pem` is the public certificate.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this certificate in a Go server, you can use the `http.ListenAndServeTLS()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: CRT
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first step in generating a `.crt` file is to create a private key. This
    key will remain securely stored on your server and should never be shared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This command generates a 2048-bit RSA private key and saves it to a file named
    `mydomain.key`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you’ll create a **certificate signing request** (**CSR**), which is a
    request to a CA to sign your public key and create a certificate. The CSR contains
    information about your domain and organization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You will be prompted to enter details such as your country, state, organization
    name, and **Common Name** (**CN**; domain name). The CN is especially important
    because it’s the domain name that the certificate will be issued for.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we’re setting up a certificate for development purposes or internal use,
    we might want to generate a self-signed certificate instead of getting one from
    a CA. This can be done by signing the CSR with your own private key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This command creates a certificate (`mydomain.crt`) that is valid for 365 days.
    Note that browsers and clients will not trust this certificate since **it’s not
    signed by a** **recognized CA**.
  prefs: []
  type: TYPE_NORMAL
- en: But fear not! Go, in its elegant way, provides the tools to navigate this cryptographic
    maze. The `crypto/tls` package offers the building blocks you need to secure your
    network communications. Think of it as your trusty cryptography toolkit, complete
    with an industrial-grade cipher and a certificate generator for good measure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s glimpse at the core idea of TLS with a basic example of securing a TCP
    connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we load our server’s certificate and key, create a TLS configuration,
    and use `tls.Listen` to wrap our regular TCP listener in a secure TLS layer. It’s
    like adding bulletproof glass and an armed guard to your regular communication
    channel.
  prefs: []
  type: TYPE_NORMAL
- en: Think of TLS as securing a vault for your most precious data. It involves multiple
    layers of encryption, strict authentication mechanisms, and constant vigilance
    against evolving threats. Go makes it easier to implement TLS, but understanding
    the fundamentals of cryptography remains essential if you want to do it right!
    After all, in the world of network communication, complacency is a vulnerability
    waiting to be exploited.
  prefs: []
  type: TYPE_NORMAL
- en: TLS is the successor to SSL. It’s the standard technology for keeping an internet
    connection secure and safeguarding any sensitive data that’s being sent between
    two systems. This prevents criminals from reading and modifying any information
    transferred, including potential personal details. The two systems can be anything
    from a server and client (in a browser-to-server scenario) to two servers communicating
    with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding TLS is crucial for anyone involved in the development of applications
    that communicate over the internet. It’s not just about encrypting data; it’s
    about ensuring that entities at either end of the communication are who they claim
    to be. Without TLS, you’re essentially shouting your personal details through
    a megaphone in Times Square and hoping only the intended recipient is listening.
  prefs: []
  type: TYPE_NORMAL
- en: TLS pitfalls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a list of pitfalls and things to keep in mind when we’re dealing with
    TLS in general.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Validity**: Ensure your certificates are valid (not expired) and renew them
    as necessary. Using expired certificates can lead to service outages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: Keep your private keys secure. If a private key is compromised,
    the corresponding certificate can be misused to intercept or tamper with secure
    communications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trust**: For production environments, use certificates issued by a trusted
    CA. Browsers and clients trust these CAs and will show warnings or block connections
    to sites with self-signed or untrusted certificates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain matching**: The domain name on the certificate must match the domain
    name that clients use to connect to your server. Mismatches can lead to security
    warnings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Certificate chains**: Understand how to serve the full certificate chain
    (not just your server’s certificate) to ensure compatibility with clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: TLS/SSL has a performance impact due to the encryption and
    decryption process. Use efficient cipher suites and consider server and client
    capabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To wrap up, think of implementing TLS in your applications as crafting a fine
    suit of armor for a knight. The materials (TLS protocols) must be of the highest
    quality, the design (your implementation) must be meticulous, and the fit (integration
    with your application) must be perfect. Just as a knight trusts their armor to
    protect them in battle, so too must your users trust your application to protect
    their data. Forge your armor well, and you will not only secure your application
    but also earn the trust and respect of those who rely on it.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve familiarized yourself with TCP sockets, conquered HTTP servers, and even
    wrapped your head around TLS. You might think that’s all there is to network programming
    in Go. How adorably naive. Now, prepare for a wild ride into the realm of UDP,
    WebSocket, and various techniques that will make you question your life choices.
  prefs: []
  type: TYPE_NORMAL
- en: Think of network programming as an unfinished game with perpetually changing
    rules. Just when you think you’ve grasped the basics, the developers throw in
    a new gameplay mechanic (such as real-time communication protocols), introduce
    unpredictable bugs (network latency), and crank up the difficulty level (scalability
    issues). Oh, and don’t forget the delightful online community, where opinions
    on the “best” way to do things are as numerous and conflicting as JavaScript frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the basics. UDP is the wild west of network protocols. It’s
    fast, unrelenting, and only cares if some data gets lost in the shuffle. It’s
    perfect for situations where speed is critical and a few lost bits here and there
    won’t cause a catastrophe, such as streaming video or online gaming.
  prefs: []
  type: TYPE_NORMAL
- en: UDP versus TCP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we introduce UDP in our system, we can rely upon some advantages.
  prefs: []
  type: TYPE_NORMAL
- en: 'A handful of them are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Speed**: UDP is blazingly fast due to its minimal overhead. It doesn’t bother
    with establishing connections or ensuring packet order, making it ideal where
    speed is critical.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low-latency applications**: Time-sensitive applications such as real-time
    gaming, video streaming, and **Voice over Internet Protocol** (**VoIP**) often
    favor UDP because they prioritize minimizing delay over reliability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Broadcast and multicast**: UDP can easily send data packets to multiple recipients
    on a network, either to all devices in a broadcast or to a selective group in
    a multicast. This is useful for tasks such as service discovery and resource announcements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simple applications**: If your application needs a basic request-response
    structure without the complexity of handling a full connection, UDP offers a streamlined
    approach.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom reliability**: When you need fine-grained control over how your application
    handles errors and lost packets, UDP allows you to implement your own reliability
    mechanisms tailored to your specific use case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UPD in Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Golang’s `net` package provides excellent support for UDP programming. Key
    functions/types include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`net.DialUDP()`: Establishes a UDP “connection” (more of a communication channel)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`net.ListenUDP()`: Creates a UDP listener to receive incoming packets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UDPConn`: Represents a UDP connection, providing methods such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadFromUDP()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WriteToUDP()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before creating our application using UDP, let’s keep in mind the trade-offs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature** | **UDP** | **TCP** |'
  prefs: []
  type: TYPE_TB
- en: '| Protocol type | Connectionless | Connection-oriented |'
  prefs: []
  type: TYPE_TB
- en: '| Reliability | Unreliable (no packet guarantees) | Reliable (ordered delivery,
    error correction) |'
  prefs: []
  type: TYPE_TB
- en: '| Overhead | Low | High |'
  prefs: []
  type: TYPE_TB
- en: '| Speed | Faster | Slower |'
  prefs: []
  type: TYPE_TB
- en: '| Use cases | Real-time, low-latency communication, broadcasts/multicast, applications
    with custom reliability | Applications requiring guaranteed data delivery, data
    integrity |'
  prefs: []
  type: TYPE_TB
- en: 'Traditional reliability in TCP often used a method called **Go-Back-N**. In
    the event of a lost packet, the following would happen:'
  prefs: []
  type: TYPE_NORMAL
- en: The sender would roll back and start retransmitting from the lost packet onward
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This meant even correctly received packets after the lost one got sent again
    (inefficient)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is fine for TCP due to its in-order delivery but wasteful for scenarios
    where order is less important.
  prefs: []
  type: TYPE_NORMAL
- en: In UDP, we can apply a technique called **Selective Retransmissions** (also
    known as **Selective Acknowledgments**, or **SACK**).
  prefs: []
  type: TYPE_NORMAL
- en: Selective Retransmissions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The whole idea is that the receiver keeps track of which packets have been received
    successfully, even if they arrive out of order, so that it can explicitly tell
    the sender which specific packets are missing, providing a list or range of missing
    sequence numbers. Lastly, the sender only retransmits packets the receiver marked
    as missing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can depict three major benefits of this strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding resending correctly received data, and improving bandwidth use in lossy
    conditions (particularly common over **point-of-sale** (**POS**) and edge connections)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding unnecessary stalls waiting for missing data before later packets can
    be processed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helps minimize delays when an occasional loss is tolerable, but maximizing the
    throughput of newer data is important
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sounds nice, right? Let’s explore how we can implement this on the server side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we need to import all packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s make these declarations easier to grasp. Here’s the intention of each
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`maxDatagramSize`: The maximum size of a UDP packet. This is set to 1024 bytes
    but can be adjusted based on network conditions or requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`packetLossRate`: A constant to simulate a 20% packet loss rate in the network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Packet`: A struct representing a packet with a sequence number (`SeqNum`)
    and data (`Payload`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we set these initial variables, we can advance with our `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we initialize a UDP server listening on port 5000\. `net.ResolveUDPAddr`
    is used to resolve the address on which the server listens. `net.ListenUDP` starts
    listening for UDP packets on the resolved address. `defer conn.Close()` ensures
    the server’s connection is closed properly when the function exits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a goroutine that continuously reads incoming packets. It reads the
    first 4 bytes of each packet to get the sequence number, assuming the sequence
    number is stored in the first 4 bytes. For each packet received, it sends an acknowledgment
    back to the sender using the `sendAck()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The main loop of the program creates packets with a sequence number and a test
    payload. `sendPacket()` attempts to send these packets to the client. Packet loss
    is simulated here; some packets are randomly dropped based on the `packetLossRate`
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s explore the `sendPacket()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`addr` (the client’s address) is `nil` or if `addr.IP` is `nil`. If either
    is `true`, it means there’s no valid client address to send the packet to, so
    the function returns immediately without doing anything.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`buf` byte slice with a size that can hold the packet’s sequence number (4
    bytes) plus the length of the packet’s payload. The sequence number is then placed
    at the beginning of this slice (`buf[:4]`) using `binary.BigEndian.PutUint32`,
    which ensures the number is stored in a big-endian format (network byte order).
    The payload is copied into the buffer right after the sequence number.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`rand.Float32()` and checking if this number is greater than the predefined
    `packetLossRate` value. If the condition is `true`, it proceeds to send the packet;
    otherwise, it simulates a packet loss by printing a message and not sending the
    packet.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`conn.WriteToUDP(buf, addr)`, where `buf` is the prepared data and `addr` is
    the client’s address. If the packet is successfully sent, it prints a message
    indicating the sequence number of the sent packet and the client’s address. If
    there’s an error during sending, it prints an error message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `sendAck()` function is designed to send an **acknowledgment** (**ACK**)
    packet back to a client to confirm the receipt of a packet. Here’s a breakdown
    of its operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ackPacket` with a size of 4 bytes. This size is chosen because the function
    only needs to send back the sequence number of the received packet, which is a
    `uint32` type and requires 4 bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`seqNum`) received as a parameter is encoded into the `ackPacket` byte slice
    using `binary.BigEndian.PutUint32`. This function call ensures that the sequenceencoding”
    number is stored in a big-endian format, which is a standard way of representing
    numbers in network communications. The big-endian format means the **most significant
    byte** (**MSB**) is stored first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ackPacket` back to the client using the `conn.WriteToUDP()` method, specifying
    `ackPacket` as the data to send and `addr` as the destination address. The `addr`
    parameter is the address of the client that originally sent the packet being acknowledged.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error handling**: If there’s an error in sending the ACK packet, the function
    prints an error message, as shown in the previous code snippet, to the console.
    This could happen for various reasons, such as network issues or if the client’s
    address is no longer valid:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `unpackUint32()` function is designed to extract a `uint32` value from
    a byte slice, ensuring that the byte slice is interpreted according to the big-endian
    byte order. Here’s a detailed explanation of its operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`buf` input byte slice is at least 4 bytes. This check is necessary because
    a `uint32` value requires 4 bytes, and attempting to extract a `uint32` value
    from a smaller buffer would result in an error. If the buffer is shorter than
    4 bytes, the function returns 0 for the `uint32` value and a `"buffer too` `short"`
    error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uint32` value from it. This is done using `binary.BigEndian.Uint32(buf)`,
    which reads the first 4 bytes of `buf` and interprets them as a `uint32` value
    in big-endian order. Big-endian order means that the byte slice is read with the
    MSB first. For example, if `buf` contains `[0x00, 0x00, 0x01, 0x02]` bytes, the
    resulting `uint32` value would be `258` because `0x00000102` in hexadecimal corresponds
    to `258` in decimal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uint32` value is returned along with `nil` for the error, indicating successful
    extraction:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`rand.Seed()` seeds the random number generator to ensure that the simulated
    packet loss is unpredictable.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The complete source code can be found in the `ch10` folder of the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Production scenario
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that a production-ready implementation would require more robust
    error handling and potentially more sophisticated data structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'The decision between UDP and TCP often hinges on these trade-offs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reliability versus speed**: If guaranteed delivery of all data is essential,
    TCP is the way to go. If minimizing latency and tolerating some packet loss is
    acceptable, UDP is a stronger choice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connection overhead**: If you need to transfer large volumes of data with
    a persistent connection, TCP excels. For simple message-oriented exchanges, UDP’s
    reduced overhead is appealing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**: Techniques such as Selective Retransmissions add complexity
    on both the sender and receiver sides compared to simple retransmission.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebSocket
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Then there’s WebSocket, a protocol for real-time communication between a client
    and a server. It’s like having a direct phone line between two parties, allowing
    continuous, two-way communication. This starkly contrasts with the traditional
    request/response model of HTTP, making WebSocket ideal for applications that require
    instant updates, such as live chat applications or financial tickers. In other
    words, both client and server can send data spontaneously, unlike the request-response
    model of traditional HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the connection is established through a handshake over HTTP but then upgraded
    to a long-lived TCP connection. Once established, it has minimal message framing
    overhead, making it suitable for real-time scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at a simple example of setting up a WebSocket server. For this
    example, we will be using the `gobwas/ws` library. So, we need to get the library
    by executing the following command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have it, we can try to use the library as shown in the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The key sections are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Imports**: It imports necessary packages for HTTP and WebSocket handling'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http.ListenAndServe` to start an HTTP server on port 8080'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ws.UpgradeHTTP`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handle WebSocket connection**: For each connection, it launches a goroutine
    to handle messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wsutil.ReadClientData`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wsutil.WriteServerMessage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Close connection**: Ensures the WebSocket connection is closed after handling
    messages or encountering an error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since it is an HTTP server at the end of the day, we can explore how to call
    it from another Go client and even from your browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, we have our Go client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ws.DefaultDialer.Dial` to establish a WebSocket connection to the server at
    `ws://localhost:8080`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`"Hello, server!"` message using `wsutil.WriteClientMessage`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`wsutil.ReadServerData`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Close connection**: After receiving the response,'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: he connection is closed gracefully with `defer conn.Close()`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Wait for user input**: Finally, the client waits for the user to press *Enter*
    before exiting, to ensure that the user has time to see the server’s response'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure your WebSocket server is running, and run your client by executing
    the following command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The client will connect to the server, send a message, display the server’s
    response, and wait for you to press *Enter* before exiting.
  prefs: []
  type: TYPE_NORMAL
- en: 'To connect to the WebSocket server from a browser, you can use the WebSocket
    API available in modern web browsers. First, create an HTML file (for example,
    `index.html`) that will import the `websocket.js` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create a JavaScript file (for example, `websocket.js`) that includes
    the code to connect to the WebSocket server, send messages, and receive messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Running the example, open the `index.html` file in a web browser. This establishes
    a WebSocket connection to the server running on `localhost:8080`.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript code connects to the WebSocket server, sends a `"Hello, server!"`
    message upon connection, and logs any messages received from the server to the
    console.
  prefs: []
  type: TYPE_NORMAL
- en: You can expand upon this by adding UI elements to send messages dynamically
    and display responses from the server.
  prefs: []
  type: TYPE_NORMAL
- en: There are many more combinations, designs, and options regarding networking
    programming with Go. In addition to these building blocks, we can choose an architecture
    pattern such as REST, whichever kind of messaging system makes sense to your use
    case, or even a **Remote Procedure Call** (**RPC**) framework such as gRPC. It’s
    crucial to make this decision to understand this base component of networking
    to grant us leverage on our choices and clear mental maps during troubleshooting
    sessions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reflecting on the labyrinth of advanced networking in Go, I recall a project
    that was as ambitious as it was fraught with peril. The requirements were simple
    on paper but complex in execution: real-time data synchronization across a distributed
    system with high reliability and low latency. It was a trial by fire, teaching
    me the importance of choosing the right tool for the job, the intricacies of connection
    pooling, and the delicate art of optimizing network performance.'
  prefs: []
  type: TYPE_NORMAL
- en: To sum up, mastering advanced networking in Go is like assembling a high-performance
    engine. Each part, whether it’s UDP, WebSocket, or further options, plays a critical
    role in the machine’s overall performance. Connection pooling and network optimization
    are the fine-tuning that ensures peak efficiency. Just as a well-oiled engine
    powers a car to victory in a race, a well-architected network drives an application
    to success in the digital realm. So, gear up, dive deep into the documentation,
    and may your network connections be fast, reliable, and secure.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We demystified network programming in Go. Starting with an overview of Go’s
    `net` package, the chapter introduced the fundamental building blocks of network
    programming, including establishing connections, handling data streams, and parsing
    network addresses. Through engaging examples and detailed explanations, readers
    learned to navigate the challenges of TCP socket programming, understand the nuances
    of HTTP servers and clients, and secure their applications with TLS.
  prefs: []
  type: TYPE_NORMAL
- en: By exploring both the theoretical aspects and practical implementations of network
    communication in Go, you gained a well-rounded understanding of how to build efficient,
    reliable, and secure networked applications. This knowledge not only enhances
    your Go programming skills but also prepares you for tackling complex networking
    challenges in real-world scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll examine how to observe our programs’ behavior using
    telemetry techniques, such as logging, tracing, and metrics.
  prefs: []
  type: TYPE_NORMAL
