<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer024">
			<h1 id="_idParaDest-203" class="chapter-number"><a id="_idTextAnchor240"/>12</h1>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor241"/>Distributing Your Apps</h1>
			<p>In this chapter, we will explore key concepts and practical applications of distributing your Go applications using modules, <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>), and release strategies. As <a id="_idIndexMarker662"/>we progress, you will be adept at using Go modules for dependency management, setting up CI workflows to automate testing and builds, and mastering the release process to distribute your <span class="No-Break">applications seamlessly.</span></p>
			<p>The chapter will cover the following <span class="No-Break">key topics:</span></p>
			<ul>
				<li><span class="No-Break">Go modules</span></li>
				<li><span class="No-Break">CI</span></li>
				<li>Releasing <span class="No-Break">your application</span></li>
			</ul>
			<p>By the end of this chapter, you will have acquired the knowledge to manage dependencies precisely, automate your testing and build processes to catch errors early, and efficiently package and release your applications. These skills provide the foundation for maintaining robust software projects that are easy to manage, update, and scale with the team size without adding extra layers <span class="No-Break">of bureaucracy.</span></p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor242"/>Technical requirements</h1>
			<p>All the code shown in this chapter can be found in the <strong class="source-inline">ch12</strong> directory of our <span class="No-Break"><strong class="source-inline">git</strong></span><span class="No-Break"> repository.</span></p>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor243"/>Go Modules</h1>
			<p>Go Modules, the<a id="_idIndexMarker663"/> beacon of hope in a sea of dependency chaos. Alright – maybe handling dependencies in Go isn’t <em class="italic">quite</em> as simple as a Sunday morning stroll in the park. But consider it more like planning a mission to Mars – complex, yes, but with the right tools (modules), the potential rewards <span class="No-Break">are stellar.</span></p>
			<p>Introduced in Go 1.11, Go Modules fundamentally reshaped the landscape of package management in Golang, especially pertinent in the realm of system programming. This feature provides a robust system for managing project dependencies, encapsulating specific versions of external packages your project relies on. At its core, Go Modules enables reproducible builds by leveraging a module cache and a defined set of dependencies, thus eliminating the infamous “works on my <span class="No-Break">machine” syndrome.</span></p>
			<p>Go Modules tackled <a id="_idIndexMarker664"/>several categories of issues that make the experience of using it absurdly more robust. I can highlight three of them: reliable versioning, reproducible builds, and managing dependency bloat. Let me explain the main changes before and after the Go Modules introduction for each one <span class="No-Break">of them.</span></p>
			<p>Let’s look at reliable <span class="No-Break">versioning first:</span></p>
			<ul>
				<li><strong class="bold">Before</strong>: The way dependencies were specified in Go projects left room for interpretation. It might not have been entirely clear which version of a package you were requesting. As a result of the ambiguity, you couldn’t be completely sure what code would be included in your project when you added a dependency. There was a possibility of unexpected versions or even different packages being <span class="No-Break">pulled in.</span></li>
				<li><strong class="bold">After</strong>: Introduced the concept <a id="_idIndexMarker665"/>of <strong class="bold">Semantic Versioning</strong> (<strong class="bold">SemVer</strong>), ensuring you know the kind of changes a dependency update contains, reducing <span class="No-Break">unpredictable breakages.</span></li>
			</ul>
			<p>Let’s now turn to <span class="No-Break">reproducible builds:</span></p>
			<ul>
				<li><strong class="bold">Before</strong>: Relying on external package repositories meant a build could fail later if dependencies changed <span class="No-Break">or disappeared</span></li>
				<li><strong class="bold">After</strong>: The introduction of the Go Module proxy and the ability to vendor (storing a copy of dependencies within the project) guarantees your code always builds the <span class="No-Break">same way</span></li>
			</ul>
			<p>Finally, let’s look at managing <span class="No-Break">dependency bloat:</span></p>
			<ul>
				<li><strong class="bold">Before</strong>: Nested dependencies could easily spiral out of control, adding size <span class="No-Break">and complexity</span></li>
				<li><strong class="bold">After</strong>: Go modules calculate the minimal set of required dependencies, keeping your <span class="No-Break">project lean</span></li>
			</ul>
			<p>A module is a collection of related Go packages. It serves as a “versionable” and interchangeable unit of <span class="No-Break">source code.</span></p>
			<p>Modules have two main objectives: to maintain the specific requirements of dependencies and to create <span class="No-Break">reproducible builds.</span></p>
			<p>Let’s start by<a id="_idIndexMarker666"/> imagining you’re organizing a library. This library will serve as our analogy for understanding modules, version control, and SemVer. Think of a module as a thrilling book series. Each series is a collection of related books released together, volume by volume. Just as with the <em class="italic">Harry Potter</em> series, each book contributes to the larger narrative, creating an exciting and cohesive story. Now, imagine every book in the series lists all previous volumes and specifies the exact editions required to understand the current book. This ensures that no matter where you pick up the series, you have a consistent experience, just like how modules ensure consistent builds by recording precise dependency requirements. Visualize a version control repository as a well-organized bookshelf in a library. Each bookshelf contains one complete book series, neatly arranged for readers to find and follow the series <span class="No-Break">without confusion.</span></p>
			<p>But how do they relate to each other? Simple: A <strong class="bold">repository</strong> is like a section in a library dedicated <a id="_idIndexMarker667"/>to a specific series or collection. Each <strong class="bold">module</strong> represents a book series within this section. Each book series (module) consists of individual books (packages). Finally, each book (<strong class="bold">package</strong>) contains chapters (<strong class="bold">Go source files</strong>), all within the covers (<strong class="bold">directory</strong>) of <span class="No-Break">that book.</span></p>
			<p>If using <strong class="source-inline">git</strong>, the version will be associated with the <span class="No-Break">repository’s tags.</span></p>
			<p class="callout-heading">SemVer</p>
			<p class="callout">SemVer (<strong class="source-inline">Major.Minor.Patch</strong>) uses a numbering system to indicate what kind of changes (breaking, new features, bug fixes) are included in a software update. The full SemVer specification <a id="_idIndexMarker668"/>can be found <span class="No-Break">at </span><a href="https://semver.org/"><span class="No-Break">https://semver.org/</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor244"/>The routine using modules</h2>
			<p>The<a id="_idIndexMarker669"/> workflow for a sunny day would be <span class="No-Break">the following:</span></p>
			<ol>
				<li>Add the imports in your <strong class="source-inline">.go</strong> files <span class="No-Break">as needed.</span></li>
				<li>The <strong class="source-inline">go build</strong> or <strong class="source-inline">go test</strong> commands will automatically add new dependencies to satisfy the imports (automatically updating the <strong class="source-inline">go.mod</strong> file and downloading the <span class="No-Break">new dependencies).</span></li>
			</ol>
			<p>There will be times when it is necessary to choose specific versions of a dependency. In such cases, the <strong class="source-inline">go get</strong> command should <span class="No-Break">be used.</span></p>
			<p>The format for the <strong class="source-inline">go get</strong> command is <strong class="source-inline">&lt;module-name&gt;@&lt;version&gt;</strong>, as in the <span class="No-Break">following example:</span></p>
			<pre class="console">
go get foo@v1.2.3</pre>			<p class="callout-heading">Changing the module file directly</p>
			<p class="callout">It is also possible to change the <strong class="source-inline">go.mod</strong> file directly, if necessary. In any case, prefer to let the <strong class="source-inline">Go</strong> commands make changes to <span class="No-Break">the file.</span></p>
			<p>Let’s explore how to use them, first, by creating our <span class="No-Break">first module.</span></p>
			<h3>Creating a new module</h3>
			<p>Let’s start <a id="_idIndexMarker670"/>by creating a new Go module for <span class="No-Break">our project.</span></p>
			<p>The first step is to set up <span class="No-Break">our workspace:</span></p>
			<pre class="console">
mkdir mybestappever
cd mybestappever</pre>			<p>We can initialize our module by running a <span class="No-Break">simple command:</span></p>
			<pre class="console">
<strong class="source-inline">go mod init github.com/yourusername/mybestappever</strong>.</pre>			<p>This command creates a <strong class="source-inline">go.mod</strong> file that will keep track of your <span class="No-Break">module’s dependencies.</span></p>
			<p>Assume we<a id="_idIndexMarker671"/> have a new <strong class="source-inline">main.go</strong> file with the <span class="No-Break">following content:</span></p>
			<pre class="source-code">
package main
import (
    "context"
    "fmt"
    "time"
    "github.com/alexrios/timer/v2"
)
func main() {
sw := &amp;timer.Stopwatch{}
ctx, cancel := context.WithCancel(context.Background())
defer cancel()
if err := sw.Start(ctx); err != nil {
    fmt.Printf("Failed to start stopwatch: %v\n", err)
    return
}
time.Sleep(1 * time.Second)
sw.Stop()
elapsed, err := sw.Elapsed()
if err != nil {
    fmt.Printf("Failed to get elapsed time: %v\n", err)
    return
}
fmt.Printf("Elapsed time: %v\n", elapsed)
}</pre>			<p>Also, let’s assume<a id="_idIndexMarker672"/> we have a <strong class="source-inline">main_test.go</strong> file with the <span class="No-Break">following content:</span></p>
			<pre class="source-code">
package main
import (
    "context"
    "testing"
    "time"
    "github.com/alexrios/timer/v2"
)
func TestStopwatch(t *testing.T) {
    sw := &amp;timer.Stopwatch{}
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    if err := sw.Start(ctx); err != nil {
        t.Fatalf("Failed to start stopwatch: %v", err)
    }
    time.Sleep(1 * time.Second)
    sw.Stop()
    elapsed, err := sw.Elapsed()
    if err != nil {
        t.Fatalf("Failed to get elapsed time: %v", err)
    }
    if elapsed &lt; 1*time.Second || elapsed &gt; 2*time.Second {
        t.Errorf("Expected elapsed time around 1 second, got %v", elapsed)
    }
}</pre>			<p>Execute the<a id="_idIndexMarker673"/> tests using the <strong class="source-inline">go test</strong> command. When you run it, the Go tool automatically resolves any new dependencies, updates the <strong class="source-inline">go.mod</strong> file, and downloads the <span class="No-Break">necessary modules.</span></p>
			<p>If you check the <strong class="source-inline">go.mod</strong> file, you should see a new line for <span class="No-Break">the dependency:</span></p>
			<pre class="source-code">
require github.com/alexrios/timer/v2 v2.0.0</pre>			<h3>Understanding module versioning</h3>
			<p>Go uses a <strong class="bold">Minimal Version Selection</strong> (<strong class="bold">MVS</strong>) algorithm<a id="_idIndexMarker674"/> to manage dependencies. MVS ensures that the build uses the minimal versions of modules that satisfy the requirements of the <span class="No-Break"><strong class="source-inline">go.mod</strong></span><span class="No-Break"> file.</span></p>
			<p>When you build<a id="_idIndexMarker675"/> or test a Go module, MVS determines the set of module versions to use based on the version requirements specified in the <strong class="source-inline">go.mod</strong> files of your module and its dependencies. Here’s how MVS resolves <span class="No-Break">these versions:</span></p>
			<ul>
				<li><strong class="bold">Starting point</strong>: The process starts with your module’s <strong class="source-inline">go.mod</strong> file, which specifies the versions of <span class="No-Break">direct dependencies.</span></li>
				<li><strong class="bold">Propagating requirements</strong>: MVS reads the <strong class="source-inline">go.mod</strong> files of the direct dependencies to gather their dependencies and their required versions. This process continues recursively for <span class="No-Break">all dependencies.</span></li>
				<li><strong class="bold">Selecting versions</strong>: MVS selects the highest required version for each module among all the <strong class="source-inline">go.mod</strong> files that mention it. The highest required version is considered the minimal version that satisfies all <span class="No-Break">version requirements.</span></li>
				<li><strong class="bold">Minimizing versions</strong>: The algorithm ensures that the minimal version of each module is selected, meaning no higher version than necessary is chosen. This reduces the risk of introducing unintended changes <span class="No-Break">or incompatibilities.</span></li>
			</ul>
			<p>By always selecting the minimal versions that satisfy all requirements, MVS avoids unnecessary upgrades and reduces the risk of introducing breaking changes from <span class="No-Break">dependency updates.</span></p>
			<p>To list the current module and all its dependencies, you can use the <strong class="source-inline">go </strong><span class="No-Break"><strong class="source-inline">list</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
go list -m all</pre>			<p>The output will include the main module followed by <span class="No-Break">its dependencies:</span></p>
			<pre class="console">
github.com/yourusername/mybestappever
github.com/alexrios/timer/v2 v2.0.0</pre>			<p>Hey! There is a new file in the <span class="No-Break">folder: </span><span class="No-Break"><strong class="source-inline">go.sum</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">go.sum</strong> file contains<a id="_idIndexMarker676"/> checksums of the content of specific module versions. This ensures that the same module versions are used consistently across builds. Here’s an example of what you might see in a <span class="No-Break"><strong class="source-inline">go.sum</strong></span><span class="No-Break"> file:</span></p>
			<pre class="console">
github.com/alexrios/timer/v2 v2.0.0 h1:...
github.com/alexrios/timer/v2 v2.0.0/go.mod h1:...</pre>			<h3>Updating dependencies</h3>
			<p>To <a id="_idIndexMarker677"/>update a dependency to the latest version, we can use the <strong class="source-inline">go </strong><span class="No-Break"><strong class="source-inline">get</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
go get github.com/alexrios/timer@latest</pre>			<p>To update to a specific version, specify the <span class="No-Break">version explicitly:</span></p>
			<pre class="console">
go get github.com/yourusername/timer@v1.1.0</pre>			<p>Sometimes, you need to specify exact versions of dependencies. You can do this directly in the <strong class="source-inline">go.mod</strong> file or by using the <strong class="source-inline">go get</strong> command, as shown previously. This is useful for ensuring compatibility or needing specific features or bug fixes from a <span class="No-Break">particular version.</span></p>
			<h3>Semantic import versioning</h3>
			<p>Go <a id="_idIndexMarker678"/>modules follow SemVer, which uses version numbers to convey meaning about the stability and compatibility of releases. The versioning scheme <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">v&lt;MAJOR&gt;.&lt;MINOR&gt;.&lt;PATCH&gt;</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>Major versions indicate incompatible <span class="No-Break">API changes</span></li>
				<li>Minor versions add functionality in a <span class="No-Break">backward-compatible manner</span></li>
				<li>Patch versions include backward-compatible <span class="No-Break">bug fixes</span></li>
			</ul>
			<p>For example, <strong class="source-inline">v1.2.3</strong> indicates major version 1, minor version 2, and patch <span class="No-Break">version 3.</span></p>
			<p>When a module reaches version 2 or higher, the major version must be included in the module path. For example, version 2 of <strong class="source-inline">github.com/alexrios/timer</strong> is identified <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">github.com/alexrios/timer/v2</strong></span><span class="No-Break">.</span></p>
			<p>You can trigger the dependencies verification at any time using the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
<strong class="source-inline">go mod tidy</strong></pre>			<p>The <strong class="source-inline">go mod tidy</strong> command in Go is essential for maintaining clean and accurate <strong class="source-inline">go.mod</strong> and <strong class="source-inline">go.sum</strong> files. It scans your project’s source code to determine which dependencies are used, adding missing ones and removing unused ones from the <strong class="source-inline">go.mod</strong> file. Additionally, it updates the <strong class="source-inline">go.sum</strong> file to ensure consistent checksums for all <a id="_idIndexMarker679"/>dependencies. This process helps to keep your project free from unnecessary dependencies, reduces security risks, ensures reproducible builds, and makes dependency management more manageable. Regularly using <strong class="source-inline">go mod tidy</strong> ensures that your Go project’s dependencies are up to date and accurately reflect the code <span class="No-Break">base’s requirements.</span></p>
			<p>The <strong class="source-inline">github.com/alexrios/timer</strong> library is public, but in your company, you’ll probably use closed source libraries, commonly called private libraries. Let’s see how to <span class="No-Break">use them.</span></p>
			<h3>Using private libraries</h3>
			<p>When<a id="_idIndexMarker680"/> working with Go modules that are hosted in private repositories, you need a setup that ensures secure and direct access, bypassing the public Go module proxy. This section will walk you through configuring Git and the Go environment for seamless work with private Go modules <span class="No-Break">on GitHub.</span></p>
			<p>First, you need to navigate to your home directory and open the <strong class="source-inline">.gitconfig</strong> file, adding the <span class="No-Break">following configuration:</span></p>
			<pre class="source-code">
[url "ssh://git@github.com/"]
    insteadOf = https://github.com/</pre>			<p>These lines tell Git to automatically use SSH (<strong class="source-inline">ssh://git@github.com/</strong>) whenever it encounters a GitHub URL that starts <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">https://github.com/</strong></span><span class="No-Break">.</span></p>
			<p>Once it’s done, we can now configure the Go environment for <span class="No-Break">private modules.</span></p>
			<p>The <strong class="source-inline">GOPRIVATE</strong> environment variable <a id="_idIndexMarker681"/>prevents the Go tools from attempting to fetch modules listed in it from the public Go module mirror or proxy. Instead, it fetches them directly from their source, which is necessary for <span class="No-Break">private modules.</span></p>
			<p>You <a id="_idIndexMarker682"/>should set <strong class="source-inline">GOPRIVATE</strong> for a single private repository by running the following command in your terminal, replacing <strong class="source-inline">&lt;org&gt;</strong> and <strong class="source-inline">&lt;project&gt;</strong> with your GitHub organization and <span class="No-Break">repository name:</span></p>
			<pre class="console">
go env -w GOPRIVATE="github.com/&lt;org&gt;/&lt;project&gt;"</pre>			<p>Alternatively, set <strong class="source-inline">GOPRIVATE</strong> for<a id="_idIndexMarker683"/> all repositories in an organization. If you work with multiple private repositories under the same organization, it’s convenient to use a wildcard (<strong class="source-inline">*</strong>) to cover <span class="No-Break">them all:</span></p>
			<pre class="console">
go env -w GOPRIVATE="github.com/&lt;org&gt;/*"</pre>			<p>Here are some <span class="No-Break">additional tips:</span></p>
			<ul>
				<li><strong class="bold">Verify your GOPRIVATE settings</strong>: Use <strong class="source-inline">go env GOPRIVATE</strong> to display the <span class="No-Break">current settings.</span></li>
				<li><strong class="bold">Using SSH keys with GitHub</strong>: Ensure your SSH keys are set up and added to your GitHub account. This setup allows you to push to and pull from your repositories without entering your username and password <span class="No-Break">each time.</span></li>
				<li><strong class="bold">Troubleshooting</strong>: If you encounter issues with accessing private repositories, verify your SSH key is loaded into the SSH agent. You can add your SSH key to the SSH agent by running <strong class="source-inline">ssh-add ~/.ssh/your-ssh-key</strong> (replace <strong class="source-inline">your-ssh-key</strong> with the path to your <span class="No-Break">SSH key).</span></li>
			</ul>
			<p>You’ve configured your environment to securely work with Go modules housed in private GitHub repositories! This setup simplifies development workflows by automating authentication for Git operations and ensuring direct, secure access to your private <span class="No-Break">Go modules.</span></p>
			<h3>Version control and go install</h3>
			<p>The <a id="_idIndexMarker684"/>most fundamental way is to host your Go program code in a public version control repository (such as GitHub, GitLab, and so on). Users with Go installed can then use <a id="_idIndexMarker685"/>the <strong class="source-inline">go install</strong> command followed by your repository’s URL to fetch, compile, and install <span class="No-Break">your program.</span></p>
			<p>In the root of our module, we can simply execute the <span class="No-Break">following command:</span></p>
			<pre class="console">
go install</pre>			<p>This makes the<a id="_idIndexMarker686"/> program accessible from any directory on your system by just typing its name in the terminal. To test if the installation worked, open a <strong class="bold">new</strong> terminal window and type <span class="No-Break">the following:</span></p>
			<pre class="console">
hello</pre>			<p>With <strong class="source-inline">go install</strong>, your compiled programs live <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">$GOPATH/bin</strong></span><span class="No-Break">.</span></p>
			<p>Since version 1.16, the <strong class="source-inline">go install</strong> command can install a Go executable from a <span class="No-Break">specific version.</span></p>
			<p>To make it simple to grasp, let’s use the <a href="https://github.com/alexrios/endpoints">https://github.com/alexrios/endpoints</a> repository as <span class="No-Break">our target.</span></p>
			<p>This repository has a <strong class="source-inline">v0.5.0</strong> tag, so to install this specific version, we can run <span class="No-Break">the following:</span></p>
			<pre class="console">
go install github.com/alexrios/endpoints@v0.5.0</pre>			<p>When you don’t know or don’t want to discover what is the latest version of the executable, you can simply use <span class="No-Break"><strong class="source-inline">latest</strong></span><span class="No-Break"> instead:</span></p>
			<pre class="console">
go install github.com/alexrios/endpoints@latest</pre>			<p>Note that within the Go ecosystem, you can install other executables without any special tool or process. Pretty <span class="No-Break">powerful, huh?</span></p>
			<p>But what about projects with multiple modules? How easily we can deal with them? Quick answer: Not easy at all before Go <span class="No-Break">version 1.18.</span></p>
			<p>Instead of introducing all folklore and the nightmares of Go early days, let’s go “back to the future” and keep our focus on how easily we can do it. Version 1.18 introduced the concept of <span class="No-Break">module workspaces.</span></p>
			<h3>Module workspaces</h3>
			<p>A <a id="_idIndexMarker687"/>Go module workspace is a way to group multiple Go modules that belong to the same project. This feature, introduced to tackle the very beast of dependency management, allows developers to work with multiple modules simultaneously. They aren’t just about neatness. It fundamentally changes how the Go toolchain <span class="No-Break">resolves dependencies.</span></p>
			<p>A Go workspace is a directory containing a unique <strong class="source-inline">go.work</strong> file referencing one or more <strong class="source-inline">go.mod</strong> files, each representing a module. This setup permits us to build, test, and manage multiple interrelated modules without the usual headaches of <span class="No-Break">version conflicts.</span></p>
			<p>Within a workspace, the Go compiler treats them as peers instead of relying on an external <strong class="source-inline">go.mod</strong> file for each module. It looks at the workspace’s <strong class="source-inline">go.work</strong> file, which lists all modules within the project, making sure everyone plays <span class="No-Break">nicely together.</span></p>
			<p>In other words, workspaces create a self-contained ecosystem for your project. Any changes you make within one module immediately ripple across the others. This streamlines development, particularly when juggling interconnected components of a <span class="No-Break">larger application.</span></p>
			<p>Enough talk; let’s see it in action. Consider this simple <span class="No-Break">workspace setup:</span></p>
			<pre class="console">
go work init ./myproject
go work use ./moduleA
go work use ./moduleB</pre>			<p>The <strong class="source-inline">go.work</strong> file acts <a id="_idIndexMarker688"/>as the orchestrator within this workspace. It ensures that when you run your Go commands, all referenced modules are considered as part of a single unified code base. This is particularly handy when you are developing interdependent modules or when you want to test local changes across modules without committing <span class="No-Break">them upstream.</span></p>
			<p>With this configuration, both <strong class="source-inline">moduleA</strong> and <strong class="source-inline">moduleB</strong> are part of the same workspace, allowing seamless integration testing <span class="No-Break">and development.</span></p>
			<p>The practical implications are profound. Suppose you have two modules: <strong class="source-inline">moduleA</strong> and <strong class="source-inline">moduleB</strong>. <strong class="source-inline">moduleA</strong> depends on <strong class="source-inline">moduleB</strong>. Traditionally, updating <strong class="source-inline">moduleB</strong> could be a nightmare of version pinning and backward compatibility. With a workspace, however, you can modify both modules at once and test the integrations in <span class="No-Break">real time.</span></p>
			<p>Here’s a simple <strong class="source-inline">go.work</strong> file <span class="No-Break">to illustrate:</span></p>
			<pre class="source-code">
go 1.21
use (
    ./path/to/module-a
    ./path/to/module-b
)</pre>			<p>The last<a id="_idIndexMarker689"/> bit of the adventure with module workspaces is to synchronize modifications within <span class="No-Break">the workspace.</span></p>
			<p>Every time we change a <strong class="source-inline">go.mod</strong> file <a id="_idIndexMarker690"/>from our modules or add or remove modules from our workspace, we should run <span class="No-Break">the following:</span></p>
			<pre class="console">
go work sync</pre>			<p>This command will keep us away from problems such as <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Inconsistency</strong>: The changes you made to the <strong class="source-inline">go.mod</strong> file will be out of sync with your <strong class="source-inline">go.work</strong> file. This discrepancy can lead to confusion and <span class="No-Break">potential errors.</span></li>
				<li><strong class="bold">Unexpected build/test behavior</strong>: When you run commands such as <strong class="source-inline">go build</strong> or <strong class="source-inline">go test</strong>, there are a few scenarios depending on how Go is <span class="No-Break">resolving dependencies:</span><ul><li><strong class="bold">Go might ignore your changes</strong>: If the required version according to your <strong class="source-inline">go.work</strong> file is already cached locally, Go might use the cached version instead of the one you specified in the <span class="No-Break">modified </span><span class="No-Break"><strong class="source-inline">go.mod</strong></span><span class="No-Break">.</span></li><li><strong class="bold">Builds might break</strong>: If your change introduces incompatible dependency versions or the required version is not available, your builds and tests <span class="No-Break">could fail.</span></li><li><strong class="bold">Issues with collaboration</strong>: If you’re working with others on a project, inconsistent dependency declarations can lead to problems with builds reproducing on <span class="No-Break">different machines.</span></li></ul></li>
			</ul>
			<p>If you forget this command, it can lead to wasted time debugging unexpected build failures caused by misaligned dependencies. Also, it might be difficult to track down the root cause of issues if you forget that you’ve <a id="_idIndexMarker691"/>manually modified a <strong class="source-inline">go.mod</strong> file. From a team collaboration perspective, the project becomes harder to maintain when different developers’ environments have diverging <span class="No-Break">dependency states.</span></p>
			<p>This<a id="_idIndexMarker692"/> approach to module management isn’t just about keeping your sanity intact—it’s about fostering an environment where logistical nightmares don’t bog down innovation. So, the next time you find yourself juggling Go modules, remember that workspaces are your friend, not just another layer of complexity to <span class="No-Break">your project.</span></p>
			<p>Although our module knowledge is ready to be tested, we want to ensure that everything is running smoothly and (hopefully) without bugs. This is when CI <span class="No-Break">takes place.</span></p>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor245"/>CI</h1>
			<p>CI is like a <a id="_idIndexMarker693"/>babysitter for your code. Ha! If you believe that, you’ve probably never tried wrestling a herd of untamed microservices into a semblance of order while simultaneously battling an infrastructure that melts down faster than a popsicle in the <span class="No-Break">Sahara Desert.</span></p>
			<p>Let’s be real – CI is more like wrangling a multi-headed hydra: one head spews out unit tests, another spits out integration tests, and somewhere in the tangled mess, there’s probably a build pipeline and deployment lurking about. CI, done right, is less about babysitting and more like a brutal code boot camp with an unforgiving <span class="No-Break">drill sergeant.</span></p>
			<p>So, what the heck is CI, as the cool kids call it? In the realm of Go, particularly for system programming, CI is the art of constantly merging code changes into a shared repository and relentlessly testing the living daylights out of the result. It’s about catching errors early, ensuring that new code doesn’t break the whole system, and automating those tedious tasks that would otherwise have us all weeping into <span class="No-Break">our keyboards.</span></p>
			<p>Think of CI as your automated code quality control. It’s where you put build scripts and test suites, maybe toss in some static analysis and linting for good measure, and then wire it all together to run every time someone commits a change. Why, you ask? Well, because nothing builds character in a code base quite like breaking it repeatedly and forcing your teammates to <span class="No-Break">fix it.</span></p>
			<p>Let’s get practical. Here’s a snippet of how a basic CI setup with GitHub Actions might look for your <a id="_idIndexMarker694"/><span class="No-Break">Go project:</span></p>
			<pre class="source-code">
name: Go CI on Commit
on:
  push:
jobs:
  test-and-dependencies:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Go
        uses: actions/setup-go@v3
        with:
          go-version: '^1.21'
      - name: Get dependencies
        run: go mod download
      - name: Run tests
        run: go test -v ./...</pre>			<h2 id="_idParaDest-209"><a id="_idTextAnchor246"/>Caching</h2>
			<p>Leveraging a cache<a id="_idIndexMarker695"/> mechanism is the difference between watching your builds chug along like a rusty steam engine and witnessing the sleek efficiency of a high-speed bullet train. Let’s see how we can make those dependency downloads a relic of <span class="No-Break">the past.</span></p>
			<p>Imagine your CI pipeline is the tireless factory worker, and those dependencies are the raw materials it needs to keep production humming. Every time your build process spins up, it has to fetch all the dependencies fresh, slowing things down and making a racket in the process. Caching is like building a well-stocked warehouse right next to your factory – the next time you need those materials, no need for an expedition, just a quick trip to <span class="No-Break">the warehouse.</span></p>
			<p>The key to <a id="_idIndexMarker696"/>caching your Go dependencies in CI lies in understanding <span class="No-Break">two things:</span></p>
			<ul>
				<li><strong class="bold">Where dependencies live</strong>: Go stores its downloaded dependencies in the Go module cache, usually located at <strong class="source-inline">~/go/pkg/mod</strong>. This is <span class="No-Break">our warehouse.</span></li>
				<li><strong class="bold">How CI workflows store stuff</strong>: Most CI systems, such as GitHub Actions, have built-in mechanisms for caching files or directories between <span class="No-Break">workflow runs.</span></li>
			</ul>
			<p>Let’s marry those concepts. Here’s how you’d modify a basic GitHub Actions workflow to cache <span class="No-Break">Go dependencies:</span></p>
			<pre class="source-code">
name: Go CI on Commit
on:
  push:
jobs:
  test-and-dependencies:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Go
        uses: actions/setup-go@v3
        with:
          go-version: '^1.21'
      - name: Cache Go modules
        uses: actions/cache@v3
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-
      - name: Get dependencies
        run: go mod download
      - name: Run tests
        run: go test -v ./...</pre>			<p>The magic <a id="_idIndexMarker697"/>happens in the Cache Go <span class="No-Break">dependencies step:</span></p>
			<ul>
				<li><strong class="source-inline">actions/cache@v3</strong>: This is the trusty GitHub Actions tool <span class="No-Break">for caching.</span></li>
				<li><strong class="source-inline">path</strong>: We tell it to cache our Go <span class="No-Break">module directory.</span></li>
				<li><strong class="source-inline">key</strong>: This uniquely identifies your cache. Notice it includes a hash of your <strong class="source-inline">go.sum</strong> file; if dependencies change, a new cache <span class="No-Break">is created.</span></li>
				<li><strong class="source-inline">restore-keys</strong>: Provides a fallback in case the exact key <span class="No-Break">isn’t found.</span></li>
			</ul>
			<p>Think of caching like this: your CI pipeline leaves a little breadcrumb trail each time it runs. The next time around, it checks for those breadcrumbs and, if found, grabs your pre-packaged dependencies instead of venturing out for a <span class="No-Break">fresh download.</span></p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor247"/>Static analysis</h2>
			<p>Static analysis tools <a id="_idIndexMarker698"/>act as an automated code review squad, tirelessly inspecting your Go code for potential pitfalls, deviations from best practices, and even subtle style inconsistencies. It’s like having a team of meticulous programmers constantly looking over your shoulder but without the awkward <span class="No-Break">code-breathing-down-your-neck sensation.</span></p>
			<p>Let’s integrate<a id="_idIndexMarker699"/> Staticcheck (<a href="https://staticcheck.dev/">https://staticcheck.dev/</a>), the vigilant code inspector, into your Go CI workflow to help you maintain pristine <span class="No-Break">code quality.</span></p>
			<p>Staticcheck<a id="_idIndexMarker700"/> steps beyond basic linting, delving deeper to identify potential bugs, inefficient code patterns, and even subtle style issues that could affect your Go code’s quality. It’s your automated code detective, tirelessly searching for problems that might slip past <span class="No-Break">cursory inspections.</span></p>
			<p>Let’s harness the power of GitHub Actions and the <strong class="source-inline">dominikh/staticcheck-action</strong> action to streamline our integration for <span class="No-Break">our workflow.</span></p>
			<p>While you can install and execute Staticcheck directly in your workflow, using a pre-built GitHub action <a id="_idIndexMarker701"/>offers <span class="No-Break">several advantages:</span></p>
			<ul>
				<li><strong class="bold">Simplified setup</strong>: The action handles installation and execution details for you, reducing workflow <span class="No-Break">configuration complexity</span></li>
				<li><strong class="bold">Potential caching</strong>: Some actions may provide automatic caching of Staticcheck results to speed up <span class="No-Break">future runs</span></li>
				<li><strong class="bold">Community-driven</strong>: Many actions are actively maintained, ensuring compatibility with the latest Go and <span class="No-Break">Staticcheck versions</span></li>
			</ul>
			<p>Here’s how your modified workflow would look using <span class="No-Break">this action:</span></p>
			<pre class="source-code">
name: Go CI
on: [push]
jobs:
  build-test-staticcheck:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: dominikh/staticcheck-action@v1.2.0
        with:
          # Optionally specify Staticcheck version:
          # version: latest</pre>			<p>Key points <a id="_idIndexMarker702"/>are <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Simplified usage</strong>: Notice how clean the integration is; you mainly reference the action (<strong class="source-inline">dominikh/staticcheck-action</strong>) and optionally customize <span class="No-Break">its version</span></li>
				<li><strong class="bold">Version control</strong>: Pinning the action version (<strong class="source-inline">v1.2.0</strong>) ensures consistent behavior across <span class="No-Break">CI runs</span></li>
			</ul>
			<p class="callout-heading">staticcheck-action configuration</p>
			<p class="callout">Consult the action’s documentation (<a href="https://github.com/dominikh/staticcheck-action">https://github.com/dominikh/staticcheck-action</a>) for supported options such as specifying the <span class="No-Break">Staticcheck version.</span></p>
			<h1 id="_idParaDest-211"><a id="_idTextAnchor248"/>Releasing your application</h1>
			<p>Sure – your unit tests <a id="_idIndexMarker703"/>are a thing of beauty, and you might even be flirting with code coverage nirvana. But the real test, my friend, comes when you must package that masterpiece you created and ship it out into the wild – that’s where GoReleaser (<a href="https://goreleaser.com/">https://goreleaser.com/</a>) enters <a id="_idIndexMarker704"/>the scene, ready to transform your release process from a cringe-worthy ordeal into a symphony <span class="No-Break">of automation.</span></p>
			<p>Forget building binaries for every blasted OS or agonizing over tarballs and checksums. Imagine a world where your release woes are as mythical as a harmonious coding session where absolutely nothing breaks. Enter the realm of cross-compilation, automatic version tagging, Docker image creation, Homebrew taps... GoReleaser isn’t just a tool; it’s your release-day <span class="No-Break">sanity preserver.</span></p>
			<p>In essence, GoReleaser is <a id="_idIndexMarker705"/>your personal release butler. You describe how you want your precious Go application packaged and distributed, and it handles the nitty-gritty<a id="_idIndexMarker706"/> details with the efficiency of a seasoned assembly line. Need a shiny new GitHub release with pre-built binaries for every known operating system? Check. Want to push Docker images to your favorite registry? <span class="No-Break">Easy peasy.</span></p>
			<pre class="source-code">
builds:
-   ldflags:
      - -s -w
      - -extldflags "-static"
    env:
      - CGO_ENABLED=0
    goos:
      - linux
      - windows
      - darwin
    goarch:
      - amd64
    mod_timestamp: '{{ .CommitTimestamp }}'
archives:
-   name_template: "{{ .ProjectName }}_{{ .Version }}_{{ .Os }}_{{ .Arch }}"
    wrap_in_directory: true
    format: binary
    format_overrides:
      - goos: windows
        format: zip
dockers:
  - image_templates:
      - "ghcr.io/alexrios/endpoints:{{ .Tag }}"
      - "ghcr.io/alexrios/endpoints:v{{ .Major }}"
      - "ghcr.io/alexrios/endpoints:v{{ .Major }}.{{ .Minor }}"
      - "ghcr.io/alexrios/endpoints:latest"</pre>			<p>Great! Now, we <a id="_idIndexMarker707"/>want to make our binaries available every time we tag our repository. To make this happen, we should use a new workflow with the <span class="No-Break">GoReleaser job:</span></p>
			<pre class="source-code">
name: GoReleaser
on:
  push:
    tags:
      - '*'
jobs:
  goreleaser:
    runs-on: ubuntu-latest
    permissions:
      packages: write
      contents: write
    steps:
      -
        name: Checkout
        uses: actions/checkout@v2
        with:
          fetch-depth: 0
      -
        name: Set up Go
        uses: actions/setup-go@v2
        with:
          go-version: 1.21
      -
        name: Run GoReleaser
        uses: goreleaser/goreleaser-action@v2
        with:
          version: latest
          args: release --rm-dist --clean
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}</pre>			<p>I remember<a id="_idIndexMarker708"/> that time when I spent the whole afternoon manually crafting release notes, praying you didn’t miss a critical bug fix. With GoReleaser, I learned to laugh at my past misery. It gleefully autogenerates release notes, tweets the announcement, and probably even bakes celebratory cookies if you ask nicely (well, maybe not <span class="No-Break">the cookies).</span></p>
			<p>Much like a wise old general inspecting the troops, I learned the hard way that a solid CI setup is worth its weight in “bug-free” code. Back in the prehistoric era before CI, we’d spend days, sometimes weeks, untangling monstrous integration messes that only surfaced right before a release. CI is the antidote to that kind <span class="No-Break">of chaos.</span></p>
			<p>Let’s think about CI like a high-stakes synchronization dance: small, frequent changes integrated continuously are a graceful waltz. Big, infrequent merges? Well, that’s like a mosh pit, and nobody <a id="_idIndexMarker709"/>walks away from <span class="No-Break">those unscathed.</span></p>
			<h1 id="_idParaDest-212"><a id="_idTextAnchor249"/>Summary</h1>
			<p>Throughout this chapter, we explored methods and tools for distributing Go applications. We focused on the meticulous management of dependencies, the automation of testing and integration processes, and strategies for efficient software release. We started with Go modules and workspaces, discussing how they enhance project consistency and reliability through better dependency management. We then explored CI and its critical role in maintaining high software quality. Lastly, we covered the essentials of deploying applications using GoReleaser, which simplifies the release process by automating packaging and distribution across different platforms. These are key concepts and tools that will form the foundation of your <span class="No-Break">Capstone project.</span></p>
			<p>As you move toward the Capstone project in the next chapter, you will have the opportunity to apply all the knowledge and skills acquired throughout the book. This final project is designed to consolidate your understanding and proficiency in a real-world scenario, challenging you to implement a complete solution from start to finish using the best practices and <span class="No-Break">tools discussed.</span></p>
			<p>The Capstone project will testify to your learning journey and valuable work, showcasing your capabilities to effectively develop, manage, automate, and release robust applications. I’m excited about this – <span class="No-Break">aren’t you?</span></p>
		</div>
	</div>
</div>


<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer025" class="Content">
			<h1 id="_idParaDest-213" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor250"/>Part 5: Going Beyond</h1>
			<p>In this part, we will dive into the intricacies of building a distributed cache and explore essential system programming practices. You will learn how to design, implement, and optimize a distributed cache system, along with effective coding practices and strategies for staying updated in the system <span class="No-Break">programming community.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B21662_13.xhtml#_idTextAnchor251"><em class="italic">Chapter 13</em></a>, <em class="italic">Capstone Project</em><em class="italic"> - Distributed Cache</em></li>
				<li><a href="B21662_14.xhtml#_idTextAnchor269"><em class="italic">Chapter 14</em></a>, <em class="italic">Effective Coding Practices</em></li>
				<li><a href="B21662_15.xhtml#_idTextAnchor288"><em class="italic">Chapter 15</em></a>, <em class="italic">Stay Sharp with System Programming</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer026">
			</div>
		</div>
	</div>
</div>
</body></html>