- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Distributing Your Apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore key concepts and practical applications of
    distributing your Go applications using modules, **continuous integration** (**CI**),
    and release strategies. As we progress, you will be adept at using Go modules
    for dependency management, setting up CI workflows to automate testing and builds,
    and mastering the release process to distribute your applications seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter will cover the following key topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Go modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Releasing your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have acquired the knowledge to manage dependencies
    precisely, automate your testing and build processes to catch errors early, and
    efficiently package and release your applications. These skills provide the foundation
    for maintaining robust software projects that are easy to manage, update, and
    scale with the team size without adding extra layers of bureaucracy.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code shown in this chapter can be found in the `ch12` directory of our
    `git` repository.
  prefs: []
  type: TYPE_NORMAL
- en: Go Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go Modules, the beacon of hope in a sea of dependency chaos. Alright – maybe
    handling dependencies in Go isn’t *quite* as simple as a Sunday morning stroll
    in the park. But consider it more like planning a mission to Mars – complex, yes,
    but with the right tools (modules), the potential rewards are stellar.
  prefs: []
  type: TYPE_NORMAL
- en: Introduced in Go 1.11, Go Modules fundamentally reshaped the landscape of package
    management in Golang, especially pertinent in the realm of system programming.
    This feature provides a robust system for managing project dependencies, encapsulating
    specific versions of external packages your project relies on. At its core, Go
    Modules enables reproducible builds by leveraging a module cache and a defined
    set of dependencies, thus eliminating the infamous “works on my machine” syndrome.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go Modules tackled several categories of issues that make the experience of
    using it absurdly more robust. I can highlight three of them: reliable versioning,
    reproducible builds, and managing dependency bloat. Let me explain the main changes
    before and after the Go Modules introduction for each one of them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at reliable versioning first:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Before**: The way dependencies were specified in Go projects left room for
    interpretation. It might not have been entirely clear which version of a package
    you were requesting. As a result of the ambiguity, you couldn’t be completely
    sure what code would be included in your project when you added a dependency.
    There was a possibility of unexpected versions or even different packages being
    pulled in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**After**: Introduced the concept of **Semantic Versioning** (**SemVer**),
    ensuring you know the kind of changes a dependency update contains, reducing unpredictable
    breakages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s now turn to reproducible builds:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Before**: Relying on external package repositories meant a build could fail
    later if dependencies changed or disappeared'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**After**: The introduction of the Go Module proxy and the ability to vendor
    (storing a copy of dependencies within the project) guarantees your code always
    builds the same way'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, let’s look at managing dependency bloat:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Before**: Nested dependencies could easily spiral out of control, adding
    size and complexity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**After**: Go modules calculate the minimal set of required dependencies, keeping
    your project lean'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A module is a collection of related Go packages. It serves as a “versionable”
    and interchangeable unit of source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modules have two main objectives: to maintain the specific requirements of
    dependencies and to create reproducible builds.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by imagining you’re organizing a library. This library will serve
    as our analogy for understanding modules, version control, and SemVer. Think of
    a module as a thrilling book series. Each series is a collection of related books
    released together, volume by volume. Just as with the *Harry Potter* series, each
    book contributes to the larger narrative, creating an exciting and cohesive story.
    Now, imagine every book in the series lists all previous volumes and specifies
    the exact editions required to understand the current book. This ensures that
    no matter where you pick up the series, you have a consistent experience, just
    like how modules ensure consistent builds by recording precise dependency requirements.
    Visualize a version control repository as a well-organized bookshelf in a library.
    Each bookshelf contains one complete book series, neatly arranged for readers
    to find and follow the series without confusion.
  prefs: []
  type: TYPE_NORMAL
- en: 'But how do they relate to each other? Simple: A **repository** is like a section
    in a library dedicated to a specific series or collection. Each **module** represents
    a book series within this section. Each book series (module) consists of individual
    books (packages). Finally, each book (**package**) contains chapters (**Go source
    files**), all within the covers (**directory**) of that book.'
  prefs: []
  type: TYPE_NORMAL
- en: If using `git`, the version will be associated with the repository’s tags.
  prefs: []
  type: TYPE_NORMAL
- en: SemVer
  prefs: []
  type: TYPE_NORMAL
- en: SemVer (`Major.Minor.Patch`) uses a numbering system to indicate what kind of
    changes (breaking, new features, bug fixes) are included in a software update.
    The full SemVer specification can be found at [https://semver.org/](https://semver.org/).
  prefs: []
  type: TYPE_NORMAL
- en: The routine using modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The workflow for a sunny day would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the imports in your `.go` files as needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `go build` or `go test` commands will automatically add new dependencies
    to satisfy the imports (automatically updating the `go.mod` file and downloading
    the new dependencies).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There will be times when it is necessary to choose specific versions of a dependency.
    In such cases, the `go get` command should be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The format for the `go get` command is `<module-name>@<version>`, as in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Changing the module file directly
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to change the `go.mod` file directly, if necessary. In any
    case, prefer to let the `Go` commands make changes to the file.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore how to use them, first, by creating our first module.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start by creating a new Go module for our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to set up our workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can initialize our module by running a simple command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This command creates a `go.mod` file that will keep track of your module’s dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume we have a new `main.go` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, let’s assume we have a `main_test.go` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Execute the tests using the `go test` command. When you run it, the Go tool
    automatically resolves any new dependencies, updates the `go.mod` file, and downloads
    the necessary modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you check the `go.mod` file, you should see a new line for the dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Understanding module versioning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go uses a `go.mod` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you build or test a Go module, MVS determines the set of module versions
    to use based on the version requirements specified in the `go.mod` files of your
    module and its dependencies. Here’s how MVS resolves these versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`go.mod` file, which specifies the versions of direct dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go.mod` files of the direct dependencies to gather their dependencies and
    their required versions. This process continues recursively for all dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go.mod` files that mention it. The highest required version is considered
    the minimal version that satisfies all version requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minimizing versions**: The algorithm ensures that the minimal version of
    each module is selected, meaning no higher version than necessary is chosen. This
    reduces the risk of introducing unintended changes or incompatibilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By always selecting the minimal versions that satisfy all requirements, MVS
    avoids unnecessary upgrades and reduces the risk of introducing breaking changes
    from dependency updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'To list the current module and all its dependencies, you can use the `go` `list`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will include the main module followed by its dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Hey! There is a new file in the folder: `go.sum`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `go.sum` file contains checksums of the content of specific module versions.
    This ensures that the same module versions are used consistently across builds.
    Here’s an example of what you might see in a `go.sum` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Updating dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To update a dependency to the latest version, we can use the `go` `get` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To update to a specific version, specify the version explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, you need to specify exact versions of dependencies. You can do this
    directly in the `go.mod` file or by using the `go get` command, as shown previously.
    This is useful for ensuring compatibility or needing specific features or bug
    fixes from a particular version.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic import versioning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Go modules follow SemVer, which uses version numbers to convey meaning about
    the stability and compatibility of releases. The versioning scheme is `v<MAJOR>.<MINOR>.<PATCH>`:'
  prefs: []
  type: TYPE_NORMAL
- en: Major versions indicate incompatible API changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minor versions add functionality in a backward-compatible manner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patch versions include backward-compatible bug fixes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `v1.2.3` indicates major version 1, minor version 2, and patch
    version 3.
  prefs: []
  type: TYPE_NORMAL
- en: When a module reaches version 2 or higher, the major version must be included
    in the module path. For example, version 2 of `github.com/alexrios/timer` is identified
    as `github.com/alexrios/timer/v2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can trigger the dependencies verification at any time using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `go mod tidy` command in Go is essential for maintaining clean and accurate
    `go.mod` and `go.sum` files. It scans your project’s source code to determine
    which dependencies are used, adding missing ones and removing unused ones from
    the `go.mod` file. Additionally, it updates the `go.sum` file to ensure consistent
    checksums for all dependencies. This process helps to keep your project free from
    unnecessary dependencies, reduces security risks, ensures reproducible builds,
    and makes dependency management more manageable. Regularly using `go mod tidy`
    ensures that your Go project’s dependencies are up to date and accurately reflect
    the code base’s requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The `github.com/alexrios/timer` library is public, but in your company, you’ll
    probably use closed source libraries, commonly called private libraries. Let’s
    see how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Using private libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with Go modules that are hosted in private repositories, you need
    a setup that ensures secure and direct access, bypassing the public Go module
    proxy. This section will walk you through configuring Git and the Go environment
    for seamless work with private Go modules on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to navigate to your home directory and open the `.gitconfig`
    file, adding the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: These lines tell Git to automatically use SSH (`ssh://git@github.com/`) whenever
    it encounters a GitHub URL that starts with `https://github.com/`.
  prefs: []
  type: TYPE_NORMAL
- en: Once it’s done, we can now configure the Go environment for private modules.
  prefs: []
  type: TYPE_NORMAL
- en: The `GOPRIVATE` environment variable prevents the Go tools from attempting to
    fetch modules listed in it from the public Go module mirror or proxy. Instead,
    it fetches them directly from their source, which is necessary for private modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should set `GOPRIVATE` for a single private repository by running the following
    command in your terminal, replacing `<org>` and `<project>` with your GitHub organization
    and repository name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, set `GOPRIVATE` for all repositories in an organization. If
    you work with multiple private repositories under the same organization, it’s
    convenient to use a wildcard (`*`) to cover them all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some additional tips:'
  prefs: []
  type: TYPE_NORMAL
- en: '`go env GOPRIVATE` to display the current settings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using SSH keys with GitHub**: Ensure your SSH keys are set up and added to
    your GitHub account. This setup allows you to push to and pull from your repositories
    without entering your username and password each time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ssh-add ~/.ssh/your-ssh-key` (replace `your-ssh-key` with the path to your
    SSH key).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ve configured your environment to securely work with Go modules housed in
    private GitHub repositories! This setup simplifies development workflows by automating
    authentication for Git operations and ensuring direct, secure access to your private
    Go modules.
  prefs: []
  type: TYPE_NORMAL
- en: Version control and go install
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most fundamental way is to host your Go program code in a public version
    control repository (such as GitHub, GitLab, and so on). Users with Go installed
    can then use the `go install` command followed by your repository’s URL to fetch,
    compile, and install your program.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the root of our module, we can simply execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes the program accessible from any directory on your system by just
    typing its name in the terminal. To test if the installation worked, open a **new**
    terminal window and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With `go install`, your compiled programs live in `$GOPATH/bin`.
  prefs: []
  type: TYPE_NORMAL
- en: Since version 1.16, the `go install` command can install a Go executable from
    a specific version.
  prefs: []
  type: TYPE_NORMAL
- en: To make it simple to grasp, let’s use the [https://github.com/alexrios/endpoints](https://github.com/alexrios/endpoints)
    repository as our target.
  prefs: []
  type: TYPE_NORMAL
- en: 'This repository has a `v0.5.0` tag, so to install this specific version, we
    can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When you don’t know or don’t want to discover what is the latest version of
    the executable, you can simply use `latest` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that within the Go ecosystem, you can install other executables without
    any special tool or process. Pretty powerful, huh?
  prefs: []
  type: TYPE_NORMAL
- en: 'But what about projects with multiple modules? How easily we can deal with
    them? Quick answer: Not easy at all before Go version 1.18.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of introducing all folklore and the nightmares of Go early days, let’s
    go “back to the future” and keep our focus on how easily we can do it. Version
    1.18 introduced the concept of module workspaces.
  prefs: []
  type: TYPE_NORMAL
- en: Module workspaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Go module workspace is a way to group multiple Go modules that belong to the
    same project. This feature, introduced to tackle the very beast of dependency
    management, allows developers to work with multiple modules simultaneously. They
    aren’t just about neatness. It fundamentally changes how the Go toolchain resolves
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: A Go workspace is a directory containing a unique `go.work` file referencing
    one or more `go.mod` files, each representing a module. This setup permits us
    to build, test, and manage multiple interrelated modules without the usual headaches
    of version conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: Within a workspace, the Go compiler treats them as peers instead of relying
    on an external `go.mod` file for each module. It looks at the workspace’s `go.work`
    file, which lists all modules within the project, making sure everyone plays nicely
    together.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, workspaces create a self-contained ecosystem for your project.
    Any changes you make within one module immediately ripple across the others. This
    streamlines development, particularly when juggling interconnected components
    of a larger application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enough talk; let’s see it in action. Consider this simple workspace setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `go.work` file acts as the orchestrator within this workspace. It ensures
    that when you run your Go commands, all referenced modules are considered as part
    of a single unified code base. This is particularly handy when you are developing
    interdependent modules or when you want to test local changes across modules without
    committing them upstream.
  prefs: []
  type: TYPE_NORMAL
- en: With this configuration, both `moduleA` and `moduleB` are part of the same workspace,
    allowing seamless integration testing and development.
  prefs: []
  type: TYPE_NORMAL
- en: 'The practical implications are profound. Suppose you have two modules: `moduleA`
    and `moduleB`. `moduleA` depends on `moduleB`. Traditionally, updating `moduleB`
    could be a nightmare of version pinning and backward compatibility. With a workspace,
    however, you can modify both modules at once and test the integrations in real
    time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple `go.work` file to illustrate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The last bit of the adventure with module workspaces is to synchronize modifications
    within the workspace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time we change a `go.mod` file from our modules or add or remove modules
    from our workspace, we should run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will keep us away from problems such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`go.mod` file will be out of sync with your `go.work` file. This discrepancy
    can lead to confusion and potential errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go build` or `go test`, there are a few scenarios depending on how Go is resolving
    dependencies:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go.work` file is already cached locally, Go might use the cached version instead
    of the one you specified in the modified `go.mod`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Builds might break**: If your change introduces incompatible dependency versions
    or the required version is not available, your builds and tests could fail.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Issues with collaboration**: If you’re working with others on a project,
    inconsistent dependency declarations can lead to problems with builds reproducing
    on different machines.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you forget this command, it can lead to wasted time debugging unexpected
    build failures caused by misaligned dependencies. Also, it might be difficult
    to track down the root cause of issues if you forget that you’ve manually modified
    a `go.mod` file. From a team collaboration perspective, the project becomes harder
    to maintain when different developers’ environments have diverging dependency
    states.
  prefs: []
  type: TYPE_NORMAL
- en: This approach to module management isn’t just about keeping your sanity intact—it’s
    about fostering an environment where logistical nightmares don’t bog down innovation.
    So, the next time you find yourself juggling Go modules, remember that workspaces
    are your friend, not just another layer of complexity to your project.
  prefs: []
  type: TYPE_NORMAL
- en: Although our module knowledge is ready to be tested, we want to ensure that
    everything is running smoothly and (hopefully) without bugs. This is when CI takes
    place.
  prefs: []
  type: TYPE_NORMAL
- en: CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CI is like a babysitter for your code. Ha! If you believe that, you’ve probably
    never tried wrestling a herd of untamed microservices into a semblance of order
    while simultaneously battling an infrastructure that melts down faster than a
    popsicle in the Sahara Desert.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s be real – CI is more like wrangling a multi-headed hydra: one head spews
    out unit tests, another spits out integration tests, and somewhere in the tangled
    mess, there’s probably a build pipeline and deployment lurking about. CI, done
    right, is less about babysitting and more like a brutal code boot camp with an
    unforgiving drill sergeant.'
  prefs: []
  type: TYPE_NORMAL
- en: So, what the heck is CI, as the cool kids call it? In the realm of Go, particularly
    for system programming, CI is the art of constantly merging code changes into
    a shared repository and relentlessly testing the living daylights out of the result.
    It’s about catching errors early, ensuring that new code doesn’t break the whole
    system, and automating those tedious tasks that would otherwise have us all weeping
    into our keyboards.
  prefs: []
  type: TYPE_NORMAL
- en: Think of CI as your automated code quality control. It’s where you put build
    scripts and test suites, maybe toss in some static analysis and linting for good
    measure, and then wire it all together to run every time someone commits a change.
    Why, you ask? Well, because nothing builds character in a code base quite like
    breaking it repeatedly and forcing your teammates to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get practical. Here’s a snippet of how a basic CI setup with GitHub Actions
    might look for your Go project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Leveraging a cache mechanism is the difference between watching your builds
    chug along like a rusty steam engine and witnessing the sleek efficiency of a
    high-speed bullet train. Let’s see how we can make those dependency downloads
    a relic of the past.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine your CI pipeline is the tireless factory worker, and those dependencies
    are the raw materials it needs to keep production humming. Every time your build
    process spins up, it has to fetch all the dependencies fresh, slowing things down
    and making a racket in the process. Caching is like building a well-stocked warehouse
    right next to your factory – the next time you need those materials, no need for
    an expedition, just a quick trip to the warehouse.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key to caching your Go dependencies in CI lies in understanding two things:'
  prefs: []
  type: TYPE_NORMAL
- en: '`~/go/pkg/mod`. This is our warehouse.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How CI workflows store stuff**: Most CI systems, such as GitHub Actions,
    have built-in mechanisms for caching files or directories between workflow runs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s marry those concepts. Here’s how you’d modify a basic GitHub Actions
    workflow to cache Go dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The magic happens in the Cache Go dependencies step:'
  prefs: []
  type: TYPE_NORMAL
- en: '`actions/cache@v3`: This is the trusty GitHub Actions tool for caching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path`: We tell it to cache our Go module directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`key`: This uniquely identifies your cache. Notice it includes a hash of your
    `go.sum` file; if dependencies change, a new cache is created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`restore-keys`: Provides a fallback in case the exact key isn’t found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Think of caching like this: your CI pipeline leaves a little breadcrumb trail
    each time it runs. The next time around, it checks for those breadcrumbs and,
    if found, grabs your pre-packaged dependencies instead of venturing out for a
    fresh download.'
  prefs: []
  type: TYPE_NORMAL
- en: Static analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Static analysis tools act as an automated code review squad, tirelessly inspecting
    your Go code for potential pitfalls, deviations from best practices, and even
    subtle style inconsistencies. It’s like having a team of meticulous programmers
    constantly looking over your shoulder but without the awkward code-breathing-down-your-neck
    sensation.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s integrate Staticcheck ([https://staticcheck.dev/](https://staticcheck.dev/)),
    the vigilant code inspector, into your Go CI workflow to help you maintain pristine
    code quality.
  prefs: []
  type: TYPE_NORMAL
- en: Staticcheck steps beyond basic linting, delving deeper to identify potential
    bugs, inefficient code patterns, and even subtle style issues that could affect
    your Go code’s quality. It’s your automated code detective, tirelessly searching
    for problems that might slip past cursory inspections.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s harness the power of GitHub Actions and the `dominikh/staticcheck-action`
    action to streamline our integration for our workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'While you can install and execute Staticcheck directly in your workflow, using
    a pre-built GitHub action offers several advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplified setup**: The action handles installation and execution details
    for you, reducing workflow configuration complexity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Potential caching**: Some actions may provide automatic caching of Staticcheck
    results to speed up future runs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Community-driven**: Many actions are actively maintained, ensuring compatibility
    with the latest Go and Staticcheck versions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s how your modified workflow would look using this action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Key points are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dominikh/staticcheck-action`) and optionally customize its version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v1.2.0`) ensures consistent behavior across CI runs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: staticcheck-action configuration
  prefs: []
  type: TYPE_NORMAL
- en: Consult the action’s documentation ([https://github.com/dominikh/staticcheck-action](https://github.com/dominikh/staticcheck-action))
    for supported options such as specifying the Staticcheck version.
  prefs: []
  type: TYPE_NORMAL
- en: Releasing your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sure – your unit tests are a thing of beauty, and you might even be flirting
    with code coverage nirvana. But the real test, my friend, comes when you must
    package that masterpiece you created and ship it out into the wild – that’s where
    GoReleaser ([https://goreleaser.com/](https://goreleaser.com/)) enters the scene,
    ready to transform your release process from a cringe-worthy ordeal into a symphony
    of automation.
  prefs: []
  type: TYPE_NORMAL
- en: Forget building binaries for every blasted OS or agonizing over tarballs and
    checksums. Imagine a world where your release woes are as mythical as a harmonious
    coding session where absolutely nothing breaks. Enter the realm of cross-compilation,
    automatic version tagging, Docker image creation, Homebrew taps... GoReleaser
    isn’t just a tool; it’s your release-day sanity preserver.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, GoReleaser is your personal release butler. You describe how you
    want your precious Go application packaged and distributed, and it handles the
    nitty-gritty details with the efficiency of a seasoned assembly line. Need a shiny
    new GitHub release with pre-built binaries for every known operating system? Check.
    Want to push Docker images to your favorite registry? Easy peasy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Now, we want to make our binaries available every time we tag our repository.
    To make this happen, we should use a new workflow with the GoReleaser job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: I remember that time when I spent the whole afternoon manually crafting release
    notes, praying you didn’t miss a critical bug fix. With GoReleaser, I learned
    to laugh at my past misery. It gleefully autogenerates release notes, tweets the
    announcement, and probably even bakes celebratory cookies if you ask nicely (well,
    maybe not the cookies).
  prefs: []
  type: TYPE_NORMAL
- en: Much like a wise old general inspecting the troops, I learned the hard way that
    a solid CI setup is worth its weight in “bug-free” code. Back in the prehistoric
    era before CI, we’d spend days, sometimes weeks, untangling monstrous integration
    messes that only surfaced right before a release. CI is the antidote to that kind
    of chaos.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s think about CI like a high-stakes synchronization dance: small, frequent
    changes integrated continuously are a graceful waltz. Big, infrequent merges?
    Well, that’s like a mosh pit, and nobody walks away from those unscathed.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we explored methods and tools for distributing Go applications.
    We focused on the meticulous management of dependencies, the automation of testing
    and integration processes, and strategies for efficient software release. We started
    with Go modules and workspaces, discussing how they enhance project consistency
    and reliability through better dependency management. We then explored CI and
    its critical role in maintaining high software quality. Lastly, we covered the
    essentials of deploying applications using GoReleaser, which simplifies the release
    process by automating packaging and distribution across different platforms. These
    are key concepts and tools that will form the foundation of your Capstone project.
  prefs: []
  type: TYPE_NORMAL
- en: As you move toward the Capstone project in the next chapter, you will have the
    opportunity to apply all the knowledge and skills acquired throughout the book.
    This final project is designed to consolidate your understanding and proficiency
    in a real-world scenario, challenging you to implement a complete solution from
    start to finish using the best practices and tools discussed.
  prefs: []
  type: TYPE_NORMAL
- en: The Capstone project will testify to your learning journey and valuable work,
    showcasing your capabilities to effectively develop, manage, automate, and release
    robust applications. I’m excited about this – aren’t you?
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 5: Going Beyond'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we will dive into the intricacies of building a distributed cache
    and explore essential system programming practices. You will learn how to design,
    implement, and optimize a distributed cache system, along with effective coding
    practices and strategies for staying updated in the system programming community.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B21662_13.xhtml#_idTextAnchor251), *Capstone Project* *- Distributed
    Cache*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B21662_14.xhtml#_idTextAnchor269), *Effective Coding Practices*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B21662_15.xhtml#_idTextAnchor288), *Stay Sharp with System Programming*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
