- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Distributing Your Apps
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分发你的应用程序
- en: In this chapter, we will explore key concepts and practical applications of
    distributing your Go applications using modules, **continuous integration** (**CI**),
    and release strategies. As we progress, you will be adept at using Go modules
    for dependency management, setting up CI workflows to automate testing and builds,
    and mastering the release process to distribute your applications seamlessly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨使用模块、**持续集成**（**CI**）和发布策略分发Go应用程序的关键概念和实际应用。随着我们的进展，你将熟练使用Go modules进行依赖项管理，设置CI工作流程来自动化测试和构建，并掌握发布过程以无缝分发你的应用程序。
- en: 'The chapter will cover the following key topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下关键主题：
- en: Go modules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go Modules
- en: CI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI
- en: Releasing your application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布你的应用程序
- en: By the end of this chapter, you will have acquired the knowledge to manage dependencies
    precisely, automate your testing and build processes to catch errors early, and
    efficiently package and release your applications. These skills provide the foundation
    for maintaining robust software projects that are easy to manage, update, and
    scale with the team size without adding extra layers of bureaucracy.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将掌握精确管理依赖项、自动化测试和构建过程以尽早捕捉错误、以及高效打包和发布应用程序的知识。这些技能为维护易于管理、更新和随着团队规模扩展而无需增加额外官僚层的健壮软件项目提供了基础。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code shown in this chapter can be found in the `ch12` directory of our
    `git` repository.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的所有代码都可以在我们的`git`仓库的`ch12`目录中找到。
- en: Go Modules
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go Modules
- en: Go Modules, the beacon of hope in a sea of dependency chaos. Alright – maybe
    handling dependencies in Go isn’t *quite* as simple as a Sunday morning stroll
    in the park. But consider it more like planning a mission to Mars – complex, yes,
    but with the right tools (modules), the potential rewards are stellar.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Go Modules，在依赖项混乱的海洋中的灯塔。好吧——处理Go中的依赖项可能并不像在公园里散步的星期天早晨那么简单。但把它看作是一次前往火星的任务——复杂，是的，但有了正确的工具（模块），潜在的回报是巨大的。
- en: Introduced in Go 1.11, Go Modules fundamentally reshaped the landscape of package
    management in Golang, especially pertinent in the realm of system programming.
    This feature provides a robust system for managing project dependencies, encapsulating
    specific versions of external packages your project relies on. At its core, Go
    Modules enables reproducible builds by leveraging a module cache and a defined
    set of dependencies, thus eliminating the infamous “works on my machine” syndrome.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go 1.11中引入，Go Modules从根本上重塑了Golang中包管理的格局，特别是在系统编程领域尤为重要。此功能提供了一套强大的系统来管理项目依赖项，封装了项目所依赖的外部包的特定版本。在核心上，Go
    Modules通过利用模块缓存和定义好的依赖项集，实现了可重复构建，从而消除了臭名昭著的“在我的机器上工作”综合征。
- en: 'Go Modules tackled several categories of issues that make the experience of
    using it absurdly more robust. I can highlight three of them: reliable versioning,
    reproducible builds, and managing dependency bloat. Let me explain the main changes
    before and after the Go Modules introduction for each one of them.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Go Modules解决了几个类别的问题，使得使用它的体验异常稳健。我可以强调其中三个：可靠的版本控制、可重复构建和管理依赖项冗余。让我在Go Modules引入之前和之后解释每个问题的主要变化。
- en: 'Let’s look at reliable versioning first:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看可靠的版本控制：
- en: '**Before**: The way dependencies were specified in Go projects left room for
    interpretation. It might not have been entirely clear which version of a package
    you were requesting. As a result of the ambiguity, you couldn’t be completely
    sure what code would be included in your project when you added a dependency.
    There was a possibility of unexpected versions or even different packages being
    pulled in.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Before**: 在Go项目中指定依赖项的方式留下了解释的空间。可能并不完全清楚你请求的是哪个版本的包。由于这种歧义，当你添加依赖项时，你无法完全确定项目中将包含哪些代码。存在意外版本或甚至不同包被拉入的可能性。'
- en: '**After**: Introduced the concept of **Semantic Versioning** (**SemVer**),
    ensuring you know the kind of changes a dependency update contains, reducing unpredictable
    breakages.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**After**: 介绍了**语义版本控制**（**SemVer**）的概念，确保你知道依赖项更新包含的变化类型，减少不可预测的破坏。'
- en: 'Let’s now turn to reproducible builds:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向可重复构建：
- en: '**Before**: Relying on external package repositories meant a build could fail
    later if dependencies changed or disappeared'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Before**: 依赖于外部包仓库意味着如果依赖项发生变化或消失，构建可能会在以后失败。'
- en: '**After**: The introduction of the Go Module proxy and the ability to vendor
    (storing a copy of dependencies within the project) guarantees your code always
    builds the same way'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**之后**：引入 Go 模块代理和供应商（在项目中存储依赖项副本）的能力，确保你的代码始终以相同的方式构建'
- en: 'Finally, let’s look at managing dependency bloat:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看如何管理依赖项膨胀：
- en: '**Before**: Nested dependencies could easily spiral out of control, adding
    size and complexity'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**之前**：嵌套依赖项很容易失控，增加大小和复杂性'
- en: '**After**: Go modules calculate the minimal set of required dependencies, keeping
    your project lean'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**之后**：Go 模块计算所需依赖项的最小集合，使你的项目保持精简'
- en: A module is a collection of related Go packages. It serves as a “versionable”
    and interchangeable unit of source code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是一组相关的 Go 包。它作为“可版本化”和可交换的源代码单元。
- en: 'Modules have two main objectives: to maintain the specific requirements of
    dependencies and to create reproducible builds.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 模块有两个主要目标：维护依赖项的特定要求，并创建可重复构建。
- en: Let’s start by imagining you’re organizing a library. This library will serve
    as our analogy for understanding modules, version control, and SemVer. Think of
    a module as a thrilling book series. Each series is a collection of related books
    released together, volume by volume. Just as with the *Harry Potter* series, each
    book contributes to the larger narrative, creating an exciting and cohesive story.
    Now, imagine every book in the series lists all previous volumes and specifies
    the exact editions required to understand the current book. This ensures that
    no matter where you pick up the series, you have a consistent experience, just
    like how modules ensure consistent builds by recording precise dependency requirements.
    Visualize a version control repository as a well-organized bookshelf in a library.
    Each bookshelf contains one complete book series, neatly arranged for readers
    to find and follow the series without confusion.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先想象你正在组织一个图书馆。这个图书馆将作为我们理解模块、版本控制和 SemVer 的类比。将模块想象成一个令人兴奋的书系。每个系列是一系列相关书籍的集合，分卷发布。就像《哈利·波特》系列一样，每本书都对更大的叙事做出贡献，创造出一个令人兴奋且连贯的故事。现在，想象这个系列中的每本书都列出了所有之前的卷，并指定了理解当前书籍所需的精确版本。这确保了无论你在哪里开始这个系列，你都能有一个一致的经历，就像模块通过记录精确的依赖项要求来确保一致的构建一样。将版本控制仓库想象成图书馆里一个组织良好的书架。每个书架包含一个完整的书系，整齐地排列，方便读者找到并跟随系列，不会感到困惑。
- en: 'But how do they relate to each other? Simple: A **repository** is like a section
    in a library dedicated to a specific series or collection. Each **module** represents
    a book series within this section. Each book series (module) consists of individual
    books (packages). Finally, each book (**package**) contains chapters (**Go source
    files**), all within the covers (**directory**) of that book.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但它们之间是如何相互关联的呢？简单来说：**仓库**就像图书馆中专门为特定系列或集合设立的章节。每个**模块**代表这个章节中的一个书系。每个书系（模块）由单个书籍（包）组成。最后，每本书（包）包含章节（Go
    源文件），所有这些都包含在书的封面（目录）中。
- en: If using `git`, the version will be associated with the repository’s tags.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 `git`，版本将与仓库的标签相关联。
- en: SemVer
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: SemVer
- en: SemVer (`Major.Minor.Patch`) uses a numbering system to indicate what kind of
    changes (breaking, new features, bug fixes) are included in a software update.
    The full SemVer specification can be found at [https://semver.org/](https://semver.org/).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: SemVer (`Major.Minor.Patch`) 使用一个编号系统来指示软件更新中包含的更改类型（破坏性更改、新功能、错误修复）。完整的 SemVer
    规范可以在 [https://semver.org/](https://semver.org/) 找到。
- en: The routine using modules
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模块的常规操作
- en: 'The workflow for a sunny day would be the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 阳光明媚的日子的工作流程如下：
- en: Add the imports in your `.go` files as needed.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要将导入添加到 `.go` 文件中。
- en: The `go build` or `go test` commands will automatically add new dependencies
    to satisfy the imports (automatically updating the `go.mod` file and downloading
    the new dependencies).
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`go build` 或 `go test` 命令将自动添加新的依赖项以满足导入（自动更新 `go.mod` 文件并下载新的依赖项）。'
- en: There will be times when it is necessary to choose specific versions of a dependency.
    In such cases, the `go get` command should be used.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有时会需要选择依赖项的特定版本。在这种情况下，应使用 `go get` 命令。
- en: 'The format for the `go get` command is `<module-name>@<version>`, as in the
    following example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`go get` 命令的格式是 `<module-name>@<version>`，如下面的示例所示：'
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Changing the module file directly
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 直接更改模块文件
- en: It is also possible to change the `go.mod` file directly, if necessary. In any
    case, prefer to let the `Go` commands make changes to the file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，也可以直接更改`go.mod`文件。在任何情况下，都建议让`Go`命令更改文件。
- en: Let’s explore how to use them, first, by creating our first module.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先通过创建我们的第一个模块来探索如何使用它们。
- en: Creating a new module
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建新模块
- en: Let’s start by creating a new Go module for our project.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先为我们的项目创建一个新的Go模块。
- en: 'The first step is to set up our workspace:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是设置我们的工作区：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can initialize our module by running a simple command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行一个简单的命令来初始化我们的模块：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command creates a `go.mod` file that will keep track of your module’s dependencies.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令创建一个`go.mod`文件，该文件将跟踪您的模块依赖项。
- en: 'Assume we have a new `main.go` file with the following content:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含以下内容的新的`main.go`文件：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Also, let’s assume we have a `main_test.go` file with the following content:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，假设我们有一个包含以下内容的`main_test.go`文件：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Execute the tests using the `go test` command. When you run it, the Go tool
    automatically resolves any new dependencies, updates the `go.mod` file, and downloads
    the necessary modules.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`go test`命令执行测试。当您运行它时，Go工具会自动解决任何新的依赖项，更新`go.mod`文件，并下载必要的模块。
- en: 'If you check the `go.mod` file, you should see a new line for the dependency:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查`go.mod`文件，您应该看到一个新行用于依赖项：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Understanding module versioning
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解模块版本控制
- en: Go uses a `go.mod` file.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Go使用`go.mod`文件。
- en: 'When you build or test a Go module, MVS determines the set of module versions
    to use based on the version requirements specified in the `go.mod` files of your
    module and its dependencies. Here’s how MVS resolves these versions:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当您构建或测试Go模块时，MVS根据您的模块及其依赖项的`go.mod`文件中指定的版本要求确定要使用的模块版本集。以下是MVS解决这些版本的方式：
- en: '`go.mod` file, which specifies the versions of direct dependencies.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go.mod`文件，它指定了直接依赖项的版本。'
- en: '`go.mod` files of the direct dependencies to gather their dependencies and
    their required versions. This process continues recursively for all dependencies.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集直接依赖项及其所需版本的`go.mod`文件。此过程递归地对所有依赖项进行。
- en: '`go.mod` files that mention it. The highest required version is considered
    the minimal version that satisfies all version requirements.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提及它的`go.mod`文件。所需最高版本被认为是满足所有版本要求的最小版本。
- en: '**Minimizing versions**: The algorithm ensures that the minimal version of
    each module is selected, meaning no higher version than necessary is chosen. This
    reduces the risk of introducing unintended changes or incompatibilities.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小化版本**：算法确保选择每个模块的最小版本，这意味着不会选择比必要的更高版本。这减少了引入意外更改或不兼容性的风险。'
- en: By always selecting the minimal versions that satisfy all requirements, MVS
    avoids unnecessary upgrades and reduces the risk of introducing breaking changes
    from dependency updates.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过始终选择满足所有要求的最小版本，MVS避免了不必要的升级，并减少了从依赖项更新中引入破坏性更改的风险。
- en: 'To list the current module and all its dependencies, you can use the `go` `list`
    command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出当前模块及其所有依赖项，您可以使用`go` `list`命令：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output will include the main module followed by its dependencies:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将包括主模块及其依赖项：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Hey! There is a new file in the folder: `go.sum`.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿！文件夹中有一个新文件：`go.sum`。
- en: 'The `go.sum` file contains checksums of the content of specific module versions.
    This ensures that the same module versions are used consistently across builds.
    Here’s an example of what you might see in a `go.sum` file:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`go.sum`文件包含特定模块版本的校验和。这确保了在构建过程中始终一致地使用相同的模块版本。以下是一个您可能在`go.sum`文件中看到的示例：'
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Updating dependencies
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新依赖项
- en: 'To update a dependency to the latest version, we can use the `go` `get` command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新依赖到最新版本，我们可以使用`go` `get`命令：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To update to a specific version, specify the version explicitly:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新到特定版本，请明确指定版本：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Sometimes, you need to specify exact versions of dependencies. You can do this
    directly in the `go.mod` file or by using the `go get` command, as shown previously.
    This is useful for ensuring compatibility or needing specific features or bug
    fixes from a particular version.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您需要指定依赖项的确切版本。您可以直接在`go.mod`文件中这样做，或者使用之前显示的`go get`命令。这对于确保兼容性或需要特定版本的功能或错误修复非常有用。
- en: Semantic import versioning
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语义导入版本控制
- en: 'Go modules follow SemVer, which uses version numbers to convey meaning about
    the stability and compatibility of releases. The versioning scheme is `v<MAJOR>.<MINOR>.<PATCH>`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Go模块遵循SemVer，它使用版本号来传达关于发布稳定性和兼容性的信息。版本方案是 `v<MAJOR>.<MINOR>.<PATCH>`：
- en: Major versions indicate incompatible API changes
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主版本表示不兼容的API更改
- en: Minor versions add functionality in a backward-compatible manner
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小版本以向后兼容的方式添加功能
- en: Patch versions include backward-compatible bug fixes
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 补丁版本包括向后兼容的错误修复
- en: For example, `v1.2.3` indicates major version 1, minor version 2, and patch
    version 3.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`v1.2.3` 表示主版本1，次版本2，补丁版本3。
- en: When a module reaches version 2 or higher, the major version must be included
    in the module path. For example, version 2 of `github.com/alexrios/timer` is identified
    as `github.com/alexrios/timer/v2`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个模块达到版本2或更高时，必须在模块路径中包含主版本号。例如，`github.com/alexrios/timer` 的版本2被标识为 `github.com/alexrios/timer/v2`。
- en: 'You can trigger the dependencies verification at any time using the following
    command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令随时触发依赖项验证：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `go mod tidy` command in Go is essential for maintaining clean and accurate
    `go.mod` and `go.sum` files. It scans your project’s source code to determine
    which dependencies are used, adding missing ones and removing unused ones from
    the `go.mod` file. Additionally, it updates the `go.sum` file to ensure consistent
    checksums for all dependencies. This process helps to keep your project free from
    unnecessary dependencies, reduces security risks, ensures reproducible builds,
    and makes dependency management more manageable. Regularly using `go mod tidy`
    ensures that your Go project’s dependencies are up to date and accurately reflect
    the code base’s requirements.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的 `go mod tidy` 命令对于维护干净和准确的 `go.mod` 和 `go.sum` 文件至关重要。它扫描您的项目源代码以确定哪些依赖项被使用，添加缺失的依赖项，并从
    `go.mod` 文件中删除未使用的依赖项。此外，它更新 `go.sum` 文件以确保所有依赖项的一致校验和。这个过程有助于使您的项目免于不必要的依赖项，降低安全风险，确保可重复构建，并使依赖项管理更加容易管理。定期使用
    `go mod tidy` 确保您的Go项目依赖项是最新的，并且准确反映了代码库的要求。
- en: The `github.com/alexrios/timer` library is public, but in your company, you’ll
    probably use closed source libraries, commonly called private libraries. Let’s
    see how to use them.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`github.com/alexrios/timer` 库是公开的，但在您的公司中，您可能使用的是闭源库，通常称为私有库。让我们看看如何使用它们。'
- en: Using private libraries
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用私有库
- en: When working with Go modules that are hosted in private repositories, you need
    a setup that ensures secure and direct access, bypassing the public Go module
    proxy. This section will walk you through configuring Git and the Go environment
    for seamless work with private Go modules on GitHub.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当与托管在私有仓库中的Go模块一起工作时，您需要一个确保安全且直接访问的设置，绕过公共Go模块代理。本节将指导您配置Git和Go环境，以便在GitHub上无缝使用私有Go模块。
- en: 'First, you need to navigate to your home directory and open the `.gitconfig`
    file, adding the following configuration:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要导航到您的家目录并打开 `.gitconfig` 文件，添加以下配置：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These lines tell Git to automatically use SSH (`ssh://git@github.com/`) whenever
    it encounters a GitHub URL that starts with `https://github.com/`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行告诉Git在遇到以 `https://github.com/` 开头的GitHub URL时自动使用SSH (`ssh://git@github.com/`)。
- en: Once it’s done, we can now configure the Go environment for private modules.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们现在可以为私有模块配置Go环境。
- en: The `GOPRIVATE` environment variable prevents the Go tools from attempting to
    fetch modules listed in it from the public Go module mirror or proxy. Instead,
    it fetches them directly from their source, which is necessary for private modules.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`GOPRIVATE` 环境变量阻止Go工具尝试从公共Go模块镜像或代理中获取列出的模块。相反，它直接从它们的源中获取，这对于私有模块是必要的。'
- en: 'You should set `GOPRIVATE` for a single private repository by running the following
    command in your terminal, replacing `<org>` and `<project>` with your GitHub organization
    and repository name:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在终端中运行以下命令来为单个私有仓库设置 `GOPRIVATE`，用 `<org>` 和 `<project>` 替换您的GitHub组织和仓库名称：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Alternatively, set `GOPRIVATE` for all repositories in an organization. If
    you work with multiple private repositories under the same organization, it’s
    convenient to use a wildcard (`*`) to cover them all:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，为组织中的所有仓库设置 `GOPRIVATE`。如果您在同一个组织下工作，有多个私有仓库，使用通配符 (`*`) 来覆盖所有这些仓库会非常方便：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here are some additional tips:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些额外的提示：
- en: '`go env GOPRIVATE` to display the current settings.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `go env GOPRIVATE` 来显示当前设置。
- en: '**Using SSH keys with GitHub**: Ensure your SSH keys are set up and added to
    your GitHub account. This setup allows you to push to and pull from your repositories
    without entering your username and password each time.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用SSH密钥与GitHub**：确保您的SSH密钥已设置并添加到您的GitHub账户。这种设置允许您在不每次都输入用户名和密码的情况下推送和拉取您的仓库。'
- en: '`ssh-add ~/.ssh/your-ssh-key` (replace `your-ssh-key` with the path to your
    SSH key).'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssh-add ~/.ssh/your-ssh-key`（将`your-ssh-key`替换为您的SSH密钥路径）。'
- en: You’ve configured your environment to securely work with Go modules housed in
    private GitHub repositories! This setup simplifies development workflows by automating
    authentication for Git operations and ensuring direct, secure access to your private
    Go modules.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您已配置环境以安全地与包含在私有GitHub仓库中的Go模块一起工作！这种设置通过自动化Git操作的认证来简化开发工作流程，并确保直接、安全地访问您的私有Go模块。
- en: Version control and go install
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 版本控制和go install
- en: The most fundamental way is to host your Go program code in a public version
    control repository (such as GitHub, GitLab, and so on). Users with Go installed
    can then use the `go install` command followed by your repository’s URL to fetch,
    compile, and install your program.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的方法是将您的Go程序代码托管在公共版本控制仓库中（如GitHub、GitLab等）。安装了Go的用户可以使用`go install`命令后跟您的仓库URL来获取、编译和安装您的程序。
- en: 'In the root of our module, we can simply execute the following command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模块根目录中，我们可以简单地执行以下命令：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This makes the program accessible from any directory on your system by just
    typing its name in the terminal. To test if the installation worked, open a **new**
    terminal window and type the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得程序可以通过在终端中输入其名称从系统上的任何目录访问。要测试安装是否成功，请打开一个**新**的终端窗口并输入以下内容：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With `go install`, your compiled programs live in `$GOPATH/bin`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`go install`，您的编译程序将存储在`$GOPATH/bin`。
- en: Since version 1.16, the `go install` command can install a Go executable from
    a specific version.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 自1.16版本以来，`go install`命令可以从特定版本安装Go可执行文件。
- en: To make it simple to grasp, let’s use the [https://github.com/alexrios/endpoints](https://github.com/alexrios/endpoints)
    repository as our target.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其更容易理解，让我们使用[https://github.com/alexrios/endpoints](https://github.com/alexrios/endpoints)仓库作为我们的目标。
- en: 'This repository has a `v0.5.0` tag, so to install this specific version, we
    can run the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此仓库有一个`v0.5.0`标签，因此要安装此特定版本，我们可以运行以下命令：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When you don’t know or don’t want to discover what is the latest version of
    the executable, you can simply use `latest` instead:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当您不知道或不想发现可执行文件的最新版本时，您可以直接使用`latest`：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that within the Go ecosystem, you can install other executables without
    any special tool or process. Pretty powerful, huh?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在Go生态系统内，您可以在不使用任何特殊工具或过程的情况下安装其他可执行文件。非常强大，不是吗？
- en: 'But what about projects with multiple modules? How easily we can deal with
    them? Quick answer: Not easy at all before Go version 1.18.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于具有多个模块的项目怎么办？我们如何轻松地处理它们？快速回答：在Go 1.18版本之前，这根本不可能。
- en: Instead of introducing all folklore and the nightmares of Go early days, let’s
    go “back to the future” and keep our focus on how easily we can do it. Version
    1.18 introduced the concept of module workspaces.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是介绍所有关于Go早期时代的民间传说和噩梦，让我们“回到未来”，并关注我们如何轻松地做到这一点。1.18版本引入了模块工作空间的概念。
- en: Module workspaces
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块工作空间
- en: A Go module workspace is a way to group multiple Go modules that belong to the
    same project. This feature, introduced to tackle the very beast of dependency
    management, allows developers to work with multiple modules simultaneously. They
    aren’t just about neatness. It fundamentally changes how the Go toolchain resolves
    dependencies.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Go模块工作空间是一种将属于同一项目的多个Go模块分组的方法。这个特性是为了解决依赖关系管理的难题而引入的，允许开发者同时处理多个模块。这不仅仅是关于整洁。它从根本上改变了Go工具链解决依赖关系的方式。
- en: A Go workspace is a directory containing a unique `go.work` file referencing
    one or more `go.mod` files, each representing a module. This setup permits us
    to build, test, and manage multiple interrelated modules without the usual headaches
    of version conflicts.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Go工作空间是一个包含唯一`go.work`文件的目录，该文件引用一个或多个`go.mod`文件，每个文件代表一个模块。这种设置使我们能够在不出现版本冲突的常规头痛中构建、测试和管理多个相互关联的模块。
- en: Within a workspace, the Go compiler treats them as peers instead of relying
    on an external `go.mod` file for each module. It looks at the workspace’s `go.work`
    file, which lists all modules within the project, making sure everyone plays nicely
    together.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作区内部，Go 编译器将它们视为同等模块，而不是依赖于每个模块的外部 `go.mod` 文件。它查看工作区的 `go.work` 文件，该文件列出了项目中的所有模块，确保所有人都能良好地协同工作。
- en: In other words, workspaces create a self-contained ecosystem for your project.
    Any changes you make within one module immediately ripple across the others. This
    streamlines development, particularly when juggling interconnected components
    of a larger application.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，工作区为你的项目创建了一个自包含的生态系统。你在一个模块内所做的任何更改都会立即影响到其他模块。这简化了开发，尤其是在处理大型应用程序相互关联的组件时。
- en: 'Enough talk; let’s see it in action. Consider this simple workspace setup:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 足够的讨论；让我们看看实际操作。考虑以下简单的工作区设置：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `go.work` file acts as the orchestrator within this workspace. It ensures
    that when you run your Go commands, all referenced modules are considered as part
    of a single unified code base. This is particularly handy when you are developing
    interdependent modules or when you want to test local changes across modules without
    committing them upstream.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在此工作区内部，`go.work` 文件充当协调者。它确保当你运行 Go 命令时，所有引用的模块都被视为单个统一代码库的一部分。这在开发相互依赖的模块或当你想在提交到上游之前测试模块之间的本地更改时尤其有用。
- en: With this configuration, both `moduleA` and `moduleB` are part of the same workspace,
    allowing seamless integration testing and development.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种配置下，`moduleA` 和 `moduleB` 都是同一工作区的一部分，允许无缝的集成测试和开发。
- en: 'The practical implications are profound. Suppose you have two modules: `moduleA`
    and `moduleB`. `moduleA` depends on `moduleB`. Traditionally, updating `moduleB`
    could be a nightmare of version pinning and backward compatibility. With a workspace,
    however, you can modify both modules at once and test the integrations in real
    time.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 实际影响深远。假设你有两个模块：`moduleA` 和 `moduleB`。`moduleA` 依赖于 `moduleB`。传统上，更新 `moduleB`
    可能会变成版本锁定和向后兼容的噩梦。然而，使用工作区，你可以同时修改这两个模块并实时测试集成。
- en: 'Here’s a simple `go.work` file to illustrate:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的 `go.work` 文件示例：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The last bit of the adventure with module workspaces is to synchronize modifications
    within the workspace.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 模块工作区的最后一段冒险是要同步工作区内的修改。
- en: 'Every time we change a `go.mod` file from our modules or add or remove modules
    from our workspace, we should run the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们更改模块的 `go.mod` 文件或从我们的工作区添加或删除模块时，我们都应该运行以下命令：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This command will keep us away from problems such as the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将使我们远离以下问题：
- en: '`go.mod` file will be out of sync with your `go.work` file. This discrepancy
    can lead to confusion and potential errors.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go.mod` 文件将与你的 `go.work` 文件不同步。这种差异可能导致混淆和潜在的错误。'
- en: '`go build` or `go test`, there are a few scenarios depending on how Go is resolving
    dependencies:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go build` 或 `go test`，根据 Go 如何解析依赖项，存在几种场景：'
- en: '`go.work` file is already cached locally, Go might use the cached version instead
    of the one you specified in the modified `go.mod`.'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go.work` 文件已经本地缓存，Go 可能会使用缓存的版本而不是你在修改的 `go.mod` 中指定的版本。'
- en: '**Builds might break**: If your change introduces incompatible dependency versions
    or the required version is not available, your builds and tests could fail.'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建可能会失败**：如果你的更改引入了不兼容的依赖项版本或所需的版本不可用，你的构建和测试可能会失败。'
- en: '**Issues with collaboration**: If you’re working with others on a project,
    inconsistent dependency declarations can lead to problems with builds reproducing
    on different machines.'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协作问题**：如果你与其他人一起在项目上工作，不一致的依赖项声明可能导致在不同机器上构建重现的问题。'
- en: If you forget this command, it can lead to wasted time debugging unexpected
    build failures caused by misaligned dependencies. Also, it might be difficult
    to track down the root cause of issues if you forget that you’ve manually modified
    a `go.mod` file. From a team collaboration perspective, the project becomes harder
    to maintain when different developers’ environments have diverging dependency
    states.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记了此命令，可能会导致调试意外构建失败所浪费的时间，这些失败是由不匹配的依赖项引起的。如果你忘记手动修改了 `go.mod` 文件，可能很难追踪问题的根本原因。从团队协作的角度来看，当不同开发者的环境具有不同的依赖项状态时，项目维护变得更加困难。
- en: This approach to module management isn’t just about keeping your sanity intact—it’s
    about fostering an environment where logistical nightmares don’t bog down innovation.
    So, the next time you find yourself juggling Go modules, remember that workspaces
    are your friend, not just another layer of complexity to your project.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模块管理方法不仅仅是为了保持你的理智——它是在培养一个环境，在那里物流噩梦不会阻碍创新。所以，下次当你发现自己正在玩转Go模块时，记住，工作空间是你的朋友，而不仅仅是项目复杂性的另一层。
- en: Although our module knowledge is ready to be tested, we want to ensure that
    everything is running smoothly and (hopefully) without bugs. This is when CI takes
    place.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的模块知识已经准备好接受测试，但我们希望确保一切运行顺畅，并且（希望如此）没有错误。这就是CI发挥作用的时候。
- en: CI
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CI
- en: CI is like a babysitter for your code. Ha! If you believe that, you’ve probably
    never tried wrestling a herd of untamed microservices into a semblance of order
    while simultaneously battling an infrastructure that melts down faster than a
    popsicle in the Sahara Desert.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: CI就像是你的代码保姆。哈！如果你相信这一点，那你可能从未尝试过在同时与基础设施作斗争，后者比撒哈拉沙漠中的冰棍融化得还要快的同时，将一群未驯服的微服务整理成有序的状态。
- en: 'Let’s be real – CI is more like wrangling a multi-headed hydra: one head spews
    out unit tests, another spits out integration tests, and somewhere in the tangled
    mess, there’s probably a build pipeline and deployment lurking about. CI, done
    right, is less about babysitting and more like a brutal code boot camp with an
    unforgiving drill sergeant.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直面现实——CI更像是在驯服多头海德拉：一个头喷出单元测试，另一个头吐出集成测试，而在混乱的某个地方，可能潜伏着构建管道和部署。
- en: So, what the heck is CI, as the cool kids call it? In the realm of Go, particularly
    for system programming, CI is the art of constantly merging code changes into
    a shared repository and relentlessly testing the living daylights out of the result.
    It’s about catching errors early, ensuring that new code doesn’t break the whole
    system, and automating those tedious tasks that would otherwise have us all weeping
    into our keyboards.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，CI究竟是什么，就像时髦的年轻人所说的那样？在Go的世界里，尤其是在系统编程领域，CI是将代码更改不断合并到共享仓库中，并对结果进行无情测试的艺术。这是关于尽早捕捉错误，确保新代码不会破坏整个系统，并自动化那些繁重的任务，否则我们都会对着键盘哭泣。
- en: Think of CI as your automated code quality control. It’s where you put build
    scripts and test suites, maybe toss in some static analysis and linting for good
    measure, and then wire it all together to run every time someone commits a change.
    Why, you ask? Well, because nothing builds character in a code base quite like
    breaking it repeatedly and forcing your teammates to fix it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 将CI视为你的自动化代码质量控制。这是你放置构建脚本和测试套件的地方，也许为了保险起见，还会加入一些静态分析和代码检查，然后将所有这些连接起来，以便每次有人提交更改时都运行。为什么你会问？嗯，因为没有什么能像反复破坏代码库并迫使你的队友修复它那样锻炼一个人的性格。
- en: 'Let’s get practical. Here’s a snippet of how a basic CI setup with GitHub Actions
    might look for your Go project:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实际一点。以下是一个使用GitHub Actions为你的Go项目设置基本CI的片段：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Caching
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存
- en: Leveraging a cache mechanism is the difference between watching your builds
    chug along like a rusty steam engine and witnessing the sleek efficiency of a
    high-speed bullet train. Let’s see how we can make those dependency downloads
    a relic of the past.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 利用缓存机制的区别在于，你可以看到你的构建过程像一辆生锈的蒸汽机车一样缓慢地前进，也可以见证高速列车般的效率。让我们看看我们如何能让那些依赖项下载成为过去式。
- en: Imagine your CI pipeline is the tireless factory worker, and those dependencies
    are the raw materials it needs to keep production humming. Every time your build
    process spins up, it has to fetch all the dependencies fresh, slowing things down
    and making a racket in the process. Caching is like building a well-stocked warehouse
    right next to your factory – the next time you need those materials, no need for
    an expedition, just a quick trip to the warehouse.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你的CI管道就像不知疲倦的工厂工人，而那些依赖项就是它需要来保持生产顺畅的原材料。每次构建过程启动时，它都必须重新获取所有依赖项，这会减慢速度，并在过程中制造噪音。缓存就像在你的工厂旁边建一个库存充足的仓库——下次你需要那些材料时，无需进行探险，只需快速去仓库一趟即可。
- en: 'The key to caching your Go dependencies in CI lies in understanding two things:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在CI中缓存Go依赖的关键在于理解两件事：
- en: '`~/go/pkg/mod`. This is our warehouse.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~/go/pkg/mod`. 这是我们的大仓库。'
- en: '**How CI workflows store stuff**: Most CI systems, such as GitHub Actions,
    have built-in mechanisms for caching files or directories between workflow runs.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如何存储 CI 工作流程中的内容**：大多数 CI 系统，如 GitHub Actions，都有内置机制在工作流程运行之间缓存文件或目录。'
- en: 'Let’s marry those concepts. Here’s how you’d modify a basic GitHub Actions
    workflow to cache Go dependencies:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些概念结合起来。以下是您如何修改基本的 GitHub Actions 工作流程以缓存 Go 依赖项：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The magic happens in the Cache Go dependencies step:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法发生在“缓存 Go 依赖项”步骤中：
- en: '`actions/cache@v3`: This is the trusty GitHub Actions tool for caching.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`actions/cache@v3`：这是可靠的 GitHub Actions 缓存工具。'
- en: '`path`: We tell it to cache our Go module directory.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：我们告诉它缓存我们的 Go 模块目录。'
- en: '`key`: This uniquely identifies your cache. Notice it includes a hash of your
    `go.sum` file; if dependencies change, a new cache is created.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key`：这唯一地标识了您的缓存。请注意，它包括您的 `go.sum` 文件的哈希值；如果依赖项发生变化，将创建一个新的缓存。'
- en: '`restore-keys`: Provides a fallback in case the exact key isn’t found.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restore-keys`：在找不到确切密钥时提供备用方案。'
- en: 'Think of caching like this: your CI pipeline leaves a little breadcrumb trail
    each time it runs. The next time around, it checks for those breadcrumbs and,
    if found, grabs your pre-packaged dependencies instead of venturing out for a
    fresh download.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 将缓存想象成这样：您的 CI 管道每次运行都会留下一些面包屑。下次运行时，它会检查这些面包屑，如果找到，就会抓取预先打包的依赖项，而不是去下载新的。
- en: Static analysis
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态分析
- en: Static analysis tools act as an automated code review squad, tirelessly inspecting
    your Go code for potential pitfalls, deviations from best practices, and even
    subtle style inconsistencies. It’s like having a team of meticulous programmers
    constantly looking over your shoulder but without the awkward code-breathing-down-your-neck
    sensation.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析工具充当自动代码审查小组，不知疲倦地检查您的 Go 代码中可能存在的陷阱、偏离最佳实践的情况，甚至可能影响您的 Go 代码质量的细微风格不一致。这就像有一支细致的程序员团队一直在您身后审视，但没有那种尴尬的代码压迫感。
- en: Let’s integrate Staticcheck ([https://staticcheck.dev/](https://staticcheck.dev/)),
    the vigilant code inspector, into your Go CI workflow to help you maintain pristine
    code quality.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 Staticcheck ([https://staticcheck.dev/](https://staticcheck.dev/))，这位警惕的代码检查员，集成到您的
    Go CI 工作流程中，以帮助您保持代码的纯净质量。
- en: Staticcheck steps beyond basic linting, delving deeper to identify potential
    bugs, inefficient code patterns, and even subtle style issues that could affect
    your Go code’s quality. It’s your automated code detective, tirelessly searching
    for problems that might slip past cursory inspections.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Staticcheck 超越了基本的代码检查，深入到识别潜在的 bug、低效的代码模式，甚至可能影响您的 Go 代码质量的细微风格问题。它是您的自动化代码侦探，不知疲倦地寻找可能被粗略检查遗漏的问题。
- en: Let’s harness the power of GitHub Actions and the `dominikh/staticcheck-action`
    action to streamline our integration for our workflow.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用 GitHub Actions 和 `dominikh/staticcheck-action` 动作来简化我们的工作流程集成。
- en: 'While you can install and execute Staticcheck directly in your workflow, using
    a pre-built GitHub action offers several advantages:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以直接在工作流程中安装和执行 Staticcheck，但使用预构建的 GitHub 动作提供了一些优势：
- en: '**Simplified setup**: The action handles installation and execution details
    for you, reducing workflow configuration complexity'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化设置**：该动作为您处理安装和执行细节，减少了工作流程配置的复杂性'
- en: '**Potential caching**: Some actions may provide automatic caching of Staticcheck
    results to speed up future runs'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**潜在缓存**：某些操作可能会自动缓存 Staticcheck 的结果以加快未来的运行速度'
- en: '**Community-driven**: Many actions are actively maintained, ensuring compatibility
    with the latest Go and Staticcheck versions'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社区驱动**：许多操作正在积极维护，确保与最新的 Go 和 Staticcheck 版本兼容'
- en: 'Here’s how your modified workflow would look using this action:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此动作，您的修改后工作流程将如下所示：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Key points are the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点如下：
- en: '`dominikh/staticcheck-action`) and optionally customize its version'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dominikh/staticcheck-action`) 并可选地自定义其版本'
- en: '`v1.2.0`) ensures consistent behavior across CI runs'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v1.2.0`) 确保在 CI 运行中保持一致的行为'
- en: staticcheck-action configuration
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: staticcheck-action 配置
- en: Consult the action’s documentation ([https://github.com/dominikh/staticcheck-action](https://github.com/dominikh/staticcheck-action))
    for supported options such as specifying the Staticcheck version.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 咨询动作的文档 ([https://github.com/dominikh/staticcheck-action](https://github.com/dominikh/staticcheck-action))
    以了解支持选项，例如指定 Staticcheck 版本。
- en: Releasing your application
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布您的应用程序
- en: Sure – your unit tests are a thing of beauty, and you might even be flirting
    with code coverage nirvana. But the real test, my friend, comes when you must
    package that masterpiece you created and ship it out into the wild – that’s where
    GoReleaser ([https://goreleaser.com/](https://goreleaser.com/)) enters the scene,
    ready to transform your release process from a cringe-worthy ordeal into a symphony
    of automation.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当然——你的单元测试是一件美丽的事物，你可能甚至正在与代码覆盖率极乐世界调情。但真正的考验，我的朋友，在于你必须将你创作的杰作打包并投入野外——这就是GoReleaser([https://goreleaser.com/](https://goreleaser.com/))登场的时候，准备好将你的发布过程从令人尴尬的磨难转变为自动化的交响曲。
- en: Forget building binaries for every blasted OS or agonizing over tarballs and
    checksums. Imagine a world where your release woes are as mythical as a harmonious
    coding session where absolutely nothing breaks. Enter the realm of cross-compilation,
    automatic version tagging, Docker image creation, Homebrew taps... GoReleaser
    isn’t just a tool; it’s your release-day sanity preserver.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 忘记为每个该死的操作系统构建二进制文件，或者痛苦地处理tar包和校验和。想象一下，你的发布烦恼就像一个和谐的编码会议一样神话般，绝对没有任何东西会出错。进入交叉编译、自动版本标记、Docker镜像创建、Homebrew
    taps的领域... GoReleaser不仅仅是一个工具；它是你发布日理智的守护者。
- en: In essence, GoReleaser is your personal release butler. You describe how you
    want your precious Go application packaged and distributed, and it handles the
    nitty-gritty details with the efficiency of a seasoned assembly line. Need a shiny
    new GitHub release with pre-built binaries for every known operating system? Check.
    Want to push Docker images to your favorite registry? Easy peasy.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，GoReleaser是你的个人发布管家。你描述你希望你的宝贵Go应用程序如何打包和分发，它以熟练的流水线效率处理所有琐碎的细节。需要为每个已知的操作系统提供预构建的二进制文件的新颖GitHub发布？没问题。想要将Docker镜像推送到你最喜欢的注册表？轻而易举。
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Great! Now, we want to make our binaries available every time we tag our repository.
    To make this happen, we should use a new workflow with the GoReleaser job:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在，我们希望在每次标记我们的仓库时都能使我们的二进制文件可用。为了实现这一点，我们应该使用一个新的工作流程与GoReleaser作业：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: I remember that time when I spent the whole afternoon manually crafting release
    notes, praying you didn’t miss a critical bug fix. With GoReleaser, I learned
    to laugh at my past misery. It gleefully autogenerates release notes, tweets the
    announcement, and probably even bakes celebratory cookies if you ask nicely (well,
    maybe not the cookies).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得有一次，我花了整个下午手动编写发布说明，祈祷你没有错过一个关键的错误修复。有了GoReleaser，我学会了嘲笑我过去的痛苦。它愉快地自动生成发布说明，发布推文公告，如果你请求的话，甚至可能烘焙庆祝的饼干（嗯，可能不是饼干）。
- en: Much like a wise old general inspecting the troops, I learned the hard way that
    a solid CI setup is worth its weight in “bug-free” code. Back in the prehistoric
    era before CI, we’d spend days, sometimes weeks, untangling monstrous integration
    messes that only surfaced right before a release. CI is the antidote to that kind
    of chaos.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 就像一位智慧的老将军检阅部队一样，我痛苦地意识到，一个稳固的CI设置的价值相当于“无bug”代码的重量。在CI之前的史前时代，我们花费了数天，有时甚至数周，来解开在发布前才出现的巨大集成混乱。CI是这种混乱的解药。
- en: 'Let’s think about CI like a high-stakes synchronization dance: small, frequent
    changes integrated continuously are a graceful waltz. Big, infrequent merges?
    Well, that’s like a mosh pit, and nobody walks away from those unscathed.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们像一场高风险的同步舞蹈一样思考CI：小而频繁的更改持续集成是一种优雅的华尔兹。大而罕见的合并？嗯，那就像一个混乱的mosh pit，没有人能从那里毫发无损地离开。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we explored methods and tools for distributing Go applications.
    We focused on the meticulous management of dependencies, the automation of testing
    and integration processes, and strategies for efficient software release. We started
    with Go modules and workspaces, discussing how they enhance project consistency
    and reliability through better dependency management. We then explored CI and
    its critical role in maintaining high software quality. Lastly, we covered the
    essentials of deploying applications using GoReleaser, which simplifies the release
    process by automating packaging and distribution across different platforms. These
    are key concepts and tools that will form the foundation of your Capstone project.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了分布式Go应用程序的方法和工具。我们专注于细致的依赖管理、测试和集成过程的自动化，以及高效的软件发布策略。我们从Go模块和工作空间开始，讨论了它们如何通过更好的依赖管理来增强项目的一致性和可靠性。然后，我们探讨了持续集成及其在保持高软件质量中的关键作用。最后，我们介绍了使用GoReleaser部署应用程序的基本知识，它通过自动化跨不同平台的打包和分发来简化发布过程。这些是构成你的综合项目基础的关键概念和工具。
- en: As you move toward the Capstone project in the next chapter, you will have the
    opportunity to apply all the knowledge and skills acquired throughout the book.
    This final project is designed to consolidate your understanding and proficiency
    in a real-world scenario, challenging you to implement a complete solution from
    start to finish using the best practices and tools discussed.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '当你进入下一章的综合项目时，你将有机会应用本书中学到的所有知识和技能。这个最终项目旨在巩固你在实际场景中的理解和熟练程度，挑战你从开始到结束使用最佳实践和工具实现一个完整的解决方案。 '
- en: The Capstone project will testify to your learning journey and valuable work,
    showcasing your capabilities to effectively develop, manage, automate, and release
    robust applications. I’m excited about this – aren’t you?
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 综合项目将证明你的学习之旅和宝贵的工作，展示你有效地开发、管理、自动化和发布健壮应用程序的能力。我对这一点感到兴奋——你呢？
- en: 'Part 5: Going Beyond'
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五部分：超越基础
- en: In this part, we will dive into the intricacies of building a distributed cache
    and explore essential system programming practices. You will learn how to design,
    implement, and optimize a distributed cache system, along with effective coding
    practices and strategies for staying updated in the system programming community.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，我们将深入研究构建分布式缓存的复杂性，并探讨必要的系统编程实践。你将学习如何设计、实现和优化分布式缓存系统，以及有效的编码实践和保持系统编程社区更新的策略。
- en: 'This part has the following chapters:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 13*](B21662_13.xhtml#_idTextAnchor251), *Capstone Project* *- Distributed
    Cache*'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B21662_13.xhtml#_idTextAnchor251)，*综合项目* - *分布式缓存*'
- en: '[*Chapter 14*](B21662_14.xhtml#_idTextAnchor269), *Effective Coding Practices*'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B21662_14.xhtml#_idTextAnchor269)，*有效的编码实践*'
- en: '[*Chapter 15*](B21662_15.xhtml#_idTextAnchor288), *Stay Sharp with System Programming*'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B21662_15.xhtml#_idTextAnchor288)，*通过系统编程保持敏锐*'
