["```go\n    mkdir spewg-cache\n    cd spewg-cache\n    ```", "```go\n    go mod init spewg-cache\n    ```", "```go\n    package main\n    type CacheItem struct {\n        Value string\n    }\n    type Cache struct {\n        items map[string]CacheItem\n    }\n    func NewCache() *Cache {\n        return &Cache{\n           items: make(map[string]CacheItem),\n        }\n    }\n    func (c *Cache) Set(key, value string) {\n        c.items[key] = CacheItem{\n           Value: value,\n        }\n    }\n    func (c *Cache) Get(key string) (string, bool) {\n        item, found := c.items[key]\n        if !found {\n           return \"\", false\n        }\n        return item.Value, true\n    }\n    ```", "```go\nimport \"sync\"\ntype Cache struct {\n    mu    sync.RWMutex\n    items map[string]CacheItem\n}\nfunc (c *Cache) Set(key, value string) {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    c.items[key] = CacheItem{\n        Value: value,\n    }\n}\nfunc (c *Cache) Get(key string) (string, bool) {\n    c.mu.RLock()\n    defer c.mu.RUnlock()\n    item, found := c.items[key]\n    if !found {\n        return \"\", false\n    }\n    return item.Value, true\n}\n```", "```go\nimport (\n    \"encoding/json\"\n    \"net/http\"\n)\ntype CacheServer struct {\n    cache *Cache\n}\nfunc NewCacheServer() *CacheServer {\n    return &CacheServer{\n        cache: NewCache(),\n    }\n}\nfunc (cs *CacheServer) SetHandler(w http.ResponseWriter, r *http.Request) {\n    var req struct {\n        Key   string `json:\"key\"`\n        Value string `json:\"value\"`\n    }\n    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n    cs.cache.Set(req.Key, req.Value)\n    w.WriteHeader(http.StatusOK)\n}\nfunc (cs *CacheServer) GetHandler(w http.ResponseWriter, r *http.Request) {\n    key := r.URL.Query().Get(\"key\")\n    value, found := cs.cache.Get(key)\n    if !found {\n        http.NotFound(w, r)\n        return\n    }\n    json.NewEncoder(w).Encode(map[string]string{\"value\": value})\n}\n```", "```go\npackage main\nimport (\n    \"fmt\"\n    \"net/http\"\n)\nfunc main() {\n    cs := NewCacheServer()\n    http.HandleFunc(\"/set\", cs.SetHandler)\n    http.HandleFunc(\"/get\", cs.GetHandler)\n    err := http.ListenAndServe(\":8080\", nil)\n    if err != nil {\n       fmt.Println(err)\n       return\n    }\n}\n```", "```go\ngo run main.go server.go\n```", "```go\ncurl -X POST -H \"Content-Type: application/json\" -d '{\"key\":\"foo\", \"value\":\"bar\"}' -i http://localhost:8080/set\n```", "```go\ncurl –i \"http://localhost:8080/get?key=foo\"\n```", "```go\npackage main\nimport (\n     \"sync\"\n     \"time\"\n)\ntype CacheItem struct {\n     Value      string\n     ExpiryTime time.Time\n}\ntype Cache struct {\n     mu    sync.RWMutex\n     items map[string]CacheItem\n}\nfunc NewCache() *Cache {\n     return &Cache{\n          items: make(map[string]CacheItem),\n     }\n}\nfunc (c *Cache) Set(key, value string, ttl time.Duration) {\n     c.mu.Lock()\n     defer c.mu.Unlock()\n     c.items[key] = CacheItem{\n          Value:      value,\n          ExpiryTime: time.Now().Add(ttl),\n     }\n}\nfunc (c *Cache) Get(key string) (string, bool) {\n     c.mu.RLock()\n     defer c.mu.RUnlock()\n     item, found := c.items[key]\n     if !found || time.Now().After(item.ExpiryTime) {\n          // If the item is not found or has expired, return false\n          return \"\", false\n     }\n     return item.Value, true\n}\n```", "```go\nfunc (c *Cache) startEvictionTicker(d time.Duration) {\n     ticker := time.NewTicker(d)\n     go func() {\n          for range ticker.C {\n               c.evictExpiredItems()\n          }\n     }()\n}\nfunc (c *Cache) evictExpiredItems() {\n     c.mu.Lock()\n     defer c.mu.Unlock()\n     now := time.Now()\n     for key, item := range c.items {\n          if now.After(item.ExpiryTime) {\n               delete(c.items, key)\n          }\n     }\n}\n```", "```go\ncache := NewCache()\ncache.startEvictionTicker(1 * time.Minute)\n```", "```go\npackage main\nimport (\n     \"container/list\"\n     \"sync\"\n     \"time\"\n)\ntype CacheItem struct {\n     Value      string\n     ExpiryTime time.Time\n}\ntype Cache struct {\n     mu       sync.RWMutex\n     items    map[string]*list.Element // Map of keys to list elements\n     eviction *list.List               // Doubly-linked list for eviction\n     capacity int                      // Maximum number of items in the cache\n}\ntype entry struct {\n     key   string\n     value CacheItem\n}\nfunc NewCache(capacity int) *Cache {\n     return &Cache{\n          items:    make(map[string]*list.Element),\n          eviction: list.New(),\n          capacity: capacity,\n     }\n}\n```", "```go\nfunc (c *Cache) Set(key, value string, ttl time.Duration) {\n     c.mu.Lock()\n     defer c.mu.Unlock()\n     // Remove the old value if it exists\n     if elem, found := c.items[key]; found {\n          c.eviction.Remove(elem)\n          delete(c.items, key)\n     }\n     // Evict the least recently used item if the cache is at capacity\n     if c.eviction.Len() >= c.capacity {\n          c.evictLRU()\n     }\n     item := CacheItem{\n          Value:      value,\n          ExpiryTime: time.Now().Add(ttl),\n     }\n     elem := c.eviction.PushFront(&entry{key, item})\n     c.items[key] = elem\n}\n```", "```go\nfunc (c *Cache) Get(key string) (string, bool) {\n     c.mu.Lock()\n     defer c.mu.Unlock()\n     elem, found := c.items[key]\n     if !found || time.Now().After(elem.Value.(*entry).value.ExpiryTime) {\n          // If the item is not found or has expired, return false\n          if found {\n               c.eviction.Remove(elem)\n               delete(c.items, key)\n          }\n          return \"\", false\n     }\n     // Move the accessed element to the front of the eviction list\n     c.eviction.MoveToFront(elem)\n     return elem.Value.(*entry).value.Value, true\n}\n```", "```go\nfunc (c *Cache) evictLRU() {\n     elem := c.eviction.Back()\n     if elem != nil {\n          c.eviction.Remove(elem)\n          kv := elem.Value.(*entry)\n          delete(c.items, kv.key)\n     }\n}\n```", "```go\nfunc (c *Cache) startEvictionTicker(d time.Duration) {\n     ticker := time.NewTicker(d)\n     go func() {\n          for range ticker.C {\n               c.evictExpiredItems()\n          }\n     }()\n}\nfunc (c *Cache) evictExpiredItems() {\n     c.mu.Lock()\n     defer c.mu.Unlock()\n     now := time.Now()\n     for key, elem := range c.items {\n          if now.After(elem.Value.(*entry).value.ExpiryTime) {\n               c.eviction.Remove(elem)\n               delete(c.items, key)\n          }\n     }\n}\n```", "```go\nfunc main() {\n     cache := NewCache(5) // Setting capacity to 5 for LRU\n     cache.startEvictionTicker(1 * time.Minute)\n}\n```", "```go\ntype CacheServer struct {\n     cache *Cache\n     peers []string\n     mu    sync.Mutex\n}\nfunc NewCacheServer(peers []string) *CacheServer {\n     return &CacheServer{\n          cache: NewCache(10),\n          peers: peers,\n     }\n}\n```", "```go\nfunc (cs *CacheServer) replicateSet(key, value string) {\n    cs.mu.Lock()\n    defer cs.mu.Unlock()\n    req := struct {\n       Key   string `json:\"key\"`\n       Value string `json:\"value\"`\n    }{\n       Key:   key,\n       Value: value,\n    }\n    data, _ := json.Marshal(req)\n    for _, peer := range cs.peers {\n       go func(peer string) {\n          client := &http.Client{}\n          req, err := http.NewRequest(\"POST\", peer+\"/set\", bytes.NewReader(data))\n          if err != nil {\n             log.Printf(\"Failed to create replication request: %v\", err)\n             return\n          }\n          req.Header.Set(\"Content-Type\", \"application/json\")\n          req.Header.Set(replicationHeader, \"true\")\n          _, err = client.Do(req)\n          if err != nil {\n             log.Printf(\"Failed to replicate to peer %s: %v\", peer, err)\n          }\n          log.Println(\"replication successful to\", peer)\n       }(peer)\n    }\n}\n```", "```go\nfunc (cs *CacheServer) SetHandler(w http.ResponseWriter, r *http.Request) {\n    var req struct {\n       Key   string `json:\"key\"`\n       Value string `json:\"value\"`\n    }\n    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {\n       http.Error(w, err.Error(), http.StatusBadRequest)\n       return\n    }\n    cs.cache.Set(req.Key, req.Value, 1*time.Hour)\n    if r.Header.Get(replicationHeader) == \"\" {\n       go cs.replicateSet(req.Key, req.Value)\n    }\n    w.WriteHeader(http.StatusOK)\n}\n```", "```go\nvar port string\nvar peers string\nfunc main() {\n    flag.StringVar(&port, \"port\", \":8080\", \"HTTP server port\")\n    flag.StringVar(&peers, \"peers\", \"\", \"Comma-separated list of peer addresses\")\n    flag.Parse()\n    peerList := strings.Split(peers, \",\")\n    cs := spewg.NewCacheServer(peerList)\n    http.HandleFunc(\"/set\", cs.SetHandler)\n    http.HandleFunc(\"/get\", cs.GetHandler)\n    err := http.ListenAndServe(port, nil)\n    if err != nil {\n       fmt.Println(err)\n       return\n    }\n}\n```", "```go\ngo run main.go -port=:8080 -peers=http://localhost:8081\n```", "```go\ngo run main.go -port=:8081 -peers=http://localhost:8080\n```", "```go\ncurl -X POST -d '{\"key\":\"foo\",\"value\":\"bar\"}' -H \"Content-Type: application/json\" http://localhost:8080/set\n```", "```go\ncurl http://localhost:8081/get?key=foo\n```", "```go\n      Node B\n     /\n    /      Key 2\n   /\n  /\n Node A --------- Key 1\n  \\\n   \\     Key 3\n    \\\n     \\\n      Node C\n```", "```go\npackage spewg\n// ... (imports) ...\ntype Node struct {\n    ID   string // Unique identifier\n    Addr string // Network address\n}\ntype HashRing struct {\n    nodes  []Node         // List of nodes\n    hashes []uint32       // Hashes for nodes (for efficient searching)\n    lock   sync.RWMutex   // Concurrency protection\n}\nfunc NewHashRing() *HashRing { ... }\nfunc (h *HashRing) AddNode(node Node) { ... }\nfunc (h *HashRing) RemoveNode(nodeID string) { ... }\nfunc (h *HashRing) GetNode(key string) Node { ... }\nfunc (h *HashRing) hash(key string) uint32 { ... }\n```", "```go\ntype CacheServer struct {\n     cache    *Cache\n     peers    []string\n     hashRing *HashRing\n     selfID   string\n     mu       sync.Mutex\n}\nfunc NewCacheServer(peers []string, selfID string) *CacheServer {\n     cs := &CacheServer{\n          cache:    NewCache(10),\n          peers:    peers,\n          hashRing: NewHashRing(),\n          selfID:   selfID,\n     }\n     for _, peer := range peers {\n          cs.hashRing.AddNode(Node{ID: peer, Addr: peer})\n     }\n     cs.hashRing.AddNode(Node{ID: selfID, Addr: \"self\"})\n     return cs\n}\n```", "```go\nconst replicationHeader = \"X-Replication-Request\"\nfunc (cs *CacheServer) SetHandler(w http.ResponseWriter, r *http.Request) {\n     var req struct {\n          Key   string `json:\"key\"`\n          Value string `json:\"value\"`\n     }\n     if err := json.NewDecoder(r.Body).Decode(&req); err != nil {\n          http.Error(w, err.Error(), http.StatusBadRequest)\n          return\n     }\n     targetNode := cs.hashRing.GetNode(req.Key)\n     if targetNode.Addr == \"self\" {\n          cs.cache.Set(req.Key, req.Value, 1*time.Hour)\n          if r.Header.Get(replicationHeader) == \"\" {\n               go cs.replicateSet(req.Key, req.Value)\n          }\n          w.WriteHeader(http.StatusOK)\n     } else {\n          cs.forwardRequest(w, targetNode, r)\n     }\n}\n```", "```go\nfunc (cs *CacheServer) replicateSet(key, value string) {\n     cs.mu.Lock()\n     defer cs.mu.Unlock()\n     req := struct {\n          Key   string `json:\"key\"`\n          Value string `json:\"value\"`\n     }{\n          Key:   key,\n          Value: value,\n     }\n     data, _ := json.Marshal(req)\n     for _, peer := range cs.peers {\n          if peer != cs.selfID {\n               go func(peer string) {\n                    client := &http.Client{}\n                    req, err := http.NewRequest(\"POST\", peer+\"/set\", bytes.NewReader(data))\n                    if err != nil {\n                         log.Printf(\"Failed to create replication request: %v\", err)\n                         return\n                    }\n                    req.Header.Set(\"Content-Type\", \"application/json\")\n                    req.Header.Set(replicationHeader, \"true\")\n                    _, err = client.Do(req)\n                    if err != nil {\n                         log.Printf(\"Failed to replicate to peer %s: %v\", peer, err)\n                    }\n               }(peer)\n          }\n     }\n}\n```", "```go\nfunc (cs *CacheServer) GetHandler(w http.ResponseWriter, r *http.Request) {\n     key := r.URL.Query().Get(\"key\")\n     targetNode := cs.hashRing.GetNode(key)\n     if targetNode.Addr == \"self\" {\n          value, found := cs.cache.Get(key)\n          if !found {\n               http.NotFound(w, r)\n               return\n          }\n          err := json.NewEncoder(w).Encode(map[string]string{\"value\": value})\n          if err != nil {\n               w.WriteHeader(http.StatusInternalServerError)\n               return\n          }\n     } else {\n          originalSender := r.Header.Get(\"X-Forwarded-For\")\n          if originalSender == cs.selfID {\n               http.Error(w, \"Loop detected\", http.StatusBadRequest)\n               return\n          }\n          r.Header.Set(\"X-Forwarded-For\", cs.selfID)\n          cs.forwardRequest(w, targetNode, r)\n     }\n}\n```", "```go\nfunc (cs *CacheServer) forwardRequest(w http.ResponseWriter, targetNode Node, r *http.Request) {\n     client := &http.Client{}\n     var req *http.Request\n     var err error\n     if r.Method == http.MethodGet {\n          url := fmt.Sprintf(\"%s%s?%s\", targetNode.Addr, r.URL.Path, r.URL.RawQuery)\n          req, err = http.NewRequest(r.Method, url, nil)\n     } else if r.Method == http.MethodPost {\n          body, err := io.ReadAll(r.Body)\n          if err != nil {\n               http.Error(w, \"Failed to read request body\", http.StatusInternalServerError)\n               return\n          }\n          url := fmt.Sprintf(\"%s%s\", targetNode.Addr, r.URL.Path)\n          req, err = http.NewRequest(r.Method, url, bytes.NewReader(body))\n          if err != nil {\n               http.Error(w, \"Failed to create forward request\", http.StatusInternalServerError)\n               return\n          }\n          req.Header.Set(\"Content-Type\", r.Header.Get(\"Content-Type\"))\n     }\n     if err != nil {\n          log.Printf(\"Failed to create forward request: %v\", err)\n          http.Error(w, \"Failed to create forward request\", http.StatusInternalServerError)\n          return\n     }\n     req.Header = r.Header\n     resp, err := client.Do(req)\n     if err != nil {\n          log.Printf(\"Failed to forward request to node %s: %v\", targetNode.Addr, err)\n          http.Error(w, \"Failed to forward request\", http.StatusInternalServerError)\n          return\n     }\n     defer resp.Body.Close()\n     w.WriteHeader(resp.StatusCode)\n     _, err = io.Copy(w, resp.Body)\n     if err != nil {\n          log.Printf(\"Failed to write response from node %s: %v\", targetNode.Addr, err)\n     }\n}\n```", "```go\nvar port string\nvar peers string\nfunc main() {\n    flag.StringVar(&port, \"port\", \":8080\", \"HTTP server port\")\n    flag.StringVar(&peers, \"peers\", \"\", \"Comma-separated list of peer addresses\")\n    flag.Parse()\n    nodeID := fmt.Sprintf(\"%s%d\", \"node\", rand.Intn(100))\n    peerList := strings.Split(peers, \",\")\n    cs := spewg.NewCacheServer(peerList, nodeID)\n    http.HandleFunc(\"/set\", cs.SetHandler)\n    http.HandleFunc(\"/get\", cs.GetHandler)\n    http.ListenAndServe(port, nil)\n}\n```", "```go\ngo run main.go -port=:8083 -peers=http://localhost:8080\n```", "```go\ngo run main.go -port=:8080 -peers=http://localhost:8083\n```", "```go\ncurl -X POST -H \"Content-Type: application/json\" -d '{\"key\": \"mykey\", \"value\": \"myvalue\"}' localhost:8080/set\n```", "```go\ncurl localhost:8080/get?key=mykey\n# OR\ncurl localhost:8083/get?key=mykey\n```", "```go\ncurl -X POST -H \"Content-Type: application/json\" -d '{\"key\": \"key1\", \"value\": \"value1\"}' localhost:8080/set\ncurl -X POST -H \"Content-Type: application/json\" -d '{\"key\": \"key2\", \"value\": \"value2\"}' localhost:8080/set\ncurl -X POST -H \"Content-Type: application/json\" -d '{\"key\": \"key3\", \"value\": \"value3\"}' localhost:8080/set\n```", "```go\ncurl localhost:8080/get?key=key1\ncurl localhost:8083/get?key=key2\ncurl localhost:8080/get?key=key3\n```"]