- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Capstone Project – Distributed Cache
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 综合项目 – 分布式缓存
- en: 'The grand finale is where we take everything we’ve learned and apply it to
    a real-world challenge. You might be thinking, “Surely, building a distributed
    cache can’t be that complex.” Spoiler alert: it’s not just about slapping together
    some in-memory storage and calling it a day. This is where theory meets practice,
    and trust me, it’s a wild ride.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一幕是我们将所学的一切应用到现实世界的挑战中。你可能正在想，“当然，构建一个分布式缓存不可能那么复杂。”剧透一下：这不仅仅是把一些内存存储拼凑在一起就算完事。这是理论与实践相遇的地方，相信我，这是一段刺激的旅程。
- en: Our distributed cache will be designed to handle frequent read and write operations
    with minimal latency. It will distribute data across multiple nodes to ensure
    scalability and fault tolerance. We’ll implement key features such as data sharding,
    replication, and eviction policies.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计的分布式缓存将能够以最小的延迟处理频繁的读写操作。它将在多个节点间分配数据，以确保可扩展性和容错性。我们将实现数据分片、复制和驱逐策略等关键功能。
- en: 'This chapter will cover the following key topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下关键主题：
- en: Setting up the project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置项目
- en: Implementing data sharding
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现数据分片
- en: Adding replication
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加复制
- en: Eviction policies
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驱逐策略
- en: By the end of this capstone project, you’ll have built a fully functional distributed
    cache from scratch. You’ll understand the intricacies of data distribution and
    performance optimization. More importantly, you’ll have the confidence to tackle
    similar challenges in your own projects.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到了这个综合项目的最后，你将从头开始构建一个完全功能的分布式缓存。你将理解数据分布和性能优化的复杂性。更重要的是，你将对自己的项目中有信心去应对类似的挑战。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code shown in this chapter can be found in the `ch13` directory of this
    book’s GitHub repository.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的所有代码都可以在这本书的GitHub仓库的`ch13`目录中找到。
- en: Understanding distributed caching
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解分布式缓存
- en: So, do you think distributed caching is just a fancy term for storing stuff
    in memory across a few servers? Bless your heart. If only life were that simple.
    Let me guess, you’re the type who thinks that simply slapping “distributed” in
    front of anything makes it automatically better, faster, and cooler. Well, strap
    in because we’re about to dive into the rabbit hole of distributed caching, where
    nothing is as straightforward as it seems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你认为分布式缓存仅仅是存储一些东西在几台服务器上的一个花哨术语吗？祝福你的心。如果生活真的那么简单就好了。让我猜猜，你是那种认为只要在任何事情前加上“分布式”这个词，它就会自动变得更好、更快、更酷的人。好吧，系好安全带，因为我们即将深入分布式缓存的兔子洞，那里没有什么是像表面上看起来那么简单的。
- en: Imagine you’re at a software developer’s party (because we all know how wild
    those get), and someone casually mentions, “Hey, why don’t we just cache everything?”
    This is like saying, “Why don’t we just solve world hunger by ordering more pizza?”
    Sure, the idea is nice, but the devil is in the details. Distributed caching is
    not about stuffing more data into memory. It’s about smartly managing data spread
    across multiple nodes while ensuring that it doesn’t turn into a synchronized
    swimming event gone horribly wrong.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你在一个软件开发者的聚会上（因为我们都知道那些有多疯狂），有人随意地说：“嘿，我们为什么不把所有东西都缓存起来呢？”这就像说：“我们为什么不通过订购更多的披萨来解决世界饥饿问题呢？”当然，这个想法不错，但魔鬼在于细节。分布式缓存不是关于把更多的数据塞进内存。它是关于智能管理分布在多个节点上的数据，同时确保它不会变成一场出人意料的糟糕的同步游泳比赛。
- en: First, let’s tackle the basics. A distributed cache is a data storage layer
    that lies between your application and your primary data store. It’s designed
    to store frequently accessed data in a way that reduces latency and improves read
    throughput. Think of it as the app’s version of having a mini fridge next to your
    desk. You don’t need to walk to the kitchen every time you need a drink. Instead,
    you have quick access to your favorite beverage, right at your fingertips.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从基础知识开始。分布式缓存是一种介于你的应用程序和主数据存储之间的数据存储层。它旨在以减少延迟和提高读取吞吐量的方式存储频繁访问的数据。想象一下，它就像是你的应用程序旁边的一个迷你冰箱。你不需要每次需要饮料时都走到厨房。相反，你可以快速地拿到你喜欢的饮料，就在你的指尖。
- en: But, as with all things in life and software, there’s a catch. Ensuring that
    the data in this mini fridge is always fresh, cold, and available to everyone
    in your office simultaneously is no small feat. Distributed caches must maintain
    consistency across multiple nodes, handle failures gracefully, and efficiently
    manage data eviction. They must ensure that data isn’t stale and that updates
    propagate correctly, all while keeping latency to a minimum.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，就像生活中的所有事情和软件一样，有一个陷阱。确保这个迷你冰箱中的数据始终新鲜、凉爽，并且同时可供办公室的每个人使用，这不是一件小事。分布式缓存必须在多个节点上保持一致性，优雅地处理故障，并有效地管理数据淘汰。它们必须确保数据不会过时，更新能够正确传播，同时将延迟保持在最低。
- en: Then comes the architecture. One popular approach is sharding, where data is
    divided into smaller chunks and distributed across different nodes. This helps
    in balancing the load and ensures that no single node becomes a bottleneck. Another
    essential feature is replication. It’s not enough to have the data spread out;
    you also need copies of it to handle node failures. However, balancing consistency,
    availability, and partition tolerance (the CAP theorem) is where things get tricky.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是架构。一种流行的方法是分片，即将数据分成更小的块，并分布到不同的节点上。这有助于平衡负载，并确保没有单个节点成为瓶颈。另一个基本特性是复制。仅仅将数据分散开来是不够的；你还需要它的副本来处理节点故障。然而，平衡一致性、可用性和分区容错（CAP定理）是事情变得棘手的地方。
- en: System requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统需求
- en: Each feature we’ll cover is crucial to building a robust and high-performing
    distributed cache system. By understanding and implementing these features, you
    will gain a comprehensive understanding of the intricacies involved in distributed
    caching.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖的每个特性对于构建一个强大且高性能的分布式缓存系统至关重要。通过理解和实施这些特性，你将全面了解分布式缓存中涉及的复杂性。
- en: At the heart of a distributed cache is its in-memory storage capability. In-memory
    storage allows for fast data access, significantly reducing the latency compared
    to disk-based storage. This feature is particularly important for applications
    that require high-speed data retrieval. Let’s explore our project requirements.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式缓存的核心是其内存存储能力。内存存储允许快速数据访问，与基于磁盘的存储相比，显著降低了延迟。这个特性对于需要高速数据检索的应用程序尤为重要。让我们来探讨我们的项目需求。
- en: Requirements
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需求
- en: 'Welcome to the delightful world of requirements! Now, before you roll your
    eyes and groan about another tedious checklist, let’s set the record straight.
    Requirements aren’t figments of some overly ambitious product manager’s imagination.
    They’re intentional choices that shape the very essence of what you’re building.
    Think of them as the DNA of your project. Without them, you’re just blindly writing
    code and praying it works out. Spoiler alert: **it won’t**.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到需求世界的快乐之地！现在，在你翻白眼和抱怨又一份繁琐的清单之前，让我们澄清事实。需求并非某些过于雄心勃勃的产品经理的想象产物。它们是有意的选择，塑造了你所构建事物的本质。把它们想象成你项目的DNA。没有它们，你只是在盲目地编写代码，祈祷它能成功。剧透一下：**不会的**。
- en: Requirements are your guiding light, your North Star. They keep you focused,
    ensure you’re building the right thing, and save you from the dreaded scope creep.
    In the context of our distributed cache project, they’re critical. So, let’s dive
    in and joyfully embrace the necessities that will make our distributed cache not
    just functional, but outstanding.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 需求是你的指南针，你的北极星。它们让你保持专注，确保你构建的是正确的东西，并帮助你避免可怕的范围蔓延。在我们分布式缓存项目的背景下，它们至关重要。那么，让我们深入其中，愉快地拥抱那些将使我们的分布式缓存不仅功能强大，而且出色的必要性。
- en: Performance
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能
- en: We want our cache to be lightning-fast. This means millisecond response times
    for data retrieval and minimal latency for data updates. Achieving this requires
    thoughtful design choices around in-memory storage and efficient data structures.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的缓存能够像闪电一样快。这意味着数据检索的响应时间以毫秒计算，数据更新的延迟最小。实现这一点需要围绕内存存储和高效数据结构的深思熟虑的设计选择。
- en: 'Here are some key points to consider:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要考虑的关键点：
- en: Fast data access and retrieval
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速的数据访问和检索
- en: Minimal latency for data updates
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据更新的最小延迟
- en: Efficient data structures and algorithms
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效的数据结构和算法
- en: Scalability
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可扩展性
- en: Our cache should scale horizontally, meaning we can add more nodes to handle
    increased load. This involves implementing sharding and ensuring that our architecture
    can grow seamlessly without significant rework.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的缓存应该能够水平扩展，这意味着我们可以添加更多节点来处理增加的负载。这涉及到实现分片，并确保我们的架构可以无缝增长，而无需进行大量重工作。
- en: 'The following are some key points to consider:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是需要考虑的一些关键点：
- en: Horizontal scalability
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水平扩展性
- en: Implementing data sharding
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施数据分片
- en: Seamless addition of new nodes
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无缝添加新节点
- en: Fault tolerance
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容错性
- en: Data should remain available even if some nodes fail. This requires implementing
    replication and ensuring that our system can handle node failures gracefully without
    data loss or significant downtime.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 即使某些节点失败，数据也应保持可用。这需要实现复制并确保我们的系统可以优雅地处理节点故障，而不会导致数据丢失或显著的中断时间。
- en: 'Here are some key points to consider:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要考虑的关键点：
- en: High availability despite node failures
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使节点故障也能保持高可用性
- en: Data replication across multiple nodes
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个节点之间进行数据复制
- en: Graceful handling of node failures
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优雅地处理节点故障
- en: Data expiry and eviction
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据过期和驱逐
- en: Our cache should efficiently manage memory by expiring old data and evicting
    less frequently accessed data. Implementing **time to live** (**TTL**) and **least
    recently used** (**LRU**) eviction policies will help us manage limited memory
    resources effectively.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的缓存应该通过过期旧数据和驱逐访问频率较低的数据来高效地管理内存。实施**生存时间**（**TTL**）和**最近最少使用**（**LRU**）驱逐策略将帮助我们有效地管理有限的内存资源。
- en: 'The following are some key points to consider:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要考虑的关键点：
- en: Efficient memory management
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效的内存管理
- en: Implementing TTL and LRU eviction policies
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施TTL和LRU驱逐策略
- en: Keeping the cache fresh and relevant
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持缓存的新鲜和相关性
- en: Monitoring and metrics
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监控和指标
- en: To ensure our cache performs optimally, we need robust monitoring and metrics.
    This involves logging cache operations, tracking performance metrics (such as
    hit/miss ratios), and setting up alerts for potential issues.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的缓存性能最优，我们需要强大的监控和指标。这包括记录缓存操作、跟踪性能指标（如命中率/未命中率的比率），并为潜在问题设置警报。
- en: 'Here are some key points to consider:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要考虑的关键点：
- en: Robust monitoring of cache operations
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对缓存操作的强大监控
- en: Performance metrics (hit/miss ratios)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能指标（命中率/未命中率）
- en: Alerts for potential issues
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对潜在问题的警报
- en: Security
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全性
- en: Security is non-negotiable. We need to ensure that our cache is secure from
    unauthorized access and potential attacks. This involves implementing authentication,
    encryption, and secure communication channels.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是不可协商的。我们需要确保我们的缓存免受未经授权的访问和潜在攻击。这包括实现身份验证、加密和安全的通信通道。
- en: 'The following are some key points to consider:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是需要考虑的一些关键点：
- en: Securing the cache from unauthorized access
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护缓存免受未经授权的访问
- en: Implementing authentication and encryption
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施身份验证和加密
- en: Ensuring secure communication channels
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保安全的通信通道
- en: Speed – in-memory storage provides rapid access to data
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速度——内存存储提供对数据的快速访问
- en: Volatility – data stored in memory is volatile and can be lost if the node fails
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易变性——存储在内存中的数据是易变的，如果节点失败可能会丢失
- en: 'Now that we’ve embraced our requirements, it’s time to dive into the core of
    the project: the design decisions. Imagine that you’re a master chef who’s been
    handed a list of ingredients and asked to create a five-star dish. The ingredients
    are your requirements, but how you combine them, what cooking techniques you use,
    and the presentation – well, that’s all up to your design decisions.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经接受了我们的需求，现在是时候深入项目的核心：设计决策。想象一下，你是一位大师级厨师，手里拿着一份配料清单，并被要求制作一道五星级菜品。配料是你的需求，但如何组合它们，使用什么烹饪技术，以及展示——这些都取决于你的设计决策。
- en: Designing a distributed cache is no different. Each requirement we’ve outlined
    necessitates thoughtful consideration and careful selection of strategies and
    technologies. The trade-offs we make will determine how well our cache performs,
    scales, handles faults, maintains consistency, and so on.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 设计分布式缓存并没有不同。我们概述的每个需求都需要深思熟虑和仔细选择策略和技术。我们做出的权衡将决定我们的缓存性能、扩展性、错误处理、一致性等方面表现如何。
- en: Design and trade-offs
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计和权衡
- en: Alright, brace yourselves, because we’re diving into the deep end of design
    decisions. Think of it as being handed a pristine Go environment and being asked
    to build a distributed cache. Simple, right? Sure, if by “simple” you mean navigating
    a minefield of trade-offs that could blow up your system if you take one wrong
    step.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，准备好吧，因为我们将要深入设计决策的深处。把它想象成被 handed 一个全新的 Go 环境，并被要求构建一个分布式缓存。简单吗？当然，如果你认为“简单”意味着在一片雷区中导航，任何一步错误都可能让你的系统崩溃。
- en: Creating the project
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建项目
- en: 'Although the fully tested and functional version of our cache is available
    in this book’s GitHub repository, let’s reproduce all the steps to make our cache
    system:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们缓存系统的完整测试和功能版本已在本书的GitHub仓库中提供，但让我们重新执行所有步骤以构建我们的缓存系统：
- en: 'Creating the project directory:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建项目目录：
- en: '[PRE0]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Initialize the `go` module:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化`go`模块：
- en: '[PRE1]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create the `cache.go` file:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`cache.go`文件：
- en: '[PRE2]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code defines a simple cache data structure for storing and retrieving string
    values using string keys. Think of it as a temporary storage space where you can
    put values and quickly get them back later by remembering their associated keys.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码定义了一个简单的缓存数据结构，用于使用字符串键存储和检索字符串值。将其视为一个临时存储空间，你可以在这里放置值，并通过记住它们的关联键，稍后快速取回。
- en: How can we know if this code works?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道这段代码是否工作？
- en: 'Luckily, I read your mind and heard you shouting silently: **Tests!**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我读懂了你的心思，听到了你无声的呼喊：**测试！**
- en: From time to time, look in the test files to learn how we’re testing our project
    components.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 不时查看测试文件，了解我们如何测试项目组件。
- en: We have a simple cache in memory, but concurrent access is not secure. Let’s
    solve this issue by choosing a way to handle thread safety.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个简单的内存缓存，但并发访问并不安全。让我们通过选择一种处理线程安全的方法来解决此问题。
- en: Thread safety
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全
- en: 'Ensuring concurrency safety is crucial to prevent data races and inconsistencies
    when multiple goroutines access the cache simultaneously. Here are some options
    you can consider:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 确保并发安全性对于防止多个goroutine同时访问缓存时的数据竞争和不一致性至关重要。以下是一些你可以考虑的选项：
- en: 'The standard library’s `sync` package:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准库的`sync`包：
- en: '`sync.Mutex`: The simplest way to achieve concurrency safety is to use a mutex
    to lock the entire cache during read or write operations. This ensures that only
    one goroutine can access the cache at a time. However, it can lead to contention
    and reduced performance under heavy load.'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync.Mutex`：实现并发安全的最简单方法是使用互斥锁在读取或写入操作期间锁定整个缓存。这确保了每次只有一个goroutine可以访问缓存。然而，在负载较重的情况下，它可能导致竞争和性能下降。'
- en: '`sync.RWMutex`: A read-write mutex allows multiple readers to access the cache
    concurrently, but only one writer at a time. This can improve performance when
    reading is more frequent than writing.'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync.RWMutex`：读写互斥锁允许多个读取者并发访问缓存，但一次只有一个写入者。当读取比写入更频繁时，这可以提高性能。'
- en: 'Concurrent map implementations:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发映射实现：
- en: '`sync.Map`: Go provides a built-in concurrent map implementation that handles
    synchronization internally. It’s optimized for frequent reads and infrequent writes,
    making it a such as choice for many caching scenarios.'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync.Map`：Go提供了一个内置的并发映射实现，它内部处理同步。它针对频繁读取和偶尔写入进行了优化，因此对于许多缓存场景来说是一个很好的选择。'
- en: '`hashicorp/golang-lru`([https://github.com/hashicorp/golang-lru](https://github.com/hashicorp/golang-lru)),
    `patrickmn/go-cache`([https://github.com/patrickmn/go-cache](https://github.com/patrickmn/go-cache)),
    and `dgraph-io/ristretto` ([https://github.com/dgraph-io/ristretto](https://github.com/dgraph-io/ristretto))
    offer concurrent-safe cache implementations with additional features such as eviction
    policies and expiration.'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hashicorp/golang-lru`([https://github.com/hashicorp/golang-lru](https://github.com/hashicorp/golang-lru))、`patrickmn/go-cache`([https://github.com/patrickmn/go-cache](https://github.com/patrickmn/go-cache))和`dgraph-io/ristretto`
    ([https://github.com/dgraph-io/ristretto](https://github.com/dgraph-io/ristretto))提供了具有额外功能（如淘汰策略和过期策略）的并发安全缓存实现。'
- en: 'Lock-free data structures:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无锁数据结构：
- en: '**Atomic operations**: For specific use cases, you might employ atomic operations
    to perform certain updates without explicit locking. However, this requires careful
    design and is generally more complex to implement correctly.'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子操作**：对于特定的用例，你可能会使用原子操作来执行某些更新，而无需显式锁定。然而，这需要仔细设计，并且通常更复杂，难以正确实现。 '
- en: 'Channel-based synchronization:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于通道的同步：
- en: '**Serializing access**: You can create a dedicated goroutine that handles all
    cache operations. Other goroutines communicate with this goroutine through channels,
    effectively serializing access to the cache.'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列化访问**：你可以创建一个专门的处理所有缓存操作的goroutine。其他goroutine通过通道与这个goroutine通信，有效地序列化对缓存的访问。'
- en: '**Sharded cache**: Divide the cache into multiple shards, each protected by
    its own mutex or concurrent map. This can reduce contention by distributing the
    load across multiple locks.'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分片缓存**：将缓存分成多个分片，每个分片由其自己的互斥锁或并发映射保护。这可以通过在多个锁之间分配负载来减少竞争。'
- en: Choosing the right approach
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择正确的方法
- en: 'The best approach for concurrency safety depends on your specific requirements:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 并发安全性的最佳方法取决于您的具体需求：
- en: '`sync.RWMutex` or `sync.Map` might be a suitable choice'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync.RWMutex`或`sync.Map`可能是一个合适的选择'
- en: '**Performance**: If maximum performance is critical, consider lock-free data
    structures or a sharded cache'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：如果最大性能至关重要，考虑无锁数据结构或分片缓存'
- en: '`sync.Mutex` or a channel-based approach might be simpler'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync.Mutex`或基于通道的方法可能更简单'
- en: For now, let’s make things simpler. A `sync.RWMutex` will strike the right balance
    between simplicity and performance.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们简化一下。一个`sync.RWMutex`将在简单性和性能之间取得平衡。
- en: Adding thread safety
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加线程安全性
- en: 'We must update `cache.go` to add thread safety using `sync.RWMutex`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须更新`cache.go`以使用`sync.RWMutex`添加线程安全性：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now we’re talking! Our cache is now thread-safe. What about the interface to
    the external world? Let’s explore the possibilities.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来谈谈重点！我们的缓存现在是线程安全的。那么，外部世界的接口呢？让我们来探讨一下可能性。
- en: The interface
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: When designing a distributed cache, one of the key decisions you’ll face is
    choosing the appropriate program interface for communication between clients and
    the cache servers. The main options available are the **Transmission Control Protocol**
    (**TCP**), **Hypertext Transfer Protocol** (**HTTP**), and other specialized protocols.
    Each has its own set of advantages and trade-offs, and understanding these will
    help us make an informed decision. For our project, we’ll settle on HTTP as the
    interface of choice, but let’s explore why.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计分布式缓存时，你将面临的关键决策之一是选择客户端与缓存服务器之间通信的适当程序接口。可供选择的主要选项包括**传输控制协议**（**TCP**）、**超文本传输协议**（**HTTP**）以及其他专用协议。每种协议都有自己的优缺点，了解这些将帮助我们做出明智的决定。对于我们的项目，我们将选择HTTP作为首选接口，但让我们来探讨一下原因。
- en: TCP
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP
- en: As we saw in previous chapters, TCP is a cornerstone of modern networking, but
    like any technology, it comes with its own set of trade-offs. On the one hand,
    TCP shines in its efficiency. Operating at a low level, it minimizes overhead,
    making it a lean and mean communication machine. This efficiency is often coupled
    with superior performance compared to higher-level protocols, especially in terms
    of latency and throughput, making it a preferred choice for applications where
    speed is critical. Moreover, TCP empowers developers with granular control over
    connection management, data flow regulation, and error handling, allowing for
    tailored solutions to specific networking challenges.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中看到的，TCP是现代网络的基础，但像任何技术一样，它也有自己的权衡。一方面，TCP在效率上表现出色。在低级别运行，它最小化了开销，使其成为一个精简高效的通信机器。这种效率通常伴随着与高级协议相比的优越性能，尤其是在延迟和吞吐量方面，使其成为速度至关重要的应用程序的首选。此外，TCP赋予开发者对连接管理、数据流调节和错误处理的细粒度控制，允许针对特定的网络挑战定制解决方案。
- en: However, this power and efficiency come at a price. The inner workings of TCP
    are intricate, requiring a deep dive into the world of network programming. Implementing
    a TCP-based interface often means manually grappling with connection establishment,
    data packet assembly, and error mitigation strategies, demanding both expertise
    and time. Even with the technical know-how, developing a robust TCP interface
    can be a lengthy process, potentially delaying project timelines. Another hurdle
    lies in the lack of standardization for application-level protocols built upon
    TCP. While TCP itself adheres to well-defined standards, the protocols that are
    layered on top often vary widely, leading to compatibility headaches and hindering
    seamless communication between different systems.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种力量和效率是有代价的。TCP的内部机制复杂，需要深入网络编程的世界。实现基于TCP的接口通常意味着手动处理连接建立、数据包组装和错误缓解策略，这需要专业知识和时间。即使拥有技术知识，开发一个健壮的TCP接口也可能是一个漫长的过程，可能会延迟项目时间表。另一个挑战是建立在TCP之上的应用层协议缺乏标准化。虽然TCP本身遵循了明确的标准，但建立在它之上的协议往往差异很大，导致兼容性问题，阻碍了不同系统之间的无缝通信。
- en: In essence, TCP is a powerful tool with the potential for high performance and
    customization, but it requires a significant investment in terms of development
    effort and expertise.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，TCP是一个功能强大的工具，具有高性能和定制的潜力，但它在开发努力和专业知识方面需要巨大的投资。
- en: HTTP
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP
- en: With its clear-cut request/response model, HTTP is relatively easy to grasp
    and implement, even for developers new to networking. This ease of use is further
    bolstered by its status as a widely embraced standard, ensuring seamless compatibility
    across diverse platforms and clients. Additionally, the vast ecosystem surrounding
    HTTP, brimming with tools, libraries, and frameworks, accelerates development
    and deployment cycles. And let’s not forget its stateless nature, which simplifies
    scaling and fault tolerance, making it easier to handle increased traffic and
    unexpected failures.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有了清晰明了的请求/响应模型，HTTP 相对容易理解和实现，即使是对于网络新手开发者来说也是如此。这种易用性因其作为广泛接受的标准的地位而得到进一步加强，确保了在不同平台和客户端之间的无缝兼容性。此外，围绕
    HTTP 的庞大生态系统，充满了工具、库和框架，加速了开发和部署周期。而且，我们不应忘记它的无状态特性，这简化了扩展和容错，使得处理增加的流量和意外故障变得更加容易。
- en: However, like any technology, HTTP isn’t without its drawbacks. Its simplicity
    comes with a trade-off in the form of overhead. The inclusion of headers and reliance
    on text-based formatting introduce additional data, potentially impacting performance
    in bandwidth-constrained environments. Furthermore, while statelessness offers
    scaling advantages, it can also lead to increased latency compared to persistent
    TCP connections. Each request necessitates establishing a fresh connection, a
    process that can add up over time unless newer protocols such as HTTP/2 or keep-alive
    mechanisms are employed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，像任何技术一样，HTTP 并非没有缺点。它的简单性以开销为代价。头部的包含和对基于文本的格式的依赖引入了额外的数据，可能会在带宽受限的环境中影响性能。此外，虽然无状态提供了扩展优势，但它与持久
    TCP 连接相比也可能导致更高的延迟。每个请求都需要建立一个新的连接，这个过程可能会随着时间的推移而累积，除非采用如 HTTP/2 或 keep-alive
    机制等新协议。
- en: In essence, HTTP provides a straightforward, standardized, and widely supported
    foundation for web communication. Its simplicity and vast ecosystem make it a
    popular choice for many applications. However, developers must be mindful of the
    potential overhead and latency implications, especially in scenarios where performance
    is paramount.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，HTTP 为网络通信提供了一个简单、标准化且广泛支持的基石。它的简单性和庞大的生态系统使其成为许多应用的流行选择。然而，开发者必须注意潜在的开销和延迟影响，尤其是在性能至关重要的场景中。
- en: Others
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他
- en: gRPC emerges as a high-performance contender in the world of network communication.
    It harnesses the power of HTTP/2 and **Protocol Buffers** (**Protobuf**) to deliver
    efficient, low-latency interactions. The use of Protobuf introduces strong typing
    and well-defined service contracts, leading to more robust and maintainable code.
    However, this power comes with a touch of complexity. Setting up gRPC requires
    support for both HTTP/2 and Protobuf, which may not be universally available,
    and the learning curve can be steeper compared to simpler protocols.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 在网络通信领域成为了一个高性能的竞争者。它利用了 HTTP/2 和 **协议缓冲区**（**Protobuf**）的力量，以提供高效、低延迟的交互。使用
    Protobuf 引入了强类型和定义良好的服务合同，从而导致了更健壮和可维护的代码。然而，这种力量也带来了一丝复杂性。设置 gRPC 需要支持 HTTP/2
    和 Protobuf，这可能并非普遍可用，而且与简单协议相比，学习曲线可能更陡峭。
- en: 'Alternatively, WebSockets offer a different kind of advantage: full-duplex
    communication. Through a single, persistent connection, WebSockets enable real-time,
    bidirectional data flow between client and server. This makes them ideal for applications
    such as chat, gaming, or live dashboards where instant updates are crucial. However,
    this flexibility comes with challenges. Implementing and managing WebSocket connections
    can be more intricate than traditional request/response models. The requirement
    for long-lived connections can also complicate scaling and introduce potential
    points of failure that need to be handled carefully.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，WebSockets 提供了一种不同的优势：全双工通信。通过一个单一、持久的连接，WebSockets 允许客户端和服务器之间进行实时、双向的数据流。这使得它们非常适合聊天、游戏或实时仪表板等需要即时更新的应用。然而，这种灵活性也伴随着挑战。实现和管理
    WebSocket 连接可能比传统的请求/响应模型更为复杂。长期连接的需求也可能使扩展变得复杂，并引入需要谨慎处理的可能性。
- en: In essence, gRPC and WebSockets each excel in different domains. gRPC shines
    in scenarios where efficiency and well-structured communication are paramount,
    while WebSockets unlock the potential for seamless real-time interactions. The
    choice between them often boils down to the specific requirements of the application
    and the trade-offs developers are willing to make.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，gRPC和WebSockets各自在不同的领域表现出色。gRPC在效率和结构化通信至关重要的场景中闪耀，而WebSockets则释放了无缝实时交互的潜力。它们之间的选择通常取决于应用程序的具体要求和开发者愿意做出的权衡。
- en: Decision – why HTTP for our project?
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 决策 - 为什么我们的项目选择HTTP？
- en: 'Given the requirements and the nature of our distributed cache project, HTTP
    stands out as the most suitable choice for several reasons:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们的分布式缓存项目的要求和性质，HTTP因其几个原因而成为最合适的选择：
- en: '**Simplicity and ease of use**: HTTP’s well-defined request/response model
    makes it easy to implement and understand. This simplicity is especially beneficial
    for a project intended to make us learn the core concepts.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性和易用性**：HTTP定义良好的请求/响应模型使其易于实现和理解。这种简单性对于旨在让我们学习核心概念的项目特别有益。'
- en: '**Standardization and compatibility**: HTTP is a widely adopted standard with
    broad compatibility across different platforms, programming languages, and clients.
    This ensures that our cache can be easily integrated with various applications
    and tools.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准化和兼容性**：HTTP是一个广泛采用的标准，具有跨不同平台、编程语言和客户端的广泛兼容性。这确保我们的缓存可以轻松集成到各种应用程序和工具中。'
- en: '**Rich ecosystem**: The rich ecosystem of libraries, tools, and frameworks
    available for HTTP can significantly speed up development. We can leverage existing
    solutions for tasks such as request parsing, routing, and connection management.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**丰富的生态系统**：可用的丰富库、工具和框架生态系统可以显著加快HTTP的开发速度。我们可以利用现有的解决方案来处理请求解析、路由和连接管理等任务。'
- en: '**Statelessness**: HTTP’s stateless nature simplifies scaling and fault tolerance.
    Each request is independent, making it easier to distribute load across multiple
    nodes and recover from failures.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态性**：HTTP的无状态特性简化了扩展和容错。每个请求都是独立的，这使得在多个节点之间分配负载和从故障中恢复变得更加容易。'
- en: '**Development speed**: Using HTTP allows us to focus on implementing the core
    functionality of the distributed cache rather than getting bogged down with low-level
    networking details. This is crucial for getting things up and running, where the
    goal is to convey key concepts without unnecessary complexity. We can add another
    protocol once the project is ready.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发速度**：使用HTTP使我们能够专注于实现分布式缓存的核心功能，而不是陷入低级网络细节的泥潭。这对于快速启动和运行至关重要，目标是在不必要复杂性的情况下传达关键概念。一旦项目准备就绪，我们就可以添加另一个协议。'
- en: Introducing the HTTP server
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍HTTP服务器
- en: 'Create `server.go` that will include HTTP handlers:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`server.go`文件，该文件将包含HTTP处理器：
- en: '[PRE4]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To initialize our server, we should create `main.go` like so:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化我们的服务器，我们应该创建`main.go`文件，如下所示：
- en: '[PRE5]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we can run our cache server for the very first time! In the terminal,
    run the following command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行我们的缓存服务器第一次了！在终端中，运行以下命令：
- en: '[PRE6]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The server should now be running on `http://localhost:8080`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器现在应该运行在`http://localhost:8080`。
- en: You can use `curl` (or a tool such as Postman) to interact with your server.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`curl`（或Postman等工具）与您的服务器进行交互。
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This should return a `200` `OK` status.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回`200` `OK`状态。
- en: 'To get the value, we can do something very similar:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取值，我们可以做类似的事情：
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This should return `{"value":"bar"}` if the key exists.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键存在，这应该返回`{"value":"bar"}`。
- en: Choosing HTTP as the interface for our distributed cache project strikes a balance
    between simplicity, standardization, and ease of integration. While TCP offers
    performance benefits, the complexity it introduces outweighs its advantages for
    our educational purposes. By using HTTP, we can leverage a widely understood and
    supported protocol, making our distributed cache accessible, scalable, and easy
    to implement. With this decision made, we can now focus on building out the core
    functionality and features of our distributed cache.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 选择HTTP作为我们分布式缓存项目的接口，在简单性、标准化和易于集成之间取得了平衡。虽然TCP提供了性能优势，但其引入的复杂性超过了我们的教育目的的优势。通过使用HTTP，我们可以利用一个广泛理解和支持的协议，使我们的分布式缓存易于访问、可扩展且易于实现。做出这个决定后，我们现在可以专注于构建分布式缓存的核心功能和特性。
- en: Eviction policies
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 驱逐策略
- en: We can’t just keep everything in memory indefinitely, right? Eventually, we’ll
    run out of space. This is where eviction policies come into play. An eviction
    policy determines which items are removed from the cache when the cache reaches
    its maximum capacity. Let’s explore some common eviction policies, discuss their
    trade-offs, and determine the best fit for our distributed cache project.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能永远把所有东西都保留在内存中，对吧？最终，我们会耗尽空间。这就是驱逐策略发挥作用的地方。驱逐策略决定了当缓存达到最大容量时，哪些项会被从缓存中移除。让我们探讨一些常见的驱逐策略，讨论它们的权衡，并确定最适合我们分布式缓存项目的方案。
- en: LRU
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LRU
- en: LRU evicts the least recently accessed item first. It assumes that items that
    haven’t been accessed recently are less likely to be accessed in the future.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: LRU首先移除最不最近访问的项。它假设那些最近没有被访问的项不太可能在未来被访问。
- en: 'Advantages:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: '**Predictable**: Simple to implement and understand'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可预测性**：易于实现和理解'
- en: '**Effective**: Works well for many access patterns where recently used items
    are more likely to be reused'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有效**：对于许多访问模式，其中最近使用过的项更有可能被重用，效果良好'
- en: 'Disadvantages:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: '**Memory overhead**: Requires maintaining a list or other structure to track
    access order, which can add some memory overhead'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存开销**：需要维护一个列表或其他结构来跟踪访问顺序，这可能会增加一些内存开销'
- en: '**Complexity**: Slightly more complex to implement than FIFO or random eviction'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂性**：比FIFO或随机驱逐稍微复杂一些'
- en: TTL
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TTL
- en: TTL assigns an expiration time to each cache item. When the item’s time is up,
    it’s evicted from the cache.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: TTL为每个缓存项分配一个过期时间。当项的时间到了，它就会被从缓存中移除。
- en: 'Advantages:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: '**Simplicity**: Easy to understand and implement'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性**：易于理解和实现'
- en: '**Freshness**: Ensures that data in the cache is fresh and relevant'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**新鲜度**：确保缓存中的数据是新鲜和相关的'
- en: 'Disadvantages:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: '**Predictability**: Less predictable than LRU as items are evicted based on
    time rather than usage'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可预测性**：比LRU的可预测性低，因为项的移除是基于时间而不是使用情况'
- en: '**Resource management**: This may require additional resources to periodically
    check and remove expired items'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源管理**：这可能需要额外的资源来定期检查和移除过期的项'
- en: First-in, first-out (FIFO)
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 先入先出（FIFO）
- en: FIFO evicts the oldest item in the cache based on the time it was added.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: FIFO基于项被添加的时间来驱逐缓存中最旧的项。
- en: 'Advantages:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: '**Simplicity**: Very easy to implement'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性**：非常易于实现'
- en: '**Predictability**: Predictable eviction pattern'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可预测性**：可预测的驱逐模式'
- en: 'Disadvantages:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: '**Inefficiency**: Doesn’t consider how recently an item was accessed, potentially
    evicting frequently used items'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低效**：没有考虑项最近被访问的情况，可能会驱逐频繁使用的项'
- en: Choosing the right eviction policy
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 选择合适的驱逐策略
- en: For our distributed cache project, we’ll need to balance performance, memory
    management, and simplicity. Given these considerations, LRU and TTL are both strong
    candidates.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的分布式缓存项目，我们需要在性能、内存管理和简单性之间取得平衡。考虑到这些因素，LRU和TTL都是强有力的候选方案。
- en: LRU is ideal for scenarios where the most recently accessed data is likely to
    be accessed again soon. It helps keep frequently accessed items in memory, which
    can improve cache hit rates. TTL ensures that data is fresh and relevant by evicting
    items after a certain period. This is particularly useful when cached data can
    become stale quickly.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: LRU适用于最近期访问的数据很可能很快再次被访问的场景。它有助于将频繁访问的项保留在内存中，这可以提高缓存命中率。TTL通过在特定时间后移除项来确保数据的新鲜和相关性。这在缓存数据可能很快变得陈旧的情况下特别有用。
- en: 'For our project, we’ll implement both LRU and TTL policies. This combination
    allows us to handle different use cases effectively: LRU for performance optimization
    based on access patterns, and TTL for ensuring data freshness.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，我们将实现LRU和TTL策略。这种组合使我们能够有效地处理不同的用例：LRU基于访问模式进行性能优化，TTL确保数据的新鲜性。
- en: Let’s incrementally add TTL and LRU eviction policies to our implementation.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步添加TTL和LRU驱逐策略到我们的实现中。
- en: Adding TTL
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加TTL
- en: 'There are two main approaches to adding TTL to our cache: using a goroutine
    with `Ticker` and evicting during `Get`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 向我们的缓存添加TTL的主要有两种方法：使用带有`Ticker`的goroutine和`Get`时驱逐。
- en: Goroutine with Ticker
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 带有Ticker的Goroutine
- en: 'In this approach, we can use a separate goroutine to run `time.Ticker`. The
    ticker periodically triggers the `evictExpiredItems` function to check for and
    remove expired entries. Let’s analyze the trade-offs:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们可以使用一个单独的goroutine来运行`time.Ticker`。这个ticker定期触发`evictExpiredItems`函数来检查和移除过期的条目。让我们分析一下权衡：
- en: '`Get` method doesn’t need to perform eviction checks, potentially making it
    slightly faster in cases where many items have expired.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Get`方法不需要执行驱逐检查，在许多项目已过期的情况下，可能会使其稍微快一些。'
- en: '**Cons**:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：'
- en: '**Additional goroutine**: This introduces the overhead of managing a separate
    goroutine and ticker'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**额外的goroutine**：这引入了管理单独goroutine和ticker的开销'
- en: '**Unnecessary checks**: If items expire infrequently or the cache is small,
    the periodic checks might be unnecessary overhead'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不必要的检查**：如果项目很少过期或缓存较小，周期性检查可能是不必要的开销'
- en: Eviction during Get
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在`Get`操作期间驱逐
- en: 'In this approach, we don’t need a separate goroutine or ticker. The expiration
    checks are performed only when an item is accessed using the `Get` method. If
    the item has expired, it’s evicted before the “not found” response is returned.
    Let’s analyze the trade-offs:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们不需要单独的goroutine或ticker。只有在使用`Get`方法访问项目时才会执行过期检查。如果项目已过期，它将在返回“未找到”响应之前被驱逐。让我们分析一下权衡：
- en: '**Pros**:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：'
- en: '**Simpler implementation**: There’s no need to manage an extra goroutine, which
    leads to less complex code'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更简单的实现**：不需要管理额外的goroutine，这导致代码更简单'
- en: '**Reduced overhead**: Avoids the potential overhead of a continuously running
    goroutine'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**降低开销**：避免了持续运行的goroutine的潜在开销'
- en: '**On-demand eviction**: Resources are only used for eviction when necessary'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按需驱逐**：仅在必要时使用驱逐资源'
- en: '`Get` might add some latency'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Get`可能会增加一些延迟'
- en: Which approach is better?
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种方法更好？
- en: The “better” approach depends on your specific use case and priorities.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: “更好的”方法取决于您的具体用例和优先级。
- en: 'You should choose the first approach in the following instances:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，您应该选择第一种方法：
- en: '- You need strict control over when items are evicted and want to ensure a
    clean cache regardless of access patterns'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '- 您需要严格控制项目何时被驱逐，并确保无论访问模式如何都能保持缓存干净'
- en: '- You have a large cache with frequent expirations, and the overhead of the
    goroutine is acceptable'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '- 您有一个大缓存，且频繁过期，goroutine的开销是可以接受的'
- en: '- Minimizing latency on `Get` operations is critical, even if it means slightly
    higher overall overhead'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '- 在`Get`操作中尽量减少延迟至关重要，即使这意味着整体开销略高'
- en: 'On the other hand, you should choose the second approach in the following instances:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在以下情况下，您应该选择第二种方法：
- en: '- You want a simpler implementation with minimal overhead'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '- 您希望有一个简单实现，且开销最小'
- en: '- You are comfortable with some delay in eviction if items are eventually removed'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '- 如果项目最终被移除，您对驱逐的延迟可以接受'
- en: '- Your cache is relatively small, and the potential latency on `Get` due to
    eviction is acceptable'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '- 您的缓存相对较小，由于驱逐导致的`Get`潜在延迟是可以接受的'
- en: You could potentially combine both approaches. Use the second approach for most
    cases but periodically run a separate eviction process (the first approach) as
    a background task to clean up any remaining expired items.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将两种方法结合起来。对于大多数情况使用第二种方法，但定期运行一个单独的驱逐过程（第一种方法）作为后台任务来清理任何剩余的已过期项目。
- en: All things considered, let’s proceed with the goroutine version so that we can
    focus on the `Get` method’s latency.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有因素，让我们先使用goroutine版本，这样我们可以专注于`Get`方法的延迟。
- en: 'We’ll modify the `CacheItem` struct so that it includes an expiry time and
    add logic to the `Set` and `Get` methods so that they can handle TTL:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改`CacheItem`结构体，使其包括过期时间，并将逻辑添加到`Set`和`Get`方法中，以便它们可以处理TTL：
- en: '[PRE9]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we’ll add a background goroutine to periodically evict expired items:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个后台goroutine，定期驱逐已过期项目：
- en: '[PRE10]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Also, during the cache’s initialization (`main.go`), we need to start this
    goroutine:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在缓存初始化（`main.go`）期间，我们需要启动这个goroutine：
- en: '[PRE11]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Adding LRU
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加LRU
- en: We’ll enhance our cache implementation by adding an LRU eviction policy. LRU
    ensures that the least recently accessed items are evicted first when the cache
    reaches its maximum capacity. We will use a doubly linked list to keep track of
    the access order of cache items.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过添加LRU驱逐策略来增强我们的缓存实现。LRU确保当缓存达到最大容量时，最不常访问的项目首先被驱逐。我们将使用双向链表来跟踪缓存项的访问顺序。
- en: 'First, we need to modify our `Cache` struct so that it includes a doubly-linked
    list (`list.List`) for eviction and a `map` struct to keep track of the list elements.
    Additionally, we’ll define a `capacity` struct to limit the number of items in
    the cache:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要修改我们的`Cache`结构体，使其包括用于驱逐的双向链表（`list.List`）和一个`map`结构来跟踪列表元素。此外，我们将定义一个`capacity`结构来限制缓存中的项目数量：
- en: '[PRE12]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we’ll modify the `Set` method so that it manages the doubly linked list
    and enforces the cache capacity:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将修改 `Set` 方法，使其管理双向链表并强制执行缓存容量：
- en: '[PRE13]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, we should pay attention to the following aspects:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们应该注意以下方面：
- en: '**Check if the key exists**: If the key already exists in the cache, remove
    the old value from the doubly linked list and the map'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查键是否存在**：如果键已经在缓存中，则从双向链表和映射中删除旧值'
- en: '`evictLRU` to remove the least recently used item'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`evictLRU` 用于移除最近最少使用项'
- en: '**Add a new item**: Add the new item to the front of the list and update the
    map'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加新项**：将新项添加到列表的前端并更新映射'
- en: 'Now, we need to update the `Get` method so that it can move accessed items
    to the front of the eviction list:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更新 `Get` 方法，使其可以将访问过的项移动到清除列表的前端：
- en: '[PRE14]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, if the item is found but has expired, it’s removed from
    the list and the map. Also, when the item is valid, the code moves it to the front
    of the list to mark it as recently accessed.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，如果找到项但已过期，则从列表和映射中删除它。此外，当项有效时，代码将其移动到列表的前端以标记为最近访问。
- en: 'We should also implement the `evictLRU` method to handle the least recently
    used item being evicted:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该实现 `evictLRU` 方法来处理最近最少使用项被清除的情况：
- en: '[PRE15]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The function removes the item at the back of the list (LRU) and deletes it from
    the map.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数从列表的末尾移除项（LRU）并从映射中删除它。
- en: 'The following code ensures the background eviction routine removes expired
    items periodically:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码确保后台清除例程定期删除过期的项：
- en: '[PRE16]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this snippet, the `startEvictionTicker` function starts a goroutine that
    periodically checks and removes expired items from the cache.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，`startEvictionTicker` 函数启动一个 goroutine，该 goroutine 会定期检查并从缓存中删除过期的项。
- en: 'Lastly, update the `main` function so that it creates a cache with a specified
    capacity and test the TTL and LRU features:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新 `main` 函数，使其创建具有指定容量的缓存并测试 TTL 和 LRU 功能：
- en: '[PRE17]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With that, we’ve incrementally added TTL and LRU eviction features to our cache
    implementation! This enhancement ensures that our cache effectively manages memory
    by keeping frequently accessed items and evicting stale or less-used data. This
    combination of TTL and LRU makes our cache robust, efficient, and well-suited
    for various use cases.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们逐步增加了 TTL 和 LRU 清除功能到我们的缓存实现中！这一增强确保我们的缓存通过保留频繁访问的项并清除过时或较少使用的数据来有效地管理内存。TTL
    和 LRU 的组合使我们的缓存更加健壮、高效，非常适合各种用例。
- en: Eviction policies are a critical aspect of any cache system, directly impacting
    its performance and efficiency. By understanding the trade-offs and strengths
    of LRU, TTL, and other policies, we can make informed decisions that align with
    our project’s goals. Implementing both LRU and TTL in our distributed cache ensures
    we balance performance and data freshness, providing a robust and versatile caching
    solution.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 清除策略是任何缓存系统的关键方面，直接影响其性能和效率。通过了解 LRU、TTL 和其他策略的权衡和优势，我们可以做出符合我们项目目标的有根据的决定。在我们的分布式缓存中实现
    LRU 和 TTL 确保我们平衡性能和数据新鲜度，提供一种健壮且多功能的缓存解决方案。
- en: 'Now that we’ve tackled the vital task of managing our cache’s memory through
    effective eviction policies such as LRU and TTL, it’s time to address another
    critical aspect: replicating our cache.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了通过有效的清除策略如 LRU 和 TTL 管理缓存内存的重要任务，现在是时候解决另一个关键方面：复制我们的缓存。
- en: Replication
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复制
- en: 'To replicate data across multiple instances of your cache server, you have
    several options. Here are some common approaches:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要在多个缓存服务器实例之间复制数据，您有几种选择。以下是一些常见方法：
- en: '**Primary replica replication**: In this setup, one instance is designated
    as the primary, and the others are replicas. The primary handles all writes and
    propagates changes to the replica.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主副本复制**：在这个设置中，一个实例被指定为主副本，其余的是副本。主副本处理所有写入并将更改传播到副本。'
- en: '**Peer-to-peer (P2P) replication**: In P2P replication, all nodes can both
    send and receive updates. This approach is more complex but avoids a single point
    of failure.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对等复制（P2P）**：在对等复制中，所有节点都可以发送和接收更新。这种方法更复杂，但避免了单点故障。'
- en: '**Publish-subscribe (Pub/Sub) model**: This approach uses a message broker
    to broadcast updates to all cache instances.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布-订阅（Pub/Sub）模型**：这种方法使用消息代理向所有缓存实例广播更新。'
- en: '**Distributed consensus protocols**: Protocols such as Raft and Paxos ensure
    strong consistency across replicas. This approach is more complex and often implemented
    using specialized libraries (for example, etcd and Consul).'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式共识协议**: 如Raft和Paxos之类的协议确保副本之间的强一致性。这种方法更复杂，通常使用专门的库（例如etcd和Consul）实现。'
- en: 'Choosing the right replication strategy depends on various factors, such as
    scalability, fault tolerance, ease of implementation, and the specific requirements
    of the application. Here’s why we’ll be going for P2P replication over the other
    three approaches:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 选择合适的复制策略取决于各种因素，例如可扩展性、容错性、实施简便性和应用程序的具体要求。以下是为什么我们将选择P2P复制而不是其他三种方法的原因：
- en: '**Scalability**:'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**:'
- en: '**P2P**: In a P2P architecture, each node can communicate with any other node,
    distributing the load evenly across the network. This allows the system to scale
    horizontally more efficiently as there is no single point of contention.'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**P2P**: 在对等架构中，每个节点可以与任何其他节点通信，将负载均匀地分布在网络上。这允许系统更有效地水平扩展，因为没有单点争用。'
- en: '**Primary replica**: Scalability is limited because the master node can become
    a bottleneck. All write operations are handled by the master, which can lead to
    performance issues as the number of clients increases.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**主副本**: 可扩展性有限，因为主节点可能会成为瓶颈。所有写操作都由主节点处理，随着客户端数量的增加，可能会导致性能问题。'
- en: '**Pub/Sub**: While scalable, the message broker can become a bottleneck or
    single point of failure if not managed properly. Scalability depends on the broker’s
    performance and architecture.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**发布/订阅**: 虽然可扩展，但如果管理不当，消息代理可能会成为瓶颈或单点故障。可扩展性取决于代理的性能和架构。'
- en: '**Distributed consensus protocols**: These can be scalable, but achieving consensus
    among many nodes can introduce latency and complexity. They are often more suitable
    for smaller clusters or where strong consistency is crucial.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**分布式共识协议**: 这些可能是可扩展的，但达成许多节点之间的共识可能会引入延迟和复杂性。它们通常更适合较小的集群或强一致性至关重要的场景。'
- en: '**Fault tolerance**:'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容错性**:'
- en: '**P2P**: In a P2P network, there is no single point of failure. If one node
    fails, the remaining nodes can continue to operate and communicate with each other,
    making the system more robust and resilient.'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**P2P**: 在对等网络中，没有单点故障。如果一个节点失败，其余节点可以继续运行并相互通信，使系统更加健壮和有弹性。'
- en: '**Primary replica**: The primary node is a single point of failure. If the
    primary goes down, the entire system’s write capability is affected until a new
    primary is elected or the old one is restored.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**主副本**: 主节点是一个单点故障。如果主节点宕机，整个系统的写能力将受到影响，直到新的主节点被选举或旧的主节点恢复。'
- en: '**Pub/Sub**: The message broker can be a single point of failure. While you
    can have multiple brokers and failover mechanisms, this adds complexity and more
    moving parts.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**发布/订阅**: 消息代理可能是一个单点故障。虽然你可以有多个代理和故障转移机制，但这增加了复杂性并引入了更多移动部件。'
- en: '**Distributed consensus protocols**: These are designed to handle node failures,
    but they come with increased complexity. Achieving consensus in the presence of
    failures can be challenging and may affect performance.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**分布式共识协议**: 这些旨在处理节点故障，但它们带来了更高的复杂性。在存在故障的情况下达成共识可能具有挑战性，并可能影响性能。'
- en: '**Consistency**:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**:'
- en: '**P2P**: While eventual consistency is more common in P2P systems, you can
    implement mechanisms to ensure stronger consistency if needed. This approach provides
    flexibility in balancing consistency and availability.'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对等网络**: 虽然在P2P系统中最终一致性更为常见，但如果需要，你可以实现机制来确保更强的istency。这种方法在平衡一致性和可用性方面提供了灵活性。'
- en: '**Primary replica**: It typically provides strong consistency since all writes
    go through the master. However, reading consistency might be delayed on replicas.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**主副本**: 它通常提供强一致性，因为所有写入都通过主节点进行。然而，在副本上读取一致性可能会延迟。'
- en: '**Pub/Sub**: It provides eventual consistency as updates are propagated to
    subscribers asynchronously.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**发布/订阅**: 它提供最终一致性，因为更新是异步传播给订阅者的。'
- en: '**Distributed consensus protocols**: These provide strong consistency but at
    the cost of higher latency and complexity.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**分布式共识协议**: 这些提供了强一致性，但代价是更高的延迟和复杂性。'
- en: '**Ease of implementation** **and management**:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实施和管理简便性**:'
- en: '**P2P**: While more complex than primary replica replication, P2P systems can
    be easier to manage at scale because they don’t require a central coordination
    point. Each node is equal, simplifying the architecture.'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**P2P**：虽然比主副本复制更复杂，但P2P系统在规模扩大时可能更容易管理，因为它们不需要中央协调点。每个节点都是平等的，简化了架构。'
- en: '**Primary replica**: This is easier to implement initially but can become complex
    to manage at scale, especially with failover and load balancing mechanisms.'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主副本**：最初实现起来比较容易，但随着规模的扩大，管理可能会变得复杂，尤其是在故障转移和负载均衡机制方面。'
- en: '**Pub/Sub**: This is relatively easy to implement using existing message brokers,
    but managing the broker infrastructure and ensuring high availability can add
    complexity.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布/订阅模式**：使用现有的消息代理实现起来相对容易，但管理代理基础设施并确保高可用性可能会增加复杂性。'
- en: '**Distributed consensus protocols**: These are generally complex to implement
    and manage as they require a deep understanding of consensus algorithms and their
    operational overhead.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式一致性协议**：这些通常在实现和管理方面比较复杂，因为它们需要深入了解一致性算法及其运营开销。'
- en: '**Flexibility**:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**:'
- en: '**P2P**: This offers high flexibility in terms of topology and can adapt to
    changes in the network easily. Nodes can join or leave the network without significant
    disruption.'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**P2P**：在拓扑方面提供了高度的灵活性，并且可以轻松适应网络的变化。节点可以加入或离开网络而不会造成重大干扰。'
- en: '**Master-slave**: This is less flexible due to the centralized nature of the
    master node. Adding or removing nodes requires reconfiguration and can affect
    the system’s availability.'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主从模式**：由于主节点的集中化特性，这不太灵活。添加或删除节点需要重新配置，可能会影响系统的可用性。'
- en: '**Pub/Sub**: This is flexible in terms of adding new subscribers, but the broker
    infrastructure can become complex to manage.'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布/订阅模式**：在添加新订阅者方面具有灵活性，但代理基础设施的管理可能会变得复杂。'
- en: '**Distributed consensus protocols**: These are flexible in terms of fault tolerance
    and consistency but require careful planning and management to handle node changes
    and network partitions.'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式一致性协议**：在容错和一致性方面具有灵活性，但需要仔细规划和管理工作节点变化和网络分区。'
- en: P2P replication is a compelling choice for our cache project. It avoids the
    single point of failure associated with the primary replica and Pub/Sub models
    and is generally more straightforward to scale and manage than distributed consensus
    protocols. While it may not provide the strong consistency guarantees of consensus
    protocols, it offers a balanced approach that can be tailored to meet various
    consistency requirements.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: P2P复制是我们缓存项目的有力选择。它避免了与主副本和发布/订阅模型相关的单点故障，并且通常比分布式一致性协议更容易扩展和管理。虽然它可能不会提供一致性协议的强一致性保证，但它提供了一种平衡的方法，可以根据各种一致性要求进行定制。
- en: Don’t get me wrong! P2P isn’t perfect, but it is a reasonable approach to get
    things going. It also has *hard* problems to solve, such as eventual consistency,
    conflict resolution, replication overhead, bandwidth consumption, and more.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要误解我！P2P并不完美，但它是启动事物的一个合理方法。它也有*困难*的问题要解决，例如最终一致性、冲突解决、复制开销、带宽消耗等等。
- en: Implementing P2P replication
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现P2P复制
- en: 'First, we need to modify the cache server so that it’s aware of the peers:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要修改缓存服务器，使其了解对等方：
- en: '[PRE18]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We also need to create a function to replicate the data to the peers:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要创建一个函数来将数据复制到对等方：
- en: '[PRE19]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The core idea here is to iterate over all the peers (`cs.peers`) in the cache
    server’s configuration and for each peer:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 核心思想是在缓存服务器的配置中迭代所有对等方(`cs.peers`)，并对每个对等方：
- en: 'For each peer, the following happens:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个对等方，以下情况发生：
- en: A new goroutine (`go func(...)`) is launched. This allows replication to happen
    concurrently for each peer, improving performance.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动一个新的goroutine (`go func(...)`)。这允许对每个对等方并发进行复制，从而提高性能。
- en: An HTTP POST request is constructed to send the JSON data to the peer’s `/``set`
    endpoint.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造一个HTTP POST请求，将JSON数据发送到对等方的`/set`端点。
- en: A custom header called `replicationHeader` is added to the request. This likely
    helps the receiving peer distinguish replication requests from regular client
    requests.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在请求中添加了一个名为`replicationHeader`的自定义头。这有助于接收方区分复制请求和常规客户端请求。
- en: The HTTP request is sent using `client.Do(req)`.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`client.Do(req)`发送HTTP请求。
- en: If there are any errors during request creation or sending, they’re logged.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在请求创建或发送过程中出现任何错误，它们将被记录。
- en: 'We can now use the replication during our `SetHandler`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在`SetHandler`期间使用复制：
- en: '[PRE20]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This new conditional block serves as a check to determine whether an incoming
    request to the cache server (`r`) is a regular client request or a replication
    request from another cache server. Based on this determination, it decides whether
    to trigger further replication to other peers.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的条件块充当检查，以确定传入缓存服务器的请求（`r`）是常规客户端请求还是来自另一个缓存服务器的复制请求。根据这个判断，它决定是否触发对其他对等节点的进一步复制。
- en: 'To glue everything together, let’s change the main function so that it receives
    the peers and bootstraps the code with them:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将所有这些整合在一起，让我们修改主函数，使其接收对等节点并用它们启动代码：
- en: '[PRE21]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With that, the implementation is complete! Let’s run two instances of our cache
    and see if our data is being replicated.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，实现就完成了！让我们运行我们缓存的两个实例，看看我们的数据是否正在复制。
- en: 'Let’s run the first instance:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行第一个实例：
- en: '[PRE22]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let’s run the second instance:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行第二个实例：
- en: '[PRE23]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can now use `curl` or any HTTP client to test the `Set` and `Get` operations
    across the cluster.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用 `curl` 或任何 HTTP 客户端来测试集群中的 `Set` 和 `Get` 操作。
- en: 'Set a key-value pair:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个键值对：
- en: '[PRE24]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Get the key-value pair from a different instance:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 从不同的实例获取键值对：
- en: '[PRE25]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You should see a value of `bar` if the replication is working correctly.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果复制工作正常，你应该会看到一个值为 `bar`。
- en: Check the logs of each instance to see the replication process in action. You
    should see log entries being applied across all instances! If you’re feeling adventurous,
    run multiple instances of the cache and see the dance of replication in front
    of your very eyes.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 检查每个实例的日志以查看复制过程正在运行。你应该会看到日志条目正在所有实例上应用！如果你感到好奇，可以运行多个缓存实例，亲眼看到复制在眼前舞动。
- en: We can add features and optimize our cache infinitely, but infinite seems too
    much for our project. The last piece of our puzzle will be sharding our data.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以无限地添加功能和优化我们的缓存，但对于我们的项目来说，“无限”似乎太多。我们拼图中的最后一部分将是分片我们的数据。
- en: Sharding
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分片
- en: 'Sharding is a fundamental technique that’s used to partition data across multiple
    nodes, ensuring scalability and performance. Sharding offers several key benefits
    that make it an attractive option for distributed caches:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 分片是一种基本技术，用于在多个节点之间划分数据，确保可扩展性和性能。分片提供了几个关键优势，使其成为分布式缓存的有吸引力的选择：
- en: '**Horizontal scaling**: Sharding allows you to scale horizontally by adding
    more nodes (shards) to your system. This enables the cache to handle larger datasets
    and higher request volumes without degrading performance.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平扩展**：通过向系统中添加更多节点（分片），分片允许你水平扩展。这使缓存能够处理更大的数据集和更高的请求量，而不会降低性能。'
- en: '**Load distribution**: By distributing data across multiple shards, sharding
    helps balance the load, preventing any single node from becoming a bottleneck.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载分布**：通过在多个分片之间分配数据，分片有助于平衡负载，防止任何单个节点成为瓶颈。'
- en: '**Parallel processing**: Multiple shards can process requests in parallel,
    leading to faster query and update operations.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行处理**：多个分片可以并行处理请求，从而加快查询和更新操作。'
- en: '**Isolation of failures**: If one shard fails, the others can continue to operate,
    ensuring that the system remains available even in the presence of failures.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**故障隔离**：如果一个分片失败，其他分片可以继续运行，确保系统即使在出现故障的情况下也能保持可用。'
- en: '**Simplified management**: Each shard can be managed independently, allowing
    for easier maintenance and upgrades without affecting the entire system.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化管理**：每个分片可以独立管理，便于维护和升级，而不会影响整个系统。'
- en: Approaches to implementing sharding
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现分片的方法
- en: There are several approaches to implementing sharding, each with its advantages
    and trade-offs. The most common approaches include range-based sharding, hash-based
    sharding, and consistent hashing.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 实现分片有几种方法，每种方法都有其优势和权衡。最常见的方法包括基于范围的分片、基于哈希的分片和一致性哈希。
- en: Range-based sharding
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于范围的分片
- en: In range-based sharding, data is divided into contiguous ranges based on the
    shard key (for example, numerical or alphabetical ranges). Each shard is responsible
    for a specific range of keys.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于范围的分片中，数据根据分片键（例如，数值或字母范围）划分为连续的范围。每个分片负责特定的键范围。
- en: 'Advantages:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: Simple to implement and understand
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单易实现和理解
- en: Efficient range queries
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效的范围查询
- en: 'Disadvantages:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: Uneven distribution of data if the key distribution is skewed
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果键分布不均匀，数据分布不均
- en: Hotspots can form if certain ranges are accessed more frequently
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果某些范围被频繁访问，可能会形成热点
- en: Hash-based sharding
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于哈希的分片
- en: In hash-based sharding, a hash function is applied to the shard key to determine
    the shard. This approach ensures a more uniform distribution of data across shards.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于哈希的分片中，将哈希函数应用于分片键以确定分片。这种方法确保了数据在分片之间的更均匀分布。
- en: 'Advantages:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: Even distribution of data
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据分布均匀
- en: Avoids hotspots caused by skewed key distributions
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免由键分布不均引起的热点
- en: 'Disadvantages:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: Range queries are inefficient as they may span multiple shards
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围查询效率低下，因为它们可能跨越多个分片
- en: Re-sharding (adding/removing nodes) can be complex
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新分片（添加/删除节点）可能很复杂
- en: Consistent hashing
  id: totrans-314
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一致性哈希
- en: Consistent hashing is a specialized form of hash-based sharding that minimizes
    the impact of re-sharding. Nodes and keys are hashed to a circular space, and
    each node is responsible for the keys in its range.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性哈希是一种特殊的基于哈希的分片形式，它最小化了重新分片的影响。节点和键被哈希到环形空间，每个节点负责其范围内的键。
- en: 'Advantages:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: Minimizes data movement during re-sharding
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化重新分片期间的数据移动
- en: Provides good load balancing and fault tolerance
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供良好的负载均衡和容错性
- en: 'Disadvantages:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: More complex to implement compared to simple hash-based sharding
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与简单的基于哈希的分片相比，实现起来更复杂
- en: Requires careful tuning and management
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要仔细调整和管理
- en: Let’s go with consistent hashing. This approach will help us achieve a balanced
    distribution of data and handle re-sharding efficiently.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们采用一致性哈希。这种方法将帮助我们实现数据的平衡分布并有效地处理重新分片。
- en: Implementing consistent hashing
  id: totrans-323
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现一致性哈希
- en: The first thing we need to do is create our hash ring. But wait! What is a hash
    ring? Keep calm and bear with me!
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要创建我们的哈希环。但是等等！什么是哈希环？保持冷静，耐心等待我解释！
- en: Imagine a circular ring on which each point represents a possible output of
    a hash function. This is our “hash ring.”
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个圆形环，每个点代表哈希函数的可能输出。这是我们“哈希环”。
- en: Each cache server (or node) in our system is assigned a random position on the
    ring that’s usually determined by hashing the server’s unique identifier (such
    as its address). These positions represent the node’s “ownership range” on the
    ring. Every piece of data (a cache entry) is hashed. The resulting hash value
    is also mapped to a point on the ring.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们系统中的每个缓存服务器（或节点）在环上被分配一个随机位置，通常是通过哈希服务器的唯一标识符（如其地址）来确定的。这些位置代表节点在环上的“所有权范围”。每条数据（一个缓存条目）都会被哈希。生成的哈希值也被映射到环上的一个点。
- en: A data key is assigned to the first node it encounters while moving clockwise
    on the ring from its position.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 数据键被分配给它从当前位置顺时针移动时遇到的第一个节点。
- en: Visualizing the hash ring
  id: totrans-328
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可视化哈希环
- en: 'In the following example, we can see the following:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们可以看到以下内容：
- en: Key 1 is assigned to Node A
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键1被分配给节点A
- en: Key 2 is assigned to Node B
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键2被分配给节点B
- en: Key 3 is assigned to Node C
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键3被分配给节点C
- en: 'Let’s take a closer look:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看：
- en: '[PRE26]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following file, `hashring.go`, is the foundation for managing the consistent
    hash ring:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文件`hashring.go`是管理一致性哈希环的基础：
- en: '[PRE27]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Upon exploring the file in the repository, we can see the following:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索存储库中的文件时，我们可以看到以下内容：
- en: '`nodes`: A slice to store node structs (the ID and address of each server).'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nodes`：一个切片，用于存储节点结构（每个服务器的ID和地址）。'
- en: '`hashes`: A slice of uint32 values to store the hashes of each node. This allows
    for efficient searching to find the responsible node.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hashes`：一个uint32值的切片，用于存储每个节点的哈希值。这允许进行高效的搜索以找到负责的节点。'
- en: '`lock`: A mutex to ensure safe, concurrent access to the ring.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lock`：一个互斥锁，以确保对环的安全、并发访问。'
- en: '`hash()`: This function uses SHA-1 to hash node IDs and data keys.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hash()`：此函数使用SHA-1对节点ID和数据键进行哈希。'
- en: '`AddNode`: This calculates a node’s hash, inserts it into the hashes slice,
    and sorts the slice to maintain order.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddNode`：此函数计算一个节点的哈希值，将其插入到`hashes`切片中，并排序以保持顺序。'
- en: '`GetNode`: Given a key, it performs a binary search on the sorted hashes to
    find the first hash that’s equal to or greater than the key’s hash. The corresponding
    node in the `nodes` slice is the owner.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetNode`：给定一个键，它对排序后的哈希值进行二分搜索，以找到第一个等于或大于键的哈希值。`nodes`切片中相应的节点是所有者。'
- en: 'We also need to update `server.go` so that it can interact with the hash ring:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新`server.go`文件，以便它能与哈希环交互：
- en: '[PRE28]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we need to modify `SetHandler` so that it handles replication and request
    forwarding:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要修改`SetHandler`以便它处理复制和请求转发：
- en: '[PRE29]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We also need to add the `replicateSet` method to replicate the `set` request
    to other peers:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加`replicateSet`方法以将`set`请求复制到其他对等节点：
- en: '[PRE30]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once we’ve done this, we can change `GetHandler` so that it forwards requests
    to the appropriate node:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这个步骤，我们可以修改 `GetHandler` 以便它将请求转发到适当的节点：
- en: '[PRE31]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Both methods are using `forwardRequest`. Let’s create it as well:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法都使用 `forwardRequest`。让我们也创建它：
- en: '[PRE32]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The last step is to update `main.go` so that it considers the nodes:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是更新 `main.go` 以考虑节点：
- en: '[PRE33]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Let’s test our consistent hashing!
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试我们的一致性哈希！
- en: 'Run the first instance:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 运行第一个实例：
- en: '[PRE34]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Run the second instance:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 运行第二个实例：
- en: '[PRE35]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The first set of tests will be the basic `SET` and `GET` commands. Let’s set
    a key-value pair on Node A (localhost:8080):'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组测试将是基本的 `SET` 和 `GET` 命令。让我们在节点 A（localhost:8080）上设置一个键值对：
- en: '[PRE36]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we can get the value from the correct node:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从正确的节点获取值：
- en: '[PRE37]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Depending on how `mykey` hashes, the value should be returned from either port
    `8080` or `8083`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 `mykey` 的哈希方式，值应从端口 `8080` 或 `8083` 返回。
- en: 'To test the hashing and key distribution, we can set multiple keys:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试哈希和键分布，我们可以设置多个键：
- en: '[PRE38]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, we can get the values and observe the distribution:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以获取值并观察分布：
- en: '[PRE39]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Some keys might be on one server, while others might be on the second server,
    depending on how their hashes map onto the ring.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 一些键可能在一个服务器上，而另一些键可能在第二个服务器上，这取决于它们的哈希如何映射到环上。
- en: 'The key takeaways from this implementation are as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个实现中可以得出的关键要点如下：
- en: The hash ring provides a way to consistently map keys to nodes, even as the
    system scales
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希环提供了一种方法，即使在系统扩展时也能一致地将键映射到节点。
- en: Consistent hashing minimizes disruptions caused by adding or removing nodes
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一致性哈希最小化了添加或删除节点引起的干扰。
- en: The implementation in the patch focuses on simplicity, using SHA-1 for hashing
    and a sorted slice for efficient node lookup
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 补丁中的实现侧重于简洁性，使用 SHA-1 进行哈希处理，并使用排序切片进行高效的节点查找
- en: Congratulations! You’ve embarked on an exhilarating journey through the world
    of distributed caching, constructing a system that’s not just functional but primed
    for new optimization. Now, it’s time to unleash the full potential of your creation
    by digging deeper into the realms of optimization, metrics, and profiling. Think
    of this as fine-tuning your high-performance engine, ensuring it purrs with efficiency
    and speed.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经开始了在分布式缓存世界中的激动人心的旅程，构建了一个不仅功能强大而且为新的优化做好了准备的系统。现在，是时候深入挖掘优化、指标和剖析的领域，以充分发挥你创作的潜力。把这看作是对你高性能引擎的微调，确保它以效率和速度平稳运行。
- en: 'Where you can go from here? Let’s sum this up:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从哪里开始？让我们总结一下：
- en: '**Optimization techniques**:'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化技术**：'
- en: '**Cache replacement algorithms**: Experiment with alternative cache replacement
    algorithms such as **Low Inter-Reference Recency Set** (**LIRS**) or **Adaptive
    Replacement Cache** (**ARC**). These algorithms can offer improved hit rates and
    better adaptability to varying workloads compared to traditional LRU.'
  id: totrans-379
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存替换算法**：尝试使用替代的缓存替换算法，如 **低互引用近期集合**（**LIRS**）或 **自适应替换缓存**（**ARC**）。与传统的
    LRU 相比，这些算法可以提供更高的命中率，并更好地适应变化的工作负载。'
- en: '**Tuning eviction policies**: Fine-tune your TTL values and LRU thresholds
    based on your specific data characteristics and access patterns. This prevents
    the premature eviction of valuable data and ensures that the cache remains responsive
    to changing demands.'
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调整淘汰策略**：根据你的具体数据特性和访问模式微调你的 TTL 值和 LRU 阈值。这可以防止有价值的数据过早淘汰，并确保缓存能够对变化的需求保持响应。'
- en: '**Compression**: Implement data compression techniques to reduce the memory
    footprint of cached items. This allows you to store more data in the cache and
    potentially improve hit rates, especially for compressible data types.'
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**压缩**：实现数据压缩技术以减少缓存项的内存占用。这允许你在缓存中存储更多数据，并可能提高命中率，特别是对于可压缩的数据类型。'
- en: '**Connection pooling**: Optimize network communication by implementing connection
    pooling between your cache clients and servers. This reduces the overhead for
    establishing new connections for each request, leading to faster response times.'
  id: totrans-382
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接池**：通过在缓存客户端和服务器之间实现连接池来优化网络通信。这减少了为每个请求建立新连接的开销，从而提高了响应时间。'
- en: '**Metrics** **and monitoring**:'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指标** **和监控**：'
- en: '**Key metrics**: Continuously monitor essential metrics such as cache hit rate,
    miss rate, eviction rate, latency, throughput, and memory usage. These metrics
    provide valuable insights into the cache’s performance and help identify potential
    bottlenecks or areas for improvement.'
  id: totrans-384
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关键指标**：持续监控关键指标，如缓存命中率、缺失率、淘汰率、延迟、吞吐量和内存使用情况。这些指标提供了关于缓存性能的宝贵见解，并有助于识别潜在的瓶颈或改进区域。'
- en: '**Visualization**: Utilize visualization tools such as Grafana to create dashboards
    that display these metrics in real time. This allows you to easily track trends,
    spot anomalies, and make data-driven decisions about cache optimization.'
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可视化**：利用Grafana等可视化工具创建仪表板，实时显示这些指标。这允许你轻松跟踪趋势，发现异常，并就缓存优化做出数据驱动的决策。'
- en: '**Alerting**: Set up alerts based on predefined thresholds for critical metrics.
    For example, you could receive an alert if the cache hit rate drops below a certain
    percentage or if latency exceeds a specified limit. This enables you to proactively
    address issues before they impact users.'
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**警报设置**：根据预定义的阈值设置关键指标的警报。例如，如果缓存命中率低于某个百分比或延迟超过指定限制，你将收到警报。这使你能够在问题影响用户之前主动解决问题。'
- en: '**Profiling**:'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能分析**：'
- en: '**CPU profiling**: Identify CPU-intensive functions or operations within your
    cache code. This helps you pinpoint areas where optimizations can yield the most
    significant performance gains.'
  id: totrans-388
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU性能分析**：识别缓存代码中的CPU密集型函数或操作。这有助于你确定优化可以带来最大性能提升的区域。'
- en: '**Memory profiling**: Analyze memory usage patterns to detect memory leaks
    or inefficient memory allocation. Optimizing memory usage can improve the cache’s
    overall performance and stability.'
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存性能分析**：分析内存使用模式以检测内存泄漏或低效的内存分配。优化内存使用可以提高缓存的整体性能和稳定性。'
- en: With dedication and a data-driven approach, you’ll unlock the full potential
    of your distributed cache and ensure it remains an asset in your future software
    architectures.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 通过专注和以数据驱动的策略，你将解锁分布式缓存的全部潜力，并确保它在未来的软件架构中保持资产地位。
- en: Oof! What a ride, huh? We explored a lot of design decisions and implementation
    during this chapter. Let’s wrap up what we have done.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！真是一次刺激的旅程，嗯？在这一章中，我们探索了许多设计决策和实现方法。让我们总结一下我们已经完成的工作。
- en: Summary
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built a distributed cache from scratch. We started with
    a simple in-memory cache and gradually added features such as thread safety, HTTP
    interface, eviction policies (LRU and TTL), replication, and consistent hashing
    for sharding. Each step was a building block that contributed to the robustness,
    scalability, and performance of our cache.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们从零开始构建了一个分布式缓存。我们从一个简单的内存缓存开始，逐步添加了线程安全、HTTP接口、淘汰策略（LRU和TTL）、复制和一致性哈希分片等功能。每一步都是一个构建块，为我们的缓存提供了稳健性、可扩展性和性能。
- en: While our cache is functional, it’s just the beginning. There are countless
    avenues for further exploration and optimization. The world of distributed caching
    is vast and ever-evolving, and this chapter has equipped you with the essential
    knowledge and practical skills to navigate it confidently. Remember, building
    a distributed cache is not just about the code; it’s about understanding the underlying
    principles, making informed design decisions, and continuously iterating to meet
    the evolving demands of your applications.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的缓存是功能性的，但这只是开始。有无数条探索和优化的途径。分布式缓存的世界广阔且不断演变，这一章已经为你提供了必要的知识和实际技能，让你能够自信地驾驭它。记住，构建分布式缓存不仅仅是代码；它还关乎理解底层原理，做出明智的设计决策，并持续迭代以满足应用程序不断变化的需求。
- en: Now that we’ve navigated the treacherous waters of design decisions and trade-offs,
    we’ve laid a solid foundation for our distributed cache. We’ve combined the right
    strategies, technologies, and a dash of cynicism to create a robust, scalable,
    and efficient system. But designing a system is only half the battle; the other
    half is writing code that doesn’t make future developers (including ourselves)
    weep tears of frustration.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经穿越了设计决策和权衡的险恶水域，为我们的分布式缓存奠定了坚实的基础。我们结合了正确的策略、技术和一丝怀疑，创建了一个稳健、可扩展和高效的系统。但设计一个系统只是战斗的一半；另一半是编写不会让未来的开发者（包括我们自己）流泪的代码。
- en: In the next chapter, *Effective Code Practices*, we’ll cover essential techniques
    to elevate your Go coding game. You’ll learn how to maximize performance by efficiently
    reusing system resources, eliminate redundant task execution for streamlined processes,
    master memory management to keep your system lean and fast, and sidestep common
    issues that can degrade performance. Prepare for a deep dive into Go’s best practices,
    where precision, clarity, and a touch of sarcasm are the keys to success.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章“有效的代码实践”中，我们将介绍提升您Go编程技能的必要技巧。您将学习如何通过高效地重用系统资源来最大化性能，消除冗余任务执行以实现流程的简化，掌握内存管理以保持系统精简且快速，以及避开可能降低性能的常见问题。准备好深入探索Go的最佳实践，其中精确性、清晰度和一丝讽刺是成功的关键。
