["```go\ntype BufferPool struct {\n    pool sync.Pool\n}\n```", "```go\nfunc NewBufferPool() *BufferPool {\n    return &BufferPool{\n        pool: sync.Pool{\n            New: func() interface{} {\n                return new(bytes.Buffer)\n            },\n        },\n    }\n}\n```", "```go\nfunc (bp *BufferPool) Get() *bytes.Buffer {\n    return bp.pool.Get().(*bytes.Buffer)\n}\n```", "```go\nfunc (bp *BufferPool) Put(buf *bytes.Buffer) {\n    buf.Reset()\n    bp.pool.Put(buf)\n}\n```", "```go\nfunc ProcessData(data []byte, bp *BufferPool) {\n    buf := bp.Get()\n    defer bp.Put(buf) // Ensure the buffer is returned to the pool.\n    buf.Write(data)\n    // Further processing can be done here.\n    fmt.Println(buf.String()) // Example output operation\n}\n```", "```go\nfunc main() {\n    bp := NewBufferPool()\n    data := []byte(\"Hello, World!\")\n    ProcessData(data, bp)\n}\n```", "```go\npackage main\nimport (\n     \"io\"\n     \"net\"\n     \"sync\"\n)\nvar bufferPool = sync.Pool{\n     New: func() interface{} {\n         return make([]byte, 1024) // creates a new buffer of 1 KB\n     },\n}\nfunc handleConnection(conn net.Conn) {\n     // Get a buffer from the pool\n     buf := bufferPool.Get().([]byte)\n     defer bufferPool.Put(buf) // ensure the buffer is put back after handling\n     for {\n         n, err := conn.Read(buf)\n         if err != nil {\n             if err != io.EOF {\n                 // Handle different types of errors\n                 println(\"Error reading:\", err.Error())\n             }\n             break\n         }\n         // Process the data, for example, echoing it back\n         conn.Write(buf[:n])\n     }\n     conn.Close()\n}\nfunc main() {\n     listener, err := net.Listen(\"tcp\", \":8080\")\n     if err != nil {\n         panic(err)\n     }\n     println(\"Server listening on port 8080\")\n     for {\n         conn, err := listener.Accept()\n         if err != nil {\n             println(\"Error accepting connection:\", err.Error())\n             continue\n         }\n         go handleConnection(conn)\n     }\n}\n```", "```go\npackage main\nimport (\n    \"bytes\"\n    \"encoding/json\"\n    \"sync\"\n)\nvar bufferPool = sync.Pool{\n    New: func() interface{} {\n        return new(bytes.Buffer) // Initialize a new buffer\n    },\n}\ntype Data struct {\n    Name string `json:\"name\"`\n    Age  int    `json:\"age\"`\n}\nfunc marshalData(data Data) ([]byte, error) {\n    // Get a buffer from the pool\n    buffer := bufferPool.Get().(*bytes.Buffer)\n    defer bufferPool.Put(buffer)\n    buffer.Reset() // Ensure buffer is empty before use\n    // Marshal data into the buffer\n    err := json.NewEncoder(buffer).Encode(data)\n    if err != nil {\n        return nil, err\n    }\n    // Copy the contents to a new slice to return\n    result := make([]byte, buffer.Len())\n    copy(result, buffer.Bytes())\n    return result, nil\n}\nfunc main() {\n    data := Data{Name: \"John Doe\", Age: 30}\n    jsonBytes, err := marshalData(data)\n    if err != nil {\n        println(\"Error marshaling JSON:\", err.Error())\n    } else {\n        println(\"JSON output:\", string(jsonBytes))\n    }\n}\n```", "```go\npackage main\nimport (\n     \"fmt\"\n     \"sync\"\n)\nvar once sync.Once\nfunc setup() {\n     fmt.Println(\"Initializing...\")\n}\nfunc main() {\n     // The setup function will only be called once\n     once.Do(setup)\n     once.Do(setup) // This won't execute setup again\n}\n```", "```go\n// Using sync.Once\nvar once sync.Once\nvar config *Config\nfunc getConfig() *Config {\n    once.Do(func() {\n        config = loadConfig()\n    })\n    return config\n}\n// Using OnceValue\nvar getConfig = sync.OnceValue(func() *Config {\n    return loadConfig()\n})\n```", "```go\npackage main\nimport (\n    «fmt\"\n    «sync»\n    «time»\n    «golang.org/x/sync/singleflight\"\n)\nfunc main() {\n    var g singleflight.Group\n    var wg sync.WaitGroup\n    // Function to simulate a costly operation\n    fetchData := func(key string) (interface{}, error) {\n         // Simulate some work\n         time.Sleep(2 * time.Second)\n         return fmt.Sprintf(\"Data for key %s\", key), nil\n    }\n    // Simulate concurrent requests\n    for i := 0; i < 5; i++ {\n         wg.Add(1)\n         go func(i int) {\n              defer wg.Done()\n              result, err, shared := g.Do(\"my_key\", func() (interface{}, error) {\n                   return fetchData(\"my_key\")\n              })\n              if err != nil {\n                   fmt.Printf(\"Error: %v\\n\", err)\n                   return\n              }\n              fmt.Printf(\"Goroutine %d got result: %v (shared: %v)\\n\", i, result, shared)\n         }(i)\n    }\n    wg.Wait()\n}\n```", "```go\npackage main\nimport (\n    «fmt\"\n    «sync»\n    «golang.org/x/sync/singleflight\"\n)\nfunc main() {\n    var g singleflight.Group\n    var wg sync.WaitGroup\n    results := map[string]string{\n         \"alpha\": \"Alpha result\",\n         \"beta\":  \"Beta result\",\n         \"gamma\": \"Gamma result\",\n    }\n    worker := func(key string) {\n         defer wg.Done()\n         result, err, _ := g.Do(key, func() (interface{}, error) {\n              // Here we just return a precomputed result\n              return results[key], nil\n         })\n         if err != nil {\n              fmt.Printf(\"Error fetching data for %s: %v\\n\", key, err)\n              return\n         }\n         fmt.Printf(\"Result for %s: %v\\n\", key, result)\n    }\n    keys := []string{«alpha», «beta», «gamma», «alpha», «beta», «gamma»}\n    for _, key := range keys {\n         wg.Add(1)\n         go worker(key)\n    }\n    wg.Wait()\n}\n```", "```go\npackage main\nimport (\n    \"fmt\"\n    \"golang.org/x/exp/mmap\"\n)\nfunc main() {\n    const filename = \"example.txt\"\n    // Open the file using mmap\n    reader, err := mmap.Open(filename)\n    if err != nil {\n        fmt.Println(\"Error opening file:\", err)\n        return\n    }\n    defer reader.Close()\n    fileSize := reader.Len()\n    data := make([]byte, fileSize)\n    _, err = reader.ReadAt(data, 0)\n    if err != nil {\n        fmt.Println(\"Error reading file:\", err)\n        return\n    }\n    // Access the last byte of the file\n    lastByte := data[fileSize-1]\n    fmt.Printf(\"Last byte of the file: %v\\n\", lastByte)\n}\n```", "```go\nAt any point in your program where you can access the slice mapping the memory, you can call it:// Modify data (example)\ndata[fileSize-1] = 'A'\n// Synchronize changes\nerr = syscall.Msync(data, syscall.MS_SYNC)\nif err != nil {\n     fmt.Println(\"Error syncing data:\", err)\n     return\n}\n```", "```go\npackage main\nimport (\n    \"net/http\"\n    \"time\"\n)\nfunc main() {\n    for i := 0; i < 1000; i++ {\n        go func() {\n            _, err := http.Get(\"http://example.com\")\n            if err != nil {\n                panic(err)\n            }\n        }()\n    }\n    time.Sleep(100 * time.Second)\n}\n```", "```go\nfunc processWithTimeout(duration time.Duration) {\n    timeout := time.After(duration)\n    // Simulate a process that might finish before the timeout\n    done := make(chan bool)\n    go func() {\n        // Simulated work (e.g., fetching data, processing, etc.)\n        time.Sleep(duration / 2) // finishes before the timeout\n        done <- true\n    }()\n    select {\n    case <-done:\n        fmt.Println(\"Finished processing\")\n    case <-timeout:\n        fmt.Println(\"Timed out\")\n    }\n}\n```", "```go\nfunc processWithManualTimer(duration time.Duration) {\n    timer := time.NewTimer(duration)\n    defer timer.Stop() // Ensure the timer is stopped to free up resources\n    done := make(chan bool)\n    go func() {\n        // Simulated work\n        time.Sleep(duration / 2) // finishes before the timeout\n        done <- true\n    }()\n    select {\n    case <-done:\n        fmt.Println(\"Finished processing\")\n    case <-timer.C:\n        fmt.Println(\"Timed out\")\n    }\n}\n```", "```go\nfunc openFiles(filenames []string) error {\n    for _, filename := range filenames {\n        f, err := os.Open(filename)\n        if err != nil {\n            return err\n        }\n        defer f.Close() // defer the close until the function exits\n    }\n    // Other processing\n    return nil\n}\n```", "```go\nfunc openFiles(filenames []string) error {\n    for _, filename := range filenames {\n        f, err := os.Open(filename)\n        if err != nil {\n            return err\n        }\n        // Do necessary file operations here\n        f.Close() // Close the file explicitly within the loop\n    }\n    return nil\n}\n```", "```go\nsessions := make(map[string]Session)\nfunc newUserSession(userID string) {\n    session := createSessionForUser(userID)\n    sessions[userID] = session\n}\nfunc deleteUserSession(userID string) {\n    delete(sessions, userID) // This does not shrink the map.\n}\n```", "```go\nif len(sessions) < len(deletedSessions) {\n    newSessions := make(map[string]Session, len(sessions))\n    for k, v := range sessions {\n        newSessions[k] = v\n    }\n    sessions = newSessions\n}\n```", "```go\nfunc readFile(path string) ([]byte, error) {\n    f, err := os.Open(path)\n    if err != nil {\n        return nil, err\n    }\n    // Missing defer f.Close()\n    return io.ReadAll(f)\n}\n```", "```go\nfunc readFile(path string) ([]byte, error) {\n    f, err := os.Open(path)\n    if err != nil {\n        return nil, err\n    }\n    defer f.Close() // Ensures that the file is closed\n    return ioutil.ReadAll(f)\n}\n```", "```go\nfunc connectToService() (*net.TCPConn, error) {\n    addr, _ := net.ResolveTCPAddr(\"tcp\", \"example.com:80\")\n    conn, err := net.DialTCP(\"tcp\", nil, addr)\n    if err != nil {\n        return nil, err\n    }\n    // Do something with the connection\n    // If an error occurs here, the connection might never be closed.\n    return conn, nil\n}\n```", "```go\nfunc connectToService() (*net.TCPConn, error) {\n    addr, _ := net.ResolveTCPAddr(\"tcp\", \"example.com:80\")\n    conn, err := net.DialTCP(\"tcp\", nil, addr)\n    if err != nil {\n        return nil, err\n    }\n    defer func() {\n        if err != nil {\n            conn.Close()\n        }\n    }()\n    // Do something with the connection\n    return conn, nil\n}\n```", "```go\nfunc fetchURL(url string) error {\n    resp, err := http.Get(url)\n    if err != nil {\n        return err\n    }\n    // Assume the body is not needed and forget to close it\n    return nil\n}\n```", "```go\nfunc fetchURL(url string) error {\n    resp, err := http.Get(url)\n    if err != nil {\n        return err\n    }\n    defer resp.Body.Close()  // Ensure the body is closed\n    // Now it's safe to use the body, for example, read it into a variable\n    body, err := io.ReadAll(resp.Body)\n    if err != nil {\n        return err\n    }\n    fmt.Println(string(body))  // Use the body for something\n    return nil\n}\n```", "```go\nfunc produce(ch chan int) {\n    for i := 0; ; i++ {\n        ch <- i  // This will block indefinitely if there's no receiver\n    }\n}\nfunc main() {\n    ch := make(chan int)\n    go produce(ch)\n    // No corresponding receive operation\n    // The goroutine produce will block after sending the first item\n}\n```", "```go\nfunc produce(ch chan int) {\n    for i := 0; ; i++ {\n        select {\n        case ch <- i:\n            // Successfully sent data\n        case <-time.After(5 * time.Second):\n            // Handle timeout e.g., exit goroutine or log warning\n            return\n        }\n    }\n}\nfunc main() {\n    ch := make(chan int)\n    go produce(ch)\n    // Implementation of a receiver or another form of channel management\n}\n```"]