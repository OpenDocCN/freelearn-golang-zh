- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Effective Coding Practices
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有效的编码实践
- en: Computer resources are plentiful these days, but they’re far from infinite.
    Knowing how to carefully manage and use them is vital to create resilient programs.
    This chapter is crafted to explore how to use resources appropriately and avoid
    memory leaks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些天计算机资源很丰富，但它们远非无穷无尽。知道如何仔细管理和使用它们对于创建健壮的程序至关重要。本章旨在探讨如何适当使用资源并避免内存泄漏。
- en: 'The chapter will cover the following key topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下关键主题：
- en: Reusing resources
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重用资源
- en: Executing tasks once
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行任务一次
- en: Efficient memory mapping
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效的内存映射
- en: Avoiding common performance pitfalls
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免常见的性能陷阱
- en: By the end of this chapter, you will have gained practical experience handling
    resources using the standard library, and you will know how to avoid making common
    mistakes with it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将获得使用标准库处理资源的实践经验，并且将知道如何避免在使用它时犯常见的错误。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code shown in this chapter can be found in the `ch14` directory of our
    GitHub repository.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的所有代码都可以在我们的GitHub仓库的`ch14`目录中找到。
- en: Reusing resources
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重用资源
- en: Reusing resources is crucial in software development because it significantly
    enhances the efficiency and performance of applications. By reusing resources,
    we can minimize the overhead associated with resource allocation and deallocation,
    reduce memory fragmentation, and decrease the latency of resource-intensive operations.
    This approach leads to more predictable and stable application behavior, particularly
    under high load. In Go, the `sync.Pool` package exemplifies this principle by
    providing a pool of reusable objects that can be dynamically allocated and freed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中重用资源至关重要，因为它显著提高了应用程序的效率和性能。通过重用资源，我们可以最小化与资源分配和释放相关的开销，减少内存碎片化，并降低资源密集型操作的开销。这种方法导致应用程序的行为更加可预测和稳定，尤其是在高负载下。在Go中，`sync.Pool`包通过提供可以动态分配和释放的可用对象池来体现这一原则。
- en: Alright, strap in kiddos – it’s time to take a wild ride through the exhilarating
    world of Go’s `sync.Pool`. You see all those folks bragging about it like it’s
    the cure for buggy code? Well, they’re not entirely wrong; it’s just not the magic
    bullet they think it is.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，孩子们，系好安全带——现在是时候体验Go的`sync.Pool`这个激动人心的世界了。你看那些吹嘘它的人，好像它是修复bug的万能药？好吧，他们并不完全错；它只是不是他们想象中的万能子弹。
- en: Imagine `sync.Pool` as your friendly neighborhood hoarder. You know, the one
    with a garage so full of stuff that you can barely squeeze in a bicycle. Except,
    in this case, instead of old newspapers and broken furniture, we’re talking about
    goroutines and memory allocations. Yep, `sync.Pool` is like the cluttered attic
    of your program, except it’s actually organized chaos designed to optimize your
    resource usage.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下`sync.Pool`就像你邻居里的那个收藏家。你知道的，那个车库堆满了东西，你几乎挤不进一辆自行车。但是，在这个例子中，我们谈论的是goroutines和内存分配。是的，`sync.Pool`就像你程序中杂乱无章的阁楼，但实际上它是一个旨在优化资源使用的有组织的混乱。
- en: You see, `sync.Pool` comes with its own set of rules and quirks. For starters,
    *objects in the pool aren’t guaranteed to stick around forever*. They can be evicted
    at any time, leaving you high and dry when you least expect it. And then there’s
    the issue of concurrency. `sync.Pool` might be thread-safe, but that doesn’t mean
    you can just toss it into your code willy-nilly and expect everything to work.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你看，`sync.Pool`有其自己的规则和怪癖。首先，池中的对象并不保证永远存在。它们可以在任何时候被移除，在你最不期望的时候让你陷入困境。然后还有并发的问题。`sync.Pool`可能是线程安全的，但这并不意味着你可以随意将其扔到你的代码中并期望一切都能正常工作。
- en: So, what the heck is this thing good for? Well, let’s get technical. `sync.Pool`
    is a way to store and reuse objects in a way that’s safe for multiple goroutines
    to mess with simultaneously. It’s useful when you’ve got pieces of data that are
    used a lot, but temporarily, and making a new one each time is slow. Think of
    it like a temporary workspace for your goroutines.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这东西到底有什么用呢？好吧，让我们来点技术性的。`sync.Pool`是一种存储和重用对象的方式，这种方式对于多个goroutine同时操作是安全的。当你有很多数据片段被频繁使用，但暂时不需要，每次都创建新的会很慢时，它很有用。把它想象成goroutines的临时工作空间。
- en: 'The following code effectively demonstrates the use of `sync.Pool` to manage
    and reuse instances of `bytes.Buffer`, which is an efficient way to handle buffers,
    especially under high load or in highly concurrent scenarios. Here’s a breakdown
    of the code and the relevance of using `sync.Pool`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码有效地展示了如何使用 `sync.Pool` 来管理和重用 `bytes.Buffer` 实例，这是一种处理缓冲区的有效方式，尤其是在高负载或高度并发的场景下。以下是代码的分解以及使用
    `sync.Pool` 的相关性：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`BufferPool` wraps `sync.Pool`, which is used to store and manage `*``bytes.Buffer`
    instances:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`BufferPool` 包装 `sync.Pool`，用于存储和管理 `*bytes.Buffer` 实例：'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This function initializes `BufferPool` with `sync.Pool`, which creates new
    `bytes.Buffer` instances when needed. The `New` function is called when `Get`
    is invoked on an empty pool:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用 `sync.Pool` 初始化 `BufferPool`，在需要时创建新的 `bytes.Buffer` 实例。当在空池上调用 `Get`
    时将调用 `New` 函数：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`Get()` retrieves `*bytes.Buffer` from the pool. If the pool is empty, it uses
    the `New` function defined in `NewBufferPool` to create a new `bytes.Buffer`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get()` 从池中检索 `*bytes.Buffer`。如果池为空，它将使用在 `NewBufferPool` 中定义的 `New` 函数创建一个新的
    `bytes.Buffer`：'
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`Put` returns `*bytes.Buffer` to the pool after resetting it, making it ready
    for reuse. Resetting the buffer is crucial to avoid data corruption between different
    uses:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`Put` 在重置缓冲区后将其返回到池中，使其准备好重用。重置缓冲区对于避免不同使用之间的数据损坏至关重要：'
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function processes data using a buffer from `BufferPool`. It acquires a
    buffer from the pool, writes data to it, and ensures the buffer is returned to
    the pool after use with `defer bp.Put(buf)`. An example operation, `fmt.Println(buf.String())`,
    is performed to demonstrate how the buffer might be used.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用 `BufferPool` 中的缓冲区处理数据。它从池中获取一个缓冲区，向其中写入数据，并确保在使用后通过 `defer bp.Put(buf)`
    将缓冲区返回到池中。一个示例操作 `fmt.Println(buf.String())` 被执行，以展示缓冲区可能的使用方式。
- en: 'We can now use the code in our `main` function:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在 `main` 函数中使用这段代码：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This creates a new `BufferPool`, defines some data, and processes it using `ProcessData`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个新的 `BufferPool`，定义了一些数据，并使用 `ProcessData` 处理这些数据。
- en: 'There are a few points to notice:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有几点需要注意：
- en: By reusing `bytes.Buffer` instances, `BufferPool` reduces the need for frequent
    allocations and garbage collections, leading to better performance.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过重用 `bytes.Buffer` 实例，`BufferPool` 减少了频繁分配和垃圾回收的需求，从而提高了性能。
- en: '`sync.Pool` is suitable for managing temporary objects that are only needed
    within the scope of a single goroutine. It helps reduce contention on shared resources
    by allowing each goroutine to maintain its own set of pooled objects, minimizing
    the need for synchronization between goroutines when accessing these objects.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync.Pool` 适用于管理仅在单个 goroutine 范围内需要的临时对象。它通过允许每个 goroutine 维护自己的池化对象集来减少对共享资源的竞争，从而最小化在访问这些对象时在
    goroutine 之间进行同步的需要。'
- en: '`sync.Pool` is safe for concurrent use by multiple goroutines, making `BufferPool`
    robust in concurrent environments.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync.Pool` 对多个 goroutine 的并发使用是安全的，这使得 `BufferPool` 在并发环境中更加健壮。'
- en: '`sync.Pool` is essentially a cache for objects. When you need a new object,
    you can request it from the pool. If the pool has an available object, it will
    return it; otherwise, it will create a new one. Once you are done with the object,
    you return it to the pool, making it available for reuse. This cycle helps manage
    memory more efficiently and reduces the computational cost of allocation.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`sync.Pool` 实质上是一个对象缓存。当你需要一个新的对象时，你可以从池中请求它。如果池中有可用的对象，它将返回它；否则，它将创建一个新的对象。一旦你用完对象，你将其返回到池中，使其可用于重用。这个循环有助于更有效地管理内存并减少分配的计算成本。'
- en: To ensure that we fully understand the capabilities of `sync.Pool`, let’s explore
    two more examples in different scenarios – network connections and JSON marshaling.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们完全理解 `sync.Pool` 的功能，让我们在不同的场景中探索两个额外的示例——网络连接和 JSON 序列化。
- en: Using sync.Pool in a network server
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在网络服务器中使用 sync.Pool
- en: 'In this scenario, we want to use `sync.Pool` to manage buffers for handling
    network connections, since it is a typical pattern in high-performance servers:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我们希望使用 `sync.Pool` 来管理处理网络连接的缓冲区，因为在高性能服务器中这是一个典型的模式：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, buffers are reused for each connection, significantly reducing
    the amount of garbage generated and improving the server’s performance by minimizing
    garbage collection overhead. This pattern is beneficial in scenarios with high
    concurrency and numerous short-lived connections.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，每个连接都会重用缓冲区，这显著减少了垃圾的产生，并通过最小化垃圾收集开销来提高服务器的性能。这种模式在高并发和大量短连接的场景中非常有用。
- en: Using sync.Pool for JSON marshaling
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 sync.Pool 进行 JSON 序列化
- en: 'In this scenario, we will explore how `sync.Pool` can be used to optimize buffer
    usage during JSON marshaling:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在此场景中，我们将探讨如何使用 `sync.Pool` 来优化 JSON 序列化过程中的缓冲区使用：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, we use `sync.Pool` to manage the buffers into which JSON data
    is marshaled. The buffer is retrieved from the pool each time `marshalData` is
    called, and once the data is copied to a new slice to be returned, the buffer
    is put back into the pool for reuse. This approach prevents the allocation of
    a new buffer on each marshaling call.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们使用 `sync.Pool` 来管理将 JSON 数据序列化到其中的缓冲区。每次调用 `marshalData` 时，都会从池中检索缓冲区，一旦数据被复制到一个新的切片以返回，缓冲区就会被放回池中以供重用。这种方法防止了在每次序列化调用时分配新的缓冲区。
- en: The buffer in the marshaling process
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 序列化过程中的缓冲区
- en: 'The buffer variable in this example is `bytes.Buffer`, which acts as a reusable
    buffer for the marshaled JSON data. Here’s the process step by step:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，缓冲区变量是 `bytes.Buffer`，它作为序列化 JSON 数据的可重用缓冲区。以下是步骤的详细说明：
- en: '`sync.Pool` with `bufferPool.Get()`.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `sync.Pool` 与 `bufferPool.Get()`。
- en: '`buffer.Reset()` before use to ensure its content is empty and ready for new
    data, ensuring data integrity.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用之前使用 `buffer.Reset()` 确保其内容为空并准备好接收新数据，以确保数据完整性。
- en: '`json.NewEncoder(buffer).Encode(data)` function marshals the data directly
    into the buffer.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`json.NewEncoder(buffer).Encode(data)` 函数直接将数据序列化到缓冲区中。'
- en: '**Copying data**: Creating a new byte slice result and copying the marshaled
    data from the buffer is essential. This step is necessary because the buffer will
    be returned to the pool and reused, so its content must not be directly returned,
    avoiding potential data corruption.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复制数据**：创建一个新的字节切片结果并将序列化数据从缓冲区复制过来是至关重要的。这一步骤是必要的，因为缓冲区将被返回到池中并重用，因此其内容不能直接返回，以避免潜在的数据损坏。'
- en: '`defer bufferPool.Put(buffer)`.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defer bufferPool.Put(buffer)`.'
- en: '**Return result**: The resulting slice containing the marshaled JSON data is
    returned from the function.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回结果**：包含序列化 JSON 数据的切片从函数中返回。'
- en: 'There are a few considerations when using `sync.Pool`. if you want to maximize
    the benefits of `sync.Pool`, make sure that you do the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `sync.Pool` 时有一些考虑因素。如果你想最大限度地发挥 `sync.Pool` 的优势，请确保你做以下几件事：
- en: Use it for objects that are expensive to create or set up
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于创建或设置成本高昂的对象
- en: Avoid using it for long-lived objects, as it is optimized for objects that have
    short lifespans
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免将其用于长期对象，因为它针对的是生命周期短的对象进行了优化
- en: Be mindful that the garbage collector may automatically remove objects in the
    pool when there is high memory pressure, so always check for `nil` after fetching
    an object from the pool
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意垃圾收集器可能在内存压力高时自动从池中移除对象，因此在从池中获取对象后，始终检查 `nil`。
- en: Pitfalls
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 风险点
- en: 'While `sync.Pool` can offer substantial performance benefits, it also introduces
    complexity and potential pitfalls:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `sync.Pool` 可以提供实质性的性能优势，但它也引入了复杂性和潜在的风险：
- en: '**Data integrity**: Extra care must be taken to ensure that data does not leak
    between uses of pooled items. This often means clearing buffers or other data
    structures before reuse.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据完整性**：必须格外小心，以确保在池化项的使用之间不会发生数据泄漏。这通常意味着在重用之前清除缓冲区或其他数据结构。'
- en: '`sync.Pool` can lead to increased memory usage, especially if the objects held
    in the pool are large or the pool grows too large.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync.Pool` 可能会导致内存使用增加，特别是如果池中持有的对象很大或池变得过大。'
- en: '`sync.Pool` minimizes the overhead of memory allocation, it introduces synchronization
    overhead that can become a bottleneck in highly concurrent scenarios.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync.Pool` 最小化了内存分配的开销，但它引入了同步开销，这可能在高度并发的场景中成为瓶颈。'
- en: Performance is not a guessing game
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 性能不是一场猜测游戏
- en: When considering the use of `sync.Pool` for marshaling operations, it’s essential
    to benchmark and profile your specific application to ensure that the benefits
    outweigh the costs.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑将 `sync.Pool` 用于序列化操作时，对特定应用程序进行基准测试和性能分析至关重要，以确保其带来的好处超过成本。
- en: In system programming, where performance and efficiency are crucial, `sync.Pool`
    can be particularly useful. For instance, in network servers or other I/O-heavy
    applications, managing many small, short-lived objects is common. Using `sync.Pool`
    in such scenarios can minimize latency and memory usage, leading to more responsive
    and scalable systems.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统编程中，性能和效率至关重要，`sync.Pool`可以特别有用。例如，在网络服务器或其他I/O密集型应用程序中，管理许多小型、短暂的对象是常见的。在这种情况下使用`sync.Pool`可以最小化延迟和内存使用，从而实现更响应和可扩展的系统。
- en: There are more useful capabilities in the `sync` package. For instance, we can
    leverage this package to ensure that code segments will be called exactly once,
    with `sync.Once`. Sounds promising, right? Let’s explore this concept in the next
    section.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`sync`包中还有更多有用的功能。例如，我们可以利用这个包来确保代码段恰好被调用一次，使用`sync.Once`。听起来很有希望，对吧？让我们在下一节中探讨这个概念。'
- en: Executing tasks once
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行任务一次
- en: '`sync.Once` – the deceptively simple tool in the `sync` package that promises
    a safe haven of “run this code only once” logic. Can this tool save the day *once*
    again (pun intended)?'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`sync.Once` – `sync` 包中一个看似简单的工具，它承诺提供一个“只运行一次此代码”的安全港逻辑。这个工具能否再次拯救这一天（有意为之）？'
- en: Imagine a group of hyperactive squirrels all scrambling toward the same acorn.
    That first lucky squirrel gets the prize; the rest are left staring at an empty
    spot, wondering what the heck just happened. That’s `sync.Once` for us. It’s great
    when you genuinely need that single-use, guaranteed execution – the initialization
    of a global variable, for example. But for anything more intricate, prepare for
    a headache.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一群非常活跃的松鼠都在争夺同一颗橡子。第一个幸运的松鼠得到了奖品；其余的都只能对着一个空地发呆，想知道到底发生了什么。这就是我们眼中的`sync.Once`。当你真正需要单次使用、保证执行的逻辑时，比如全局变量的初始化，它是非常好的。但对于更复杂的事情，准备好头疼吧。
- en: If you are a Gen-X/Millennial Java enterprise person, you might suspect that
    `sync.Once` is just a lazy initialization, singleton pattern implementation. And
    yes! It is precisely that! But if you’re a Gen-Z, let me explain in simpler, non-ancient
    words – `sync.Once` stores a boolean and a mutex (think of it like a locked door).
    The first time a goroutine calls `Do()`, that boolean flips from `false` to `true`,
    and the code inside `Do()` gets executed. All other goroutines knocking on the
    mutex door hang around waiting for their turn, which will never come.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个X世代/千禧年Java企业人士，你可能会怀疑`sync.Once`只是懒加载，单例模式实现。没错！正是如此！但如果你是Z世代，让我用更简单、不那么古老的话来解释
    – `sync.Once`存储一个布尔值和一个互斥锁（想象成一把锁着的门）。第一次goroutine调用`Do()`时，那个布尔值从`false`变为`true`，并且`Do()`内部的代码被执行。所有其他敲打互斥锁门的goroutine都会等待它们的轮次，而这个轮次永远不会到来。
- en: In Go terms, it takes a function, `f`, as its argument. The first time `Do`
    is called, it executes `f`. All subsequent calls to `Do` (even from different
    goroutines) will have no effect – they will simply wait until the initial execution
    of `f` completes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go的术语中，它接受一个函数`f`作为其参数。第一次调用`Do`时，它会执行`f`。所有随后的`Do`调用（即使是来自不同goroutines的）都不会产生任何效果
    – 它们将简单地等待`f`的初始执行完成。
- en: 'Too abstract? Here’s a tiny example to illustrate the concept:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 太抽象了吗？这里有一个小例子来说明这个概念：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This snippet has a simple `setup` function we want to execute only once. We
    use `sync.Once`’s `Do` method to ensure that the setup function is called exactly
    once, regardless of how many times `Do` is invoked. It’s like having a bouncer
    at your function’s door, ensuring that only the first caller gets in.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段有一个简单的`setup`函数，我们只想执行一次。我们使用`sync.Once`的`Do`方法来确保`setup`函数恰好被调用一次，不管`Do`被调用多少次。就像在你的函数门口有一个保安，确保只有第一个调用者能进来。
- en: I don’t know about you, but, to me, all these steps seem a bit verbose to do
    a simple thing. Coincidentally or not, the Go team feels the same, and since version
    1.21, we have had some shortcuts to do the same with three distinct functions
    – `OnceFunc`, `OnceValue`, and `OnceValues`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道你，但对我来说，所有这些步骤似乎有点冗长，只是为了做一件简单的事情。巧合与否，Go团队也有同样的感觉，从版本1.21开始，我们有一些捷径可以用三个不同的函数来做同样的事情
    – `OnceFunc`、`OnceValue`和`OnceValues`。
- en: 'Let’s break down their function signatures:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下它们的函数签名：
- en: '`OnceFunc(f func()) func()`: This function takes a function, `f`, and returns
    a new function. The returned function, when called, will invoke `f` only once
    and return its result. This is handy when you want the result of a function that
    should only be computed once.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnceFunc(f func()) func()`：这个函数接受一个函数 `f` 并返回一个新的函数。当调用返回的函数时，它将只调用一次 `f`
    并返回其结果。当你想要一个只应计算一次的函数的结果时，这很有用。'
- en: '`OnceValue[T any](f func() T) func() T`: This is similar to `OnceFunc`, but
    it’s specialized for functions that return a single value of type `T`. The returned
    function will return the value produced by the first (and only) call to `f`.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnceValue[T any](f func() T) func() T`：这与 `OnceFunc` 类似，但它专门用于返回类型为 `T` 的单个值的函数。返回的函数将返回
    `f` 的第一次（也是唯一一次）调用产生的值。'
- en: '`OnceValues[T1, T2 any](f func() (T1, T2)) func() (T1, T2)`: This extends the
    concept further for functions that return multiple values.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnceValues[T1, T2 any](f func() (T1, T2)) func() (T1, T2)`：这进一步扩展了概念，用于返回多个值的函数。'
- en: These new functions eliminate some boilerplate code that you’d otherwise need
    when using `Once.Do`. They offer a concise way to capture the “initialize once
    and return value” pattern often seen in Go programs. Also, they are designed to
    capture the results of the executed function. This eliminates the need for manual
    result storage.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新函数消除了在使用 `Once.Do` 时可能需要的某些样板代码。它们提供了一种简洁的方式来捕获在 Go 程序中经常看到的“初始化一次并返回值”模式。此外，它们还设计用来捕获执行函数的结果。这消除了手动存储结果的需求。
- en: 'To put things in perspective, let’s look at the following snippet that does
    the same task using both options:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地说明问题，让我们看看以下代码片段，它使用两种选项执行相同任务：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Ultimately, remember that `sync.Once` is like that overly specific kitchen tool
    you buy, thinking it’ll revolutionize your cooking, but it ends up gathering dust
    in a drawer. It has its place, but most of the time, simpler synchronization tools
    or a bit of careful refactoring will be a much less frustrating option.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记住，`sync.Once` 就像你买的那种过于具体的厨房工具，以为它会彻底改变你的烹饪，但最终它却在抽屉里积满灰尘。它有自己的位置，但大多数时候，更简单的同步工具或一点精心的重构将是一个更不令人沮丧的选择。
- en: We choose `sync.Once` as a synchronization tool, not a result-sharing mechanism.
    There are multiple scenarios when we want to share the result of a function with
    multiple callers but control the execution of the function itself. Even better,
    we want to be able to deduplicate concurrent function calls. In these scenarios,
    we can leverage our next tool for the job – `singleflight`!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择 `sync.Once` 作为同步工具，而不是结果共享机制。有多个场景下我们希望与多个调用者共享函数的结果，但控制函数本身的执行。更好的是，我们希望能够去重并发函数调用。在这些场景中，我们可以利用我们为这项工作准备的下一个工具——`singleflight`！
- en: singleflight
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: singleflight
- en: The `singleflight` Go package is designed to prevent duplicate executions of
    a function while it is in flight. It is instrumental in system programming, where
    managing redundant operations efficiently can significantly enhance performance
    and reduce unnecessary load.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`singleflight` Go 包旨在防止在执行过程中重复执行函数。它在系统编程中至关重要，有效地管理冗余操作可以显著提高性能并减少不必要的负载。'
- en: When multiple goroutines request the same resource simultaneously, `singleflight`
    ensures that only one request proceeds to fetch or compute the resource. All other
    requests wait for the result of the initial request, receiving the same response
    once it completes. This mechanism helps avoid repetitive work, such as multiple
    database queries for the same data or redundant API calls.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个 goroutine 同时请求相同的资源时，`singleflight` 确保只有一个请求继续获取或计算资源。所有其他请求将等待初始请求的结果，一旦完成，将接收相同的响应。这种机制有助于避免重复工作，例如对相同数据的多次数据库查询或冗余
    API 调用。
- en: This concept is essential for programmers looking to optimize their systems,
    especially in high-concurrency environments. It simplifies handling multiple requests
    by ensuring that expensive operations are not executed more than necessary. `singleflight`
    is straightforward to implement and can integrate seamlessly into existing Go
    applications, making it an attractive tool for system programmers aiming to boost
    efficiency and reliability.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念对于希望优化其系统的程序员至关重要，尤其是在高并发环境中。它通过确保昂贵的操作不会执行超过必要的次数来简化处理多个请求。`singleflight`
    的实现简单，可以无缝集成到现有的 Go 应用程序中，使其成为系统程序员提升效率和可靠性的有吸引力的工具。
- en: 'The following example demonstrates how it can be used to ensure that a function
    is only executed once even *if called multiple* *times concurrently*:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何使用它来确保即使多次并发调用，函数也只执行一次：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, the `fetchData` function is invoked by multiple goroutines,
    but `singleflight.Group` ensures that it is only executed once. The other goroutines
    wait and receive the same result.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`fetchData` 函数被多个 goroutines 调用，但 `singleflight.Group` 确保它只执行一次。其他 goroutines
    等待并接收相同的结果。
- en: Package x/sync
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 包 x/sync
- en: '`singleflight` is part of the `golang.org/x/sync` package. In other words,
    it is not part of the standard library, yet is maintained by the Go team. Ensure
    you “go get” it before using it.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`singleflight` 是 `golang.org/x/sync` 包的一部分。换句话说，它不是标准库的一部分，但由 Go 团队维护。在使用之前，请确保你已经“go
    get”了它。'
- en: 'Let’s explore another example, but this time, we will see how to use `singleflight.Group`
    for different keys, each potentially representing different data or resources:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索另一个示例，但这次，我们将看到如何使用 `singleflight.Group` 处理不同的键，每个键可能代表不同的数据或资源：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, different keys are handled, but the function call is *deduplicated
    per key*. For instance, multiple requests for `"alpha"` will result in only one
    execution, and all callers will receive the same `"``Alpha result"`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，处理了不同的键，但函数调用是按键**去重**的。例如，对 `"alpha"` 的多个请求将只导致一次执行，并且所有调用者都将接收到相同的
    `"Alpha result"`。
- en: 'The `singleflight` package is a powerful tool for managing concurrent function
    calls in Go. Here are some of the most common scenarios where it shines:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`singleflight` 包是管理 Go 中并发函数调用的强大工具。以下是一些它最常见且表现优异的场景：'
- en: '`singleflight` can ensure that only one request is made to the backend or database,
    while the others wait and receive the shared result. This prevents unnecessary
    loads and improves response times.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`singleflight` 可以确保只向后端或数据库发送一个请求，而其他请求则等待并接收共享的结果。这防止了不必要的负载并提高了响应时间。'
- en: '`singleflight` allows you to cache the results of the first execution. Subsequent
    calls with the same parameters will reuse the cached result, avoiding redundant
    work.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`singleflight` 允许你缓存第一次执行的结果。后续具有相同参数的调用将重用缓存的结果，避免重复工作。'
- en: '`singleflight` to limit the rate at which a function is executed. For example,
    if you have a function that interacts with a rate-limited API, `singleflight`
    can prevent multiple calls from happening simultaneously, ensuring compliance
    with the API’s restrictions.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `singleflight` 来限制函数执行的速率。例如，如果你有一个与速率限制 API 交互的函数，`singleflight` 可以防止同时发生多个调用，确保符合
    API 的限制。
- en: '`singleflight` can ensure that only one instance of the task is running at
    a time, preventing resource contention and potential inconsistencies.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`singleflight` 可以确保同一时间只有一个任务实例在运行，从而防止资源竞争和潜在的不一致性。'
- en: The most common benefit of introducing `singleflight` in these scenarios is
    preventing redundant work, especially in scenarios with high concurrency. It also
    avoids unnecessary computations or network requests.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些场景中引入 `singleflight` 的最常见好处是防止重复工作，尤其是在高并发场景中。它还避免了不必要的计算或网络请求。
- en: Beyond concurrency management, another critical aspect of system programming
    is memory management. Efficiently accessing and manipulating large datasets can
    significantly boost performance, and this is where memory mapping comes into play.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 除了并发管理之外，系统编程的另一个关键方面是内存管理。有效地访问和操作大型数据集可以显著提高性能，这正是内存映射发挥作用的地方。
- en: Effective memory mapping
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有效的内存映射
- en: '`mmap` (or `mmap` comes with a side of head-scratching complexity and a few
    potential landmines. Let’s dive in, shall we?'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`mmap`（或者 `mmap` 带来了一些令人挠头的复杂性和一些潜在的陷阱。让我们深入探讨，好吗？'
- en: Imagine `mmap` as breaking down the walls of your local library. Instead of
    laboriously checking out books (or reading from files the boring way), you gain
    direct access to the whole darn collection. You can flip through those dusty volumes
    at lightning speed, finding exactly what you need without waiting for the nice
    librarian (your operating system’s filesystem). Sounds amazing, right?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下 `mmap` 就像拆除了你本地图书馆的墙壁。你不必费力地借书（或以无聊的方式读取文件），你可以直接访问整个收藏。你可以以光速翻阅那些尘封的卷轴，找到你需要的东西，而无需等待那位好心的图书管理员（你的操作系统的文件系统）。听起来很棒，对吧？
- en: It is a system call that creates a mapping between a file on disk and a block
    of memory in your program’s address space. Suddenly, those file bytes become just
    another chunk of memory for you to play with. This is awesome for huge files,
    where traditional read/write operations would chug along like a rusty steam engine.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个系统调用，它在磁盘上的文件和程序地址空间中的内存块之间创建映射。突然，那些文件字节变成了你可以玩耍的另一个内存块。这对于大文件来说很棒，在传统读写操作中，它们会像生锈的蒸汽机一样缓慢。
- en: 'Here’s how you can achieve this in Go, using the cross-platform `golang.org/x/exp/mmap`
    package instead of direct syscalls:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何在 Go 中使用跨平台的 `golang.org/x/exp/mmap` 包而不是直接系统调用来实现这一点的：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, we use the `mmap` package to manage the memory-mapped file.
    The reader object is retrieved using `mmap.Open()`, and the file is read into
    a `data` byte slice.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `mmap` 包来管理内存映射文件。通过 `mmap.Open()` 获取读取器对象，并将文件读入 `data` 字节切片。
- en: API usage
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API 使用
- en: 'The `mmap` package provides a higher-level API for memory-mapping files, abstracting
    away the complexities of direct syscall usage. Here’s the process step by step:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`mmap` 包提供了对文件内存映射的高级 API，抽象出了直接系统调用使用的复杂性。以下是逐步过程：'
- en: '`mmap.Open(filename)`, which returns a `ReaderAt` interface to read the file.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mmap.Open(filename)`，它返回一个 `ReaderAt` 接口以读取文件。'
- en: '`reader.ReadAt(data, 0)`.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`reader.ReadAt(data, 0)`。'
- en: '**Access Data**: The last byte of the file is accessed and printed.'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**访问数据**：访问并打印文件的最后一个字节。'
- en: 'The main benefits of using the `mmap` package over direct syscalls are as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `mmap` 包而不是直接系统调用的主要好处如下：
- en: '`mmap` package abstracts away platform-specific details, allowing your code
    to run on multiple operating systems without modification'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mmap` 包抽象出平台特定的细节，允许您的代码在不修改的情况下在多个操作系统上运行'
- en: '`mmap` package provides a more Go-like interface, making the code easier to
    read and maintain'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mmap` 包提供了一个更 Go 风格的接口，使代码更容易阅读和维护'
- en: '**Error handling**: The package handles many of the error-prone details of
    memory mapping, reducing the likelihood of bugs and increasing the robustness
    of your code'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理**：该包处理了许多内存映射的错误细节，减少了错误的可能性，并增加了代码的健壮性'
- en: But wait a minute! Do we need to leverage the OS to synchronize the data back
    just when it wants? This seems off! There are moments when we want to ensure that
    the app writes the data. For those situations, the `msync` syscall exists.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！我们是否需要在操作系统想要同步数据时利用它？这似乎不太对！有时候我们想要确保应用程序写入数据。对于这些情况，存在 `msync` 系统调用。
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Advanced usage with protection and mapping flags
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用保护和映射标志的高级用法
- en: 'We can customize the behavior further by specifying protection and mapping
    flags. The `mmap` package doesn’t expose these directly, but understanding them
    is crucial for advanced usage:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过指定保护和映射标志进一步自定义行为。`mmap` 包不直接暴露这些标志，但理解它们对于高级用法至关重要：
- en: '`syscall.PROT_READ`: Pages may be read'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syscall.PROT_READ`：页面可以被读取'
- en: '`syscall.PROT_WRITE`: Pages may be written'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syscall.PROT_WRITE`：页面可以被写入'
- en: '`syscall.PROT_EXEC`: Pages may be executed'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syscall.PROT_EXEC`：页面可以被执行'
- en: 'A combination: `syscall.PROT_READ` | `syscall.PROT_WRITE`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合：`syscall.PROT_READ` | `syscall.PROT_WRITE`
- en: '`syscall.MAP_SHARED`: Changes are shared with other processes that map the
    same file*   `syscall.MAP_PRIVATE`: Changes are private to the process and not
    written back to the file*   A combination: `syscall.MAP_SHARED` | `syscall.MAP_POPULATE`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syscall.MAP_SHARED`: 更改与其他映射相同文件的进程共享*   `syscall.MAP_PRIVATE`: 更改仅对进程私有，不会写回文件*   组合：`syscall.MAP_SHARED`
    | `syscall.MAP_POPULATE`'
- en: 'The lesson here? `mmap` is like a high-performance sports car – exhilarating
    when handled correctly, but disastrous in the hands of the inexperienced. Use
    it wisely, for scenarios such as the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的教训是？`mmap` 就像一辆高性能跑车——当正确处理时令人兴奋，但如果不经经验的人操作，就会造成灾难。明智地使用它，用于以下场景：
- en: '**Working with gigantic files**: Quickly search, analyze, or modify massive
    datasets that would choke traditional I/O'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理巨型文件**：快速搜索、分析或修改大量数据集，这些数据集会令传统的 I/O 咽气'
- en: '**Shared memory communication**: Create blazing-fast communication channels
    between processes'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享内存通信**：在进程之间创建闪电般的通信通道'
- en: Remember, with `mmap`, you’re taking the safeties off. You need to handle synchronization,
    error checking, and potential memory corruption yourself. But when you do master
    it, the performance gains can be so satisfying that the complexity feels almost
    worthwhile.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，使用 `mmap` 时，你是在解除安全措施。你需要自己处理同步、错误检查和潜在的内存损坏。但当你掌握它时，性能提升可以非常令人满意，以至于复杂性几乎值得。
- en: MS_ASYNC
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: MS_ASYNC
- en: We can still make `Msync` async by passing the flag `MS_ASYNC`. The main difference
    is that we enqueue our request for modification, and the OS can eventually handle
    it. At this point, we can use `Munmap` or even crash. The OS will eventually handle
    writing the data unless it also crashes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以通过传递标志 `MS_ASYNC` 来使 `Msync` 异步。主要区别在于我们将修改请求排队，操作系统最终会处理它。在这个时候，我们可以使用
    `Munmap` 或甚至崩溃。操作系统最终会处理写入数据，除非它也崩溃。
- en: Avoiding common performance pitfalls
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免常见的性能陷阱
- en: There are performance pitfalls in Golang – you’d think that with all its built-in
    concurrency magic, we could just sprinkle some goroutines here and there and watch
    our programs fly. Unfortunately, the reality isn’t that generous, and treating
    Go like a performance panacea is like expecting a spoonful of sugar to fix a flat
    tire. It’s sweet, but oh boy – it’s not going to help when your code base starts
    to resemble a rush-hour traffic jam.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Golang 中存在性能陷阱——你可能会认为凭借其内置的并发魔法，我们只需在这里那里撒一些 goroutines，就能看到程序飞快地运行。不幸的是，现实并非如此慷慨，将
    Go 视为性能灵丹妙药就像期待一勺糖能修复漏气的轮胎一样。它很甜蜜，但哦，当你的代码库开始像高峰时段的交通堵塞一样时，它可帮不上忙。
- en: 'Let’s dive into an example that illustrates a common misstep – excessive creation
    of goroutines for tasks that aren’t CPU-bound:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来展示一个常见的错误——为非 CPU 密集型任务过度创建 goroutines：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, spawning a thousand goroutines to make HTTP requests is like
    sending a thousand people to fetch a single cup of coffee – inefficient and chaotic.
    Instead, using a worker pool or controlling the number of concurrent goroutines
    can significantly improve both performance and resource utilization.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，为发起 HTTP 请求而启动一千个 goroutines 就像派出一千人去取一杯咖啡——低效且混乱。相反，使用工作池或控制并发 goroutines
    的数量可以显著提高性能和资源利用率。
- en: Even using thousands of goroutines is inefficient; the real problem is when
    we leak memory, which can literally kill our programs.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 即使使用成千上万的 goroutines 也是低效的；真正的问题是当我们泄漏内存时，这可能会直接导致我们的程序崩溃。
- en: Leaking with time.After
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `time.After` 的泄漏
- en: The `time.After` function in Go is a convenient way to create a timeout, returning
    a channel that delivers the current time after a specified duration. However,
    its simplicity can be deceptive because it can lead to memory leaks if not used
    carefully.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的 `time.After` 函数是一种创建超时的便捷方式，它返回一个在指定持续时间后传递当前时间的通道。然而，它的简单性可能会让人产生误解，因为它如果不小心使用可能会导致内存泄漏。
- en: 'Here’s why `time.After` can lead to memory issues:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `time.After` 为什么会导致内存问题的原因：
- en: '`time.After` generates a new channel and starts a timer. This channel receives
    a value when the timer expires.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time.After` 生成一个新的通道并启动一个计时器。这个通道在计时器到期时接收一个值。'
- en: '**Garbage collection**: The channel and the timer are not eligible for garbage
    collection until the timer fires, regardless of whether you still need the timer
    or not. This means that if the duration specified is long, or if the channel is
    not read from (because the operation using the timeout finishes earlier), the
    timer and its channel continue to occupy memory.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垃圾回收**：通道和计时器只有在计时器触发时才符合垃圾回收的条件，无论你是否还需要计时器。这意味着如果指定的持续时间很长，或者通道没有被读取（因为使用超时的操作提前完成），计时器和它的通道将继续占用内存。'
- en: '`time.After` before it fires. Unlike creating a timer with `time.NewTimer`,
    which provides a `Stop` method to halt the timer and release resources, `time.After`
    does not expose such a mechanism. Therefore, if the timer is no longer needed,
    it still consumes resources until it completes.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time.After` 在触发之前。与使用 `time.NewTimer` 创建计时器不同，后者提供了一个 `Stop` 方法来停止计时器并释放资源，`time.After`
    并没有暴露这样的机制。因此，如果计时器不再需要，它仍然会消耗资源直到完成。'
- en: 'Here’s an example to illustrate the problem:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例来说明这个问题：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, even though the processing might finish before the timeout
    occurs, the timer associated with `time.After` will still occupy memory until
    it sends a message to its channel, which is never read because the select block
    has already been completed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，即使处理可能在大约超时之前完成，与`time.After`关联的计时器仍然会占用内存，直到它向其通道发送消息，而这个通道永远不会被读取，因为选择块已经完成。
- en: 'For scenarios where memory efficiency is crucial and the timeouts are either
    long or not always necessary (i.e., the operation might finish before the timeout),
    it is better to use `time.NewTimer`. This way, you can stop the timer manually
    when it is no longer needed:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内存效率至关重要且超时时间较长或不是始终必要的场景（即操作可能在超时之前完成），最好使用`time.NewTimer`。这样，你可以在不再需要时手动停止计时器：
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: By using `time.NewTimer` and stopping it with `timer.Stop()`, you ensure that
    resources are immediately freed once they are no longer needed, thus preventing
    a memory leak.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`time.NewTimer`并在不需要时停止它，你可以确保资源一旦不再需要就立即释放，从而防止内存泄漏。
- en: Defer in for loops
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在for循环中使用Defer
- en: In Go, `defer` is used to schedule a function call to be run after the function
    completes. It’s typically used to handle clean-up actions, such as closing file
    handles or database connections. However, when `defer` is used inside a loop,
    the deferred calls do not execute immediately at the end of each iteration as
    might intuitively be expected. Instead, they accumulate and execute only when
    the entire function containing the loop exits.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，`defer`用于安排在函数完成后运行函数调用。它通常用于处理清理操作，例如关闭文件句柄或数据库连接。然而，当`defer`在循环内部使用时，延迟调用不会在每个迭代结束时立即执行，正如直观上可能预期的那样。相反，它们会累积并在包含循环的整个函数退出时才执行。
- en: This behavior means that if you defer a cleanup operation inside a loop, every
    deferred call stacks up in memory until the loop exits. This can lead to high
    memory usage, especially if the loop iterates many times, which might not only
    affect performance but also lead to program crashes, due to out-of-memory errors.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为意味着，如果你在循环内部延迟一个清理操作，每次延迟调用都会在内存中堆叠，直到循环退出。这可能导致内存使用量很高，特别是如果循环迭代次数很多，这不仅可能影响性能，还可能导致程序崩溃，因为内存不足错误。
- en: 'Here’s a simplified example to illustrate this issue:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简化的例子来说明这个问题：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, if `filenames` contain hundreds or thousands of names, each
    file gets opened one by one per loop iteration, and `defer f.Close()` schedules
    the file to be closed only when the `openFiles` function exits. If the number
    of files is large, this can accumulate a substantial amount of memory reserved
    for all these open files.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果`filenames`包含数百或数千个名称，每个文件在每个循环迭代中逐个打开，而`defer f.Close()`安排文件仅在`openFiles`函数退出时关闭。如果文件数量很大，这可能会积累大量为所有这些打开文件预留的内存。
- en: 'To avoid this pitfall, manage the resource within the loop itself without using
    `defer` if the resource does not need to persist beyond the scope of the loop
    iteration:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个陷阱，如果资源不需要在循环迭代范围之外持续存在，请在循环内部管理资源而不使用`defer`：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this revised approach, each file is closed right after its related operations
    are completed within the same loop iteration. This prevents unnecessary memory
    buildup and ensures that resources are freed up as soon as they are no longer
    needed, which is much more memory efficient.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个改进的方法中，每个文件在其相关操作在同一循环迭代内完成之后立即关闭。这防止了不必要的内存积累，并确保资源在不再需要时立即释放，从而大大提高了内存效率。
- en: Maps management
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Map管理
- en: Maps in Go are highly flexible and dynamically grow as more key-value pairs
    are added. However, one crucial aspect of maps that developers sometimes overlook
    is that maps do not automatically shrink or release memory when items are removed.
    If the keys are continuously added without management, the map will continue to
    increase in size, potentially consuming a large amount of memory – even if many
    of those keys are no longer needed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的Map非常灵活，并且随着更多键值对的添加而动态增长。然而，开发者有时会忽视Map的一个关键方面，即Map在删除项目时不会自动缩小或释放内存。如果键是连续添加而没有管理，Map将继续增长，可能消耗大量内存——即使许多这些键不再需要。
- en: The Go runtime optimizes map operations for speed rather than memory usage.
    When items are deleted from a map, the runtime does not immediately reclaim the
    memory associated with those entries. Instead, the memory remains part of the
    map’s underlying structure to allow for faster re-insertion of new items. The
    idea is that if space was needed once, it might be needed again, which can improve
    performance in scenarios with frequent additions and deletions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Go运行时优化映射操作以速度为主，而不是内存使用。当从映射中删除项目时，运行时不立即回收与这些条目相关的内存。相反，该内存仍然是映射底层结构的一部分，以便允许更快地重新插入新项目。这种想法是，如果空间曾经需要，可能再次需要，这可以在频繁添加和删除的场景中提高性能。
- en: 'Consider a scenario where a map is used to cache results of operations or store
    session information in a web server:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个场景，其中使用映射来缓存操作结果或在Web服务器中存储会话信息：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding example, even after a session is deleted using `delete(sessions,
    userID)`, the map does not release the memory where the session data was stored.
    Over time, with enough user turnover, the map can grow to consume a significant
    amount of memory, leading to a memory leak if the map continues to expand without
    bounds.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，即使使用 `delete(sessions, userID)` 删除了会话，该映射也没有释放存储会话数据的内存。随着时间的推移，随着用户更替的增加，映射可以增长到消耗大量内存，如果映射继续无限制地扩展，可能会导致内存泄露。
- en: 'If you know that the map should shrink after many deletions, consider creating
    a new map and copying over only the active items. This can release memory held
    by many deleted entries:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道在多次删除后映射应该缩小，考虑创建一个新的映射并仅复制活动条目。这可以释放许多已删除条目所持有的内存：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For specific use cases, such as when keys have a short lifespan or the map size
    fluctuates significantly, consider using specialized data structures or third-party
    libraries designed for more efficient memory management. Also, it’s beneficial
    to schedule regular clean-up operations where you assess the utility of data within
    the map and remove unnecessary entries. This is particularly important in caching
    scenarios where stale data can linger indefinitely.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特定的用例，例如当键有短暂的生存期或映射大小显著波动时，考虑使用专门的数据结构或第三方库，这些库旨在更有效地管理内存。此外，安排定期的清理操作也是有益的，在这些操作中，你评估映射中数据的效用并删除不必要的条目。这在缓存场景中尤为重要，因为陈旧的数据可能会无限期地保留。
- en: Resource management
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源管理
- en: While the garbage collector effectively manages memory, it does not handle other
    types of resources, such as open files, network connections, or database connections.
    These resources must be explicitly closed to free up the system resources they
    consume. If not properly managed, these resources can remain open indefinitely,
    leading to resource leaks that can eventually exhaust the system’s available resources,
    potentially causing an application to slow down or crash.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然垃圾回收器有效地管理内存，但它不处理其他类型的资源，例如打开的文件、网络连接或数据库连接。这些资源必须被显式关闭以释放它们所消耗的系统资源。如果不正确管理，这些资源可能会无限期地保持打开状态，导致资源泄露，最终耗尽系统的可用资源，可能使应用程序变慢或崩溃。
- en: 'A common scenario where resource leaks occur is when handling files or network
    connections:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 资源泄露的常见场景之一是在处理文件或网络连接时：
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding function, the file is opened but never closed. This is a resource
    leak. The correct approach should include a `defer` statement to ensure that the
    file is closed after all operations on it are complete:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，文件被打开但从未关闭。这是一个资源泄露。正确的方法应包括一个 `defer` 语句，以确保在完成对该文件的所有操作后关闭文件：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It’s crucial to handle resources correctly, not just when operations succeed
    but also when they fail. Consider the case of initializing a network connection:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 正确处理资源至关重要，不仅当操作成功时，而且在操作失败时也是如此。考虑初始化网络连接的情况：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this example, if an error occurs after the connection is established but
    before it is returned (or during any subsequent operations before the connection
    is explicitly closed), the connection might remain open. This can be mitigated
    by ensuring that connections are closed in the face of errors, possibly using
    a pattern like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，如果在建立连接之后但在返回之前（或在连接显式关闭之前的任何后续操作）发生错误，连接可能会保持打开状态。这可以通过确保在出现错误时关闭连接来缓解，可能使用如下模式：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Handling HTTP bodies
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理HTTP正文
- en: Every `http.Response` from an HTTP client operation contains a `Body` field,
    which is `io.ReadCloser`. This `Body` field holds the response body. According
    to Go’s HTTP client documentation, the user is responsible for closing the response
    body when finished with it. Failing to close the response body can keep underlying
    sockets open longer than necessary, leading to resource leaks that can exhaust
    system resources, degrade performance, and eventually cause application instability.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 来自HTTP客户端操作的每个`http.Response`都包含一个`Body`字段，该字段是`io.ReadCloser`。这个`Body`字段包含响应体。根据Go的HTTP客户端文档，用户负责在完成使用后关闭响应体。未关闭响应体可能导致底层套接字比必要的长时间保持打开，导致资源泄漏，降低性能，并最终导致应用程序不稳定。
- en: 'When an `http.Response` body is not closed, the following scenarios can occur:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当`http.Response`的体未关闭时，可能会出现以下情况：
- en: '**Network and socket resources**: The underlying network connections can remain
    open. These are limited system resources. When they are used up, new network requests
    cannot be made, which can block or break parts of an application or even other
    applications running on the same system.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络和套接字资源**：底层网络连接可以保持打开。这些是有限的系统资源。当它们被耗尽时，无法发起新的网络请求，这可能导致应用程序的部分或甚至同一系统上运行的其他应用程序阻塞或中断。'
- en: '**Memory usage**: Each open connection consumes memory. If many connections
    are left open (especially in high-throughput applications), this can lead to substantial
    memory use and potential exhaustion.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存使用**：每个打开的连接都会消耗内存。如果许多连接保持打开状态（尤其是在高吞吐量应用程序中），这可能导致大量内存使用和潜在耗尽。'
- en: 'A typical scenario where developers might forget to close the response body
    is when handling HTTP requests:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可能会忘记关闭响应体的典型场景是在处理HTTP请求时：
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, the response body is never closed. Even though the function
    does not explicitly need the body, it is still fetched and must be closed to free
    up resources.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，响应体从未被关闭。即使函数不需要体，它仍然被获取，并且必须关闭以释放资源。
- en: 'The correct way to handle this is to ensure the response body is closed as
    soon as you are done with it, using `defer` immediately after checking the error
    from the HTTP request:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的做法是确保在完成响应体后立即关闭它，在检查HTTP请求的错误后立即使用`defer`：
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this corrected example, `defer resp.Body.Close()` is used immediately after
    confirming the request did not fail. This ensures that the body is always closed,
    regardless of how the rest of the function executes (whether it returns early
    due to an error or completes fully).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个修正的例子中，在确认请求没有失败后立即使用`defer resp.Body.Close()`。这确保了无论函数的其余部分如何执行（是否因错误而提前返回或完全完成），体总是会被关闭。
- en: Channel mismanagement
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通道管理不当
- en: When using unbuffered channels, the `send` operation blocks until another goroutine
    is ready to receive the data. If the receiving goroutine has terminated or fails
    to continue execution to the point of the receive operation (due to a logic error
    or condition), the sending goroutine will be blocked indefinitely. This results
    in both the goroutine and the channel consuming resources indefinitely.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用无缓冲通道时，`send`操作会阻塞，直到另一个goroutine准备好接收数据。如果接收goroutine已终止或未能继续执行到接收操作（由于逻辑错误或条件），发送goroutine将无限期地被阻塞。这导致goroutine和通道无限期地消耗资源。
- en: Buffered channels allow you to send multiple values without a receiver being
    ready to read immediately. However, if values remain in a channel buffer and there
    are no remaining references to this channel (e.g., all goroutines that could read
    from the channel have finished execution without draining the channel), the data
    remains in memory, leading to a memory leak.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲通道允许你在接收者尚未准备好立即读取的情况下发送多个值。然而，如果值留在通道缓冲区中，并且没有剩余的对此通道的引用（例如，所有可能从通道读取的goroutine都已完成执行而没有清空通道），数据将保留在内存中，导致内存泄漏。
- en: Sometimes, channels are used to control the execution flow of goroutines, such
    as signaling to stop execution. If these channels are not closed or if goroutines
    don’t have a way to exit based on channel input, it might lead to goroutines running
    indefinitely.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，通道被用来控制goroutine的执行流程，例如发出停止执行的信号。如果这些通道没有被关闭，或者goroutine没有基于通道输入退出的方式，可能会导致goroutine无限期地运行。
- en: 'Consider a scenario where a goroutine sends data to a channel that is never
    read:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个goroutine向一个永远不会被读取的通道发送数据的场景：
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding example, the `produce` goroutine will block indefinitely after
    sending the first integer to the channel because there is no receiver. This causes
    the goroutine and the value in the channel to remain in memory indefinitely.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，由于没有接收者，`produce` 协程在向通道发送第一个整数后将会无限期地阻塞。这会导致协程和通道中的值无限期地保留在内存中。
- en: 'To manage channels effectively and prevent such leaks, do the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地管理通道并防止此类泄露，请执行以下操作：
- en: '`select` statements with a default case to avoid blocking.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用默认情况的`select`语句以避免阻塞。
- en: '**Close channels when no longer needed**: This can signal to receiving goroutines
    that no more data will be sent on a channel. However, be careful to ensure that
    no goroutine attempts to send on a closed channel, as this will cause a panic.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当不再需要时关闭通道**：这可以向接收协程发出信号，表明将不再向通道发送更多数据。然而，务必确保没有协程尝试向已关闭的通道发送数据，因为这会导致恐慌。'
- en: '`select` statement can be used with `case` for channel operations and a default
    `case` to handle the scenario where no channels are ready.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`select`语句可以与`case`一起用于通道操作，以及一个默认的`case`来处理没有通道准备好的场景。'
- en: 'Here’s a refined example using a timeout:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个使用超时的改进示例：
- en: '[PRE28]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In general, to prevent resource leaks, do the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，为了防止资源泄露，请执行以下操作：
- en: Always defer the closing of resources immediately after their successful creation
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在资源成功创建后立即推迟其关闭。
- en: Check for errors that could occur after resource acquisition but before they
    are returned or further used
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查在资源获取后但返回或进一步使用之前可能发生的错误。
- en: Consider using patterns such as `defer` inside conditional blocks or immediately
    after checking for a successful resource acquisition
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑在条件块内部或立即在检查资源成功获取后使用`defer`模式。
- en: Use tools such as static analyzers, which can help catch cases where resources
    are not closed
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用静态分析器等工具，这些工具可以帮助捕捉资源未关闭的情况。
- en: In conclusion, learning about everyday problems and pitfalls is more than avoiding
    these features; it is about mastering the language. Think of it as tuning a guitar;
    each string must be adjusted to the right tone. Too tight, and it snaps; too loose,
    and it won’t play. Mastering Go’s and its memory management requires a similar
    touch, ensuring that each component is in harmony to produce the most efficient
    performance. Keep it simple, measure often, and adjust as necessary – your programs
    (and your sanity) will thank you.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，了解日常问题和陷阱不仅仅是避免这些特性；它是关于掌握语言。把它想象成调音吉他；每根弦都必须调整到正确的音调。太紧了，它会断裂；太松了，它就不会演奏。掌握
    Go 语言及其内存管理需要类似的技巧，确保每个组件都能和谐地工作，以产生最有效的性能。保持简单，经常测量，并在必要时进行调整——你的程序（以及你的理智）会感谢你。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Effective coding practices in Go involve efficient resource management, proper
    synchronization, and avoiding common performance pitfalls. Techniques such as
    reusing resources with `sync.Pool`, ensuring one-time task execution with `sync.Once`,
    preventing redundant operations with `singleflight`, and using memory mapping
    efficiently can significantly enhance application performance. Always be mindful
    of potential issues such as memory leaks, resource mismanagement, and improper
    use of concurrency constructs to maintain optimal performance and resource utilization.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的有效编码实践涉及有效的资源管理、适当的同步以及避免常见的性能陷阱。例如，使用`sync.Pool`重用资源、使用`sync.Once`确保一次性任务执行、使用`singleflight`防止冗余操作以及有效地使用内存映射等技术可以显著提高应用程序的性能。始终关注潜在的内存泄露、资源管理不当和不正确使用并发结构等问题，以保持最佳性能和资源利用率。
