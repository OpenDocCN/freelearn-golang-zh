<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer029">
			<h1 id="_idParaDest-251" class="chapter-number"><a id="_idTextAnchor288"/>15</h1>
			<h1 id="_idParaDest-252"><a id="_idTextAnchor289"/>Stay Sharp with System Programming</h1>
			<p>This chapter will wrap up our learning journey by exploring the history of the most famous projects and companies adopting Go. You will also be presented with the most iconic materials to learn about system programming and how to stay up to date with <span class="No-Break">this community.</span></p>
			<p>The chapter will cover the following <span class="No-Break">key topics:</span></p>
			<ul>
				<li><span class="No-Break">Real-world applications</span></li>
				<li>Navigating the system <span class="No-Break">programming landscape</span></li>
				<li>Resources for <span class="No-Break">continued learning</span></li>
			</ul>
			<p>By the end of this chapter, you will have learned how to continue enhancing your system programming knowledge and <span class="No-Break">its ecosystem.</span></p>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor290"/>Real-world applications</h1>
			<p>The best way to<a id="_idIndexMarker917"/> truly grasp the power of Go in system programming is to see it in the wild. Let’s explore real-world use cases where Go has been successfully employed to build robust and <span class="No-Break">efficient systems.</span></p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor291"/>Dropbox’s leap of faith</h2>
			<p>“Python is perfect for everything, right?” Ah, the sweet sound of naive optimism. You know – the kind<a id="_idIndexMarker918"/> you hear just before a<a id="_idIndexMarker919"/> catastrophic performance bottleneck in your monolithic Python code base. But hey, at least it was quick to write; am <span class="No-Break">I right?</span></p>
			<p>You know, migrating from Python to Go is a bit like swapping out a skateboard for a Formula One race car. Sure – both get you from point A to B, but one does it with a heck of a lot more speed and precision. And let’s face it, who doesn’t love the thrill of a roaring engine, especially when it means your cloud storage service can handle millions of <span class="No-Break">concurrent users?</span></p>
			<p>Dropbox, the <a id="_idIndexMarker920"/>beloved cloud storage giant, found itself in a <a id="_idIndexMarker921"/>similar predicament. Their Python backend, while convenient in the early days, was starting to creak under the weight of its own success. That’s when they made the bold decision to rewrite a significant chunk of their backend in Go. It’s fast, it’s efficient, and it’s got a concurrency model that makes scalability feel like child’s play. Well, maybe not child’s play, but certainly less like herding cats than Python’s <span class="No-Break">threading model.</span></p>
			<p>One of the key challenges Dropbox faced was handling a massive number of concurrent requests. With Python, this often involved spawning a new thread for each request, which quickly became a resource hog. Go, on the other hand, uses goroutines, which are far lighter and cheaper to create. This allowed Dropbox to scale its backend effortlessly, handling millions of concurrent users without breaking <span class="No-Break">a sweat.</span></p>
			<p>No one can tell the story better than the Dropbox team itself. You can see it in more detail at the <em class="italic">Go at Dropbox</em> <span class="No-Break">talk (</span><a href="https://www.youtube.com/watch?v=JOx9enktnUM"><span class="No-Break">https://www.youtube.com/watch?v=JOx9enktnUM</span></a><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor292"/>HashiCorp – Go from day one</h2>
			<p>Infrastructure as code? More<a id="_idIndexMarker922"/> like infrastructure as a tangled ball of yarn. That’s the kind of exasperated sigh you’ll hear from DevOps engineers wrestling with complex configuration management tools. But fear not, for HashiCorp, the <a id="_idIndexMarker923"/>wizards of infrastructure automation, have a solution that’s as smooth as a well-oiled <span class="No-Break">Kubernetes cluster.</span></p>
			<p>Imagine trying to build a house using nothing but duct tape and toothpicks. It might work, but it’ll be flimsy, unstable, and prone to collapse. That’s what traditional infrastructure management can feel like. HashiCorp, however, offers a different approach, one that’s rooted in code, automation, and the power <span class="No-Break">of Go.</span></p>
			<p>HashiCorp, the creator of tools such as Terraform, Vault, and Consul, made a strategic decision early on to embrace Go as their primary language. This wasn’t just a whim; it was a calculated move that aligned with their vision of a more efficient, reliable, and scalable approach to <span class="No-Break">infrastructure management.</span></p>
			<p>In an interview<a id="_idIndexMarker924"/> with Nic Jackson, a developer at HashiCorp, he discusses why they decided to use Go as the primary programming language for <span class="No-Break">their products.</span></p>
			<p>Here are some of<a id="_idIndexMarker925"/> the reasons why HashiCorp decided to <span class="No-Break">use Go:</span></p>
			<ul>
				<li>It is simple and easy to learn, which makes it easier for developers to get started with and <span class="No-Break">be productive.</span></li>
				<li>It is good for building small, succinct applications. HashiCorp builds a lot of microservices, which are small, self-contained services that <span class="No-Break">work together.</span></li>
				<li>It has a rich standard library, which means that a lot of the functionality that HashiCorp needs is already built into the language. This makes it easier to write programs <span class="No-Break">in Go.</span></li>
				<li>It is good for building highly distributed systems. HashiCorp’s products are designed to be used in distributed environments, and Go’s concurrency model makes it easy to write code that can run on <span class="No-Break">multiple machines.</span></li>
			</ul>
			<p>You can see the interview integrally at the following <span class="No-Break">link: </span><a href="https://youtu.be/qlwp0mHFLHU"><span class="No-Break">https://youtu.be/qlwp0mHFLHU</span></a></p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor293"/>Grafana Labs – visualizing success with Go</h2>
			<p>In the <a id="_idIndexMarker926"/>ecosystem of monitoring and observability, Grafana Labs <a id="_idIndexMarker927"/>has emerged as a dominant force, empowering organizations to gain insights into their complex systems. While Grafana, their flagship visualization platform, is primarily a frontend application, the company’s backend infrastructure and numerous supporting tools are built on the foundation of Go. This strategic choice has played a crucial role in their ability to deliver high-performance, scalable, and reliable solutions for monitoring <span class="No-Break">and observability.</span></p>
			<p>Modern systems generate a deluge of data, from metrics and logs to traces. Grafana Labs recognized the need for a backend infrastructure that could ingest, process, and store this data efficiently. Go’s inherent performance advantages, stemming from its compiled nature and efficient concurrency model, made it an ideal choice for handling the demanding workloads of monitoring <span class="No-Break">and observability.</span></p>
			<p>Grafana Labs <a id="_idIndexMarker928"/>leverages Go’s goroutines and channels to <a id="_idIndexMarker929"/>create highly concurrent and efficient backend services. Goroutines, lightweight threads of execution, allow them to handle a massive number of concurrent operations, such as data ingestion and query processing, without the overhead of traditional threads. Channels facilitate seamless communication and synchronization between goroutines, ensuring data integrity and efficient <span class="No-Break">resource utilization.</span></p>
			<p>Beyond Grafana, Grafana Labs has developed a suite of tools and components that rely on Go’s capabilities. Loki, their log aggregation system, utilizes Go’s efficient I/O handling and compression algorithms to ingest and store vast amounts of log data. Tempo, their distributed tracing backend, leverages Go’s networking capabilities for seamless communication between tracing agents and the central <span class="No-Break">Tempo server.</span></p>
			<p>They define the <a id="_idIndexMarker930"/>main advantages of <span class="No-Break">using Go:</span></p>
			<ul>
				<li><strong class="bold">Speed</strong>: Go is quick, though not as fast as a meticulously written C program. However, it allows for quicker development compared to C. It significantly outpaces languages such as Perl or Ruby in terms of <span class="No-Break">execution speed.</span></li>
				<li><strong class="bold">Simplified deployment</strong>: The static binaries that Go creates are straightforward <span class="No-Break">to deploy.</span></li>
				<li><strong class="bold">Balanced freedom</strong>: Go offers considerable flexibility without the temptations of unnecessary complex pointer arithmetic, promoting simpler, effective <span class="No-Break">coding practices.</span></li>
				<li><strong class="bold">Cross-platform compatibility</strong>: Go supports building applications across various platforms, including Linux, Solaris, macOS, Windows, and BSDs on different architectures such as amd64, i686, or arm. Even lesser-known systems such as plan9 might be supported, depending on the libraries used. For extremely uncommon platforms, gccgo might offer a <span class="No-Break">viable solution.</span></li>
				<li><strong class="bold">Accessibility in programming</strong>: Go simplifies backend and systems programming with its powerful yet <span class="No-Break">elegant syntax.</span></li>
				<li><strong class="bold">Profiling tools</strong>: The<a id="_idIndexMarker931"/> profiling capabilities in Go, such as CPU and heap profiling, are robust and valuable. The addition of trace profiling in Go 1.5 has been <span class="No-Break">particularly beneficial.</span></li>
				<li><strong class="bold">Built-in concurrency</strong>: Concurrency is an integral part of Go, making it easy to manage and effective <span class="No-Break">to use.</span></li>
				<li><strong class="bold">Powerful interfaces</strong>: Although Go’s interfaces may require some learning, they become indispensable <span class="No-Break">once mastered.</span></li>
			</ul>
			<p>There’s a full breakdown of the use of Go in Grafana Labs in the <em class="italic">Where and Why We Use Go</em> blog <span class="No-Break">post (</span><a href="https://grafana.com/blog/2015/08/21/where-and-why-we-use-go/"><span class="No-Break">https://grafana.com/blog/2015/08/21/where-and-why-we-use-go/</span></a><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor294"/>Docker – building a container revolution with Go</h2>
			<p>Docker, the<a id="_idIndexMarker932"/> platform that revolutionized software development and deployment with its container technology, owes much of its success to a rather <a id="_idIndexMarker933"/>unconventional choice: Go. While other established languages such as Java or C++ might have seemed more obvious for building such a complex system, Docker’s founders recognized the unique advantages Go offered for their <span class="No-Break">ambitious project.</span></p>
			<p>At its core, Docker is about lightweight isolation and portability. Go’s minimalist syntax and compiled nature aligned perfectly with this philosophy. Go’s fast compilation times and ability to produce statically linked binaries streamlined the development process and ensured consistent behavior across different environments, making it easier to package and distribute <span class="No-Break">Docker containers.</span></p>
			<p>Docker’s design heavily relies on concurrency to manage multiple containers simultaneously. Go’s goroutines and channels provide a lightweight and efficient concurrency model, allowing Docker to handle many concurrent operations with minimal overhead. This proved crucial for building a scalable and responsive platform that could efficiently manage <span class="No-Break">containerized applications.</span></p>
			<p>One of Docker’s key strengths is its ability to run on various platforms, from Linux to Windows to macOS. Go’s cross-platform compatibility simplified the development process, as developers could write code once and compile it for different architectures without significant modifications. This enabled Docker to quickly expand its reach and become the de facto standard <span class="No-Break">for containerization.</span></p>
			<p>Although Go <a id="_idIndexMarker934"/>was relatively new when Docker was created, its increasing community and rapidly growing ecosystem provided the necessary libraries and tools for building a complex system. The Docker team actively contributed to the Go community, developing open source libraries such as <strong class="source-inline">libcontainer</strong> for low-level container management, further solidifying Go’s position in the <span class="No-Break">container ecosystem.</span></p>
			<p>In retrospect, Docker’s<a id="_idIndexMarker935"/> decision to embrace Go appears almost prescient. Go’s unique strengths aligned seamlessly with the requirements of containerization, enabling the Docker team to build a robust, efficient, and portable platform that transformed the way software is developed and deployed. While other languages might have sufficed, Go’s combination of simplicity, performance, concurrency, and cross-platform compatibility proved to be the perfect recipe for building a <span class="No-Break">container revolution.</span></p>
			<p>The list of successful applications written in Go goes on. To put things in perspective, Golang steals the<a id="_idIndexMarker936"/> scene in the <strong class="bold">Cloud Native Computing Foundation</strong> (<strong class="bold">CNCF</strong>). Most cloud-native apps are written <span class="No-Break">in Go.</span></p>
			<p>You can browse all these projects <span class="No-Break">at </span><a href="https://www.cncf.io/"><span class="No-Break">https://www.cncf.io/</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor295"/>SoundCloud – from Ruby to Go</h2>
			<p>SoundCloud <a id="_idIndexMarker937"/>initially built their platform using Ruby <a id="_idIndexMarker938"/>on Rails, which they affectionately called “Mothership.” This monolithic application handled their public API, used by both their client applications and thousands of third-party applications, as well as the user-facing web application. As the platform grew, so did the complexity and scale of the challenges they faced. With millions of users and a massive volume of music uploads every minute, the limitations of the monolithic architecture became <span class="No-Break">increasingly apparent.</span></p>
			<p>To address scalability issues, SoundCloud decided to transition to a microservices architecture. This approach allowed them to separate domain logic into smaller, independent services, each with its own well-defined API. The microservices architecture provided greater flexibility and improved scalability, but it also introduced new challenges, such as managing inter-service communication and ensuring consistent <span class="No-Break">data handling.</span></p>
			<p>SoundCloud’s <a id="_idIndexMarker939"/>engineering team evaluated several<a id="_idIndexMarker940"/> programming languages to support their new microservices architecture. Go was chosen for several <span class="No-Break">key reasons:</span></p>
			<ul>
				<li><strong class="bold">Performance and concurrency</strong>: Go’s efficient concurrency model, powered by goroutines, allowed SoundCloud to handle numerous simultaneous connections, which was crucial for their <span class="No-Break">high-traffic platform.</span></li>
				<li><strong class="bold">Simplicity and readability</strong>: Go’s design philosophy of simplicity and minimalism made it easier for engineers to understand and maintain the code. The language’s <strong class="bold">what you see is what you get</strong> (<strong class="bold">WYSIWYG</strong>) nature helped new engineers become productive quickly, reducing the time from onboarding to making <span class="No-Break">meaningful contributions.</span></li>
				<li><strong class="bold">Fast compilation and deployment</strong>: Go’s fast compilation times and static typing facilitated quick iterations during development. This enabled SoundCloud to rapidly develop, test, and deploy new features, improving their overall <span class="No-Break">development velocity.</span></li>
				<li><strong class="bold">Community and ecosystem</strong>: The growing ecosystem of Go libraries and tools, as well as an active community, provided SoundCloud with the resources and support needed to build <span class="No-Break">robust applications.</span></li>
			</ul>
			<p>SoundCloud gradually migrated their services to Go, starting with non-critical components to minimize risk. They developed several internal tools and libraries to support the new architecture, including Bazooka, their deployment platform. This phased approach allowed them to incrementally refactor the monolith without disrupting <span class="No-Break">existing services.</span></p>
			<p>The transition to Go resulted in significant improvements in system performance and reliability. By leveraging Go’s concurrency features, SoundCloud could handle higher loads with fewer resources, reducing server costs. The simplicity of Go’s syntax and structure also made code reviews more focused on the problem domain rather than language intricacies, enhancing collaboration and productivity <span class="No-Break">among developers.</span></p>
			<p>SoundCloud’s <a id="_idIndexMarker941"/>migration to Go was driven by the need for better performance, scalability, and maintainability as their platform grew. By adopting Go and a microservices <a id="_idIndexMarker942"/>architecture, they successfully overcame the limitations of their monolithic Ruby on Rails application, setting a strong foundation for future growth <span class="No-Break">and innovation.</span></p>
			<h1 id="_idParaDest-259"><a id="_idTextAnchor296"/>Navigating the system programming landscape</h1>
			<p>The world of <a id="_idIndexMarker943"/>system programming is constantly evolving. To remain a skilled practitioner, it’s essential to stay informed about the <span class="No-Break">latest developments.</span></p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor297"/>Go release notes and blog</h2>
			<p>Religiously <a id="_idIndexMarker944"/>follow Go’s release notes. Each new version often brings enhancements specifically for system programming, such as improved memory management or <span class="No-Break">runtime optimizations.</span></p>
			<p>The official Go blog is an excellent resource for staying up to date with the latest news, announcements, and updates related to the Go programming language. You can find it <span class="No-Break">at </span><a href="https://blog.golang.org/"><span class="No-Break">https://blog.golang.org/</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor298"/>Community</h2>
			<p>It may <a id="_idIndexMarker945"/>sound dated, but joining mailing lists such as <strong class="source-inline">golang-nuts</strong> and <strong class="source-inline">golang-dev</strong> can keep you in the loop about discussions, announcements, and developments in the <span class="No-Break">Go community.</span></p>
			<p>Controversy aside, following influential Go developers, Go-related accounts, and hashtags such as <strong class="source-inline">#golang</strong> on X can provide real-time updates, discussions, and links to interesting articles <span class="No-Break">and resources.</span></p>
			<p>Also, participate in online forums (such as Go’s subreddit), Slack channels, and conferences (such as <em class="italic">GopherCon</em>). Engage with other Go developers, learn from their experiences, and share <span class="No-Break">your knowledge.</span></p>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor299"/>Contribution</h2>
			<p>I highly <a id="_idIndexMarker946"/>recommend you follow repositories related to the Go programming language on GitHub, especially the official Go repository and popular Go libraries and frameworks, which can give you insights into ongoing developments, issues, and pull requests. As you feel confident, contributing to open source Go projects is an excellent way to learn and give back to <span class="No-Break">the community.</span></p>
			<p><em class="italic">Tip</em>: Start with smaller contributions or bug fixes, and gradually take on more <span class="No-Break">challenging tasks.</span></p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor300"/>Experimentation</h2>
			<p>Don’t hesitate <a id="_idIndexMarker947"/>to experiment with new Go features and libraries as they become available. Hands-on experience is invaluable for understanding their potential in <span class="No-Break">your projects.</span></p>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor301"/>Resources for continued learning</h1>
			<p>Your journey in <a id="_idIndexMarker948"/>system programming with Go doesn’t end here. The following resources will help you expand your knowledge <span class="No-Break">and skills.</span></p>
			<p>System programming focuses more on deepening your understanding of the fundamental layers of a computer system than on chasing the latest technologies or frameworks. It may seem counterintuitive, but the goal is to master the core principles rather than just keep up with the newest trends. By gaining a solid grasp of how operating systems, hardware, and system libraries interact, you develop the ability to write more efficient and <span class="No-Break">reliable code.</span></p>
			<p>This field requires a thorough knowledge of low-level programming languages, such as C and sometimes Assembly, as these languages offer the fine-grained control needed to manipulate hardware directly. System programmers often work on developing or modifying operating systems, drivers, embedded systems, and performance-critical applications. They need to understand memory management, process scheduling, and filesystem implementations, among other <span class="No-Break">core components.</span></p>
			<p>Moreover, system programming emphasizes a deep understanding of computer architecture, including CPU operations, caching mechanisms, and I/O processes. This knowledge enables you to optimize software to run efficiently on the hardware it targets, which is vital for applications where performance and resource utilization <span class="No-Break">are critical.</span></p>
			<p>Another <a id="_idIndexMarker949"/>aspect of system programming is its stability and longevity. Unlike high-level frameworks and libraries, which may become obsolete as new technologies emerge, the fundamental concepts of system programming remain constant. Mastering these principles provides a robust foundation that can be applied across various technologies and platforms, ensuring long-term relevance in the ever-evolving field of <span class="No-Break">computer science.</span></p>
			<p>I have some book recommendations for you, but they might be considered classics compared with <span class="No-Break">recent publications.</span></p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor302"/>Advanced Programming in the UNIX Environment by W. Richard Stevens</h2>
			<p>Often referred to as <em class="italic">APUE</em>, this book is a detailed study of Unix system programming, covering all aspects of the Unix operating system and the fundamentals of system programming. It serves as an essential reference for understanding how Unix systems work, delving into topics such as file I/O, process control, signal handling, and <strong class="bold">inter-process communication</strong> (<strong class="bold">IPC</strong>). The <a id="_idIndexMarker950"/>book is known for its clear explanations and practical examples, making complex concepts accessible to both novice and experienced programmers. It also emphasizes best practices and robust programming techniques, equipping readers with the skills necessary to develop reliable and efficient Unix applications. With its comprehensive coverage and authoritative insights, APUE is a cornerstone in the library of any serious <span class="No-Break">Unix programmer.</span></p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor303"/>Learn C Programming - Second Edition: A beginner’s guide to learning the most powerful and general-purpose programming language with ease</h2>
			<p>In system<a id="_idIndexMarker951"/> programming, you will invariably touch some C code. In this case, I would recommend a smooth ride instead of a mountain bike competition. This book is like training wheels for your programming bike. It holds your hand, wipes your tears, and gently guides you into the cold, unforgiving world <span class="No-Break">of C.</span></p>
			<p>The author distills the chaos of C into something you might understand. It’s almost like magic, but less exciting. Each chapter gives you examples to chew on, making sure you don’t just stare blankly at your screen, wondering what went wrong. The book doesn’t just throw you into the deep end. Instead, it walks you down the stairs into the shallow end, one careful step at <span class="No-Break">a time.</span></p>
			<p>This isn’t your grandpa’s C programming book. It’s got all the modern stuff to keep you from looking like a relic. Just when you think you’ve got it, the book throws in exercises to remind you that you don’t. Keeps <span class="No-Break">you humble.</span></p>
			<p>If you’re a newbie or just need to refresh your C skills, this book has got you covered. The authors keep it simple, but not so simple you feel talked down to. It’s like they know you’re smart but clueless. A <span class="No-Break">rare talent.</span></p>
			<p>It is your go-to guide for entering the wild world of C. It’s straightforward, practical, and slightly condescending in a way that makes you think: Maybe I can actually <span class="No-Break">do this.</span></p>
			<h2 id="_idParaDest-267"><a id="_idTextAnchor304"/>Linux Kernel Programming - Second Edition: A comprehensive and practical guide to kernel internals, writing modules, and kernel synchronization</h2>
			<p>So, you’ve decided to tackle the Linux kernel. Bold move. Picking up <em class="italic">Linux Kernel Programming - Second Edition</em> is like strapping on your hiking boots for a trek through the Himalayas. It’s tough terrain, but with the right guide, you’ll reach <span class="No-Break">the summit.</span></p>
			<p>The author of this book has a knack for making the labyrinth of kernel internals seem almost navigable. They break down the complexities into bite-sized pieces, making the overwhelming world of kernel development feel a bit less like rocket science. And they don’t just give you dry theory. Oh no – they hand you practical examples that are like breadcrumbs, leading you through a dense forest <span class="No-Break">of code.</span></p>
			<p>This book doesn’t just toss you into the deep end to fend for yourself. It takes you through the process step by step, from understanding kernel internals to writing modules and handling synchronization. It’s a methodical journey, one that ensures you don’t get lost along the way. And it’s not stuck in the past. The content is updated, modern, and relevant, so you’re learning the latest and greatest in <span class="No-Break">kernel programming.</span></p>
			<p>Just when you start feeling confident, the book hits you with exercises and challenges that remind you there’s still a lot to learn. These aren’t just busywork—they’re designed to make you think critically and deepen <span class="No-Break">your understanding.</span></p>
			<p>Whether you’re<a id="_idIndexMarker952"/> a newbie or looking to sharpen your kernel skills, this book is your reliable guide. The authors strike a perfect balance, simplifying the complex without dumbing it down. They know you’re smart but might need a bit of handholding in this <span class="No-Break">daunting field.</span></p>
			<p>In conclusion, it’s comprehensive, practical, and challenging in all the right ways. If you’re serious about mastering kernel programming, this book is your roadmap <span class="No-Break">to success.</span></p>
			<h2 id="_idParaDest-268"><a id="_idTextAnchor305"/>Linux System Programming Techniques: Become a proficient Linux system programmer using expert recipes and techniques</h2>
			<p>Think of this book as your mentor, ready to impart the wisdom of the Linux sages with a side of <span class="No-Break">tough love.</span></p>
			<p>This book is packed with hands-on recipes. These are different from your run-of-the-mill, follow-the-instructions kind of recipes. They’re more like secret family recipes passed down from generations of Linux gurus, designed to give you fundamental skills and deep understanding. Each example is carefully crafted to show you how to do something and why it works <span class="No-Break">that way.</span></p>
			<p>You’ll appreciate the practical approach. The authors don’t just tell you what to do—they show you how to think like a system programmer. The challenges and exercises are where the magic happens. They push you to apply your knowledge, think critically, and solve real problems. It’s like having a stern but supportive coach who knows you’ve got what <span class="No-Break">it takes.</span></p>
			<p>This book is a testament to insightful, practical, and challenging learning in the most rewarding way. It offers expert recipes and techniques that will propel your skills to new heights, inspiring you to strive for <span class="No-Break">continuous improvement.</span></p>
			<h2 id="_idParaDest-269"><a id="_idTextAnchor306"/>Operating Systems: Design and Implementation by Andrew S. Tanenbaum</h2>
			<p>This book, often used in <a id="_idIndexMarker953"/>academic settings, provides a solid foundation in the theory and practical aspects of operating systems. Tanenbaum’s approach includes running examples with a real operating system, MINIX, which he developed specifically for educational purposes. The book covers a broad range of topics essential to understanding operating systems, such as process management, memory management, filesystems, I/O systems, <span class="No-Break">and security.</span></p>
			<p>One of the standout features of this book is its hands-on methodology. By incorporating MINIX, Tanenbaum allows readers to explore and modify a real, working operating system. This practical experience is invaluable for gaining a deep understanding of how theoretical concepts are applied in real-world systems. The text also includes comprehensive explanations of operating system principles, complemented by detailed diagrams and code examples that illustrate the inner workings of <span class="No-Break">OS components.</span></p>
			<p><em class="italic">Operating Systems: Design and Implementation</em> is structured to facilitate both learning and teaching, making it a favorite among students and educators alike. Tanenbaum’s clear and engaging writing style, coupled with his extensive experience in the field, ensures that complex ideas are presented in an accessible manner. For anyone looking to gain a thorough understanding of operating systems from both a theoretical and practical perspective, this book is an <span class="No-Break">essential resource.</span></p>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor307"/>Unix Network Programming by W. Richard Stevens</h2>
			<p>This is another classic by Stevens that delves into the specifics of network programming in Unix environments. It’s essential for anyone working with network applications in Unix. The book provides a comprehensive guide to the concepts, protocols, and techniques needed to develop robust and efficient network software. It covers a wide range of topics, including sockets, TCP/IP, UDP, raw sockets, and <span class="No-Break">multicast communication.</span></p>
			<p>Stevens’ detailed and methodical approach ensures that readers not only learn the theory behind network protocols but also gain practical skills through extensive examples and sample code. The book addresses common challenges in network programming, such as error handling, performance optimization, and scalability. It also explores advanced topics such as non-blocking I/O, signal-driven I/O, and the use of select and poll <span class="No-Break">for multiplexing.</span></p>
			<p><em class="italic">Unix Network Programming</em> is widely regarded as the definitive resource on the subject, known for its clarity, depth, and practical relevance. By following the guidance and examples provided, readers can develop a deep understanding of network programming principles <a id="_idIndexMarker954"/>and apply them to create efficient, reliable, and high-performance networked applications. Whether you are a beginner looking to learn the basics or an experienced programmer seeking to refine your skills, this book is an indispensable reference in the field of Unix <span class="No-Break">network programming.</span></p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor308"/>Linux System Programming Techniques: Become a proficient Linux system programmer using expert recipes and techniques</h2>
			<p>Ready to unravel the mysteries of Linux system programming? <em class="italic">Linux System Programming Techniques </em>is your ultimate guide to mastering the art of extending the Linux OS with your own programs. This book is like a masterclass, packed with practical examples and expert recipes that will turn you into a proficient Linux <span class="No-Break">system programmer.</span></p>
			<p>The author kicks things off by diving into the Linux filesystem and its basic commands. They guide you through the built-in manual pages, the <strong class="bold">GNU Compiler Collection</strong> (<strong class="bold">GCC</strong>), and <a id="_idIndexMarker955"/>essential Linux system calls. You’ll learn not just how to write programs, but how to handle errors like a pro, catching them and printing <span class="No-Break">relevant information.</span></p>
			<p>The book serves up many recipes on reading and writing files using streams and file descriptors. You’ll get hands-on experience with forking, creating zombie processes, and managing daemons with <strong class="source-inline">systemd</strong>. And just when you think you’ve got it all figured out, the authors introduce you to creating shared libraries and the nuances <span class="No-Break">of IPC.</span></p>
			<p>As you advance, you’ll delve into the world of POSIX threads, learning how to write robust multithreaded programs. Debugging your <a id="_idIndexMarker956"/>programs using the <strong class="bold">GNU Debugger</strong> (<strong class="bold">GDB</strong>) and Valgrind is covered extensively, ensuring you have all the tools you need to squash those <span class="No-Break">pesky bugs.</span></p>
			<p>By the end of this journey, you’ll be equipped to develop your own system programs for Linux, including daemons, tools, clients, and filters. The book promises to deepen your understanding of Linux system programming, integrating programs seamlessly with the <span class="No-Break">Linux OS.</span></p>
			<p>You’ll discover how to write programs using a wide variety of system calls and delve into POSIX functions. The book covers key concepts such as signals, pipes, IPC, and process management, giving you a comprehensive toolkit for any Linux system programming challenge. Advanced topics such as filesystem operations, creating shared libraries, and debugging your programs are also explored <span class="No-Break">in detail.</span></p>
			<p>It is perfect for <a id="_idIndexMarker957"/>anyone looking to develop system programs for Linux and gain a deeper understanding of the OS. Whether you’re facing issues with a specific part of Linux system programming or seeking specific recipes and solutions, this book has <span class="No-Break">you covered.</span></p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor309"/>Mastering Embedded Linux Programming - Third Edition: Create fast and reliable embedded solutions with Linux 5.4 and the Yocto Project 3.1 (Dunfell)</h2>
			<p>This is your definitive guide to creating versatile and robust embedded solutions with Linux 5.4 and the Yocto Project 3.1 (Dunfell). This book is like a master toolkit for anyone serious about embedded Linux development, from the basics to the cutting-edge features <span class="No-Break">of Linux.</span></p>
			<p>The author starts by breaking down the core elements of embedded Linux projects: the toolchain, the bootloader, the kernel, and the root filesystem. You’ll learn to create each component from scratch and automate the process using Buildroot and the Yocto Project. As you progress, the book guides you through implementing effective storage strategies for flash memory and remotely updating your devices once they’re deployed. It’s not just about getting things to work—it’s about making them work efficiently <span class="No-Break">and securely.</span></p>
			<p>You’ll dive into the nitty-gritty of writing code for embedded Linux, from accessing hardware directly from your applications to the complexities of multithreaded programming and efficient memory management. The final chapters are dedicated to debugging and profiling, ensuring you have all the tools to pinpoint performance bottlenecks and optimize <span class="No-Break">your system.</span></p>
			<p>By the end of this journey, you’ll be able to create efficient and secure embedded devices using Linux. Whether you’re dealing with smart TVs, Wi-Fi routers, industrial controllers, or any other IoT device, this book covers <span class="No-Break">it all.</span></p>
			<p>You’ll learn to use Buildroot and the Yocto Project to create embedded Linux systems, troubleshoot BitBake build failures, and streamline your Yocto development workflow. The book also covers secure updates for IoT devices using tools like Mender or Balena. Prototyping peripheral additions, interacting with hardware without kernel device drivers, dividing your system into supervised services with BusyBox <strong class="source-inline">runit</strong>, and remote debugging with GDB are also thoroughly covered. Performance measurement tools such as <strong class="source-inline">perf</strong>, <strong class="source-inline">ftrace</strong>, eBPF, and Callgrind are explained to help you optimize <span class="No-Break">your systems.</span></p>
			<p>If you’re a<a id="_idIndexMarker958"/> systems software engineer or system administrator looking to master Linux implementation on embedded devices, this book is for you. It’s also perfect for embedded systems engineers transitioning from low-power microcontrollers to high-speed systems on chips running Linux. Anyone responsible for developing new hardware that needs to run Linux will find this book invaluable. A basic working knowledge of the POSIX standard, C programming, and shell scripting is assumed, making this book both accessible <span class="No-Break">and comprehensive.</span></p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor310"/>Modern Operating Systems by Andrew S. Tanenbaum</h2>
			<p>Also, Tanenbaum’s book provides a comprehensive look at the operating systems used in modern computers, focusing on the mechanics of their operation and design principles. This book provides a comprehensive look at the operating systems used in modern computers, focusing on the mechanics of their operation and design principles. The text covers various topics critical to understanding how contemporary operating systems function, including process and thread management, memory management, filesystems, I/O systems, <span class="No-Break">and security.</span></p>
			<p>Tanenbaum’s clear and engaging writing style, combined with his ability to simplify complex concepts, makes this book accessible to both students and professionals. The book is renowned for its thorough explanations and well-organized structure, making it an excellent resource for both academic courses and self-study. It includes numerous case studies of popular operating systems such as Windows, Linux, and Unix, providing real-world examples of the <span class="No-Break">principles discussed.</span></p>
			<p><em class="italic">Modern Operating Systems</em> also delves into advanced topics such as distributed systems, multimedia systems, and real-time operating systems, reflecting the latest developments and trends in the field. The inclusion of practical examples, exercises, and review questions at the end of each chapter helps reinforce learning and provides hands-on experience with <span class="No-Break">the material.</span></p>
			<p>For anyone seeking to understand the complexities of modern operating systems and their design, this book is an essential read. It not only provides a solid theoretical foundation but also offers insights into practical implementation, making it a valuable resource for both aspiring and experienced <span class="No-Break">system programmers.</span></p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor311"/>The Art of UNIX Programming by Eric S. Raymond</h2>
			<p>This book explores <a id="_idIndexMarker959"/>the philosophy and practice of Unix programming, presenting a set of design norms and philosophies that Unix has accumulated over the years. Raymond delves into the Unix culture and its emphasis on simplicity, clarity, and modularity, which have shaped the development of Unix systems <span class="No-Break">and software.</span></p>
			<p>The book is divided into three parts: basic principles, design patterns, and case studies. In the first part, Raymond discusses the foundational principles of Unix programming, such as the importance of building small, reusable components that do one thing well, the power of text-based data streams, and the preference for <strong class="bold">open source software</strong> (<strong class="bold">OSS</strong>). These <a id="_idIndexMarker960"/>principles help readers understand the core values that guide <span class="No-Break">Unix development.</span></p>
			<p>The second part covers design patterns, where Raymond explains common patterns and best practices used in Unix programming. This section provides insights into how to structure programs, manage resources, and handle errors effectively. By understanding these patterns, programmers can create more maintainable and <span class="No-Break">robust software.</span></p>
			<p>The third part includes case studies of successful Unix programs, offering practical examples of the principles and patterns in action. These case studies illustrate how experienced Unix programmers approach problem-solving and software design, providing valuable lessons <span class="No-Break">for readers.</span></p>
			<p><em class="italic">The Art of UNIX Programming</em> is not just a technical manual but also a reflection on the cultural and philosophical aspects of Unix. Raymond’s engaging writing style and thoughtful commentary make it a compelling read for anyone interested in the Unix way of thinking. Whether you are a novice programmer or an experienced developer, this book offers a deeper appreciation of the Unix tradition and its enduring influence on <span class="No-Break">software development.</span></p>
			<p class="callout-heading">Mentorship</p>
			<p class="callout">Consider having a mentor as your last, but not least, step. Seek guidance from experienced Go developers or mentors who can provide valuable insights and advice in the context of <span class="No-Break">system programming.</span></p>
			<h1 id="_idParaDest-275"><a id="_idTextAnchor312"/>Your system programming journey</h1>
			<p>What a<a id="_idIndexMarker961"/> journey, right? Thanks for sticking with me this far. I hope you’ve gained a new perspective on creating Go applications with system programming <span class="No-Break">in mind.</span></p>
			<p>And remember – Go is more than a programming language; it’s a gateway to a world of possibilities in system development. By embracing continuous learning, staying engaged with the community, and applying your skills to real-world problems, you’ll be well equipped to build the high-performance, reliable, and scalable systems <span class="No-Break">of tomorrow.</span></p>
			<p>Let this book serve as your foundation, and may your journey in Go-powered system programming be filled with success <span class="No-Break">and innovation!</span></p>
			<p><span class="No-Break">Farewell!</span></p>
		</div>
	</div>
</div>


<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer030">
			<h1 id="_idParaDest-276" class="chapter-number"><a id="_idTextAnchor313"/>Appendix </h1>
			<h1 id="_idParaDest-277"><a id="_idTextAnchor314"/>Hardware Automation</h1>
			<p>In this chapter, you will learn about hardware automation, specifically focusing on interaction with physical hardware devices such as wearables and flash disks. The chapter explores how programs can respond to events triggered by USB and Bluetooth devices and the process of building programs that automate file organization on a flash drive or react to the distance of a <span class="No-Break">wearable device.</span></p>
			<p>The goal of the chapter is to equip you with the knowledge and skills to create a program that can automate tasks based on <span class="No-Break">hardware events.</span></p>
			<p>This information is crucial for any programmer interested in hardware interaction. In the real-world context, understanding how to automate tasks with hardware devices is increasingly important as the use of such devices becomes more prevalent. This knowledge can lead to more efficient and effective management of digital resources, enhance productivity, and provide practical solutions to <span class="No-Break">common problems.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li><span class="No-Break">USB</span></li>
				<li><span class="No-Break">Bluetooth</span></li>
				<li>XDG <span class="No-Break">and freedesktop.org</span></li>
			</ul>
			<h1 id="_idParaDest-278"><a id="_idTextAnchor315"/>Automation in system programming</h1>
			<p>Automation<a id="_idIndexMarker962"/> is centered around the interaction between physical hardware devices and the automation of tasks based on the state or changes in the state of these devices. This differs from software automation, which focuses on automating digital processes and tasks within <span class="No-Break">software environments.</span></p>
			<p>Programming automation is like herding cats. Now imagine that each cat is replaced by a line of code, and the people doing the herding are wearing blindfolds called “traditional programming approaches.” Within its community, Go acts like a high-powered laser pointer. Suddenly, those cats, or lines of code, line up in an orderly fashion, ready to follow your every command with the grace of a synchronized swimming team. This is the magic of Go’s library ecosystem — transforming what was once a chaotic cat rodeo into a well-orchestrated ballet of bytes and <span class="No-Break">data streams.</span></p>
			<p>The ability to write concise, efficient code that directly interfaces with hardware is not just a boon but a revolution in how we approach <a id="_idIndexMarker963"/>automation tasks. Whether managing data from a USB device or handling Bluetooth connections, the Go ecosystem provides vibrant community-driven libraries to make these tasks manageable and <span class="No-Break">remarkably easy.</span></p>
			<p>So, buckle up to link the physical world with system programming! This chapter explores two pieces of hardware from everyday use: wearables and <span class="No-Break">flash disks.</span></p>
			<h1 id="_idParaDest-279"><a id="_idTextAnchor316"/>USB</h1>
			<p>For this section, we are exploring how a program can respond to events triggered by USB devices. With this<a id="_idIndexMarker964"/> knowledge, when a specific USB device is plugged in, we can take several actions – for example, automatically start a backup process, launch an application, or execute a <span class="No-Break">custom script.</span></p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor317"/>Application</h2>
			<p>I like to keep my files organized, but every time I lend my flash disk to a friend, they just put all the files in the root directory with no organization whatsoever. Now, I have a messy storage device and an unstable friendship. Imagine (a hundred times worse) a root directory looks like <span class="No-Break">the following:</span></p>
			<pre class="console">
.
├── music_2.wav
├── picture_10.png
├── Book_2009.pdf
├── Manual_1.pdf
└── Manual_2.pdf</pre>			<p>To keep things cool between my friend and me, I created a program that automates keeping things organized in my <span class="No-Break">flash drive.</span></p>
			<h3>A quick refresher</h3>
			<p>The <strong class="bold">Universal Serial Bus</strong>, commonly known as <strong class="bold">USB</strong>, is more than just a cable and a port on your computer or device. It’s a<a id="_idIndexMarker965"/> comprehensive standard that defines cables, connectors, and communication protocols for connection, communication, and power supply between computers, peripherals, and <span class="No-Break">other computers.</span></p>
			<p>USB has evolved through several versions, offering speed, power delivery, and functionality improvements. The key features of USB include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Plug and play</strong>: Devices <a id="_idIndexMarker966"/>can be connected and disconnected without rebooting <span class="No-Break">the system</span></li>
				<li><strong class="bold">Power supply</strong>: USB can power connected devices, eliminating the need for separate power supplies for <span class="No-Break">some peripherals</span></li>
				<li><strong class="bold">Data transfer</strong>: USB transfers data between the device and <span class="No-Break">the computer</span></li>
			</ul>
			<h3>Flash drives</h3>
			<p>A flash drive, thumb drive, or USB stick is <a id="_idIndexMarker967"/>a portable storage device that uses flash memory and connects to a computer or other device via a USB interface. Flash drives are used for storing, transferring, and backing up data. They are valued for their size, durability, and speed, especially compared to older portable storage media such as floppy disks <span class="No-Break">and CD-ROMs.</span></p>
			<p>Let me share with you the process of building this kind of program. First, we should consider the building blocks: the goal and <span class="No-Break">the automation.</span></p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor318"/>The goal</h2>
			<p>In an automated way or not, we need to keep the files organized, so starting with this part seems like a <span class="No-Break">good idea.</span></p>
			<p>Let’s take a look at the <span class="No-Break">following function:</span></p>
			<pre class="source-code">
func organizeFiles(paths []string) ([]string, error) {
   var err error
   events := make([]string, 0)
   for _, path := range paths {
      err := filepath.WalkDir(path, func(path string, dir os.DirEntry, err error) error {
         if err != nil {
            return err
         }
         if !dir.IsDir() {
            ext := filepath.Ext(path)
            destDir := filepath.Join(filepath.Dir(path), ext[1:]) // Remove the leading dot from the extension
            destPath := filepath.Join(destDir, dir.Name())
            // Create the destination directory if it doesn›t exist
            if err := os.MkdirAll(destDir, os.ModePerm); err != nil {
               return err
            }
            // Move the file to the destination
            if err := os.Rename(path, destPath); err != nil {
               return err
            }
            events = append(events, fmt.Sprintf("Moved %s to %s\n", path, destPath))
         }
         return nil
      })
      if err != nil {
         fmt.Printf("Error walking the path %v: %v\n", path, err)
      }
   }
   return events, err
}</pre>			<p>Things we should notice are <span class="No-Break">the following:</span></p>
			<ol>
				<li><strong class="bold">Processing multiple paths</strong>: The function is designed to handle a slice of file paths, allowing it to operate on multiple directories or files <span class="No-Break">at once.</span></li>
				<li><strong class="bold">Directory traversal</strong>: Once again, we’re using <strong class="source-inline">filepath.WalkDir</strong> to traverse each directory tree specified in the <span class="No-Break">input paths.</span></li>
				<li><strong class="bold">Error handling</strong>: As it traverses directories, the function handles any errors encountered. This includes both errors in accessing the directory contents and errors specifically related to individual files or directories within <span class="No-Break">those paths.</span></li>
				<li><strong class="bold">File organization based on extension</strong>: For each file encountered (non-directory), the function organizes it into a new directory based on its file extension. This involves file organization based on extension. The function takes a detailed approach to organize files (excluding directories) by their extension. This process involves extracting the file extension, creating a new directory for each unique extension (if one doesn’t already exist), and moving the file into its newly designated directory. This systematic organization makes file management more intuitive <span class="No-Break">and accessible.</span></li>
				<li>Recording actions: The function records all the file movements it performs. Each action of moving a file from its original location to the new directory based on its extension is recorded as a string in the <span class="No-Break">events slice.</span></li>
				<li>Returning results: After processing all paths, the function returns <span class="No-Break">two values:</span><ul><li>A slice of strings (events), each describing an action taken on <span class="No-Break">a file</span></li><li>An error value, which is nil if no errors were encountered or the last error that occurred during the processing of <span class="No-Break">the paths</span></li></ul></li>
			</ol>
			<p>Let’s test this function! Once we are manipulating files, we can use a helper function to help us deal with <span class="No-Break">code repetition:</span></p>
			<pre class="source-code">
func createTempFileWithExt(dir, ext string) (string, error) {
   file, err := os.CreateTemp(dir, "*"+ext)
   if err != nil {
      return "", err
   }
   file.Close()
   return file.Name(), nil
}</pre>			<p>This helper function creates a temporary file with a given extension. A neat detail of the <strong class="source-inline">CreateTemp</strong> function is when the string pattern includes a <strong class="source-inline">"*"</strong> and the random string replaces the last <strong class="source-inline">"*"</strong>. For example, if the ext is “.txt” the filename will be something <span class="No-Break">like “1217776936.txt”.</span></p>
			<p>Look at the complete code of the tests for <strong class="source-inline">"success"</strong>, <strong class="source-inline">"empty path"</strong>, and <strong class="source-inline">"invalid path"</strong> in the <span class="No-Break">git repository.</span></p>
			<p>When reading from the storage, for a <strong class="source-inline">/temp</strong> path, we need to inform the program <span class="No-Break">as follows:</span></p>
			<pre class="console">
filepath.WalkDir("/tmp",...)</pre>			<p>However, we need to discover where the device is mounted for the flash drive. One way to do it manually is by using the <strong class="source-inline">df -h</strong> command, and the output will show multiple lines. Still, we’re interested in a line quite <span class="No-Break">like this:</span></p>
			<pre class="console">
/dev/sdc1        15G   16M   15G   1% /media/alexrios/usbtest</pre>			<p>Feeling overwhelmed by the output? Let’s understand <span class="No-Break">what’s happening:</span></p>
			<ul>
				<li><strong class="source-inline">/dev/sdc1</strong>: This field represents the device or block device corresponding to the mounted filesystem. In this case, <strong class="source-inline">/dev/sdc1</strong> is the device associated with <span class="No-Break">the filesystem.</span></li>
				<li><strong class="source-inline">15G</strong>: This field shows the total size of the filesystem, which is 15 gigabytes (GB) in <span class="No-Break">this example.</span></li>
				<li><strong class="source-inline">16M</strong>: This field displays the space used on the filesystem. Here, it indicates that 16 megabytes (MB) of disk space are currently <span class="No-Break">in use.</span></li>
				<li><strong class="source-inline">15G</strong>: This field represents the available disk space on the filesystem. In this case, there are 15 gigabytes of <span class="No-Break">free space.</span></li>
				<li><strong class="source-inline">1%</strong>: This field shows the percentage of disk space used. Only 1% of the total filesystem space is occupied in <span class="No-Break">this example.</span></li>
				<li><strong class="source-inline">/media/alexrios/usbtest</strong>: This field is the mount point of the filesystem. It indicates where the filesystem is mounted in the directory hierarchy. In this case, the filesystem is mounted <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">/media/alexrios/usbtest</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>Since a device could have multiple mount points (partitions) in the same flash drive, we will access this information programmatically by reading the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">proc/mounts</strong></span><span class="No-Break"> file.</span></p>
			<h2 id="_idParaDest-282"><a id="_idTextAnchor319"/>The /proc/mounts file</h2>
			<p>The <strong class="source-inline">/proc/mounts</strong> file is a <a id="_idIndexMarker968"/>special file in the Linux operating system that provides a real-time, dynamic view of the currently <span class="No-Break">mounted filesystems.</span></p>
			<p>Here’s what you can find in the <strong class="source-inline">/proc/mounts</strong> file and what each <span class="No-Break">field represents:</span></p>
			<ul>
				<li>Device or UUID: The first field usually represents the block device or <strong class="bold">Universally Unique Identifier</strong> (<strong class="bold">UUID</strong>) of the <a id="_idIndexMarker969"/>physical storage or partition where the filesystem is mounted. For example, it might be something like <strong class="source-inline">/dev/sda1</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">UUID=12345678-1234-5678-90ab-cdef01234567</strong></span><span class="No-Break">.</span></li>
				<li>Mount point: The second field shows the directory where the filesystem is mounted. This is the location in the filesystem hierarchy where you can access the contents of the <span class="No-Break">mounted device.</span></li>
				<li>Filesystem type: The third field specifies the type of filesystem mounted on the given mount point. Common examples include <strong class="source-inline">ext4</strong>, <strong class="source-inline">ntfs</strong>, <strong class="source-inline">tmpfs</strong>, <strong class="source-inline">nfs</strong>, and <span class="No-Break">many others.</span></li>
				<li>Mount options: The fourth field lists the mount options for mounting the filesystem. These options control various aspects of how the filesystem behaves. Common options include <strong class="source-inline">rw</strong> (read-write), <strong class="source-inline">ro</strong> (read-only), <strong class="source-inline">noexec</strong>, <strong class="source-inline">nosuid</strong>, <span class="No-Break">and more.</span></li>
				<li>Dump flag: The fifth field is typically either <strong class="source-inline">0</strong> or <strong class="source-inline">1</strong> and indicates whether the filesystem should be backed up using the dump command. A value of <strong class="source-inline">0</strong> means no backup, and <strong class="source-inline">1</strong> means it should be included <span class="No-Break">in backups.</span></li>
				<li>Filesystem check order: The sixth field is used by the <strong class="source-inline">fsck</strong> utility to determine the order in which filesystems should be checked during system startup. A value of <strong class="source-inline">0</strong> means no automatic <span class="No-Break">filesystem checks.</span></li>
			</ul>
			<p>The <strong class="source-inline">/proc/mounts</strong> file provides a convenient way for users and system utilities to examine the current state of mounted filesystems on a Linux system. Various system management tools, scripts, and administrators often use them to gather information about mounted devices and <span class="No-Break">their configurations.</span></p>
			<p class="callout-heading">/proc/mounts</p>
			<p class="callout">This is not an<a id="_idIndexMarker970"/> actual file on your disk but rather a virtual file that the Linux kernel generates and updates to reflect the current state of <span class="No-Break">mounted filesystems.</span></p>
			<h2 id="_idParaDest-283"><a id="_idTextAnchor320"/>Reading the files on the flash drive</h2>
			<p>It’s time to <a id="_idIndexMarker971"/>read <strong class="source-inline">/proc/mounts</strong> to read the mount point and discover where our program will read <span class="No-Break">the files.</span></p>
			<p>This is the program idea: listing all files on a device that is mounted on your system. Also, it should take a device path as an input parameter, verify the path, read mounted filesystems from <strong class="source-inline">/proc/mounts</strong>, and then list all files for the specified device. Let’s break down the code step by step, highlighting the key snippets for <span class="No-Break">each part.</span></p>
			<p><strong class="bold">Step 1: Reading the first parameter as </strong><span class="No-Break"><strong class="bold">a path</strong></span></p>
			<pre class="source-code">
path := os.Args[1]
if !strings.HasPrefix(path, "/dev/") {
    fmt.Println("Path must start with /dev/")
    return
}</pre>			<p>In this initial step, the program reads the first command-line argument as the path of the device. It then checks whether the provided path starts with <strong class="source-inline">/dev/</strong> to ensure it’s a valid device path. If the path doesn’t match the criteria, the program prints an error message <span class="No-Break">and exits.</span></p>
			<p><strong class="bold">Step 2: Opening and </strong><span class="No-Break"><strong class="bold">reading /proc/mounts</strong></span></p>
			<pre class="source-code">
file, err := os.Open("/proc/mounts")
if err != nil {
    fmt.Printf("Error opening /proc/mounts: %v\n", err)
    return
}
defer file.Close()</pre>			<p>The program <a id="_idIndexMarker972"/>opens the <strong class="source-inline">/proc/mounts</strong> file to read the list of mounted filesystems. If there’s an error opening the file, it prints the error and exits. The <strong class="source-inline">defer</strong> statement ensures that the file is closed once all operations on the file are completed, preventing <span class="No-Break">resource leaks.</span></p>
			<p><strong class="bold">Step 3: Scanning </strong><span class="No-Break"><strong class="bold">through /proc/mounts</strong></span></p>
			<pre class="source-code">
scanner := bufio.NewScanner(file)
for scanner.Scan() {
    line := scanner.Text()
    fields := strings.Fields(line)
    if len(fields) &gt;= 2 {
        device := fields[0]
        mountPoint := fields[1]</pre>			<p>Using a scanner, the program reads each line from <strong class="source-inline">/proc/mounts</strong>. It splits each line into fields, where the first field is the device, and the second field is its mount point. This step is crucial for identifying the mount point of the device specified by <span class="No-Break">the user.</span></p>
			<p><strong class="bold">Step 4: Matching the device and </strong><span class="No-Break"><strong class="bold">listing files</strong></span></p>
			<pre class="source-code">
if strings.HasPrefix(device, path) {
    mountPoint = strings.ReplaceAll(mountPoint, "\\040", " ")
    fmt.Printf("Device: %s is mounted on: %s\n", device, mountPoint)
    fmt.Println("Files:")
    err := filepath.Walk(mountPoint, func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return filepath.SkipDir
        }
        fmt.Println(path)
        return nil
    })
    if err != nil {
        fmt.Printf("Error walking the path %v: %v\n", mountPoint, err)
    }
}
}
}</pre>			<p>If the device <a id="_idIndexMarker973"/>from <strong class="source-inline">/proc/mounts</strong> matches the path provided by the user, the program then corrects any space encoding in the mount point path and announces the device and its mount point. It uses <strong class="source-inline">filepath.Walk</strong> to traverse the filesystem starting from the mount point, listing all files. If an error occurs during traversal, it prints <span class="No-Break">the error.</span></p>
			<p><strong class="bold">Step 5: Handling </strong><span class="No-Break"><strong class="bold">scanner errors</strong></span></p>
			<pre class="console">
if err := scanner.Err(); err != nil {
    fmt.Printf("Error reading /proc/mounts: %v\n", err)
}</pre>			<p>After completing the scan of <strong class="source-inline">/proc/mounts</strong>, the program checks for any errors that might have occurred during the scanning process and reports them. This ensures that any issues encountered while reading the file are acknowledged and <span class="No-Break">handled appropriately.</span></p>
			<p>Pay close attention to the <strong class="source-inline">mountPoint = strings.ReplaceAll(mountPoint, "\\040", " ")</strong> line. This is necessary to handle a specific formatting convention in the <strong class="source-inline">/proc/mounts</strong> file on <span class="No-Break">Unix-like systems.</span></p>
			<p>In <strong class="source-inline">/proc/mounts</strong>, which <a id="_idIndexMarker974"/>lists all mounted filesystems, spaces in file paths (common in mount points) are represented by the <strong class="source-inline">\040</strong> escape sequence. The file uses a space character to delimit different fields in each line. For instance, a mount point path such as <strong class="source-inline">/media/My Drive</strong> would be represented as <strong class="source-inline">/media/My\040Drive</strong> <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">/proc/mounts</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-284"><a id="_idTextAnchor321"/>Partitions versus blocks versus devices versus disks</h2>
			<p>In system programming and hardware automation, managing storage efficiently is crucial. To navigate this subject effectively, we should understand the fundamental concepts of partitions, blocks, devices, <span class="No-Break">and disks.</span></p>
			<h3>Partitions – dividing storage</h3>
			<p>A partition<a id="_idIndexMarker975"/> is a logical division of a physical storage device, such as a hard drive or SSD. Partitions are created to segment a single physical device into multiple isolated sections, each functioning as an independent storage unit. These divisions serve <span class="No-Break">several purposes:</span></p>
			<ul>
				<li><strong class="bold">Operating system isolation</strong>: Partitions enable the installation of different operating systems on a single physical disk, allowing users to choose between them <span class="No-Break">during boot</span></li>
				<li><strong class="bold">Data organization</strong>: Partitions help separate user data from system data, facilitating efficient data management <span class="No-Break">and backups</span></li>
				<li><strong class="bold">Security</strong>: Isolating data on separate partitions can enhance security by limiting access to specific sections<a id="_idIndexMarker976"/> of the <span class="No-Break">storage device</span></li>
			</ul>
			<h3>Blocks – fixed-sized storage units</h3>
			<p>Blocks<a id="_idIndexMarker977"/> are fixed-sized units of data used for storage and retrieval on storage devices. Storage devices, including hard drives and SSDs, are organized into blocks, each typically having a predefined size, such as 512 bytes or 4 KB. Key aspects of blocks include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Data handling</strong>: Operating systems interact with storage devices by reading and writing data in blocks. This block-based approach ensures data consistency and efficient <span class="No-Break">I/O operations.</span></li>
				<li><strong class="bold">Filesystem management</strong>: Filesystems manage data within these blocks, keeping track of which blocks are allocated to specific files <span class="No-Break">and directories.</span></li>
				<li><strong class="bold">Optimizing storage</strong>: Using fixed-sized blocks allows for the efficient use of storage space and <span class="No-Break">minimizes fragmentation.</span></li>
			</ul>
			<h3>Devices – the physical or virtual storage media</h3>
			<p>In the context of system programming and hardware automation, a device refers to either a physical <a id="_idIndexMarker978"/>storage device, such as a hard drive or SSD, or a virtual device represented by software. Devices can be seen as the interface through which the operating system and applications interact with storage resources. Key aspects include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Physical and virtual devices</strong>: Devices can be physical hardware components connected to a computer or virtual representations created by <span class="No-Break">software layers</span></li>
				<li><strong class="bold">Device identification</strong>: Detecting and identifying storage devices are crucial tasks in hardware automation, allowing for device initialization <span class="No-Break">and maintenance</span></li>
				<li><strong class="bold">Resource allocation</strong>: Managing <a id="_idIndexMarker979"/>devices includes tasks such as assigning device drivers, handling device failures, and ensuring efficient <span class="No-Break">data access</span></li>
			</ul>
			<h3>Disks – the storage hardware</h3>
			<p>Disks, a term often used<a id="_idIndexMarker980"/> interchangeably with storage devices, are the physical hardware <a id="_idIndexMarker981"/>components responsible for data storage. These <a id="_idIndexMarker982"/>can be <strong class="bold">hard disk drives</strong> (<strong class="bold">HDDs</strong>), <strong class="bold">solid-state drives</strong> (<strong class="bold">SSDs</strong>), optical drives, or <strong class="bold">network-attached storage</strong> (<strong class="bold">NAS</strong>) devices. Key aspects<a id="_idIndexMarker983"/> include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Types of disks</strong>: Various types of disks are available, each with its unique characteristics, including capacity, speed, <span class="No-Break">and durability</span></li>
				<li><strong class="bold">Storage capacity</strong>: Disks provide the storage capacity required for storing data, applications, and <span class="No-Break">operating systems</span></li>
				<li><strong class="bold">Performance</strong>: Different types of disks offer varying levels of performance, impacting data access speeds and overall <span class="No-Break">system responsiveness</span></li>
			</ul>
			<p>We still want to know when the flash drive was inserted into the USB and act (organize the files). Do we have a standardized way to do that? <span class="No-Break">Fortunately, yes!</span></p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor322"/>Open source to the rescue!</h2>
			<p>In the dynamic and ever-evolving landscape of Linux, a story of collaboration and innovation unfolded with the emergence of XDG <span class="No-Break">and freedesktop.org.</span></p>
			<h3>Birth of freedesktop.org</h3>
			<p>In the spring of 2000, a new chapter began with<a id="_idIndexMarker984"/> Havoc Pennington and his vision. Recognizing the fragmented state of the Linux desktop environment, he established freedesktop.org. It wasn’t just another organization; it was a beacon of collaboration, inviting developers from GNOME, KDE, and other projects to join hands. Their mission? To weave a tapestry of interoperability and shared technology across different <span class="No-Break">desktop environments.</span></p>
			<h3>XDG – the standard bearer</h3>
			<p>Parallel to<a id="_idIndexMarker985"/> this, the <strong class="bold">X Desktop Group</strong> (<strong class="bold">XDG</strong>) emerged, focusing on crafting standards that would serve as bridges between the diverse desktop environments. They weren’t just creating guidelines; they were building the lingua franca for the Linux desktop world. Their contributions, such as the XDG Base Directory and Desktop Menu Specifications, were like puzzle pieces that fit perfectly, bringing a sense of order and compatibility to the <span class="No-Break">once-chaotic landscape.</span></p>
			<h3>A symphony of collaboration</h3>
			<p>What set<a id="_idIndexMarker986"/> freedesktop.org and<a id="_idIndexMarker987"/> XDG apart was their approach. They didn’t dictate; they collaborated. They listened and adapted, creating solutions that resonated across various platforms. This wasn’t just about technology but about people, ideas, and the magic that happens when they <span class="No-Break">come together.</span></p>
			<p>In this tale of unity, XDG and freedesktop.org stand as beacons, illuminating the path toward a more integrated and user-friendly Linux experience. Their legacy is not just in the code and standards they’ve created, but in the spirit of cooperation they’ve fostered in the open <span class="No-Break">source community.</span></p>
			<p>To achieve our goal, we’re using one of the core components of <span class="No-Break">freedesktop.org: D-Bus.</span></p>
			<h3>D-Bus – the communication conduit</h3>
			<p>D-Bus, another brainchild nurtured in the ecosystem of freedesktop.org, is a message bus system that <a id="_idIndexMarker988"/>provides a simple way for applications to talk to one another and to the system. It’s like the postal service of the Linux world, delivering messages between applications, ensuring they can work <span class="No-Break">together harmoniously.</span></p>
			<p>Before we interact with USB events, let’s dip a toe in the water with a simpler example: sending <span class="No-Break">system notifications.</span></p>
			<p>First, we need to add the import <a id="_idIndexMarker989"/>of the <strong class="source-inline">dbus</strong> library, <strong class="source-inline">github.com/godbus/dbus/v5</strong>, after we should connect to the session bus and make sure that we’re deferring the release of <span class="No-Break">the resources:</span></p>
			<pre class="source-code">
conn, err := dbus.ConnectSessionBus()
if err != nil {
   fmt.Errorf("failed to connect to session bus: %v", err)
}
defer conn.Close()</pre>			<p>Look at the notification’s <span class="No-Break">specification (</span><a href="https://specifications.freedesktop.org/notification-spec/notification-spec-latest.html"><span class="No-Break">https://specifications.freedesktop.org/notification-spec/notification-spec-latest.html</span></a><span class="No-Break">)</span></p>
			<p>Now we need to use the connection to access the notification object to make a call <span class="No-Break">for it:</span></p>
			<pre class="source-code">
call := obj.Call("org.freedesktop.Notifications.Notify", 0, appName, replacesID, appIcon, summary, body, actions, hints, expireTimeout)
if call.Err != nil {
    fmt.Sprintf("Error: %v", call.Err)
    return
}</pre>			<p>As we can see in the notification specification, the parameters are <span class="No-Break">as follows:</span></p>
			<table id="table001-2" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="bold">Name</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="bold">Type</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="bold">Required</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="source-inline">app_name</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="source-inline">STRING</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">False</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>The name of the application sending the notification. Can <span class="No-Break">be blank.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="source-inline">replaces_id</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="source-inline">UINT32</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">False</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>The notification ID that this notification replaces. A value of <strong class="source-inline">0</strong> means that this notification won’t replace <span class="No-Break">existing notifications.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="source-inline">app_icon</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="source-inline">STRING</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">False</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>The program icon of the calling application. Can be an empty string, indicating <span class="No-Break">no icon.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="source-inline">summary</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="source-inline">STRING</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">True</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>The summary text briefly describing <span class="No-Break">the notification.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="source-inline">body</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="source-inline">STRING</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">False</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>The detailed body text. Can <span class="No-Break">be empty.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="source-inline">actions</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><strong class="source-inline">as </strong>(array of <span class="No-Break">strings)</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">False</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Actions that are sent as a list of pairs. Each even element in the list (starting at index 0) represents the identifier for the action. Each odd element is the localized string that will be displayed to <span class="No-Break">the user.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="source-inline">hints</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><strong class="source-inline">a{sv} </strong>(array of string-variant <span class="No-Break">pairs)</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">False</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>Hints that can be passed to the server from the client program. They can pass along information, such as the process PID or window ID. Can <span class="No-Break">be empty.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="source-inline">expire_timeout</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="source-inline">INT32</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break">True</span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>The timeout time in milliseconds from the display of the notification, at which the notification should <span class="No-Break">automatically close.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>Here’s what each variable represents and how it affects <span class="No-Break">the notification:</span></p>
			<ul>
				<li><strong class="source-inline">appName := "Organizer"</strong>: <strong class="source-inline">appName</strong> specifies the name of the application sending the notification. In this case, the notification will appear to come from an application named “<span class="No-Break">Super App.”</span></li>
				<li><strong class="source-inline">replacesID := uint32(0)</strong>: <strong class="source-inline">replacesID</strong> is used to replace an existing notification. A value of <strong class="source-inline">0</strong> means this new notification will not replace any existing notification. If it were a non-zero value, it would attempt to replace a notification with <span class="No-Break">that ID.</span></li>
				<li><strong class="source-inline">appIcon := "view-refresh"</strong>: <strong class="source-inline">appIcon</strong> specifies the icon of the application sending the notification. An empty string <strong class="source-inline">""</strong> indicates that no icon will be used. If a path or icon name were provided, it would display that icon with <span class="No-Break">the notification.</span></li>
				<li><strong class="source-inline">summary := "Organizer is done!"</strong>: <strong class="source-inline">summary</strong> is a brief text that describes the notification. In this case, the summary is “Organizer is done!”, which will likely be shown as the title or headline of <span class="No-Break">the notification.</span></li>
				<li><strong class="source-inline">body := fmt.Sprintf("The files at %s were successfully organized.", "/dev/sdc")</strong>: <strong class="source-inline">body</strong> is the detailed text of the notification, providing <span class="No-Break">more information.</span></li>
				<li><strong class="source-inline">actions := []string{}</strong>: <strong class="source-inline">actions</strong> are used to define interactive elements or buttons in the notification. An empty <strong class="source-inline">[]string{}</strong> slice means no actions or buttons will be added to <span class="No-Break">the notification.</span></li>
				<li><strong class="source-inline">hints := map[string]dbus.Variant{}</strong>: <strong class="source-inline">hints</strong> are additional properties or data that can be used to modify the appearance or behavior of the notification. An empty <strong class="source-inline">map[string]dbus.Variant{}</strong> map implies that no additional hints are provided. Hints can include things such as a sound file to play, urgency level, and <span class="No-Break">so on.</span></li>
				<li><strong class="source-inline">expireTimeout := int32(5000)</strong>: <strong class="source-inline">expireTimeout</strong> specifies the duration (in milliseconds) before the notification automatically closes. A value of <strong class="source-inline">5000</strong> means the notification will close after five seconds. A value of <strong class="source-inline">-1</strong> would mean the notification’s expiration depends on the notification server’s settings, and <strong class="source-inline">0</strong> would mean the notification never <span class="No-Break">expires automatically.</span></li>
			</ul>
			<p class="callout-heading">App icons</p>
			<p class="callout">You can find more about app icons on the specification <span class="No-Break">page (</span><a href="https://specifications.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html"><span class="No-Break">https://specifications.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html</span></a><span class="No-Break">).</span></p>
			<p>Lastly, we call <span class="No-Break">the object:</span></p>
			<pre class="source-code">
call := obj.Call("org.freedesktop.Notifications.Notify", 0, appName, replacesID, appIcon, summary, body, actions, hints, expireTimeout)
if call.Err != nil {
    fmt.Sprintf("Error: %v", call.Err)
    return
}</pre>			<p>In the <strong class="source-inline">usb/example2</strong> directory, we run the program by executing <span class="No-Break">the following:</span></p>
			<pre class="console">
go run main.go</pre>			<p>A new system notification will pop up on the screen! That’s <span class="No-Break">cool, huh?</span></p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor323"/>Interacting with USB events</h2>
			<p>We already have a way to organize the flash <a id="_idIndexMarker990"/>drive with the file extension, a function to discover the file mount, and a way to notify the user of the task’s completion. Now, we are ready to interact with the system event triggered when a new flash drive <span class="No-Break">is connected.</span></p>
			<p>Once again, we need to use the <span class="No-Break"><strong class="source-inline">dbus</strong></span><span class="No-Break"> package:</span></p>
			<pre class="source-code">
"github.com/godbus/dbus/v5"</pre>			<p>We need to connect to <span class="No-Break">the bus:</span></p>
			<pre class="source-code">
conn, err := dbus.SystemBus()
if err != nil {
   fmt.Sprintf("Failed to connect to system bus: %v\n", err)
  return
}
defer conn.Close()</pre>			<p>Since we’re<a id="_idIndexMarker991"/> interested in listening to the D-Bus events, we need to give the D-Bus connection a way to notify our program. We do that with a channel of <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">*dbus.Signal</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
ch := make(chan *dbus.Signal)
conn.Signal(ch)</pre>			<p>Remember, we’re not interested in all signals available in the bus; we just want the event representing the USB device being inserted. In our case, the signal name <span class="No-Break">is</span><span class="No-Break"><strong class="source-inline"> "org.freedesktop.DBus.ObjectManager.InterfacesAdded"</strong></span><span class="No-Break">.</span></p>
			<p>In D-Bus, we have a special entity to do that. It’s called a <span class="No-Break">match rule:</span></p>
			<p><strong class="source-inline">matchRule := "</strong><span class="No-Break"><strong class="source-inline">type='signal',sender='org.freedesktop.UDisks2',interface='org.freedesktop.DBus.ObjectManager',path='/org/freedesktop/UDisks2'"</strong></span></p>
			<p>In our program, <strong class="source-inline">matchRule</strong> is a string that defines a D-Bus match rule. The components of the match rule are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">type='signal'</strong>: Indicates that your program wants to listen for signals (as opposed to other types of D-Bus messages such as method calls <span class="No-Break">or errors).</span></li>
				<li><strong class="source-inline">sender='org.freedesktop.UDisks2'</strong>: Specifies that the signals should come from <strong class="source-inline">org.freedesktop.UDisks2</strong>, which is the D-Bus service provided by UDisks2 (a service for managing disk drives and related resources <span class="No-Break">in Linux).</span></li>
				<li><strong class="source-inline">interface='org.freedesktop.DBus.ObjectManager'</strong>: Filters signals to those that are emitted by objects implementing the <strong class="source-inline">org.freedesktop.DBus.ObjectManager</strong> interface. This interface is used for managing and enumerating objects (such as disk drives, partitions, etc.) under a certain <span class="No-Break">D-Bus service.</span></li>
				<li><strong class="source-inline">path='/org/freedesktop/UDisks2'</strong>: Specifies the path of the objects from which signals should be received. This path corresponds to the <span class="No-Break">UDisks2 service.</span></li>
			</ul>
			<p>The following<a id="_idIndexMarker992"/> line uses the established D-Bus connection (<strong class="source-inline">conn</strong>) to call the <strong class="source-inline">AddMatch</strong> method on the D-Bus daemon. <strong class="source-inline">AddMatch</strong> is a method provided by D-Bus that tells the bus daemon to start forwarding the messages (signals, in this case) that match the given rule to <span class="No-Break">your application.</span></p>
			<pre class="source-code">
call := conn.BusObject().Call("org.freedesktop.DBus.AddMatch", 0, matchStr)</pre>			<p>The details are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">conn.BusObject()</strong>: Retrieves a proxy object for communicating with the bus <span class="No-Break">daemon itself</span></li>
				<li><strong class="source-inline">.Call(...)</strong>: Calls a method on the <span class="No-Break">bus daemon</span></li>
				<li><strong class="source-inline">"org.freedesktop.DBus.AddMatch"</strong>: The method used to tell the D-Bus system’s central service to only send messages that meet specific criteria to the application calling <span class="No-Break">this method</span></li>
				<li><strong class="source-inline">0</strong>: The flag for the method call, usually set to <strong class="source-inline">0</strong> in typical <span class="No-Break">use cases</span></li>
				<li><strong class="source-inline">matchStr</strong>: The match rule defined earlier, passed as an argument to <span class="No-Break">the method</span></li>
			</ul>
			<p>In the following code is a loop that listens for specific D-Bus signals and handles them accordingly. It is particularly focused on signals related to new interfaces being added in UDisks2, which is a service for managing disk drives <span class="No-Break">in Linux.</span></p>
			<p>Let’s break down the code step <span class="No-Break">by step.</span></p>
			<p><strong class="bold">Step 1 – Listening </strong><span class="No-Break"><strong class="bold">for signals</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
   for signal := range ch {
       ...
   }</pre>			<p>This <strong class="source-inline">for</strong> loop iterates over a channel (<strong class="source-inline">ch</strong>) that receives D-Bus signals. Each item received over the channel is a <strong class="source-inline">signal</strong>, representing a D-Bus signal that has been sent to <span class="No-Break">your application.</span></p>
			<p><strong class="bold">Step 2 – Checking </strong><span class="No-Break"><strong class="bold">signal name</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
   if signal.Name == "org.freedesktop.DBus.ObjectManager.InterfacesAdded" {
       ...
   }</pre>			<p>The code checks whether the signal’s name is <strong class="source-inline">"org.freedesktop.DBus.ObjectManager.InterfacesAdded"</strong>. This signal is emitted when a new interface (such as a new block device) is added to the object manager <span class="No-Break">in UDisks2.</span></p>
			<p><strong class="bold">Step 3 – Extracting the </strong><span class="No-Break"><strong class="bold">object path</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
path := signal.Body[0].(dbus.ObjectPath)</pre>			<p>This line extracts the<a id="_idIndexMarker993"/> first element of the signal’s body, which should be the object path of the newly added interface. The object path identifies the specific object (such as a disk or partition) <span class="No-Break">within UDisks2.</span></p>
			<p><strong class="bold">Step 4 – Checking the </strong><span class="No-Break"><strong class="bold">path prefix</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
   if strings.HasPrefix(string(path), "/org/freedesktop/UDisks2/block_devices/") {
       ...
   }</pre>			<p>The code checks whether the path of the new interface starts with <strong class="source-inline">"/org/freedesktop/UDisks2/block_devices/"</strong>. This prefix indicates that the interface is a block device, such as a hard drive or USB <span class="No-Break">flash drive.</span></p>
			<p><strong class="bold">Step 5 – Accessing </strong><span class="No-Break"><strong class="bold">device properties</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
   deviceObj := conn.Object("org.freedesktop.UDisks2", path)
   deviceProps := deviceObj.Call("org.freedesktop.DBus.Properties.Get", 0, "org.freedesktop.UDisks2.Block", "Device")</pre>			<p>If the path matches, the <a id="_idIndexMarker994"/>code proceeds to interact with that specific device. It does so by calling the <strong class="source-inline">org.freedesktop.DBus.Properties.Get</strong> method on the device object to get its properties. The properties of interest are from the <strong class="source-inline">"org.freedesktop.UDisks2.Block"</strong> interface, specifically the <strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">Device"</strong></span><span class="No-Break"> property.</span></p>
			<p><strong class="bold">Step 6 – </strong><span class="No-Break"><strong class="bold">Error handling</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
   if deviceProps.Err != nil {
       ...
   }</pre>			<p>This checks whether there was an error in the method call to get the device properties. If there was an error, it prints an error message and continues to the <span class="No-Break">next signal.</span></p>
			<p><strong class="bold">Step 7 – Printing </strong><span class="No-Break"><strong class="bold">mount points</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
   mountPoints := deviceProps.Body[0].(dbus.Variant)
   fmt.Println(fmt.Sprintf("%s", mountPoints.Value()))</pre>			<p>This extracts the <strong class="source-inline">Device</strong> property from the response (<strong class="source-inline">deviceProps.Body[0]</strong>). The property is cast to the <strong class="source-inline">dbus.Variant</strong> type, which is a generic container for any D-Bus data type. The value is then printed out. This value typically represents the file path to the device node (such as <strong class="source-inline">/dev/sda1</strong> for a <span class="No-Break">disk partition).</span></p>
			<p>In the <strong class="source-inline">appendix-a/usb/example4</strong> directory, we execute <span class="No-Break">the program:</span></p>
			<pre class="console">
go run main.go</pre>			<p>We should see the name as something like <span class="No-Break">the following:</span></p>
			<pre class="console">
/dev/sdc
/dev/sdc1</pre>			<p>To understand this output, we should make clear the difference between storage devices <span class="No-Break">and partitions.</span></p>
			<p>The difference <a id="_idIndexMarker995"/>between the <strong class="source-inline">/dev/sdc</strong> and <strong class="source-inline">/dev/sdc1</strong> outputs in Linux is related to how storage devices and their partitions are represented in <span class="No-Break">the filesystem.</span></p>
			<p><strong class="source-inline">/dev/sdc</strong> represents the entire physical storage device. In Linux (and other Unix-like operating systems), storage devices such as hard drives, SSDs, and USB flash drives are represented as files in the <strong class="source-inline">/dev</strong> directory. The name <strong class="source-inline">sdc</strong> is typically assigned based on the order in which the system recognizes the device (following <strong class="source-inline">sda</strong>, <strong class="source-inline">sdb</strong>, and <span class="No-Break">so on).</span></p>
			<p>When the program output shows <strong class="source-inline">/dev/sdc</strong>, it refers to the whole storage device, which includes all its partitions <span class="No-Break">and data.</span></p>
			<p><strong class="source-inline">/dev/sdc1</strong> represents a specific partition on the storage device. The number at the end (<strong class="source-inline">1</strong> in this case) signifies the first partition on the <span class="No-Break"><strong class="source-inline">sdc</strong></span><span class="No-Break"> device.</span></p>
			<p>As we discussed earlier, partitions are subdivisions of a physical storage device. They allow you to segment the device into different sections, each of which can be formatted with a different filesystem or used for <span class="No-Break">different purposes.</span></p>
			<p>In other words, <strong class="source-inline">/dev/sdc1</strong> is the first partition on the <strong class="source-inline">/dev/sdc</strong> <span class="No-Break">storage device.</span></p>
			<p>In practical terms, the differences in accessing both are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Accessing <strong class="source-inline">/dev/sdc</strong> would be for operations that affect the entire disk, such as disk formatting, partitioning, and obtaining disk-wide information (such as total size, disk <span class="No-Break">health, etc.)</span></li>
				<li>Accessing <strong class="source-inline">/dev/sdc1</strong> would be for operations specific to that partition, such as mounting the partition to access its filesystem, checking the filesystem health, or formatting just <span class="No-Break">that partition</span></li>
			</ul>
			<p>Keep in mind that the path we choose here is to inspect all <span class="No-Break">partitions available.</span></p>
			<p>But wait! Since the D-Bus has the information on the partitions, it would be nice if we could access the mount point information from it instead of parsing the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">proc/mounts</strong></span><span class="No-Break"> file.</span></p>
			<p>Fortunately, <span class="No-Break">we can!</span></p>
			<p>Let’s look at how we can <a id="_idIndexMarker996"/>do that in our brand-new <span class="No-Break"><strong class="source-inline">mountPoints</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
func mountPoints(deviceNames []string) ([]string, error) {
   conn, err := dbus.ConnectSystemBus()
   if err != nil {
      return nil, fmt.Errorf("failed to connect to system bus: %v", err)
   }
   defer conn.Close()
   var mountPoints []string
   for _, deviceName := range deviceNames {
      objPath := path.Join("/org/freedesktop/UDisks2/block_devices", deviceName)
      obj := conn.Object("org.freedesktop.UDisks2", dbus.ObjectPath(objPath))
      var result map[string]dbus.Variant
      err = obj.Call("org.freedesktop.DBus.Properties.GetAll", 0, "org.freedesktop.UDisks2.Filesystem").Store(&amp;result)
      if err != nil {
         return nil, fmt.Errorf("failed to call method: %v", err)
      }
      if mountPointsVariant, exists := result["MountPoints"]; exists {
         mountPointsValue := mountPointsVariant.Value().([][]byte)
         for _, mp := range mountPointsValue {
            mountPoints = append(mountPoints, string(mp))
         }
      }
   }
   if len(mountPoints) == 0 {
      return nil, fmt.Errorf("no mount points found")
   }
   return mountPoints, nil
}</pre>			<p>Here’s an explanation of how the<a id="_idIndexMarker997"/> <span class="No-Break">function works:</span></p>
			<ul>
				<li>Connection to D-Bus: It starts by establishing a connection to the D-Bus system bus using <strong class="source-inline">dbus.ConnectSystemBus()</strong>. The system bus is used to interact with system-level services such as UDisks2. If there’s an error in connecting to the system bus, it returns <span class="No-Break">an error.</span></li>
				<li>Initialization: It initializes an empty <strong class="source-inline">mountPoints</strong> slice to store the mount points found for the <span class="No-Break">provided devices.</span></li>
				<li>Device name iteration: Using a <strong class="source-inline">for</strong> loop, the function then iterates through each device name in the <span class="No-Break"><strong class="source-inline">deviceNames</strong></span><span class="No-Break"> slice.</span></li>
				<li>D-Bus object path: For each device name, it constructs the D-Bus object path by joining it with the UDisks2 block device path. This is done using <strong class="source-inline">path.Join("/org/freedesktop/UDisks2/block_devices", deviceName)</strong>. This object path specifies the D-Bus object representing the block device with the <span class="No-Break">given name.</span></li>
				<li>D-Bus object and method call: It creates a D-Bus object using <strong class="source-inline">conn.Object</strong> with the UDisks2 service name and the constructed object path. Then, it calls the <strong class="source-inline">"org.freedesktop.DBus.Properties.GetAll"</strong> D-Bus method on the object to retrieve all properties of the <strong class="source-inline">"org.freedesktop.UDisks2.Filesystem"</strong> interface. The result is stored in the <span class="No-Break">result map.</span></li>
				<li>Mount points extraction: The function checks whether the <strong class="source-inline">"MountPoints"</strong> property exists in the resulting map using <strong class="source-inline">result["MountPoints"]</strong>. If it exists, it extracts the mount points as a slice of byte slices (<strong class="source-inline">[][]byte</strong>) from <span class="No-Break">the property.</span></li>
				<li>Conversion to strings: It then iterates through the byte slices of mount points and converts them to strings. These strings represent the mount points of the device. The mount points are appended to the <span class="No-Break"><strong class="source-inline">mountPoints</strong></span><span class="No-Break"> slice.</span></li>
				<li>Error handling: If no mount points were found for a device or if there was an error in the D-Bus method call, it returns an error indicating that no mount points <span class="No-Break">were found.</span></li>
				<li>Result return: Finally, if <a id="_idIndexMarker998"/>at least one mount point was found, the function returns the <strong class="source-inline">mountPoints</strong> slice containing all the mount points and nil as <span class="No-Break">the error.</span></li>
			</ul>
			<p>Now we know how to organize the files, listen to storage device events, and find the mount points. We are ready to glue all these <span class="No-Break">things up.</span></p>
			<p>The full functional example is available in the git repository. Try yourself to organize a messy <span class="No-Break">flash drive!</span></p>
			<h1 id="_idParaDest-287"><a id="_idTextAnchor324"/>Bluetooth</h1>
			<p>Imagine, if you will, a world where your trusty smartwatch does more than just count your steps or remind you of meetings. In this world, my Samsung Galaxy Watch Active 2 becomes the guardian of my workstation, a faithful ally ensuring that my data remains secure from the wandering eyes of overly curious colleagues. Yes, you read <span class="No-Break">that right.</span></p>
			<p>Welcome to my journey of turning a simple wearable into a tool of ingenious <span class="No-Break">workstation security.</span></p>
			<p>There I was, sitting in my cubicle adorned with the obligatory tech paraphernalia, when a thought struck me. In an office where “snooping” is often disguised as “accidental glances,” could I not leverage my beloved smartwatch to enhance my workstation’s security? The mission was set: to lock my screen automatically whenever I stepped away, leaving my nosy colleagues to stare at a pristine <span class="No-Break">lock screen.</span></p>
			<p>The strategy was straightforward yet elegant. I would employ a program that diligently monitored the<a id="_idIndexMarker999"/> Bluetooth signal strength (RSSI) between my Linux machine and my smartwatch. Once the signal dipped below a certain threshold – a subtle hint that I’d abandoned my desk, possibly in pursuit of another coffee – the script would gallantly secure my workstation. Pure genius, <span class="No-Break">isn’t it?</span></p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor325"/>Detecting the smartwatch</h2>
			<p>The<a id="_idIndexMarker1000"/> first step was <a id="_idIndexMarker1001"/>simple. The following program will use the <strong class="source-inline">github.com/muka/go-bluetooth/api</strong> <span class="No-Break">Bluetooth library:</span></p>
			<pre class="source-code">
package main
import (
    "fmt"
    "github.com/muka/go-bluetooth/api"
)
func main() {
    adapter, err := api.GetDefaultAdapter()
    if err != nil {
        panic(err)
    }
    err = adapter.StartDiscovery()
    if err != nil {
        panic(err)
    }
    devices, err := adapter.GetDevices()
    if err != nil {
        panic(err)
    }
    for _, device := range devices {
        info, err := device.GetProperties()
        if err != nil {
            continue
        }
        if info.Name == "Galaxy Watch Active2(207D)" {
            fmt.Println("Found the watch:", info.Name)
        }
    }
}</pre>			<p>Here’s how you can get the <a id="_idIndexMarker1002"/>default <span class="No-Break">Bluetooth adapter:</span></p>
			<pre class="source-code">
adapter, err := api.GetDefaultAdapter()
if err != nil {
    fmt.Printf("Failed to find default adapter: %s\n", err)
}</pre>			<p>With the<a id="_idIndexMarker1003"/> adapter, let’s start the <span class="No-Break">device discovery:</span></p>
			<pre class="source-code">
err = adapter.StartDiscovery()
if err != nil {
    fmt.Printf("Failed to start discovery: %s\n", err)
}</pre>			<p>We can now start to <a id="_idIndexMarker1004"/>retrieve and display <span class="No-Break">device information:</span></p>
			<pre class="source-code">
devices, err := adapter.GetDevices()
if err != nil {
    fmt.Printf("Failed to get devices: %s\n", err)
}
for _, device := range devices {
    info, err := device.GetProperties()
    if err != nil {
        fmt.Printf("Failed to get properties: %s\n", err)
        continue
    }
    fmt.Println(info.Name, info.Address, info.RSSI)
}</pre>			<p>Let’s examine this <span class="No-Break">code snippet:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">adapter.GetDevices()</strong></span><span class="No-Break">:</span><ul><li>This retrieves a list of discovered <span class="No-Break">Bluetooth devices.</span></li><li>If it fails to retrieve the devices, an error <span class="No-Break">is printed.</span></li><li>The program then iterates (<strong class="source-inline">for</strong> loop) through <span class="No-Break">each device.</span></li></ul></li>
				<li><span class="No-Break"><strong class="source-inline">device.GetProperties()</strong></span><span class="No-Break">:</span><ul><li>This obtains properties of each<a id="_idIndexMarker1005"/> device, such as the name, address, and <strong class="bold">received signal strength </strong><span class="No-Break"><strong class="bold">indicator</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">RSSI</strong></span><span class="No-Break">).</span></li><li>If fetching properties for a device fails, it prints an error message and continues with the <span class="No-Break">next device.</span></li><li>Lastly, it prints<a id="_idIndexMarker1006"/> each device’s name, address, and RSSI. RSSI<a id="_idIndexMarker1007"/> measures how well your device can hear a signal from an access point or router, which helps determine the distance from <span class="No-Break">the device.</span></li></ul></li>
			</ul>
			<p>Wait a minute! RSSI? What is that? Good question! Let’s explore <span class="No-Break">this concept.</span></p>
			<h3>Understanding RSSI</h3>
			<p>Imagine <a id="_idIndexMarker1008"/>RSSI as office gossip – you hear it loud and clear when you’re near the source (0 dB, the office rumor mill). Still, as you stroll away to your cubicle fortress, the details get fuzzier until they’re just whispers (-100 dB, practically the land of myths and legends). This RSSI, a creature of decibels, roams from 0 (gossip central) to -100 (the realm of forgotten tales), with its strength varying based on which Bluetooth beast it rides – each with <span class="No-Break">its quirks.</span></p>
			<h4>Distance estimation</h4>
			<p>RSSI, much <a id="_idIndexMarker1009"/>like our ability to hear office gossip, hints at how close we are to the source. Higher values (less negative, let’s say -30 dB) suggest you’re probably hovering over someone’s shoulder, while lower values (more negative, such as -80 dB) mean you’re safely in your cubicle, shielded from the chatter. But here’s the catch – RSSI is about as reliable in measuring exact distance as using coffee aroma is in navigating to the kitchen. It’s a wild mix of signal strength, the mood of the office walls, and whether the microwave is on its <span class="No-Break">interference spree.</span></p>
			<h4>Setting the proximity threshold</h4>
			<p>Now, let’s talk about <a id="_idIndexMarker1010"/>setting this so-called proximity threshold. This is like deciding how close you must be to hear the gossip. Say, -70 dBm – close enough to catch the gist but far away enough to feign ignorance. It’s a game of trial and error, much like finding the perfect spot in the office to catch Wi-Fi but avoid awkward conversations. And remember, just like the office layout changes (thanks to our restless office manager), this threshold might need some <span class="No-Break">tweaking occasionally.</span></p>
			<h4>Applications</h4>
			<p>RSSI isn’t just <a id="_idIndexMarker1011"/>about eavesdropping on office tales. In our tech haven, it’s the silent ninja triggering actions when devices cozy up – like magically unlocking doors as you approach (no more fumbling for keys!) or clocking you in because attendance systems are sneaky like that. And for the indoor positioning? It’s the modern-day Marauder’s Map, minus the accuracy to catch someone sneaking to the <span class="No-Break">break room.</span></p>
			<h4>Limitations</h4>
			<p>But here’s the fun part – RSSI-based <a id="_idIndexMarker1012"/>proximity detection is as precise as our office weather predictions. It’s less about measuring exact distances and more about wild guesses of “nearness.” Plus, the RSSI value changes its mind more often than our boss changes meeting schedules, thanks to walls, microwaves, and other tech gizmos <span class="No-Break">throwing tantrums.</span></p>
			<h4>Implementation considerations</h4>
			<p>If you’re <a id="_idIndexMarker1013"/>planning to harness the power of RSSI, prepare for some calibration wizardry – because each device and office corner has its own tale to tell. And to smooth out RSSI’s mood swings, a bit of filtering magic (such as a moving average spell) can keep your proximity detection from going on a <span class="No-Break">rollercoaster ride.</span></p>
			<p>After running this program a couple of times, I discovered RSSI -70 dBm works very well. So, let’s update our program to use <span class="No-Break">this value.</span></p>
			<p>First, let’s take a <span class="No-Break">periodic check:</span></p>
			<pre class="source-code">
ticker := time.NewTicker(10 * time.Second)
defer ticker.Stop()</pre>			<p>And then, change how we do our pooling and process <span class="No-Break">the devices:</span></p>
			<pre class="console">
for {
    select {
    case &lt;-ticker.C:
        devices, err := adapter.GetDevices()
        if err != nil {
            fmt.Printf("Failed to get devices: %s\n", err)
            continue
        }
        for _, device := range devices {
            info, err := device.GetProperties()
            if err != nil {
                fmt.Printf("Failed to get properties: %s\n", err)
                continue
            }
            if info.RSSI &lt; -70 &amp;&amp; info.Name == "Galaxy Watch Active2(207D) LE" {
                fmt.Println(info.Name, info.RSSI)
            }
        }
    }
}</pre>			<p>The updated<a id="_idIndexMarker1014"/> program includes several key changes from the previous one, focusing on implementing periodic polling using a ticker. Here’s what has changed from the previous program: the program executed a one-time scan for Bluetooth devices and then exited. It did not continuously monitor for device presence or changes. The scanning for devices and checking their properties was done immediately and only once when the program was run. There was no mechanism in place for the program to periodically check the status of <span class="No-Break">Bluetooth devices.</span></p>
			<p>So, in the updated program, we are using uses a <strong class="source-inline">time.Ticker</strong> to create periodic events every 10 seconds, allowing it to monitor changes and new devices <span class="No-Break">over time.</span></p>
			<p>The use of <strong class="source-inline">defer</strong> to ensure <strong class="source-inline">ticker.Stop()</strong> is called when the program exits, which helps in managing resources effectively and avoiding <span class="No-Break">potential leaks.</span></p>
			<p>This allows the program to continuously monitor the Bluetooth environment. Here is <span class="No-Break">the code:</span></p>
			<pre class="source-code">
   ticker := time.NewTicker(10 * time.Second)
   defer ticker.Stop()</pre>			<p>Also, we use the <strong class="source-inline">select</strong> statement for synchronization. The program now waits on the ticker’s channel using a <strong class="source-inline">select</strong> statement. This is a more efficient way to handle asynchronous, periodic events <span class="No-Break">in Go:</span></p>
			<pre class="source-code">
   select {
   case &lt;-ticker.C:
       // Device scanning logic
   }</pre>			<p class="callout-heading">Note</p>
			<p class="callout">The scanning for devices and checking their properties is now placed inside an infinite loop, which is triggered by the <span class="No-Break">ticker’s channel.</span></p>
			<p>These changes <a id="_idIndexMarker1015"/>make the program more suitable for our scenario, where continuous monitoring of Bluetooth devices <span class="No-Break">is required.</span></p>
			<p>Now it’s time to take action: lock <span class="No-Break">the screen!</span></p>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor326"/>Locking the screen</h2>
			<p>As the story of this <a id="_idIndexMarker1016"/>automation unfolded, we reached its climax – dynamically detecting the smartwatch and responding in real time. The plot was simple yet effective: should the watch wander beyond the threshold of -70 dBm, akin to stepping out of an invisible circle, my workstation would <span class="No-Break">lock itself.</span></p>
			<p>The moment of truth arrived each time the RSSI sang below -70 dBm. The program would execute the lock command. This function should be more <span class="No-Break">than enough:</span></p>
			<pre class="source-code">
func lockScreen() error {
   _, err := exec.Command("xdg-screensaver", "lock").Output()
   if err != nil {
      return err
   }
   return nil
}</pre>			<p>Now we should call the function when at our <span class="No-Break">proposed condition:</span></p>
			<pre class="source-code">
if info.RSSI &lt; -70 &amp;&amp; info.Name == "Galaxy Watch Active2(207D) LE" {
   err := lockScreen()
   if err != nil {
      fmt.Printf("Failed to lock screen: %s\n", err)
      continue
   }
}</pre>			<p class="callout-heading">Enter xdg-screensaver</p>
			<p class="callout">xdg-screensaver is a <a id="_idIndexMarker1017"/>command-line tool born from the need for a standardized way to control the screensaver across different desktop environments. In the past, each environment had its own way of handling screensavers, leading to compatibility headaches for developers and <span class="No-Break">users alike.</span></p>
			<p class="callout">xdg-screensaver stepped in as a unifier. It provided a common interface, allowing applications to seamlessly interact with the screensaver, regardless of the underlying desktop environment. This tool is a direct beneficiary of the standardization efforts championed by XDG, showcasing how abstract standards can lead to tangible, <span class="No-Break">user-friendly solutions.</span></p>
			<p>This was the<a id="_idIndexMarker1018"/> crescendo of my symphony – the locking of the screen, as seamless as the closing of a book after a captivating chapter. It was a dance of technology and logic, playing out on the grand stage of <span class="No-Break">my workstation.</span></p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor327"/>XDG dilemma</h2>
			<p>Word of my creation spread like wildfire across the cubicles. Colleagues, intrigued by the blend of convenience and security it offered, started flocking to my desk, their eyes wide with curiosity. “Can we use this too?” they asked eagerly, their voices a blend of excitement and a hint <span class="No-Break">of envy.</span></p>
			<p>After patting myself on the back for creating an automation that locked my computer when my smartwatch moved away, I hit a snag: the command I used to lock the screen, xdg-screensaver, didn’t work for everyone. Here’s a simpler take on what I discovered and what <span class="No-Break">it means.</span></p>
			<p>Think of xdg-screensaver<a id="_idIndexMarker1019"/> as a common tool that is supposed to work on most Linux computers. But, just like people in different countries speak different languages, computers in our office use different types of systems or “environments.” And it turns out that xdg-screensaver doesn’t speak the language of some of <span class="No-Break">these systems.</span></p>
			<h2 id="_idParaDest-291"><a id="_idTextAnchor328"/>The Wayland conundrum</h2>
			<p>The plot thickened with the introduction of<a id="_idIndexMarker1020"/> Wayland, the avant-garde system many had adopted. This new player in the game didn’t play well with xdg-screensaver, leaving those users out in the cold. The program, once the hero of the hour, now faced its limitation, its <span class="No-Break">Achilles’ heel.</span></p>
			<p>This journey took me into the depths of Bluetooth protocols, signal fluctuations, and the peculiarities of various desktop environments. Each discovery was like peeling back a layer, revealing more about the enigmatic nature of Bluetooth interactions and the challenges of creating a <span class="No-Break">one-size-fits-all solution.</span></p>
			<p>Perhaps the true purpose of this journey was not to deliver an immediate solution but to unravel the mysteries of Bluetooth automation itself. The real victory lay in the collective understanding we were gaining – an exploration of the nuances of technology that govern our <span class="No-Break">daily interactions.</span></p>
			<p>Now, each query about automation is met with a thoughtful conversation about the complexities of Bluetooth automation. The office buzzes with a newfound appreciation for the challenges and intricacies of creating technology that adapts to <span class="No-Break">diverse environments.</span></p>
			<h1 id="_idParaDest-292"><a id="_idTextAnchor329"/>Summary</h1>
			<p>In this chapter, we learned about the fundamentals of hardware automation, particularly in the context of system programming. Key lessons included understanding the interaction between software and physical hardware devices such as wearables and USB flash drives, the basics of USB technology, and the development of a program for automating file organization on a flash drive. Additionally, you have learned about an experiment involving a Bluetooth application designed to lock the screen, illustrating a practical application of <span class="No-Break">hardware-software interaction.</span></p>
			<p>The chapter covered practical aspects such as reading from the storage, understanding the <strong class="source-inline">/proc/mounts</strong> file in Linux, and the differences between partitions, blocks, devices, and disks. It also included how Bluetooth can be used to determine distance between based on <span class="No-Break">the RSSI.</span></p>
			<p>Understanding hardware automation, particularly in the context of USB and Bluetooth technologies, is common knowledge for modern programmers working with automation. These skills enable you to develop practical solutions for everyday <span class="No-Break">technological challenges.</span></p>
		</div>
	</div>
</div>
</body></html>