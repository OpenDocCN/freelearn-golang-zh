- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Stay Sharp with System Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持系统编程的敏锐度
- en: This chapter will wrap up our learning journey by exploring the history of the
    most famous projects and companies adopting Go. You will also be presented with
    the most iconic materials to learn about system programming and how to stay up
    to date with this community.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将通过探索采用Go最著名的项目和公司的历史来结束我们的学习之旅。你还将接触到学习系统编程和保持与这个社区同步的最具代表性的资料。
- en: 'The chapter will cover the following key topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下关键主题：
- en: Real-world applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真实世界的应用
- en: Navigating the system programming landscape
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在系统编程领域中导航
- en: Resources for continued learning
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续学习的资源
- en: By the end of this chapter, you will have learned how to continue enhancing
    your system programming knowledge and its ecosystem.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会如何继续提升你的系统编程知识和其生态系统。
- en: Real-world applications
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 真实世界的应用
- en: The best way to truly grasp the power of Go in system programming is to see
    it in the wild. Let’s explore real-world use cases where Go has been successfully
    employed to build robust and efficient systems.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 真正掌握Go在系统编程中的力量，最好的方式是看到它在野外的应用。让我们探索Go成功应用于构建稳健和高效系统的真实世界案例。
- en: Dropbox’s leap of faith
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dropbox的冒险尝试
- en: “Python is perfect for everything, right?” Ah, the sweet sound of naive optimism.
    You know – the kind you hear just before a catastrophic performance bottleneck
    in your monolithic Python code base. But hey, at least it was quick to write;
    am I right?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: “Python适合一切，对吧？”啊，这是天真乐观的甜美声音。你知道——那种你会在你的单体Python代码库发生灾难性性能瓶颈之前听到的声音。但嘿，至少它写起来很快；我说的对吗？
- en: You know, migrating from Python to Go is a bit like swapping out a skateboard
    for a Formula One race car. Sure – both get you from point A to B, but one does
    it with a heck of a lot more speed and precision. And let’s face it, who doesn’t
    love the thrill of a roaring engine, especially when it means your cloud storage
    service can handle millions of concurrent users?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道，从Python迁移到Go有点像用一辆F1赛车替换滑板。当然——两者都能让你从A点到B点，但一个做得更快更精确。而且说实话，谁不喜欢引擎轰鸣的刺激，尤其是当这意味着你的云存储服务可以处理数百万并发用户时？
- en: Dropbox, the beloved cloud storage giant, found itself in a similar predicament.
    Their Python backend, while convenient in the early days, was starting to creak
    under the weight of its own success. That’s when they made the bold decision to
    rewrite a significant chunk of their backend in Go. It’s fast, it’s efficient,
    and it’s got a concurrency model that makes scalability feel like child’s play.
    Well, maybe not child’s play, but certainly less like herding cats than Python’s
    threading model.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Dropbox，这个备受喜爱的云存储巨头，发现自己陷入了类似的困境。他们的Python后端，虽然在早期很方便，但随着自身成功的增加，开始显得力不从心。正是在这个时候，他们做出了大胆的决定，用Go重写了后端的一部分。它速度快，效率高，并且有一个让可扩展性变得像玩儿一样简单的并发模型。好吧，可能不是像玩儿一样简单，但肯定比Python的线程模型更容易管理。
- en: One of the key challenges Dropbox faced was handling a massive number of concurrent
    requests. With Python, this often involved spawning a new thread for each request,
    which quickly became a resource hog. Go, on the other hand, uses goroutines, which
    are far lighter and cheaper to create. This allowed Dropbox to scale its backend
    effortlessly, handling millions of concurrent users without breaking a sweat.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Dropbox面临的一个主要挑战是处理大量的并发请求。使用Python，这通常意味着为每个请求创建一个新的线程，这很快就会变成资源消耗者。然而，Go使用goroutines，它们更轻量级，创建成本更低。这使得Dropbox能够轻松扩展其后端，无需费劲就能处理数百万并发用户。
- en: No one can tell the story better than the Dropbox team itself. You can see it
    in more detail at the *Go at Dropbox* talk ([https://www.youtube.com/watch?v=JOx9enktnUM](https://www.youtube.com/watch?v=JOx9enktnUM)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人能比Dropbox团队自己更好地讲述这个故事了。你可以在*Go at Dropbox*的演讲中看到更多细节（[https://www.youtube.com/watch?v=JOx9enktnUM](https://www.youtube.com/watch?v=JOx9enktnUM))。
- en: HashiCorp – Go from day one
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HashiCorp——从第一天开始使用Go
- en: Infrastructure as code? More like infrastructure as a tangled ball of yarn.
    That’s the kind of exasperated sigh you’ll hear from DevOps engineers wrestling
    with complex configuration management tools. But fear not, for HashiCorp, the
    wizards of infrastructure automation, have a solution that’s as smooth as a well-oiled
    Kubernetes cluster.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施即代码？更像是基础设施即一团乱麻。这是你在与复杂的配置管理工具搏斗的DevOps工程师中会听到的那种沮丧的叹息。但别担心，因为基础设施自动化的巫师HashiCorp有一个解决方案，就像一个润滑良好的Kubernetes集群一样顺畅。
- en: Imagine trying to build a house using nothing but duct tape and toothpicks.
    It might work, but it’ll be flimsy, unstable, and prone to collapse. That’s what
    traditional infrastructure management can feel like. HashiCorp, however, offers
    a different approach, one that’s rooted in code, automation, and the power of
    Go.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，只用胶带和牙签来建造房子。这可能可行，但会显得脆弱、不稳定，容易倒塌。这就是传统基础设施管理可能给人的感觉。然而，HashiCorp提供了一种不同的方法，这种方法基于代码、自动化和Go的力量。
- en: HashiCorp, the creator of tools such as Terraform, Vault, and Consul, made a
    strategic decision early on to embrace Go as their primary language. This wasn’t
    just a whim; it was a calculated move that aligned with their vision of a more
    efficient, reliable, and scalable approach to infrastructure management.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: HashiCorp，Terraform、Vault和Consul等工具的创造者，在早期就做出了战略决策，将Go作为他们的主要编程语言。这并非一时冲动；这是一个经过深思熟虑的举动，与他们对更高效、可靠和可扩展的基础设施管理方法的愿景相一致。
- en: In an interview with Nic Jackson, a developer at HashiCorp, he discusses why
    they decided to use Go as the primary programming language for their products.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在与HashiCorp的开发者Nic Jackson的访谈中，他讨论了为什么他们决定将Go作为产品的主要编程语言。
- en: 'Here are some of the reasons why HashiCorp decided to use Go:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是HashiCorp决定使用Go的一些原因：
- en: It is simple and easy to learn, which makes it easier for developers to get
    started with and be productive.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它简单易学，这使得开发者更容易开始并提高生产力。
- en: It is good for building small, succinct applications. HashiCorp builds a lot
    of microservices, which are small, self-contained services that work together.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于构建小型、简洁的应用程序来说，这是一个不错的选择。HashiCorp构建了许多微服务，这些微服务是小型、自包含的服务，它们可以协同工作。
- en: It has a rich standard library, which means that a lot of the functionality
    that HashiCorp needs is already built into the language. This makes it easier
    to write programs in Go.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个丰富的标准库，这意味着HashiCorp需要的许多功能已经内置到语言中。这使得用Go编写程序变得更加容易。
- en: It is good for building highly distributed systems. HashiCorp’s products are
    designed to be used in distributed environments, and Go’s concurrency model makes
    it easy to write code that can run on multiple machines.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它非常适合构建高度分布式的系统。HashiCorp的产品设计用于在分布式环境中使用，Go的并发模型使得编写可以在多台机器上运行的代码变得容易。
- en: 'You can see the interview integrally at the following link: [https://youtu.be/qlwp0mHFLHU](https://youtu.be/qlwp0mHFLHU)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接中完整查看访谈：[https://youtu.be/qlwp0mHFLHU](https://youtu.be/qlwp0mHFLHU)
- en: Grafana Labs – visualizing success with Go
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Grafana Labs – 使用Go可视化成功
- en: In the ecosystem of monitoring and observability, Grafana Labs has emerged as
    a dominant force, empowering organizations to gain insights into their complex
    systems. While Grafana, their flagship visualization platform, is primarily a
    frontend application, the company’s backend infrastructure and numerous supporting
    tools are built on the foundation of Go. This strategic choice has played a crucial
    role in their ability to deliver high-performance, scalable, and reliable solutions
    for monitoring and observability.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在监控和可观察性的生态系统中，Grafana Labs已经崛起为一股主导力量，帮助组织深入了解其复杂的系统。虽然Grafana，他们的旗舰可视化平台，主要是一个前端应用程序，但公司的后端基础设施和众多支持工具都是建立在Go的基础之上。这个战略选择在他们的监控和可观察性解决方案的高性能、可扩展和可靠性方面发挥了关键作用。
- en: Modern systems generate a deluge of data, from metrics and logs to traces. Grafana
    Labs recognized the need for a backend infrastructure that could ingest, process,
    and store this data efficiently. Go’s inherent performance advantages, stemming
    from its compiled nature and efficient concurrency model, made it an ideal choice
    for handling the demanding workloads of monitoring and observability.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现代系统会产生大量的数据，从指标和日志到跟踪。Grafana Labs意识到需要一个能够高效地摄取、处理和存储这些数据的后端基础设施。Go的固有性能优势，源于其编译特性和高效的并发模型，使其成为处理监控和可观察性需求繁重的工作负载的理想选择。
- en: Grafana Labs leverages Go’s goroutines and channels to create highly concurrent
    and efficient backend services. Goroutines, lightweight threads of execution,
    allow them to handle a massive number of concurrent operations, such as data ingestion
    and query processing, without the overhead of traditional threads. Channels facilitate
    seamless communication and synchronization between goroutines, ensuring data integrity
    and efficient resource utilization.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Grafana Labs利用Go的goroutines和channels创建高度并发和高效的后端服务。轻量级的goroutines允许它们处理大量的并发操作，如数据摄取和查询处理，而无需传统线程的开销。channels促进了goroutines之间的无缝通信和同步，确保数据完整性和高效资源利用。
- en: Beyond Grafana, Grafana Labs has developed a suite of tools and components that
    rely on Go’s capabilities. Loki, their log aggregation system, utilizes Go’s efficient
    I/O handling and compression algorithms to ingest and store vast amounts of log
    data. Tempo, their distributed tracing backend, leverages Go’s networking capabilities
    for seamless communication between tracing agents and the central Tempo server.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Grafana，Grafana Labs还开发了一系列依赖Go能力的工具和组件。Loki，他们的日志聚合系统，利用Go高效的I/O处理和压缩算法来摄取和存储大量的日志数据。Tempo，他们的分布式跟踪后端，利用Go的网络能力实现跟踪代理和中央Tempo服务器之间的无缝通信。
- en: 'They define the main advantages of using Go:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 他们定义了使用Go的主要优势：
- en: '**Speed**: Go is quick, though not as fast as a meticulously written C program.
    However, it allows for quicker development compared to C. It significantly outpaces
    languages such as Perl or Ruby in terms of execution speed.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：Go运行速度快，虽然不如精心编写的C程序快，但它与C相比允许更快的开发。它在执行速度方面显著优于Perl或Ruby等语言。'
- en: '**Simplified deployment**: The static binaries that Go creates are straightforward
    to deploy.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化部署**：Go创建的静态二进制文件部署起来非常简单。'
- en: '**Balanced freedom**: Go offers considerable flexibility without the temptations
    of unnecessary complex pointer arithmetic, promoting simpler, effective coding
    practices.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平衡的自由度**：Go提供了相当大的灵活性，避免了不必要的复杂指针算术的诱惑，促进了简单而有效的编码实践。'
- en: '**Cross-platform compatibility**: Go supports building applications across
    various platforms, including Linux, Solaris, macOS, Windows, and BSDs on different
    architectures such as amd64, i686, or arm. Even lesser-known systems such as plan9
    might be supported, depending on the libraries used. For extremely uncommon platforms,
    gccgo might offer a viable solution.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨平台兼容性**：Go支持在包括Linux、Solaris、macOS、Windows以及不同架构（如amd64、i686或arm）上的BSDs等各个平台上构建应用程序。根据使用的库，甚至可能支持像plan9这样的不太为人所知的系统。对于非常不常见的平台，gccgo可能提供一种可行的解决方案。'
- en: '**Accessibility in programming**: Go simplifies backend and systems programming
    with its powerful yet elegant syntax.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编程的易用性**：Go通过其强大而优雅的语法简化了后端和系统编程。'
- en: '**Profiling tools**: The profiling capabilities in Go, such as CPU and heap
    profiling, are robust and valuable. The addition of trace profiling in Go 1.5
    has been particularly beneficial.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能分析工具**：Go中的性能分析功能，如CPU和堆分析，强大且有价值。Go 1.5中添加的跟踪分析特别有益。'
- en: '**Built-in concurrency**: Concurrency is an integral part of Go, making it
    easy to manage and effective to use.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内置并发**：并发是Go的一个基本组成部分，这使得它易于管理和有效使用。'
- en: '**Powerful interfaces**: Although Go’s interfaces may require some learning,
    they become indispensable once mastered.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强大的接口**：尽管Go的接口可能需要一些学习，但一旦掌握，它们就变得不可或缺。'
- en: There’s a full breakdown of the use of Go in Grafana Labs in the *Where and
    Why We Use Go* blog post ([https://grafana.com/blog/2015/08/21/where-and-why-we-use-go/](https://grafana.com/blog/2015/08/21/where-and-why-we-use-go/)).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Where and Why We Use Go*博客文章中，有关于Grafana Labs中Go使用情况的全面分析（[https://grafana.com/blog/2015/08/21/where-and-why-we-use-go/](https://grafana.com/blog/2015/08/21/where-and-why-we-use-go/))。
- en: Docker – building a container revolution with Go
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker – 使用Go构建容器革命
- en: 'Docker, the platform that revolutionized software development and deployment
    with its container technology, owes much of its success to a rather unconventional
    choice: Go. While other established languages such as Java or C++ might have seemed
    more obvious for building such a complex system, Docker’s founders recognized
    the unique advantages Go offered for their ambitious project.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Docker，这个通过其容器技术革新了软件开发和部署的平台，其成功很大程度上归功于一个相当不寻常的选择：Go。虽然像Java或C++这样的成熟语言在构建如此复杂的系统时可能看起来更为明显，但Docker的创始人认识到Go为他们的雄心勃勃项目提供的独特优势。
- en: At its core, Docker is about lightweight isolation and portability. Go’s minimalist
    syntax and compiled nature aligned perfectly with this philosophy. Go’s fast compilation
    times and ability to produce statically linked binaries streamlined the development
    process and ensured consistent behavior across different environments, making
    it easier to package and distribute Docker containers.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，Docker关注的是轻量级隔离和可移植性。Go的简约语法和编译特性与这一理念完美契合。Go的快速编译时间和能够生成静态链接的二进制文件简化了开发过程，并确保了在不同环境中的行为一致性，这使得打包和分发Docker容器变得更加容易。
- en: Docker’s design heavily relies on concurrency to manage multiple containers
    simultaneously. Go’s goroutines and channels provide a lightweight and efficient
    concurrency model, allowing Docker to handle many concurrent operations with minimal
    overhead. This proved crucial for building a scalable and responsive platform
    that could efficiently manage containerized applications.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的设计高度依赖于并发来同时管理多个容器。Go的goroutines和channels提供了一个轻量级且高效的并发模型，使得Docker能够以最小的开销处理许多并发操作。这对于构建一个可扩展且响应迅速的平台至关重要，该平台能够高效地管理容器化应用程序。
- en: One of Docker’s key strengths is its ability to run on various platforms, from
    Linux to Windows to macOS. Go’s cross-platform compatibility simplified the development
    process, as developers could write code once and compile it for different architectures
    without significant modifications. This enabled Docker to quickly expand its reach
    and become the de facto standard for containerization.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的一个关键优势是其能够在各种平台上运行，从Linux到Windows再到macOS。Go的跨平台兼容性简化了开发过程，因为开发者可以编写一次代码，然后为不同的架构编译，而无需进行重大修改。这使得Docker能够迅速扩大其影响力，成为容器化的实际标准。
- en: Although Go was relatively new when Docker was created, its increasing community
    and rapidly growing ecosystem provided the necessary libraries and tools for building
    a complex system. The Docker team actively contributed to the Go community, developing
    open source libraries such as `libcontainer` for low-level container management,
    further solidifying Go’s position in the container ecosystem.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Go在Docker创建时相对较新，但其不断增长的社区和快速发展的生态系统为构建复杂系统提供了必要的库和工具。Docker团队积极为Go社区做出贡献，开发了如`libcontainer`等开源库，用于低级容器管理，进一步巩固了Go在容器生态系统中的地位。
- en: In retrospect, Docker’s decision to embrace Go appears almost prescient. Go’s
    unique strengths aligned seamlessly with the requirements of containerization,
    enabling the Docker team to build a robust, efficient, and portable platform that
    transformed the way software is developed and deployed. While other languages
    might have sufficed, Go’s combination of simplicity, performance, concurrency,
    and cross-platform compatibility proved to be the perfect recipe for building
    a container revolution.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾过去，Docker决定拥抱Go似乎几乎是先知般的。Go的独特优势与容器化的需求完美契合，使得Docker团队能够构建一个强大、高效且可移植的平台，从而改变了软件开发和部署的方式。虽然其他语言可能也足够用，但Go的简单性、性能、并发性和跨平台兼容性的结合，证明了它是构建容器革命的完美配方。
- en: The list of successful applications written in Go goes on. To put things in
    perspective, Golang steals the scene in the **Cloud Native Computing Foundation**
    (**CNCF**). Most cloud-native apps are written in Go.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 用Go编写的成功应用程序列表还在继续。为了更清楚地了解这一点，Golang在**云原生计算基金会**（**CNCF**）中占据了主导地位。大多数云原生应用程序都是用Go编写的。
- en: You can browse all these projects at [https://www.cncf.io/](https://www.cncf.io/).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以浏览所有这些项目，请访问[https://www.cncf.io/](https://www.cncf.io/)。
- en: SoundCloud – from Ruby to Go
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SoundCloud – 从Ruby到Go
- en: SoundCloud initially built their platform using Ruby on Rails, which they affectionately
    called “Mothership.” This monolithic application handled their public API, used
    by both their client applications and thousands of third-party applications, as
    well as the user-facing web application. As the platform grew, so did the complexity
    and scale of the challenges they faced. With millions of users and a massive volume
    of music uploads every minute, the limitations of the monolithic architecture
    became increasingly apparent.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: SoundCloud最初使用Ruby on Rails构建了他们的平台，他们亲切地称之为“母舰”。这个单体应用程序处理了他们的公共API，这些API被他们的客户端应用程序和数千个第三方应用程序使用，以及面向用户的Web应用程序。随着平台的增长，他们面临的复杂性和规模挑战也随之增加。随着数百万用户和每分钟大量音乐上传，单体架构的局限性变得越来越明显。
- en: To address scalability issues, SoundCloud decided to transition to a microservices
    architecture. This approach allowed them to separate domain logic into smaller,
    independent services, each with its own well-defined API. The microservices architecture
    provided greater flexibility and improved scalability, but it also introduced
    new challenges, such as managing inter-service communication and ensuring consistent
    data handling.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决可扩展性问题，SoundCloud 决定过渡到微服务架构。这种方法允许他们将领域逻辑分解成更小、独立的微服务，每个微服务都有自己的明确定义的 API。微服务架构提供了更大的灵活性并提高了可扩展性，但也引入了新的挑战，例如管理服务间的通信和确保数据处理的一致性。
- en: 'SoundCloud’s engineering team evaluated several programming languages to support
    their new microservices architecture. Go was chosen for several key reasons:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: SoundCloud 的工程团队评估了多种编程语言以支持他们新的微服务架构。选择 Go 语言有几个关键原因：
- en: '**Performance and concurrency**: Go’s efficient concurrency model, powered
    by goroutines, allowed SoundCloud to handle numerous simultaneous connections,
    which was crucial for their high-traffic platform.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能和并发性**：Go 语言高效的并发模型，由 goroutines 驱动，使得 SoundCloud 能够处理大量的并发连接，这对于他们高流量的平台至关重要。'
- en: '**Simplicity and readability**: Go’s design philosophy of simplicity and minimalism
    made it easier for engineers to understand and maintain the code. The language’s
    **what you see is what you get** (**WYSIWYG**) nature helped new engineers become
    productive quickly, reducing the time from onboarding to making meaningful contributions.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简洁性和可读性**：Go 语言简洁和极简主义的设计哲学使得工程师更容易理解和维护代码。该语言的**所见即所得**（WYSIWYG）特性帮助新工程师快速成为生产力，减少了从入职到做出有意义的贡献的时间。'
- en: '**Fast compilation and deployment**: Go’s fast compilation times and static
    typing facilitated quick iterations during development. This enabled SoundCloud
    to rapidly develop, test, and deploy new features, improving their overall development
    velocity.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速编译和部署**：Go 语言的快速编译时间和静态类型促进了开发过程中的快速迭代。这使得 SoundCloud 能够快速开发、测试和部署新功能，提高了他们的整体开发速度。'
- en: '**Community and ecosystem**: The growing ecosystem of Go libraries and tools,
    as well as an active community, provided SoundCloud with the resources and support
    needed to build robust applications.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社区和生态系统**：Go 库和工具不断增长的生态系统以及活跃的社区为 SoundCloud 提供了构建稳健应用程序所需资源和支持。'
- en: SoundCloud gradually migrated their services to Go, starting with non-critical
    components to minimize risk. They developed several internal tools and libraries
    to support the new architecture, including Bazooka, their deployment platform.
    This phased approach allowed them to incrementally refactor the monolith without
    disrupting existing services.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: SoundCloud 逐步将服务迁移到 Go 语言，从非关键组件开始以最小化风险。他们开发了几个内部工具和库来支持新的架构，包括他们的部署平台 Bazooka。这种分阶段的方法允许他们逐步重构单体，而不影响现有服务。
- en: The transition to Go resulted in significant improvements in system performance
    and reliability. By leveraging Go’s concurrency features, SoundCloud could handle
    higher loads with fewer resources, reducing server costs. The simplicity of Go’s
    syntax and structure also made code reviews more focused on the problem domain
    rather than language intricacies, enhancing collaboration and productivity among
    developers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 向 Go 语言的过渡导致了系统性能和可靠性的显著提升。通过利用 Go 语言的并发特性，SoundCloud 可以用更少的资源处理更高的负载，从而降低服务器成本。Go
    语言的语法和结构的简洁性也使得代码审查更加专注于问题域，而不是语言复杂性，增强了开发者之间的协作和生产力。
- en: SoundCloud’s migration to Go was driven by the need for better performance,
    scalability, and maintainability as their platform grew. By adopting Go and a
    microservices architecture, they successfully overcame the limitations of their
    monolithic Ruby on Rails application, setting a strong foundation for future growth
    and innovation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 随着SoundCloud平台的增长，他们迁移到 Go 语言是由对更好性能、可扩展性和可维护性的需求驱动的。通过采用 Go 语言和微服务架构，他们成功地克服了单体
    Ruby on Rails 应用程序的局限性，为未来的增长和创新奠定了坚实的基础。
- en: Navigating the system programming landscape
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索系统编程领域
- en: The world of system programming is constantly evolving. To remain a skilled
    practitioner, it’s essential to stay informed about the latest developments.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 系统编程的世界不断在演变。为了保持技能的专业性，了解最新的发展至关重要。
- en: Go release notes and blog
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go 发布说明和博客
- en: Religiously follow Go’s release notes. Each new version often brings enhancements
    specifically for system programming, such as improved memory management or runtime
    optimizations.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 严格遵守Go的发布说明。每个新版本通常都会为系统编程带来特定的增强，例如改进的内存管理或运行时优化。
- en: The official Go blog is an excellent resource for staying up to date with the
    latest news, announcements, and updates related to the Go programming language.
    You can find it at [https://blog.golang.org/](https://blog.golang.org/).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的Go博客是了解与Go编程语言相关的最新新闻、公告和更新的绝佳资源。您可以在[https://blog.golang.org/](https://blog.golang.org/)找到它。
- en: Community
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 社区
- en: It may sound dated, but joining mailing lists such as `golang-nuts` and `golang-dev`
    can keep you in the loop about discussions, announcements, and developments in
    the Go community.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然听起来有些过时，但加入如`golang-nuts`和`golang-dev`之类的邮件列表，可以让你了解Go社区中的讨论、公告和发展情况。
- en: Controversy aside, following influential Go developers, Go-related accounts,
    and hashtags such as `#golang` on X can provide real-time updates, discussions,
    and links to interesting articles and resources.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 不论争议如何，关注有影响力的Go开发者、与Go相关的账户和标签，如X上的`#golang`，可以提供实时更新、讨论以及有趣的文章和资源的链接。
- en: Also, participate in online forums (such as Go’s subreddit), Slack channels,
    and conferences (such as *GopherCon*). Engage with other Go developers, learn
    from their experiences, and share your knowledge.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，参与在线论坛（如Go的subreddit），Slack频道和会议（如*GopherCon*）。与其他Go开发者互动，从他们的经验中学习，并分享你的知识。
- en: Contribution
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 贡献
- en: I highly recommend you follow repositories related to the Go programming language
    on GitHub, especially the official Go repository and popular Go libraries and
    frameworks, which can give you insights into ongoing developments, issues, and
    pull requests. As you feel confident, contributing to open source Go projects
    is an excellent way to learn and give back to the community.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议你关注GitHub上与Go编程语言相关的仓库，特别是官方Go仓库和流行的Go库和框架，这可以让你了解正在进行的发展、问题和拉取请求。当你感到自信时，为开源Go项目做出贡献是学习和回馈社区的一种极好方式。
- en: '*Tip*: Start with smaller contributions or bug fixes, and gradually take on
    more challenging tasks.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*提示*：从较小的贡献或错误修复开始，逐渐承担更具挑战性的任务。'
- en: Experimentation
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实验
- en: Don’t hesitate to experiment with new Go features and libraries as they become
    available. Hands-on experience is invaluable for understanding their potential
    in your projects.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当新的Go功能和库可用时，不要犹豫去尝试它们。实际操作经验对于理解它们在你的项目中的潜力至关重要。
- en: Resources for continued learning
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续学习的资源
- en: Your journey in system programming with Go doesn’t end here. The following resources
    will help you expand your knowledge and skills.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你的Go系统编程之旅不会就此结束。以下资源将帮助你扩展你的知识和技能。
- en: System programming focuses more on deepening your understanding of the fundamental
    layers of a computer system than on chasing the latest technologies or frameworks.
    It may seem counterintuitive, but the goal is to master the core principles rather
    than just keep up with the newest trends. By gaining a solid grasp of how operating
    systems, hardware, and system libraries interact, you develop the ability to write
    more efficient and reliable code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 系统编程更注重深化你对计算机系统基本层的理解，而不是追逐最新的技术或框架。这听起来可能有些反直觉，但目标是掌握核心原则，而不仅仅是跟上最新趋势。通过深入了解操作系统、硬件和系统库之间的交互，你将能够编写更高效和可靠的代码。
- en: This field requires a thorough knowledge of low-level programming languages,
    such as C and sometimes Assembly, as these languages offer the fine-grained control
    needed to manipulate hardware directly. System programmers often work on developing
    or modifying operating systems, drivers, embedded systems, and performance-critical
    applications. They need to understand memory management, process scheduling, and
    filesystem implementations, among other core components.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个领域需要深入了解低级编程语言，如C和有时是汇编语言，因为这些语言提供了直接操作硬件所需的精细控制。系统程序员通常从事开发或修改操作系统、驱动程序、嵌入式系统和性能关键型应用程序的工作。他们需要了解内存管理、进程调度和文件系统实现等核心组件。
- en: Moreover, system programming emphasizes a deep understanding of computer architecture,
    including CPU operations, caching mechanisms, and I/O processes. This knowledge
    enables you to optimize software to run efficiently on the hardware it targets,
    which is vital for applications where performance and resource utilization are
    critical.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，系统编程强调对计算机架构的深入理解，包括CPU操作、缓存机制和I/O过程。这种知识使你能够优化软件，使其在目标硬件上高效运行，这对于性能和资源利用至关重要的应用程序至关重要。
- en: Another aspect of system programming is its stability and longevity. Unlike
    high-level frameworks and libraries, which may become obsolete as new technologies
    emerge, the fundamental concepts of system programming remain constant. Mastering
    these principles provides a robust foundation that can be applied across various
    technologies and platforms, ensuring long-term relevance in the ever-evolving
    field of computer science.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 系统编程的另一个方面是其稳定性和持久性。与可能随着新技术出现而变得过时的高级框架和库不同，系统编程的基本概念保持不变。掌握这些原则提供了一个坚实的基石，可以应用于各种技术和平台，确保在计算机科学这个不断发展的领域中具有长期的相关性。
- en: I have some book recommendations for you, but they might be considered classics
    compared with recent publications.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一些书推荐给你，但与近期出版物相比，它们可能被认为是经典之作。
- en: Advanced Programming in the UNIX Environment by W. Richard Stevens
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 《UNIX环境高级编程》由W. Richard Stevens著
- en: Often referred to as *APUE*, this book is a detailed study of Unix system programming,
    covering all aspects of the Unix operating system and the fundamentals of system
    programming. It serves as an essential reference for understanding how Unix systems
    work, delving into topics such as file I/O, process control, signal handling,
    and **inter-process communication** (**IPC**). The book is known for its clear
    explanations and practical examples, making complex concepts accessible to both
    novice and experienced programmers. It also emphasizes best practices and robust
    programming techniques, equipping readers with the skills necessary to develop
    reliable and efficient Unix applications. With its comprehensive coverage and
    authoritative insights, APUE is a cornerstone in the library of any serious Unix
    programmer.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通常被称为*APUE*，这本书是Unix系统编程的详细研究，涵盖了Unix操作系统的所有方面和系统编程的基础。它作为理解Unix系统工作原理的必备参考书，深入探讨了诸如文件I/O、进程控制、信号处理和**进程间通信**（**IPC**）等主题。这本书以其清晰的解释和实用的例子而闻名，使复杂的概念对新手和经验丰富的程序员都易于理解。它还强调最佳实践和健壮的编程技术，为读者提供了开发可靠和高效Unix应用程序所需的技能。凭借其全面覆盖和权威见解，APUE是任何严肃Unix程序员图书馆的基石。
- en: 'Learn C Programming - Second Edition: A beginner’s guide to learning the most
    powerful and general-purpose programming language with ease'
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 《学习C编程 - 第二版：轻松掌握最强大、最通用的编程语言入门指南》
- en: In system programming, you will invariably touch some C code. In this case,
    I would recommend a smooth ride instead of a mountain bike competition. This book
    is like training wheels for your programming bike. It holds your hand, wipes your
    tears, and gently guides you into the cold, unforgiving world of C.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统编程中，你不可避免地会接触到一些C代码。在这种情况下，我建议选择平稳的骑行而不是山地自行车比赛。这本书就像是你的编程自行车上的辅助轮。它握住你的手，擦干你的眼泪，并温柔地引导你进入寒冷、残酷的C语言世界。
- en: The author distills the chaos of C into something you might understand. It’s
    almost like magic, but less exciting. Each chapter gives you examples to chew
    on, making sure you don’t just stare blankly at your screen, wondering what went
    wrong. The book doesn’t just throw you into the deep end. Instead, it walks you
    down the stairs into the shallow end, one careful step at a time.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 作者将C语言的混乱提炼成你可以理解的东西。这几乎就像魔法，但不够刺激。每一章都给你一些例子去咀嚼，确保你不会只是茫然地看着屏幕，不知道出了什么问题。这本书不会直接把你扔进深水区。相反，它一步一步地引导你走下楼梯，进入浅水区。
- en: This isn’t your grandpa’s C programming book. It’s got all the modern stuff
    to keep you from looking like a relic. Just when you think you’ve got it, the
    book throws in exercises to remind you that you don’t. Keeps you humble.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是你爷爷的C编程书。它包含了所有现代内容，让你看起来不会像古董。当你以为你已经掌握了它时，这本书会加入练习来提醒你，你还没有。这让你保持谦逊。
- en: If you’re a newbie or just need to refresh your C skills, this book has got
    you covered. The authors keep it simple, but not so simple you feel talked down
    to. It’s like they know you’re smart but clueless. A rare talent.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是个新手或者只是需要刷新你的C语言技能，这本书为你提供了全面的覆盖。作者们使内容简单，但又不至于让你感到被轻视。就像是他们知道你很聪明，但可能有些迷茫。这是一项罕见的天赋。
- en: 'It is your go-to guide for entering the wild world of C. It’s straightforward,
    practical, and slightly condescending in a way that makes you think: Maybe I can
    actually do this.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你进入C语言狂野世界的首选指南。它直接、实用，并且略带轻视，让你想：也许我真的可以做到这一点。
- en: 'Linux Kernel Programming - Second Edition: A comprehensive and practical guide
    to kernel internals, writing modules, and kernel synchronization'
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 《Linux内核编程 - 第二版》：一本全面且实用的内核内部结构、编写模块和内核同步指南
- en: So, you’ve decided to tackle the Linux kernel. Bold move. Picking up *Linux
    Kernel Programming - Second Edition* is like strapping on your hiking boots for
    a trek through the Himalayas. It’s tough terrain, but with the right guide, you’ll
    reach the summit.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你已经决定挑战Linux内核。这是一个大胆的决定。拿起《Linux内核编程 - 第二版》就像是穿上登山靴准备穿越喜马拉雅山脉。这是一片艰难的领域，但有了正确的指南，你将到达顶峰。
- en: The author of this book has a knack for making the labyrinth of kernel internals
    seem almost navigable. They break down the complexities into bite-sized pieces,
    making the overwhelming world of kernel development feel a bit less like rocket
    science. And they don’t just give you dry theory. Oh no – they hand you practical
    examples that are like breadcrumbs, leading you through a dense forest of code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的作者擅长使内核内部的迷宫看起来几乎可以导航。他们将复杂性分解成小块，使内核开发的浩瀚世界感觉不那么像火箭科学。而且他们不仅仅提供干燥的理论。哦不——他们给你提供实用的例子，就像面包屑一样，引导你穿过代码的密集森林。
- en: This book doesn’t just toss you into the deep end to fend for yourself. It takes
    you through the process step by step, from understanding kernel internals to writing
    modules and handling synchronization. It’s a methodical journey, one that ensures
    you don’t get lost along the way. And it’s not stuck in the past. The content
    is updated, modern, and relevant, so you’re learning the latest and greatest in
    kernel programming.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书不仅仅把你扔进深水区让你自己挣扎。它带你一步步地走，从理解内核内部结构到编写模块和处理同步。这是一次有系统的旅程，确保你在旅途中不会迷失方向。而且它并不停留在过去。内容是更新、现代且相关的，所以你学习的是内核编程的最新和最优秀的内容。
- en: Just when you start feeling confident, the book hits you with exercises and
    challenges that remind you there’s still a lot to learn. These aren’t just busywork—they’re
    designed to make you think critically and deepen your understanding.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始感到自信时，这本书会给你带来练习和挑战，让你意识到还有许多东西需要学习。这些不仅仅是忙碌的工作——它们旨在让你批判性地思考并深化你的理解。
- en: Whether you’re a newbie or looking to sharpen your kernel skills, this book
    is your reliable guide. The authors strike a perfect balance, simplifying the
    complex without dumbing it down. They know you’re smart but might need a bit of
    handholding in this daunting field.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 不论你是新手还是想要磨练你的内核技能，这本书都是你可靠的指南。作者们找到了完美的平衡点，简化了复杂的内容，但又不至于使内容变得肤浅。他们知道你很聪明，但可能在这个令人畏惧的领域中需要一点点的引导。
- en: In conclusion, it’s comprehensive, practical, and challenging in all the right
    ways. If you’re serious about mastering kernel programming, this book is your
    roadmap to success.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，这本书内容全面、实用且具有挑战性。如果你对掌握内核编程认真负责，这本书就是你的成功之路。
- en: 'Linux System Programming Techniques: Become a proficient Linux system programmer
    using expert recipes and techniques'
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 《Linux系统编程技巧》：使用专家技巧和技巧成为熟练的Linux系统程序员
- en: Think of this book as your mentor, ready to impart the wisdom of the Linux sages
    with a side of tough love.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将这本书视为你的导师，准备好用一丝严厉的爱来传授Linux圣贤的智慧。
- en: This book is packed with hands-on recipes. These are different from your run-of-the-mill,
    follow-the-instructions kind of recipes. They’re more like secret family recipes
    passed down from generations of Linux gurus, designed to give you fundamental
    skills and deep understanding. Each example is carefully crafted to show you how
    to do something and why it works that way.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书充满了实用的技巧。这些技巧与那些普通的、按步骤操作的技巧不同。它们更像是代代相传的家族秘方，旨在为你提供基本技能和深入理解。每个例子都经过精心设计，旨在展示如何做某事以及为什么这样做是有效的。
- en: You’ll appreciate the practical approach. The authors don’t just tell you what
    to do—they show you how to think like a system programmer. The challenges and
    exercises are where the magic happens. They push you to apply your knowledge,
    think critically, and solve real problems. It’s like having a stern but supportive
    coach who knows you’ve got what it takes.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你会欣赏这种实用方法。作者们不仅告诉你该做什么，还展示了如何像系统程序员一样思考。挑战和练习是魔法发生的地方。它们推动你应用你的知识，进行批判性思考，并解决实际问题。这就像有一个严厉但支持你的教练，他知道你有能力做到。
- en: This book is a testament to insightful, practical, and challenging learning
    in the most rewarding way. It offers expert recipes and techniques that will propel
    your skills to new heights, inspiring you to strive for continuous improvement.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书是对洞察力、实用性和挑战性学习的最好证明。它提供了专家级的食谱和技术，将推动你的技能达到新的高度，激励你追求持续改进。
- en: 'Operating Systems: Design and Implementation by Andrew S. Tanenbaum'
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 《操作系统：设计与实现》作者：安德鲁·S·坦南鲍姆
- en: This book, often used in academic settings, provides a solid foundation in the
    theory and practical aspects of operating systems. Tanenbaum’s approach includes
    running examples with a real operating system, MINIX, which he developed specifically
    for educational purposes. The book covers a broad range of topics essential to
    understanding operating systems, such as process management, memory management,
    filesystems, I/O systems, and security.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书常用于学术环境，为操作系统的理论和实践方面提供了坚实的基础。坦南鲍姆的方法包括使用他专门为教育目的开发的真实操作系统MINIX进行运行示例。本书涵盖了理解操作系统所必需的广泛主题，如进程管理、内存管理、文件系统、I/O系统和安全性。
- en: One of the standout features of this book is its hands-on methodology. By incorporating
    MINIX, Tanenbaum allows readers to explore and modify a real, working operating
    system. This practical experience is invaluable for gaining a deep understanding
    of how theoretical concepts are applied in real-world systems. The text also includes
    comprehensive explanations of operating system principles, complemented by detailed
    diagrams and code examples that illustrate the inner workings of OS components.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的一个显著特点是其实践方法。通过整合MINIX，坦南鲍姆让读者能够探索和修改一个真实的工作操作系统。这种实践经验对于深入理解理论概念如何在现实世界系统中应用是极其宝贵的。文本还包括对操作系统原理的全面解释，辅以详细的图表和代码示例，展示了操作系统组件的内部工作原理。
- en: '*Operating Systems: Design and Implementation* is structured to facilitate
    both learning and teaching, making it a favorite among students and educators
    alike. Tanenbaum’s clear and engaging writing style, coupled with his extensive
    experience in the field, ensures that complex ideas are presented in an accessible
    manner. For anyone looking to gain a thorough understanding of operating systems
    from both a theoretical and practical perspective, this book is an essential resource.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 《操作系统：设计与实现》结构旨在促进学习和教学，使其在学生和教育工作者中都非常受欢迎。坦南鲍姆清晰而引人入胜的写作风格，加上他在该领域的丰富经验，确保了复杂思想以易于理解的方式呈现。对于希望从理论和实践两个角度全面了解操作系统的人来说，这本书是必不可少的资源。
- en: Unix Network Programming by W. Richard Stevens
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 《Unix网络编程》作者：W.理查德·斯蒂文斯
- en: This is another classic by Stevens that delves into the specifics of network
    programming in Unix environments. It’s essential for anyone working with network
    applications in Unix. The book provides a comprehensive guide to the concepts,
    protocols, and techniques needed to develop robust and efficient network software.
    It covers a wide range of topics, including sockets, TCP/IP, UDP, raw sockets,
    and multicast communication.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由斯蒂文斯创作的另一部经典之作，深入探讨了Unix环境下的网络编程细节。对于在Unix环境下使用网络应用程序的任何人来说，这本书都是必不可少的。本书提供了开发健壮和高效网络软件所需的概念、协议和技术全面指南。它涵盖了广泛的主题，包括套接字、TCP/IP、UDP、原始套接字和多播通信。
- en: Stevens’ detailed and methodical approach ensures that readers not only learn
    the theory behind network protocols but also gain practical skills through extensive
    examples and sample code. The book addresses common challenges in network programming,
    such as error handling, performance optimization, and scalability. It also explores
    advanced topics such as non-blocking I/O, signal-driven I/O, and the use of select
    and poll for multiplexing.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 斯蒂文斯的详细且系统化的方法确保读者不仅能学习网络协议背后的理论，还能通过大量的示例和代码片段获得实际技能。本书针对网络编程中的常见挑战进行了探讨，例如错误处理、性能优化和可扩展性。它还探讨了高级主题，如非阻塞I/O、信号驱动I/O以及使用select和poll进行多路复用。
- en: '*Unix Network Programming* is widely regarded as the definitive resource on
    the subject, known for its clarity, depth, and practical relevance. By following
    the guidance and examples provided, readers can develop a deep understanding of
    network programming principles and apply them to create efficient, reliable, and
    high-performance networked applications. Whether you are a beginner looking to
    learn the basics or an experienced programmer seeking to refine your skills, this
    book is an indispensable reference in the field of Unix network programming.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 《Unix网络编程》被广泛认为是该主题的权威资源，以其清晰性、深度和实用性而闻名。通过遵循提供的指导和示例，读者可以深入理解网络编程原则，并将其应用于创建高效、可靠和高性能的网络应用程序。无论你是想学习基础的初学者，还是寻求提高技能的有经验的程序员，这本书都是Unix网络编程领域的不可或缺的参考书。
- en: 'Linux System Programming Techniques: Become a proficient Linux system programmer
    using expert recipes and techniques'
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 《Linux系统编程技术：使用专家秘籍和技术成为熟练的Linux系统程序员》
- en: Ready to unravel the mysteries of Linux system programming? *Linux System Programming
    Techniques* is your ultimate guide to mastering the art of extending the Linux
    OS with your own programs. This book is like a masterclass, packed with practical
    examples and expert recipes that will turn you into a proficient Linux system
    programmer.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 准备揭开Linux系统编程的神秘面纱？《Linux系统编程技术》是你掌握使用自己的程序扩展Linux操作系统的艺术的不二指南。这本书就像一个大师班，充满了实用的示例和专家秘籍，将使你成为一名熟练的Linux系统程序员。
- en: The author kicks things off by diving into the Linux filesystem and its basic
    commands. They guide you through the built-in manual pages, the **GNU Compiler
    Collection** (**GCC**), and essential Linux system calls. You’ll learn not just
    how to write programs, but how to handle errors like a pro, catching them and
    printing relevant information.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 作者从Linux文件系统和其基本命令开始，引导你了解内置的man页、**GNU编译器集合**（**GCC**）和基本Linux系统调用。你不仅将学习如何编写程序，还将学会如何像专业人士一样处理错误，捕捉它们并打印相关信息。
- en: The book serves up many recipes on reading and writing files using streams and
    file descriptors. You’ll get hands-on experience with forking, creating zombie
    processes, and managing daemons with `systemd`. And just when you think you’ve
    got it all figured out, the authors introduce you to creating shared libraries
    and the nuances of IPC.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供了许多关于使用流和文件描述符读写文件的秘籍。你将亲身体验分叉、创建僵尸进程以及使用`systemd`管理守护进程。在你认为一切尽在掌握之中时，作者们将向你介绍创建共享库和IPC的微妙之处。
- en: As you advance, you’ll delve into the world of POSIX threads, learning how to
    write robust multithreaded programs. Debugging your programs using the **GNU Debugger**
    (**GDB**) and Valgrind is covered extensively, ensuring you have all the tools
    you need to squash those pesky bugs.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你不断进步，你将深入POSIX线程的世界，学习如何编写健壮的多线程程序。本书详细介绍了使用**GNU调试器**（**GDB**）和Valgrind调试程序，确保你拥有所有必要的工具来消除那些讨厌的虫子。
- en: By the end of this journey, you’ll be equipped to develop your own system programs
    for Linux, including daemons, tools, clients, and filters. The book promises to
    deepen your understanding of Linux system programming, integrating programs seamlessly
    with the Linux OS.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到此旅程结束时，你将能够为Linux开发自己的系统程序，包括守护进程、工具、客户端和过滤器。本书承诺加深你对Linux系统编程的理解，使程序与Linux操作系统无缝集成。
- en: You’ll discover how to write programs using a wide variety of system calls and
    delve into POSIX functions. The book covers key concepts such as signals, pipes,
    IPC, and process management, giving you a comprehensive toolkit for any Linux
    system programming challenge. Advanced topics such as filesystem operations, creating
    shared libraries, and debugging your programs are also explored in detail.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你将发现如何使用各种系统调用编写程序，并深入了解 POSIX 函数。本书涵盖了诸如信号、管道、IPC 和进程管理等关键概念，为你提供了应对任何 Linux
    系统编程挑战的全面工具包。本书还详细探讨了高级主题，如文件系统操作、创建共享库以及调试你的程序。
- en: It is perfect for anyone looking to develop system programs for Linux and gain
    a deeper understanding of the OS. Whether you’re facing issues with a specific
    part of Linux system programming or seeking specific recipes and solutions, this
    book has you covered.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于想要为 Linux 开发系统程序并深入了解操作系统的任何人来说，这是一本完美的书籍。无论你是在面对 Linux 系统编程的特定部分的问题，还是在寻找特定的食谱和解决方案，这本书都能满足你的需求。
- en: 'Mastering Embedded Linux Programming - Third Edition: Create fast and reliable
    embedded solutions with Linux 5.4 and the Yocto Project 3.1 (Dunfell)'
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 《精通嵌入式 Linux 编程》- 第三版：使用 Linux 5.4 和 Yocto 项目 3.1（Dunfell）创建快速可靠的嵌入式解决方案
- en: This is your definitive guide to creating versatile and robust embedded solutions
    with Linux 5.4 and the Yocto Project 3.1 (Dunfell). This book is like a master
    toolkit for anyone serious about embedded Linux development, from the basics to
    the cutting-edge features of Linux.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你的 Linux 5.4 和 Yocto 项目 3.1（Dunfell）创建多功能和稳健嵌入式解决方案的终极指南。对于任何认真从事嵌入式 Linux
    开发的人来说，这本书就像是一个大师工具包，从基础知识到 Linux 的尖端特性。
- en: 'The author starts by breaking down the core elements of embedded Linux projects:
    the toolchain, the bootloader, the kernel, and the root filesystem. You’ll learn
    to create each component from scratch and automate the process using Buildroot
    and the Yocto Project. As you progress, the book guides you through implementing
    effective storage strategies for flash memory and remotely updating your devices
    once they’re deployed. It’s not just about getting things to work—it’s about making
    them work efficiently and securely.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 作者首先从分解嵌入式 Linux 项目的核心元素开始：工具链、引导加载程序、内核和根文件系统。你将学习从头创建每个组件，并使用 Buildroot 和
    Yocto 项目自动化这个过程。随着你的进步，本书将指导你实施有效的闪存存储策略，并在设备部署后远程更新你的设备。这不仅仅是让事情工作，而是让它们高效且安全地工作。
- en: You’ll dive into the nitty-gritty of writing code for embedded Linux, from accessing
    hardware directly from your applications to the complexities of multithreaded
    programming and efficient memory management. The final chapters are dedicated
    to debugging and profiling, ensuring you have all the tools to pinpoint performance
    bottlenecks and optimize your system.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你将深入探索为嵌入式 Linux 编写代码的细节，从直接从你的应用程序访问硬件到多线程编程的复杂性以及高效的内存管理。最后几章致力于调试和性能分析，确保你拥有所有工具来定位性能瓶颈并优化你的系统。
- en: By the end of this journey, you’ll be able to create efficient and secure embedded
    devices using Linux. Whether you’re dealing with smart TVs, Wi-Fi routers, industrial
    controllers, or any other IoT device, this book covers it all.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次旅程结束时，你将能够使用 Linux 创建高效且安全的嵌入式设备。无论你是在处理智能电视、Wi-Fi 路由器、工业控制器或其他任何物联网设备，这本书都涵盖了所有内容。
- en: You’ll learn to use Buildroot and the Yocto Project to create embedded Linux
    systems, troubleshoot BitBake build failures, and streamline your Yocto development
    workflow. The book also covers secure updates for IoT devices using tools like
    Mender or Balena. Prototyping peripheral additions, interacting with hardware
    without kernel device drivers, dividing your system into supervised services with
    BusyBox `runit`, and remote debugging with GDB are also thoroughly covered. Performance
    measurement tools such as `perf`, `ftrace`, eBPF, and Callgrind are explained
    to help you optimize your systems.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习如何使用 Buildroot 和 Yocto 项目创建嵌入式 Linux 系统，排查 BitBake 构建失败的问题，并简化你的 Yocto 开发工作流程。本书还涵盖了使用
    Mender 或 Balena 等工具为物联网设备进行安全更新的内容。本书还详细介绍了原型外围设备添加、无需内核设备驱动程序与硬件交互、使用 BusyBox
    `runit` 将系统划分为受监督服务以及使用 GDB 进行远程调试等内容。本书还解释了性能测量工具，如 `perf`、`ftrace`、eBPF 和 Callgrind，以帮助你优化系统。
- en: If you’re a systems software engineer or system administrator looking to master
    Linux implementation on embedded devices, this book is for you. It’s also perfect
    for embedded systems engineers transitioning from low-power microcontrollers to
    high-speed systems on chips running Linux. Anyone responsible for developing new
    hardware that needs to run Linux will find this book invaluable. A basic working
    knowledge of the POSIX standard, C programming, and shell scripting is assumed,
    making this book both accessible and comprehensive.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名系统软件工程师或系统管理员，希望掌握嵌入式设备上的 Linux 实现，这本书适合你。它也适用于从低功耗微控制器过渡到高速芯片上运行的 Linux
    系统的嵌入式系统工程师。任何需要开发需要运行 Linux 的新硬件的人都会发现这本书非常有价值。假设读者具备对 POSIX 标准、C 编程和 shell 脚本的基本了解，这使得这本书既易于接近又内容全面。
- en: Modern Operating Systems by Andrew S. Tanenbaum
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 《现代操作系统》由安德鲁·S·坦能鲍姆著
- en: Also, Tanenbaum’s book provides a comprehensive look at the operating systems
    used in modern computers, focusing on the mechanics of their operation and design
    principles. This book provides a comprehensive look at the operating systems used
    in modern computers, focusing on the mechanics of their operation and design principles.
    The text covers various topics critical to understanding how contemporary operating
    systems function, including process and thread management, memory management,
    filesystems, I/O systems, and security.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，坦能鲍姆的书籍全面审视了现代计算机使用的操作系统，重点关注它们的操作机制和设计原则。本书全面审视了现代计算机使用的操作系统，重点关注它们的操作机制和设计原则。文本涵盖了理解当代操作系统如何运行的关键主题，包括进程和线程管理、内存管理、文件系统、I/O
    系统和安全。
- en: Tanenbaum’s clear and engaging writing style, combined with his ability to simplify
    complex concepts, makes this book accessible to both students and professionals.
    The book is renowned for its thorough explanations and well-organized structure,
    making it an excellent resource for both academic courses and self-study. It includes
    numerous case studies of popular operating systems such as Windows, Linux, and
    Unix, providing real-world examples of the principles discussed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 坦能鲍姆清晰而引人入胜的写作风格，结合他简化复杂概念的能力，使得这本书既适合学生也适合专业人士阅读。这本书以其详尽的解释和良好的组织结构而闻名，是学术课程和自学的好资源。它包括了许多流行操作系统的案例研究，如
    Windows、Linux 和 Unix，提供了讨论原则的现实世界例子。
- en: '*Modern Operating Systems* also delves into advanced topics such as distributed
    systems, multimedia systems, and real-time operating systems, reflecting the latest
    developments and trends in the field. The inclusion of practical examples, exercises,
    and review questions at the end of each chapter helps reinforce learning and provides
    hands-on experience with the material.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*现代操作系统* 还深入探讨了高级主题，例如分布式系统、多媒体系统和实时操作系统，反映了该领域的最新发展和趋势。每章末尾包含的实际例子、练习和复习问题有助于巩固学习，并提供对材料的实际操作经验。'
- en: For anyone seeking to understand the complexities of modern operating systems
    and their design, this book is an essential read. It not only provides a solid
    theoretical foundation but also offers insights into practical implementation,
    making it a valuable resource for both aspiring and experienced system programmers.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何希望理解现代操作系统的复杂性和其设计的人来说，这本书是必读的。它不仅提供了一个坚实的理论基础，还提供了对实际实施的见解，使其成为有抱负的和经验丰富的系统程序员的宝贵资源。
- en: The Art of UNIX Programming by Eric S. Raymond
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 《UNIX 编程艺术》由埃里克·S·雷蒙德著
- en: This book explores the philosophy and practice of Unix programming, presenting
    a set of design norms and philosophies that Unix has accumulated over the years.
    Raymond delves into the Unix culture and its emphasis on simplicity, clarity,
    and modularity, which have shaped the development of Unix systems and software.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本书探讨了 Unix 编程的哲学和实践，展示了一套 Unix 多年来积累的设计规范和哲学。雷蒙德深入探讨了 Unix 文化及其对简洁、清晰和模块化的重视，这些都塑造了
    Unix 系统和软件的发展。
- en: 'The book is divided into three parts: basic principles, design patterns, and
    case studies. In the first part, Raymond discusses the foundational principles
    of Unix programming, such as the importance of building small, reusable components
    that do one thing well, the power of text-based data streams, and the preference
    for **open source software** (**OSS**). These principles help readers understand
    the core values that guide Unix development.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 本书分为三部分：基本原理、设计模式和案例研究。在第一部分，Raymond讨论了Unix编程的基础原则，例如构建小型、可重用组件的重要性，基于文本的数据流的强大功能，以及对开源软件（OSS）的偏好。这些原则帮助读者理解指导Unix开发的核心理念。
- en: The second part covers design patterns, where Raymond explains common patterns
    and best practices used in Unix programming. This section provides insights into
    how to structure programs, manage resources, and handle errors effectively. By
    understanding these patterns, programmers can create more maintainable and robust
    software.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分涵盖了设计模式，Raymond解释了在Unix编程中使用的常见模式和最佳实践。本节提供了如何构建程序、管理资源以及有效处理错误的见解。通过理解这些模式，程序员可以创建更易于维护和健壮的软件。
- en: The third part includes case studies of successful Unix programs, offering practical
    examples of the principles and patterns in action. These case studies illustrate
    how experienced Unix programmers approach problem-solving and software design,
    providing valuable lessons for readers.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分包括成功Unix程序案例研究，提供了原则和模式在实际应用中的实用示例。这些案例研究展示了经验丰富的Unix程序员如何解决问题和进行软件设计，为读者提供了宝贵的经验教训。
- en: '*The Art of UNIX Programming* is not just a technical manual but also a reflection
    on the cultural and philosophical aspects of Unix. Raymond’s engaging writing
    style and thoughtful commentary make it a compelling read for anyone interested
    in the Unix way of thinking. Whether you are a novice programmer or an experienced
    developer, this book offers a deeper appreciation of the Unix tradition and its
    enduring influence on software development.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 《UNIX编程艺术》不仅是一本技术手册，也是对Unix文化和哲学方面的反思。Raymond引人入胜的写作风格和深思熟虑的评论使它成为任何对Unix思维方式感兴趣的人的必读之作。无论你是新手程序员还是经验丰富的开发者，这本书都能让你对Unix传统及其对软件开发持久影响的欣赏更加深刻。
- en: Mentorship
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 导师制
- en: Consider having a mentor as your last, but not least, step. Seek guidance from
    experienced Go developers or mentors who can provide valuable insights and advice
    in the context of system programming.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 将导师视为你最后但同样重要的步骤。向经验丰富的Go开发者或导师寻求指导，他们可以在系统编程的背景下提供有价值的见解和建议。
- en: Your system programming journey
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的系统编程之旅
- en: What a journey, right? Thanks for sticking with me this far. I hope you’ve gained
    a new perspective on creating Go applications with system programming in mind.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 多么一段旅程，不是吗？感谢你一直陪伴我走到这里。我希望你通过系统编程的视角对创建Go应用程序有了新的认识。
- en: And remember – Go is more than a programming language; it’s a gateway to a world
    of possibilities in system development. By embracing continuous learning, staying
    engaged with the community, and applying your skills to real-world problems, you’ll
    be well equipped to build the high-performance, reliable, and scalable systems
    of tomorrow.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 记住——Go不仅仅是一种编程语言；它是通往系统开发世界中各种可能性的大门。通过拥抱持续学习，与社区保持互动，并将你的技能应用于现实世界的问题，你将准备好构建明天的高性能、可靠和可扩展的系统。
- en: Let this book serve as your foundation, and may your journey in Go-powered system
    programming be filled with success and innovation!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让这本书成为你的基石，愿你在Go驱动的系统编程之旅中充满成功和创新！
- en: Farewell!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 再见！
- en: Appendix
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录
- en: Hardware Automation
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件自动化
- en: In this chapter, you will learn about hardware automation, specifically focusing
    on interaction with physical hardware devices such as wearables and flash disks.
    The chapter explores how programs can respond to events triggered by USB and Bluetooth
    devices and the process of building programs that automate file organization on
    a flash drive or react to the distance of a wearable device.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解硬件自动化，特别是关注与物理硬件设备（如可穿戴设备和闪存盘）的交互。本章探讨了程序如何响应USB和蓝牙设备触发的事件，以及构建自动化文件组织在闪存盘上的程序或对可穿戴设备距离做出反应的过程。
- en: The goal of the chapter is to equip you with the knowledge and skills to create
    a program that can automate tasks based on hardware events.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是让你具备创建基于硬件事件自动执行任务的程序的知识和技能。
- en: This information is crucial for any programmer interested in hardware interaction.
    In the real-world context, understanding how to automate tasks with hardware devices
    is increasingly important as the use of such devices becomes more prevalent. This
    knowledge can lead to more efficient and effective management of digital resources,
    enhance productivity, and provide practical solutions to common problems.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何对硬件交互感兴趣的程序员来说，这些信息至关重要。在现实世界的背景下，随着这类设备的使用越来越普遍，了解如何使用硬件设备自动化任务变得越来越重要。这些知识可以导致数字资源的更有效和高效的管理，提高生产力，并为常见问题提供实际解决方案。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: USB
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: USB
- en: Bluetooth
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝牙
- en: XDG and freedesktop.org
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XDG和freedesktop.org
- en: Automation in system programming
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统编程中的自动化
- en: Automation is centered around the interaction between physical hardware devices
    and the automation of tasks based on the state or changes in the state of these
    devices. This differs from software automation, which focuses on automating digital
    processes and tasks within software environments.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化主要集中在物理硬件设备之间的交互以及基于这些设备状态或状态变化的任务自动化。这与软件自动化不同，软件自动化侧重于在软件环境中自动化数字过程和任务。
- en: Programming automation is like herding cats. Now imagine that each cat is replaced
    by a line of code, and the people doing the herding are wearing blindfolds called
    “traditional programming approaches.” Within its community, Go acts like a high-powered
    laser pointer. Suddenly, those cats, or lines of code, line up in an orderly fashion,
    ready to follow your every command with the grace of a synchronized swimming team.
    This is the magic of Go’s library ecosystem — transforming what was once a chaotic
    cat rodeo into a well-orchestrated ballet of bytes and data streams.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 编程自动化就像牧猫。现在想象一下，每只猫都变成了一行代码，而牧猫的人戴着被称为“传统编程方法”的蒙眼布。在Go社区中，Go就像一个高功率激光笔。突然，那些猫，或者说那些代码，整齐地排列起来，准备以同步游泳队的优雅姿态听从你的每一个命令。这就是Go的库生态系统的魔力——将曾经混乱的猫马戏团变成了一场精心编排的字节和数据流芭蕾舞。
- en: The ability to write concise, efficient code that directly interfaces with hardware
    is not just a boon but a revolution in how we approach automation tasks. Whether
    managing data from a USB device or handling Bluetooth connections, the Go ecosystem
    provides vibrant community-driven libraries to make these tasks manageable and
    remarkably easy.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 能够编写简洁、高效的代码，直接与硬件接口，不仅是一大福音，而且是我们处理自动化任务方式的一次革命。无论是管理USB设备的数据还是处理蓝牙连接，Go生态系统提供了充满活力的社区驱动的库，使这些任务变得可管理且异常简单。
- en: 'So, buckle up to link the physical world with system programming! This chapter
    explores two pieces of hardware from everyday use: wearables and flash disks.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，系好安全带，将物理世界与系统编程联系起来！本章探讨了两个日常使用的硬件设备：可穿戴设备和闪存盘。
- en: USB
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: USB
- en: For this section, we are exploring how a program can respond to events triggered
    by USB devices. With this knowledge, when a specific USB device is plugged in,
    we can take several actions – for example, automatically start a backup process,
    launch an application, or execute a custom script.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一个程序如何响应由USB设备触发的事件。有了这些知识，当特定的USB设备被插入时，我们可以采取几种行动——例如，自动启动备份过程，启动应用程序或执行自定义脚本。
- en: Application
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序
- en: 'I like to keep my files organized, but every time I lend my flash disk to a
    friend, they just put all the files in the root directory with no organization
    whatsoever. Now, I have a messy storage device and an unstable friendship. Imagine
    (a hundred times worse) a root directory looks like the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢保持我的文件井井有条，但每次我把我的闪存盘借给朋友时，他们总是把所有文件都放在根目录中，没有任何组织。现在，我有一个杂乱无章的存储设备和一段不稳定的友谊。想象一下（糟糕一百倍）根目录看起来如下：
- en: '[PRE0]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To keep things cool between my friend and me, I created a program that automates
    keeping things organized in my flash drive.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我和朋友之间的关系保持融洽，我创建了一个程序来自动化我的闪存盘中的组织。
- en: A quick refresher
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 快速回顾
- en: The **Universal Serial Bus**, commonly known as **USB**, is more than just a
    cable and a port on your computer or device. It’s a comprehensive standard that
    defines cables, connectors, and communication protocols for connection, communication,
    and power supply between computers, peripherals, and other computers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用串行总线**（通常称为**USB**），不仅仅是你的电脑或设备上的一个电缆和一个端口。它是一个全面的标准，定义了连接、通信和电源供应的电缆、连接器和通信协议，用于计算机、外围设备和其他计算机之间的连接、通信和电源供应。'
- en: 'USB has evolved through several versions, offering speed, power delivery, and
    functionality improvements. The key features of USB include the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: USB 已经历了几次版本迭代，提供了速度、电源传输和功能改进。USB 的关键特性包括以下内容：
- en: '**Plug and play**: Devices can be connected and disconnected without rebooting
    the system'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**即插即用**：设备可以在不重启系统的情况下连接和断开。'
- en: '**Power supply**: USB can power connected devices, eliminating the need for
    separate power supplies for some peripherals'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电源供应**：USB 可以为连接的设备供电，消除了某些外围设备需要单独电源的需求'
- en: '**Data transfer**: USB transfers data between the device and the computer'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据传输**：USB 在设备和计算机之间传输数据'
- en: Flash drives
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: U盘
- en: A flash drive, thumb drive, or USB stick is a portable storage device that uses
    flash memory and connects to a computer or other device via a USB interface. Flash
    drives are used for storing, transferring, and backing up data. They are valued
    for their size, durability, and speed, especially compared to older portable storage
    media such as floppy disks and CD-ROMs.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: U盘、闪存盘或USB棒是一种使用闪存并通过USB接口连接到计算机或其他设备的便携式存储设备。U盘用于存储、传输和备份数据。它们因其尺寸、耐用性和速度而受到重视，尤其是与老式的便携式存储媒体（如软盘和CD-ROM）相比。
- en: 'Let me share with you the process of building this kind of program. First,
    we should consider the building blocks: the goal and the automation.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我与你分享构建这类程序的过程。首先，我们应该考虑构建模块：目标和自动化。
- en: The goal
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: In an automated way or not, we need to keep the files organized, so starting
    with this part seems like a good idea.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是自动化的还是非自动化的，我们都需要保持文件组织，因此从这个部分开始似乎是个好主意。
- en: 'Let’s take a look at the following function:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下函数：
- en: '[PRE1]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Things we should notice are the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意以下事项：
- en: '**Processing multiple paths**: The function is designed to handle a slice of
    file paths, allowing it to operate on multiple directories or files at once.'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理多个路径**：该函数被设计来处理文件路径的一部分，允许它一次性操作多个目录或文件。'
- en: '`filepath.WalkDir` to traverse each directory tree specified in the input paths.'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `filepath.WalkDir` 遍历输入路径中指定的每个目录树。
- en: '**Error handling**: As it traverses directories, the function handles any errors
    encountered. This includes both errors in accessing the directory contents and
    errors specifically related to individual files or directories within those paths.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**错误处理**：在遍历目录时，该函数处理遇到的任何错误。这包括访问目录内容时的错误以及与特定文件或目录相关的错误。'
- en: '**File organization based on extension**: For each file encountered (non-directory),
    the function organizes it into a new directory based on its file extension. This
    involves file organization based on extension. The function takes a detailed approach
    to organize files (excluding directories) by their extension. This process involves
    extracting the file extension, creating a new directory for each unique extension
    (if one doesn’t already exist), and moving the file into its newly designated
    directory. This systematic organization makes file management more intuitive and
    accessible.'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**基于扩展名的文件组织**：对于遇到的每个文件（非目录），该函数根据其文件扩展名将其组织到新的目录中。这涉及到基于扩展名的文件组织。该函数采用详细的方法通过扩展名对文件（排除目录）进行组织。这个过程包括提取文件扩展名，为每个唯一的扩展名创建一个新的目录（如果尚未存在），并将文件移动到其新指定的目录中。这种系统化的组织使文件管理更加直观和易于访问。'
- en: 'Recording actions: The function records all the file movements it performs.
    Each action of moving a file from its original location to the new directory based
    on its extension is recorded as a string in the events slice.'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录操作：该函数记录它执行的所有文件移动。每个将文件从原始位置移动到基于其扩展名的新目录的操作都被记录在事件切片中的字符串。
- en: 'Returning results: After processing all paths, the function returns two values:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回结果：处理完所有路径后，该函数返回两个值：
- en: A slice of strings (events), each describing an action taken on a file
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串切片（事件），每个描述对文件执行的操作
- en: An error value, which is nil if no errors were encountered or the last error
    that occurred during the processing of the paths
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个错误值，如果没有遇到错误则为 nil，或者在处理路径过程中发生的最后一个错误
- en: 'Let’s test this function! Once we are manipulating files, we can use a helper
    function to help us deal with code repetition:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试这个函数！一旦我们开始操作文件，我们可以使用一个辅助函数来帮助我们处理代码重复：
- en: '[PRE2]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This helper function creates a temporary file with a given extension. A neat
    detail of the `CreateTemp` function is when the string pattern includes a `"*"`
    and the random string replaces the last `"*"`. For example, if the ext is “.txt”
    the filename will be something like “1217776936.txt”.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此辅助函数创建一个具有给定扩展名的临时文件。`CreateTemp` 函数的一个巧妙细节是当字符串模式包含一个 `"*"` 并且随机字符串替换最后一个
    `"*"` 时。例如，如果扩展名是 “.txt”，则文件名可能是“1217776936.txt”。
- en: Look at the complete code of the tests for `"success"`, `"empty path"`, and
    `"invalid path"` in the git repository.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 git 仓库中针对 `"success"`、`"empty path"` 和 `"invalid path"` 的测试完整代码。
- en: 'When reading from the storage, for a `/temp` path, we need to inform the program
    as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当从存储读取时，对于 `/temp` 路径，我们需要按如下方式通知程序：
- en: '[PRE3]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, we need to discover where the device is mounted for the flash drive.
    One way to do it manually is by using the `df -h` command, and the output will
    show multiple lines. Still, we’re interested in a line quite like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要发现设备挂载在闪存驱动器的哪个位置。一种手动执行的方法是使用 `df -h` 命令，输出将显示多行。尽管如此，我们感兴趣的行大致如下：
- en: '[PRE4]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Feeling overwhelmed by the output? Let’s understand what’s happening:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 感到输出令人不知所措？让我们了解正在发生的事情：
- en: '`/dev/sdc1`: This field represents the device or block device corresponding
    to the mounted filesystem. In this case, `/dev/sdc1` is the device associated
    with the filesystem.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dev/sdc1`：此字段表示与挂载的文件系统相对应的设备或块设备。在这种情况下，`/dev/sdc1` 是与文件系统关联的设备。'
- en: '`15G`: This field shows the total size of the filesystem, which is 15 gigabytes
    (GB) in this example.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`15G`：此字段显示文件系统的总大小，在此示例中为 15 兆字节（GB）。'
- en: '`16M`: This field displays the space used on the filesystem. Here, it indicates
    that 16 megabytes (MB) of disk space are currently in use.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`16M`：此字段显示文件系统上使用的空间。在这里，它表示当前有 16 兆字节（MB）的磁盘空间被使用。'
- en: '`15G`: This field represents the available disk space on the filesystem. In
    this case, there are 15 gigabytes of free space.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`15G`：此字段表示文件系统上的可用磁盘空间。在这种情况下，有 15 兆字节（MB）的空闲空间。'
- en: '`1%`: This field shows the percentage of disk space used. Only 1% of the total
    filesystem space is occupied in this example.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1%`：此字段显示磁盘空间的使用百分比。在此示例中，只有 1% 的总文件系统空间被占用。'
- en: '`/media/alexrios/usbtest`: This field is the mount point of the filesystem.
    It indicates where the filesystem is mounted in the directory hierarchy. In this
    case, the filesystem is mounted at `/media/alexrios/usbtest`.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/media/alexrios/usbtest`：此字段是文件系统的挂载点。它表示文件系统在目录层次结构中的挂载位置。在这种情况下，文件系统挂载在
    `/media/alexrios/usbtest`。'
- en: Since a device could have multiple mount points (partitions) in the same flash
    drive, we will access this information programmatically by reading the `/``proc/mounts`
    file.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一个设备在同一闪存驱动器中可能有多个挂载点（分区），我们将通过读取 `/proc/mounts` 文件以编程方式访问此信息。
- en: The /proc/mounts file
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`/proc/mounts` 文件'
- en: The `/proc/mounts` file is a special file in the Linux operating system that
    provides a real-time, dynamic view of the currently mounted filesystems.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`/proc/mounts` 文件是 Linux 操作系统中的一个特殊文件，它提供了当前挂载的文件系统的实时、动态视图。'
- en: 'Here’s what you can find in the `/proc/mounts` file and what each field represents:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `/proc/mounts` 文件中可以找到以下内容以及每个字段代表的意义：
- en: 'Device or UUID: The first field usually represents the block device or `/dev/sda1`
    or `UUID=12345678-1234-5678-90ab-cdef01234567`.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备或 UUID：第一个字段通常表示块设备或 `/dev/sda1` 或 `UUID=12345678-1234-5678-90ab-cdef01234567`。
- en: 'Mount point: The second field shows the directory where the filesystem is mounted.
    This is the location in the filesystem hierarchy where you can access the contents
    of the mounted device.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂载点：第二个字段显示文件系统挂载的目录。这是文件系统层次结构中可以访问挂载设备内容的位置。
- en: 'Filesystem type: The third field specifies the type of filesystem mounted on
    the given mount point. Common examples include `ext4`, `ntfs`, `tmpfs`, `nfs`,
    and many others.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统类型：第三个字段指定挂载点上的文件系统类型。常见的例子包括 `ext4`、`ntfs`、`tmpfs`、`nfs` 以及许多其他类型。
- en: 'Mount options: The fourth field lists the mount options for mounting the filesystem.
    These options control various aspects of how the filesystem behaves. Common options
    include `rw` (read-write), `ro` (read-only), `noexec`, `nosuid`, and more.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂载选项：第四个字段列出了挂载文件系统的挂载选项。这些选项控制文件系统行为的各个方面。常见的选项包括 `rw`（读写）、`ro`（只读）、`noexec`、`nosuid`
    等。
- en: 'Dump flag: The fifth field is typically either `0` or `1` and indicates whether
    the filesystem should be backed up using the dump command. A value of `0` means
    no backup, and `1` means it should be included in backups.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出标志：第五字段通常是`0`或`1`，表示是否应该使用dump命令备份文件系统。`0`表示不备份，而`1`表示应该包含在备份中。
- en: 'Filesystem check order: The sixth field is used by the `fsck` utility to determine
    the order in which filesystems should be checked during system startup. A value
    of `0` means no automatic filesystem checks.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统检查顺序：第六字段由`fsck`实用程序使用，以确定在系统启动期间应检查文件系统的顺序。`0`表示没有自动文件系统检查。
- en: The `/proc/mounts` file provides a convenient way for users and system utilities
    to examine the current state of mounted filesystems on a Linux system. Various
    system management tools, scripts, and administrators often use them to gather
    information about mounted devices and their configurations.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`/proc/mounts`文件为用户和系统实用程序提供了一个方便的方式来检查Linux系统上挂载的文件系统的当前状态。各种系统管理工具、脚本和管理员经常使用它们来收集有关挂载设备和其配置的信息。'
- en: /proc/mounts
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: /proc/mounts
- en: This is not an actual file on your disk but rather a virtual file that the Linux
    kernel generates and updates to reflect the current state of mounted filesystems.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是磁盘上的实际文件，而是一个由Linux内核生成并更新以反映挂载的文件系统当前状态的虚拟文件。
- en: Reading the files on the flash drive
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取闪存驱动器上的文件
- en: It’s time to read `/proc/mounts` to read the mount point and discover where
    our program will read the files.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是读取`/proc/mounts`以读取挂载点并发现程序将读取文件的位置。
- en: 'This is the program idea: listing all files on a device that is mounted on
    your system. Also, it should take a device path as an input parameter, verify
    the path, read mounted filesystems from `/proc/mounts`, and then list all files
    for the specified device. Let’s break down the code step by step, highlighting
    the key snippets for each part.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的想法：列出系统上挂载的设备上的所有文件。此外，它应该接受一个设备路径作为输入参数，验证路径，从`/proc/mounts`读取挂载的文件系统，然后列出指定设备上的所有文件。让我们一步一步地分解代码，突出每个部分的关键片段。
- en: '**Step 1: Reading the first parameter as** **a path**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**第1步：读取第一个参数作为** **路径**'
- en: '[PRE5]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this initial step, the program reads the first command-line argument as the
    path of the device. It then checks whether the provided path starts with `/dev/`
    to ensure it’s a valid device path. If the path doesn’t match the criteria, the
    program prints an error message and exits.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个初始步骤中，程序读取第一个命令行参数作为设备的路径。然后检查提供的路径是否以`/dev/`开头，以确保它是一个有效的设备路径。如果路径不符合标准，程序将打印错误信息并退出。
- en: '**Step 2: Opening and** **reading /proc/mounts**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**第2步：打开和** **读取 /proc/mounts**'
- en: '[PRE6]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The program opens the `/proc/mounts` file to read the list of mounted filesystems.
    If there’s an error opening the file, it prints the error and exits. The `defer`
    statement ensures that the file is closed once all operations on the file are
    completed, preventing resource leaks.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 程序打开`/proc/mounts`文件以读取挂载的文件系统列表。如果打开文件时发生错误，它将打印错误信息并退出。`defer`语句确保在完成所有文件操作后关闭文件，防止资源泄露。
- en: '**Step 3: Scanning** **through /proc/mounts**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**第3步：扫描** **/proc/mounts**'
- en: '[PRE7]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using a scanner, the program reads each line from `/proc/mounts`. It splits
    each line into fields, where the first field is the device, and the second field
    is its mount point. This step is crucial for identifying the mount point of the
    device specified by the user.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用扫描器，程序从`/proc/mounts`读取每一行。它将每一行分割成字段，其中第一个字段是设备，第二个字段是其挂载点。这一步对于识别用户指定的设备的挂载点至关重要。
- en: '**Step 4: Matching the device and** **listing files**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**第4步：匹配设备并** **列出文件**'
- en: '[PRE8]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If the device from `/proc/mounts` matches the path provided by the user, the
    program then corrects any space encoding in the mount point path and announces
    the device and its mount point. It uses `filepath.Walk` to traverse the filesystem
    starting from the mount point, listing all files. If an error occurs during traversal,
    it prints the error.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`/proc/mounts`中的设备与用户提供的路径匹配，程序将纠正挂载点路径中的任何空格编码，并宣布设备及其挂载点。它使用`filepath.Walk`从挂载点开始遍历文件系统，列出所有文件。如果在遍历过程中发生错误，它将打印错误信息。
- en: '**Step 5: Handling** **scanner errors**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**第5步：处理** **扫描器错误**'
- en: '[PRE9]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After completing the scan of `/proc/mounts`, the program checks for any errors
    that might have occurred during the scanning process and reports them. This ensures
    that any issues encountered while reading the file are acknowledged and handled
    appropriately.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 完成对 `/proc/mounts` 的扫描后，程序会检查扫描过程中可能发生的任何错误，并将它们报告出来。这确保了在读取文件时遇到的任何问题都会得到认可和处理。
- en: Pay close attention to the `mountPoint = strings.ReplaceAll(mountPoint, "\\040",
    " ")` line. This is necessary to handle a specific formatting convention in the
    `/proc/mounts` file on Unix-like systems.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细关注 `mountPoint = strings.ReplaceAll(mountPoint, "\\040", " ")` 这一行。这在处理 Unix-like
    系统上 `/proc/mounts` 文件中的特定格式化约定时是必要的。
- en: In `/proc/mounts`, which lists all mounted filesystems, spaces in file paths
    (common in mount points) are represented by the `\040` escape sequence. The file
    uses a space character to delimit different fields in each line. For instance,
    a mount point path such as `/media/My Drive` would be represented as `/media/My\040Drive`
    in `/proc/mounts`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `/proc/mounts` 中，它列出了所有挂载的文件系统，文件路径中的空格（在挂载点中很常见）由 `\040` 转义序列表示。该文件使用空格字符来分隔每行的不同字段。例如，挂载点路径
    `/media/My Drive` 在 `/proc/mounts` 中表示为 `/media/My\040Drive`。
- en: Partitions versus blocks versus devices versus disks
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分区与块与设备与磁盘
- en: In system programming and hardware automation, managing storage efficiently
    is crucial. To navigate this subject effectively, we should understand the fundamental
    concepts of partitions, blocks, devices, and disks.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统编程和硬件自动化中，有效地管理存储至关重要。为了有效地掌握这个主题，我们应该了解分区、块、设备和磁盘的基本概念。
- en: Partitions – dividing storage
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分区 – 划分存储
- en: 'A partition is a logical division of a physical storage device, such as a hard
    drive or SSD. Partitions are created to segment a single physical device into
    multiple isolated sections, each functioning as an independent storage unit. These
    divisions serve several purposes:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 分区是物理存储设备（如硬盘或 SSD）的逻辑划分。创建分区是为了将单个物理设备分割成多个独立的区域，每个区域作为一个独立的存储单元运行。这些划分有以下几个目的：
- en: '**Operating system isolation**: Partitions enable the installation of different
    operating systems on a single physical disk, allowing users to choose between
    them during boot'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统隔离**：分区允许在单个物理磁盘上安装不同的操作系统，使用户在启动时可以选择它们。'
- en: '**Data organization**: Partitions help separate user data from system data,
    facilitating efficient data management and backups'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据组织**：分区有助于将用户数据与系统数据分开，便于高效的数据管理和备份。'
- en: '**Security**: Isolating data on separate partitions can enhance security by
    limiting access to specific sections of the storage device'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：在单独的分区上隔离数据可以通过限制对存储设备特定部分的访问来增强安全性'
- en: Blocks – fixed-sized storage units
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 块 – 固定大小的存储单元
- en: 'Blocks are fixed-sized units of data used for storage and retrieval on storage
    devices. Storage devices, including hard drives and SSDs, are organized into blocks,
    each typically having a predefined size, such as 512 bytes or 4 KB. Key aspects
    of blocks include the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 块是用于在存储设备上存储和检索数据的固定大小数据单元。包括硬盘和 SSD 在内的存储设备被组织成块，每个块通常具有预定义的大小，如 512 字节或 4
    KB。块的关键方面包括以下内容：
- en: '**Data handling**: Operating systems interact with storage devices by reading
    and writing data in blocks. This block-based approach ensures data consistency
    and efficient I/O operations.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据处理**：操作系统通过在块中读取和写入数据与存储设备交互。这种基于块的策略确保了数据的一致性和高效的 I/O 操作。'
- en: '**Filesystem management**: Filesystems manage data within these blocks, keeping
    track of which blocks are allocated to specific files and directories.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件系统管理**：文件系统在这些块中管理数据，跟踪哪些块分配给了特定的文件和目录。'
- en: '**Optimizing storage**: Using fixed-sized blocks allows for the efficient use
    of storage space and minimizes fragmentation.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化存储**：使用固定大小的块可以有效地利用存储空间并最小化碎片化。'
- en: Devices – the physical or virtual storage media
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设备 – 物理或虚拟存储媒体
- en: 'In the context of system programming and hardware automation, a device refers
    to either a physical storage device, such as a hard drive or SSD, or a virtual
    device represented by software. Devices can be seen as the interface through which
    the operating system and applications interact with storage resources. Key aspects
    include the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统编程和硬件自动化的背景下，设备指的是物理存储设备（如硬盘或 SSD）或由软件表示的虚拟设备。设备可以看作是操作系统和应用程序与存储资源交互的接口。以下是一些关键方面：
- en: '**Physical and virtual devices**: Devices can be physical hardware components
    connected to a computer or virtual representations created by software layers'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理和虚拟设备**：设备可以是连接到计算机的物理硬件组件，或由软件层创建的虚拟表示'
- en: '**Device identification**: Detecting and identifying storage devices are crucial
    tasks in hardware automation, allowing for device initialization and maintenance'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备识别**：检测和识别存储设备是硬件自动化的关键任务，允许进行设备初始化和维护'
- en: '**Resource allocation**: Managing devices includes tasks such as assigning
    device drivers, handling device failures, and ensuring efficient data access'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源分配**：管理设备包括分配设备驱动程序、处理设备故障和确保高效数据访问的任务'
- en: Disks – the storage hardware
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 磁盘 – 存储硬件
- en: 'Disks, a term often used interchangeably with storage devices, are the physical
    hardware components responsible for data storage. These can be **hard disk drives**
    (**HDDs**), **solid-state drives** (**SSDs**), optical drives, or **network-attached
    storage** (**NAS**) devices. Key aspects include the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘，一个经常与存储设备互换使用的术语，是负责数据存储的物理硬件组件。这些可以是**硬盘驱动器**（**HDDs**）、**固态驱动器**（**SSDs**）、光盘驱动器或**网络附加存储**（**NAS**）设备。关键方面包括以下内容：
- en: '**Types of disks**: Various types of disks are available, each with its unique
    characteristics, including capacity, speed, and durability'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**磁盘类型**：各种类型的磁盘可供选择，每种磁盘都有其独特的特性，包括容量、速度和耐用性'
- en: '**Storage capacity**: Disks provide the storage capacity required for storing
    data, applications, and operating systems'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储容量**：磁盘提供了存储数据、应用程序和操作系统的所需存储容量'
- en: '**Performance**: Different types of disks offer varying levels of performance,
    impacting data access speeds and overall system responsiveness'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：不同类型的磁盘提供不同级别的性能，影响数据访问速度和整体系统响应速度'
- en: We still want to know when the flash drive was inserted into the USB and act
    (organize the files). Do we have a standardized way to do that? Fortunately, yes!
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然想知道闪存盘何时被插入USB并采取行动（组织文件）。我们是否有标准化的方法来做这件事？幸运的是，有！
- en: Open source to the rescue!
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开源拯救！
- en: In the dynamic and ever-evolving landscape of Linux, a story of collaboration
    and innovation unfolded with the emergence of XDG and freedesktop.org.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux动态且不断演变的领域中，随着XDG和freedesktop.org的出现，一个关于协作和创新的故事展开了。
- en: Birth of freedesktop.org
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: freedesktop.org的诞生
- en: In the spring of 2000, a new chapter began with Havoc Pennington and his vision.
    Recognizing the fragmented state of the Linux desktop environment, he established
    freedesktop.org. It wasn’t just another organization; it was a beacon of collaboration,
    inviting developers from GNOME, KDE, and other projects to join hands. Their mission?
    To weave a tapestry of interoperability and shared technology across different
    desktop environments.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 2000年春天，随着Havoc Pennington和他的愿景，一个新的篇章开始了。他认识到Linux桌面环境的碎片化状态，因此建立了freedesktop.org。这不仅仅是一个组织；它是一个合作的灯塔，邀请GNOME、KDE和其他项目的开发者携手合作。他们的使命是什么？在各个桌面环境之间编织一个互操作性共享技术的锦缎。
- en: XDG – the standard bearer
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XDG – 标准的旗手
- en: Parallel to this, the **X Desktop Group** (**XDG**) emerged, focusing on crafting
    standards that would serve as bridges between the diverse desktop environments.
    They weren’t just creating guidelines; they were building the lingua franca for
    the Linux desktop world. Their contributions, such as the XDG Base Directory and
    Desktop Menu Specifications, were like puzzle pieces that fit perfectly, bringing
    a sense of order and compatibility to the once-chaotic landscape.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，**X桌面小组**（**XDG**）出现了，专注于制定将成为不同桌面环境之间桥梁的标准。他们不仅仅是创建指南；他们正在构建Linux桌面世界的通用语言。他们的贡献，如XDG基本目录和桌面菜单规范，就像完美拼凑的拼图碎片，为曾经混乱的景象带来了秩序和兼容性。
- en: A symphony of collaboration
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协作交响曲
- en: What set freedesktop.org and XDG apart was their approach. They didn’t dictate;
    they collaborated. They listened and adapted, creating solutions that resonated
    across various platforms. This wasn’t just about technology but about people,
    ideas, and the magic that happens when they come together.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: freedesktop.org和XDG与众不同的地方在于他们的方法。他们没有发号施令；他们进行了合作。他们倾听并适应，创造了在各种平台上产生共鸣的解决方案。这不仅仅关乎技术，还关乎人、思想和当它们聚集在一起时产生的魔力。
- en: In this tale of unity, XDG and freedesktop.org stand as beacons, illuminating
    the path toward a more integrated and user-friendly Linux experience. Their legacy
    is not just in the code and standards they’ve created, but in the spirit of cooperation
    they’ve fostered in the open source community.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个统一的传说中，XDG和freedesktop.org作为灯塔，照亮了通往更集成和用户友好的Linux体验的道路。它们的遗产不仅在于他们创建的代码和标准，还在于他们在开源社区中培养的合作精神。
- en: 'To achieve our goal, we’re using one of the core components of freedesktop.org:
    D-Bus.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的目标，我们正在使用freedesktop.org的核心组件之一：D-Bus。
- en: D-Bus – the communication conduit
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D-Bus – 通信通道
- en: D-Bus, another brainchild nurtured in the ecosystem of freedesktop.org, is a
    message bus system that provides a simple way for applications to talk to one
    another and to the system. It’s like the postal service of the Linux world, delivering
    messages between applications, ensuring they can work together harmoniously.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: D-Bus，freedesktop.org生态系统中孕育的另一个产物，是一个消息总线系统，为应用程序之间以及与系统之间的通信提供了一种简单的方式。它就像Linux世界的邮政服务，在应用程序之间传递消息，确保它们可以和谐地一起工作。
- en: 'Before we interact with USB events, let’s dip a toe in the water with a simpler
    example: sending system notifications.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们与USB事件交互之前，让我们先从一个更简单的例子开始：发送系统通知。
- en: 'First, we need to add the import of the `dbus` library, `github.com/godbus/dbus/v5`,
    after we should connect to the session bus and make sure that we’re deferring
    the release of the resources:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要添加`dbus`库的导入，`github.com/godbus/dbus/v5`，之后我们应该连接到会话总线并确保我们正在延迟释放资源：
- en: '[PRE10]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Look at the notification’s specification ([https://specifications.freedesktop.org/notification-spec/notification-spec-latest.html](https://specifications.freedesktop.org/notification-spec/notification-spec-latest.html))
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 查看通知的规范([https://specifications.freedesktop.org/notification-spec/notification-spec-latest.html](https://specifications.freedesktop.org/notification-spec/notification-spec-latest.html))
- en: 'Now we need to use the connection to access the notification object to make
    a call for it:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要使用连接来访问通知对象以对其进行调用：
- en: '[PRE11]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As we can see in the notification specification, the parameters are as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在通知规范中可以看到的，参数如下：
- en: '| **Name** | **Type** | **Required** | **Description** |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **类型** | **必需** | **描述** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `app_name` | `STRING` | False | The name of the application sending the notification.
    Can be blank. |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `app_name` | `STRING` | False | 发送通知的应用程序名称。可以是空白。 |'
- en: '| `replaces_id` | `UINT32` | False | The notification ID that this notification
    replaces. A value of `0` means that this notification won’t replace existing notifications.
    |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `replaces_id` | `UINT32` | False | 此通知替换的通知ID。值为`0`表示此通知不会替换现有通知。 |'
- en: '| `app_icon` | `STRING` | False | The program icon of the calling application.
    Can be an empty string, indicating no icon. |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| `app_icon` | `STRING` | False | 调用应用程序的程序图标。可以是空字符串，表示没有图标。 |'
- en: '| `summary` | `STRING` | True | The summary text briefly describing the notification.
    |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| `summary` | `STRING` | True | 简要描述通知的摘要文本。 |'
- en: '| `body` | `STRING` | False | The detailed body text. Can be empty. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `body` | `STRING` | False | 详细正文。可以是空的。 |'
- en: '| `actions` | `as` (array of strings) | False | Actions that are sent as a
    list of pairs. Each even element in the list (starting at index 0) represents
    the identifier for the action. Each odd element is the localized string that will
    be displayed to the user. |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `actions` | `as` (字符串数组) | False | 以成对列表形式发送的操作。列表中的每个偶数元素（从索引0开始）代表操作的标识符。每个奇数元素是显示给用户的本地化字符串。
    |'
- en: '| `hints` | `a{sv}` (array of string-variant pairs) | False | Hints that can
    be passed to the server from the client program. They can pass along information,
    such as the process PID or window ID. Can be empty. |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `hints` | `a{sv}` (字符串-变体对数组) | False | 可以从客户端程序传递给服务器的提示。它们可以传递信息，例如进程PID或窗口ID。可以是空的。
    |'
- en: '| `expire_timeout` | `INT32` | True | The timeout time in milliseconds from
    the display of the notification, at which the notification should automatically
    close. |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `expire_timeout` | `INT32` | True | 从通知显示开始，通知应自动关闭的毫秒超时时间。 |'
- en: 'Here’s what each variable represents and how it affects the notification:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这里每个变量代表什么以及它如何影响通知：
- en: '`appName := "Organizer"`: `appName` specifies the name of the application sending
    the notification. In this case, the notification will appear to come from an application
    named “Super App.”'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appName := "Organizer"`: `appName`指定发送通知的应用程序名称。在这种情况下，通知将显示为来自名为“Super App”的应用程序。'
- en: '`replacesID := uint32(0)`: `replacesID` is used to replace an existing notification.
    A value of `0` means this new notification will not replace any existing notification.
    If it were a non-zero value, it would attempt to replace a notification with that
    ID.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replacesID := uint32(0)`: `replacesID` 用于替换现有的通知。值为 `0` 表示这个新的通知不会替换任何现有的通知。如果是一个非零值，它将尝试替换具有该ID的通知。'
- en: '`appIcon := "view-refresh"`: `appIcon` specifies the icon of the application
    sending the notification. An empty string `""` indicates that no icon will be
    used. If a path or icon name were provided, it would display that icon with the
    notification.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appIcon := "view-refresh"`: `appIcon` 指定发送通知的应用程序的图标。一个空字符串 `""` 表示不会使用任何图标。如果提供了路径或图标名称，它将显示与通知一起的该图标。'
- en: '`summary := "Organizer is done!"`: `summary` is a brief text that describes
    the notification. In this case, the summary is “Organizer is done!”, which will
    likely be shown as the title or headline of the notification.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`summary := "Organizer is done!"`: `summary` 是描述通知的简短文本。在这种情况下，摘要为“Organizer
    is done!”，这很可能会作为通知的标题或标题显示。'
- en: '`body := fmt.Sprintf("The files at %s were successfully organized.", "/dev/sdc")`:
    `body` is the detailed text of the notification, providing more information.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body := fmt.Sprintf("The files at %s were successfully organized.", "/dev/sdc")`:
    `body` 是通知的详细文本，提供了更多信息。'
- en: '`actions := []string{}`: `actions` are used to define interactive elements
    or buttons in the notification. An empty `[]string{}` slice means no actions or
    buttons will be added to the notification.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`actions := []string{}`: `actions` 用于定义通知中的交互元素或按钮。一个空的 `[]string{}` 切片表示不会添加任何操作或按钮到通知中。'
- en: '`hints := map[string]dbus.Variant{}`: `hints` are additional properties or
    data that can be used to modify the appearance or behavior of the notification.
    An empty `map[string]dbus.Variant{}` map implies that no additional hints are
    provided. Hints can include things such as a sound file to play, urgency level,
    and so on.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hints := map[string]dbus.Variant{}`: `hints` 是可以用来修改通知外观或行为的附加属性或数据。一个空的 `map[string]dbus.Variant{}`
    映射表示没有提供额外的提示。提示可以包括播放的声音文件、紧急程度等级等。'
- en: '`expireTimeout := int32(5000)`: `expireTimeout` specifies the duration (in
    milliseconds) before the notification automatically closes. A value of `5000`
    means the notification will close after five seconds. A value of `-1` would mean
    the notification’s expiration depends on the notification server’s settings, and
    `0` would mean the notification never expires automatically.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expireTimeout := int32(5000)`: `expireTimeout` 指定了通知自动关闭前的时间（以毫秒为单位）。值为 `5000`
    表示通知将在五秒后关闭。值为 `-1` 表示通知的过期取决于通知服务器的设置，而 `0` 表示通知永远不会自动过期。'
- en: App icons
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 应用图标
- en: You can find more about app icons on the specification page ([https://specifications.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html](https://specifications.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html)).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在规范页面上找到更多关于应用图标的信息（[https://specifications.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html](https://specifications.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html)）。
- en: 'Lastly, we call the object:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用对象：
- en: '[PRE12]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the `usb/example2` directory, we run the program by executing the following:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `usb/example2` 目录中，我们通过执行以下命令来运行程序：
- en: '[PRE13]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A new system notification will pop up on the screen! That’s cool, huh?
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上会弹出一个新的系统通知！这很酷，不是吗？
- en: Interacting with USB events
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与USB事件交互
- en: We already have a way to organize the flash drive with the file extension, a
    function to discover the file mount, and a way to notify the user of the task’s
    completion. Now, we are ready to interact with the system event triggered when
    a new flash drive is connected.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了通过文件扩展名组织闪存驱动器的方法，一个发现文件挂载的功能，以及通知用户任务完成的方式。现在，我们准备与连接新闪存驱动器时触发的系统事件交互。
- en: 'Once again, we need to use the `dbus` package:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们需要使用 `dbus` 包：
- en: '[PRE14]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We need to connect to the bus:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要连接到总线：
- en: '[PRE15]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Since we’re interested in listening to the D-Bus events, we need to give the
    D-Bus connection a way to notify our program. We do that with a channel of type
    `*dbus.Signal`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们感兴趣的是监听D-Bus事件，我们需要给D-Bus连接提供一个通知我们程序的方式。我们通过一个类型为 `*dbus.Signal` 的通道来实现这一点：
- en: '[PRE16]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Remember, we’re not interested in all signals available in the bus; we just
    want the event representing the USB device being inserted. In our case, the signal
    name is `"org.freedesktop.DBus.ObjectManager.InterfacesAdded"`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们感兴趣的并不是总线上的所有信号；我们只想得到表示USB设备插入的事件。在我们的例子中，信号名称是 `"org.freedesktop.DBus.ObjectManager.InterfacesAdded"`。
- en: 'In D-Bus, we have a special entity to do that. It’s called a match rule:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在D-Bus中，我们有一个特殊的实体来做这件事。它被称为匹配规则：
- en: '`matchRule := "``type=''signal'',sender=''org.freedesktop.UDisks2'',interface=''org.freedesktop.DBus.ObjectManager'',path=''/org/freedesktop/UDisks2''"`'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`matchRule := "``type=''signal'',sender=''org.freedesktop.UDisks2'',interface=''org.freedesktop.DBus.ObjectManager'',path=''/org/freedesktop/UDisks2''"`'
- en: 'In our program, `matchRule` is a string that defines a D-Bus match rule. The
    components of the match rule are as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序中，`matchRule`是一个字符串，用于定义D-Bus匹配规则。匹配规则的组成部分如下：
- en: '`type=''signal''`: Indicates that your program wants to listen for signals
    (as opposed to other types of D-Bus messages such as method calls or errors).'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type=''signal''`: 表示你的程序想要监听信号（与D-Bus消息的其他类型，如方法调用或错误不同）。'
- en: '`sender=''org.freedesktop.UDisks2''`: Specifies that the signals should come
    from `org.freedesktop.UDisks2`, which is the D-Bus service provided by UDisks2
    (a service for managing disk drives and related resources in Linux).'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sender=''org.freedesktop.UDisks2''`: 指定信号应来自`org.freedesktop.UDisks2`，这是UDisks2提供的D-Bus服务（一个用于管理Linux中磁盘驱动器和相关资源的服务）。'
- en: '`interface=''org.freedesktop.DBus.ObjectManager''`: Filters signals to those
    that are emitted by objects implementing the `org.freedesktop.DBus.ObjectManager`
    interface. This interface is used for managing and enumerating objects (such as
    disk drives, partitions, etc.) under a certain D-Bus service.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interface=''org.freedesktop.DBus.ObjectManager''`: 过滤由实现`org.freedesktop.DBus.ObjectManager`接口的对象发出的信号。此接口用于管理并枚举在特定D-Bus服务下的对象（如磁盘驱动器、分区等）。'
- en: '`path=''/org/freedesktop/UDisks2''`: Specifies the path of the objects from
    which signals should be received. This path corresponds to the UDisks2 service.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path=''/org/freedesktop/UDisks2''`: 指定应接收信号的对象的路径。此路径对应于UDisks2服务。'
- en: The following line uses the established D-Bus connection (`conn`) to call the
    `AddMatch` method on the D-Bus daemon. `AddMatch` is a method provided by D-Bus
    that tells the bus daemon to start forwarding the messages (signals, in this case)
    that match the given rule to your application.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行使用建立的D-Bus连接（`conn`）在D-Bus守护进程上调用`AddMatch`方法。`AddMatch`是D-Bus提供的方法，告诉总线守护进程开始转发匹配给定规则的消息（在这种情况下是信号）到你的应用程序。
- en: '[PRE17]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The details are as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 详细情况如下：
- en: '`conn.BusObject()`: Retrieves a proxy object for communicating with the bus
    daemon itself'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conn.BusObject()`: 获取与总线守护进程本身通信的代理对象'
- en: '`.Call(...)`: Calls a method on the bus daemon'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.Call(...)`: 在总线守护进程上调用方法'
- en: '`"org.freedesktop.DBus.AddMatch"`: The method used to tell the D-Bus system’s
    central service to only send messages that meet specific criteria to the application
    calling this method'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"org.freedesktop.DBus.AddMatch"`: 用于告诉D-Bus系统的中央服务只向调用此方法的程序发送满足特定标准的消息的方法'
- en: '`0`: The flag for the method call, usually set to `0` in typical use cases'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`: 方法调用的标志，在典型用例中通常设置为`0`'
- en: '`matchStr`: The match rule defined earlier, passed as an argument to the method'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`matchStr`: 之前定义的匹配规则，作为方法的参数传递'
- en: In the following code is a loop that listens for specific D-Bus signals and
    handles them accordingly. It is particularly focused on signals related to new
    interfaces being added in UDisks2, which is a service for managing disk drives
    in Linux.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中有一个循环，用于监听特定的D-Bus信号并相应地处理它们。它特别关注与UDisks2中添加的新接口相关的信号，UDisks2是一个用于管理Linux中磁盘驱动器的服务。
- en: Let’s break down the code step by step.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地分解代码。
- en: '**Step 1 – Listening** **for signals**:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 1 – 监听信号**：'
- en: '[PRE18]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This `for` loop iterates over a channel (`ch`) that receives D-Bus signals.
    Each item received over the channel is a `signal`, representing a D-Bus signal
    that has been sent to your application.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`for`循环遍历接收D-Bus信号的通道（`ch`）。通过通道接收到的每个项目都是一个`signal`，代表已发送到你的应用程序的D-Bus信号。
- en: '**Step 2 – Checking** **signal name**:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 2 – 检查信号名称**：'
- en: '[PRE19]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The code checks whether the signal’s name is `"org.freedesktop.DBus.ObjectManager.InterfacesAdded"`.
    This signal is emitted when a new interface (such as a new block device) is added
    to the object manager in UDisks2.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 代码检查信号的名称是否为`"org.freedesktop.DBus.ObjectManager.InterfacesAdded"`。当在UDisks2的对象管理器中添加新接口（如新的块设备）时，会发出此信号。
- en: '**Step 3 – Extracting the** **object path**:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 3 – 提取对象路径**：'
- en: '[PRE20]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This line extracts the first element of the signal’s body, which should be the
    object path of the newly added interface. The object path identifies the specific
    object (such as a disk or partition) within UDisks2.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码提取了信号主体的第一个元素，应该是新添加接口的对象路径。对象路径标识了UDisks2中特定的对象（如磁盘或分区）。
- en: '**Step 4 – Checking the** **path prefix**:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 4 – 检查** **路径前缀**：'
- en: '[PRE21]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The code checks whether the path of the new interface starts with `"/org/freedesktop/UDisks2/block_devices/"`.
    This prefix indicates that the interface is a block device, such as a hard drive
    or USB flash drive.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 代码检查新接口的路径是否以 `"/org/freedesktop/UDisks2/block_devices/"` 开头。这个前缀表示该接口是一个块设备，例如硬盘或USB闪存驱动器。
- en: '**Step 5 – Accessing** **device properties**:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 5 – 访问** **设备属性**：'
- en: '[PRE22]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If the path matches, the code proceeds to interact with that specific device.
    It does so by calling the `org.freedesktop.DBus.Properties.Get` method on the
    device object to get its properties. The properties of interest are from the `"org.freedesktop.UDisks2.Block"`
    interface, specifically the `"``Device"` property.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果路径匹配，代码将继续与该特定设备交互。它是通过在设备对象上调用 `org.freedesktop.DBus.Properties.Get` 方法来获取其属性来实现的。感兴趣的属性来自
    `"org.freedesktop.UDisks2.Block"` 接口，特别是 `"Device"` 属性。
- en: '**Step 6 –** **Error handling**:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 6 –** **错误处理**：'
- en: '[PRE23]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This checks whether there was an error in the method call to get the device
    properties. If there was an error, it prints an error message and continues to
    the next signal.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这检查了获取设备属性的方法调用中是否有错误。如果有错误，它将打印错误消息并继续到下一个信号。
- en: '**Step 7 – Printing** **mount points**:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 7 – 打印** **挂载点**：'
- en: '[PRE24]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This extracts the `Device` property from the response (`deviceProps.Body[0]`).
    The property is cast to the `dbus.Variant` type, which is a generic container
    for any D-Bus data type. The value is then printed out. This value typically represents
    the file path to the device node (such as `/dev/sda1` for a disk partition).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这从响应中提取 `Device` 属性 (`deviceProps.Body[0]`)。该属性被转换为 `dbus.Variant` 类型，这是一个用于任何
    D-Bus 数据类型的通用容器。然后打印出该值。此值通常表示设备节点的文件路径（例如磁盘分区的 `/dev/sda1`）。
- en: 'In the `appendix-a/usb/example4` directory, we execute the program:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `appendix-a/usb/example4` 目录中，我们执行程序：
- en: '[PRE25]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We should see the name as something like the following:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到类似以下的名字：
- en: '[PRE26]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To understand this output, we should make clear the difference between storage
    devices and partitions.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这个输出，我们应该明确存储设备和分区的区别。
- en: The difference between the `/dev/sdc` and `/dev/sdc1` outputs in Linux is related
    to how storage devices and their partitions are represented in the filesystem.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 中 `/dev/sdc` 和 `/dev/sdc1` 输出的区别与存储设备和其分区在文件系统中的表示方式有关。
- en: '`/dev/sdc` represents the entire physical storage device. In Linux (and other
    Unix-like operating systems), storage devices such as hard drives, SSDs, and USB
    flash drives are represented as files in the `/dev` directory. The name `sdc`
    is typically assigned based on the order in which the system recognizes the device
    (following `sda`, `sdb`, and so on).'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`/dev/sdc` 表示整个物理存储设备。在 Linux（以及其他类 Unix 操作系统）中，硬盘、SSD 和 USB 闪存驱动器等存储设备在 `/dev`
    目录中表示为文件。名称 `sdc` 通常根据系统识别设备的顺序分配（在 `sda`、`sdb` 等之后）。'
- en: When the program output shows `/dev/sdc`, it refers to the whole storage device,
    which includes all its partitions and data.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序输出显示 `/dev/sdc` 时，它指的是整个存储设备，包括其所有分区和数据。
- en: '`/dev/sdc1` represents a specific partition on the storage device. The number
    at the end (`1` in this case) signifies the first partition on the `sdc` device.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`/dev/sdc1` 表示存储设备上的一个特定分区。末尾的数字（本例中的 `1`）表示 `sdc` 设备上的第一个分区。'
- en: As we discussed earlier, partitions are subdivisions of a physical storage device.
    They allow you to segment the device into different sections, each of which can
    be formatted with a different filesystem or used for different purposes.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，分区是物理存储设备的细分。它们允许您将设备分割成不同的部分，每个部分都可以使用不同的文件系统格式化或用于不同的目的。
- en: In other words, `/dev/sdc1` is the first partition on the `/dev/sdc` storage
    device.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`/dev/sdc1` 是 `/dev/sdc` 存储设备上的第一个分区。
- en: 'In practical terms, the differences in accessing both are as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，访问两者的区别如下：
- en: Accessing `/dev/sdc` would be for operations that affect the entire disk, such
    as disk formatting, partitioning, and obtaining disk-wide information (such as
    total size, disk health, etc.)
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 `/dev/sdc` 将用于影响整个磁盘的操作，例如磁盘格式化、分区以及获取磁盘范围的信息（例如总大小、磁盘健康状态等）。
- en: Accessing `/dev/sdc1` would be for operations specific to that partition, such
    as mounting the partition to access its filesystem, checking the filesystem health,
    or formatting just that partition
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 `/dev/sdc1` 将用于针对该分区的特定操作，例如挂载分区以访问其文件系统、检查文件系统健康状态或仅格式化该分区。
- en: Keep in mind that the path we choose here is to inspect all partitions available.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们选择此路径是为了检查所有可用的分区。
- en: But wait! Since the D-Bus has the information on the partitions, it would be
    nice if we could access the mount point information from it instead of parsing
    the `/``proc/mounts` file.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！由于 D-Bus 有关于分区的信息，如果我们能从它那里访问挂载点信息而不是解析 `/proc/mounts` 文件，那就太好了。
- en: Fortunately, we can!
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以！
- en: 'Let’s look at how we can do that in our brand-new `mountPoints` function:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何在全新的 `mountPoints` 函数中做到这一点：
- en: '[PRE27]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here’s an explanation of how the function works:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是关于函数如何工作的解释：
- en: 'Connection to D-Bus: It starts by establishing a connection to the D-Bus system
    bus using `dbus.ConnectSystemBus()`. The system bus is used to interact with system-level
    services such as UDisks2\. If there’s an error in connecting to the system bus,
    it returns an error.'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到 D-Bus：它首先使用 `dbus.ConnectSystemBus()` 建立与 D-Bus 系统总线的连接。系统总线用于与系统级服务（如 UDisks2）交互。如果连接到系统总线时发生错误，它返回一个错误。
- en: 'Initialization: It initializes an empty `mountPoints` slice to store the mount
    points found for the provided devices.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化：它初始化一个空的 `mountPoints` 切片以存储为提供的设备找到的挂载点。
- en: 'Device name iteration: Using a `for` loop, the function then iterates through
    each device name in the `deviceNames` slice.'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备名称迭代：使用 `for` 循环，函数随后遍历 `deviceNames` 切片中的每个设备名称。
- en: 'D-Bus object path: For each device name, it constructs the D-Bus object path
    by joining it with the UDisks2 block device path. This is done using `path.Join("/org/freedesktop/UDisks2/block_devices",
    deviceName)`. This object path specifies the D-Bus object representing the block
    device with the given name.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: D-Bus 对象路径：对于每个设备名称，它通过将 UDisks2 块设备路径与之连接来构造 D-Bus 对象路径。这是通过 `path.Join("/org/freedesktop/UDisks2/block_devices",
    deviceName)` 实现的。此对象路径指定了代表具有给定名称的块设备的 D-Bus 对象。
- en: 'D-Bus object and method call: It creates a D-Bus object using `conn.Object`
    with the UDisks2 service name and the constructed object path. Then, it calls
    the `"org.freedesktop.DBus.Properties.GetAll"` D-Bus method on the object to retrieve
    all properties of the `"org.freedesktop.UDisks2.Filesystem"` interface. The result
    is stored in the result map.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: D-Bus 对象和方法调用：它使用 `conn.Object` 和 UDisks2 服务名称以及构造的对象路径创建一个 D-Bus 对象。然后，它调用对象上的
    `"org.freedesktop.DBus.Properties.GetAll"` D-Bus 方法来检索 `"org.freedesktop.UDisks2.Filesystem"`
    接口的所有属性。结果存储在结果映射中。
- en: 'Mount points extraction: The function checks whether the `"MountPoints"` property
    exists in the resulting map using `result["MountPoints"]`. If it exists, it extracts
    the mount points as a slice of byte slices (`[][]byte`) from the property.'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂载点提取：函数使用 `result["MountPoints"]` 检查结果映射中是否存在 `"MountPoints"` 属性。如果存在，它从属性中提取挂载点作为字节切片的切片
    (`[][]byte`)。
- en: 'Conversion to strings: It then iterates through the byte slices of mount points
    and converts them to strings. These strings represent the mount points of the
    device. The mount points are appended to the `mountPoints` slice.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换为字符串：然后它遍历挂载点的字节切片并将它们转换为字符串。这些字符串代表设备的挂载点。挂载点被追加到 `mountPoints` 切片中。
- en: 'Error handling: If no mount points were found for a device or if there was
    an error in the D-Bus method call, it returns an error indicating that no mount
    points were found.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理：如果没有找到设备的挂载点或 D-Bus 方法调用中发生错误，它返回一个错误，指示没有找到挂载点。
- en: 'Result return: Finally, if at least one mount point was found, the function
    returns the `mountPoints` slice containing all the mount points and nil as the
    error.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果返回：最后，如果至少找到一个挂载点，函数返回包含所有挂载点的 `mountPoints` 切片和 nil 作为错误。
- en: Now we know how to organize the files, listen to storage device events, and
    find the mount points. We are ready to glue all these things up.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何组织文件，监听存储设备事件，并找到挂载点。我们准备好将这些事情粘合在一起。
- en: The full functional example is available in the git repository. Try yourself
    to organize a messy flash drive!
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 完整功能示例可在 git 仓库中找到。试着整理一下混乱的闪存驱动器！
- en: Bluetooth
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝牙
- en: Imagine, if you will, a world where your trusty smartwatch does more than just
    count your steps or remind you of meetings. In this world, my Samsung Galaxy Watch
    Active 2 becomes the guardian of my workstation, a faithful ally ensuring that
    my data remains secure from the wandering eyes of overly curious colleagues. Yes,
    you read that right.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，在一个世界里，你那可靠的智能手表不仅仅能计数你的步数或提醒你会议。在这个世界里，我的 Samsung Galaxy Watch Active
    2 成为了我的工作站的保护者，一个忠诚的盟友，确保我的数据免受过于好奇的同事的窥视。是的，你没听错。
- en: Welcome to my journey of turning a simple wearable into a tool of ingenious
    workstation security.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到我将简单可穿戴设备变成巧妙工作站安全工具的旅程。
- en: 'There I was, sitting in my cubicle adorned with the obligatory tech paraphernalia,
    when a thought struck me. In an office where “snooping” is often disguised as
    “accidental glances,” could I not leverage my beloved smartwatch to enhance my
    workstation’s security? The mission was set: to lock my screen automatically whenever
    I stepped away, leaving my nosy colleagues to stare at a pristine lock screen.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 那时，我正坐在我的隔间里，隔间里装饰着必不可少的科技配件，突然一个想法闪过我的脑海。在一个“偷窥”常常伪装成“偶然一瞥”的办公室里，我能否利用我钟爱的智能手表来增强我的工作站的安全性？任务已经设定：当我离开时自动锁定我的屏幕，让好奇的同事们只能盯着一个干净的锁屏。
- en: The strategy was straightforward yet elegant. I would employ a program that
    diligently monitored the Bluetooth signal strength (RSSI) between my Linux machine
    and my smartwatch. Once the signal dipped below a certain threshold – a subtle
    hint that I’d abandoned my desk, possibly in pursuit of another coffee – the script
    would gallantly secure my workstation. Pure genius, isn’t it?
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 该策略简单而优雅。我会使用一个程序勤勉地监控我的Linux机器和我的智能手表之间的蓝牙信号强度（RSSI）。一旦信号下降到某个阈值以下——这是一个我可能已经离开办公桌、可能是在寻找另一杯咖啡的微妙暗示——脚本就会英勇地锁定我的工作站。纯粹的天才，不是吗？
- en: Detecting the smartwatch
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测智能手表
- en: 'The first step was simple. The following program will use the `github.com/muka/go-bluetooth/api`
    Bluetooth library:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步很简单。以下程序将使用`github.com/muka/go-bluetooth/api`蓝牙库：
- en: '[PRE28]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here’s how you can get the default Bluetooth adapter:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你可以获取默认蓝牙适配器的方法：
- en: '[PRE29]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With the adapter, let’s start the device discovery:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 使用适配器，让我们开始设备发现：
- en: '[PRE30]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can now start to retrieve and display device information:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始检索和显示设备信息：
- en: '[PRE31]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let’s examine this code snippet:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查这个代码片段：
- en: '`adapter.GetDevices()`:'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adapter.GetDevices()`:'
- en: This retrieves a list of discovered Bluetooth devices.
  id: totrans-396
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将检索到已发现的所有蓝牙设备列表。
- en: If it fails to retrieve the devices, an error is printed.
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果无法检索到设备，则会打印一条错误信息。
- en: The program then iterates (`for` loop) through each device.
  id: totrans-398
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序随后会迭代（`for`循环）遍历每个设备。
- en: '`device.GetProperties()`:'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device.GetProperties()`:'
- en: This obtains properties of each device, such as the name, address, and **received
    signal strength** **indicator** (**RSSI**).
  id: totrans-400
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将获取每个设备的属性，例如名称、地址和**接收信号强度** **指示器**（**RSSI**）。
- en: If fetching properties for a device fails, it prints an error message and continues
    with the next device.
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果获取设备的属性失败，它会打印一条错误消息并继续下一个设备。
- en: Lastly, it prints each device’s name, address, and RSSI. RSSI measures how well
    your device can hear a signal from an access point or router, which helps determine
    the distance from the device.
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，它打印出每个设备的名称、地址和RSSI。RSSI衡量你的设备能够从接入点或路由器接收信号的好坏，这有助于确定设备与之间的距离。
- en: Wait a minute! RSSI? What is that? Good question! Let’s explore this concept.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下！RSSI是什么？这是个好问题！让我们来探索这个概念。
- en: Understanding RSSI
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解RSSI
- en: Imagine RSSI as office gossip – you hear it loud and clear when you’re near
    the source (0 dB, the office rumor mill). Still, as you stroll away to your cubicle
    fortress, the details get fuzzier until they’re just whispers (-100 dB, practically
    the land of myths and legends). This RSSI, a creature of decibels, roams from
    0 (gossip central) to -100 (the realm of forgotten tales), with its strength varying
    based on which Bluetooth beast it rides – each with its quirks.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 将RSSI想象成办公室的八卦——当你靠近源头时（0 dB，办公室的谣言工厂），你会听到它清晰而响亮。然而，当你漫步到你的隔间堡垒时，细节会变得模糊，直到它们只是耳语（-100
    dB，几乎就是神话和传说的领域）。这个RSSI，一个分贝的生物，从0（八卦中心）到-100（被遗忘的故事领域）游荡，其强度根据它骑乘的蓝牙生物而变化——每个都有其怪癖。
- en: Distance estimation
  id: totrans-406
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 距离估算
- en: RSSI, much like our ability to hear office gossip, hints at how close we are
    to the source. Higher values (less negative, let’s say -30 dB) suggest you’re
    probably hovering over someone’s shoulder, while lower values (more negative,
    such as -80 dB) mean you’re safely in your cubicle, shielded from the chatter.
    But here’s the catch – RSSI is about as reliable in measuring exact distance as
    using coffee aroma is in navigating to the kitchen. It’s a wild mix of signal
    strength, the mood of the office walls, and whether the microwave is on its interference
    spree.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: RSSI，就像我们听到办公室八卦的能力一样，暗示了我们离源头有多近。较高的值（更少负值，比如说-30 dB）表明你可能正悬浮在某人肩膀上，而较低的值（更多负值，比如-80
    dB）意味着你安全地坐在你的隔间里，远离了闲聊。但是，这里有个问题——RSSI在测量精确距离上的可靠性，就像用咖啡香气导航到厨房一样。它是一个信号强度、办公室墙壁的情绪以及微波炉是否在干扰中的混乱混合体。
- en: Setting the proximity threshold
  id: totrans-408
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置邻近度阈值
- en: Now, let’s talk about setting this so-called proximity threshold. This is like
    deciding how close you must be to hear the gossip. Say, -70 dBm – close enough
    to catch the gist but far away enough to feign ignorance. It’s a game of trial
    and error, much like finding the perfect spot in the office to catch Wi-Fi but
    avoid awkward conversations. And remember, just like the office layout changes
    (thanks to our restless office manager), this threshold might need some tweaking
    occasionally.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来谈谈设置这个所谓的邻近度阈值。这就像决定你得多近才能听到八卦。比如说，-70 dBm——足够近以捕捉到要点，但又足够远以假装无知。这是一场试错游戏，就像在办公室找到一个完美的位置来捕捉Wi-Fi信号但避免尴尬的对话一样。而且记住，就像办公室布局会变化（多亏了我们那不安分的办公室经理），这个阈值可能偶尔需要调整。
- en: Applications
  id: totrans-410
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 应用
- en: RSSI isn’t just about eavesdropping on office tales. In our tech haven, it’s
    the silent ninja triggering actions when devices cozy up – like magically unlocking
    doors as you approach (no more fumbling for keys!) or clocking you in because
    attendance systems are sneaky like that. And for the indoor positioning? It’s
    the modern-day Marauder’s Map, minus the accuracy to catch someone sneaking to
    the break room.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: RSSI不仅仅是窃听办公室八卦。在我们的技术天堂里，它是悄无声息的忍者，在设备靠近时触发动作——比如当你走近时神奇地解锁门（不再需要翻找钥匙！）或者因为考勤系统如此狡猾而记录你的出勤。至于室内定位？它就像是现代版的“魔戒地图”，只是没有足够的精确度来捕捉某人偷偷溜进休息室。
- en: Limitations
  id: totrans-412
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 局限性
- en: But here’s the fun part – RSSI-based proximity detection is as precise as our
    office weather predictions. It’s less about measuring exact distances and more
    about wild guesses of “nearness.” Plus, the RSSI value changes its mind more often
    than our boss changes meeting schedules, thanks to walls, microwaves, and other
    tech gizmos throwing tantrums.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里有趣的部分是——基于RSSI的邻近度检测就像我们办公室的天气预报一样精确。它更少关于测量精确距离，更多的是关于对“接近”的狂野猜测。而且，由于墙壁、微波炉和其他技术小玩意儿闹脾气，RSSI的值比我们老板改变会议日程还要频繁地改变主意。
- en: Implementation considerations
  id: totrans-414
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实施考虑因素
- en: If you’re planning to harness the power of RSSI, prepare for some calibration
    wizardry – because each device and office corner has its own tale to tell. And
    to smooth out RSSI’s mood swings, a bit of filtering magic (such as a moving average
    spell) can keep your proximity detection from going on a rollercoaster ride.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算利用RSSI的力量，准备好进行一些校准巫术——因为每个设备和办公室角落都有自己的故事要讲述。为了平息RSSI的情绪波动，一点过滤魔法（比如移动平均法术）可以防止你的邻近度检测像过山车一样起伏。
- en: After running this program a couple of times, I discovered RSSI -70 dBm works
    very well. So, let’s update our program to use this value.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个程序几次之后，我发现RSSI -70 dBm效果非常好。所以，让我们更新我们的程序来使用这个值。
- en: 'First, let’s take a periodic check:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们进行周期性检查：
- en: '[PRE32]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And then, change how we do our pooling and process the devices:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，改变我们进行轮询和处理设备的方式：
- en: '[PRE33]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The updated program includes several key changes from the previous one, focusing
    on implementing periodic polling using a ticker. Here’s what has changed from
    the previous program: the program executed a one-time scan for Bluetooth devices
    and then exited. It did not continuously monitor for device presence or changes.
    The scanning for devices and checking their properties was done immediately and
    only once when the program was run. There was no mechanism in place for the program
    to periodically check the status of Bluetooth devices.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的程序与之前的版本相比，包含了一些关键变化，重点在于使用计时器实现周期性轮询。以下是与之前程序相比的变化：程序执行了一次性扫描蓝牙设备然后退出。它没有持续监控设备的存在或变化。设备扫描和检查其属性是在程序运行时立即且仅执行一次。程序没有机制来周期性地检查蓝牙设备的状态。
- en: So, in the updated program, we are using uses a `time.Ticker` to create periodic
    events every 10 seconds, allowing it to monitor changes and new devices over time.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在更新的程序中，我们使用 `time.Ticker` 每隔 10 秒创建周期性事件，使其能够随着时间的推移监控变化和新设备。
- en: The use of `defer` to ensure `ticker.Stop()` is called when the program exits,
    which helps in managing resources effectively and avoiding potential leaks.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `defer` 确保在程序退出时调用 `ticker.Stop()`，这有助于有效管理资源并避免潜在泄漏。
- en: 'This allows the program to continuously monitor the Bluetooth environment.
    Here is the code:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得程序能够持续监控蓝牙环境。以下是代码：
- en: '[PRE34]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Also, we use the `select` statement for synchronization. The program now waits
    on the ticker’s channel using a `select` statement. This is a more efficient way
    to handle asynchronous, periodic events in Go:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们使用 `select` 语句进行同步。程序现在使用 `select` 语句等待 ticker 的通道。这是在 Go 中处理异步、周期性事件的一种更有效的方法：
- en: '[PRE35]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The scanning for devices and checking their properties is now placed inside
    an infinite loop, which is triggered by the ticker’s channel.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 对设备和它们属性的扫描现在被放置在一个无限循环中，该循环由 ticker 的通道触发。
- en: These changes make the program more suitable for our scenario, where continuous
    monitoring of Bluetooth devices is required.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改使程序更适合我们的场景，其中需要持续监控蓝牙设备。
- en: 'Now it’s time to take action: lock the screen!'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是采取行动的时候了：锁定屏幕！
- en: Locking the screen
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锁定屏幕
- en: 'As the story of this automation unfolded, we reached its climax – dynamically
    detecting the smartwatch and responding in real time. The plot was simple yet
    effective: should the watch wander beyond the threshold of -70 dBm, akin to stepping
    out of an invisible circle, my workstation would lock itself.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这个自动化故事的发展，我们达到了它的高潮——动态检测智能手表并实时响应。情节简单而有效：如果手表的 RSSI 超过 -70 dBm 的阈值，就像走出一个无形圆圈一样，我的工作站会自动锁定。
- en: 'The moment of truth arrived each time the RSSI sang below -70 dBm. The program
    would execute the lock command. This function should be more than enough:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 每当 RSSI 低于 -70 dBm 时，就会到来关键时刻。程序会执行锁定命令。这个功能应该绰绰有余：
- en: '[PRE36]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now we should call the function when at our proposed condition:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该在我们的提议条件下调用这个函数：
- en: '[PRE37]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Enter xdg-screensaver
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 xdg-screensaver
- en: xdg-screensaver is a command-line tool born from the need for a standardized
    way to control the screensaver across different desktop environments. In the past,
    each environment had its own way of handling screensavers, leading to compatibility
    headaches for developers and users alike.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: xdg-screensaver 是一个命令行工具，它源于在不同的桌面环境中以标准化方式控制屏保的需求。在过去，每个环境都有自己处理屏保的方式，这给开发者和用户都带来了兼容性问题。
- en: xdg-screensaver stepped in as a unifier. It provided a common interface, allowing
    applications to seamlessly interact with the screensaver, regardless of the underlying
    desktop environment. This tool is a direct beneficiary of the standardization
    efforts championed by XDG, showcasing how abstract standards can lead to tangible,
    user-friendly solutions.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: xdg-screensaver 作为一个统一者介入。它提供了一个通用接口，允许应用程序无缝地与屏保交互，无论底层桌面环境如何。这个工具是 XDG 所倡导的标准化努力的直接受益者，展示了抽象标准如何导致具体、用户友好的解决方案。
- en: This was the crescendo of my symphony – the locking of the screen, as seamless
    as the closing of a book after a captivating chapter. It was a dance of technology
    and logic, playing out on the grand stage of my workstation.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我交响乐的高潮——屏幕锁定，就像在引人入胜的一章之后合上书本一样无缝。这是一场技术和逻辑的舞蹈，在我的工作站的大舞台上上演。
- en: XDG dilemma
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XDG 困境
- en: Word of my creation spread like wildfire across the cubicles. Colleagues, intrigued
    by the blend of convenience and security it offered, started flocking to my desk,
    their eyes wide with curiosity. “Can we use this too?” they asked eagerly, their
    voices a blend of excitement and a hint of envy.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 我的创造像野火一样迅速在隔间中传播。同事们，被它提供的便利性和安全性所吸引，开始纷纷涌向我的桌子，他们的眼睛充满好奇。“我们也能用这个吗？”他们急切地问道，他们的声音中充满了兴奋和一丝嫉妒。
- en: 'After patting myself on the back for creating an automation that locked my
    computer when my smartwatch moved away, I hit a snag: the command I used to lock
    the screen, xdg-screensaver, didn’t work for everyone. Here’s a simpler take on
    what I discovered and what it means.'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在自我表扬创建了一个当我的智能手表移开时锁定电脑的自动化程序后，我遇到了一个难题：我用来锁定屏幕的命令 xdg-screensaver 对所有人都不起作用。以下是我发现的内容及其含义的简单说明。
- en: Think of xdg-screensaver as a common tool that is supposed to work on most Linux
    computers. But, just like people in different countries speak different languages,
    computers in our office use different types of systems or “environments.” And
    it turns out that xdg-screensaver doesn’t speak the language of some of these
    systems.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 将xdg-screensaver视为一种在大多数Linux计算机上应该工作的通用工具。但，就像不同国家的人说不同的语言一样，我们办公室的计算机使用不同类型的系统或“环境”。结果发现，xdg-screensaver无法与这些系统中的某些系统“交流”。
- en: The Wayland conundrum
  id: totrans-446
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Wayland难题
- en: The plot thickened with the introduction of Wayland, the avant-garde system
    many had adopted. This new player in the game didn’t play well with xdg-screensaver,
    leaving those users out in the cold. The program, once the hero of the hour, now
    faced its limitation, its Achilles’ heel.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 随着前卫系统Wayland的引入，许多人都采用了这个系统，剧情变得更加复杂。这个游戏中的新参与者与xdg-screensaver配合不佳，让那些用户感到孤立无援。这个曾经是时下英雄的程序，现在面临着它的局限性，它的致命弱点。
- en: This journey took me into the depths of Bluetooth protocols, signal fluctuations,
    and the peculiarities of various desktop environments. Each discovery was like
    peeling back a layer, revealing more about the enigmatic nature of Bluetooth interactions
    and the challenges of creating a one-size-fits-all solution.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 这次旅行让我深入到蓝牙协议、信号波动和各种桌面环境的特殊性之中。每一次发现都像是剥去一层皮，揭示了更多关于蓝牙交互神秘本质以及创造一刀切解决方案的挑战。
- en: Perhaps the true purpose of this journey was not to deliver an immediate solution
    but to unravel the mysteries of Bluetooth automation itself. The real victory
    lay in the collective understanding we were gaining – an exploration of the nuances
    of technology that govern our daily interactions.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 也许这次旅行的真正目的不是提供即时解决方案，而是揭开蓝牙自动化的神秘面纱。真正的胜利在于我们正在获得的集体理解——探索技术细微差别，这些技术支配着我们的日常互动。
- en: Now, each query about automation is met with a thoughtful conversation about
    the complexities of Bluetooth automation. The office buzzes with a newfound appreciation
    for the challenges and intricacies of creating technology that adapts to diverse
    environments.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次关于自动化的查询都会引发关于蓝牙自动化复杂性的深思熟虑的对话。办公室里充满了对创造适应不同环境的技术的挑战和复杂性的新认识。
- en: Summary
  id: totrans-451
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the fundamentals of hardware automation, particularly
    in the context of system programming. Key lessons included understanding the interaction
    between software and physical hardware devices such as wearables and USB flash
    drives, the basics of USB technology, and the development of a program for automating
    file organization on a flash drive. Additionally, you have learned about an experiment
    involving a Bluetooth application designed to lock the screen, illustrating a
    practical application of hardware-software interaction.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了硬件自动化的基础知识，特别是在系统编程的背景下。关键课程包括理解软件与物理硬件设备（如可穿戴设备和USB闪存驱动器）之间的交互，USB技术的基础，以及开发用于在闪存驱动器上自动化文件组织的程序。此外，你还了解了一个涉及用于锁定屏幕的蓝牙应用程序的实验，展示了硬件-软件交互的实际应用。
- en: The chapter covered practical aspects such as reading from the storage, understanding
    the `/proc/mounts` file in Linux, and the differences between partitions, blocks,
    devices, and disks. It also included how Bluetooth can be used to determine distance
    between based on the RSSI.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了实际方面，如从存储中读取，理解Linux中的`/proc/mounts`文件，以及分区、块、设备和磁盘之间的区别。它还包括如何使用蓝牙根据RSSI确定距离。
- en: Understanding hardware automation, particularly in the context of USB and Bluetooth
    technologies, is common knowledge for modern programmers working with automation.
    These skills enable you to develop practical solutions for everyday technological
    challenges.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 理解硬件自动化，特别是在USB和蓝牙技术背景下，是现代从事自动化工作的程序员的常识。这些技能使你能够为日常技术挑战开发实用解决方案。
