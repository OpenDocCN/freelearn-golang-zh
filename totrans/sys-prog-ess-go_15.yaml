- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stay Sharp with System Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will wrap up our learning journey by exploring the history of the
    most famous projects and companies adopting Go. You will also be presented with
    the most iconic materials to learn about system programming and how to stay up
    to date with this community.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter will cover the following key topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Real-world applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating the system programming landscape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resources for continued learning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned how to continue enhancing
    your system programming knowledge and its ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to truly grasp the power of Go in system programming is to see
    it in the wild. Let’s explore real-world use cases where Go has been successfully
    employed to build robust and efficient systems.
  prefs: []
  type: TYPE_NORMAL
- en: Dropbox’s leap of faith
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: “Python is perfect for everything, right?” Ah, the sweet sound of naive optimism.
    You know – the kind you hear just before a catastrophic performance bottleneck
    in your monolithic Python code base. But hey, at least it was quick to write;
    am I right?
  prefs: []
  type: TYPE_NORMAL
- en: You know, migrating from Python to Go is a bit like swapping out a skateboard
    for a Formula One race car. Sure – both get you from point A to B, but one does
    it with a heck of a lot more speed and precision. And let’s face it, who doesn’t
    love the thrill of a roaring engine, especially when it means your cloud storage
    service can handle millions of concurrent users?
  prefs: []
  type: TYPE_NORMAL
- en: Dropbox, the beloved cloud storage giant, found itself in a similar predicament.
    Their Python backend, while convenient in the early days, was starting to creak
    under the weight of its own success. That’s when they made the bold decision to
    rewrite a significant chunk of their backend in Go. It’s fast, it’s efficient,
    and it’s got a concurrency model that makes scalability feel like child’s play.
    Well, maybe not child’s play, but certainly less like herding cats than Python’s
    threading model.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key challenges Dropbox faced was handling a massive number of concurrent
    requests. With Python, this often involved spawning a new thread for each request,
    which quickly became a resource hog. Go, on the other hand, uses goroutines, which
    are far lighter and cheaper to create. This allowed Dropbox to scale its backend
    effortlessly, handling millions of concurrent users without breaking a sweat.
  prefs: []
  type: TYPE_NORMAL
- en: No one can tell the story better than the Dropbox team itself. You can see it
    in more detail at the *Go at Dropbox* talk ([https://www.youtube.com/watch?v=JOx9enktnUM](https://www.youtube.com/watch?v=JOx9enktnUM)).
  prefs: []
  type: TYPE_NORMAL
- en: HashiCorp – Go from day one
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Infrastructure as code? More like infrastructure as a tangled ball of yarn.
    That’s the kind of exasperated sigh you’ll hear from DevOps engineers wrestling
    with complex configuration management tools. But fear not, for HashiCorp, the
    wizards of infrastructure automation, have a solution that’s as smooth as a well-oiled
    Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine trying to build a house using nothing but duct tape and toothpicks.
    It might work, but it’ll be flimsy, unstable, and prone to collapse. That’s what
    traditional infrastructure management can feel like. HashiCorp, however, offers
    a different approach, one that’s rooted in code, automation, and the power of
    Go.
  prefs: []
  type: TYPE_NORMAL
- en: HashiCorp, the creator of tools such as Terraform, Vault, and Consul, made a
    strategic decision early on to embrace Go as their primary language. This wasn’t
    just a whim; it was a calculated move that aligned with their vision of a more
    efficient, reliable, and scalable approach to infrastructure management.
  prefs: []
  type: TYPE_NORMAL
- en: In an interview with Nic Jackson, a developer at HashiCorp, he discusses why
    they decided to use Go as the primary programming language for their products.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the reasons why HashiCorp decided to use Go:'
  prefs: []
  type: TYPE_NORMAL
- en: It is simple and easy to learn, which makes it easier for developers to get
    started with and be productive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is good for building small, succinct applications. HashiCorp builds a lot
    of microservices, which are small, self-contained services that work together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a rich standard library, which means that a lot of the functionality
    that HashiCorp needs is already built into the language. This makes it easier
    to write programs in Go.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is good for building highly distributed systems. HashiCorp’s products are
    designed to be used in distributed environments, and Go’s concurrency model makes
    it easy to write code that can run on multiple machines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see the interview integrally at the following link: [https://youtu.be/qlwp0mHFLHU](https://youtu.be/qlwp0mHFLHU)'
  prefs: []
  type: TYPE_NORMAL
- en: Grafana Labs – visualizing success with Go
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the ecosystem of monitoring and observability, Grafana Labs has emerged as
    a dominant force, empowering organizations to gain insights into their complex
    systems. While Grafana, their flagship visualization platform, is primarily a
    frontend application, the company’s backend infrastructure and numerous supporting
    tools are built on the foundation of Go. This strategic choice has played a crucial
    role in their ability to deliver high-performance, scalable, and reliable solutions
    for monitoring and observability.
  prefs: []
  type: TYPE_NORMAL
- en: Modern systems generate a deluge of data, from metrics and logs to traces. Grafana
    Labs recognized the need for a backend infrastructure that could ingest, process,
    and store this data efficiently. Go’s inherent performance advantages, stemming
    from its compiled nature and efficient concurrency model, made it an ideal choice
    for handling the demanding workloads of monitoring and observability.
  prefs: []
  type: TYPE_NORMAL
- en: Grafana Labs leverages Go’s goroutines and channels to create highly concurrent
    and efficient backend services. Goroutines, lightweight threads of execution,
    allow them to handle a massive number of concurrent operations, such as data ingestion
    and query processing, without the overhead of traditional threads. Channels facilitate
    seamless communication and synchronization between goroutines, ensuring data integrity
    and efficient resource utilization.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond Grafana, Grafana Labs has developed a suite of tools and components that
    rely on Go’s capabilities. Loki, their log aggregation system, utilizes Go’s efficient
    I/O handling and compression algorithms to ingest and store vast amounts of log
    data. Tempo, their distributed tracing backend, leverages Go’s networking capabilities
    for seamless communication between tracing agents and the central Tempo server.
  prefs: []
  type: TYPE_NORMAL
- en: 'They define the main advantages of using Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Speed**: Go is quick, though not as fast as a meticulously written C program.
    However, it allows for quicker development compared to C. It significantly outpaces
    languages such as Perl or Ruby in terms of execution speed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplified deployment**: The static binaries that Go creates are straightforward
    to deploy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Balanced freedom**: Go offers considerable flexibility without the temptations
    of unnecessary complex pointer arithmetic, promoting simpler, effective coding
    practices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-platform compatibility**: Go supports building applications across
    various platforms, including Linux, Solaris, macOS, Windows, and BSDs on different
    architectures such as amd64, i686, or arm. Even lesser-known systems such as plan9
    might be supported, depending on the libraries used. For extremely uncommon platforms,
    gccgo might offer a viable solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Accessibility in programming**: Go simplifies backend and systems programming
    with its powerful yet elegant syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Profiling tools**: The profiling capabilities in Go, such as CPU and heap
    profiling, are robust and valuable. The addition of trace profiling in Go 1.5
    has been particularly beneficial.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Built-in concurrency**: Concurrency is an integral part of Go, making it
    easy to manage and effective to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Powerful interfaces**: Although Go’s interfaces may require some learning,
    they become indispensable once mastered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s a full breakdown of the use of Go in Grafana Labs in the *Where and
    Why We Use Go* blog post ([https://grafana.com/blog/2015/08/21/where-and-why-we-use-go/](https://grafana.com/blog/2015/08/21/where-and-why-we-use-go/)).
  prefs: []
  type: TYPE_NORMAL
- en: Docker – building a container revolution with Go
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Docker, the platform that revolutionized software development and deployment
    with its container technology, owes much of its success to a rather unconventional
    choice: Go. While other established languages such as Java or C++ might have seemed
    more obvious for building such a complex system, Docker’s founders recognized
    the unique advantages Go offered for their ambitious project.'
  prefs: []
  type: TYPE_NORMAL
- en: At its core, Docker is about lightweight isolation and portability. Go’s minimalist
    syntax and compiled nature aligned perfectly with this philosophy. Go’s fast compilation
    times and ability to produce statically linked binaries streamlined the development
    process and ensured consistent behavior across different environments, making
    it easier to package and distribute Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: Docker’s design heavily relies on concurrency to manage multiple containers
    simultaneously. Go’s goroutines and channels provide a lightweight and efficient
    concurrency model, allowing Docker to handle many concurrent operations with minimal
    overhead. This proved crucial for building a scalable and responsive platform
    that could efficiently manage containerized applications.
  prefs: []
  type: TYPE_NORMAL
- en: One of Docker’s key strengths is its ability to run on various platforms, from
    Linux to Windows to macOS. Go’s cross-platform compatibility simplified the development
    process, as developers could write code once and compile it for different architectures
    without significant modifications. This enabled Docker to quickly expand its reach
    and become the de facto standard for containerization.
  prefs: []
  type: TYPE_NORMAL
- en: Although Go was relatively new when Docker was created, its increasing community
    and rapidly growing ecosystem provided the necessary libraries and tools for building
    a complex system. The Docker team actively contributed to the Go community, developing
    open source libraries such as `libcontainer` for low-level container management,
    further solidifying Go’s position in the container ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: In retrospect, Docker’s decision to embrace Go appears almost prescient. Go’s
    unique strengths aligned seamlessly with the requirements of containerization,
    enabling the Docker team to build a robust, efficient, and portable platform that
    transformed the way software is developed and deployed. While other languages
    might have sufficed, Go’s combination of simplicity, performance, concurrency,
    and cross-platform compatibility proved to be the perfect recipe for building
    a container revolution.
  prefs: []
  type: TYPE_NORMAL
- en: The list of successful applications written in Go goes on. To put things in
    perspective, Golang steals the scene in the **Cloud Native Computing Foundation**
    (**CNCF**). Most cloud-native apps are written in Go.
  prefs: []
  type: TYPE_NORMAL
- en: You can browse all these projects at [https://www.cncf.io/](https://www.cncf.io/).
  prefs: []
  type: TYPE_NORMAL
- en: SoundCloud – from Ruby to Go
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SoundCloud initially built their platform using Ruby on Rails, which they affectionately
    called “Mothership.” This monolithic application handled their public API, used
    by both their client applications and thousands of third-party applications, as
    well as the user-facing web application. As the platform grew, so did the complexity
    and scale of the challenges they faced. With millions of users and a massive volume
    of music uploads every minute, the limitations of the monolithic architecture
    became increasingly apparent.
  prefs: []
  type: TYPE_NORMAL
- en: To address scalability issues, SoundCloud decided to transition to a microservices
    architecture. This approach allowed them to separate domain logic into smaller,
    independent services, each with its own well-defined API. The microservices architecture
    provided greater flexibility and improved scalability, but it also introduced
    new challenges, such as managing inter-service communication and ensuring consistent
    data handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'SoundCloud’s engineering team evaluated several programming languages to support
    their new microservices architecture. Go was chosen for several key reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance and concurrency**: Go’s efficient concurrency model, powered
    by goroutines, allowed SoundCloud to handle numerous simultaneous connections,
    which was crucial for their high-traffic platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplicity and readability**: Go’s design philosophy of simplicity and minimalism
    made it easier for engineers to understand and maintain the code. The language’s
    **what you see is what you get** (**WYSIWYG**) nature helped new engineers become
    productive quickly, reducing the time from onboarding to making meaningful contributions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fast compilation and deployment**: Go’s fast compilation times and static
    typing facilitated quick iterations during development. This enabled SoundCloud
    to rapidly develop, test, and deploy new features, improving their overall development
    velocity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Community and ecosystem**: The growing ecosystem of Go libraries and tools,
    as well as an active community, provided SoundCloud with the resources and support
    needed to build robust applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SoundCloud gradually migrated their services to Go, starting with non-critical
    components to minimize risk. They developed several internal tools and libraries
    to support the new architecture, including Bazooka, their deployment platform.
    This phased approach allowed them to incrementally refactor the monolith without
    disrupting existing services.
  prefs: []
  type: TYPE_NORMAL
- en: The transition to Go resulted in significant improvements in system performance
    and reliability. By leveraging Go’s concurrency features, SoundCloud could handle
    higher loads with fewer resources, reducing server costs. The simplicity of Go’s
    syntax and structure also made code reviews more focused on the problem domain
    rather than language intricacies, enhancing collaboration and productivity among
    developers.
  prefs: []
  type: TYPE_NORMAL
- en: SoundCloud’s migration to Go was driven by the need for better performance,
    scalability, and maintainability as their platform grew. By adopting Go and a
    microservices architecture, they successfully overcame the limitations of their
    monolithic Ruby on Rails application, setting a strong foundation for future growth
    and innovation.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating the system programming landscape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The world of system programming is constantly evolving. To remain a skilled
    practitioner, it’s essential to stay informed about the latest developments.
  prefs: []
  type: TYPE_NORMAL
- en: Go release notes and blog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Religiously follow Go’s release notes. Each new version often brings enhancements
    specifically for system programming, such as improved memory management or runtime
    optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: The official Go blog is an excellent resource for staying up to date with the
    latest news, announcements, and updates related to the Go programming language.
    You can find it at [https://blog.golang.org/](https://blog.golang.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Community
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It may sound dated, but joining mailing lists such as `golang-nuts` and `golang-dev`
    can keep you in the loop about discussions, announcements, and developments in
    the Go community.
  prefs: []
  type: TYPE_NORMAL
- en: Controversy aside, following influential Go developers, Go-related accounts,
    and hashtags such as `#golang` on X can provide real-time updates, discussions,
    and links to interesting articles and resources.
  prefs: []
  type: TYPE_NORMAL
- en: Also, participate in online forums (such as Go’s subreddit), Slack channels,
    and conferences (such as *GopherCon*). Engage with other Go developers, learn
    from their experiences, and share your knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: Contribution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I highly recommend you follow repositories related to the Go programming language
    on GitHub, especially the official Go repository and popular Go libraries and
    frameworks, which can give you insights into ongoing developments, issues, and
    pull requests. As you feel confident, contributing to open source Go projects
    is an excellent way to learn and give back to the community.
  prefs: []
  type: TYPE_NORMAL
- en: '*Tip*: Start with smaller contributions or bug fixes, and gradually take on
    more challenging tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: Experimentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Don’t hesitate to experiment with new Go features and libraries as they become
    available. Hands-on experience is invaluable for understanding their potential
    in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Resources for continued learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your journey in system programming with Go doesn’t end here. The following resources
    will help you expand your knowledge and skills.
  prefs: []
  type: TYPE_NORMAL
- en: System programming focuses more on deepening your understanding of the fundamental
    layers of a computer system than on chasing the latest technologies or frameworks.
    It may seem counterintuitive, but the goal is to master the core principles rather
    than just keep up with the newest trends. By gaining a solid grasp of how operating
    systems, hardware, and system libraries interact, you develop the ability to write
    more efficient and reliable code.
  prefs: []
  type: TYPE_NORMAL
- en: This field requires a thorough knowledge of low-level programming languages,
    such as C and sometimes Assembly, as these languages offer the fine-grained control
    needed to manipulate hardware directly. System programmers often work on developing
    or modifying operating systems, drivers, embedded systems, and performance-critical
    applications. They need to understand memory management, process scheduling, and
    filesystem implementations, among other core components.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, system programming emphasizes a deep understanding of computer architecture,
    including CPU operations, caching mechanisms, and I/O processes. This knowledge
    enables you to optimize software to run efficiently on the hardware it targets,
    which is vital for applications where performance and resource utilization are
    critical.
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect of system programming is its stability and longevity. Unlike
    high-level frameworks and libraries, which may become obsolete as new technologies
    emerge, the fundamental concepts of system programming remain constant. Mastering
    these principles provides a robust foundation that can be applied across various
    technologies and platforms, ensuring long-term relevance in the ever-evolving
    field of computer science.
  prefs: []
  type: TYPE_NORMAL
- en: I have some book recommendations for you, but they might be considered classics
    compared with recent publications.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Programming in the UNIX Environment by W. Richard Stevens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often referred to as *APUE*, this book is a detailed study of Unix system programming,
    covering all aspects of the Unix operating system and the fundamentals of system
    programming. It serves as an essential reference for understanding how Unix systems
    work, delving into topics such as file I/O, process control, signal handling,
    and **inter-process communication** (**IPC**). The book is known for its clear
    explanations and practical examples, making complex concepts accessible to both
    novice and experienced programmers. It also emphasizes best practices and robust
    programming techniques, equipping readers with the skills necessary to develop
    reliable and efficient Unix applications. With its comprehensive coverage and
    authoritative insights, APUE is a cornerstone in the library of any serious Unix
    programmer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Learn C Programming - Second Edition: A beginner’s guide to learning the most
    powerful and general-purpose programming language with ease'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In system programming, you will invariably touch some C code. In this case,
    I would recommend a smooth ride instead of a mountain bike competition. This book
    is like training wheels for your programming bike. It holds your hand, wipes your
    tears, and gently guides you into the cold, unforgiving world of C.
  prefs: []
  type: TYPE_NORMAL
- en: The author distills the chaos of C into something you might understand. It’s
    almost like magic, but less exciting. Each chapter gives you examples to chew
    on, making sure you don’t just stare blankly at your screen, wondering what went
    wrong. The book doesn’t just throw you into the deep end. Instead, it walks you
    down the stairs into the shallow end, one careful step at a time.
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t your grandpa’s C programming book. It’s got all the modern stuff
    to keep you from looking like a relic. Just when you think you’ve got it, the
    book throws in exercises to remind you that you don’t. Keeps you humble.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re a newbie or just need to refresh your C skills, this book has got
    you covered. The authors keep it simple, but not so simple you feel talked down
    to. It’s like they know you’re smart but clueless. A rare talent.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is your go-to guide for entering the wild world of C. It’s straightforward,
    practical, and slightly condescending in a way that makes you think: Maybe I can
    actually do this.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux Kernel Programming - Second Edition: A comprehensive and practical guide
    to kernel internals, writing modules, and kernel synchronization'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, you’ve decided to tackle the Linux kernel. Bold move. Picking up *Linux
    Kernel Programming - Second Edition* is like strapping on your hiking boots for
    a trek through the Himalayas. It’s tough terrain, but with the right guide, you’ll
    reach the summit.
  prefs: []
  type: TYPE_NORMAL
- en: The author of this book has a knack for making the labyrinth of kernel internals
    seem almost navigable. They break down the complexities into bite-sized pieces,
    making the overwhelming world of kernel development feel a bit less like rocket
    science. And they don’t just give you dry theory. Oh no – they hand you practical
    examples that are like breadcrumbs, leading you through a dense forest of code.
  prefs: []
  type: TYPE_NORMAL
- en: This book doesn’t just toss you into the deep end to fend for yourself. It takes
    you through the process step by step, from understanding kernel internals to writing
    modules and handling synchronization. It’s a methodical journey, one that ensures
    you don’t get lost along the way. And it’s not stuck in the past. The content
    is updated, modern, and relevant, so you’re learning the latest and greatest in
    kernel programming.
  prefs: []
  type: TYPE_NORMAL
- en: Just when you start feeling confident, the book hits you with exercises and
    challenges that remind you there’s still a lot to learn. These aren’t just busywork—they’re
    designed to make you think critically and deepen your understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you’re a newbie or looking to sharpen your kernel skills, this book
    is your reliable guide. The authors strike a perfect balance, simplifying the
    complex without dumbing it down. They know you’re smart but might need a bit of
    handholding in this daunting field.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, it’s comprehensive, practical, and challenging in all the right
    ways. If you’re serious about mastering kernel programming, this book is your
    roadmap to success.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux System Programming Techniques: Become a proficient Linux system programmer
    using expert recipes and techniques'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Think of this book as your mentor, ready to impart the wisdom of the Linux sages
    with a side of tough love.
  prefs: []
  type: TYPE_NORMAL
- en: This book is packed with hands-on recipes. These are different from your run-of-the-mill,
    follow-the-instructions kind of recipes. They’re more like secret family recipes
    passed down from generations of Linux gurus, designed to give you fundamental
    skills and deep understanding. Each example is carefully crafted to show you how
    to do something and why it works that way.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll appreciate the practical approach. The authors don’t just tell you what
    to do—they show you how to think like a system programmer. The challenges and
    exercises are where the magic happens. They push you to apply your knowledge,
    think critically, and solve real problems. It’s like having a stern but supportive
    coach who knows you’ve got what it takes.
  prefs: []
  type: TYPE_NORMAL
- en: This book is a testament to insightful, practical, and challenging learning
    in the most rewarding way. It offers expert recipes and techniques that will propel
    your skills to new heights, inspiring you to strive for continuous improvement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Operating Systems: Design and Implementation by Andrew S. Tanenbaum'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This book, often used in academic settings, provides a solid foundation in the
    theory and practical aspects of operating systems. Tanenbaum’s approach includes
    running examples with a real operating system, MINIX, which he developed specifically
    for educational purposes. The book covers a broad range of topics essential to
    understanding operating systems, such as process management, memory management,
    filesystems, I/O systems, and security.
  prefs: []
  type: TYPE_NORMAL
- en: One of the standout features of this book is its hands-on methodology. By incorporating
    MINIX, Tanenbaum allows readers to explore and modify a real, working operating
    system. This practical experience is invaluable for gaining a deep understanding
    of how theoretical concepts are applied in real-world systems. The text also includes
    comprehensive explanations of operating system principles, complemented by detailed
    diagrams and code examples that illustrate the inner workings of OS components.
  prefs: []
  type: TYPE_NORMAL
- en: '*Operating Systems: Design and Implementation* is structured to facilitate
    both learning and teaching, making it a favorite among students and educators
    alike. Tanenbaum’s clear and engaging writing style, coupled with his extensive
    experience in the field, ensures that complex ideas are presented in an accessible
    manner. For anyone looking to gain a thorough understanding of operating systems
    from both a theoretical and practical perspective, this book is an essential resource.'
  prefs: []
  type: TYPE_NORMAL
- en: Unix Network Programming by W. Richard Stevens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is another classic by Stevens that delves into the specifics of network
    programming in Unix environments. It’s essential for anyone working with network
    applications in Unix. The book provides a comprehensive guide to the concepts,
    protocols, and techniques needed to develop robust and efficient network software.
    It covers a wide range of topics, including sockets, TCP/IP, UDP, raw sockets,
    and multicast communication.
  prefs: []
  type: TYPE_NORMAL
- en: Stevens’ detailed and methodical approach ensures that readers not only learn
    the theory behind network protocols but also gain practical skills through extensive
    examples and sample code. The book addresses common challenges in network programming,
    such as error handling, performance optimization, and scalability. It also explores
    advanced topics such as non-blocking I/O, signal-driven I/O, and the use of select
    and poll for multiplexing.
  prefs: []
  type: TYPE_NORMAL
- en: '*Unix Network Programming* is widely regarded as the definitive resource on
    the subject, known for its clarity, depth, and practical relevance. By following
    the guidance and examples provided, readers can develop a deep understanding of
    network programming principles and apply them to create efficient, reliable, and
    high-performance networked applications. Whether you are a beginner looking to
    learn the basics or an experienced programmer seeking to refine your skills, this
    book is an indispensable reference in the field of Unix network programming.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux System Programming Techniques: Become a proficient Linux system programmer
    using expert recipes and techniques'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ready to unravel the mysteries of Linux system programming? *Linux System Programming
    Techniques* is your ultimate guide to mastering the art of extending the Linux
    OS with your own programs. This book is like a masterclass, packed with practical
    examples and expert recipes that will turn you into a proficient Linux system
    programmer.
  prefs: []
  type: TYPE_NORMAL
- en: The author kicks things off by diving into the Linux filesystem and its basic
    commands. They guide you through the built-in manual pages, the **GNU Compiler
    Collection** (**GCC**), and essential Linux system calls. You’ll learn not just
    how to write programs, but how to handle errors like a pro, catching them and
    printing relevant information.
  prefs: []
  type: TYPE_NORMAL
- en: The book serves up many recipes on reading and writing files using streams and
    file descriptors. You’ll get hands-on experience with forking, creating zombie
    processes, and managing daemons with `systemd`. And just when you think you’ve
    got it all figured out, the authors introduce you to creating shared libraries
    and the nuances of IPC.
  prefs: []
  type: TYPE_NORMAL
- en: As you advance, you’ll delve into the world of POSIX threads, learning how to
    write robust multithreaded programs. Debugging your programs using the **GNU Debugger**
    (**GDB**) and Valgrind is covered extensively, ensuring you have all the tools
    you need to squash those pesky bugs.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this journey, you’ll be equipped to develop your own system programs
    for Linux, including daemons, tools, clients, and filters. The book promises to
    deepen your understanding of Linux system programming, integrating programs seamlessly
    with the Linux OS.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll discover how to write programs using a wide variety of system calls and
    delve into POSIX functions. The book covers key concepts such as signals, pipes,
    IPC, and process management, giving you a comprehensive toolkit for any Linux
    system programming challenge. Advanced topics such as filesystem operations, creating
    shared libraries, and debugging your programs are also explored in detail.
  prefs: []
  type: TYPE_NORMAL
- en: It is perfect for anyone looking to develop system programs for Linux and gain
    a deeper understanding of the OS. Whether you’re facing issues with a specific
    part of Linux system programming or seeking specific recipes and solutions, this
    book has you covered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mastering Embedded Linux Programming - Third Edition: Create fast and reliable
    embedded solutions with Linux 5.4 and the Yocto Project 3.1 (Dunfell)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is your definitive guide to creating versatile and robust embedded solutions
    with Linux 5.4 and the Yocto Project 3.1 (Dunfell). This book is like a master
    toolkit for anyone serious about embedded Linux development, from the basics to
    the cutting-edge features of Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'The author starts by breaking down the core elements of embedded Linux projects:
    the toolchain, the bootloader, the kernel, and the root filesystem. You’ll learn
    to create each component from scratch and automate the process using Buildroot
    and the Yocto Project. As you progress, the book guides you through implementing
    effective storage strategies for flash memory and remotely updating your devices
    once they’re deployed. It’s not just about getting things to work—it’s about making
    them work efficiently and securely.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll dive into the nitty-gritty of writing code for embedded Linux, from accessing
    hardware directly from your applications to the complexities of multithreaded
    programming and efficient memory management. The final chapters are dedicated
    to debugging and profiling, ensuring you have all the tools to pinpoint performance
    bottlenecks and optimize your system.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this journey, you’ll be able to create efficient and secure embedded
    devices using Linux. Whether you’re dealing with smart TVs, Wi-Fi routers, industrial
    controllers, or any other IoT device, this book covers it all.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll learn to use Buildroot and the Yocto Project to create embedded Linux
    systems, troubleshoot BitBake build failures, and streamline your Yocto development
    workflow. The book also covers secure updates for IoT devices using tools like
    Mender or Balena. Prototyping peripheral additions, interacting with hardware
    without kernel device drivers, dividing your system into supervised services with
    BusyBox `runit`, and remote debugging with GDB are also thoroughly covered. Performance
    measurement tools such as `perf`, `ftrace`, eBPF, and Callgrind are explained
    to help you optimize your systems.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re a systems software engineer or system administrator looking to master
    Linux implementation on embedded devices, this book is for you. It’s also perfect
    for embedded systems engineers transitioning from low-power microcontrollers to
    high-speed systems on chips running Linux. Anyone responsible for developing new
    hardware that needs to run Linux will find this book invaluable. A basic working
    knowledge of the POSIX standard, C programming, and shell scripting is assumed,
    making this book both accessible and comprehensive.
  prefs: []
  type: TYPE_NORMAL
- en: Modern Operating Systems by Andrew S. Tanenbaum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Also, Tanenbaum’s book provides a comprehensive look at the operating systems
    used in modern computers, focusing on the mechanics of their operation and design
    principles. This book provides a comprehensive look at the operating systems used
    in modern computers, focusing on the mechanics of their operation and design principles.
    The text covers various topics critical to understanding how contemporary operating
    systems function, including process and thread management, memory management,
    filesystems, I/O systems, and security.
  prefs: []
  type: TYPE_NORMAL
- en: Tanenbaum’s clear and engaging writing style, combined with his ability to simplify
    complex concepts, makes this book accessible to both students and professionals.
    The book is renowned for its thorough explanations and well-organized structure,
    making it an excellent resource for both academic courses and self-study. It includes
    numerous case studies of popular operating systems such as Windows, Linux, and
    Unix, providing real-world examples of the principles discussed.
  prefs: []
  type: TYPE_NORMAL
- en: '*Modern Operating Systems* also delves into advanced topics such as distributed
    systems, multimedia systems, and real-time operating systems, reflecting the latest
    developments and trends in the field. The inclusion of practical examples, exercises,
    and review questions at the end of each chapter helps reinforce learning and provides
    hands-on experience with the material.'
  prefs: []
  type: TYPE_NORMAL
- en: For anyone seeking to understand the complexities of modern operating systems
    and their design, this book is an essential read. It not only provides a solid
    theoretical foundation but also offers insights into practical implementation,
    making it a valuable resource for both aspiring and experienced system programmers.
  prefs: []
  type: TYPE_NORMAL
- en: The Art of UNIX Programming by Eric S. Raymond
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This book explores the philosophy and practice of Unix programming, presenting
    a set of design norms and philosophies that Unix has accumulated over the years.
    Raymond delves into the Unix culture and its emphasis on simplicity, clarity,
    and modularity, which have shaped the development of Unix systems and software.
  prefs: []
  type: TYPE_NORMAL
- en: 'The book is divided into three parts: basic principles, design patterns, and
    case studies. In the first part, Raymond discusses the foundational principles
    of Unix programming, such as the importance of building small, reusable components
    that do one thing well, the power of text-based data streams, and the preference
    for **open source software** (**OSS**). These principles help readers understand
    the core values that guide Unix development.'
  prefs: []
  type: TYPE_NORMAL
- en: The second part covers design patterns, where Raymond explains common patterns
    and best practices used in Unix programming. This section provides insights into
    how to structure programs, manage resources, and handle errors effectively. By
    understanding these patterns, programmers can create more maintainable and robust
    software.
  prefs: []
  type: TYPE_NORMAL
- en: The third part includes case studies of successful Unix programs, offering practical
    examples of the principles and patterns in action. These case studies illustrate
    how experienced Unix programmers approach problem-solving and software design,
    providing valuable lessons for readers.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Art of UNIX Programming* is not just a technical manual but also a reflection
    on the cultural and philosophical aspects of Unix. Raymond’s engaging writing
    style and thoughtful commentary make it a compelling read for anyone interested
    in the Unix way of thinking. Whether you are a novice programmer or an experienced
    developer, this book offers a deeper appreciation of the Unix tradition and its
    enduring influence on software development.'
  prefs: []
  type: TYPE_NORMAL
- en: Mentorship
  prefs: []
  type: TYPE_NORMAL
- en: Consider having a mentor as your last, but not least, step. Seek guidance from
    experienced Go developers or mentors who can provide valuable insights and advice
    in the context of system programming.
  prefs: []
  type: TYPE_NORMAL
- en: Your system programming journey
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What a journey, right? Thanks for sticking with me this far. I hope you’ve gained
    a new perspective on creating Go applications with system programming in mind.
  prefs: []
  type: TYPE_NORMAL
- en: And remember – Go is more than a programming language; it’s a gateway to a world
    of possibilities in system development. By embracing continuous learning, staying
    engaged with the community, and applying your skills to real-world problems, you’ll
    be well equipped to build the high-performance, reliable, and scalable systems
    of tomorrow.
  prefs: []
  type: TYPE_NORMAL
- en: Let this book serve as your foundation, and may your journey in Go-powered system
    programming be filled with success and innovation!
  prefs: []
  type: TYPE_NORMAL
- en: Farewell!
  prefs: []
  type: TYPE_NORMAL
- en: Appendix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hardware Automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about hardware automation, specifically focusing
    on interaction with physical hardware devices such as wearables and flash disks.
    The chapter explores how programs can respond to events triggered by USB and Bluetooth
    devices and the process of building programs that automate file organization on
    a flash drive or react to the distance of a wearable device.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of the chapter is to equip you with the knowledge and skills to create
    a program that can automate tasks based on hardware events.
  prefs: []
  type: TYPE_NORMAL
- en: This information is crucial for any programmer interested in hardware interaction.
    In the real-world context, understanding how to automate tasks with hardware devices
    is increasingly important as the use of such devices becomes more prevalent. This
    knowledge can lead to more efficient and effective management of digital resources,
    enhance productivity, and provide practical solutions to common problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: USB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bluetooth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XDG and freedesktop.org
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automation in system programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automation is centered around the interaction between physical hardware devices
    and the automation of tasks based on the state or changes in the state of these
    devices. This differs from software automation, which focuses on automating digital
    processes and tasks within software environments.
  prefs: []
  type: TYPE_NORMAL
- en: Programming automation is like herding cats. Now imagine that each cat is replaced
    by a line of code, and the people doing the herding are wearing blindfolds called
    “traditional programming approaches.” Within its community, Go acts like a high-powered
    laser pointer. Suddenly, those cats, or lines of code, line up in an orderly fashion,
    ready to follow your every command with the grace of a synchronized swimming team.
    This is the magic of Go’s library ecosystem — transforming what was once a chaotic
    cat rodeo into a well-orchestrated ballet of bytes and data streams.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to write concise, efficient code that directly interfaces with hardware
    is not just a boon but a revolution in how we approach automation tasks. Whether
    managing data from a USB device or handling Bluetooth connections, the Go ecosystem
    provides vibrant community-driven libraries to make these tasks manageable and
    remarkably easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, buckle up to link the physical world with system programming! This chapter
    explores two pieces of hardware from everyday use: wearables and flash disks.'
  prefs: []
  type: TYPE_NORMAL
- en: USB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this section, we are exploring how a program can respond to events triggered
    by USB devices. With this knowledge, when a specific USB device is plugged in,
    we can take several actions – for example, automatically start a backup process,
    launch an application, or execute a custom script.
  prefs: []
  type: TYPE_NORMAL
- en: Application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I like to keep my files organized, but every time I lend my flash disk to a
    friend, they just put all the files in the root directory with no organization
    whatsoever. Now, I have a messy storage device and an unstable friendship. Imagine
    (a hundred times worse) a root directory looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To keep things cool between my friend and me, I created a program that automates
    keeping things organized in my flash drive.
  prefs: []
  type: TYPE_NORMAL
- en: A quick refresher
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Universal Serial Bus**, commonly known as **USB**, is more than just a
    cable and a port on your computer or device. It’s a comprehensive standard that
    defines cables, connectors, and communication protocols for connection, communication,
    and power supply between computers, peripherals, and other computers.
  prefs: []
  type: TYPE_NORMAL
- en: 'USB has evolved through several versions, offering speed, power delivery, and
    functionality improvements. The key features of USB include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Plug and play**: Devices can be connected and disconnected without rebooting
    the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Power supply**: USB can power connected devices, eliminating the need for
    separate power supplies for some peripherals'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data transfer**: USB transfers data between the device and the computer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flash drives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A flash drive, thumb drive, or USB stick is a portable storage device that uses
    flash memory and connects to a computer or other device via a USB interface. Flash
    drives are used for storing, transferring, and backing up data. They are valued
    for their size, durability, and speed, especially compared to older portable storage
    media such as floppy disks and CD-ROMs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me share with you the process of building this kind of program. First,
    we should consider the building blocks: the goal and the automation.'
  prefs: []
  type: TYPE_NORMAL
- en: The goal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In an automated way or not, we need to keep the files organized, so starting
    with this part seems like a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Things we should notice are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Processing multiple paths**: The function is designed to handle a slice of
    file paths, allowing it to operate on multiple directories or files at once.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`filepath.WalkDir` to traverse each directory tree specified in the input paths.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Error handling**: As it traverses directories, the function handles any errors
    encountered. This includes both errors in accessing the directory contents and
    errors specifically related to individual files or directories within those paths.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**File organization based on extension**: For each file encountered (non-directory),
    the function organizes it into a new directory based on its file extension. This
    involves file organization based on extension. The function takes a detailed approach
    to organize files (excluding directories) by their extension. This process involves
    extracting the file extension, creating a new directory for each unique extension
    (if one doesn’t already exist), and moving the file into its newly designated
    directory. This systematic organization makes file management more intuitive and
    accessible.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Recording actions: The function records all the file movements it performs.
    Each action of moving a file from its original location to the new directory based
    on its extension is recorded as a string in the events slice.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Returning results: After processing all paths, the function returns two values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A slice of strings (events), each describing an action taken on a file
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An error value, which is nil if no errors were encountered or the last error
    that occurred during the processing of the paths
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s test this function! Once we are manipulating files, we can use a helper
    function to help us deal with code repetition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This helper function creates a temporary file with a given extension. A neat
    detail of the `CreateTemp` function is when the string pattern includes a `"*"`
    and the random string replaces the last `"*"`. For example, if the ext is “.txt”
    the filename will be something like “1217776936.txt”.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the complete code of the tests for `"success"`, `"empty path"`, and
    `"invalid path"` in the git repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'When reading from the storage, for a `/temp` path, we need to inform the program
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we need to discover where the device is mounted for the flash drive.
    One way to do it manually is by using the `df -h` command, and the output will
    show multiple lines. Still, we’re interested in a line quite like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Feeling overwhelmed by the output? Let’s understand what’s happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/dev/sdc1`: This field represents the device or block device corresponding
    to the mounted filesystem. In this case, `/dev/sdc1` is the device associated
    with the filesystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`15G`: This field shows the total size of the filesystem, which is 15 gigabytes
    (GB) in this example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`16M`: This field displays the space used on the filesystem. Here, it indicates
    that 16 megabytes (MB) of disk space are currently in use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`15G`: This field represents the available disk space on the filesystem. In
    this case, there are 15 gigabytes of free space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1%`: This field shows the percentage of disk space used. Only 1% of the total
    filesystem space is occupied in this example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/media/alexrios/usbtest`: This field is the mount point of the filesystem.
    It indicates where the filesystem is mounted in the directory hierarchy. In this
    case, the filesystem is mounted at `/media/alexrios/usbtest`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since a device could have multiple mount points (partitions) in the same flash
    drive, we will access this information programmatically by reading the `/``proc/mounts`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The /proc/mounts file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `/proc/mounts` file is a special file in the Linux operating system that
    provides a real-time, dynamic view of the currently mounted filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what you can find in the `/proc/mounts` file and what each field represents:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Device or UUID: The first field usually represents the block device or `/dev/sda1`
    or `UUID=12345678-1234-5678-90ab-cdef01234567`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mount point: The second field shows the directory where the filesystem is mounted.
    This is the location in the filesystem hierarchy where you can access the contents
    of the mounted device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Filesystem type: The third field specifies the type of filesystem mounted on
    the given mount point. Common examples include `ext4`, `ntfs`, `tmpfs`, `nfs`,
    and many others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mount options: The fourth field lists the mount options for mounting the filesystem.
    These options control various aspects of how the filesystem behaves. Common options
    include `rw` (read-write), `ro` (read-only), `noexec`, `nosuid`, and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dump flag: The fifth field is typically either `0` or `1` and indicates whether
    the filesystem should be backed up using the dump command. A value of `0` means
    no backup, and `1` means it should be included in backups.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Filesystem check order: The sixth field is used by the `fsck` utility to determine
    the order in which filesystems should be checked during system startup. A value
    of `0` means no automatic filesystem checks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `/proc/mounts` file provides a convenient way for users and system utilities
    to examine the current state of mounted filesystems on a Linux system. Various
    system management tools, scripts, and administrators often use them to gather
    information about mounted devices and their configurations.
  prefs: []
  type: TYPE_NORMAL
- en: /proc/mounts
  prefs: []
  type: TYPE_NORMAL
- en: This is not an actual file on your disk but rather a virtual file that the Linux
    kernel generates and updates to reflect the current state of mounted filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the files on the flash drive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s time to read `/proc/mounts` to read the mount point and discover where
    our program will read the files.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the program idea: listing all files on a device that is mounted on
    your system. Also, it should take a device path as an input parameter, verify
    the path, read mounted filesystems from `/proc/mounts`, and then list all files
    for the specified device. Let’s break down the code step by step, highlighting
    the key snippets for each part.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1: Reading the first parameter as** **a path**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this initial step, the program reads the first command-line argument as the
    path of the device. It then checks whether the provided path starts with `/dev/`
    to ensure it’s a valid device path. If the path doesn’t match the criteria, the
    program prints an error message and exits.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2: Opening and** **reading /proc/mounts**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The program opens the `/proc/mounts` file to read the list of mounted filesystems.
    If there’s an error opening the file, it prints the error and exits. The `defer`
    statement ensures that the file is closed once all operations on the file are
    completed, preventing resource leaks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3: Scanning** **through /proc/mounts**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using a scanner, the program reads each line from `/proc/mounts`. It splits
    each line into fields, where the first field is the device, and the second field
    is its mount point. This step is crucial for identifying the mount point of the
    device specified by the user.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 4: Matching the device and** **listing files**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If the device from `/proc/mounts` matches the path provided by the user, the
    program then corrects any space encoding in the mount point path and announces
    the device and its mount point. It uses `filepath.Walk` to traverse the filesystem
    starting from the mount point, listing all files. If an error occurs during traversal,
    it prints the error.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 5: Handling** **scanner errors**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After completing the scan of `/proc/mounts`, the program checks for any errors
    that might have occurred during the scanning process and reports them. This ensures
    that any issues encountered while reading the file are acknowledged and handled
    appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Pay close attention to the `mountPoint = strings.ReplaceAll(mountPoint, "\\040",
    " ")` line. This is necessary to handle a specific formatting convention in the
    `/proc/mounts` file on Unix-like systems.
  prefs: []
  type: TYPE_NORMAL
- en: In `/proc/mounts`, which lists all mounted filesystems, spaces in file paths
    (common in mount points) are represented by the `\040` escape sequence. The file
    uses a space character to delimit different fields in each line. For instance,
    a mount point path such as `/media/My Drive` would be represented as `/media/My\040Drive`
    in `/proc/mounts`.
  prefs: []
  type: TYPE_NORMAL
- en: Partitions versus blocks versus devices versus disks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In system programming and hardware automation, managing storage efficiently
    is crucial. To navigate this subject effectively, we should understand the fundamental
    concepts of partitions, blocks, devices, and disks.
  prefs: []
  type: TYPE_NORMAL
- en: Partitions – dividing storage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A partition is a logical division of a physical storage device, such as a hard
    drive or SSD. Partitions are created to segment a single physical device into
    multiple isolated sections, each functioning as an independent storage unit. These
    divisions serve several purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Operating system isolation**: Partitions enable the installation of different
    operating systems on a single physical disk, allowing users to choose between
    them during boot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data organization**: Partitions help separate user data from system data,
    facilitating efficient data management and backups'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: Isolating data on separate partitions can enhance security by
    limiting access to specific sections of the storage device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocks – fixed-sized storage units
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Blocks are fixed-sized units of data used for storage and retrieval on storage
    devices. Storage devices, including hard drives and SSDs, are organized into blocks,
    each typically having a predefined size, such as 512 bytes or 4 KB. Key aspects
    of blocks include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data handling**: Operating systems interact with storage devices by reading
    and writing data in blocks. This block-based approach ensures data consistency
    and efficient I/O operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filesystem management**: Filesystems manage data within these blocks, keeping
    track of which blocks are allocated to specific files and directories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimizing storage**: Using fixed-sized blocks allows for the efficient use
    of storage space and minimizes fragmentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Devices – the physical or virtual storage media
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the context of system programming and hardware automation, a device refers
    to either a physical storage device, such as a hard drive or SSD, or a virtual
    device represented by software. Devices can be seen as the interface through which
    the operating system and applications interact with storage resources. Key aspects
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Physical and virtual devices**: Devices can be physical hardware components
    connected to a computer or virtual representations created by software layers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Device identification**: Detecting and identifying storage devices are crucial
    tasks in hardware automation, allowing for device initialization and maintenance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource allocation**: Managing devices includes tasks such as assigning
    device drivers, handling device failures, and ensuring efficient data access'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disks – the storage hardware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Disks, a term often used interchangeably with storage devices, are the physical
    hardware components responsible for data storage. These can be **hard disk drives**
    (**HDDs**), **solid-state drives** (**SSDs**), optical drives, or **network-attached
    storage** (**NAS**) devices. Key aspects include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Types of disks**: Various types of disks are available, each with its unique
    characteristics, including capacity, speed, and durability'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage capacity**: Disks provide the storage capacity required for storing
    data, applications, and operating systems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Different types of disks offer varying levels of performance,
    impacting data access speeds and overall system responsiveness'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We still want to know when the flash drive was inserted into the USB and act
    (organize the files). Do we have a standardized way to do that? Fortunately, yes!
  prefs: []
  type: TYPE_NORMAL
- en: Open source to the rescue!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the dynamic and ever-evolving landscape of Linux, a story of collaboration
    and innovation unfolded with the emergence of XDG and freedesktop.org.
  prefs: []
  type: TYPE_NORMAL
- en: Birth of freedesktop.org
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the spring of 2000, a new chapter began with Havoc Pennington and his vision.
    Recognizing the fragmented state of the Linux desktop environment, he established
    freedesktop.org. It wasn’t just another organization; it was a beacon of collaboration,
    inviting developers from GNOME, KDE, and other projects to join hands. Their mission?
    To weave a tapestry of interoperability and shared technology across different
    desktop environments.
  prefs: []
  type: TYPE_NORMAL
- en: XDG – the standard bearer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Parallel to this, the **X Desktop Group** (**XDG**) emerged, focusing on crafting
    standards that would serve as bridges between the diverse desktop environments.
    They weren’t just creating guidelines; they were building the lingua franca for
    the Linux desktop world. Their contributions, such as the XDG Base Directory and
    Desktop Menu Specifications, were like puzzle pieces that fit perfectly, bringing
    a sense of order and compatibility to the once-chaotic landscape.
  prefs: []
  type: TYPE_NORMAL
- en: A symphony of collaboration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What set freedesktop.org and XDG apart was their approach. They didn’t dictate;
    they collaborated. They listened and adapted, creating solutions that resonated
    across various platforms. This wasn’t just about technology but about people,
    ideas, and the magic that happens when they come together.
  prefs: []
  type: TYPE_NORMAL
- en: In this tale of unity, XDG and freedesktop.org stand as beacons, illuminating
    the path toward a more integrated and user-friendly Linux experience. Their legacy
    is not just in the code and standards they’ve created, but in the spirit of cooperation
    they’ve fostered in the open source community.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve our goal, we’re using one of the core components of freedesktop.org:
    D-Bus.'
  prefs: []
  type: TYPE_NORMAL
- en: D-Bus – the communication conduit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: D-Bus, another brainchild nurtured in the ecosystem of freedesktop.org, is a
    message bus system that provides a simple way for applications to talk to one
    another and to the system. It’s like the postal service of the Linux world, delivering
    messages between applications, ensuring they can work together harmoniously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we interact with USB events, let’s dip a toe in the water with a simpler
    example: sending system notifications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to add the import of the `dbus` library, `github.com/godbus/dbus/v5`,
    after we should connect to the session bus and make sure that we’re deferring
    the release of the resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Look at the notification’s specification ([https://specifications.freedesktop.org/notification-spec/notification-spec-latest.html](https://specifications.freedesktop.org/notification-spec/notification-spec-latest.html))
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to use the connection to access the notification object to make
    a call for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the notification specification, the parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Type** | **Required** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `app_name` | `STRING` | False | The name of the application sending the notification.
    Can be blank. |'
  prefs: []
  type: TYPE_TB
- en: '| `replaces_id` | `UINT32` | False | The notification ID that this notification
    replaces. A value of `0` means that this notification won’t replace existing notifications.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `app_icon` | `STRING` | False | The program icon of the calling application.
    Can be an empty string, indicating no icon. |'
  prefs: []
  type: TYPE_TB
- en: '| `summary` | `STRING` | True | The summary text briefly describing the notification.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `body` | `STRING` | False | The detailed body text. Can be empty. |'
  prefs: []
  type: TYPE_TB
- en: '| `actions` | `as` (array of strings) | False | Actions that are sent as a
    list of pairs. Each even element in the list (starting at index 0) represents
    the identifier for the action. Each odd element is the localized string that will
    be displayed to the user. |'
  prefs: []
  type: TYPE_TB
- en: '| `hints` | `a{sv}` (array of string-variant pairs) | False | Hints that can
    be passed to the server from the client program. They can pass along information,
    such as the process PID or window ID. Can be empty. |'
  prefs: []
  type: TYPE_TB
- en: '| `expire_timeout` | `INT32` | True | The timeout time in milliseconds from
    the display of the notification, at which the notification should automatically
    close. |'
  prefs: []
  type: TYPE_TB
- en: 'Here’s what each variable represents and how it affects the notification:'
  prefs: []
  type: TYPE_NORMAL
- en: '`appName := "Organizer"`: `appName` specifies the name of the application sending
    the notification. In this case, the notification will appear to come from an application
    named “Super App.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replacesID := uint32(0)`: `replacesID` is used to replace an existing notification.
    A value of `0` means this new notification will not replace any existing notification.
    If it were a non-zero value, it would attempt to replace a notification with that
    ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`appIcon := "view-refresh"`: `appIcon` specifies the icon of the application
    sending the notification. An empty string `""` indicates that no icon will be
    used. If a path or icon name were provided, it would display that icon with the
    notification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`summary := "Organizer is done!"`: `summary` is a brief text that describes
    the notification. In this case, the summary is “Organizer is done!”, which will
    likely be shown as the title or headline of the notification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`body := fmt.Sprintf("The files at %s were successfully organized.", "/dev/sdc")`:
    `body` is the detailed text of the notification, providing more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`actions := []string{}`: `actions` are used to define interactive elements
    or buttons in the notification. An empty `[]string{}` slice means no actions or
    buttons will be added to the notification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hints := map[string]dbus.Variant{}`: `hints` are additional properties or
    data that can be used to modify the appearance or behavior of the notification.
    An empty `map[string]dbus.Variant{}` map implies that no additional hints are
    provided. Hints can include things such as a sound file to play, urgency level,
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expireTimeout := int32(5000)`: `expireTimeout` specifies the duration (in
    milliseconds) before the notification automatically closes. A value of `5000`
    means the notification will close after five seconds. A value of `-1` would mean
    the notification’s expiration depends on the notification server’s settings, and
    `0` would mean the notification never expires automatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: App icons
  prefs: []
  type: TYPE_NORMAL
- en: You can find more about app icons on the specification page ([https://specifications.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html](https://specifications.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we call the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `usb/example2` directory, we run the program by executing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: A new system notification will pop up on the screen! That’s cool, huh?
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with USB events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already have a way to organize the flash drive with the file extension, a
    function to discover the file mount, and a way to notify the user of the task’s
    completion. Now, we are ready to interact with the system event triggered when
    a new flash drive is connected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, we need to use the `dbus` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to connect to the bus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we’re interested in listening to the D-Bus events, we need to give the
    D-Bus connection a way to notify our program. We do that with a channel of type
    `*dbus.Signal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Remember, we’re not interested in all signals available in the bus; we just
    want the event representing the USB device being inserted. In our case, the signal
    name is `"org.freedesktop.DBus.ObjectManager.InterfacesAdded"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In D-Bus, we have a special entity to do that. It’s called a match rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '`matchRule := "``type=''signal'',sender=''org.freedesktop.UDisks2'',interface=''org.freedesktop.DBus.ObjectManager'',path=''/org/freedesktop/UDisks2''"`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our program, `matchRule` is a string that defines a D-Bus match rule. The
    components of the match rule are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type=''signal''`: Indicates that your program wants to listen for signals
    (as opposed to other types of D-Bus messages such as method calls or errors).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sender=''org.freedesktop.UDisks2''`: Specifies that the signals should come
    from `org.freedesktop.UDisks2`, which is the D-Bus service provided by UDisks2
    (a service for managing disk drives and related resources in Linux).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`interface=''org.freedesktop.DBus.ObjectManager''`: Filters signals to those
    that are emitted by objects implementing the `org.freedesktop.DBus.ObjectManager`
    interface. This interface is used for managing and enumerating objects (such as
    disk drives, partitions, etc.) under a certain D-Bus service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path=''/org/freedesktop/UDisks2''`: Specifies the path of the objects from
    which signals should be received. This path corresponds to the UDisks2 service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following line uses the established D-Bus connection (`conn`) to call the
    `AddMatch` method on the D-Bus daemon. `AddMatch` is a method provided by D-Bus
    that tells the bus daemon to start forwarding the messages (signals, in this case)
    that match the given rule to your application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The details are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`conn.BusObject()`: Retrieves a proxy object for communicating with the bus
    daemon itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.Call(...)`: Calls a method on the bus daemon'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"org.freedesktop.DBus.AddMatch"`: The method used to tell the D-Bus system’s
    central service to only send messages that meet specific criteria to the application
    calling this method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0`: The flag for the method call, usually set to `0` in typical use cases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matchStr`: The match rule defined earlier, passed as an argument to the method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following code is a loop that listens for specific D-Bus signals and
    handles them accordingly. It is particularly focused on signals related to new
    interfaces being added in UDisks2, which is a service for managing disk drives
    in Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s break down the code step by step.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1 – Listening** **for signals**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This `for` loop iterates over a channel (`ch`) that receives D-Bus signals.
    Each item received over the channel is a `signal`, representing a D-Bus signal
    that has been sent to your application.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2 – Checking** **signal name**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The code checks whether the signal’s name is `"org.freedesktop.DBus.ObjectManager.InterfacesAdded"`.
    This signal is emitted when a new interface (such as a new block device) is added
    to the object manager in UDisks2.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3 – Extracting the** **object path**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This line extracts the first element of the signal’s body, which should be the
    object path of the newly added interface. The object path identifies the specific
    object (such as a disk or partition) within UDisks2.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 4 – Checking the** **path prefix**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The code checks whether the path of the new interface starts with `"/org/freedesktop/UDisks2/block_devices/"`.
    This prefix indicates that the interface is a block device, such as a hard drive
    or USB flash drive.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 5 – Accessing** **device properties**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If the path matches, the code proceeds to interact with that specific device.
    It does so by calling the `org.freedesktop.DBus.Properties.Get` method on the
    device object to get its properties. The properties of interest are from the `"org.freedesktop.UDisks2.Block"`
    interface, specifically the `"``Device"` property.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 6 –** **Error handling**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This checks whether there was an error in the method call to get the device
    properties. If there was an error, it prints an error message and continues to
    the next signal.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 7 – Printing** **mount points**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This extracts the `Device` property from the response (`deviceProps.Body[0]`).
    The property is cast to the `dbus.Variant` type, which is a generic container
    for any D-Bus data type. The value is then printed out. This value typically represents
    the file path to the device node (such as `/dev/sda1` for a disk partition).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `appendix-a/usb/example4` directory, we execute the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see the name as something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To understand this output, we should make clear the difference between storage
    devices and partitions.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the `/dev/sdc` and `/dev/sdc1` outputs in Linux is related
    to how storage devices and their partitions are represented in the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: '`/dev/sdc` represents the entire physical storage device. In Linux (and other
    Unix-like operating systems), storage devices such as hard drives, SSDs, and USB
    flash drives are represented as files in the `/dev` directory. The name `sdc`
    is typically assigned based on the order in which the system recognizes the device
    (following `sda`, `sdb`, and so on).'
  prefs: []
  type: TYPE_NORMAL
- en: When the program output shows `/dev/sdc`, it refers to the whole storage device,
    which includes all its partitions and data.
  prefs: []
  type: TYPE_NORMAL
- en: '`/dev/sdc1` represents a specific partition on the storage device. The number
    at the end (`1` in this case) signifies the first partition on the `sdc` device.'
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed earlier, partitions are subdivisions of a physical storage device.
    They allow you to segment the device into different sections, each of which can
    be formatted with a different filesystem or used for different purposes.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, `/dev/sdc1` is the first partition on the `/dev/sdc` storage
    device.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practical terms, the differences in accessing both are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing `/dev/sdc` would be for operations that affect the entire disk, such
    as disk formatting, partitioning, and obtaining disk-wide information (such as
    total size, disk health, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing `/dev/sdc1` would be for operations specific to that partition, such
    as mounting the partition to access its filesystem, checking the filesystem health,
    or formatting just that partition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that the path we choose here is to inspect all partitions available.
  prefs: []
  type: TYPE_NORMAL
- en: But wait! Since the D-Bus has the information on the partitions, it would be
    nice if we could access the mount point information from it instead of parsing
    the `/``proc/mounts` file.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we can!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at how we can do that in our brand-new `mountPoints` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an explanation of how the function works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Connection to D-Bus: It starts by establishing a connection to the D-Bus system
    bus using `dbus.ConnectSystemBus()`. The system bus is used to interact with system-level
    services such as UDisks2\. If there’s an error in connecting to the system bus,
    it returns an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Initialization: It initializes an empty `mountPoints` slice to store the mount
    points found for the provided devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Device name iteration: Using a `for` loop, the function then iterates through
    each device name in the `deviceNames` slice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'D-Bus object path: For each device name, it constructs the D-Bus object path
    by joining it with the UDisks2 block device path. This is done using `path.Join("/org/freedesktop/UDisks2/block_devices",
    deviceName)`. This object path specifies the D-Bus object representing the block
    device with the given name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'D-Bus object and method call: It creates a D-Bus object using `conn.Object`
    with the UDisks2 service name and the constructed object path. Then, it calls
    the `"org.freedesktop.DBus.Properties.GetAll"` D-Bus method on the object to retrieve
    all properties of the `"org.freedesktop.UDisks2.Filesystem"` interface. The result
    is stored in the result map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mount points extraction: The function checks whether the `"MountPoints"` property
    exists in the resulting map using `result["MountPoints"]`. If it exists, it extracts
    the mount points as a slice of byte slices (`[][]byte`) from the property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Conversion to strings: It then iterates through the byte slices of mount points
    and converts them to strings. These strings represent the mount points of the
    device. The mount points are appended to the `mountPoints` slice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Error handling: If no mount points were found for a device or if there was
    an error in the D-Bus method call, it returns an error indicating that no mount
    points were found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Result return: Finally, if at least one mount point was found, the function
    returns the `mountPoints` slice containing all the mount points and nil as the
    error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we know how to organize the files, listen to storage device events, and
    find the mount points. We are ready to glue all these things up.
  prefs: []
  type: TYPE_NORMAL
- en: The full functional example is available in the git repository. Try yourself
    to organize a messy flash drive!
  prefs: []
  type: TYPE_NORMAL
- en: Bluetooth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine, if you will, a world where your trusty smartwatch does more than just
    count your steps or remind you of meetings. In this world, my Samsung Galaxy Watch
    Active 2 becomes the guardian of my workstation, a faithful ally ensuring that
    my data remains secure from the wandering eyes of overly curious colleagues. Yes,
    you read that right.
  prefs: []
  type: TYPE_NORMAL
- en: Welcome to my journey of turning a simple wearable into a tool of ingenious
    workstation security.
  prefs: []
  type: TYPE_NORMAL
- en: 'There I was, sitting in my cubicle adorned with the obligatory tech paraphernalia,
    when a thought struck me. In an office where “snooping” is often disguised as
    “accidental glances,” could I not leverage my beloved smartwatch to enhance my
    workstation’s security? The mission was set: to lock my screen automatically whenever
    I stepped away, leaving my nosy colleagues to stare at a pristine lock screen.'
  prefs: []
  type: TYPE_NORMAL
- en: The strategy was straightforward yet elegant. I would employ a program that
    diligently monitored the Bluetooth signal strength (RSSI) between my Linux machine
    and my smartwatch. Once the signal dipped below a certain threshold – a subtle
    hint that I’d abandoned my desk, possibly in pursuit of another coffee – the script
    would gallantly secure my workstation. Pure genius, isn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the smartwatch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step was simple. The following program will use the `github.com/muka/go-bluetooth/api`
    Bluetooth library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how you can get the default Bluetooth adapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'With the adapter, let’s start the device discovery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now start to retrieve and display device information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s examine this code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`adapter.GetDevices()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This retrieves a list of discovered Bluetooth devices.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If it fails to retrieve the devices, an error is printed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The program then iterates (`for` loop) through each device.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`device.GetProperties()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This obtains properties of each device, such as the name, address, and **received
    signal strength** **indicator** (**RSSI**).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If fetching properties for a device fails, it prints an error message and continues
    with the next device.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, it prints each device’s name, address, and RSSI. RSSI measures how well
    your device can hear a signal from an access point or router, which helps determine
    the distance from the device.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Wait a minute! RSSI? What is that? Good question! Let’s explore this concept.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding RSSI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine RSSI as office gossip – you hear it loud and clear when you’re near
    the source (0 dB, the office rumor mill). Still, as you stroll away to your cubicle
    fortress, the details get fuzzier until they’re just whispers (-100 dB, practically
    the land of myths and legends). This RSSI, a creature of decibels, roams from
    0 (gossip central) to -100 (the realm of forgotten tales), with its strength varying
    based on which Bluetooth beast it rides – each with its quirks.
  prefs: []
  type: TYPE_NORMAL
- en: Distance estimation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: RSSI, much like our ability to hear office gossip, hints at how close we are
    to the source. Higher values (less negative, let’s say -30 dB) suggest you’re
    probably hovering over someone’s shoulder, while lower values (more negative,
    such as -80 dB) mean you’re safely in your cubicle, shielded from the chatter.
    But here’s the catch – RSSI is about as reliable in measuring exact distance as
    using coffee aroma is in navigating to the kitchen. It’s a wild mix of signal
    strength, the mood of the office walls, and whether the microwave is on its interference
    spree.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the proximity threshold
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now, let’s talk about setting this so-called proximity threshold. This is like
    deciding how close you must be to hear the gossip. Say, -70 dBm – close enough
    to catch the gist but far away enough to feign ignorance. It’s a game of trial
    and error, much like finding the perfect spot in the office to catch Wi-Fi but
    avoid awkward conversations. And remember, just like the office layout changes
    (thanks to our restless office manager), this threshold might need some tweaking
    occasionally.
  prefs: []
  type: TYPE_NORMAL
- en: Applications
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: RSSI isn’t just about eavesdropping on office tales. In our tech haven, it’s
    the silent ninja triggering actions when devices cozy up – like magically unlocking
    doors as you approach (no more fumbling for keys!) or clocking you in because
    attendance systems are sneaky like that. And for the indoor positioning? It’s
    the modern-day Marauder’s Map, minus the accuracy to catch someone sneaking to
    the break room.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: But here’s the fun part – RSSI-based proximity detection is as precise as our
    office weather predictions. It’s less about measuring exact distances and more
    about wild guesses of “nearness.” Plus, the RSSI value changes its mind more often
    than our boss changes meeting schedules, thanks to walls, microwaves, and other
    tech gizmos throwing tantrums.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation considerations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’re planning to harness the power of RSSI, prepare for some calibration
    wizardry – because each device and office corner has its own tale to tell. And
    to smooth out RSSI’s mood swings, a bit of filtering magic (such as a moving average
    spell) can keep your proximity detection from going on a rollercoaster ride.
  prefs: []
  type: TYPE_NORMAL
- en: After running this program a couple of times, I discovered RSSI -70 dBm works
    very well. So, let’s update our program to use this value.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s take a periodic check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, change how we do our pooling and process the devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The updated program includes several key changes from the previous one, focusing
    on implementing periodic polling using a ticker. Here’s what has changed from
    the previous program: the program executed a one-time scan for Bluetooth devices
    and then exited. It did not continuously monitor for device presence or changes.
    The scanning for devices and checking their properties was done immediately and
    only once when the program was run. There was no mechanism in place for the program
    to periodically check the status of Bluetooth devices.'
  prefs: []
  type: TYPE_NORMAL
- en: So, in the updated program, we are using uses a `time.Ticker` to create periodic
    events every 10 seconds, allowing it to monitor changes and new devices over time.
  prefs: []
  type: TYPE_NORMAL
- en: The use of `defer` to ensure `ticker.Stop()` is called when the program exits,
    which helps in managing resources effectively and avoiding potential leaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows the program to continuously monitor the Bluetooth environment.
    Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we use the `select` statement for synchronization. The program now waits
    on the ticker’s channel using a `select` statement. This is a more efficient way
    to handle asynchronous, periodic events in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The scanning for devices and checking their properties is now placed inside
    an infinite loop, which is triggered by the ticker’s channel.
  prefs: []
  type: TYPE_NORMAL
- en: These changes make the program more suitable for our scenario, where continuous
    monitoring of Bluetooth devices is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it’s time to take action: lock the screen!'
  prefs: []
  type: TYPE_NORMAL
- en: Locking the screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the story of this automation unfolded, we reached its climax – dynamically
    detecting the smartwatch and responding in real time. The plot was simple yet
    effective: should the watch wander beyond the threshold of -70 dBm, akin to stepping
    out of an invisible circle, my workstation would lock itself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The moment of truth arrived each time the RSSI sang below -70 dBm. The program
    would execute the lock command. This function should be more than enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we should call the function when at our proposed condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Enter xdg-screensaver
  prefs: []
  type: TYPE_NORMAL
- en: xdg-screensaver is a command-line tool born from the need for a standardized
    way to control the screensaver across different desktop environments. In the past,
    each environment had its own way of handling screensavers, leading to compatibility
    headaches for developers and users alike.
  prefs: []
  type: TYPE_NORMAL
- en: xdg-screensaver stepped in as a unifier. It provided a common interface, allowing
    applications to seamlessly interact with the screensaver, regardless of the underlying
    desktop environment. This tool is a direct beneficiary of the standardization
    efforts championed by XDG, showcasing how abstract standards can lead to tangible,
    user-friendly solutions.
  prefs: []
  type: TYPE_NORMAL
- en: This was the crescendo of my symphony – the locking of the screen, as seamless
    as the closing of a book after a captivating chapter. It was a dance of technology
    and logic, playing out on the grand stage of my workstation.
  prefs: []
  type: TYPE_NORMAL
- en: XDG dilemma
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Word of my creation spread like wildfire across the cubicles. Colleagues, intrigued
    by the blend of convenience and security it offered, started flocking to my desk,
    their eyes wide with curiosity. “Can we use this too?” they asked eagerly, their
    voices a blend of excitement and a hint of envy.
  prefs: []
  type: TYPE_NORMAL
- en: 'After patting myself on the back for creating an automation that locked my
    computer when my smartwatch moved away, I hit a snag: the command I used to lock
    the screen, xdg-screensaver, didn’t work for everyone. Here’s a simpler take on
    what I discovered and what it means.'
  prefs: []
  type: TYPE_NORMAL
- en: Think of xdg-screensaver as a common tool that is supposed to work on most Linux
    computers. But, just like people in different countries speak different languages,
    computers in our office use different types of systems or “environments.” And
    it turns out that xdg-screensaver doesn’t speak the language of some of these
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: The Wayland conundrum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The plot thickened with the introduction of Wayland, the avant-garde system
    many had adopted. This new player in the game didn’t play well with xdg-screensaver,
    leaving those users out in the cold. The program, once the hero of the hour, now
    faced its limitation, its Achilles’ heel.
  prefs: []
  type: TYPE_NORMAL
- en: This journey took me into the depths of Bluetooth protocols, signal fluctuations,
    and the peculiarities of various desktop environments. Each discovery was like
    peeling back a layer, revealing more about the enigmatic nature of Bluetooth interactions
    and the challenges of creating a one-size-fits-all solution.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the true purpose of this journey was not to deliver an immediate solution
    but to unravel the mysteries of Bluetooth automation itself. The real victory
    lay in the collective understanding we were gaining – an exploration of the nuances
    of technology that govern our daily interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Now, each query about automation is met with a thoughtful conversation about
    the complexities of Bluetooth automation. The office buzzes with a newfound appreciation
    for the challenges and intricacies of creating technology that adapts to diverse
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the fundamentals of hardware automation, particularly
    in the context of system programming. Key lessons included understanding the interaction
    between software and physical hardware devices such as wearables and USB flash
    drives, the basics of USB technology, and the development of a program for automating
    file organization on a flash drive. Additionally, you have learned about an experiment
    involving a Bluetooth application designed to lock the screen, illustrating a
    practical application of hardware-software interaction.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter covered practical aspects such as reading from the storage, understanding
    the `/proc/mounts` file in Linux, and the differences between partitions, blocks,
    devices, and disks. It also included how Bluetooth can be used to determine distance
    between based on the RSSI.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding hardware automation, particularly in the context of USB and Bluetooth
    technologies, is common knowledge for modern programmers working with automation.
    These skills enable you to develop practical solutions for everyday technological
    challenges.
  prefs: []
  type: TYPE_NORMAL
