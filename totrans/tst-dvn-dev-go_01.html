<html><head></head><body>
<div id="_idContainer018">
<h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor015"/><span class="koboSpan" id="kobo.1.1">1</span></h1>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/><span class="koboSpan" id="kobo.2.1">Getting to Grips with Test-Driven Development</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Programs and software have never been more complex than they are today. </span><span class="koboSpan" id="kobo.3.2">From my experience, the typical tech startup setup involves deployment to the cloud, distributed databases, and a variety of software integrations from the very beginning of the project. </span><span class="koboSpan" id="kobo.3.3">As we use software and consume data at unprecedented rates, the expectation of high availability and scalability has become standard for all the services we </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">interact with.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">So, why should we care about testing when we are so busy delivering complex functionality in fast-paced, high-growth environments? </span><span class="koboSpan" id="kobo.5.2">Simply put, to verify and prove that the code you write behaves and performs to the expectations and requirements of your project. </span><span class="koboSpan" id="kobo.5.3">This is important to you as the software professional, as well as to your team and </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">product manager.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we’ll look at the </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">Agile</span></strong><span class="koboSpan" id="kobo.9.1"> technique of </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">Test-Driven Development</span></strong><span class="koboSpan" id="kobo.11.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.12.1">TDD</span></strong><span class="koboSpan" id="kobo.13.1">) and how we can use it to verify production code. </span><span class="koboSpan" id="kobo.13.2">TDD puts test writing before implementation, ensuring that test scripts cover and change with requirements. </span><span class="koboSpan" id="kobo.13.3">Its techniques allow us to deliver quality, well-tested, and maintainable code. </span><span class="koboSpan" id="kobo.13.4">The task of software testing is a necessity for all programmers, and TDD seamlessly incorporates test writing into the code </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">delivery process.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">This chapter begins our exploration into the world of testing. </span><span class="koboSpan" id="kobo.15.2">It will give you the required understanding of TDD and its main techniques. </span><span class="koboSpan" id="kobo.15.3">Defining and setting these fundamentals firmly in our minds will set the stage for the later implementation of automated testing </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">in Go.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">In this chapter, we’ll cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.19.1">The world and fundamentals </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">of TDD</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">The benefits and use </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">of TDD</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Alternatives </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">to TDD</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.25.1">Test metrics</span></span></li>
</ul>
<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/><span class="koboSpan" id="kobo.26.1">Exploring the world of TDD</span></h1>
<p><span class="koboSpan" id="kobo.27.1">In a nutshell, TDD </span><a id="_idIndexMarker000"/><span class="koboSpan" id="kobo.28.1">is a technique that allows us to write automated tests with short feedback loops. </span><span class="koboSpan" id="kobo.28.2">It is an iterative process that incorporates testing into the software development process, allowing developers to use the same techniques for writing their tests as they use for writing </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">production code.</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">TDD was created as an Agile working practice, as it allows teams to deliver code in an iterative process, consisting of writing functional code, verifying new code with tests, and iteratively refactoring new code, </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">if required.</span></span></p>
<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/><span class="koboSpan" id="kobo.32.1">Introduction to the Agile methodology</span></h2>
<p><span class="koboSpan" id="kobo.33.1">This precursor to the</span><a id="_idIndexMarker001"/><span class="koboSpan" id="kobo.34.1"> Agile movement was</span><a id="_idIndexMarker002"/><span class="koboSpan" id="kobo.35.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.36.1">waterfall methodology</span></strong><span class="koboSpan" id="kobo.37.1">, which was the most popular project management technique. </span><span class="koboSpan" id="kobo.37.2">This process involves delivering software projects in stages, with work starting on each stage once the stage before it is completed, just like water flows downstream. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.38.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.39.1">.1</span></em><span class="koboSpan" id="kobo.40.1"> shows the five stages of the </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">waterfall methodology:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer007">
<span class="koboSpan" id="kobo.42.1"><img alt="Figure 1.1 – The five stages of the waterfall methodology " src="image/Figure_1.1_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.43.1">Figure 1.1 – The five stages of the waterfall methodology</span></p>
<p><span class="koboSpan" id="kobo.44.1">Intuition from manufacturing and </span><a id="_idIndexMarker003"/><span class="koboSpan" id="kobo.45.1">construction projects might suggest that it is natural to divide the software delivery process into sequential phases, gathering and formulating all requirements at the start of the project. </span><span class="koboSpan" id="kobo.45.2">However, this way of working poses three difficulties when used to deliver large </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">software projects:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.47.1">Changing the course of the project or requirements is difficult. </span><span class="koboSpan" id="kobo.47.2">A working solution is only available at the end of the process, requiring verification of a large deliverable. </span><span class="koboSpan" id="kobo.47.3">Testing an entire project is much more difficult than testing </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">small deliverables.</span></span></li>
<li><span class="koboSpan" id="kobo.49.1">Customers need to decide all of their requirements in detail at the beginning of the project. </span><span class="koboSpan" id="kobo.49.2">The waterfall allows for minimal customer involvement, as they are only consulted in the requirements and </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">verification phases.</span></span></li>
<li><span class="koboSpan" id="kobo.51.1">The process requires detailed documentation, which specifies both requirements and the software design approach. </span><span class="koboSpan" id="kobo.51.2">Crucially, the project documentation includes timelines and estimates that the clients need to approve prior to </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">project initiation.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.53.1">The waterfall model is all about planning work</span></p>
<p class="callout"><span class="koboSpan" id="kobo.54.1">Project management with the waterfall methodology allows you to plan your project in well-defined, linear phases. </span><span class="koboSpan" id="kobo.54.2">This approach is intuitive and suitable for projects with clearly defined goals and boundaries. </span><span class="koboSpan" id="kobo.54.3">In practice, however, the waterfall model lacks the flexibility and iterative approach required for delivering complex </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">software projects.</span></span></p>
<p><span class="koboSpan" id="kobo.56.1">A better way of working</span><a id="_idIndexMarker004"/><span class="koboSpan" id="kobo.57.1"> named </span><strong class="bold"><span class="koboSpan" id="kobo.58.1">Agile</span></strong><span class="koboSpan" id="kobo.59.1"> emerged, which could address the challenges of the waterfall methodology. </span><span class="koboSpan" id="kobo.59.2">TDD relies</span><a id="_idIndexMarker005"/><span class="koboSpan" id="kobo.60.1"> on the principles of the Agile methodology. </span><span class="koboSpan" id="kobo.60.2">The literature on Agile working practices is extensive, so we won’t be looking at Agile in detail, but a brief understanding of the origins of TDD will allow us to understand its approach and get into </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">its mindset.</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.62.1">Agile software development</span></em><span class="koboSpan" id="kobo.63.1"> is an umbrella term for multiple code delivery and project planning</span><a id="_idIndexMarker006"/><span class="koboSpan" id="kobo.64.1"> practices</span><a id="_idIndexMarker007"/><span class="koboSpan" id="kobo.65.1"> such as </span><strong class="bold"><span class="koboSpan" id="kobo.66.1">SCRUM</span></strong><span class="koboSpan" id="kobo.67.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.68.1">Kanban</span></strong><span class="koboSpan" id="kobo.69.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.70.1">Extreme Programming</span></strong><span class="koboSpan" id="kobo.71.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.72.1">XP</span></strong><span class="koboSpan" id="kobo.73.1">), </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">and</span></span><span class="No-Break"><a id="_idIndexMarker008"/></span><span class="No-Break"><span class="koboSpan" id="kobo.75.1"> TDD.</span></span></p>
<p><span class="koboSpan" id="kobo.76.1">As implied by its name, it is all about the ability to respond and adapt to change. </span><span class="koboSpan" id="kobo.76.2">One of the main disadvantages of the waterfall way of working was its inflexibility, and Agile was designed to address </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">this issue.</span></span></p>
<p><span class="koboSpan" id="kobo.78.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.79.1">Agile manifesto</span></strong><span class="koboSpan" id="kobo.80.1"> was</span><a id="_idIndexMarker009"/><span class="koboSpan" id="kobo.81.1"> written and signed by 17 software engineering leaders and pioneers in 2001. </span><span class="koboSpan" id="kobo.81.2">It outlines the 4 core values and 12 central principles of Agile. </span><span class="koboSpan" id="kobo.81.3">The manifesto is available freely </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">at </span></span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">agilemanifesto.org</span></span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.85.1">The four core Agile</span><a id="_idIndexMarker010"/><span class="koboSpan" id="kobo.86.1"> values highlight the spirit of </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">the movement:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.88.1">Individuals and interactions over processes and tools</span></strong><span class="koboSpan" id="kobo.89.1">: This means that the team involved in the delivery of the project is more important than their technical tools </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">and processes.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.91.1">Working software over comprehensive documentation</span></strong><span class="koboSpan" id="kobo.92.1">: This means that delivering working functionality to customers is the number one priority. </span><span class="koboSpan" id="kobo.92.2">While documentation is important, teams should always focus on consistently </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">delivering value.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.94.1">Customer collaboration over contract negotiation</span></strong><span class="koboSpan" id="kobo.95.1">: This means that customers should be involved in a feedback loop over the lifetime of the project, ensuring that the project and work continue to deliver value and satisfy their needs </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">and requirements.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.97.1">Responding to change over following a plan</span></strong><span class="koboSpan" id="kobo.98.1">: This means that teams should be responsive to change over following a predefined plan or roadmap. </span><span class="koboSpan" id="kobo.98.2">The team should be able to</span><a id="_idIndexMarker011"/><span class="koboSpan" id="kobo.99.1"> pivot and change direction </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">whenever required.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.101.1">Agile is all about people</span></p>
<p class="callout"><span class="koboSpan" id="kobo.102.1">The Agile methodology </span><a id="_idIndexMarker012"/><span class="koboSpan" id="kobo.103.1">is not a prescriptive list of practices. </span><span class="koboSpan" id="kobo.103.2">It is all about teams working together to overcome uncertainty and change during the life cycle of a project. </span><span class="koboSpan" id="kobo.103.3">Agile teams are interdisciplinary, consisting of engineers, software testing professionals, product managers, and more. </span><span class="koboSpan" id="kobo.103.4">This ensures that the team members with a variety of skills collaborate to deliver the software project as </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">a whole.</span></span></p>
<p><span class="koboSpan" id="kobo.105.1">Unlike the waterfall model, the stages of the </span><a id="_idIndexMarker013"/><span class="koboSpan" id="kobo.106.1">Agile software delivery methodology repeat, focusing on delivering software in small increments or iterations, as opposed to the big deliverables of waterfall. </span><span class="koboSpan" id="kobo.106.2">In Agile nomenclature, these </span><a id="_idIndexMarker014"/><span class="koboSpan" id="kobo.107.1">iterations are </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">called </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.109.1">sprints</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.111.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.112.1">.2</span></em><span class="koboSpan" id="kobo.113.1"> depicts the</span><a id="_idIndexMarker015"/><span class="koboSpan" id="kobo.114.1"> stages of Agile </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">project delivery:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer008">
<span class="koboSpan" id="kobo.116.1"><img alt="Figure 1.2 – The stages of Agile software delivery " src="image/Figure_1.2_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.117.1">Figure 1.2 – The stages of Agile software delivery</span></p>
<p><span class="koboSpan" id="kobo.118.1">Let’s look at the cyclical stages of Agile </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">software delivery:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.120.1">We begin with the </span><strong class="bold"><span class="koboSpan" id="kobo.121.1">Plan</span></strong><span class="koboSpan" id="kobo.122.1"> phase. </span><span class="koboSpan" id="kobo.122.2">The product owner discusses project requirements that will be delivered in the current sprint with key stakeholders. </span><span class="koboSpan" id="kobo.122.3">The outcome of this phase is the prioritized list of client requirements that will be implemented in </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">this sprint.</span></span></li>
<li><span class="koboSpan" id="kobo.124.1">Once the requirements and scope of the project are settled, the </span><strong class="bold"><span class="koboSpan" id="kobo.125.1">Design</span></strong><span class="koboSpan" id="kobo.126.1"> phase begins. </span><span class="koboSpan" id="kobo.126.2">This phase involves both technical architecture design, as well as UI/UX design. </span><span class="koboSpan" id="kobo.126.3">This phase builds on the requirements from the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.127.1">Plan</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.128.1"> phase.</span></span></li>
<li><span class="koboSpan" id="kobo.129.1">Next, the </span><strong class="bold"><span class="koboSpan" id="kobo.130.1">Implement</span></strong><span class="koboSpan" id="kobo.131.1"> phase</span><a id="_idIndexMarker016"/><span class="koboSpan" id="kobo.132.1"> begins. </span><span class="koboSpan" id="kobo.132.2">The designs are used as the guide from which we implement the scoped functionality. </span><span class="koboSpan" id="kobo.132.3">Since the sprint is short, if any discrepancies are found during implementation, then the team can easily move to </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">earlier phases.</span></span></li>
<li><span class="koboSpan" id="kobo.134.1">As soon as a deliverable is complete, the </span><strong class="bold"><span class="koboSpan" id="kobo.135.1">Test</span></strong><span class="koboSpan" id="kobo.136.1"> phase begins. </span><span class="koboSpan" id="kobo.136.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.137.1">Test</span></strong><span class="koboSpan" id="kobo.138.1"> phase runs almost concurrently with the </span><strong class="bold"><span class="koboSpan" id="kobo.139.1">Implement</span></strong><span class="koboSpan" id="kobo.140.1"> phase, as test specifications can be written as soon as the </span><strong class="bold"><span class="koboSpan" id="kobo.141.1">Design</span></strong><span class="koboSpan" id="kobo.142.1"> phase is completed. </span><span class="koboSpan" id="kobo.142.2">A deliverable cannot be considered finished until its tests have passed. </span><span class="koboSpan" id="kobo.142.3">Work can move back and forth between the </span><strong class="bold"><span class="koboSpan" id="kobo.143.1">Implement</span></strong><span class="koboSpan" id="kobo.144.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.145.1">Test</span></strong><span class="koboSpan" id="kobo.146.1"> phases, as the engineers fix any </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">identified defects.</span></span></li>
<li><span class="koboSpan" id="kobo.148.1">Finally, once all testing and implementation are completed successfully, the </span><strong class="bold"><span class="koboSpan" id="kobo.149.1">Release</span></strong><span class="koboSpan" id="kobo.150.1"> phase begins. </span><span class="koboSpan" id="kobo.150.2">This phase completes any client-facing documentation or release notes. </span><span class="koboSpan" id="kobo.150.3">At the end of this phase, the sprint is considered closed. </span><span class="koboSpan" id="kobo.150.4">A new sprint can begin, following</span><a id="_idIndexMarker017"/><span class="koboSpan" id="kobo.151.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">same cycle.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.153.1">The customer gets a new deliverable at the end of each sprint, enabling them to see whether the product still suits their requirements and inform changes for future sprints. </span><span class="koboSpan" id="kobo.153.2">The deliverable of each sprint is tested before it is released, ensuring that later sprints do not break existing functionality and deliver new functionality. </span><span class="koboSpan" id="kobo.153.3">The scope and effort of the testing performed are limited to exercising the functionality developed during </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">the sprint.</span></span></p>
<p><span class="koboSpan" id="kobo.155.1">One of the signatories of the Agile manifesto</span><a id="_idIndexMarker018"/><span class="koboSpan" id="kobo.156.1"> was software engineer Kent Beck. </span><span class="koboSpan" id="kobo.156.2">He is credited with having rediscovered and formalized the methodology </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">of TDD.</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">Since then, Agile has been highly successful for many teams, becoming an industry standard because it enables them to verify functionality as it is being delivered. </span><span class="koboSpan" id="kobo.158.2">It combines testing with software delivery and refactoring, removing the separation between the code writing and testing process, and shortening the feedback loop between the engineering team and the customer requirements. </span><span class="koboSpan" id="kobo.158.3">This shorter loop is the principle that gives flexibility </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">to Agile.</span></span></p>
<p><span class="koboSpan" id="kobo.160.1">We will focus on learning how to leverage its process and techniques in our own </span><strong class="bold"><span class="koboSpan" id="kobo.161.1">Go</span></strong><span class="koboSpan" id="kobo.162.1"> projects throughout the chapters of </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">this book.</span></span></p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/><span class="koboSpan" id="kobo.164.1">Types of automated tests</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.165.1">Automated testing</span></strong><span class="koboSpan" id="kobo.166.1"> suites </span><a id="_idIndexMarker019"/><span class="koboSpan" id="kobo.167.1">are tests that involve tools and frameworks to verify the behavior of software systems. </span><span class="koboSpan" id="kobo.167.2">They provide a repeatable way of performing the verification of system requirements. </span><span class="koboSpan" id="kobo.167.3">They are the norm for Agile teams, who must test their systems after each sprint and release to ensure that new functionality is shipped without disrupting </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">old/existing functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.169.1">All automated tests define their inputs and expected outputs according to the requirements of the system under test. </span><span class="koboSpan" id="kobo.169.2">We will divide them into several types of tests according to </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">three criteria:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.171.1">The amount of knowledge they have of </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">the system</span></span></li>
<li><span class="koboSpan" id="kobo.173.1">The type of requirement </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">they verify</span></span></li>
<li><span class="koboSpan" id="kobo.175.1">The </span><a id="_idIndexMarker020"/><span class="koboSpan" id="kobo.176.1">scope of the functionality </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">they cover</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.178.1">Each test we will study will be described according to these </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">three traits.</span></span></p>
<h3><span class="koboSpan" id="kobo.180.1">System knowledge</span></h3>
<p><span class="koboSpan" id="kobo.181.1">As you can see in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.182.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.183.1">.3</span></em><span class="koboSpan" id="kobo.184.1">, automated </span><a id="_idIndexMarker021"/><span class="koboSpan" id="kobo.185.1">tests can be divided into three categories according to how much internal knowledge they have of the system </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">they test:</span></span></p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.187.1"><img alt="Figure 1.3 – Types of tests according to system knowledge " src="image/Figure_1.3_B18371.png"/></span></p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.188.1">Figure 1.3 – Types of tests according to system knowledge</span></p>
<p><span class="koboSpan" id="kobo.189.1">Let’s explore the three categories of </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">tests further:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.191.1">Black box tests</span></strong><span class="koboSpan" id="kobo.192.1"> are</span><a id="_idIndexMarker022"/><span class="koboSpan" id="kobo.193.1"> run from the perspective of the user. </span><span class="koboSpan" id="kobo.193.2">The internals of the system are treated as unknown by the test writer, as they would be to a user. </span><span class="koboSpan" id="kobo.193.3">Tests and expected outputs are formulated according to the requirement they verify. </span><span class="koboSpan" id="kobo.193.4">Black box tests tend not to be brittle if the internals of the </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">system change.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.195.1">White box tests</span></strong><span class="koboSpan" id="kobo.196.1"> are </span><a id="_idIndexMarker023"/><span class="koboSpan" id="kobo.197.1">run from the perspective of the developer. </span><span class="koboSpan" id="kobo.197.2">The internals of the system are fully known to the test writer, most likely a developer. </span><span class="koboSpan" id="kobo.197.3">These tests can be more detailed and potentially uncover hidden errors that black box testing cannot discover. </span><span class="koboSpan" id="kobo.197.4">White box tests are often brittle if the internals of the </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">system change.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.199.1">Gray box tests</span></strong><span class="koboSpan" id="kobo.200.1"> are a</span><a id="_idIndexMarker024"/><span class="koboSpan" id="kobo.201.1"> mixture of black box and white box tests. </span><span class="koboSpan" id="kobo.201.2">The internals of the system are partially known to the test writer, as they would be to a specialist or privileged user. </span><span class="koboSpan" id="kobo.201.3">These tests can verify more advanced use cases and requirements than black box tests (for example security or certain non-functional requirements) and are</span><a id="_idIndexMarker025"/><span class="koboSpan" id="kobo.202.1"> usually more time-consuming to write and run </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">as well.</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.204.1">Requirement types</span></h3>
<p><span class="koboSpan" id="kobo.205.1">In general, we should </span><a id="_idIndexMarker026"/><span class="koboSpan" id="kobo.206.1">provide tests that verify both the functionality and usability of </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">a system.</span></span></p>
<p><span class="koboSpan" id="kobo.208.1">For example, we could have all the correct functionality on a page, but if it takes 5+ seconds to load, users will abandon it. </span><span class="koboSpan" id="kobo.208.2">In this case, the system is functional, but it does not satisfy your </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">customers’ needs.</span></span></p>
<p><span class="koboSpan" id="kobo.210.1">We can further divide our automated tests into two categories, based on the type of requirement that </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">they verify:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.212.1">Functional tests</span></strong><span class="koboSpan" id="kobo.213.1">: These </span><a id="_idIndexMarker027"/><span class="koboSpan" id="kobo.214.1">tests cover the functionality of the system under test added during the sprint, with functional tests from prior sprints ensuring that there are no regressions in functionality in later sprints. </span><span class="koboSpan" id="kobo.214.2">These kinds of tests are usually black box tests, as these tests should be written and run according to the functionality that a typical user has </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">access to.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.216.1">Non-functional tests</span></strong><span class="koboSpan" id="kobo.217.1">: These </span><a id="_idIndexMarker028"/><span class="koboSpan" id="kobo.218.1">tests cover all the aspects of the system that are not covered by functional requirements but affect the user experience and functioning of the system. </span><span class="koboSpan" id="kobo.218.2">These tests cover aspects such as performance, usability, and security aspects. </span><span class="koboSpan" id="kobo.218.3">These kinds of tests are usually white-box tests, as they usually need to be formulated according to </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">implementation </span></span><span class="No-Break"><a id="_idIndexMarker029"/></span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">details.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.221.1">Correctness and usability testing</span></p>
<p class="callout"><span class="koboSpan" id="kobo.222.1">Tests that verify the correctness of the </span><a id="_idIndexMarker030"/><span class="koboSpan" id="kobo.223.1">system are known as </span><strong class="bold"><span class="koboSpan" id="kobo.224.1">functional tests</span></strong><span class="koboSpan" id="kobo.225.1">, while tests that verify the usability and performance of the</span><a id="_idIndexMarker031"/><span class="koboSpan" id="kobo.226.1"> system are known as </span><strong class="bold"><span class="koboSpan" id="kobo.227.1">non-functional tests</span></strong><span class="koboSpan" id="kobo.228.1">. </span><span class="koboSpan" id="kobo.228.2">Common non-functional tests are performance tests, load tests, and </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">security tests.</span></span></p>
<h3><span class="koboSpan" id="kobo.230.1">The testing pyramid</span></h3>
<p><span class="koboSpan" id="kobo.231.1">An important concept of testing</span><a id="_idIndexMarker032"/><span class="koboSpan" id="kobo.232.1"> in Agile is </span><strong class="bold"><span class="koboSpan" id="kobo.233.1">the testing pyramid</span></strong><span class="koboSpan" id="kobo.234.1">. </span><span class="koboSpan" id="kobo.234.2">It lays out the types of automated tests that should be included in the </span><strong class="bold"><span class="koboSpan" id="kobo.235.1">automated testing suites</span></strong><span class="koboSpan" id="kobo.236.1"> of software systems. </span><span class="koboSpan" id="kobo.236.2">It provides guidance on the sequence and priority of each type of test to perform in order to ensure that new functionality is shipped with a proportionate amount of testing effort and without disrupting </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">old/existing functionality.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.238.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.239.1">.4</span></em><span class="koboSpan" id="kobo.240.1"> presents the testing pyramid with its three types of tests: unit tests, integration tests, and </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">end-to-end tests:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer010">
<span class="koboSpan" id="kobo.242.1"><img alt="Figure 1.4 – The testing pyramid and its components " src="image/Figure_1.4_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.243.1">Figure 1.4 – The testing pyramid and its components</span></p>
<p><span class="koboSpan" id="kobo.244.1">Each type of test can then be further described according to the three established traits of system knowledge, requirement type, and </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">testing scope.</span></span></p>
<h4><span class="koboSpan" id="kobo.246.1">Unit tests</span></h4>
<p><span class="koboSpan" id="kobo.247.1">At the </span><a id="_idIndexMarker033"/><span class="koboSpan" id="kobo.248.1">bottom of the testing pyramid, we</span><a id="_idIndexMarker034"/><span class="koboSpan" id="kobo.249.1"> have </span><strong class="bold"><span class="koboSpan" id="kobo.250.1">unit tests</span></strong><span class="koboSpan" id="kobo.251.1">. </span><span class="koboSpan" id="kobo.251.2">They are presented at the bottom because they are the most numerous. </span><span class="koboSpan" id="kobo.251.3">They have a small testing scope, covering the functionality of individual components under a variety of conditions. </span><span class="koboSpan" id="kobo.251.4">Good unit tests should be tested in isolation from other components so that we can fully control the test environment </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">and setup.</span></span></p>
<p><span class="koboSpan" id="kobo.253.1">Since the number of unit tests increases as new features are added to the code, they need to be robust and fast to execute. </span><span class="koboSpan" id="kobo.253.2">Typically, test suites are run with each code change, so they need to provide feedback to </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">engineers quickly.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.255.1">Unit tests</span></strong><span class="koboSpan" id="kobo.256.1"> have been </span><a id="_idIndexMarker035"/><span class="koboSpan" id="kobo.257.1">traditionally thought of as </span><strong class="bold"><span class="koboSpan" id="kobo.258.1">white-box tests</span></strong><span class="koboSpan" id="kobo.259.1"> since they are typically written by developers who know all the implementation details of the component. </span><span class="koboSpan" id="kobo.259.2">However, Go unit tests usually only test the exported/public functionality of the package. </span><span class="koboSpan" id="kobo.259.3">This brings them closer</span><a id="_idIndexMarker036"/><span class="koboSpan" id="kobo.260.1"> to </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.261.1">gray-box tests</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.263.1">We will explore unit tests further in </span><a href="B18371_02.xhtml#_idTextAnchor035"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.264.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.265.1">, </span><em class="italic"><span class="koboSpan" id="kobo.266.1">Unit </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.267.1">Testing Essentials</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">.</span></span></p>
<h4><span class="koboSpan" id="kobo.269.1">Integration tests</span></h4>
<p><span class="koboSpan" id="kobo.270.1">In the</span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.271.1"> middle of the testing pyramid, we </span><a id="_idIndexMarker038"/><span class="koboSpan" id="kobo.272.1">have </span><strong class="bold"><span class="koboSpan" id="kobo.273.1">integration tests</span></strong><span class="koboSpan" id="kobo.274.1">. </span><span class="koboSpan" id="kobo.274.2">They are an essential part of the pyramid, but they should not be as numerous and should not be run as often as </span><strong class="bold"><span class="koboSpan" id="kobo.275.1">unit tests</span></strong><span class="koboSpan" id="kobo.276.1">, which</span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.277.1"> are at the bottom of </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">the pyramid.</span></span></p>
<p><span class="koboSpan" id="kobo.279.1">Unit tests verify that a single piece of functionality is working correctly, while integration tests extend the scope and test the communication between multiple components. </span><span class="koboSpan" id="kobo.279.2">These components can be external or internal to the system – a database, an external API, or another microservice in the system. </span><span class="koboSpan" id="kobo.279.3">Often, integration tests run in dedicated environments, which allows us to separate production and test data as well as </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">reduce costs.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.281.1">Integration tests</span></strong><span class="koboSpan" id="kobo.282.1"> could </span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.283.1">be </span><strong class="bold"><span class="koboSpan" id="kobo.284.1">black-box tests</span></strong><span class="koboSpan" id="kobo.285.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.286.1">gray-box tests</span></strong><span class="koboSpan" id="kobo.287.1">. </span><span class="koboSpan" id="kobo.287.2">If the </span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.288.1">tests cover external APIs and customer-facing functionality, they can be categorized as </span><strong class="bold"><span class="koboSpan" id="kobo.289.1">black-box tests</span></strong><span class="koboSpan" id="kobo.290.1">, while more specialized security or performance tests would be considered </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.291.1">gray-box tests</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.293.1">We will explore integration tests further in </span><a href="B18371_04.xhtml#_idTextAnchor085"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.294.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.295.1">, </span><em class="italic"><span class="koboSpan" id="kobo.296.1">Building Efficient </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.297.1">Test Suites</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">.</span></span></p>
<h4><span class="koboSpan" id="kobo.299.1">End-to-end tests</span></h4>
<p><span class="koboSpan" id="kobo.300.1">At the top</span><a id="_idIndexMarker042"/><span class="koboSpan" id="kobo.301.1"> of the testing pyramid, we have </span><strong class="bold"><span class="koboSpan" id="kobo.302.1">end-to-end tests</span></strong><span class="koboSpan" id="kobo.303.1">. </span><span class="koboSpan" id="kobo.303.2">They </span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.304.1">are the least numerous of all the tests we have seen so far. </span><span class="koboSpan" id="kobo.304.2">They test the entire functionality of the application (as added during each sprint), ensuring that the project deliverables are working according to requirements and can potentially be shipped at the conclusion of a </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">given sprint.</span></span></p>
<p><span class="koboSpan" id="kobo.306.1">These tests can be the most time-consuming to write, maintain, and run since they can involve a large variety of scenarios. </span><span class="koboSpan" id="kobo.306.2">Just like integration tests, they are also typically run in dedicated environments that mimic </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">production environments.</span></span></p>
<p><span class="koboSpan" id="kobo.308.1">There are a lot of similarities between integration tests and end-to-end tests, especially in microservice architectures where one service’s end-to-end functionality involves integration with another service’s </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">end-to-end functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.310.1">We will explore end-to-end tests further in </span><a href="B18371_05.xhtml#_idTextAnchor124"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.311.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.312.1">, </span><em class="italic"><span class="koboSpan" id="kobo.313.1">Performing Integration Testing</span></em><span class="koboSpan" id="kobo.314.1">, and </span><a href="B18371_08.xhtml#_idTextAnchor179"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.315.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.316.1">, </span><em class="italic"><span class="koboSpan" id="kobo.317.1">Testing </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.318.1">Microservice Architectures</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.320.1">Now that we understand the different types of automated tests, it’s time to look at how we can leverage the Agile practice of TDD to implement them alongside our code. </span><span class="koboSpan" id="kobo.320.2">TDD will help us write well-tested code that delivers all the components of the </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">testing pyramid.</span></span></p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/><span class="koboSpan" id="kobo.322.1">The iterative approach of TDD</span></h2>
<p><span class="koboSpan" id="kobo.323.1">As we’ve mentioned </span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.324.1">before, TDD is an Agile practice that will be the focus of our exploration. </span><span class="koboSpan" id="kobo.324.2">The principle of TDD is simple: write the unit tests for a piece of functionality before </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">implementing it.</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">TDD brings the testing process together with the implementation process, ensuring that every piece of functionality is tested as soon as it is written, making the software development process iterative, and giving developers </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">quick feedback.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.328.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.329.1">.5</span></em><span class="koboSpan" id="kobo.330.1"> demonstrates the steps of the</span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.331.1"> TDD process, known as the </span><strong class="bold"><span class="koboSpan" id="kobo.332.1">red</span></strong><span class="koboSpan" id="kobo.333.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.334.1">green</span></strong><span class="koboSpan" id="kobo.335.1">, and </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.336.1">refactor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.337.1"> process:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer011">
<span class="koboSpan" id="kobo.338.1"><img alt="Figure 1.5 – The steps of TDD " src="image/Figure_1.5_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.339.1">Figure 1.5 – The steps of TDD</span></p>
<p><span class="koboSpan" id="kobo.340.1">Let’s </span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.341.1">have a look at the cyclical </span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.342.1">phases of the TDD </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">working process:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.344.1">We start at the </span><strong class="bold"><span class="koboSpan" id="kobo.345.1">red phase</span></strong><span class="koboSpan" id="kobo.346.1">. </span><span class="koboSpan" id="kobo.346.2">We begin by considering what we want to test and translating this requirement into a test. </span><span class="koboSpan" id="kobo.346.3">Some requirements may be made up of several smaller requirements: at this point, we test only the first small requirement. </span><span class="koboSpan" id="kobo.346.4">This test will fail until the new functionality is implemented, giving a name to the red phase. </span><span class="koboSpan" id="kobo.346.5">The failing test is key because we want to ensure that the test will fail reliably regardless of what code </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">we write.</span></span></li>
<li><span class="koboSpan" id="kobo.348.1">Next, we move to the </span><strong class="bold"><span class="koboSpan" id="kobo.349.1">green phase</span></strong><span class="koboSpan" id="kobo.350.1">. </span><span class="koboSpan" id="kobo.350.2">We swap from test code to implementation, writing just enough code as required to make the failing test pass. </span><span class="koboSpan" id="kobo.350.3">The code does not need to be perfect or optimal, but it should be correct enough for the test to pass. </span><span class="koboSpan" id="kobo.350.4">It should focus on the requirement tested by the previously written </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">failing test.</span></span></li>
<li><span class="koboSpan" id="kobo.352.1">Finally, we move to the </span><strong class="bold"><span class="koboSpan" id="kobo.353.1">refactor phase</span></strong><span class="koboSpan" id="kobo.354.1">. </span><span class="koboSpan" id="kobo.354.2">This phase is all about cleaning up both the implementation and the test code, removing duplication, and optimizing </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">our solution.</span></span></li>
<li><span class="koboSpan" id="kobo.356.1">We repeat this process until all the requirements are tested and implemented and all tests pass. </span><span class="koboSpan" id="kobo.356.2">The </span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.357.1">developer frequently swaps between testing and implementing code, extending functionality </span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.358.1">and </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">tests accordingly.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.360.1">That’s all there is to </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">doing TDD!</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.362.1">TDD is all about developers</span></p>
<p class="callout"><span class="koboSpan" id="kobo.363.1">TDD is a developer-centric process where unit tests are written before implementation. </span><span class="koboSpan" id="kobo.363.2">Developers first write a failing test. </span><span class="koboSpan" id="kobo.363.3">Then, they write the simplest implementation to make the test pass. </span><span class="koboSpan" id="kobo.363.4">Finally, once the functionality is implemented and working as expected, they can refactor the code and test as needed. </span><span class="koboSpan" id="kobo.363.5">The process is repeated as many times as necessary. </span><span class="koboSpan" id="kobo.363.6">No piece of code or functionality is written without </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">corresponding tests.</span></span></p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/><span class="koboSpan" id="kobo.365.1">TDD best practices</span></h2>
<p><span class="koboSpan" id="kobo.366.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.367.1">red</span></strong><span class="koboSpan" id="kobo.368.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.369.1">green</span></strong><span class="koboSpan" id="kobo.370.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.371.1">refactor</span></strong><span class="koboSpan" id="kobo.372.1"> approach to TDD is simple, yet very powerful. </span><span class="koboSpan" id="kobo.372.2">While the process is simple, we can make some recommendations and best practices for how to write components and tests that </span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.373.1">can more easily be delivered </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">with TDD.</span></span></p>
<h3><span class="koboSpan" id="kobo.375.1">Structure your tests</span></h3>
<p><span class="koboSpan" id="kobo.376.1">We can formulate a shared, repeatable, test structure to make tests more readable and maintainable. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.377.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.378.1">.6</span></em><span class="koboSpan" id="kobo.379.1"> depicts the </span><strong class="bold"><span class="koboSpan" id="kobo.380.1">Arrange-Act-Assert</span></strong><span class="koboSpan" id="kobo.381.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.382.1">AAA</span></strong><span class="koboSpan" id="kobo.383.1">) pattern</span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.384.1"> that is often used </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">with TDD:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer012">
<span class="koboSpan" id="kobo.386.1"><img alt="Figure 1.6 – The steps of the Arrange-Act-Assert pattern " src="image/Figure_1.6_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.387.1">Figure 1.6 – The steps of the Arrange-Act-Assert pattern</span></p>
<p><span class="koboSpan" id="kobo.388.1">The AAA pattern describes how to structure tests in a </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">uniform manner:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.390.1">We begin with the </span><strong class="bold"><span class="koboSpan" id="kobo.391.1">Arrange</span></strong><span class="koboSpan" id="kobo.392.1"> step, which is the setup part of the test. </span><span class="koboSpan" id="kobo.392.2">This is when we</span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.393.1"> set up the </span><strong class="bold"><span class="koboSpan" id="kobo.394.1">Unit Under Test</span></strong><span class="koboSpan" id="kobo.395.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.396.1">UUT</span></strong><span class="koboSpan" id="kobo.397.1">) and all of the dependencies that it requires during setup. </span><span class="koboSpan" id="kobo.397.2">We also set up the inputs and the preconditions used by the test scenario in </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">this section.</span></span></li>
<li><span class="koboSpan" id="kobo.399.1">Next, the </span><strong class="bold"><span class="koboSpan" id="kobo.400.1">Act</span></strong><span class="koboSpan" id="kobo.401.1"> step is where we perform the actions specified by the test scenario. </span><span class="koboSpan" id="kobo.401.2">Depending on the type of test that we are implementing, this could simply be invoking a function, an external API, or even a database function. </span><span class="koboSpan" id="kobo.401.3">This step uses the preconditions and inputs defined in the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.402.1">Arrange</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.403.1"> step.</span></span></li>
<li><span class="koboSpan" id="kobo.404.1">Finally, the </span><strong class="bold"><span class="koboSpan" id="kobo.405.1">Assert</span></strong><span class="koboSpan" id="kobo.406.1"> step is where we confirm that the UUT behaves according to requirements. </span><span class="koboSpan" id="kobo.406.2">This step compares the output from the UUT with the expected output, as defined by </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">the requirements.</span></span></li>
<li><span class="koboSpan" id="kobo.408.1">If the </span><strong class="bold"><span class="koboSpan" id="kobo.409.1">Assert</span></strong><span class="koboSpan" id="kobo.410.1"> step shows that the actual output from the UUT is not as expected, then the test is considered failed and the test </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">is finished.</span></span></li>
<li><span class="koboSpan" id="kobo.412.1">If the </span><strong class="bold"><span class="koboSpan" id="kobo.413.1">Assert</span></strong><span class="koboSpan" id="kobo.414.1"> step shows that the actual output from the UUT is as expected, then we have two options: one option is that if there are no more test steps, the test is considered passed and the test is finished. </span><span class="koboSpan" id="kobo.414.2">The other option is that if there are more test steps, then we go back to the </span><strong class="bold"><span class="koboSpan" id="kobo.415.1">Act</span></strong><span class="koboSpan" id="kobo.416.1"> step </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">and continue.</span></span></li>
<li><span class="koboSpan" id="kobo.418.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.419.1">Act</span></strong><span class="koboSpan" id="kobo.420.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.421.1">Assert</span></strong><span class="koboSpan" id="kobo.422.1"> steps can be repeated as many times as necessary for your test scenario. </span><span class="koboSpan" id="kobo.422.2">However, you should avoid writing lengthy, complicated tests. </span><span class="koboSpan" id="kobo.422.3">This is described further in </span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.423.1">the best practices throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">this section.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.425.1">Your team can leverage test helpers and frameworks to minimize setup and assertion code duplication. </span><span class="koboSpan" id="kobo.425.2">Using the AAA pattern will help to set the standard for how tests should be written and read, minimizing the cognitive load of new and existing team members and improving the maintainability of the </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">code base.</span></span></p>
<h4><span class="koboSpan" id="kobo.427.1">Control scope</span></h4>
<p><span class="koboSpan" id="kobo.428.1">As we have seen, the scope of your test depends on the type of test you are writing. </span><span class="koboSpan" id="kobo.428.2">Regardless of the type of test, you should strive to restrict the functionality of your components and the assertions of your tests as much as possible. </span><span class="koboSpan" id="kobo.428.3">This is possible with TDD, which allows us to test and implement code at the </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">same time.</span></span></p>
<p><span class="koboSpan" id="kobo.430.1">Keeping things as simple as possible immediately brings </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">some advantages:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.432.1">Easier debugging in the case </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">of failures</span></span></li>
<li><span class="koboSpan" id="kobo.434.1">Easier to maintain and adjust tests when the Arrange and Assert steps </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">are simple</span></span></li>
<li><span class="koboSpan" id="kobo.436.1">Faster execution time of tests, especially with the ability to run tests </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">in parallel</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.438.1">Test outputs, not implementation</span></h3>
<p><span class="koboSpan" id="kobo.439.1">As we have seen from the previous definitions of tests, they are all about defining inputs and expected outputs. </span><span class="koboSpan" id="kobo.439.2">As developers who know implementation details, it can be tempting to add assertions that verify the inner workings of </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">the UUT.</span></span></p>
<p><span class="koboSpan" id="kobo.441.1">However, this is an anti-pattern that results in a tight coupling between the test and the implementation. </span><span class="koboSpan" id="kobo.441.2">Once tests are aware of implementation details, they need to be changed together with code changes. </span><span class="koboSpan" id="kobo.441.3">Therefore, when structuring tests, it is important to focus on testing </span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.442.1">externally visible outputs, not </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">implementation details.</span></span></p>
<h3><span class="koboSpan" id="kobo.444.1">Keep tests independent</span></h3>
<p><span class="koboSpan" id="kobo.445.1">Tests are typically organized in test suites, which cover a variety of scenarios and requirements. </span><span class="koboSpan" id="kobo.445.2">While these test suites allow developers to leverage shared functionality, tests should run independently of </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">each other.</span></span></p>
<p><span class="koboSpan" id="kobo.447.1">Tests should start from a pre-defined and repeatable starting state that does not change with the number of runs and order of execution. </span><span class="koboSpan" id="kobo.447.2">Setup and clean-up code ensures that the starting point and end state of each test is </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">as expected.</span></span></p>
<p><span class="koboSpan" id="kobo.449.1">It is, therefore, best that tests create their own UUT against which to run modifications and verifications, as opposed to sharing one with other tests. </span><span class="koboSpan" id="kobo.449.2">Overall, this will ensure that your test suites are robust</span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.450.1"> and can be run </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">in parallel.</span></span></p>
<p><span class="koboSpan" id="kobo.452.1">Adopting TDD and its best practices allows Agile teams to deliver well-tested code that is easy to maintain and modify. </span><span class="koboSpan" id="kobo.452.2">This is one of many benefits of TDD, which we will continue to explore in the </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">next section.</span></span></p>
<h1 id="_idParaDest-23"><a id="_idTextAnchor022"/><span class="koboSpan" id="kobo.454.1">Understanding the benefits and use of TDD</span></h1>
<p><span class="koboSpan" id="kobo.455.1">With the fundamentals and best practices of TDD in mind, let us have a more in-depth look at the benefits of adopting it as practice in your teams. </span><span class="koboSpan" id="kobo.455.2">As Agile working practices are industry standard, we will discuss TDD usage in Agile teams going forward. </span><span class="koboSpan" id="kobo.455.3">Incorporating TDD in the development process immediately allows developers to write and maintain their tests more easily, enabling them to detect and fix bugs more </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">easily too.</span></span></p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/><span class="koboSpan" id="kobo.457.1">Pros and cons of using TDD</span></h2>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.458.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.459.1">.7</span></em><span class="koboSpan" id="kobo.460.1"> depicts some of the pros</span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.461.1"> and cons of</span><a id="_idIndexMarker057"/> <span class="No-Break"><span class="koboSpan" id="kobo.462.1">using TDD:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer013">
<span class="koboSpan" id="kobo.463.1"><img alt="Figure 1.7 – Pros and cons of using TDD " src="image/Figure_1.7_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.464.1">Figure 1.7 – Pros and cons of using TDD</span></p>
<p><span class="koboSpan" id="kobo.465.1">We can expand on these pros and </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">cons highlights:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.467.1">TDD allows the development and testing process to happen at the same time, ensuring that all code is tested from the beginning. </span><span class="koboSpan" id="kobo.467.2">While TDD does require writing more code upfront, the written code is immediately covered by tests, and bugs are fixed while relevant code is fresh in developers’ minds. </span><span class="koboSpan" id="kobo.467.3">Testing should not be an afterthought and should not be rushed or cut if the implementation </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">is delayed.</span></span></li>
<li><span class="koboSpan" id="kobo.469.1">TDD allows developers to analyze project requirements in detail at the beginning of the sprint. </span><span class="koboSpan" id="kobo.469.2">While it does require product managers to establish the details of what needs to be built as part of sprint planning, it also allows developers to give early feedback on what can and cannot be implemented during </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">each sprint.</span></span></li>
<li><span class="koboSpan" id="kobo.471.1">Well-tested code that has been built with TDD can be confidently shipped and changed. </span><span class="koboSpan" id="kobo.471.2">Once a code base has an established test suite, developers can confidently change code, knowing that existing functionality will not be broken because test failures would flag any issues before changes </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">are shipped.</span></span></li>
<li><span class="koboSpan" id="kobo.473.1">Finally, the most important pro is that it gives developers ownership of their code quality by making them responsible for both implementation and testing. </span><span class="koboSpan" id="kobo.473.2">Writing tests at the same time as code gives developers a short feedback loop on where their code might be faulty, as opposed to shipping a full feature and hearing about </span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.474.1">where they missed the mark </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">much</span></span><span class="No-Break"><a id="_idIndexMarker059"/></span><span class="No-Break"><span class="koboSpan" id="kobo.476.1"> later.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.477.1">In my opinion, the most important advantage of using TDD is the increased ownership by developers. </span><span class="koboSpan" id="kobo.477.2">The immediate feedback loop allows them to do their best work, while also giving them peace of mind that they have not broken any </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">existing code.</span></span></p>
<p><span class="koboSpan" id="kobo.479.1">Now that we understand what TDD and its benefits are, let us explore the basic application of TDD to a simple </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">calculator example.</span></span></p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/><span class="koboSpan" id="kobo.481.1">Use case – the simple terminal calculator</span></h2>
<p><span class="koboSpan" id="kobo.482.1">This use case will give</span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.483.1"> you a good understanding of the general process we will undertake when testing more </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">advanced examples.</span></span></p>
<p><span class="koboSpan" id="kobo.485.1">The use case we will look at is the simple terminal calculator. </span><span class="koboSpan" id="kobo.485.2">The calculator will run in the terminal and use the standard input to read its parameters. </span><span class="koboSpan" id="kobo.485.3">The calculator will only handle two operators and the simple mathematical operations you see in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.486.1">Figure 1</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.487.1">.8</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer014">
<span class="koboSpan" id="kobo.489.1"><img alt="Figure 1.8 – The simple calculator runs in the terminal " src="image/Figure_1.8_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.490.1">Figure 1.8 – The simple calculator runs in the terminal</span></p>
<p><span class="koboSpan" id="kobo.491.1">This functionality is</span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.492.1"> simple, but the calculator should also be able to handle edge cases and other </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">input errors.</span></span></p>
<h3><span class="koboSpan" id="kobo.494.1">Requirements</span></h3>
<p><span class="koboSpan" id="kobo.495.1">Agile teams typically write their requirements</span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.496.1"> from the user’s perspective. </span><span class="koboSpan" id="kobo.496.2">The requirements of the project are written first in order to capture customer needs and to guide the test cases and implementation of the entire simple calculator project. </span><span class="koboSpan" id="kobo.496.3">In Agile teams, requirements go through multiple iterations, with engineering leadership weighing in early to ensure that the required functionality can </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">be delivered.</span></span></p>
<p><span class="koboSpan" id="kobo.498.1">Users should be able to do </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.500.1">Input positive, negative, and zero values using the terminal input. </span><span class="koboSpan" id="kobo.500.2">These values should be correctly transformed </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">into numbers.</span></span></li>
<li><span class="koboSpan" id="kobo.502.1">Access the mathematical operations of addition, subtraction, multiplication, and division. </span><span class="koboSpan" id="kobo.502.2">These operations should return the correct results for the entire range </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">of inputs.</span></span></li>
<li><span class="koboSpan" id="kobo.504.1">View fractional results rounded up to two </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">decimal places.</span></span></li>
<li><span class="koboSpan" id="kobo.506.1">View user-friendly error messages, guiding them on how to fix </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">their input.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.508.1">Agile requirements from the perspective of the user</span></p>
<p class="callout"><span class="koboSpan" id="kobo.509.1">Requirements are used to capture the needs and perspectives of the end user. </span><span class="koboSpan" id="kobo.509.2">The requirements set out the precondition, the user actions, and the acceptance criteria. </span><span class="koboSpan" id="kobo.509.3">They specify what we should build as well as how to verify </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">the implementation.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.511.1">Remember that we only specify requirements on a sprint-by-sprint basis. </span><span class="koboSpan" id="kobo.511.2">It is an anti-pattern to specify requirements of the entire product upfront, as well as work in the mindset that they cannot </span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.512.1">change. </span><span class="koboSpan" id="kobo.512.2">Software building in Agile is an </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">iterative process.</span></span></p>
<h3><span class="koboSpan" id="kobo.514.1">Architecture</span></h3>
<p><span class="koboSpan" id="kobo.515.1">Our simple terminal </span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.516.1">calculator is small enough to implement in one sprint. </span><span class="koboSpan" id="kobo.516.2">We will take our four requirements and translate them into a simple system architecture. </span><span class="koboSpan" id="kobo.516.3">The calculator will be downloaded and run by users locally, so we do not need to consider any networking or cloud </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">deployment aspects.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.518.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.519.1">.9</span></em><span class="koboSpan" id="kobo.520.1"> shows what the design of the calculator module could </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">look like:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer015">
<span class="koboSpan" id="kobo.522.1"><img alt="Figure 1.9 – Architecture of the simple terminal calculator " src="image/Figure_1.9_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.523.1">Figure 1.9 – Architecture of the simple terminal calculator</span></p>
<p><span class="koboSpan" id="kobo.524.1">Each of the components of the calculator module has its own, well-defined responsibilities </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">and functionality:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.526.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.527.1">Input parser</span></strong><span class="koboSpan" id="kobo.528.1"> is in charge of integrating with the terminal input and reading the user input correctly and passing it to the </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">calculator module.</span></span></li>
<li><span class="koboSpan" id="kobo.530.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.531.1">Input validator</span></strong><span class="koboSpan" id="kobo.532.1"> is in charge of validating the input sent from the </span><strong class="bold"><span class="koboSpan" id="kobo.533.1">Input parser</span></strong><span class="koboSpan" id="kobo.534.1">, such as whether the input contains valid numbers and the operators </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">are valid.</span></span></li>
<li><span class="koboSpan" id="kobo.536.1">Once the input is parsed and validated, the </span><strong class="bold"><span class="koboSpan" id="kobo.537.1">Calculator engine</span></strong><span class="koboSpan" id="kobo.538.1"> takes in the numbers and attempts to find the result of </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">the operation.</span></span></li>
<li><span class="koboSpan" id="kobo.540.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.541.1">Calculator engine</span></strong><span class="koboSpan" id="kobo.542.1"> then relies on the </span><strong class="bold"><span class="koboSpan" id="kobo.543.1">Result formatter</span></strong><span class="koboSpan" id="kobo.544.1"> to format the result correctly and print it to the </span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.545.1">terminal output. </span><span class="koboSpan" id="kobo.545.2">In the case of an error, it relies on the </span><strong class="bold"><span class="koboSpan" id="kobo.546.1">Error formatter</span></strong><span class="koboSpan" id="kobo.547.1"> to produce and print </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">user-friendly errors.</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.549.1">Applying TDD</span></h3>
<p><span class="koboSpan" id="kobo.550.1">As described, we will </span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.551.1">use the </span><strong class="bold"><span class="koboSpan" id="kobo.552.1">red</span></strong><span class="koboSpan" id="kobo.553.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.554.1">green</span></strong><span class="koboSpan" id="kobo.555.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.556.1">refactor</span></strong><span class="koboSpan" id="kobo.557.1"> process to apply TDD to deliver the required user functionality in an iterative manner. </span><span class="koboSpan" id="kobo.557.2">Tests are written first, based on the requirements and design of the simple </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">terminal calculator.</span></span></p>
<p><span class="koboSpan" id="kobo.559.1">An overview of how the process might work for the implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">Divide(x,y)</span></strong><span class="koboSpan" id="kobo.561.1"> function in </span><strong class="bold"><span class="koboSpan" id="kobo.562.1">the calculator engine</span></strong><span class="koboSpan" id="kobo.563.1"> is demonstrated in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.564.1">Figure 1</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.565.1">.10</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<span class="koboSpan" id="kobo.567.1"><img alt="Figure 1.10 – The TDD process applied to the calculator engine " src="image/Figure_1.10_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.568.1">Figure 1.10 – The TDD process applied to the calculator engine</span></p>
<p><span class="koboSpan" id="kobo.569.1"> This is a small snapshot</span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.570.1"> that demonstrates the steps involved when </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">using TDD:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.572.1">We begin by writing a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">TestDivide()</span></strong><span class="koboSpan" id="kobo.574.1"> that arranges two non-zero inputs and writes assertions for dividing them. </span><span class="koboSpan" id="kobo.574.2">This is the simplest case that we can implement. </span><span class="koboSpan" id="kobo.574.3">Then, we run the test suite to ensure that the newly written </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">TestDivide()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.576.1">is failing.</span></span></li>
<li><span class="koboSpan" id="kobo.577.1">Now that the test has established the expected behavior, we can begin our implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">Divide(x,y)</span></strong><span class="koboSpan" id="kobo.579.1"> function. </span><span class="koboSpan" id="kobo.579.2">We write just enough code to handle the simple case of two non-zero inputs. </span><span class="koboSpan" id="kobo.579.3">Then, we run the test suite to verify that the code we have written satisfies the assertions of </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">TestDivide()</span></strong><span class="koboSpan" id="kobo.581.1">. </span><span class="koboSpan" id="kobo.581.2">All tests should now </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">be passing.</span></span></li>
<li><span class="koboSpan" id="kobo.583.1">We can now take some time to refactor the existing code that we have written. </span><span class="koboSpan" id="kobo.583.2">The newly written code can be cleaned up according to the clean code practices, as well as the TDD best practices that we have discussed. </span><span class="koboSpan" id="kobo.583.3">The test suite is run once more to validate that the refactor step has not broken any new or </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">existing tests.</span></span></li>
<li><span class="koboSpan" id="kobo.585.1">The simplest functionality for the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">Divide(x,y)</span></strong><span class="koboSpan" id="kobo.587.1"> function is now implemented and validated. </span><span class="koboSpan" id="kobo.587.2">We can turn to looking at more advanced functionality or edge cases. </span><span class="koboSpan" id="kobo.587.3">One such edge case could be handling a zero divisor gracefully. </span><span class="koboSpan" id="kobo.587.4">We now add a new test, </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">TestDivide_Zero()</span></strong><span class="koboSpan" id="kobo.589.1">, which sets up and asserts the case of a zero divisor. </span><span class="koboSpan" id="kobo.589.2">As usual, we run the test suite to ensure that the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">TestDivide_Zero()</span></strong><span class="koboSpan" id="kobo.591.1"> test </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">is failing.</span></span></li>
<li><span class="koboSpan" id="kobo.593.1">We modify the implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">Divide(x,y)</span></strong><span class="koboSpan" id="kobo.595.1"> to handle a zero divisor gracefully and correctly, as established in the calculator requirements (talking to product owners and perhaps even users if necessary). </span><span class="koboSpan" id="kobo.595.2">We run the tests again to ensure that all tests are </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">now passing.</span></span></li>
<li><span class="koboSpan" id="kobo.597.1">Finally, we begin</span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.598.1"> a new round of refactoring, ensuring that code and tests are well written. </span><span class="koboSpan" id="kobo.598.2">All tests are run once more to ensure that refactoring has not caused </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">any errors.</span></span></li>
</ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.600.1">TDD is second nature</span></p>
<p class="callout"><span class="koboSpan" id="kobo.601.1">The development process swaps between writing test code and writing implementation code as many times as required. </span><span class="koboSpan" id="kobo.601.2">While it might seem cumbersome at first, swapping between writing test code and implementation code quickly becomes second nature to </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">TDD practitioners.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.603.1">Always remember to start with a failing test and then write as little code as possible to make the test pass. </span><span class="koboSpan" id="kobo.603.2">Optimize your code only in the refactor phase, once you have all functionality working </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">as verified.</span></span></p>
<p><span class="koboSpan" id="kobo.605.1">We are now familiar with the process of TDD and have looked at how to write and structure our tests accordingly. </span><span class="koboSpan" id="kobo.605.2">However, it’s important to consider alternative processes </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">as well.</span></span></p>
<h1 id="_idParaDest-26"><a id="_idTextAnchor025"/><span class="koboSpan" id="kobo.607.1">Alternatives to TDD</span></h1>
<p><span class="koboSpan" id="kobo.608.1">As we’ve seen, TDD is simply a way to deliver well-tested code in an iterative way. </span><span class="koboSpan" id="kobo.608.2">Putting tests first ensures that no functionality is ever delivered without being tested and refactored. </span><span class="koboSpan" id="kobo.608.3">In this section, we will have a look at some other common processes for </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">testing code.</span></span></p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/><span class="koboSpan" id="kobo.610.1">Waterfall testing</span></h2>
<p><span class="koboSpan" id="kobo.611.1">As we remember from our</span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.612.1"> introduction to the waterfall methodology, the testing or verification phase of waterfall projects happens after the implementation phase is fully completed. </span><span class="koboSpan" id="kobo.612.2">The entire project is delivered, and all requirements are implemented by </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">this point.</span></span></p>
<p><span class="koboSpan" id="kobo.614.1">Here are </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">the advantages:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.616.1">Waterfall projects are</span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.617.1"> typically well structured and well documented. </span><span class="koboSpan" id="kobo.617.2">Testing plans are informed by this extensive documentation and testers can ensure that all of the end-to-end tests that they implement cover the identified </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">user needs.</span></span></li>
<li><span class="koboSpan" id="kobo.619.1">Developers and testers can rely on the project documentation to work independently, without the need to communicate. </span><span class="koboSpan" id="kobo.619.2">This division allows teams to work in shifts – testers verify functionality and developers fix any bugs that </span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">may arise.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.621.1">These are </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">the disadvantages:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.623.1">As the entire project is </span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.624.1">already implemented, it is easier for bugs to become complex. </span><span class="koboSpan" id="kobo.624.2">Furthermore, since the entire project is already implemented, it might take considerably more engineering effort to fix a bug, in the case that large changes need to </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">be undertaken.</span></span></li>
<li><span class="koboSpan" id="kobo.626.1">In the case that client requirements are not well known or clear from the beginning, a lot of implementation and testing effort might be wasted if the requirements change once the client sees the delivered product at the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">the process.</span></span></li>
<li><span class="koboSpan" id="kobo.628.1">The testing process can often be seen as a time-wasting, negative exercise that should be finished as soon as possible. </span><span class="koboSpan" id="kobo.628.2">Furthermore, if there are delays in the development process, it </span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.629.1">can be easy to cut corners in the verification process, delivering an</span><a id="_idIndexMarker073"/> <span class="No-Break"><span class="koboSpan" id="kobo.630.1">unstable product.</span></span></li>
</ul>
<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/><span class="koboSpan" id="kobo.631.1">Acceptance Test-Driven Development</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.632.1">Acceptance Test-Driven Development</span></strong><span class="koboSpan" id="kobo.633.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.634.1">ATDD</span></strong><span class="koboSpan" id="kobo.635.1">) is an </span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.636.1">Agile development </span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.637.1">process related to TDD. </span><span class="koboSpan" id="kobo.637.2">ATDD involves people from multiple disciplines from product, engineering, and testing to ensure that </span><strong class="bold"><span class="koboSpan" id="kobo.638.1">the right product is being developed in the right way</span></strong><span class="koboSpan" id="kobo.639.1">. </span><span class="koboSpan" id="kobo.639.2">The customer requirements are translated into a list of requirements that can be understood by a wide variety of stakeholders. </span><span class="koboSpan" id="kobo.639.3">These requirements are then converted to automated acceptance tests, which are used to verify what the engineering department </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">is delivering.</span></span></p>
<p><span class="koboSpan" id="kobo.641.1">The advantages of ATDD are </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.643.1">Just like with TDD, tests </span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.644.1">are written first when you use ATDD. </span><span class="koboSpan" id="kobo.644.2">A complete suite of automated acceptance tests can be run after each commit or incremental code delivery, ensuring that all end-to-end functionality works </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">as expected.</span></span></li>
<li><span class="koboSpan" id="kobo.646.1">If done right, using ATDD on a project will be widely supported by a wide variety of stakeholders inside the business, as they will have a good understanding of the direction and customer </span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.647.1">value it </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">will provide.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.649.1">The</span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.650.1"> disadvantages are </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.652.1">Significant communication and synchronization effort is required for the inter-disciplinary effort of writing requirements. </span><span class="koboSpan" id="kobo.652.2">It can be time-consuming to get a variety of stakeholders to give the time and </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">effort needed.</span></span></li>
<li><span class="koboSpan" id="kobo.654.1">This approach might not be best suited for greenfield projects, where there are a lot of unknowns upfront. </span><span class="koboSpan" id="kobo.654.2">It can be particularly challenging to write acceptance tests for a project that does not even have an API or database </span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">model yet.</span></span></li>
<li><span class="koboSpan" id="kobo.656.1">It can be challenging to get sample payloads or datasets from the outset of a project, especially if</span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.657.1"> these are provided by the client or a </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">third party.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.659.1">Further </span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.660.1">related to ATDD, we have </span><strong class="bold"><span class="koboSpan" id="kobo.661.1">Behavior-Driven Development</span></strong><span class="koboSpan" id="kobo.662.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.663.1">BDD</span></strong><span class="koboSpan" id="kobo.664.1">). </span><span class="koboSpan" id="kobo.664.2">It provides precise </span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.665.1">guidance on how to structure the conversation between stakeholders using business domain language. </span><span class="koboSpan" id="kobo.665.2">We will explore BDD further in </span><a href="B18371_05.xhtml#_idTextAnchor124"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.666.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.667.1">, </span><em class="italic"><span class="koboSpan" id="kobo.668.1">Performing </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.669.1">Integration Testing</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.671.1">As we begin to write and think of test code together with functional code, it’s important to set success criteria for our test code. </span><span class="koboSpan" id="kobo.671.2">Test metrics can help us achieve </span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">just that.</span></span></p>
<h1 id="_idParaDest-29"><a id="_idTextAnchor028"/><span class="koboSpan" id="kobo.673.1">Understanding test metrics</span></h1>
<p><span class="koboSpan" id="kobo.674.1">Now that we understand how to deliver projects with tests first, it’s time to look at some metrics that can quantify how well-tested a project is. </span><span class="koboSpan" id="kobo.674.2">It’s important to deliver tests across the entire test pyramid, as it’s important to be able to ensure the application is working correctly end-to-end as well as working well with its </span><span class="No-Break"><span class="koboSpan" id="kobo.675.1">external dependencies.</span></span></p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/><span class="koboSpan" id="kobo.676.1">Important test metrics</span></h2>
<p><span class="koboSpan" id="kobo.677.1">There is a wide range of</span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.678.1"> metrics that we can measure when quantifying the quality </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">of software:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.680.1">Requirement coverage</span></strong><span class="koboSpan" id="kobo.681.1">: This indicates the percentage of your project requirements that are covered by tests. </span><span class="koboSpan" id="kobo.681.2">A test could cover multiple requirements, but no customer requirement should be </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">left untested.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.683.1">Defect count and distribution</span></strong><span class="koboSpan" id="kobo.684.1">: This indicates how many defects or bugs are discovered in each module/part of the application. </span><span class="koboSpan" id="kobo.684.2">The distribution will also signal whether there are any particular problem areas in the system that could </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">be refactored.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.686.1">Defect resolution time</span></strong><span class="koboSpan" id="kobo.687.1">: This indicates how quickly the development team is able to fix bugs once they are detected. </span><span class="koboSpan" id="kobo.687.2">A long </span><strong class="bold"><span class="koboSpan" id="kobo.688.1">Mean Time To Resolution</span></strong><span class="koboSpan" id="kobo.689.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.690.1">MTTR</span></strong><span class="koboSpan" id="kobo.691.1">) can indicate </span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.692.1">that the development team is short-staffed, while a long max resolution time in a particular area of the system can indicate that the code in that particular part is difficult </span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">to change.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.694.1">Code coverage</span></strong><span class="koboSpan" id="kobo.695.1">: This indicates the percentage of your code base that is exercised by unit tests. </span><span class="koboSpan" id="kobo.695.2">Since tests should be written first, coverage also shows whether the development team is using TDD. </span><span class="koboSpan" id="kobo.695.3">Low test coverage can also indicate issues with the </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">system design.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.697.1">Burndown rates and charts</span></strong><span class="koboSpan" id="kobo.698.1">: These indicate the rate at which the team is able to deliver functionality. </span><span class="koboSpan" id="kobo.698.2">As development and testing are a unified task, a user story or requirement cannot be considered complete unless it is tested, so the burndown rate will </span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.699.1">include only stories that are ready for delivery. </span><span class="koboSpan" id="kobo.699.2">Burndown charts can indicate delays in </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">project timelines.</span></span></li>
</ul>
<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/><span class="koboSpan" id="kobo.701.1">Code coverage</span></h2>
<p><span class="koboSpan" id="kobo.702.1">Since the code coverage</span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.703.1"> metric is such an important TDD indicator, let’s explore it further. </span><span class="koboSpan" id="kobo.703.2">In order to achieve a high coverage percentage, tests should cover </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.705.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.706.1">functions</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.707.1">you implemented</span></span></li>
<li><span class="koboSpan" id="kobo.708.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.709.1">statements</span></strong><span class="koboSpan" id="kobo.710.1"> that your functions are </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">composed of</span></span></li>
<li><span class="koboSpan" id="kobo.712.1">The different </span><strong class="bold"><span class="koboSpan" id="kobo.713.1">execution paths</span></strong><span class="koboSpan" id="kobo.714.1"> of </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">your functions</span></span></li>
<li><span class="koboSpan" id="kobo.716.1">The different </span><strong class="bold"><span class="koboSpan" id="kobo.717.1">conditions</span></strong><span class="koboSpan" id="kobo.718.1"> of your </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">Boolean variables</span></span></li>
<li><span class="koboSpan" id="kobo.720.1">The different </span><strong class="bold"><span class="koboSpan" id="kobo.721.1">parameter values</span></strong><span class="koboSpan" id="kobo.722.1"> that can be passed to </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">your functions</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.724.1">The Go test runner provides the coverage percentage for Go applications. </span><span class="koboSpan" id="kobo.724.2">We will have a look at how to do this in </span><a href="B18371_02.xhtml#_idTextAnchor035"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.725.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.726.1">, </span><em class="italic"><span class="koboSpan" id="kobo.727.1">Unit </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.728.1">Testing Essentials.</span></em></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.729.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.730.1">.11</span></em><span class="koboSpan" id="kobo.731.1"> shows a flow chart of the implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">Divide(x,y)</span></strong><span class="koboSpan" id="kobo.733.1"> function from the simple </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">terminal calculator:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer017">
<span class="koboSpan" id="kobo.735.1"><img alt="Figure 1.11 – Execution flow of the Divide function in the simple calculator " src="image/Figure_1.11_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.736.1">Figure 1.11 – Execution flow of the Divide function in the simple calculator</span></p>
<p><span class="koboSpan" id="kobo.737.1">Tests should be written to cover and verify </span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.739.1">The execution path for </span><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">y != 0</span></strong></li>
<li><span class="koboSpan" id="kobo.741.1">The execution path for </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">y == 0</span></strong></li>
<li><span class="koboSpan" id="kobo.743.1">The error message of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">DivideZero</span></strong></span><span class="No-Break"> </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">error</span></span></li>
<li><span class="koboSpan" id="kobo.746.1">The output from the result </span><span class="No-Break"><span class="koboSpan" id="kobo.747.1">calculation statements</span></span></li>
<li><span class="koboSpan" id="kobo.748.1">The output </span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.749.1">from the print </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">result statements</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.751.1">Code coverage percentage</span></h3>
<p><span class="koboSpan" id="kobo.752.1">In large projects, it will be unfeasible </span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.753.1">to reach 100% test coverage for the code base. </span><span class="koboSpan" id="kobo.753.2">There have been many discussions in the tech community about what a </span><em class="italic"><span class="koboSpan" id="kobo.754.1">good</span></em><span class="koboSpan" id="kobo.755.1"> test coverage percentage is. </span><span class="koboSpan" id="kobo.755.2">It is generally accepted that a good coverage amount is around the 80% mark. </span><span class="koboSpan" id="kobo.755.3">After that point, experience shows there can be </span><span class="No-Break"><span class="koboSpan" id="kobo.756.1">diminishing returns.</span></span></p>
<p><span class="koboSpan" id="kobo.757.1">The code coverage percentage will also depend on the kind of project you are running. </span><span class="koboSpan" id="kobo.757.2">A legacy code base with a low code coverage percentage will require considerable effort to bring up to the 80% mark. </span><span class="koboSpan" id="kobo.757.3">Similarly, a greenfield project will also be difficult to test if there are </span><span class="No-Break"><span class="koboSpan" id="kobo.758.1">many unknowns.</span></span></p>
<p><span class="koboSpan" id="kobo.759.1">Just like any code you write, test code needs to be maintained and refactored. </span><span class="koboSpan" id="kobo.759.2">Keeping a high coverage percentage requires maintaining and updating a lot of test code. </span><span class="koboSpan" id="kobo.759.3">This can increase the development cost of refactoring or other code changes, as it potentially requires updating many test cases. </span><span class="koboSpan" id="kobo.759.4">The business value of maintaining tests that do not cover requirements is very </span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.760.1">low, so you should ensure that your tests are providing value to your </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">test suites.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.762.1">Well-tested code is not necessarily bug-free code</span></p>
<p class="callout"><span class="koboSpan" id="kobo.763.1">Your tests should aim to provide verification for important code behavior, as opposed to simply writing code to get a certain code coverage percentage. </span><span class="koboSpan" id="kobo.763.2">The team should embrace a testing culture using TDD and a good coverage percentage </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">will follow.</span></span></p>
<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/><span class="koboSpan" id="kobo.765.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.766.1">In this chapter, we covered all the testing fundamentals that you will need to get started with TDD. </span><span class="koboSpan" id="kobo.766.2">We began with an explanation of what Agile is and how TDD fits into the Agile development process. </span><span class="koboSpan" id="kobo.766.3">You learned about the different types of automated tests and the testing pyramid. </span><span class="koboSpan" id="kobo.766.4">Then, we looked at the iterative process of delivering code with TDD using the red, green, and refactor process, and explored some TDD best practices on how to structure and </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">write tests.</span></span></p>
<p><span class="koboSpan" id="kobo.768.1">In </span><a href="B18371_02.xhtml#_idTextAnchor035"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.769.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.770.1">, </span><em class="italic"><span class="koboSpan" id="kobo.771.1">Unit Testing Essentials</span></em><span class="koboSpan" id="kobo.772.1">, we will learn how to write tests in Go and begin to get some hands-on experience with TDD. </span><span class="koboSpan" id="kobo.772.2">We will begin to use the red, green, and refactor process and write tests according to the TDD best practices that we </span><span class="No-Break"><span class="koboSpan" id="kobo.773.1">have learned.</span></span></p>
<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/><span class="koboSpan" id="kobo.774.1">Questions</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.775.1">What is the testing pyramid? </span><span class="koboSpan" id="kobo.775.2">What are </span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">its components?</span></span></li>
<li><span class="koboSpan" id="kobo.777.1">What is the difference between functional and </span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">non-functional tests?</span></span></li>
<li><span class="koboSpan" id="kobo.779.1">Explain what the red, green, and refactor TDD </span><span class="No-Break"><span class="koboSpan" id="kobo.780.1">approach is.</span></span></li>
<li><span class="koboSpan" id="kobo.781.1">What </span><span class="No-Break"><span class="koboSpan" id="kobo.782.1">is ATDD?</span></span></li>
<li><span class="koboSpan" id="kobo.783.1">What is </span><span class="No-Break"><span class="koboSpan" id="kobo.784.1">code coverage?</span></span></li>
</ol>
<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/><span class="koboSpan" id="kobo.785.1">Further reading</span></h1>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.786.1">Learning Agile: Understanding Scrum, XP, Lean, and Kanban</span></em><span class="koboSpan" id="kobo.787.1"> – Andrew Stellman and Jennifer Greene, published by </span><span class="No-Break"><span class="koboSpan" id="kobo.788.1">O’Reilly Media</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.789.1">Test Driven Development: By Example</span></em><span class="koboSpan" id="kobo.790.1"> – Kent Beck, published by Addison-Wesley </span><span class="No-Break"><span class="koboSpan" id="kobo.791.1">Signature Series</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.792.1">Clean Code: A Handbook of Agile Software Craftsmanship</span></em><span class="koboSpan" id="kobo.793.1"> – Robert C. </span><span class="koboSpan" id="kobo.793.2">Martin, published by </span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">Prentice Hall</span></span></li>
</ul>
<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/><span class="koboSpan" id="kobo.795.1">Answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.796.1">The testing pyramid specifies how automated test suites should be structured. </span><span class="koboSpan" id="kobo.796.2">At the bottom of the pyramid are unit tests, which test a single isolated component. </span><span class="koboSpan" id="kobo.796.3">Next up in the middle of the pyramid are integration tests, which test that multiple components are able to work together as specified. </span><span class="koboSpan" id="kobo.796.4">Finally, at the top of the test pyramid are end-to-end tests that test the behavior of the </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">entire application.</span></span></li>
<li><span class="koboSpan" id="kobo.798.1">Functional tests cover the correctness of a system, while non-functional tests cover the usability and performance of a system. </span><span class="koboSpan" id="kobo.798.2">Both types of tests are required to ensure that the system satisfies the </span><span class="No-Break"><span class="koboSpan" id="kobo.799.1">customers’ needs.</span></span></li>
<li><span class="koboSpan" id="kobo.800.1">The red, green, and refactor TDD approach refers to the three phases of the process. </span><span class="koboSpan" id="kobo.800.2">The red phase involves writing a new failing test for the functionality we intend to implement. </span><span class="koboSpan" id="kobo.800.3">The green phase involves writing enough implementation code to make all tests pass. </span><span class="koboSpan" id="kobo.800.4">Finally, the refactor phase involves optimizing both implementation and testing code to remove duplication and come up with </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">better solutions.</span></span></li>
<li><span class="koboSpan" id="kobo.802.1">Acceptance test-driven development. </span><span class="koboSpan" id="kobo.802.2">Just like TDD, ATDD puts tests first. </span><span class="koboSpan" id="kobo.802.3">ATDD is related to TDD, but it involves writing a suite of acceptance tests before the implementation begins. </span><span class="koboSpan" id="kobo.802.4">It involves multiple stakeholders to ensure that the acceptance test captures the </span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">customer’s requirements.</span></span></li>
<li><span class="koboSpan" id="kobo.804.1">Code coverage is the percentage of your lines of code that are exercised by your unit test. </span><span class="koboSpan" id="kobo.804.2">This is calculated by considering the function statements, parameter values, and execution paths of your code. </span><span class="koboSpan" id="kobo.804.3">The Go test runner outputs the calculated code coverage. </span><span class="koboSpan" id="kobo.804.4">We should aim for a good value, but optimizing for 100% is normally </span><span class="No-Break"><span class="koboSpan" id="kobo.805.1">not appropriate.</span></span></li>
</ol>
</div>
</body></html>