<html><head></head><body>
<div id="_idContainer027">
<h1 class="chapter-number" id="_idParaDest-36"><a id="_idTextAnchor035"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/><span class="koboSpan" id="kobo.2.1">Unit Testing Essentials</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we learned all about the iterative process of writing tests alongside code using TDD, as well as how it fits</span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.4.1"> into the </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">Agile project methodology</span></strong><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">We</span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.7.1"> covered the </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">red, green, refactor approach</span></strong><span class="koboSpan" id="kobo.9.1">, which requires frequent switching between source code and </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">test code.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">When first starting with TDD, following a prescribed process for writing code may seem like an artificial way of working, but it soon becomes second nature with practice. </span><span class="koboSpan" id="kobo.11.2">In this chapter, we will learn all the Go fundamentals required to begin putting everything else we have learned to use. </span><span class="koboSpan" id="kobo.11.3">We will begin to write unit tests with Go’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.12.1">testing</span></strong><span class="koboSpan" id="kobo.13.1"> package, focusing on the test writing syntax and process. </span><span class="koboSpan" id="kobo.13.2">This chapter will allow us to get hands-on experience with all the concepts we have explored </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">so far.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">As we saw </span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.16.1">from the </span><strong class="bold"><span class="koboSpan" id="kobo.17.1">testing pyramid</span></strong><span class="koboSpan" id="kobo.18.1"> in </span><a href="B18371_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.19.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.20.1">, </span><em class="italic"><span class="koboSpan" id="kobo.21.1">Getting to Grips with Test-Driven Development</span></em><span class="koboSpan" id="kobo.22.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.23.1">unit tests</span></strong><span class="koboSpan" id="kobo.24.1"> are the most numerous. </span><span class="koboSpan" id="kobo.24.2">They are used to verify the functionality of a single unit, in isolation. </span><span class="koboSpan" id="kobo.24.3">We will begin our exploration of TDD and Go testing by implementing </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">unit tests.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">The Go programming language was created by the team at Google to allow developers to write simple and efficient software, which they felt was not achievable with the tools they had available at the time. </span><span class="koboSpan" id="kobo.26.2">This principle of simplicity is echoed throughout the entire language, including its test writing and </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">running functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">The Go standard library provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.29.1">testing</span></strong><span class="koboSpan" id="kobo.30.1"> package, which provides the essentials we need for writing automated tests. </span><span class="koboSpan" id="kobo.30.2">Tests are simply functions that satisfy certain conventions and signatures, making it easier for developers to write code using the same strategies and mechanisms as they write their </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">source code.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">The Go toolchain provides a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">go test</span></strong><span class="koboSpan" id="kobo.34.1"> command for running all the tests that we have defined. </span><span class="koboSpan" id="kobo.34.2">This simple yet powerful command also provides functionality for running benchmarks, which we can use to examine the performance of a </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">given component.</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">In this chapter, we will cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.38.1">The Go package as the </span><strong class="bold"><span class="koboSpan" id="kobo.39.1">Unit Under </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.40.1">Test</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.41.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.42.1">UUT</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.44.1">The fundamentals of working with Go’s </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">testing package</span></span></li>
<li><span class="koboSpan" id="kobo.46.1">Test setup </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">and teardown</span></span></li>
<li><span class="koboSpan" id="kobo.48.1">Grouping tests into suites </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">with subtests</span></span></li>
<li><span class="koboSpan" id="kobo.50.1">The difference between a test and </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">a benchmark</span></span></li>
</ul>
<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/><span class="koboSpan" id="kobo.52.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.53.1">You will need to have </span><strong class="bold"><span class="koboSpan" id="kobo.54.1">Go version 1.19</span></strong><span class="koboSpan" id="kobo.55.1"> or later installed to run the code samples in this chapter. </span><span class="koboSpan" id="kobo.55.2">The installation process is described in the official Go documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">at </span></span><a href="https://go.dev/doc/install"><span class="No-Break"><span class="koboSpan" id="kobo.57.1">https://go.dev/doc/install</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.58.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">The code examples included in this book are publicly available </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">at </span></span><a href="https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter02"><span class="No-Break"><span class="koboSpan" id="kobo.61.1">https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter02</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.62.1">.</span></span></p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor038"/><span class="koboSpan" id="kobo.63.1">The unit under test</span></h1>
<p><span class="koboSpan" id="kobo.64.1">In </span><a href="B18371_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.65.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.66.1">, </span><em class="italic"><span class="koboSpan" id="kobo.67.1">Getting to Grips with Test-Driven Development</span></em><span class="koboSpan" id="kobo.68.1">, we discussed the structure of </span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.69.1">tests </span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.70.1">using the </span><strong class="bold"><span class="koboSpan" id="kobo.71.1">Arrange-Act-Assert</span></strong><span class="koboSpan" id="kobo.72.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.73.1">AAA</span></strong><span class="koboSpan" id="kobo.74.1">) pattern. </span><span class="koboSpan" id="kobo.74.2">We also briefly mentioned that the Arrange step sets up the </span><strong class="bold"><span class="koboSpan" id="kobo.75.1">Unit Under Test</span></strong><span class="koboSpan" id="kobo.76.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.77.1">UUT</span></strong><span class="koboSpan" id="kobo.78.1">) and its dependencies. </span><span class="koboSpan" id="kobo.78.2">The test then exercises and verifies the functionality of </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">the UUT.</span></span></p>
<p><span class="koboSpan" id="kobo.80.1">In Go, source code is organized into packages and modules. </span><span class="koboSpan" id="kobo.80.2">We will begin by exploring what these are and how they work and then look at how test files fit into this structure. </span><span class="koboSpan" id="kobo.80.3">A solid understanding of the power of packages will set the scene for us to begin considering not only </span><em class="italic"><span class="koboSpan" id="kobo.81.1">how</span></em><span class="koboSpan" id="kobo.82.1"> to write tests, but </span><em class="italic"><span class="koboSpan" id="kobo.83.1">what</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.84.1">to test.</span></span></p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/><span class="koboSpan" id="kobo.85.1">Modules and packages</span></h2>
<p><span class="koboSpan" id="kobo.86.1">If you have worked with Go for a while, you might be familiar with Go’s </span><strong class="bold"><span class="koboSpan" id="kobo.87.1">module system</span></strong><span class="koboSpan" id="kobo.88.1">, which was introduced as the default dependency management solution in </span><strong class="bold"><span class="koboSpan" id="kobo.89.1">Go 1.13</span></strong><span class="koboSpan" id="kobo.90.1">. </span><span class="koboSpan" id="kobo.90.2">The latest Go version at the time of writing is </span><strong class="bold"><span class="koboSpan" id="kobo.91.1">version 1.19</span></strong><span class="koboSpan" id="kobo.92.1">, so the module system has been the standard solution for </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">some time.</span></span></p>
<h3><span class="koboSpan" id="kobo.94.1">Modules</span></h3>
<p><span class="koboSpan" id="kobo.95.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.96.1">module</span></strong><span class="koboSpan" id="kobo.97.1"> is a collection</span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.98.1"> of packages that are distributed and</span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.99.1"> released together. </span><span class="koboSpan" id="kobo.99.2">The name of the module should be representative of its functionality, as well as where to find it. </span><span class="koboSpan" id="kobo.99.3">The Go toolchain provides support for popular code hosting solutions such as GitHub and Bitbucket and can issue the correct requests for downloading dependencies from their version </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">control systems.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">Modules are declared by placing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">go.mod</span></strong><span class="koboSpan" id="kobo.103.1"> file at the root of the project directory. </span><span class="koboSpan" id="kobo.103.2">A new module can be initialized by running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">go mod init</span></strong><span class="koboSpan" id="kobo.105.1"> command with a module path as a parameter. </span><span class="koboSpan" id="kobo.105.2">We can initialize the module for all our code examples by running the following command in </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">the Terminal:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.107.1">
$ go mod init "github.com/PacktPublishing/Test-Driven-Development-in-Go"</span></pre>
<p><span class="koboSpan" id="kobo.108.1">The module path we have provided is the same as the GitHub repository path. </span><span class="koboSpan" id="kobo.108.2">The generated file only contains two lines – one for the module path and one for the version of </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">Go required:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.110.1">
module github.com/PacktPublishing/Test-Driven-Development-in-Go
go 1.19</span></pre>
<p><span class="koboSpan" id="kobo.111.1">In general, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">go.mod</span></strong><span class="koboSpan" id="kobo.113.1"> file </span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.114.1">contains </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">these properties:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.116.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">module path</span></span></li>
<li><span class="koboSpan" id="kobo.118.1">The version of Go required for </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">the project</span></span></li>
<li><span class="koboSpan" id="kobo.120.1">Any external dependencies that need to be imported when building </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">the project</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.122.1">Since our project is empty for now, our module’s file does not specify any external dependencies. </span><span class="koboSpan" id="kobo.122.2">The packages of the standard library do not need to be declared as dependencies. </span><span class="koboSpan" id="kobo.122.3">This file will be automatically updated with dependencies once they are used in the source code of </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">the module.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.124.1">The generated go.mod file</span></p>
<p class="callout"><span class="koboSpan" id="kobo.125.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">go.mod</span></strong><span class="koboSpan" id="kobo.127.1"> file is generated, but</span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.128.1"> not read-only. </span><span class="koboSpan" id="kobo.128.2">However, as a rule of thumb, you should avoid editing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">go.mod</span></strong><span class="koboSpan" id="kobo.130.1"> file manually. </span><span class="koboSpan" id="kobo.130.2">In general, developers edit it only to change version numbers, not to manually change its entries. </span><span class="koboSpan" id="kobo.130.3">You can also recreate it any time with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">go mod </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">init</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.133.1"> command.</span></span></p>
<h3><span class="koboSpan" id="kobo.134.1">Packages</span></h3>
<p><span class="koboSpan" id="kobo.135.1">While modules are </span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.136.1">a fantastic way to bundle and release </span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.137.1">projects, most production systems would be almost impossible to maintain or understand if they did not have any internal organization or hierarchy. </span><span class="koboSpan" id="kobo.137.2">This is where Go packages come in to help us provide this </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">much-needed structure.</span></span></p>
<p><span class="koboSpan" id="kobo.139.1">Go source code is organized into </span><strong class="bold"><span class="koboSpan" id="kobo.140.1">packages</span></strong><span class="koboSpan" id="kobo.141.1">. </span><span class="koboSpan" id="kobo.141.2">The first line of every source file must be the package declaration, which can be done using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">package</span></strong><span class="koboSpan" id="kobo.143.1"> keyword. </span><span class="koboSpan" id="kobo.143.2">All the names defined in the source file are then added to the </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">declared package.</span></span></p>
<p><span class="koboSpan" id="kobo.145.1">Looking back at the simple terminal calculator example from </span><a href="B18371_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.146.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.147.1">, </span><em class="italic"><span class="koboSpan" id="kobo.148.1">Getting to Grips with Test-Driven Development</span></em><span class="koboSpan" id="kobo.149.1">, we can specify a package and source code structure for it, as seen in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.150.1">Figure 2</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.151.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">:</span></span></p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div>
<div class="IMG---Figure" id="_idContainer019">
<span class="koboSpan" id="kobo.153.1"><img alt="Figure 2.1 – The module, packages, and source files of the simple Terminal calculator " src="image/Figure_2.01_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.154.1">Figure 2.1 – The module, packages, and source files of the simple Terminal calculator</span></p>
<p><span class="koboSpan" id="kobo.155.1">The module contains three packages, each containing </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">specialized functionality:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.157.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">input</span></strong><span class="koboSpan" id="kobo.159.1"> package contains an input parser and validation functionality. </span><span class="koboSpan" id="kobo.159.2">It has dependencies on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">calculator</span></strong><span class="koboSpan" id="kobo.161.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">format</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.163.1"> packages.</span></span></li>
<li><span class="koboSpan" id="kobo.164.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">calculator</span></strong><span class="koboSpan" id="kobo.166.1"> package contains all the calculation engine logic, providing functionality for all the operations that the calculator provides. </span><span class="koboSpan" id="kobo.166.2">It has a dependency on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">format</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.168.1"> package.</span></span></li>
<li><span class="koboSpan" id="kobo.169.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">format</span></strong><span class="koboSpan" id="kobo.171.1"> package contains formatting logic for results and errors. </span><span class="koboSpan" id="kobo.171.2">It has no dependencies on our </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">existing packages.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.173.1">Package naming is important</span></p>
<p class="callout"><span class="koboSpan" id="kobo.174.1">Package names</span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.175.1"> should be representative of the functionality they provide so that other code may reference them. </span><span class="koboSpan" id="kobo.175.2">Package names should be short and descriptive. </span><span class="koboSpan" id="kobo.175.3">They should also be meaningful when used along with the names of the types and functions </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">they provide.</span></span></p>
<p><span class="koboSpan" id="kobo.177.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">format</span></strong><span class="koboSpan" id="kobo.179.1"> package is</span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.180.1"> at the bottom of our package hierarchy, and</span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.181.1"> we can begin by defining it and its result formatting capabilities immediately. </span><span class="koboSpan" id="kobo.181.2">Looking at the contents of its </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">result.go</span></strong><span class="koboSpan" id="kobo.183.1"> source file, we can see its </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">simple definition:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.185.1">
package format
func Result(expression string, result float64) string {
</span><strong class="bold"><span class="koboSpan" id="kobo.186.1">  // implementation code</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.187.1">  return ""</span></strong><span class="koboSpan" id="kobo.188.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.189.1">This package defines a </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">Result</span></strong><span class="koboSpan" id="kobo.191.1"> function that outputs a formatted string of the given expression and result. </span><span class="koboSpan" id="kobo.191.2">We added the return of an empty string to ensure the code compiles until we are ready to begin implementation with TDD. </span><span class="koboSpan" id="kobo.191.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">error.go</span></strong><span class="koboSpan" id="kobo.193.1"> file is similarly defined and has been omitted </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">for brevity.</span></span></p>
<p><span class="koboSpan" id="kobo.195.1">Looking at the calculator engine in more detail, the contents of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">engine.go</span></strong><span class="koboSpan" id="kobo.197.1"> source file can begin </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">like so:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.199.1">package calculator</span></strong><span class="koboSpan" id="kobo.200.1">
type Engine struct {}
func(e *Engine) Add(x, y float64) float64{
</span><strong class="bold"><span class="koboSpan" id="kobo.201.1">  // implementation code</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.202.1">  </span></strong><strong class="bold"><span class="koboSpan" id="kobo.203.1">return 0</span></strong><span class="koboSpan" id="kobo.204.1">
}
// ... </span><span class="koboSpan" id="kobo.204.2">method declarations</span></pre>
<p><span class="koboSpan" id="kobo.205.1">We begin with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">package calculator</span></strong><span class="koboSpan" id="kobo.207.1"> definition, adding the source file and all its definitions to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">calculator</span></strong><span class="koboSpan" id="kobo.209.1"> package. </span><span class="koboSpan" id="kobo.209.2">Then, we create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">Engine</span></strong><span class="koboSpan" id="kobo.211.1"> type that will contain all the dependencies of the calculator. </span><span class="koboSpan" id="kobo.211.2">After these few lines, we can begin to define methods for all the operations that the engine needs to provide. </span><span class="koboSpan" id="kobo.211.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">Add</span></strong><span class="koboSpan" id="kobo.213.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">Engine</span></strong><span class="koboSpan" id="kobo.215.1"> type is an example of what the definition of the addition </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">operation is.</span></span></p>
<p><span class="koboSpan" id="kobo.217.1">Those of you who </span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.218.1">are </span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.219.1">eagle-eyed will notice that the types, methods, and functions have been defined with a capital letter. </span><span class="koboSpan" id="kobo.219.2">This makes them </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.220.1">exported names</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.222.1">Visibility outside of the package</span></p>
<p class="callout"><span class="koboSpan" id="kobo.223.1">Only the exported names of a package are visible for usage outside of their defined package. </span><span class="koboSpan" id="kobo.223.2">Unlike other languages, there are no visibility modifiers in Go. </span><span class="koboSpan" id="kobo.223.3">In the code examples for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">format</span></strong><span class="koboSpan" id="kobo.225.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">calculator</span></strong><span class="koboSpan" id="kobo.227.1"> packages, we need their functionality to be available outside of their respective packages, so this is why they have been exported and defined with a </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">capital letter.</span></span></p>
<p><span class="koboSpan" id="kobo.229.1">A package can declare a dependency on another package by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">import</span></strong><span class="koboSpan" id="kobo.231.1"> keyword. </span><span class="koboSpan" id="kobo.231.2">We can then reference the variables, types, and functions of the imported package by qualifying them with the package</span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.232.1"> name and the </span><strong class="bold"><span class="koboSpan" id="kobo.233.1">dot </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.234.1">operator</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.235.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.236.1">.</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.238.1">With some exceptions, there can only be one single package name per directory. </span><span class="koboSpan" id="kobo.238.2">The declaration of the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">input</span></strong><span class="koboSpan" id="kobo.240.1"> package will also require the creation of a new directory. </span><span class="koboSpan" id="kobo.240.2">The declaration of </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">Parser</span></strong><span class="koboSpan" id="kobo.242.1">, which has a dependency on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">Engine</span></strong><span class="koboSpan" id="kobo.244.1"> type, looks </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.246.1">
package input
</span><strong class="bold"><span class="koboSpan" id="kobo.247.1">import "github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter02/calculator"</span></strong><span class="koboSpan" id="kobo.248.1">
type Parser struct {
</span><strong class="bold"><span class="koboSpan" id="kobo.249.1">  engine *calculator.Engine</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.250.1">  validator *Validator</span></strong><span class="koboSpan" id="kobo.251.1">
}
func (p *Parser) ProcessExpression(expr string) (*string, error) {
</span><strong class="bold"><span class="koboSpan" id="kobo.252.1">  // implementation code</span></strong><span class="koboSpan" id="kobo.253.1">
}
// ... </span><span class="koboSpan" id="kobo.253.2">method declarations</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">Parser</span></strong><span class="koboSpan" id="kobo.255.1"> is </span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.256.1">declared </span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.257.1">as part of </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">package input</span></strong><span class="koboSpan" id="kobo.259.1">. </span><span class="koboSpan" id="kobo.259.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">Parser</span></strong><span class="koboSpan" id="kobo.261.1"> type needs the functionality of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">Calculator</span></strong><span class="koboSpan" id="kobo.263.1"> type, so it imports the </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">calculator</span></strong><span class="koboSpan" id="kobo.265.1"> package. </span><span class="koboSpan" id="kobo.265.2">As mentioned, the reference to </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">calculator.Engine</span></strong><span class="koboSpan" id="kobo.267.1"> is qualified using its provided package and the dot operator. </span><span class="koboSpan" id="kobo.267.2">This lets the compiler know that the type referenced is coming from an imported package, not the </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">current package.</span></span></p>
<p><span class="koboSpan" id="kobo.269.1">The highlighted import path consists of </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">three parts:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.271.1">The module that the package belongs </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">to: </span></span><a href="http://github.com/PacktPublishing/Test-Driven-Development-in-Go"><span class="No-Break"><span class="koboSpan" id="kobo.273.1">github.com/PacktPublishing/Test-Driven-Development-in-Go</span></span></a></li>
<li><span class="koboSpan" id="kobo.274.1">The sub-directory path from the root of the </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">module: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">chapter02</span></strong></span></li>
<li><span class="koboSpan" id="kobo.277.1">The name of the imported </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">package: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">calculator</span></strong></span></li>
</ul>
<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/><span class="koboSpan" id="kobo.280.1">The power of Go packages</span></h2>
<p><span class="koboSpan" id="kobo.281.1">Packages are a </span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.282.1">powerful and central concept to Go. </span><span class="koboSpan" id="kobo.282.2">They </span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.283.1">allow developers to do </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.285.1">Group components</span></strong><span class="koboSpan" id="kobo.286.1">: When named well, packages provide an easy way to understand, uniquely group, and document multiple components that share the </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">same functionality.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.288.1">Encapsulate code</span></strong><span class="koboSpan" id="kobo.289.1">: Since only exported methods are visible to external code, packages are the most important encapsulation mechanism in Go. </span><span class="koboSpan" id="kobo.289.2">They give developers fine-grained control over exactly what is available for use outside of </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">the package.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.291.1">Reuse code</span></strong><span class="koboSpan" id="kobo.292.1">: Packages provide modularity to our programs, allowing us to reuse code in multiple places by providing a way for users to import them. </span><span class="koboSpan" id="kobo.292.2">The ability to leverage code from outside the current module allows developers to share the same solutions, without reinventing </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">the wheel.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.294.1">Easily manage dependencies</span></strong><span class="koboSpan" id="kobo.295.1">: Go’s module system follows </span><strong class="bold"><span class="koboSpan" id="kobo.296.1">Semantic Versioning</span></strong><span class="koboSpan" id="kobo.297.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.298.1">SemVer</span></strong><span class="koboSpan" id="kobo.299.1">), which</span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.300.1"> uses three primary numbers to manage imported dependencies: the major, the minor, and the patch version. </span><span class="koboSpan" id="kobo.300.2">This allows developers to pin dependencies to a certain version, as well as easily know when they need to upgrade to a </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">newer version.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.302.1">Now that we understand the fundamentals of modules and packages, let’s turn our attention toward where testing fits into the codebase and its packages. </span><span class="koboSpan" id="kobo.302.2">Notice that the methods of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">Engine</span></strong><span class="koboSpan" id="kobo.304.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">Parser</span></strong><span class="koboSpan" id="kobo.306.1"> custom types do not have any code implemented yet: this is because TDD is all about writing </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">tests first!</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.308.1">Packages as APIs</span></p>
<p class="callout"><span class="koboSpan" id="kobo.309.1">Due to their</span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.310.1"> encapsulation</span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.311.1"> and modularity properties, packages enable developers to build and structure their code using similar techniques as when designing external APIs, by choosing the signatures and functions they want to provide to </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">external users.</span></span></p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.313.1">Test file naming and placement</span></h2>
<p><span class="koboSpan" id="kobo.314.1">Unlike other</span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.315.1"> programming languages, test files live alongside the source code in Go. </span><span class="koboSpan" id="kobo.315.2">All test files must end with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">_test.go</span></strong><span class="koboSpan" id="kobo.317.1"> suffix. </span><span class="koboSpan" id="kobo.317.2">Go’s test runner scans the codebase for these test files and runs them accordingly. </span><span class="koboSpan" id="kobo.317.3">The test runner is part of the Go toolchain and can be invoked using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">go </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">test</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.320.1"> command.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.321.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.322.1">.2</span></em><span class="koboSpan" id="kobo.323.1"> presents the directory structure of the simple terminal calculator discussed </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">so far:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer020">
<span class="koboSpan" id="kobo.325.1"><img alt="Figure 2.2 – The directory structure of the simple Terminal calculator " src="image/Figure_2.02_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.326.1">Figure 2.2 – The directory structure of the simple Terminal calculator</span></p>
<p><span class="koboSpan" id="kobo.327.1">All the code that we will be discussing in this chapter can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">chapter02</span></strong><span class="koboSpan" id="kobo.329.1"> directory of the dedicated repository corresponding to this book. </span><span class="koboSpan" id="kobo.329.2">Then, inside this directory, we have three further directories for </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">format</span></strong><span class="koboSpan" id="kobo.331.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">calculator</span></strong><span class="koboSpan" id="kobo.333.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">input</span></strong><span class="koboSpan" id="kobo.335.1">, which each contain their source code files and corresponding </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">test files.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.337.1">Naming test files</span></p>
<p class="callout"><span class="koboSpan" id="kobo.338.1">While test files</span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.339.1"> need to end with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">_test.go</span></strong><span class="koboSpan" id="kobo.341.1"> suffix, matching the rest of their name to their corresponding source code file is not enforced. </span><span class="koboSpan" id="kobo.341.2">However, it is highly recommended that you use the source filename and then append the test suffix. </span><span class="koboSpan" id="kobo.341.3">This will also ensure that the two files stay together when </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">sorted lexicographically.</span></span></p>
<p><span class="koboSpan" id="kobo.343.1">The source files and test files live directly next to each other, in the same directory, making it even easier for developers to swap between writing implementation code and test code when</span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.344.1"> practicing TDD. </span><span class="koboSpan" id="kobo.344.2">Some editing tools can even do this with a </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">keyboard shortcut!</span></span></p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.346.1">Additional test packages</span></h2>
<p><span class="koboSpan" id="kobo.347.1">Although test files</span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.348.1"> are named the same as their corresponding source files and live in the same directory, the package structure will tell a different story. </span><span class="koboSpan" id="kobo.348.2">We previously mentioned that, with some exceptions, only one package may be declared per directory. </span><span class="koboSpan" id="kobo.348.3">Test files are one of </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">these exceptions.</span></span></p>
<p><span class="koboSpan" id="kobo.350.1">Test files are allowed to declare an additional test package, matching the source files package with </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">_test</span></strong><span class="koboSpan" id="kobo.352.1"> appended. </span><span class="koboSpan" id="kobo.352.2">From a visibility perspective, this test package is the same as any other package and will need to import the packages that it wishes to have access to. </span><span class="koboSpan" id="kobo.352.3">It will also only have access to the exported names of its </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">imported packages.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.354.1">Test packages as a recommended practice</span></p>
<p class="callout"><span class="koboSpan" id="kobo.355.1">The usage of the dedicated </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">_test</span></strong><span class="koboSpan" id="kobo.357.1"> package is not enforced in Go, but it is recommended. </span><span class="koboSpan" id="kobo.357.2">Whenever possible, you should declare your tests in a dedicated </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">test package.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.359.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.360.1">.3</span></em><span class="koboSpan" id="kobo.361.1"> depicts the separate definitions of test packages in the simple </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">Terminal calculator:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer021">
<span class="koboSpan" id="kobo.363.1"><img alt="Figure 2.3 – The package and directory structure of the simple calculator " src="image/Figure_2.03_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.364.1">Figure 2.3 – The package and directory structure of the simple calculator</span></p>
<p><span class="koboSpan" id="kobo.365.1">The dedicated test</span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.366.1"> package is defined in the same directory as the source package, achieving full separation between the source and test code. </span><span class="koboSpan" id="kobo.366.2">Using the dedicated test package brings the</span><a id="_idIndexMarker118"/> <span class="No-Break"><span class="koboSpan" id="kobo.367.1">following advantages:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.368.1">Prevents brittle tests</span></strong><span class="koboSpan" id="kobo.369.1">: Restricting access to only exported functionality does not give test code visibility into package internals, such as state variables, which would otherwise cause </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">inconsistent results.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.371.1">Separates test and core package dependencies</span></strong><span class="koboSpan" id="kobo.372.1">: The test package allows the test to import any dependencies required, without adding those dependencies to the core package. </span><span class="koboSpan" id="kobo.372.2">In practice, test code will often have its own dedicated verifiers and functionality, which we would not want to be visible to production code. </span><span class="koboSpan" id="kobo.372.3">The test package is a seamless way to </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">guarantee separation.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.374.1">Allows developers to integrate with their own packages</span></strong><span class="koboSpan" id="kobo.375.1">: We previously mentioned that packages allow developers to build their internal code as small APIs. </span><span class="koboSpan" id="kobo.375.2">Writing tests </span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.376.1">from a dedicated test package allows developers to see how easy it is to integrate with their designed external interfaces, ensuring that their code </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">is maintainable.</span></span></li>
</ul>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.378.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.379.1">.4</span></em><span class="koboSpan" id="kobo.380.1"> shows the </span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.381.1">updated module, packages, source, and test files of the simple Terminal calculator, which now uses </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">_test</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.383.1"> packages:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer022">
<span class="koboSpan" id="kobo.384.1"><img alt="Figure 2.4 – The module, packages, source, and test files of the simple Terminal calculator " src="image/Figure_2.04_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.385.1">Figure 2.4 – The module, packages, source, and test files of the simple Terminal calculator</span></p>
<p><span class="koboSpan" id="kobo.386.1">Let’s describe the dependencies between the packages in terms of the AAA pattern that we know from </span><a href="B18371_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.387.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.388.1">, </span><em class="italic"><span class="koboSpan" id="kobo.389.1">Getting to Grips with Test-Driven Development</span></em><span class="koboSpan" id="kobo.390.1">. </span><span class="koboSpan" id="kobo.390.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.391.1">Arrange</span></strong><span class="koboSpan" id="kobo.392.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.393.1">Assert</span></strong><span class="koboSpan" id="kobo.394.1"> steps are performed on the UUT and are conveniently defined in the correspondingly </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">named package:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.396.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">format</span></strong><span class="koboSpan" id="kobo.398.1"> package does not have any dependencies on other packages. </span><span class="koboSpan" id="kobo.398.2">As a result, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">format_test</span></strong><span class="koboSpan" id="kobo.400.1"> package performs all three steps on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">format</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.402.1"> package.</span></span></li>
<li><span class="koboSpan" id="kobo.403.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">calculator</span></strong><span class="koboSpan" id="kobo.405.1"> package has a dependency on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">format</span></strong><span class="koboSpan" id="kobo.407.1"> package. </span><span class="koboSpan" id="kobo.407.2">As a result, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">calculator_test</span></strong><span class="koboSpan" id="kobo.409.1"> package arranges the dependencies from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">format</span></strong><span class="koboSpan" id="kobo.411.1"> package. </span><span class="koboSpan" id="kobo.411.2">Then, it performs the Act and Assert steps on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">calculator</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.413.1"> package.</span></span></li>
<li><span class="koboSpan" id="kobo.414.1">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">input</span></strong><span class="koboSpan" id="kobo.416.1"> package has a dependency on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">calculator</span></strong><span class="koboSpan" id="kobo.418.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">input</span></strong><span class="koboSpan" id="kobo.420.1"> packages. </span><span class="koboSpan" id="kobo.420.2">As a result, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">input_test</span></strong><span class="koboSpan" id="kobo.422.1"> package arranges the dependencies of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">input</span></strong><span class="koboSpan" id="kobo.424.1"> package, which are provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">calculator</span></strong><span class="koboSpan" id="kobo.426.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">input</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.428.1"> packages.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.429.1">This section has given </span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.430.1">you an introduction to the Go module system and discussed how to place and name tests in the overall codebase. </span><span class="koboSpan" id="kobo.430.2">Now, let’s look at how to implement tests </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">in Go.</span></span></p>
<h1 id="_idParaDest-44"><a id="_idTextAnchor043"/><span class="koboSpan" id="kobo.432.1">Working with the testing package</span></h1>
<p><span class="koboSpan" id="kobo.433.1">The standard library</span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.434.1"> provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">testing</span></strong><span class="koboSpan" id="kobo.436.1"> package, which contains the essentials we need for writing and running tests. </span><span class="koboSpan" id="kobo.436.2">In this section, we will explore how to use it and begin to apply it so that we can write tests for our simple terminal </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">cal</span><a id="_idTextAnchor044"/><span class="koboSpan" id="kobo.438.1">culator example.</span></span></p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor045"/><span class="koboSpan" id="kobo.439.1">The testing package</span></h2>
<p><span class="koboSpan" id="kobo.440.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">testing</span></strong><span class="koboSpan" id="kobo.442.1"> package </span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.443.1">provides support for testing Go code. </span><span class="koboSpan" id="kobo.443.2">It must be imported by all test code as this is the way to interact with the test runner. </span><span class="koboSpan" id="kobo.443.3">At a glance, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">testing</span></strong><span class="koboSpan" id="kobo.445.1"> package seems very simplistic, but it fits with Go’s language design. </span><span class="koboSpan" id="kobo.445.2">Packages should be small, focused, and have a limited number of dependencies. </span><span class="koboSpan" id="kobo.445.3">This should make them easy to test with a relatively simple </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">testing library.</span></span></p>
<p><span class="koboSpan" id="kobo.447.1">Here are some of the important types from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">testing</span></strong><span class="koboSpan" id="kobo.449.1"> library that we will </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">be using:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">testing.T</span></strong><span class="koboSpan" id="kobo.452.1">: All tests must use this type to interact with the test runner. </span><span class="koboSpan" id="kobo.452.2">It contains a method for declaring failing tests, skipping tests, and running tests in parallel. </span><span class="koboSpan" id="kobo.452.3">We will look at and begin to use these methods in </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">this section.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">testing.B</span></strong><span class="koboSpan" id="kobo.455.1">: Analogous to the test runner, this </span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.456.1">type is Go’s </span><strong class="bold"><span class="koboSpan" id="kobo.457.1">benchmark</span></strong><span class="koboSpan" id="kobo.458.1"> runner. </span><span class="koboSpan" id="kobo.458.2">It has the same methods for failing tests, skipping tests, and running benchmarks in parallel. </span><span class="koboSpan" id="kobo.458.3">Benchmarks are special kinds of tests that are used for verifying the performance of your code, as opposed to its functionality. </span><span class="koboSpan" id="kobo.458.4">We will explore benchmarks later in </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">this chapter.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">testing.F</span></strong><span class="koboSpan" id="kobo.461.1">: This type is used to set up and</span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.462.1"> run </span><strong class="bold"><span class="koboSpan" id="kobo.463.1">fuzz tests</span></strong><span class="koboSpan" id="kobo.464.1"> and was added to the Go standard </span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.465.1">toolchain in </span><strong class="bold"><span class="koboSpan" id="kobo.466.1">Go 1.18</span></strong><span class="koboSpan" id="kobo.467.1">. </span><span class="koboSpan" id="kobo.467.2">It creates a randomized seed for the testing target and works together with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">testing.T</span></strong><span class="koboSpan" id="kobo.469.1"> type to provide test-running functionality. </span><span class="koboSpan" id="kobo.469.2">Fuzz tests are special kinds of tests that use random inputs to </span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.470.1">find edge cases and bugs in our code. </span><span class="koboSpan" id="kobo.470.2">We will explore fuzz tests further in </span><a href="B18371_10.xhtml#_idTextAnchor218"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.471.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.472.1">, </span><em class="italic"><span class="koboSpan" id="kobo.473.1">Testing </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.474.1">Edge Cases</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.476.1">The testing package is used in all tests</span></p>
<p class="callout"><span class="koboSpan" id="kobo.477.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">testing</span></strong><span class="koboSpan" id="kobo.479.1"> package must be imported by all tests as it is the only way to interact with Go’s test runner. </span><span class="koboSpan" id="kobo.479.2">As previously discussed, test filenames must end with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">_test.go</span></strong><span class="koboSpan" id="kobo.481.1"> suffix, but tests will only be run if they use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">testing</span></strong><span class="koboSpan" id="kobo.483.1"> package. </span><span class="koboSpan" id="kobo.483.2">Tests must also satisfy a standard test signature, which is explained in the next section, </span><em class="italic"><span class="koboSpan" id="kobo.484.1">Working with the </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.485.1">testing package</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.487.1">Now, let’s have a look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">testing.T</span></strong><span class="koboSpan" id="kobo.489.1"> type in a little bit more detail since it will be the focus of our exploration in </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">this chapter.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.491.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.492.1">.5</span></em><span class="koboSpan" id="kobo.493.1"> presents a summary of some of the methods we </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">will discuss:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer023">
<span class="koboSpan" id="kobo.495.1"><img alt="Figure 2.5 – The logging, failing, and skipping methods of the testing.T type " src="image/Figure_2.05_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.496.1">Figure 2.5 – The logging, failing, and skipping methods of the testing.T type</span></p>
<p><span class="koboSpan" id="kobo.497.1">It exposes the following methods for logging, skipping, and failing tests that are important </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">to understand:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">t.Log(args)</span></strong><span class="koboSpan" id="kobo.500.1">: This prints the given arguments to the error log after the test has </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">finished executing.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">t.Logf(format, args)</span></strong><span class="koboSpan" id="kobo.503.1">: This has the same functionality as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">t.Log</span></strong><span class="koboSpan" id="kobo.505.1"> method, but allows </span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.506.1">the arguments to be formatted </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">before printing.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">t.Fail()</span></strong><span class="koboSpan" id="kobo.509.1">: This marks the current test as failed but continues execution until </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">the end.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">t.FailNow()</span></strong><span class="koboSpan" id="kobo.512.1">: This marks the current test as failed and immediately stops the execution of the current test. </span><span class="koboSpan" id="kobo.512.2">The next test will be run while continuing </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">the suite.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">t.Error(args)</span></strong><span class="koboSpan" id="kobo.515.1">: This is equivalent to calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">t.Log(args)</span></strong><span class="koboSpan" id="kobo.517.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">t.Fail()</span></strong><span class="koboSpan" id="kobo.519.1">. </span><span class="koboSpan" id="kobo.519.2">This method makes it convenient to log an error to the error log and mark the current test </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">as failed.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">t.Errorf(format, args)</span></strong><span class="koboSpan" id="kobo.522.1">: This is equivalent to calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">t.Logf(format, args)</span></strong><span class="koboSpan" id="kobo.524.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">t.Fail()</span></strong><span class="koboSpan" id="kobo.526.1">. </span><span class="koboSpan" id="kobo.526.2">This method makes it convenient to fail a test, then format and print an error line in </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">one call.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">t.Fatal(args)</span></strong><span class="koboSpan" id="kobo.529.1">: This is equivalent to calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">t.Log(args)</span></strong><span class="koboSpan" id="kobo.531.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">t.FailNow()</span></strong><span class="koboSpan" id="kobo.533.1">. </span><span class="koboSpan" id="kobo.533.2">This method makes it convenient to fail a test and print an error line in </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">one call.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">t.Fatalf(format, args)</span></strong><span class="koboSpan" id="kobo.536.1">: This is equivalent to calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">t.Logf(format, args)</span></strong><span class="koboSpan" id="kobo.538.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">t.FailNow()</span></strong><span class="koboSpan" id="kobo.540.1">. </span><span class="koboSpan" id="kobo.540.2">This method makes it convenient to fail a test, then format and print an error line in one </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">method call.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">t.SkipNow()</span></strong><span class="koboSpan" id="kobo.543.1">: This</span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.544.1"> marks the current test as skipped and immediately stops its execution. </span><span class="koboSpan" id="kobo.544.2">Note that if the test has already been marked as failed, then it remains failed, </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">not skipped.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">t.Skip(args)</span></strong><span class="koboSpan" id="kobo.547.1">: This is equivalent to calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">t.Log(args)</span></strong><span class="koboSpan" id="kobo.549.1">, followed by </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">t.SkipNow()</span></strong><span class="koboSpan" id="kobo.551.1">. </span><span class="koboSpan" id="kobo.551.2">This method makes it convenient to skip a test and print an error line in </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">one call.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">T.Skipf(format, args)</span></strong><span class="koboSpan" id="kobo.554.1">: This is equivalent to calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">t.Logf(format, args)</span></strong><span class="koboSpan" id="kobo.556.1">, followed by </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">t.SkipNow()</span></strong><span class="koboSpan" id="kobo.558.1">. </span><span class="koboSpan" id="kobo.558.2">This method makes it convenient to skip a test, then format and print an error line in </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">one call.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.560.1">In general, developers use the convenience methods presented previously when writing their tests, as opposed to invoking </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">t.Fail()</span></strong><span class="koboSpan" id="kobo.562.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">t.FailNow()</span></strong><span class="koboSpan" id="kobo.564.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">t.SkipNow()</span></strong><span class="koboSpan" id="kobo.566.1"> explicitly. </span><span class="koboSpan" id="kobo.566.2">Going forward, we will make use of them as we begin to write our </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">test code.</span></span></p>
<p><span class="koboSpan" id="kobo.568.1">Another thing you might be wondering about is whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">testing</span></strong><span class="koboSpan" id="kobo.570.1"> package provides any assertion functionality. </span><span class="koboSpan" id="kobo.570.2">It does not provide any inbuilt assertions, so we will need to compare values ourselves. </span><span class="koboSpan" id="kobo.570.3">We will explore third-party assertion libraries further in </span><a href="B18371_03.xhtml#_idTextAnchor061"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.571.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.572.1">, </span><em class="italic"><span class="koboSpan" id="kobo.573.1">Mocking and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.574.1">Assertion Frameworks</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">.</span></span></p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor046"/><span class="koboSpan" id="kobo.576.1">Test signatures</span></h2>
<p><span class="koboSpan" id="kobo.577.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">testing</span></strong><span class="koboSpan" id="kobo.579.1"> package </span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.580.1">is used for writing unit tests, which are placed in their own test files. </span><span class="koboSpan" id="kobo.580.2">Go tests are functions that satisfy the </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">following signature:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.582.1">func TestName(t *testing.T)</span></strong><span class="koboSpan" id="kobo.583.1"> {
</span><strong class="bold"><span class="koboSpan" id="kobo.584.1">  // implementation</span></strong><span class="koboSpan" id="kobo.585.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.586.1">This test signature highlights the following requirements for </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">Go tests:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.588.1">Tests are exported functions whose name begins </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">Test</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.592.1">Test names can have an additional suffix that specifies what the test is covering. </span><span class="koboSpan" id="kobo.592.2">The suffix must also begin with a capital letter, as we can see specified by </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">Name</span></strong><span class="koboSpan" id="kobo.594.1"> in the test signature, which doubles as the </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">test name.</span></span></li>
<li><span class="koboSpan" id="kobo.596.1">Tests must take in a single parameter of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">*testing.T</span></strong><span class="koboSpan" id="kobo.598.1"> type. </span><span class="koboSpan" id="kobo.598.2">As we’ve explained so far, this will be how the test interacts with the test runner. </span><span class="koboSpan" id="kobo.598.3">You can name the testing parameter however you want, but Go developers typically use </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">t</span></strong><span class="koboSpan" id="kobo.600.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">denote it.</span></span></li>
<li><span class="koboSpan" id="kobo.602.1">Tests must not have a </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">return type.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.604.1">Go tests are just functions</span></p>
<p class="callout"><span class="koboSpan" id="kobo.605.1">As we can see, tests are simply functions that satisfy a certain signature. </span><span class="koboSpan" id="kobo.605.2">The Go test tool scans the code base for these special functions in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">_test.go</span></strong><span class="koboSpan" id="kobo.607.1"> files and runs </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">them accordingly.</span></span></p>
<p><span class="koboSpan" id="kobo.609.1">Inside these test functions, we can define and implement our test code using the AAA pattern. </span><span class="koboSpan" id="kobo.609.2">You should keep the scope of your test small, preferring to write several tests rather than writing one large, potentially </span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">brittle test.</span></span></p>
<p><span class="koboSpan" id="kobo.611.1">Just like package names, test names are very important, so we need to give them some special consideration. </span><span class="koboSpan" id="kobo.611.2">Having effectively named tests can bring developers some </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">important advantages:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.613.1">Documentation and understanding</span></strong><span class="koboSpan" id="kobo.614.1">: A suite of </span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.615.1">effectively named tests will help newcomers understand how a particular piece of code is supposed to work. </span><span class="koboSpan" id="kobo.615.2">As they are easy to change, they also allow you to explore the behavior of the code under a variety </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">of conditions.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.617.1">Refactoring support</span></strong><span class="koboSpan" id="kobo.618.1">: The test name sets the intention of the test; then, its implementation simply executes it. </span><span class="koboSpan" id="kobo.618.2">Once the code has been refactored, the test implementation may change, but the intention of the test, conveyed by its name, remains. </span><span class="koboSpan" id="kobo.618.3">Well-named tests can support code refactoring, which might need to change the test implementation/execution. </span><span class="koboSpan" id="kobo.618.4">We will discuss code refactoring strategies further in </span><a href="B18371_07.xhtml#_idTextAnchor162"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.619.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.620.1">, </span><em class="italic"><span class="koboSpan" id="kobo.621.1">Refactoring </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.622.1">in Go</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.624.1">Consistency</span></strong><span class="koboSpan" id="kobo.625.1">: Setting a standard for how tests should be named and structured throughout your code base will make it easier for you to know what to expect, reducing cognitive load when </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">reading code.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.627.1">Other than the special signature we’ve just seen, Go does not enforce any other naming standards. </span><span class="koboSpan" id="kobo.627.2">The consensus in the Go community is that they should be easily understood and concise. </span><span class="koboSpan" id="kobo.627.3">The Go </span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.628.1">standard library ties tests with the name of the function that they test: the UUT. </span><span class="koboSpan" id="kobo.628.2">The test name simply follows the </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">TestUnitUnderTest</span></strong><span class="koboSpan" id="kobo.630.1"> structure. </span><span class="koboSpan" id="kobo.630.2">For example, a test for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">Add</span></strong><span class="koboSpan" id="kobo.632.1"> function will be </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">TestAdd</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.636.1">Another common approach is to name the tests using a </span><strong class="bold"><span class="koboSpan" id="kobo.637.1">Behavior-Driven Development</span></strong><span class="koboSpan" id="kobo.638.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.639.1">BDD</span></strong><span class="koboSpan" id="kobo.640.1">) style </span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.641.1">approach. </span><span class="koboSpan" id="kobo.641.2">We will explore BDD tests in detail in </span><a href="B18371_05.xhtml#_idTextAnchor124"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.642.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.643.1">, </span><em class="italic"><span class="koboSpan" id="kobo.644.1">Performing </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.645.1">Integration Testing</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.647.1">In this naming approach, the name of the test follows the structure of </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">TestUnitUnderTest_PreconditionsOrInputs_ExpectedOutput</span></strong><span class="koboSpan" id="kobo.649.1">. </span><span class="koboSpan" id="kobo.649.2">For example, a test for the function will be named </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">TestAdd_TwoNegativeNumbers_NegativeResults</span></strong><span class="koboSpan" id="kobo.651.1"> if it tests adding two negative </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">numbers together.</span></span></p>
<p><span class="koboSpan" id="kobo.653.1">While the BDD style naming pattern is a lot more precise, it goes against the principle of simplicity and conciseness that is so central to Go. </span><span class="koboSpan" id="kobo.653.2">We will use the simpler approach: naming the test after its UUT. </span><span class="koboSpan" id="kobo.653.3">We will see how we can achieve the extra precision of preconditions and expected output using subtests later in </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">this chapter.</span></span></p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.655.1">Running tests</span></h2>
<p><span class="koboSpan" id="kobo.656.1">One of the commands </span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.657.1">of the Go toolchain is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">go test</span></strong><span class="koboSpan" id="kobo.659.1"> command. </span><span class="koboSpan" id="kobo.659.2">We’ve previously mentioned that it is Go’s test runner and that we will use it to execute tests. </span><span class="koboSpan" id="kobo.659.3">We’ll look at how to use it in more detail in </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">this section.</span></span></p>
<p><span class="koboSpan" id="kobo.661.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">_test.go</span></strong><span class="koboSpan" id="kobo.663.1"> files, the test </span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.664.1">runner will treat three kinds of </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">functions especially:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.666.1">Test functions</span></strong><span class="koboSpan" id="kobo.667.1"> that have </span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.668.1">a name beginning with </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">Test</span></strong><span class="koboSpan" id="kobo.670.1">. </span><span class="koboSpan" id="kobo.670.2">We have covered test functions at length in </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">this section.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.672.1">Benchmark functions</span></strong><span class="koboSpan" id="kobo.673.1"> have a</span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.674.1"> name beginning with </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">Benchmark</span></strong><span class="koboSpan" id="kobo.676.1">. </span><span class="koboSpan" id="kobo.676.2">We will cover these in the </span><em class="italic"><span class="koboSpan" id="kobo.677.1">Difference between a test and a benchmark</span></em><span class="koboSpan" id="kobo.678.1"> section of </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">this chapter.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.680.1">Example functions</span></strong><span class="koboSpan" id="kobo.681.1"> that have</span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.682.1"> a name beginning with </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">Example</span></strong><span class="koboSpan" id="kobo.684.1">. </span><span class="koboSpan" id="kobo.684.2">These are outside the scope of our discussion in </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">this book.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.686.1">The test runner will look for files that end in </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">_test.go</span></strong><span class="koboSpan" id="kobo.688.1">, build them into their own packages, and then link them in the </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">test binary.</span></span></p>
<p><span class="koboSpan" id="kobo.690.1">The output of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">go test</span></strong><span class="koboSpan" id="kobo.692.1"> command will print out all the test failures of the executed tests to the standard output. </span><span class="koboSpan" id="kobo.692.2">You can add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">–v</span></strong><span class="koboSpan" id="kobo.694.1"> flag, which is short for verbose, to get it to print the name and execution time of all tests, including </span><span class="No-Break"><span class="koboSpan" id="kobo.695.1">passed tests.</span></span></p>
<p><span class="koboSpan" id="kobo.696.1">Tests are executed and output in lexicographic order. </span><span class="koboSpan" id="kobo.696.2">Here is the output from our </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">engine_test.go</span></strong><span class="koboSpan" id="kobo.698.1">, which contains tests for the operations of the calculator, implemented </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">engine.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.702.1">
$ go test ./...
</span><strong class="bold"><span class="koboSpan" id="kobo.703.1">=== RUN   TestAdd</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.704.1">    engine_test.go:7: Add(2,3) incorrect, got: 2, want: 5.</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.705.1">--- FAIL: TestAdd (0.00s)</span></strong><span class="koboSpan" id="kobo.706.1">
FAIL
exit status 1
FAIL    github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter02/calculator   0.278s</span></pre>
<p><span class="koboSpan" id="kobo.707.1">Test failures are marked in the output with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">FAIL</span></strong><span class="koboSpan" id="kobo.709.1"> keyword and any error messages are printed to the standard output. </span><span class="koboSpan" id="kobo.709.2">In our example, we have a failing test: </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">TestAdd</span></strong><span class="koboSpan" id="kobo.711.1">. </span><span class="koboSpan" id="kobo.711.2">As we saw in the previous section, we can print informative error messages and fail tests using a variety of methods from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">testing.T</span></strong><span class="koboSpan" id="kobo.713.1"> type, which we have access to in all tests from the parameter of the </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">test signature.</span></span></p>
<p><span class="koboSpan" id="kobo.715.1">At the end of the test output, we can see the outcome of the entire test run, as well as the time it took to run. </span><span class="koboSpan" id="kobo.715.2">We can also see the running time for </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">each test.</span></span></p>
<p><span class="koboSpan" id="kobo.717.1">The test runner</span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.718.1"> supports two </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">running modes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.720.1">When the command has no package specifications, it will build and run all tests in the current directory. </span><span class="koboSpan" id="kobo.720.2">This is </span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.721.1">known as </span><strong class="bold"><span class="koboSpan" id="kobo.722.1">local directory mode</span></strong><span class="koboSpan" id="kobo.723.1">. </span><span class="koboSpan" id="kobo.723.2">This is how we ran the preceding command using </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">go </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">test –v</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.727.1">When the command has package specifications, it will build and run all tests matching the specific package arguments. </span><span class="koboSpan" id="kobo.727.2">This is known as </span><strong class="bold"><span class="koboSpan" id="kobo.728.1">package list mode</span></strong><span class="koboSpan" id="kobo.729.1">. </span><span class="koboSpan" id="kobo.729.2">Developers</span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.730.1"> usually run their tests in this mode for large projects as it can be cumbersome to change between directories and run the tests in each of them using local </span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">directory mode.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.732.1">We can easily specify what tests to run by providing </span><span class="No-Break"><span class="koboSpan" id="kobo.733.1">these properties:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.734.1">A specific package name</span></strong><span class="koboSpan" id="kobo.735.1">: For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">go test engine_test</span></strong><span class="koboSpan" id="kobo.737.1"> will run the tests from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">engine_test</span></strong><span class="koboSpan" id="kobo.739.1"> package from anywhere in the </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">project directory.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.741.1">The expression as the package identifier</span></strong><span class="koboSpan" id="kobo.742.1">: For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">go test ./...</span></strong><span class="koboSpan" id="kobo.744.1"> will run all the tests in the project, regardless of where it’s being </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">run from.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.746.1">A subdirectory path</span></strong><span class="koboSpan" id="kobo.747.1">: For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">go test ./chapter02</span></strong><span class="koboSpan" id="kobo.749.1"> will run all the tests in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">chapter02</span></strong><span class="koboSpan" id="kobo.751.1"> subdirectory of the current path, but will not traverse to further </span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">nested directories.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.753.1">A regular expression, together with the </span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">–run</span></strong><strong class="bold"><span class="koboSpan" id="kobo.755.1"> flag</span></strong><span class="koboSpan" id="kobo.756.1">: For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">go test –run "^engine"</span></strong><span class="koboSpan" id="kobo.758.1"> will run all packages that begin with the word </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">engine</span></strong><span class="koboSpan" id="kobo.760.1">. </span><span class="koboSpan" id="kobo.760.2">A subdirectory path can also be provided alongside the </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">test name.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.762.1">A test name, together with the </span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">–run</span></strong><strong class="bold"><span class="koboSpan" id="kobo.764.1"> flag</span></strong><span class="koboSpan" id="kobo.765.1">: For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">go test –run TestAdd</span></strong><span class="koboSpan" id="kobo.767.1"> will only the test specified. </span><span class="koboSpan" id="kobo.767.2">A subdirectory path can also be provided alongside the </span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">test name.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.769.1">The Go test runner can cache successful test results to avoid wasting resources by rerunning tests on code that has not changed. </span><span class="koboSpan" id="kobo.769.2">Being able to cache successful test results is disabled by default when running in local directory mode, but enabled in package </span><span class="No-Break"><span class="koboSpan" id="kobo.770.1">list mode.</span></span></p>
<p><span class="koboSpan" id="kobo.771.1">As you can see, the </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.772.1">output of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">go test –v ./...</span></strong><span class="koboSpan" id="kobo.774.1"> command, which triggers package list mode, will mark the cached results with </span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">(cached)</span></strong><span class="koboSpan" id="kobo.776.1"> on their corresponding </span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">output line:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.778.1">
$ go test -v ./... </span><span class="koboSpan" id="kobo.778.2">=== RUN   TestAdd
    engine_test.go:7: Add(2,3) incorrect, got: 2, want: 5.
</span><span class="koboSpan" id="kobo.778.3">--- FAIL: TestAdd (0.00s)
FAIL
FAIL    github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter02/calculator   0.112s
=== RUN   TestParser
--- PASS: TestParser (0.00s)
PASS
ok      github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter02/input        (cached)
FAIL</span></pre>
<p><span class="koboSpan" id="kobo.779.1">Note that only </span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.780.1">successful test runs can be cached. </span><span class="koboSpan" id="kobo.780.2">Test failures will be run every time until they pass, at which point they can </span><span class="No-Break"><span class="koboSpan" id="kobo.781.1">be cached.</span></span></p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.782.1">Writing tests</span></h2>
<p><span class="koboSpan" id="kobo.783.1">So far, we have </span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.784.1">examined the structure of packages, where test files fit into their structure, as well as become acquainted with Go’s testing package and test signatures. </span><span class="koboSpan" id="kobo.784.2">Now, let’s take everything we have learned and begin </span><span class="No-Break"><span class="koboSpan" id="kobo.785.1">applying it.</span></span></p>
<p><span class="koboSpan" id="kobo.786.1">With the knowledge we have of how to test code works in Go, we can expand on the </span><strong class="bold"><span class="koboSpan" id="kobo.787.1">red, green, refactor</span></strong><span class="koboSpan" id="kobo.788.1"> approach</span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.789.1"> with more specific steps. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.790.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.791.1">.6</span></em><span class="koboSpan" id="kobo.792.1"> shows the expanded flow of TDD in Go for </span><span class="No-Break"><span class="koboSpan" id="kobo.793.1">new functionality:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<span class="koboSpan" id="kobo.794.1"><img alt="Figure 2.6 – Expanded TDD flow in Go " src="image/Figure_2.06_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.795.1">Figure 2.6 – Expanded TDD flow in Go</span></p>
<p><span class="koboSpan" id="kobo.796.1">We can describe the</span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.797.1"> test writing process with the </span><span class="No-Break"><span class="koboSpan" id="kobo.798.1">following steps:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.799.1">Create the test file and test package</span></strong><span class="koboSpan" id="kobo.800.1">: You create a new directory to place your files and packages in. </span><span class="koboSpan" id="kobo.800.2">Then, you place the </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">_test.go</span></strong><span class="koboSpan" id="kobo.802.1"> file corresponding to the test that you will be implementing in this new directory. </span><span class="koboSpan" id="kobo.802.2">This will ensure that you have a place to begin writing test code alongside implementation code. </span><span class="koboSpan" id="kobo.802.3">As previously mentioned, while Go does not enforce the usage of the external test package, you should use one </span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">whenever possible.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.804.1">Create the source code file and package</span></strong><span class="koboSpan" id="kobo.805.1">: In the same directory, create the source code file and declare the package name at the top to ensure that empty </span><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">.go</span></strong><span class="koboSpan" id="kobo.807.1"> files are immediately compiled. </span><span class="koboSpan" id="kobo.807.2">At this point, you will begin reflecting on the structure of your code, as we did with the simple terminal calculator at the beginning of </span><span class="No-Break"><span class="koboSpan" id="kobo.808.1">this chapter.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.809.1">Write the test signature for the new functionality</span></strong><span class="koboSpan" id="kobo.810.1">: While in the test file, you can create the new test, named after the UUT you will be testing. </span><span class="koboSpan" id="kobo.810.2">The test signature will also require you to import the testing package, getting you ready to write your </span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">test code.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.812.1">Write the definitions of your UUT</span></strong><span class="koboSpan" id="kobo.813.1">: Inside your previously empty source file, write the definitions for the custom types, methods, and functions that you intend to test. </span><span class="koboSpan" id="kobo.813.2">This will allow you to settle on the signatures or API of your UUT, then structure your test accordingly. </span><span class="koboSpan" id="kobo.813.3">As we did in the simple terminal calculator, return empty or zero values according to the signature of your methods to ensure your </span><span class="No-Break"><span class="koboSpan" id="kobo.814.1">code compiles.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.815.1">Set up your test scenario</span></strong><span class="koboSpan" id="kobo.816.1">: Starting with the simplest test cases first, write your test using the AAA approach, invoking the previously defined signatures of your UUT. </span><span class="koboSpan" id="kobo.816.2">This is the reason we created the signatures and returned dummy values for the code </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">to compile.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.818.1">Run your test to see it fail</span></strong><span class="koboSpan" id="kobo.819.1">: At this point, your code should be fully compiling so that you can </span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.820.1">run your tests to see the new code fail. </span><span class="koboSpan" id="kobo.820.2">To speed up the feedback further, you can run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.821.1">go test</span></strong><span class="koboSpan" id="kobo.822.1"> command in the directory of your </span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">new package.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.824.1">Implement the functionality required by your test scenario</span></strong><span class="koboSpan" id="kobo.825.1">: Going back to your UUT, write just enough code to satisfy your newest test scenario. </span><span class="koboSpan" id="kobo.825.2">This will require changing some of your </span><span class="No-Break"><span class="koboSpan" id="kobo.826.1">dummy code.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.827.1">Run your test to see it pass</span></strong><span class="koboSpan" id="kobo.828.1">: At this point, your code should be fully compiling so that you can execute your tests using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">go test</span></strong><span class="koboSpan" id="kobo.830.1"> command. </span><span class="koboSpan" id="kobo.830.2">Your new test should </span><span class="No-Break"><span class="koboSpan" id="kobo.831.1">now pass.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.832.1">Refactor your newest test and code</span></strong><span class="koboSpan" id="kobo.833.1">: Look for any improvements you can make to your source and test code. </span><span class="koboSpan" id="kobo.833.2">Improvements should be frequent and small, so make sure to take the time to review </span><span class="No-Break"><span class="koboSpan" id="kobo.834.1">your code.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.835.1">Run your test to see it pass</span></strong><span class="koboSpan" id="kobo.836.1">: Your new test should continue to pass after </span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">this refactoring.</span></span></li>
<li><span class="koboSpan" id="kobo.838.1">Repeat all of these steps as many times as required until all the functionality is implemented. </span><span class="koboSpan" id="kobo.838.2">You will define your UUT signatures and tests as required, starting from the simplest functionality and </span><span class="No-Break"><span class="koboSpan" id="kobo.839.1">working forward.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.840.1">As expected, the</span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.841.1"> TDD process requires frequent changes between the source and test code. </span><span class="koboSpan" id="kobo.841.2">Test runs should always fail first, then pass as we implement and refactor the </span><span class="No-Break"><span class="koboSpan" id="kobo.842.1">source code.</span></span></p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.843.1">Use case – implementing the calculator engine</span></h2>
<p><span class="koboSpan" id="kobo.844.1">Let’s use our </span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.845.1">established working practice to write and implement the functionality of the calculator that we will define in </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">engine.go</span></strong><span class="koboSpan" id="kobo.847.1">. </span><span class="koboSpan" id="kobo.847.2">This will also give us some hands-on experience with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">testing</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.849.1"> package.</span></span></p>
<h3><span class="koboSpan" id="kobo.850.1">Step 1 – creating the test file and test package</span></h3>
<p><span class="koboSpan" id="kobo.851.1">As we saw</span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.852.1"> in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.853.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.854.1">.2</span></em><span class="koboSpan" id="kobo.855.1">, we will create a directory named </span><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">calculator</span></strong><span class="koboSpan" id="kobo.857.1"> where we will place the corresponding calculator </span><span class="No-Break"><span class="koboSpan" id="kobo.858.1">engine files.</span></span></p>
<p><span class="koboSpan" id="kobo.859.1">We will create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">engine_test.go</span></strong><span class="koboSpan" id="kobo.861.1"> test file and declare the external </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">calculator_test</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.863.1"> package:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.864.1">package calculator_test</span></strong></pre>
<p><span class="koboSpan" id="kobo.865.1">At this point, the test file only contains a single line, and there are no </span><span class="No-Break"><span class="koboSpan" id="kobo.866.1">compile errors.</span></span></p>
<h3><span class="koboSpan" id="kobo.867.1">Step 2 – creating the source code file and package</span></h3>
<p><span class="koboSpan" id="kobo.868.1">In the same</span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.869.1"> directory, we must create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">engine.go</span></strong><span class="koboSpan" id="kobo.871.1"> file and declare the calculator package, which matches the already declared external </span><span class="No-Break"><span class="koboSpan" id="kobo.872.1">test package:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.873.1">package calculator</span></strong></pre>
<p><span class="koboSpan" id="kobo.874.1">At this point, the source code file also contains a single line and there are no </span><span class="No-Break"><span class="koboSpan" id="kobo.875.1">compile errors.</span></span></p>
<h3><span class="koboSpan" id="kobo.876.1">Step 3 – writing the test signature for the new functionality</span></h3>
<p><span class="koboSpan" id="kobo.877.1">We will begin</span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.878.1"> by testing and implementing the calculator addition functionality, as that is the simplest function. </span><span class="koboSpan" id="kobo.878.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">engine_test.go</span></strong><span class="koboSpan" id="kobo.880.1"> file, add a new test corresponding to the Go test signature and import the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">testing</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.882.1"> package:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.883.1">
package calculator_test
import "testing"
</span><strong class="bold"><span class="koboSpan" id="kobo.884.1">func TestAdd(t *testing.T)</span></strong><span class="koboSpan" id="kobo.885.1"> {
}</span></pre>
<p><span class="koboSpan" id="kobo.886.1">As its name and package indicate, we will be testing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">Add</span></strong><span class="koboSpan" id="kobo.888.1"> function or method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">calculator</span></strong><span class="koboSpan" id="kobo.890.1"> package. </span><span class="koboSpan" id="kobo.890.2">With just these few lines of code, we already have a decent indication of what this test will cover. </span><span class="koboSpan" id="kobo.890.3">This is a very </span><span class="No-Break"><span class="koboSpan" id="kobo.891.1">powerful mechanism.</span></span></p>
<h3><span class="koboSpan" id="kobo.892.1">Step 4 – writing the definitions of your UUT</span></h3>
<p><span class="koboSpan" id="kobo.893.1">Here, we will </span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.894.1">add stubbed definitions of the UUT to the source file so that we can invoke them in our newly written code. </span><span class="koboSpan" id="kobo.894.2">While this is a small departure from writing no code that does not have corresponding test code, it will make it easier for us to reference the code in test code from any code editor. </span><span class="koboSpan" id="kobo.894.3">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">engine.go</span></strong><span class="koboSpan" id="kobo.896.1"> file, we must add stubs for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">Engine</span></strong><span class="koboSpan" id="kobo.898.1"> custom type and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">Add</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.900.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.901.1">
package calculator
type Engine struct {}
func(e *Engine) Add(x, y float64) float64{
</span><strong class="bold"><span class="koboSpan" id="kobo.902.1">  return 0</span></strong><span class="koboSpan" id="kobo.903.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.904.1">We return a dummy value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">0</span></strong><span class="koboSpan" id="kobo.906.1"> to ensure that the code continues </span><span class="No-Break"><span class="koboSpan" id="kobo.907.1">to compile.</span></span></p>
<h3><span class="koboSpan" id="kobo.908.1">Step 5 – setting up your test scenario</span></h3>
<p><span class="koboSpan" id="kobo.909.1">Going back to</span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.910.1"> the test code, we will add a simple test scenario to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">TestAdd</span></strong><span class="koboSpan" id="kobo.912.1"> function, which is currently empty. </span><span class="koboSpan" id="kobo.912.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.913.1">engine_test.go</span></strong><span class="koboSpan" id="kobo.914.1"> file, we will add testing code that was written using the AAA pattern, as indicated by the comments corresponding with </span><span class="No-Break"><span class="koboSpan" id="kobo.915.1">each step:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.916.1">
package calculator_test
import (
  "testing"
</span><strong class="bold"><span class="koboSpan" id="kobo.917.1">  "github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter02/calculator"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.918.1">)</span></strong><span class="koboSpan" id="kobo.919.1">
func TestAdd(t *testing.T) {
  // Arrange
  e := calculator.Engine{}
  // Act
  got := e.Add(2.5,3.5)
  //Assert
  if got != 6.0 {
    t.Errorf("Add(%.2f,%.2f) incorrect, got: %.2f, want:
      %.2f", 2.5, 3.5, got, 6.0)
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.920.1">In the Arrange step, </span><strong class="source-inline"><span class="koboSpan" id="kobo.921.1">TestAdd</span></strong><span class="koboSpan" id="kobo.922.1"> creates an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.923.1">calculator.Engine</span></strong><span class="koboSpan" id="kobo.924.1">, which requires the calculator package to be imported inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.925.1">test file.</span></span></p>
<p><span class="koboSpan" id="kobo.926.1">In the Act step, we invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.927.1">Add</span></strong><span class="koboSpan" id="kobo.928.1"> method on the created </span><strong class="source-inline"><span class="koboSpan" id="kobo.929.1">Engine</span></strong><span class="koboSpan" id="kobo.930.1"> instance and pass it the two inputs that we will be using in </span><span class="No-Break"><span class="koboSpan" id="kobo.931.1">this step.</span></span></p>
<p><span class="koboSpan" id="kobo.932.1">Finally, in the Assert step, we compare the actual and expected values in an </span><strong class="source-inline"><span class="koboSpan" id="kobo.933.1">if</span></strong><span class="koboSpan" id="kobo.934.1"> statement and </span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.935.1">call for the test failure using </span><strong class="source-inline"><span class="koboSpan" id="kobo.936.1">t.Errorf</span></strong><span class="koboSpan" id="kobo.937.1"> if they do </span><span class="No-Break"><span class="koboSpan" id="kobo.938.1">not match.</span></span></p>
<h3><span class="koboSpan" id="kobo.939.1">Step 6 – running your test to see if it fails</span></h3>
<p><span class="koboSpan" id="kobo.940.1">Starting with a </span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.941.1">failing test is very important to the TDD philosophy since it ensures that our test is actually being run and does not pass falsely. </span><span class="koboSpan" id="kobo.941.2">We can run </span><span class="No-Break"><span class="koboSpan" id="kobo.942.1">our test:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.943.1">
$ go test -run TestAdd ./chapter02/calculator -v
--- FAIL: TestAdd (0.00s)
    engine_test.go:20: Add(2.50,3.50) incorrect, got: 0.00, want: 6.00
FAIL
exit status 1
FAIL    github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter02/calculator   0.198s</span></pre>
<p><span class="koboSpan" id="kobo.944.1">The test fails and our informative error message is printed out to the terminal. </span><span class="koboSpan" id="kobo.944.2">The test is expected to fail since our method is currently only returning the dummy value. </span><span class="koboSpan" id="kobo.944.3">With that, we have completed</span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.945.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.946.1">red</span></strong><span class="koboSpan" id="kobo.947.1"> phase of the red, green, </span><span class="No-Break"><span class="koboSpan" id="kobo.948.1">refactor approach.</span></span></p>
<h3><span class="koboSpan" id="kobo.949.1">Step 7 – implementing the functionality required by your test scenario</span></h3>
<p><span class="koboSpan" id="kobo.950.1">With the failing </span><strong class="source-inline"><span class="koboSpan" id="kobo.951.1">TestAdd</span></strong><span class="koboSpan" id="kobo.952.1"> in place, it’s time to implement the </span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.953.1">functionality required to make it pass. </span><span class="koboSpan" id="kobo.953.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">engine.go</span></strong><span class="koboSpan" id="kobo.955.1"> file, we must change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">Add</span></strong><span class="koboSpan" id="kobo.957.1"> method to remove the dummy </span><span class="No-Break"><span class="koboSpan" id="kobo.958.1">value return:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.959.1">
func(e *Engine) Add(x, y float64) float64{
</span><strong class="bold"><span class="koboSpan" id="kobo.960.1">  return x + y</span></strong><span class="koboSpan" id="kobo.961.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.962.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.963.1">Add</span></strong><span class="koboSpan" id="kobo.964.1"> method will now use the input parameters and return their </span><span class="No-Break"><span class="koboSpan" id="kobo.965.1">addition result.</span></span></p>
<h3><span class="koboSpan" id="kobo.966.1">Step 8 – running your test to see if it passes</span></h3>
<p><span class="koboSpan" id="kobo.967.1">Exactly like </span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.968.1">in </span><em class="italic"><span class="koboSpan" id="kobo.969.1">Step 6 – running your test to see if it fails</span></em><span class="koboSpan" id="kobo.970.1">, we will run </span><span class="No-Break"><span class="koboSpan" id="kobo.971.1">the test</span></span><span class="No-Break"><span class="koboSpan" id="kobo.972.1">:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.973.1">
$ go test -run TestAdd ./chapter02/calculator -v 
=== RUN   TestAdd
--- PASS: TestAdd (0.00s)
ok      github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter02/calculator   0.109s</span></pre>
<p><span class="koboSpan" id="kobo.974.1">The test is now passing and we have verified that our code satisfies the test requirements. </span><span class="koboSpan" id="kobo.974.2">With that, we have </span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.975.1">completed the </span><strong class="bold"><span class="koboSpan" id="kobo.976.1">green</span></strong><span class="koboSpan" id="kobo.977.1"> phase of the red, green, </span><span class="No-Break"><span class="koboSpan" id="kobo.978.1">refactor approach.</span></span></p>
<h3><span class="koboSpan" id="kobo.979.1">Step 9 – refactoring your newest test and code</span></h3>
<p><span class="koboSpan" id="kobo.980.1">This step is not </span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.981.1">guaranteed to take place. </span><span class="koboSpan" id="kobo.981.2">We can improve our test code by extracting variables that allow us to clean up the test code, removing the need for us to repeat </span><span class="No-Break"><span class="koboSpan" id="kobo.982.1">hardcoded values:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.983.1">
func TestAdd(t *testing.T) {
  // Arrange
  e := calculator.Engine{}
</span><strong class="bold"><span class="koboSpan" id="kobo.984.1">  x, y := 2.5,3.5</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.985.1">  want := 6.0</span></strong><span class="koboSpan" id="kobo.986.1">
  // Act
  got := e.Add(x,y)
  //Assert
  if got != want {
    t.Errorf("Add(%.2f,%.2f) incorrect, got: %.2f, want: %.2f",             x, y, got, want)
 }
}</span></pre>
<p><span class="koboSpan" id="kobo.987.1">In the Arrange section, we now declare three variables for our inputs and expected output. </span><span class="koboSpan" id="kobo.987.2">We make use of these variables throughout the test, passing them to the UUT as well as to the</span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.988.1"> formatted </span><span class="No-Break"><span class="koboSpan" id="kobo.989.1">error message.</span></span></p>
<h3><span class="koboSpan" id="kobo.990.1">Step 10 – re-running your test to see if it passes</span></h3>
<p><span class="koboSpan" id="kobo.991.1">Exactly</span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.992.1"> like in </span><em class="italic"><span class="koboSpan" id="kobo.993.1">Step 8 – running your test to see if it passes</span></em><span class="koboSpan" id="kobo.994.1">, we must run </span><span class="No-Break"><span class="koboSpan" id="kobo.995.1">the test</span></span><span class="No-Break"><span class="koboSpan" id="kobo.996.1">:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.997.1">
$ go test -run TestAdd ./chapter02/calculator -v 
=== RUN   TestAdd
--- PASS: TestAdd (0.00s)
ok      github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter02/calculator   0.196s</span></pre>
<p><span class="koboSpan" id="kobo.998.1">The test is now passing and we have verified that our refactoring has not broken any implemented functionality. </span><span class="koboSpan" id="kobo.998.2">With that, we have </span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.999.1">completed the </span><strong class="bold"><span class="koboSpan" id="kobo.1000.1">refactor</span></strong><span class="koboSpan" id="kobo.1001.1"> phase of the red, green, </span><span class="No-Break"><span class="koboSpan" id="kobo.1002.1">refactor approach.</span></span></p>
<p><span class="koboSpan" id="kobo.1003.1">These steps can now be repeated for all the other operations of the simple terminal calculator. </span><span class="koboSpan" id="kobo.1003.2">You can go ahead and implement them, which will allow you to practice using TDD in Go. </span><span class="koboSpan" id="kobo.1003.3">Next, we’ll explore how to streamline our test writing processing using test setup </span><span class="No-Break"><span class="koboSpan" id="kobo.1004.1">and teardown.</span></span></p>
<h1 id="_idParaDest-50"><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.1005.1">Test setup and teardown</span></h1>
<p><span class="koboSpan" id="kobo.1006.1">We’ve written our first example of a test and source code by leveraging an external test package and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">testing.T</span></strong><span class="koboSpan" id="kobo.1008.1"> type. </span><span class="koboSpan" id="kobo.1008.2">This has worked very well for our simple example, but, as we begin to ramp up and write more tests, it can be cumbersome to continue repeating the same test setup and cleanup. </span><span class="koboSpan" id="kobo.1008.3">In this section, we will explore what functionality the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">testing</span></strong><span class="koboSpan" id="kobo.1010.1"> package offers to streamline this process </span><span class="No-Break"><span class="koboSpan" id="kobo.1011.1">for us.</span></span></p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.1012.1">The TestMain approach</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.1013.1">Go 1.4</span></strong><span class="koboSpan" id="kobo.1014.1"> introduced </span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.1015.1">a new special</span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.1016.1"> test</span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.1017.1"> called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1018.1">TestMain</span></strong><span class="koboSpan" id="kobo.1019.1">. </span><span class="koboSpan" id="kobo.1019.2">This is a feature that is often underutilized, but it gives us great flexibility when it comes to setup and teardown code. </span><span class="koboSpan" id="kobo.1019.3">The signature of this test is </span><span class="No-Break"><span class="koboSpan" id="kobo.1020.1">as follows:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1021.1">func TestMain(m *testing.M)</span></strong><span class="koboSpan" id="kobo.1022.1"> {
  // implementation
}</span></pre>
<p><span class="koboSpan" id="kobo.1023.1">Unlike other tests, the name of this test is fixed and it takes in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">*testing.M</span></strong><span class="koboSpan" id="kobo.1025.1"> type as its only parameter, as opposed to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1026.1">*testing.T</span></strong><span class="koboSpan" id="kobo.1027.1"> as other tests do. </span><span class="koboSpan" id="kobo.1027.2">Once you override it, the code in this method will give you more control over how your tests run. </span><span class="koboSpan" id="kobo.1027.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1028.1">TestMain</span></strong><span class="koboSpan" id="kobo.1029.1"> method will be run before any of the other tests in </span><span class="No-Break"><span class="koboSpan" id="kobo.1030.1">this package.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1031.1">One TestMain function per package</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1032.1">As names need to be unique inside a package, you will only be able to define one </span><strong class="source-inline"><span class="koboSpan" id="kobo.1033.1">TestMain</span></strong><span class="koboSpan" id="kobo.1034.1"> function per package. </span><span class="koboSpan" id="kobo.1034.2">You should be mindful that this method will control how all the tests inside the given package run, not just those in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1035.1">given file.</span></span></p>
<p><span class="koboSpan" id="kobo.1036.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1037.1">testing.M</span></strong><span class="koboSpan" id="kobo.1038.1"> type is much smaller than the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1039.1">testing.T</span></strong><span class="koboSpan" id="kobo.1040.1"> type and exposes a method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1041.1">Run()</span></strong><span class="koboSpan" id="kobo.1042.1">, which allows us to run the tests in the given package and returns an </span><span class="No-Break"><span class="koboSpan" id="kobo.1043.1">exit code.</span></span></p>
<p><span class="koboSpan" id="kobo.1044.1">The usage of this function </span><span class="No-Break"><span class="koboSpan" id="kobo.1045.1">is simple:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1046.1">
func TestMain(m *testing.M) {
  // setup statements
  setup()
  // run the tests
  e := m.Run()
  // cleanup statements
  teardown()
  // report the exit code
</span><strong class="bold"><span class="koboSpan" id="kobo.1047.1">  os.Exit(e)</span></strong><span class="koboSpan" id="kobo.1048.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.1049.1">The preceding code </span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.1050.1">sample</span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.1051.1"> outlines a </span><span class="No-Break"><span class="koboSpan" id="kobo.1052.1">simple recipe:</span></span></p>
<ol>
<li value="1"><strong class="bold"><span class="koboSpan" id="kobo.1053.1">Declare the special </span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.1054.1">TestMain</span></strong><strong class="bold"><span class="koboSpan" id="kobo.1055.1"> signature</span></strong><span class="koboSpan" id="kobo.1056.1">: Write the correct name and signature of the test in your test file. </span><span class="koboSpan" id="kobo.1056.2">In general, you should place this definition as high up at the beginning of the file </span><span class="No-Break"><span class="koboSpan" id="kobo.1057.1">as possible.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1058.1">Write your setup code</span></strong><span class="koboSpan" id="kobo.1059.1">: Inside the body of the main test, you should write your setup code. </span><span class="koboSpan" id="kobo.1059.2">I recommend writing a separate </span><strong class="source-inline"><span class="koboSpan" id="kobo.1060.1">setup()</span></strong><span class="koboSpan" id="kobo.1061.1"> function and calling that instead of writing the code directly into your test function. </span><span class="koboSpan" id="kobo.1061.2">This will help with the readability of your test file. </span><span class="koboSpan" id="kobo.1061.3">All of these statements will run before your tests </span><span class="No-Break"><span class="koboSpan" id="kobo.1062.1">are executed.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1063.1">Invoke the </span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.1064.1">Run()</span></strong><strong class="bold"><span class="koboSpan" id="kobo.1065.1"> function</span></strong><span class="koboSpan" id="kobo.1066.1">: After you have written your setup code, you will have to invoke </span><strong class="source-inline"><span class="koboSpan" id="kobo.1067.1">m.</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1068.1">Run()</span></strong><span class="koboSpan" id="kobo.1069.1"> and save the exit value returned from this function inside a variable, named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1070.1">e</span></strong><span class="koboSpan" id="kobo.1071.1"> in our code sample. </span><span class="koboSpan" id="kobo.1071.2">It is at this point that the tests will run and the exit value will report whether your tests </span><span class="No-Break"><span class="koboSpan" id="kobo.1072.1">have failed.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1073.1">Write your teardown/cleanup code</span></strong><span class="koboSpan" id="kobo.1074.1">: In the same way as the setup, you can write your teardown or cleanup code after the invocation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1075.1">Run()</span></strong><span class="koboSpan" id="kobo.1076.1"> method. </span><span class="koboSpan" id="kobo.1076.2">I also recommend creating a separate function named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1077.1">teardown</span></strong><span class="koboSpan" id="kobo.1078.1">, as opposed to writing the code directly into your </span><strong class="source-inline"><span class="koboSpan" id="kobo.1079.1">TestMain</span></strong><span class="koboSpan" id="kobo.1080.1"> code block. </span><span class="koboSpan" id="kobo.1080.2">All of these statements will run after your tests </span><span class="No-Break"><span class="koboSpan" id="kobo.1081.1">are executed.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1082.1">Report the exit value</span></strong><span class="koboSpan" id="kobo.1083.1">: This step is very important as it allows us to indicate test failures to the test runner. </span><span class="koboSpan" id="kobo.1083.2">You should pass the exit code returned from the test run and pass it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1084.1">os.Exit</span></strong><span class="koboSpan" id="kobo.1085.1"> function. </span><span class="koboSpan" id="kobo.1085.2">If you forget to add this part of the main function, you might get false positives reported to your </span><span class="No-Break"><span class="koboSpan" id="kobo.1086.1">test runner.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1087.1">We implement the same recipe in our calculator example, defining the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1088.1">TestMain</span></strong><span class="koboSpan" id="kobo.1089.1"> function</span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.1090.1"> alongside </span><strong class="source-inline"><span class="koboSpan" id="kobo.1091.1">TestAdd</span></strong><span class="koboSpan" id="kobo.1092.1"> in</span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.1093.1"> the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1094.1">engine_test.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1095.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1096.1">
func TestMain(m *testing.M) {
  // setup statements
  setup()
  // run the tests
  e := m.Run()
  // cleanup statements
  teardown()
  // report the exit code
  os.Exit(e)
}
func setup() {
  log.Println("Setting up.")
}
func teardown() {
  log.Println("Tearing down.")
}</span></pre>
<p><span class="koboSpan" id="kobo.1097.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1098.1">setup()</span></strong><span class="koboSpan" id="kobo.1099.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1100.1">teardown()</span></strong><span class="koboSpan" id="kobo.1101.1"> functions simply print two lines to the Terminal. </span><span class="koboSpan" id="kobo.1101.2">Running the test shows us the </span><span class="No-Break"><span class="koboSpan" id="kobo.1102.1">following output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1103.1">
$ go test -run TestAdd ./chapter02/calculator -v 
2022/08/14 11:02:51 Setting up.
</span><span class="koboSpan" id="kobo.1103.2">=== RUN   TestAdd
--- PASS: TestAdd (0.00s)
PASS
2022/08/14 11:02:51 Tearing down.
</span><span class="koboSpan" id="kobo.1103.3">ok      github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter02/calculator   0.345s</span></pre>
<p><span class="koboSpan" id="kobo.1104.1">As we can see</span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.1105.1"> from the </span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.1106.1">test output, the setup and teardown log lines are printed around the test run output, before </span><span class="No-Break"><span class="koboSpan" id="kobo.1107.1">and after.</span></span></p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.1108.1">init functions</span></h2>
<p><span class="koboSpan" id="kobo.1109.1">The second option </span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.1110.1">you have </span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.1111.1">available to ensure that the test setup runs correctly is to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1112.1">init</span></strong><span class="koboSpan" id="kobo.1113.1"> functions. </span><span class="koboSpan" id="kobo.1113.2">It is often the case with unit tests that no teardown logic is required, only setup logic. </span><span class="koboSpan" id="kobo.1113.3">In these cases, where you simply want to ensure that some logic is run before the tests, you might want to opt for a less cumbersome approach </span><span class="No-Break"><span class="koboSpan" id="kobo.1114.1">than </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1115.1">TestMain</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1116.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1117.1">Unlike the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1118.1">TestMain</span></strong><span class="koboSpan" id="kobo.1119.1"> approach, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1120.1">init</span></strong><span class="koboSpan" id="kobo.1121.1"> functions are not specifically restricted to test code. </span><span class="koboSpan" id="kobo.1121.2">The signature of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1122.1">init</span></strong><span class="koboSpan" id="kobo.1123.1"> function looks </span><span class="No-Break"><span class="koboSpan" id="kobo.1124.1">like this:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1125.1">func init() {</span></strong><span class="koboSpan" id="kobo.1126.1">
  // implementation
}</span></pre>
<p><span class="koboSpan" id="kobo.1127.1">The name of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1128.1">init</span></strong><span class="koboSpan" id="kobo.1129.1"> function is fixed and it takes no parameters. </span><span class="koboSpan" id="kobo.1129.2">This function will be called before any main function, regardless of whether that main function is in the source code or the special test runner </span><span class="No-Break"><span class="koboSpan" id="kobo.1130.1">main function.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1131.1">Multiple init functions per package</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1132.1">Unlike other names, multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.1133.1">init</span></strong><span class="koboSpan" id="kobo.1134.1"> functions are allowed per package. </span><span class="koboSpan" id="kobo.1134.2">However, you should be mindful that they will all be called before the main runner. </span><span class="koboSpan" id="kobo.1134.3">When multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.1135.1">init</span></strong><span class="koboSpan" id="kobo.1136.1"> functions are defined in the same file, they are run in definition order. </span><span class="koboSpan" id="kobo.1136.2">On the other hand, when they are defined in multiple files, they are run in the lexicographic order of </span><span class="No-Break"><span class="koboSpan" id="kobo.1137.1">their filenames.</span></span></p>
<p><span class="koboSpan" id="kobo.1138.1">We will define an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1139.1">init</span></strong><span class="koboSpan" id="kobo.1140.1"> function, alongside </span><strong class="source-inline"><span class="koboSpan" id="kobo.1141.1">TestMain</span></strong><span class="koboSpan" id="kobo.1142.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1143.1">TestAdd</span></strong><span class="koboSpan" id="kobo.1144.1">, in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1145.1">engine_test.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1146.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1147.1">
func init() {
  log.Println("Init setup.")
}</span></pre>
<p><span class="koboSpan" id="kobo.1148.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1149.1">init()</span></strong><span class="koboSpan" id="kobo.1150.1"> function simply prints another line to the Terminal. </span><span class="koboSpan" id="kobo.1150.2">Running the test shows us the </span><span class="No-Break"><span class="koboSpan" id="kobo.1151.1">following output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1152.1">
$ go test -run TestAdd ./chapter02/calculator -v 
2022/08/14 11:57:38 Init setup.
</span><span class="koboSpan" id="kobo.1152.2">2022/08/14 11:57:38 Setting up.
</span><span class="koboSpan" id="kobo.1152.3">=== RUN   TestAdd
--- PASS: TestAdd (0.00s)
PASS
2022/08/14 11:57:38 Tearing down.
</span><span class="koboSpan" id="kobo.1152.4">ok      github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter02/calculator   0.252s</span></pre>
<p><span class="koboSpan" id="kobo.1153.1">As we can see from </span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.1154.1">the test</span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.1155.1"> run output, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1156.1">init</span></strong><span class="koboSpan" id="kobo.1157.1"> setup is run before the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1158.1">TestMain</span></strong><span class="koboSpan" id="kobo.1159.1"> setup. </span><span class="koboSpan" id="kobo.1159.2">The logline defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1160.1">init</span></strong><span class="koboSpan" id="kobo.1161.1"> function is printed before any other code </span><span class="No-Break"><span class="koboSpan" id="kobo.1162.1">is executed.</span></span></p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.1163.1">Deferred functions</span></h2>
<p><span class="koboSpan" id="kobo.1164.1">We can make</span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.1165.1"> use of </span><strong class="bold"><span class="koboSpan" id="kobo.1166.1">deferred functions</span></strong><span class="koboSpan" id="kobo.1167.1"> for teardown logic that does not leak</span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.1168.1"> outside the scope of the current test. </span><span class="koboSpan" id="kobo.1168.2">Just like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1169.1">init</span></strong><span class="koboSpan" id="kobo.1170.1"> functions, this is a construct that does not only exist in </span><span class="No-Break"><span class="koboSpan" id="kobo.1171.1">test code.</span></span></p>
<p><span class="koboSpan" id="kobo.1172.1">In Go, deferred functions are declared using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1173.1">defer</span></strong><span class="koboSpan" id="kobo.1174.1"> statement. </span><span class="koboSpan" id="kobo.1174.2">Once this is applied to a function call, the function will only be executed once the surrounding function call has been completed, either successfully or using a panic. </span><span class="koboSpan" id="kobo.1174.3">For example, we can defer the teardown function </span><span class="No-Break"><span class="koboSpan" id="kobo.1175.1">like so:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1176.1">defer teardown()</span></strong></pre>
<p class="callout-heading"><span class="koboSpan" id="kobo.1177.1">Deferred function definitions</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1178.1">We can apply the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1179.1">defer</span></strong><span class="koboSpan" id="kobo.1180.1"> statement to named </span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.1181.1"> functions or </span><strong class="bold"><span class="koboSpan" id="kobo.1182.1">anonymous functions</span></strong><span class="koboSpan" id="kobo.1183.1"> defined inline. </span><span class="koboSpan" id="kobo.1183.2">It is Go convention to define your deferred functions at the top of the enclosing function. </span><span class="koboSpan" id="kobo.1183.3">This will ensure that the function will be deferred before any errors can occur and stop </span><span class="No-Break"><span class="koboSpan" id="kobo.1184.1">the deferral.</span></span></p>
<p><span class="koboSpan" id="kobo.1185.1">The approaches we’ve seen so far are made up of Go’s language constructs, but they can be cumbersome to keep defining and have the disadvantage of creating package-level changes. </span><span class="koboSpan" id="kobo.1185.2">Deferred functions give us fine-grained control, making changes only to the test</span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.1186.1"> where they are invoked. </span><span class="koboSpan" id="kobo.1186.2">However, the disadvantages are that we need to remember</span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.1187.1"> to add them to each test and that we can only use this approach for teardown, not setup logic. </span><span class="koboSpan" id="kobo.1187.2">You should weigh the advantages and disadvantages of each mechanism as you begin to write </span><span class="No-Break"><span class="koboSpan" id="kobo.1188.1">more tests.</span></span></p>
<p><span class="koboSpan" id="kobo.1189.1">Let’s modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1190.1">TestAdd</span></strong><span class="koboSpan" id="kobo.1191.1"> function in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1192.1">engine_test.go</span></strong><span class="koboSpan" id="kobo.1193.1"> file to add a deferred function, leaving the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1194.1">TestMain</span></strong><span class="koboSpan" id="kobo.1195.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1196.1">init</span></strong><span class="koboSpan" id="kobo.1197.1"> functions already defined in this test </span><span class="No-Break"><span class="koboSpan" id="kobo.1198.1">file unchanged:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1199.1">
func TestAdd(t *testing.T) {
</span><strong class="bold"><span class="koboSpan" id="kobo.1200.1">  defer func ()  {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1201.1">  log.Println("Deferred tearing down.")</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1202.1">}()</span></strong><span class="koboSpan" id="kobo.1203.1">
  // Arrange
  e := calculator.Engine{}
  x, y := 2.5, 3.5
  want := 6.0
  // Act
  got := e.Add(x, y)
  //Assert
  if got != want {
    t.Errorf("Add(%.2f,%.2f) incorrect, got: %.2f, want:
      %.2f", x, y, got, want)
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.1204.1">The deferred function simply prints out another log line to the Terminal. </span><span class="koboSpan" id="kobo.1204.2">Running the test shows us the</span><a id="_idIndexMarker183"/> <span class="No-Break"><span class="koboSpan" id="kobo.1205.1">following</span></span><span class="No-Break"><a id="_idIndexMarker184"/></span><span class="No-Break"><span class="koboSpan" id="kobo.1206.1"> output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1207.1">
$ go test -run TestAdd ./chapter02/calculator -v 
2022/08/14 12:25:49 Init setup.
</span><span class="koboSpan" id="kobo.1207.2">2022/08/14 12:25:49 Setting up.
</span><span class="koboSpan" id="kobo.1207.3">=== RUN   TestAdd
2022/08/14 12:25:49 Deferred tearing down.
</span><span class="koboSpan" id="kobo.1207.4">--- PASS: TestAdd (0.00s)
PASS
2022/08/14 12:25:49 Tearing down.
</span><span class="koboSpan" id="kobo.1207.5">ok      github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter02/calculator   0.215s</span></pre>
<p><span class="koboSpan" id="kobo.1208.1">As we can see from the test run output, the deferred teardown call is executed before the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1209.1">TestMain</span></strong><span class="koboSpan" id="kobo.1210.1"> function’s teardown step. </span><span class="koboSpan" id="kobo.1210.2">This is expected due to the invocation order of </span><span class="No-Break"><span class="koboSpan" id="kobo.1211.1">deferred functions.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1212.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1213.1">.7</span></em><span class="koboSpan" id="kobo.1214.1"> depicts a summary of the order in which all the setup and teardown mechanisms we’ve looked at </span><span class="No-Break"><span class="koboSpan" id="kobo.1215.1">will execute:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<span class="koboSpan" id="kobo.1216.1"><img alt="Figure 2.7 – Summary of the order of setup and teardown mechanisms " src="image/Figure_2.07_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1217.1">Figure 2.7 – Summary of the order of setup and teardown mechanisms</span></p>
<p><span class="koboSpan" id="kobo.1218.1">The order verifies what we’ve seen with our </span><span class="No-Break"><span class="koboSpan" id="kobo.1219.1">terminal output:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1220.1">The tests kick off with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1221.1">go test</span></strong><span class="koboSpan" id="kobo.1222.1"> command, as we’ve become used to running them </span><span class="No-Break"><span class="koboSpan" id="kobo.1223.1">so far.</span></span></li>
<li><span class="koboSpan" id="kobo.1224.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1225.1">init</span></strong><span class="koboSpan" id="kobo.1226.1"> functions execute before the temporary main program of </span><span class="No-Break"><span class="koboSpan" id="kobo.1227.1">the tests.</span></span></li>
<li><span class="koboSpan" id="kobo.1228.1">Once the tests are ready to execute, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1229.1">TestMain</span></strong><span class="koboSpan" id="kobo.1230.1"> function starts and its setup </span><span class="No-Break"><span class="koboSpan" id="kobo.1231.1">functions execute.</span></span></li>
<li><span class="koboSpan" id="kobo.1232.1">The tests are then run by invoking </span><strong class="source-inline"><span class="koboSpan" id="kobo.1233.1">m.Run()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1234.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1235.1">TestMain</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1236.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1237.1">Once all the tests have been run, the deferred functions defined inside the scope of the tests </span><span class="No-Break"><span class="koboSpan" id="kobo.1238.1">are executed.</span></span></li>
<li><span class="koboSpan" id="kobo.1239.1">Once the tests and their functions exit, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1240.1">TestMain</span></strong><span class="koboSpan" id="kobo.1241.1"> function’s teardown function </span><span class="No-Break"><span class="koboSpan" id="kobo.1242.1">is executed.</span></span></li>
<li><span class="koboSpan" id="kobo.1243.1">Finally, the tests end with the exit value returned from the call </span><span class="No-Break"><span class="koboSpan" id="kobo.1244.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1245.1">m.Run()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1246.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1247.1">As we begin to </span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.1248.1">consider </span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.1249.1">writing tests on a larger scale, we will also need a way to separate tests according to a smaller test scope and different scenarios. </span><span class="koboSpan" id="kobo.1249.2">In the next section, we’ll see how to achieve that </span><span class="No-Break"><span class="koboSpan" id="kobo.1250.1">using </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1251.1">subtests</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1252.1">.</span></span></p>
<h1 id="_idParaDest-54"><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.1253.1">Operating with subtests</span></h1>
<p><span class="koboSpan" id="kobo.1254.1">In TDD, the test scope </span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.1255.1">should be small, and the outcome should be easy to understand. </span><span class="koboSpan" id="kobo.1255.2">We explored TDD best practices in </span><a href="B18371_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1256.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.1257.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1258.1">Getting to Grips with Test-Driven Development</span></em><span class="koboSpan" id="kobo.1259.1">. </span><span class="koboSpan" id="kobo.1259.2">To achieve these best practices, we need separation between </span><span class="No-Break"><span class="koboSpan" id="kobo.1260.1">test scenarios.</span></span></p>
<p><span class="koboSpan" id="kobo.1261.1">Let’s consider the example of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1262.1">TestAdd</span></strong><span class="koboSpan" id="kobo.1263.1"> function that we have worked with so far. </span><span class="koboSpan" id="kobo.1263.2">It currently tests adding two positive numbers, but we will extend it to cover negative inputs. </span><span class="koboSpan" id="kobo.1263.3">With the knowledge we have so far, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.1264.1">two options:</span></span></p>
<ol>
<li value="1"><strong class="bold"><span class="koboSpan" id="kobo.1265.1">Extend the scope of </span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.1266.1">TestAdd</span></strong><strong class="bold"><span class="koboSpan" id="kobo.1267.1"> to verify the new scenario</span></strong><span class="koboSpan" id="kobo.1268.1">: This approach will make the Assert step longer, but it has the advantage of reusing the </span><span class="No-Break"><span class="koboSpan" id="kobo.1269.1">previous steps.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1270.1">Create a new test to verify the new scenario</span></strong><span class="koboSpan" id="kobo.1271.1">: This approach will keep the scope of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1272.1">TestAdd</span></strong><span class="koboSpan" id="kobo.1273.1"> as is, but it has the disadvantage of us having to redefine and re-execute the Arrange and Act steps of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1274.1">existing test.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1275.1">If we choose to go with the second option, we will have to name the new test something different. </span><span class="koboSpan" id="kobo.1275.2">We will name it </span><strong class="source-inline"><span class="koboSpan" id="kobo.1276.1">TestAdd_Negative</span></strong><span class="koboSpan" id="kobo.1277.1"> to signify that we will be testing negative inputs in this test. </span><span class="koboSpan" id="kobo.1277.2">However, this doesn’t fall in line with the naming of the existing </span><strong class="source-inline"><span class="koboSpan" id="kobo.1278.1">TestAdd</span></strong><span class="koboSpan" id="kobo.1279.1"> function, so we will have to rename the existing test to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1280.1">TestAdd_Positive</span></strong><span class="koboSpan" id="kobo.1281.1">. </span><span class="koboSpan" id="kobo.1281.2">As expected, running the tests will output the result on </span><span class="No-Break"><span class="koboSpan" id="kobo.1282.1">different lines:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1283.1">
$ go test -run "^TestAdd" ./chapter02/calculator -v 
=== RUN   TestAdd_Positive
--- PASS: TestAdd_Positive (0.00s)
=== RUN   TestAdd_Negative
--- PASS: TestAdd_Negative (0.00s)
PASS
ok      github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter02/calculator   0.266s</span></pre>
<p><span class="koboSpan" id="kobo.1284.1">We want to have a small self-contained test, but it would be cumbersome to continue to define new tests, potentially having to change the name of existing tests for each new edge case or scenario we test. </span><span class="koboSpan" id="kobo.1284.2">Go provides us with a more elegant solution to this common</span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.1285.1"> problem, which we will cover in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1286.1">next section.</span></span></p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.1287.1">Implementing subtests</span></h2>
<p><span class="koboSpan" id="kobo.1288.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1289.1">testing.T</span></strong><span class="koboSpan" id="kobo.1290.1"> type </span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.1291.1">provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1292.1">Run(name string, f func(t *testing.T)) bool</span></strong><span class="koboSpan" id="kobo.1293.1"> method, which takes in </span><span class="No-Break"><span class="koboSpan" id="kobo.1294.1">two parameters:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1295.1">A name parameter of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1296.1">string</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1297.1"> type</span></span></li>
<li><span class="koboSpan" id="kobo.1298.1">A function that takes in a single parameter of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1299.1">*</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1300.1">testing.T</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1301.1"> type</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1302.1">Once passed to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1303.1">Run</span></strong><span class="koboSpan" id="kobo.1304.1"> method, the test runner will run the function as a subtest of the current tests, allowing us to create a test hierarchy, each with its own separation. </span><span class="koboSpan" id="kobo.1304.2">Since the enclosing test and the subtests share the same instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1305.1">testing.T</span></strong><span class="koboSpan" id="kobo.1306.1">, a subtest failure will cause the enclosing test to fail as well. </span><span class="koboSpan" id="kobo.1306.2">This behavior gives us the ability to create multi-layered test hierarchies according to our needs. </span><span class="koboSpan" id="kobo.1306.3">Taking the example of adding positive and negative inputs as test scenarios, we can refactor </span><strong class="source-inline"><span class="koboSpan" id="kobo.1307.1">TestAdd</span></strong><span class="koboSpan" id="kobo.1308.1"> to take advantage of the power </span><span class="No-Break"><span class="koboSpan" id="kobo.1309.1">of subtests:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1310.1">
func TestAdd(t *testing.T) {
  // Arrange
  e := calculator.Engine{}
</span><strong class="bold"><span class="koboSpan" id="kobo.1311.1">  actAssert := func(x, y, want float64) {</span></strong><span class="koboSpan" id="kobo.1312.1">
  // Act
  got := e.Add(x, y)
  //Assert
  if got != want {
    t.Errorf("Add(%.2f,%.2f) incorrect, got: %.2f, want:
      %.2f", x, y, got, want)
  }
}
</span><strong class="bold"><span class="koboSpan" id="kobo.1313.1">  t.Run("positive input", func(t *testing.T) {</span></strong><span class="koboSpan" id="kobo.1314.1">
    x, y := 2.5, 3.5
    want := 6.0
    actAssert(x, y, want)
  })
</span><strong class="bold"><span class="koboSpan" id="kobo.1315.1">  t.Run("negative input", func(t *testing.T) {</span></strong><span class="koboSpan" id="kobo.1316.1">
    x, y := -2.5, -3.5
    want := -6.0
    actAssert(x, y, want)
  })
}</span></pre>
<p><span class="koboSpan" id="kobo.1317.1">We create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1318.1">actAssert</span></strong><span class="koboSpan" id="kobo.1319.1"> function that takes in the inputs and expected output as parameters. </span><span class="koboSpan" id="kobo.1319.2">This function will perform the Act and Assert steps without having to repeat them. </span><span class="koboSpan" id="kobo.1319.3">Then, we </span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.1320.1">create two subtests using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1321.1">t.Run</span></strong><span class="koboSpan" id="kobo.1322.1"> method we’ve seen before. </span><span class="koboSpan" id="kobo.1322.2">The name of each subtest indicates what scenario it will cover. </span><span class="koboSpan" id="kobo.1322.3">Running the tests will produce the </span><span class="No-Break"><span class="koboSpan" id="kobo.1323.1">following result:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1324.1">
$ go test -run "^TestAdd" ./chapter02/calculator -v 
=== RUN   TestAdd
=== RUN   TestAdd/positive_input
=== RUN   TestAdd/negative_input
--- PASS: TestAdd (0.00s)
    --- PASS: TestAdd/positive_input (0.00s)
    --- PASS: TestAdd/negative_input (0.00s)
PASS
ok      github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter02/calculator   0.195s</span></pre>
<p><span class="koboSpan" id="kobo.1325.1">As we can see from the output, the subtests are nested under the enclosing test. </span><span class="koboSpan" id="kobo.1325.2">By leveraging subtests, we now have a convenient way to create tests that share the Arrange step, but can also be easily extended with more scenarios without the need to </span><span class="No-Break"><span class="koboSpan" id="kobo.1326.1">rename tests.</span></span></p>
<p><span class="koboSpan" id="kobo.1327.1">We will discuss the </span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.1328.1">related technique of </span><strong class="bold"><span class="koboSpan" id="kobo.1329.1">table-driven testing</span></strong><span class="koboSpan" id="kobo.1330.1">, which </span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.1331.1">leverages the power of subtests, in </span><a href="B18371_04.xhtml#_idTextAnchor085"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1332.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.1333.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1334.1">Building Efficient </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1335.1">Test Suites</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1336.1">.</span></span></p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.1337.1">Code coverage</span></h2>
<p><span class="koboSpan" id="kobo.1338.1">Now that we</span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.1339.1"> know</span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.1340.1"> how to write tests that cover different scenarios and how to run them, we can have a look at what our </span><strong class="bold"><span class="koboSpan" id="kobo.1341.1">code coverage</span></strong><span class="koboSpan" id="kobo.1342.1"> is. </span><span class="koboSpan" id="kobo.1342.2">As we remember from </span><a href="B18371_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1343.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.1344.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1345.1">Getting to Grips with Test-Driven Development</span></em><span class="koboSpan" id="kobo.1346.1">, this important metric measures what percentage of your code is exercised </span><span class="No-Break"><span class="koboSpan" id="kobo.1347.1">by tests.</span></span></p>
<p><span class="koboSpan" id="kobo.1348.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1349.1">go test</span></strong><span class="koboSpan" id="kobo.1350.1"> command has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1351.1">–cover</span></strong><span class="koboSpan" id="kobo.1352.1"> flag, which computes the code coverage profile of the given package. </span><span class="koboSpan" id="kobo.1352.2">It also offers the possibility of saving the profile to a file by passing a file path to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1353.1">-coverprofile</span></strong><span class="koboSpan" id="kobo.1354.1"> flag. </span><span class="koboSpan" id="kobo.1354.2">We will then see how to view these saved </span><span class="No-Break"><span class="koboSpan" id="kobo.1355.1">coverage profiles.</span></span></p>
<p><span class="koboSpan" id="kobo.1356.1">Let’s run it for </span><span class="No-Break"><span class="koboSpan" id="kobo.1357.1">our calculator:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1358.1">
$ go test -run "^TestAdd" ./chapter02/calculator -cover -v 
=== RUN   TestAdd
=== RUN   TestAdd/positive_input
=== RUN   TestAdd/negative_input
--- PASS: TestAdd (0.00s)
    --- PASS: TestAdd/positive_input (0.00s)
    --- PASS: TestAdd/negative_input (0.00s)
PASS
coverage: 100.0% of statements
ok      github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter02/calculator   0.113s</span></pre>
<p><span class="koboSpan" id="kobo.1359.1">This command prints out the coverage percentage after running all the tests. </span><span class="koboSpan" id="kobo.1359.2">We are currently measuring coverage of 100% since our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1360.1">Add</span></strong><span class="koboSpan" id="kobo.1361.1"> function is </span><span class="No-Break"><span class="koboSpan" id="kobo.1362.1">very simple.</span></span></p>
<p><span class="koboSpan" id="kobo.1363.1">Now, let’s save the code coverage profile to a file using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1364.1">go test ./chapter02/calculator -coverprofile=calcCover.out</span></strong><span class="koboSpan" id="kobo.1365.1">. </span><span class="koboSpan" id="kobo.1365.2">This will create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1366.1">calcCover.out</span></strong><span class="koboSpan" id="kobo.1367.1"> file in the current directory. </span><span class="koboSpan" id="kobo.1367.2">We can view this file visually using another tool in the Go toolchain. </span><span class="koboSpan" id="kobo.1367.3">Running </span><strong class="source-inline"><span class="koboSpan" id="kobo.1368.1">go tool cover -html=calcCover.out</span></strong><span class="koboSpan" id="kobo.1369.1"> will open a new window in your browser to display the coverage </span><span class="No-Break"><span class="koboSpan" id="kobo.1370.1">profile visually.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1371.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1372.1">.8</span></em><span class="koboSpan" id="kobo.1373.1"> shows the visual representation of our cover profile, which shows that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1374.1">Add</span></strong><span class="koboSpan" id="kobo.1375.1"> method is covered </span><span class="No-Break"><span class="koboSpan" id="kobo.1376.1">by tests:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer026">
<span class="koboSpan" id="kobo.1377.1"><img alt="Figure 2.8 – The visual representation of the saved profile " src="image/Figure_2.08_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1378.1">Figure 2.8 – The visual representation of the saved profile</span></p>
<p><span class="koboSpan" id="kobo.1379.1">That covers all </span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.1380.1">the </span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.1381.1">essentials we need to know to begin writing Go tests with TDD. </span><span class="koboSpan" id="kobo.1381.2">The last thing we need to tackle is how to write and </span><span class="No-Break"><span class="koboSpan" id="kobo.1382.1">use benchmarks.</span></span></p>
<h1 id="_idParaDest-57"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.1383.1">The difference between a test and a benchmark</span></h1>
<p><span class="koboSpan" id="kobo.1384.1">The last concept</span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.1385.1"> we will</span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.1386.1"> be looking at in this chapter is </span><strong class="bold"><span class="koboSpan" id="kobo.1387.1">benchmarks</span></strong><span class="koboSpan" id="kobo.1388.1">. </span><span class="koboSpan" id="kobo.1388.2">The testing package gives us access to benchmarks using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1389.1">testing.B</span></strong><span class="koboSpan" id="kobo.1390.1"> type. </span><span class="koboSpan" id="kobo.1390.2">They have a signature very similar </span><span class="No-Break"><span class="koboSpan" id="kobo.1391.1">to tests:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1392.1">func BenchmarkName(b *testing.B) {</span></strong><span class="koboSpan" id="kobo.1393.1">
  // implementation
}</span></pre>
<p><span class="koboSpan" id="kobo.1394.1">The signature highlights the following requirements for </span><span class="No-Break"><span class="koboSpan" id="kobo.1395.1">Go benchmarks:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1396.1">Benchmarks are exported functions whose name begins </span><span class="No-Break"><span class="koboSpan" id="kobo.1397.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1398.1">Benchmark</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1399.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1400.1">Benchmark names can have an additional suffix that specifies what the test is covering. </span><span class="koboSpan" id="kobo.1400.2">The suffix must also begin with a capital letter, as we can see </span><span class="No-Break"><span class="koboSpan" id="kobo.1401.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1402.1">Name</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1403.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1404.1">Benchmarks must take in a single parameter of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1405.1">*testing.B</span></strong><span class="koboSpan" id="kobo.1406.1"> type. </span><span class="koboSpan" id="kobo.1406.2">As we’ve explained so far, this will be how the test interacts with the test runner. </span><span class="koboSpan" id="kobo.1406.3">You can name the testing parameter however you want, but Go developers typically use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1407.1">b</span></strong><span class="koboSpan" id="kobo.1408.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.1409.1">denote it.</span></span></li>
<li><span class="koboSpan" id="kobo.1410.1">Benchmarks must not have a </span><span class="No-Break"><span class="koboSpan" id="kobo.1411.1">return type.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.1412.1">Benchmarks are an important Go profiling tool</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1413.1">Tests verify the functionality of your programs, while benchmarks verify the performance of your code. </span><span class="koboSpan" id="kobo.1413.2">You should use both in your </span><span class="No-Break"><span class="koboSpan" id="kobo.1414.1">testing strategy.</span></span></p>
<p><span class="koboSpan" id="kobo.1415.1">Benchmarks can</span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.1416.1"> also </span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.1417.1">be run with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1418.1">go test</span></strong><span class="koboSpan" id="kobo.1419.1"> command, but we have to specify to the runner that we are interested in benchmarks with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1420.1">–bench</span></strong><span class="koboSpan" id="kobo.1421.1"> flag. </span><span class="koboSpan" id="kobo.1421.2">We must supply a regular expression that matches the packages that we want to run. </span><span class="koboSpan" id="kobo.1421.3">We can run all benchmarks by matching all packages in the current directory using </span><span class="No-Break"><span class="koboSpan" id="kobo.1422.1">this command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1423.1">
go test -bench. </span><span class="koboSpan" id="kobo.1423.2">.</span></pre>
<p><span class="koboSpan" id="kobo.1424.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1425.1">testing.B</span></strong><span class="koboSpan" id="kobo.1426.1"> type also has access to logging errors and signaling test failures, just as we saw in the introduction to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1427.1">testing.T</span></strong><span class="koboSpan" id="kobo.1428.1"> type: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1429.1">b.Error</span></strong><span class="koboSpan" id="kobo.1430.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1431.1">b.Errorf</span></strong><span class="koboSpan" id="kobo.1432.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1433.1">b.Fatal</span></strong><span class="koboSpan" id="kobo.1434.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1435.1">b.Fatalf</span></strong><span class="koboSpan" id="kobo.1436.1">. </span><span class="koboSpan" id="kobo.1436.2">Just like tests, benchmarks live in test files, which must have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1437.1">_test.go</span></strong><span class="koboSpan" id="kobo.1438.1"> suffix to be detected by the Go </span><span class="No-Break"><span class="koboSpan" id="kobo.1439.1">test runner.</span></span></p>
<p><span class="koboSpan" id="kobo.1440.1">Let’s write a benchmark for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1441.1">Add</span></strong><span class="koboSpan" id="kobo.1442.1"> function in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1443.1">engine_test.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1444.1"> file:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1445.1">func BenchmarkAdd(b *testing.B) {</span></strong><span class="koboSpan" id="kobo.1446.1">
  e := calculator.Engine{}
  // run the Add function b.N times
</span><strong class="bold"><span class="koboSpan" id="kobo.1447.1">  for i := 0; i &lt; b.N; i++</span></strong><span class="koboSpan" id="kobo.1448.1"> {
    e.Add(2, 3)
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.1449.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1450.1">BenchmarkAdd</span></strong><span class="koboSpan" id="kobo.1451.1"> example runs the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1452.1">Add</span></strong><span class="koboSpan" id="kobo.1453.1"> function with the parameters in a loop for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1454.1">b.N</span></strong><span class="koboSpan" id="kobo.1455.1"> times. </span><span class="koboSpan" id="kobo.1455.2">Go’s test runner controls the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1456.1">N</span></strong><span class="koboSpan" id="kobo.1457.1"> and will increase it until it is satisfied that the numbers it has measured </span><span class="No-Break"><span class="koboSpan" id="kobo.1458.1">are stable.</span></span></p>
<p><span class="koboSpan" id="kobo.1459.1">As with all performance tests, you should be wary of running benchmarks on your local machine. </span><span class="koboSpan" id="kobo.1459.2">You might measure some large variations in measurement according to what your computer </span><span class="No-Break"><span class="koboSpan" id="kobo.1460.1">is processing.</span></span></p>
<p><span class="koboSpan" id="kobo.1461.1">Now, we run</span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.1462.1"> our </span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.1463.1">benchmark to see the </span><span class="No-Break"><span class="koboSpan" id="kobo.1464.1">following output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1465.1">
$ go test -bench. </span><span class="koboSpan" id="kobo.1465.2">./ chapter02/calculator -v 
pkg: github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter02/calculator
cpu: IntelI Core(TM) i5-8279U CPU @ 2.40GHz
BenchmarkAdd-8          1000000000               0.2684 ns/op
PASS
ok      github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter02/calculator   0.408s</span></pre>
<p><span class="koboSpan" id="kobo.1466.1">The output of the benchmark run highlights </span><span class="No-Break"><span class="koboSpan" id="kobo.1467.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1468.1">The name of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1469.1">benchmark: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1470.1">BenchmarkAdd</span></strong></span></li>
<li><span class="koboSpan" id="kobo.1471.1">The number of CPU cores used to run the benchmark, added as a suffix to the test </span><span class="No-Break"><span class="koboSpan" id="kobo.1472.1">name: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1473.1">8</span></strong></span></li>
<li><span class="koboSpan" id="kobo.1474.1">How many times the benchmark was </span><span class="No-Break"><span class="koboSpan" id="kobo.1475.1">executed: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1476.1">1000000000</span></strong></span></li>
<li><span class="koboSpan" id="kobo.1477.1">The average amount of time that an individual test iteration took, measured in nanoseconds: </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1478.1">0.2684 ns/op</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1479.1">Our function is very simple, which is why it has a very </span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.1480.1">low running </span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.1481.1">time. </span><span class="koboSpan" id="kobo.1481.2">We will explore more complex examples of benchmarks in </span><a href="B18371_08.xhtml#_idTextAnchor179"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1482.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.1483.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1484.1">Testing </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1485.1">Microservice Architectures</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1486.1">.</span></span></p>
<h1 id="_idParaDest-58"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.1487.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1488.1">In this chapter, we covered all the unit testing essentials that we will need to get started with TDD in Go. </span><span class="koboSpan" id="kobo.1488.2">We began by introducing Go modules and packages, as well as where test files are placed and how they declare their additional test packages. </span><span class="koboSpan" id="kobo.1488.3">You learned about the most important methods in Go’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1489.1">testing</span></strong><span class="koboSpan" id="kobo.1490.1"> package and started writing some simple unit tests with it. </span><span class="koboSpan" id="kobo.1490.2">Then, we explored ways to reduce code duplication by making use of setup and teardown functions, as well as how to better organize tests using subtests. </span><span class="koboSpan" id="kobo.1490.3">Finally, we learned how to write and run benchmarks, which are an important part of any </span><span class="No-Break"><span class="koboSpan" id="kobo.1491.1">testing strategy.</span></span></p>
<p><span class="koboSpan" id="kobo.1492.1">In </span><a href="B18371_03.xhtml#_idTextAnchor061"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1493.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.1494.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1495.1">Mocking and Assertion Frameworks</span></em><span class="koboSpan" id="kobo.1496.1">, we will write more complicated tests, which require dependencies. </span><span class="koboSpan" id="kobo.1496.2">We will explore some popular frameworks and begin to use them to write tests that are closer to </span><span class="No-Break"><span class="koboSpan" id="kobo.1497.1">real-world examples.</span></span></p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.1498.1">Questions</span></h1>
<p><span class="koboSpan" id="kobo.1499.1">Answer the following questions to test your knowledge of </span><span class="No-Break"><span class="koboSpan" id="kobo.1500.1">this chapter:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1501.1">In Go, what is the difference between a module and </span><span class="No-Break"><span class="koboSpan" id="kobo.1502.1">a package?</span></span></li>
<li><span class="koboSpan" id="kobo.1503.1">What is the additional test package? </span><span class="koboSpan" id="kobo.1503.2">What are some of the advantages of </span><span class="No-Break"><span class="koboSpan" id="kobo.1504.1">using it?</span></span></li>
<li><span class="koboSpan" id="kobo.1505.1">What are the requirements for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1506.1">test signature?</span></span></li>
<li><span class="koboSpan" id="kobo.1507.1">What are subtests and how do you </span><span class="No-Break"><span class="koboSpan" id="kobo.1508.1">create them?</span></span></li>
<li><span class="koboSpan" id="kobo.1509.1">What is a benchmark? </span><span class="koboSpan" id="kobo.1509.2">How do you </span><span class="No-Break"><span class="koboSpan" id="kobo.1510.1">write one?</span></span></li>
</ol>
<h1 id="_idParaDest-60"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.1511.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.1512.1">To learn more about the topics that were covered in this chapter, take a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.1513.1">following resources:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1514.1">The official documentation for the testing package is available </span><span class="No-Break"><span class="koboSpan" id="kobo.1515.1">at </span></span><a href="https://pkg.go.dev/testing"><span class="No-Break"><span class="koboSpan" id="kobo.1516.1">https://pkg.go.dev/testing</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1517.1">The Art of Unit Testing</span></em><span class="koboSpan" id="kobo.1518.1">, by Roy Osherove, published by </span><span class="No-Break"><span class="koboSpan" id="kobo.1519.1">Manning Publications</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1520.1">Profiling Go Programs </span></em><span class="koboSpan" id="kobo.1521.1">is available on the Go blog </span><span class="No-Break"><span class="koboSpan" id="kobo.1522.1">at </span></span><a href="https://go.dev/blog/pprof"><span class="No-Break"><span class="koboSpan" id="kobo.1523.1">https://go.dev/blog/pprof</span></span></a></li>
</ul>
</div>
</body></html>