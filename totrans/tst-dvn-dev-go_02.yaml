- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit Testing Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned all about the iterative process of writing
    tests alongside code using TDD, as well as how it fits into the **Agile project
    methodology**. We covered the **red, green, refactor approach**, which requires
    frequent switching between source code and test code.
  prefs: []
  type: TYPE_NORMAL
- en: When first starting with TDD, following a prescribed process for writing code
    may seem like an artificial way of working, but it soon becomes second nature
    with practice. In this chapter, we will learn all the Go fundamentals required
    to begin putting everything else we have learned to use. We will begin to write
    unit tests with Go’s `testing` package, focusing on the test writing syntax and
    process. This chapter will allow us to get hands-on experience with all the concepts
    we have explored so far.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw from the **testing pyramid** in [*Chapter 1*](B18371_01.xhtml#_idTextAnchor015),
    *Getting to Grips with Test-Driven Development*, **unit tests** are the most numerous.
    They are used to verify the functionality of a single unit, in isolation. We will
    begin our exploration of TDD and Go testing by implementing unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: The Go programming language was created by the team at Google to allow developers
    to write simple and efficient software, which they felt was not achievable with
    the tools they had available at the time. This principle of simplicity is echoed
    throughout the entire language, including its test writing and running functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The Go standard library provides the `testing` package, which provides the essentials
    we need for writing automated tests. Tests are simply functions that satisfy certain
    conventions and signatures, making it easier for developers to write code using
    the same strategies and mechanisms as they write their source code.
  prefs: []
  type: TYPE_NORMAL
- en: The Go toolchain provides a single `go test` command for running all the tests
    that we have defined. This simple yet powerful command also provides functionality
    for running benchmarks, which we can use to examine the performance of a given
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Go package as the **Unit Under** **Test** (**UUT**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fundamentals of working with Go’s testing package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test setup and teardown
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping tests into suites with subtests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between a test and a benchmark
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need to have **Go version 1.19** or later installed to run the code
    samples in this chapter. The installation process is described in the official
    Go documentation at [https://go.dev/doc/install](https://go.dev/doc/install).
  prefs: []
  type: TYPE_NORMAL
- en: The code examples included in this book are publicly available at [https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter02](https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: The unit under test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B18371_01.xhtml#_idTextAnchor015), *Getting to Grips with Test-Driven
    Development*, we discussed the structure of tests using the **Arrange-Act-Assert**
    (**AAA**) pattern. We also briefly mentioned that the Arrange step sets up the
    **Unit Under Test** (**UUT**) and its dependencies. The test then exercises and
    verifies the functionality of the UUT.
  prefs: []
  type: TYPE_NORMAL
- en: In Go, source code is organized into packages and modules. We will begin by
    exploring what these are and how they work and then look at how test files fit
    into this structure. A solid understanding of the power of packages will set the
    scene for us to begin considering not only *how* to write tests, but *what* to
    test.
  prefs: []
  type: TYPE_NORMAL
- en: Modules and packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have worked with Go for a while, you might be familiar with Go’s **module
    system**, which was introduced as the default dependency management solution in
    **Go 1.13**. The latest Go version at the time of writing is **version 1.19**,
    so the module system has been the standard solution for some time.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **module** is a collection of packages that are distributed and released together.
    The name of the module should be representative of its functionality, as well
    as where to find it. The Go toolchain provides support for popular code hosting
    solutions such as GitHub and Bitbucket and can issue the correct requests for
    downloading dependencies from their version control systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modules are declared by placing a `go.mod` file at the root of the project
    directory. A new module can be initialized by running the `go mod init` command
    with a module path as a parameter. We can initialize the module for all our code
    examples by running the following command in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The module path we have provided is the same as the GitHub repository path.
    The generated file only contains two lines – one for the module path and one for
    the version of Go required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, the `go.mod` file contains these properties:'
  prefs: []
  type: TYPE_NORMAL
- en: The module path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The version of Go required for the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any external dependencies that need to be imported when building the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since our project is empty for now, our module’s file does not specify any external
    dependencies. The packages of the standard library do not need to be declared
    as dependencies. This file will be automatically updated with dependencies once
    they are used in the source code of the module.
  prefs: []
  type: TYPE_NORMAL
- en: The generated go.mod file
  prefs: []
  type: TYPE_NORMAL
- en: The `go.mod` file is generated, but not read-only. However, as a rule of thumb,
    you should avoid editing the `go.mod` file manually. In general, developers edit
    it only to change version numbers, not to manually change its entries. You can
    also recreate it any time with the `go mod` `init` command.
  prefs: []
  type: TYPE_NORMAL
- en: Packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While modules are a fantastic way to bundle and release projects, most production
    systems would be almost impossible to maintain or understand if they did not have
    any internal organization or hierarchy. This is where Go packages come in to help
    us provide this much-needed structure.
  prefs: []
  type: TYPE_NORMAL
- en: Go source code is organized into `package` keyword. All the names defined in
    the source file are then added to the declared package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking back at the simple terminal calculator example from [*Chapter 1*](B18371_01.xhtml#_idTextAnchor015),
    *Getting to Grips with Test-Driven Development*, we can specify a package and
    source code structure for it, as seen in *Figure 2**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – The module, packages, and source files of the simple Terminal
    calculator ](img/Figure_2.01_B18371.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – The module, packages, and source files of the simple Terminal calculator
  prefs: []
  type: TYPE_NORMAL
- en: 'The module contains three packages, each containing specialized functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: The `input` package contains an input parser and validation functionality. It
    has dependencies on the `calculator` and `format` packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `calculator` package contains all the calculation engine logic, providing
    functionality for all the operations that the calculator provides. It has a dependency
    on the `format` package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `format` package contains formatting logic for results and errors. It has
    no dependencies on our existing packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package naming is important
  prefs: []
  type: TYPE_NORMAL
- en: Package names should be representative of the functionality they provide so
    that other code may reference them. Package names should be short and descriptive.
    They should also be meaningful when used along with the names of the types and
    functions they provide.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `format` package is at the bottom of our package hierarchy, and we can
    begin by defining it and its result formatting capabilities immediately. Looking
    at the contents of its `result.go` source file, we can see its simple definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This package defines a `Result` function that outputs a formatted string of
    the given expression and result. We added the return of an empty string to ensure
    the code compiles until we are ready to begin implementation with TDD. The `error.go`
    file is similarly defined and has been omitted for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the calculator engine in more detail, the contents of the `engine.go`
    source file can begin like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We begin with the `package calculator` definition, adding the source file and
    all its definitions to the `calculator` package. Then, we create an `Engine` type
    that will contain all the dependencies of the calculator. After these few lines,
    we can begin to define methods for all the operations that the engine needs to
    provide. The `Add` method of the `Engine` type is an example of what the definition
    of the addition operation is.
  prefs: []
  type: TYPE_NORMAL
- en: Those of you who are eagle-eyed will notice that the types, methods, and functions
    have been defined with a capital letter. This makes them **exported names**.
  prefs: []
  type: TYPE_NORMAL
- en: Visibility outside of the package
  prefs: []
  type: TYPE_NORMAL
- en: Only the exported names of a package are visible for usage outside of their
    defined package. Unlike other languages, there are no visibility modifiers in
    Go. In the code examples for the `format` and `calculator` packages, we need their
    functionality to be available outside of their respective packages, so this is
    why they have been exported and defined with a capital letter.
  prefs: []
  type: TYPE_NORMAL
- en: A package can declare a dependency on another package by using the `import`
    keyword. We can then reference the variables, types, and functions of the imported
    package by qualifying them with the package name and the **dot** **operator**
    (**.**).
  prefs: []
  type: TYPE_NORMAL
- en: 'With some exceptions, there can only be one single package name per directory.
    The declaration of the new `input` package will also require the creation of a
    new directory. The declaration of `Parser`, which has a dependency on the `Engine`
    type, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`Parser` is declared as part of `package input`. The `Parser` type needs the
    functionality of the `Calculator` type, so it imports the `calculator` package.
    As mentioned, the reference to `calculator.Engine` is qualified using its provided
    package and the dot operator. This lets the compiler know that the type referenced
    is coming from an imported package, not the current package.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The highlighted import path consists of three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The module that the package belongs to: [github.com/PacktPublishing/Test-Driven-Development-in-Go](http://github.com/PacktPublishing/Test-Driven-Development-in-Go)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The sub-directory path from the root of the module: `chapter02`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The name of the imported package: `calculator`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The power of Go packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Packages are a powerful and central concept to Go. They allow developers to
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Group components**: When named well, packages provide an easy way to understand,
    uniquely group, and document multiple components that share the same functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encapsulate code**: Since only exported methods are visible to external code,
    packages are the most important encapsulation mechanism in Go. They give developers
    fine-grained control over exactly what is available for use outside of the package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reuse code**: Packages provide modularity to our programs, allowing us to
    reuse code in multiple places by providing a way for users to import them. The
    ability to leverage code from outside the current module allows developers to
    share the same solutions, without reinventing the wheel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easily manage dependencies**: Go’s module system follows **Semantic Versioning**
    (**SemVer**), which uses three primary numbers to manage imported dependencies:
    the major, the minor, and the patch version. This allows developers to pin dependencies
    to a certain version, as well as easily know when they need to upgrade to a newer
    version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we understand the fundamentals of modules and packages, let’s turn
    our attention toward where testing fits into the codebase and its packages. Notice
    that the methods of the `Engine` and `Parser` custom types do not have any code
    implemented yet: this is because TDD is all about writing tests first!'
  prefs: []
  type: TYPE_NORMAL
- en: Packages as APIs
  prefs: []
  type: TYPE_NORMAL
- en: Due to their encapsulation and modularity properties, packages enable developers
    to build and structure their code using similar techniques as when designing external
    APIs, by choosing the signatures and functions they want to provide to external
    users.
  prefs: []
  type: TYPE_NORMAL
- en: Test file naming and placement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike other programming languages, test files live alongside the source code
    in Go. All test files must end with the `_test.go` suffix. Go’s test runner scans
    the codebase for these test files and runs them accordingly. The test runner is
    part of the Go toolchain and can be invoked using the `go` `test` command.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.2* presents the directory structure of the simple terminal calculator
    discussed so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – The directory structure of the simple Terminal calculator ](img/Figure_2.02_B18371.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – The directory structure of the simple Terminal calculator
  prefs: []
  type: TYPE_NORMAL
- en: All the code that we will be discussing in this chapter can be found in the
    `chapter02` directory of the dedicated repository corresponding to this book.
    Then, inside this directory, we have three further directories for `format`, `calculator`,
    and `input`, which each contain their source code files and corresponding test
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Naming test files
  prefs: []
  type: TYPE_NORMAL
- en: While test files need to end with the `_test.go` suffix, matching the rest of
    their name to their corresponding source code file is not enforced. However, it
    is highly recommended that you use the source filename and then append the test
    suffix. This will also ensure that the two files stay together when sorted lexicographically.
  prefs: []
  type: TYPE_NORMAL
- en: The source files and test files live directly next to each other, in the same
    directory, making it even easier for developers to swap between writing implementation
    code and test code when practicing TDD. Some editing tools can even do this with
    a keyboard shortcut!
  prefs: []
  type: TYPE_NORMAL
- en: Additional test packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although test files are named the same as their corresponding source files and
    live in the same directory, the package structure will tell a different story.
    We previously mentioned that, with some exceptions, only one package may be declared
    per directory. Test files are one of these exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Test files are allowed to declare an additional test package, matching the source
    files package with `_test` appended. From a visibility perspective, this test
    package is the same as any other package and will need to import the packages
    that it wishes to have access to. It will also only have access to the exported
    names of its imported packages.
  prefs: []
  type: TYPE_NORMAL
- en: Test packages as a recommended practice
  prefs: []
  type: TYPE_NORMAL
- en: The usage of the dedicated `_test` package is not enforced in Go, but it is
    recommended. Whenever possible, you should declare your tests in a dedicated test
    package.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.3* depicts the separate definitions of test packages in the simple
    Terminal calculator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – The package and directory structure of the simple calculator
    ](img/Figure_2.03_B18371.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – The package and directory structure of the simple calculator
  prefs: []
  type: TYPE_NORMAL
- en: 'The dedicated test package is defined in the same directory as the source package,
    achieving full separation between the source and test code. Using the dedicated
    test package brings the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Prevents brittle tests**: Restricting access to only exported functionality
    does not give test code visibility into package internals, such as state variables,
    which would otherwise cause inconsistent results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Separates test and core package dependencies**: The test package allows the
    test to import any dependencies required, without adding those dependencies to
    the core package. In practice, test code will often have its own dedicated verifiers
    and functionality, which we would not want to be visible to production code. The
    test package is a seamless way to guarantee separation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Allows developers to integrate with their own packages**: We previously mentioned
    that packages allow developers to build their internal code as small APIs. Writing
    tests from a dedicated test package allows developers to see how easy it is to
    integrate with their designed external interfaces, ensuring that their code is
    maintainable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 2**.4* shows the updated module, packages, source, and test files of
    the simple Terminal calculator, which now uses `_test` packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – The module, packages, source, and test files of the simple Terminal
    calculator ](img/Figure_2.04_B18371.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – The module, packages, source, and test files of the simple Terminal
    calculator
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s describe the dependencies between the packages in terms of the AAA pattern
    that we know from [*Chapter 1*](B18371_01.xhtml#_idTextAnchor015), *Getting to
    Grips with Test-Driven Development*. The **Arrange** and **Assert** steps are
    performed on the UUT and are conveniently defined in the correspondingly named
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: The `format` package does not have any dependencies on other packages. As a
    result, the `format_test` package performs all three steps on the `format` package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `calculator` package has a dependency on the `format` package. As a result,
    the `calculator_test` package arranges the dependencies from the `format` package.
    Then, it performs the Act and Assert steps on the `calculator` package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `input` package has a dependency on the `calculator` and `input`
    packages. As a result, the `input_test` package arranges the dependencies of the
    `input` package, which are provided by the `calculator` and `input` packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This section has given you an introduction to the Go module system and discussed
    how to place and name tests in the overall codebase. Now, let’s look at how to
    implement tests in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the testing package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard library provides the `testing` package, which contains the essentials
    we need for writing and running tests. In this section, we will explore how to
    use it and begin to apply it so that we can write tests for our simple terminal
    calculator example.
  prefs: []
  type: TYPE_NORMAL
- en: The testing package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `testing` package provides support for testing Go code. It must be imported
    by all test code as this is the way to interact with the test runner. At a glance,
    the `testing` package seems very simplistic, but it fits with Go’s language design.
    Packages should be small, focused, and have a limited number of dependencies.
    This should make them easy to test with a relatively simple testing library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the important types from the `testing` library that we will
    be using:'
  prefs: []
  type: TYPE_NORMAL
- en: '`testing.T`: All tests must use this type to interact with the test runner.
    It contains a method for declaring failing tests, skipping tests, and running
    tests in parallel. We will look at and begin to use these methods in this section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`testing.B`: Analogous to the test runner, this type is Go’s **benchmark**
    runner. It has the same methods for failing tests, skipping tests, and running
    benchmarks in parallel. Benchmarks are special kinds of tests that are used for
    verifying the performance of your code, as opposed to its functionality. We will
    explore benchmarks later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`testing.F`: This type is used to set up and run `testing.T` type to provide
    test-running functionality. Fuzz tests are special kinds of tests that use random
    inputs to find edge cases and bugs in our code. We will explore fuzz tests further
    in [*Chapter 10*](B18371_10.xhtml#_idTextAnchor218), *Testing* *Edge Cases*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The testing package is used in all tests
  prefs: []
  type: TYPE_NORMAL
- en: The `testing` package must be imported by all tests as it is the only way to
    interact with Go’s test runner. As previously discussed, test filenames must end
    with the `_test.go` suffix, but tests will only be run if they use the `testing`
    package. Tests must also satisfy a standard test signature, which is explained
    in the next section, *Working with the* *testing package*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s have a look at the `testing.T` type in a little bit more detail since
    it will be the focus of our exploration in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.5* presents a summary of some of the methods we will discuss:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – The logging, failing, and skipping methods of the testing.T
    type ](img/Figure_2.05_B18371.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – The logging, failing, and skipping methods of the testing.T type
  prefs: []
  type: TYPE_NORMAL
- en: 'It exposes the following methods for logging, skipping, and failing tests that
    are important to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '`t.Log(args)`: This prints the given arguments to the error log after the test
    has finished executing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`t.Logf(format, args)`: This has the same functionality as the `t.Log` method,
    but allows the arguments to be formatted before printing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`t.Fail()`: This marks the current test as failed but continues execution until
    the end.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`t.FailNow()`: This marks the current test as failed and immediately stops
    the execution of the current test. The next test will be run while continuing
    the suite.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`t.Error(args)`: This is equivalent to calling `t.Log(args)` and `t.Fail()`.
    This method makes it convenient to log an error to the error log and mark the
    current test as failed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`t.Errorf(format, args)`: This is equivalent to calling `t.Logf(format, args)`
    and `t.Fail()`. This method makes it convenient to fail a test, then format and
    print an error line in one call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`t.Fatal(args)`: This is equivalent to calling `t.Log(args)` and `t.FailNow()`.
    This method makes it convenient to fail a test and print an error line in one
    call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`t.Fatalf(format, args)`: This is equivalent to calling `t.Logf(format, args)`
    and `t.FailNow()`. This method makes it convenient to fail a test, then format
    and print an error line in one method call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`t.SkipNow()`: This marks the current test as skipped and immediately stops
    its execution. Note that if the test has already been marked as failed, then it
    remains failed, not skipped.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`t.Skip(args)`: This is equivalent to calling `t.Log(args)`, followed by `t.SkipNow()`.
    This method makes it convenient to skip a test and print an error line in one
    call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T.Skipf(format, args)`: This is equivalent to calling `t.Logf(format, args)`,
    followed by `t.SkipNow()`. This method makes it convenient to skip a test, then
    format and print an error line in one call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, developers use the convenience methods presented previously when
    writing their tests, as opposed to invoking `t.Fail()`, `t.FailNow()`, or `t.SkipNow()`
    explicitly. Going forward, we will make use of them as we begin to write our test
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing you might be wondering about is whether the `testing` package
    provides any assertion functionality. It does not provide any inbuilt assertions,
    so we will need to compare values ourselves. We will explore third-party assertion
    libraries further in [*Chapter 3*](B18371_03.xhtml#_idTextAnchor061), *Mocking
    and* *Assertion Frameworks*.
  prefs: []
  type: TYPE_NORMAL
- en: Test signatures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `testing` package is used for writing unit tests, which are placed in their
    own test files. Go tests are functions that satisfy the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This test signature highlights the following requirements for Go tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Tests are exported functions whose name begins with `Test`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test names can have an additional suffix that specifies what the test is covering.
    The suffix must also begin with a capital letter, as we can see specified by `Name`
    in the test signature, which doubles as the test name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests must take in a single parameter of the `*testing.T` type. As we’ve explained
    so far, this will be how the test interacts with the test runner. You can name
    the testing parameter however you want, but Go developers typically use `t` to
    denote it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests must not have a return type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go tests are just functions
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, tests are simply functions that satisfy a certain signature.
    The Go test tool scans the code base for these special functions in the `_test.go`
    files and runs them accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Inside these test functions, we can define and implement our test code using
    the AAA pattern. You should keep the scope of your test small, preferring to write
    several tests rather than writing one large, potentially brittle test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like package names, test names are very important, so we need to give
    them some special consideration. Having effectively named tests can bring developers
    some important advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Documentation and understanding**: A suite of effectively named tests will
    help newcomers understand how a particular piece of code is supposed to work.
    As they are easy to change, they also allow you to explore the behavior of the
    code under a variety of conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Refactoring support**: The test name sets the intention of the test; then,
    its implementation simply executes it. Once the code has been refactored, the
    test implementation may change, but the intention of the test, conveyed by its
    name, remains. Well-named tests can support code refactoring, which might need
    to change the test implementation/execution. We will discuss code refactoring
    strategies further in [*Chapter 7*](B18371_07.xhtml#_idTextAnchor162), *Refactoring*
    *in Go*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency**: Setting a standard for how tests should be named and structured
    throughout your code base will make it easier for you to know what to expect,
    reducing cognitive load when reading code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other than the special signature we’ve just seen, Go does not enforce any other
    naming standards. The consensus in the Go community is that they should be easily
    understood and concise. The Go standard library ties tests with the name of the
    function that they test: the UUT. The test name simply follows the `TestUnitUnderTest`
    structure. For example, a test for the `Add` function will be named `TestAdd`.'
  prefs: []
  type: TYPE_NORMAL
- en: Another common approach is to name the tests using a **Behavior-Driven Development**
    (**BDD**) style approach. We will explore BDD tests in detail in [*Chapter 5*](B18371_05.xhtml#_idTextAnchor124),
    *Performing* *Integration Testing*.
  prefs: []
  type: TYPE_NORMAL
- en: In this naming approach, the name of the test follows the structure of `TestUnitUnderTest_PreconditionsOrInputs_ExpectedOutput`.
    For example, a test for the function will be named `TestAdd_TwoNegativeNumbers_NegativeResults`
    if it tests adding two negative numbers together.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the BDD style naming pattern is a lot more precise, it goes against the
    principle of simplicity and conciseness that is so central to Go. We will use
    the simpler approach: naming the test after its UUT. We will see how we can achieve
    the extra precision of preconditions and expected output using subtests later
    in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Running tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the commands of the Go toolchain is the `go test` command. We’ve previously
    mentioned that it is Go’s test runner and that we will use it to execute tests.
    We’ll look at how to use it in more detail in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `_test.go` files, the test runner will treat three kinds of functions
    especially:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Test`. We have covered test functions at length in this section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Benchmark`. We will cover these in the *Difference between a test and a benchmark*
    section of this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Example`. These are outside the scope of our discussion in this book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test runner will look for files that end in `_test.go`, build them into
    their own packages, and then link them in the test binary.
  prefs: []
  type: TYPE_NORMAL
- en: The output of the `go test` command will print out all the test failures of
    the executed tests to the standard output. You can add a `–v` flag, which is short
    for verbose, to get it to print the name and execution time of all tests, including
    passed tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tests are executed and output in lexicographic order. Here is the output from
    our `engine_test.go`, which contains tests for the operations of the calculator,
    implemented in `engine.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Test failures are marked in the output with the `FAIL` keyword and any error
    messages are printed to the standard output. In our example, we have a failing
    test: `TestAdd`. As we saw in the previous section, we can print informative error
    messages and fail tests using a variety of methods from the `testing.T` type,
    which we have access to in all tests from the parameter of the test signature.'
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the test output, we can see the outcome of the entire test run,
    as well as the time it took to run. We can also see the running time for each
    test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test runner supports two running modes:'
  prefs: []
  type: TYPE_NORMAL
- en: When the command has no package specifications, it will build and run all tests
    in the current directory. This is known as `go` `test –v`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the command has package specifications, it will build and run all tests
    matching the specific package arguments. This is known as **package list mode**.
    Developers usually run their tests in this mode for large projects as it can be
    cumbersome to change between directories and run the tests in each of them using
    local directory mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can easily specify what tests to run by providing these properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`go test engine_test` will run the tests from the `engine_test` package from
    anywhere in the project directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go test ./...` will run all the tests in the project, regardless of where
    it’s being run from.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go test ./chapter02` will run all the tests in the `chapter02` subdirectory
    of the current path, but will not traverse to further nested directories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`–run``go test –run "^engine"` will run all packages that begin with the word
    `engine`. A subdirectory path can also be provided alongside the test name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`–run``go test –run TestAdd` will only the test specified. A subdirectory path
    can also be provided alongside the test name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Go test runner can cache successful test results to avoid wasting resources
    by rerunning tests on code that has not changed. Being able to cache successful
    test results is disabled by default when running in local directory mode, but
    enabled in package list mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the output of the `go test –v ./...` command, which triggers
    package list mode, will mark the cached results with `(cached)` on their corresponding
    output line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that only successful test runs can be cached. Test failures will be run
    every time until they pass, at which point they can be cached.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have examined the structure of packages, where test files fit into
    their structure, as well as become acquainted with Go’s testing package and test
    signatures. Now, let’s take everything we have learned and begin applying it.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the knowledge we have of how to test code works in Go, we can expand on
    the **red, green, refactor** approach with more specific steps. *Figure 2**.6*
    shows the expanded flow of TDD in Go for new functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Expanded TDD flow in Go ](img/Figure_2.06_B18371.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Expanded TDD flow in Go
  prefs: []
  type: TYPE_NORMAL
- en: 'We can describe the test writing process with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_test.go` file corresponding to the test that you will be implementing in
    this new directory. This will ensure that you have a place to begin writing test
    code alongside implementation code. As previously mentioned, while Go does not
    enforce the usage of the external test package, you should use one whenever possible.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`.go` files are immediately compiled. At this point, you will begin reflecting
    on the structure of your code, as we did with the simple terminal calculator at
    the beginning of this chapter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Write the test signature for the new functionality**: While in the test file,
    you can create the new test, named after the UUT you will be testing. The test
    signature will also require you to import the testing package, getting you ready
    to write your test code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Write the definitions of your UUT**: Inside your previously empty source
    file, write the definitions for the custom types, methods, and functions that
    you intend to test. This will allow you to settle on the signatures or API of
    your UUT, then structure your test accordingly. As we did in the simple terminal
    calculator, return empty or zero values according to the signature of your methods
    to ensure your code compiles.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Set up your test scenario**: Starting with the simplest test cases first,
    write your test using the AAA approach, invoking the previously defined signatures
    of your UUT. This is the reason we created the signatures and returned dummy values
    for the code to compile.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`go test` command in the directory of your new package.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Implement the functionality required by your test scenario**: Going back
    to your UUT, write just enough code to satisfy your newest test scenario. This
    will require changing some of your dummy code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`go test` command. Your new test should now pass.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Refactor your newest test and code**: Look for any improvements you can make
    to your source and test code. Improvements should be frequent and small, so make
    sure to take the time to review your code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Run your test to see it pass**: Your new test should continue to pass after
    this refactoring.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat all of these steps as many times as required until all the functionality
    is implemented. You will define your UUT signatures and tests as required, starting
    from the simplest functionality and working forward.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As expected, the TDD process requires frequent changes between the source and
    test code. Test runs should always fail first, then pass as we implement and refactor
    the source code.
  prefs: []
  type: TYPE_NORMAL
- en: Use case – implementing the calculator engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s use our established working practice to write and implement the functionality
    of the calculator that we will define in `engine.go`. This will also give us some
    hands-on experience with the `testing` package.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – creating the test file and test package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we saw in *Figure 2**.2*, we will create a directory named `calculator` where
    we will place the corresponding calculator engine files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create the `engine_test.go` test file and declare the external `calculator_test`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the test file only contains a single line, and there are no compile
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – creating the source code file and package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the same directory, we must create the `engine.go` file and declare the
    calculator package, which matches the already declared external test package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the source code file also contains a single line and there are
    no compile errors.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – writing the test signature for the new functionality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will begin by testing and implementing the calculator addition functionality,
    as that is the simplest function. In the `engine_test.go` file, add a new test
    corresponding to the Go test signature and import the `testing` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As its name and package indicate, we will be testing the `Add` function or method
    of the `calculator` package. With just these few lines of code, we already have
    a decent indication of what this test will cover. This is a very powerful mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 – writing the definitions of your UUT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here, we will add stubbed definitions of the UUT to the source file so that
    we can invoke them in our newly written code. While this is a small departure
    from writing no code that does not have corresponding test code, it will make
    it easier for us to reference the code in test code from any code editor. In the
    `engine.go` file, we must add stubs for the `Engine` custom type and the `Add`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We return a dummy value of `0` to ensure that the code continues to compile.
  prefs: []
  type: TYPE_NORMAL
- en: Step 5 – setting up your test scenario
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Going back to the test code, we will add a simple test scenario to the `TestAdd`
    function, which is currently empty. In the `engine_test.go` file, we will add
    testing code that was written using the AAA pattern, as indicated by the comments
    corresponding with each step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the Arrange step, `TestAdd` creates an instance of `calculator.Engine`, which
    requires the calculator package to be imported inside the test file.
  prefs: []
  type: TYPE_NORMAL
- en: In the Act step, we invoke the `Add` method on the created `Engine` instance
    and pass it the two inputs that we will be using in this step.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the Assert step, we compare the actual and expected values in an
    `if` statement and call for the test failure using `t.Errorf` if they do not match.
  prefs: []
  type: TYPE_NORMAL
- en: Step 6 – running your test to see if it fails
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Starting with a failing test is very important to the TDD philosophy since
    it ensures that our test is actually being run and does not pass falsely. We can
    run our test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The test fails and our informative error message is printed out to the terminal.
    The test is expected to fail since our method is currently only returning the
    dummy value. With that, we have completed the **red** phase of the red, green,
    refactor approach.
  prefs: []
  type: TYPE_NORMAL
- en: Step 7 – implementing the functionality required by your test scenario
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the failing `TestAdd` in place, it’s time to implement the functionality
    required to make it pass. In the `engine.go` file, we must change the `Add` method
    to remove the dummy value return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `Add` method will now use the input parameters and return their addition
    result.
  prefs: []
  type: TYPE_NORMAL
- en: Step 8 – running your test to see if it passes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Exactly like in *Step 6 – running your test to see if it fails*, we will run
    the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The test is now passing and we have verified that our code satisfies the test
    requirements. With that, we have completed the **green** phase of the red, green,
    refactor approach.
  prefs: []
  type: TYPE_NORMAL
- en: Step 9 – refactoring your newest test and code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This step is not guaranteed to take place. We can improve our test code by
    extracting variables that allow us to clean up the test code, removing the need
    for us to repeat hardcoded values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the Arrange section, we now declare three variables for our inputs and expected
    output. We make use of these variables throughout the test, passing them to the
    UUT as well as to the formatted error message.
  prefs: []
  type: TYPE_NORMAL
- en: Step 10 – re-running your test to see if it passes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Exactly like in *Step 8 – running your test to see if it passes*, we must run
    the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The test is now passing and we have verified that our refactoring has not broken
    any implemented functionality. With that, we have completed the **refactor** phase
    of the red, green, refactor approach.
  prefs: []
  type: TYPE_NORMAL
- en: These steps can now be repeated for all the other operations of the simple terminal
    calculator. You can go ahead and implement them, which will allow you to practice
    using TDD in Go. Next, we’ll explore how to streamline our test writing processing
    using test setup and teardown.
  prefs: []
  type: TYPE_NORMAL
- en: Test setup and teardown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve written our first example of a test and source code by leveraging an external
    test package and the `testing.T` type. This has worked very well for our simple
    example, but, as we begin to ramp up and write more tests, it can be cumbersome
    to continue repeating the same test setup and cleanup. In this section, we will
    explore what functionality the `testing` package offers to streamline this process
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: The TestMain approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`TestMain`. This is a feature that is often underutilized, but it gives us
    great flexibility when it comes to setup and teardown code. The signature of this
    test is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Unlike other tests, the name of this test is fixed and it takes in the `*testing.M`
    type as its only parameter, as opposed to `*testing.T` as other tests do. Once
    you override it, the code in this method will give you more control over how your
    tests run. The `TestMain` method will be run before any of the other tests in
    this package.
  prefs: []
  type: TYPE_NORMAL
- en: One TestMain function per package
  prefs: []
  type: TYPE_NORMAL
- en: As names need to be unique inside a package, you will only be able to define
    one `TestMain` function per package. You should be mindful that this method will
    control how all the tests inside the given package run, not just those in the
    given file.
  prefs: []
  type: TYPE_NORMAL
- en: The `testing.M` type is much smaller than the `testing.T` type and exposes a
    method called `Run()`, which allows us to run the tests in the given package and
    returns an exit code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The usage of this function is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code sample outlines a simple recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TestMain` **signature**: Write the correct name and signature of the test
    in your test file. In general, you should place this definition as high up at
    the beginning of the file as possible.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`setup()` function and calling that instead of writing the code directly into
    your test function. This will help with the readability of your test file. All
    of these statements will run before your tests are executed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Run()``m.` `Run()` and save the exit value returned from this function inside
    a variable, named `e` in our code sample. It is at this point that the tests will
    run and the exit value will report whether your tests have failed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Run()` method. I also recommend creating a separate function named `teardown`,
    as opposed to writing the code directly into your `TestMain` code block. All of
    these statements will run after your tests are executed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`os.Exit` function. If you forget to add this part of the main function, you
    might get false positives reported to your test runner.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We implement the same recipe in our calculator example, defining the `TestMain`
    function alongside `TestAdd` in the `engine_test.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setup()` and `teardown()` functions simply print two lines to the Terminal.
    Running the test shows us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the test output, the setup and teardown log lines are printed
    around the test run output, before and after.
  prefs: []
  type: TYPE_NORMAL
- en: init functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second option you have available to ensure that the test setup runs correctly
    is to use `init` functions. It is often the case with unit tests that no teardown
    logic is required, only setup logic. In these cases, where you simply want to
    ensure that some logic is run before the tests, you might want to opt for a less
    cumbersome approach than `TestMain`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the `TestMain` approach, the `init` functions are not specifically restricted
    to test code. The signature of the `init` function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The name of the `init` function is fixed and it takes no parameters. This function
    will be called before any main function, regardless of whether that main function
    is in the source code or the special test runner main function.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple init functions per package
  prefs: []
  type: TYPE_NORMAL
- en: Unlike other names, multiple `init` functions are allowed per package. However,
    you should be mindful that they will all be called before the main runner. When
    multiple `init` functions are defined in the same file, they are run in definition
    order. On the other hand, when they are defined in multiple files, they are run
    in the lexicographic order of their filenames.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will define an `init` function, alongside `TestMain` and `TestAdd`, in the
    `engine_test.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `init()` function simply prints another line to the Terminal. Running the
    test shows us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the test run output, the `init` setup is run before the `TestMain`
    setup. The logline defined in the `init` function is printed before any other
    code is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Deferred functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can make use of `init` functions, this is a construct that does not only
    exist in test code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Go, deferred functions are declared using the `defer` statement. Once this
    is applied to a function call, the function will only be executed once the surrounding
    function call has been completed, either successfully or using a panic. For example,
    we can defer the teardown function like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Deferred function definitions
  prefs: []
  type: TYPE_NORMAL
- en: We can apply the `defer` statement to named functions or **anonymous functions**
    defined inline. It is Go convention to define your deferred functions at the top
    of the enclosing function. This will ensure that the function will be deferred
    before any errors can occur and stop the deferral.
  prefs: []
  type: TYPE_NORMAL
- en: The approaches we’ve seen so far are made up of Go’s language constructs, but
    they can be cumbersome to keep defining and have the disadvantage of creating
    package-level changes. Deferred functions give us fine-grained control, making
    changes only to the test where they are invoked. However, the disadvantages are
    that we need to remember to add them to each test and that we can only use this
    approach for teardown, not setup logic. You should weigh the advantages and disadvantages
    of each mechanism as you begin to write more tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify the `TestAdd` function in the `engine_test.go` file to add a deferred
    function, leaving the `TestMain` and `init` functions already defined in this
    test file unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The deferred function simply prints out another log line to the Terminal. Running
    the test shows us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the test run output, the deferred teardown call is executed
    before the `TestMain` function’s teardown step. This is expected due to the invocation
    order of deferred functions.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.7* depicts a summary of the order in which all the setup and teardown
    mechanisms we’ve looked at will execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Summary of the order of setup and teardown mechanisms ](img/Figure_2.07_B18371.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Summary of the order of setup and teardown mechanisms
  prefs: []
  type: TYPE_NORMAL
- en: 'The order verifies what we’ve seen with our terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: The tests kick off with the `go test` command, as we’ve become used to running
    them so far.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `init` functions execute before the temporary main program of the tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the tests are ready to execute, the `TestMain` function starts and its
    setup functions execute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The tests are then run by invoking `m.Run()` from `TestMain`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once all the tests have been run, the deferred functions defined inside the
    scope of the tests are executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the tests and their functions exit, the `TestMain` function’s teardown
    function is executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the tests end with the exit value returned from the call to `m.Run()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we begin to consider writing tests on a larger scale, we will also need a
    way to separate tests according to a smaller test scope and different scenarios.
    In the next section, we’ll see how to achieve that using **subtests**.
  prefs: []
  type: TYPE_NORMAL
- en: Operating with subtests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In TDD, the test scope should be small, and the outcome should be easy to understand.
    We explored TDD best practices in [*Chapter 1*](B18371_01.xhtml#_idTextAnchor015),
    *Getting to Grips with Test-Driven Development*. To achieve these best practices,
    we need separation between test scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the example of the `TestAdd` function that we have worked with
    so far. It currently tests adding two positive numbers, but we will extend it
    to cover negative inputs. With the knowledge we have so far, we have two options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TestAdd` **to verify the new scenario**: This approach will make the Assert
    step longer, but it has the advantage of reusing the previous steps.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`TestAdd` as is, but it has the disadvantage of us having to redefine and re-execute
    the Arrange and Act steps of the existing test.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we choose to go with the second option, we will have to name the new test
    something different. We will name it `TestAdd_Negative` to signify that we will
    be testing negative inputs in this test. However, this doesn’t fall in line with
    the naming of the existing `TestAdd` function, so we will have to rename the existing
    test to `TestAdd_Positive`. As expected, running the tests will output the result
    on different lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We want to have a small self-contained test, but it would be cumbersome to continue
    to define new tests, potentially having to change the name of existing tests for
    each new edge case or scenario we test. Go provides us with a more elegant solution
    to this common problem, which we will cover in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing subtests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `testing.T` type provides the `Run(name string, f func(t *testing.T)) bool`
    method, which takes in two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: A name parameter of the `string` type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function that takes in a single parameter of the `*``testing.T` type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once passed to the `Run` method, the test runner will run the function as a
    subtest of the current tests, allowing us to create a test hierarchy, each with
    its own separation. Since the enclosing test and the subtests share the same instance
    of `testing.T`, a subtest failure will cause the enclosing test to fail as well.
    This behavior gives us the ability to create multi-layered test hierarchies according
    to our needs. Taking the example of adding positive and negative inputs as test
    scenarios, we can refactor `TestAdd` to take advantage of the power of subtests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We create an `actAssert` function that takes in the inputs and expected output
    as parameters. This function will perform the Act and Assert steps without having
    to repeat them. Then, we create two subtests using the `t.Run` method we’ve seen
    before. The name of each subtest indicates what scenario it will cover. Running
    the tests will produce the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the output, the subtests are nested under the enclosing test.
    By leveraging subtests, we now have a convenient way to create tests that share
    the Arrange step, but can also be easily extended with more scenarios without
    the need to rename tests.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss the related technique of **table-driven testing**, which leverages
    the power of subtests, in [*Chapter 4*](B18371_04.xhtml#_idTextAnchor085), *Building
    Efficient* *Test Suites*.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know how to write tests that cover different scenarios and how to
    run them, we can have a look at what our **code coverage** is. As we remember
    from [*Chapter 1*](B18371_01.xhtml#_idTextAnchor015), *Getting to Grips with Test-Driven
    Development*, this important metric measures what percentage of your code is exercised
    by tests.
  prefs: []
  type: TYPE_NORMAL
- en: The `go test` command has a `–cover` flag, which computes the code coverage
    profile of the given package. It also offers the possibility of saving the profile
    to a file by passing a file path to the `-coverprofile` flag. We will then see
    how to view these saved coverage profiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run it for our calculator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This command prints out the coverage percentage after running all the tests.
    We are currently measuring coverage of 100% since our `Add` function is very simple.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s save the code coverage profile to a file using `go test ./chapter02/calculator
    -coverprofile=calcCover.out`. This will create the `calcCover.out` file in the
    current directory. We can view this file visually using another tool in the Go
    toolchain. Running `go tool cover -html=calcCover.out` will open a new window
    in your browser to display the coverage profile visually.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.8* shows the visual representation of our cover profile, which
    shows that the `Add` method is covered by tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – The visual representation of the saved profile ](img/Figure_2.08_B18371.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – The visual representation of the saved profile
  prefs: []
  type: TYPE_NORMAL
- en: That covers all the essentials we need to know to begin writing Go tests with
    TDD. The last thing we need to tackle is how to write and use benchmarks.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between a test and a benchmark
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last concept we will be looking at in this chapter is `testing.B` type.
    They have a signature very similar to tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The signature highlights the following requirements for Go benchmarks:'
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarks are exported functions whose name begins with `Benchmark`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benchmark names can have an additional suffix that specifies what the test is
    covering. The suffix must also begin with a capital letter, as we can see with
    `Name`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benchmarks must take in a single parameter of the `*testing.B` type. As we’ve
    explained so far, this will be how the test interacts with the test runner. You
    can name the testing parameter however you want, but Go developers typically use
    `b` to denote it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benchmarks must not have a return type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benchmarks are an important Go profiling tool
  prefs: []
  type: TYPE_NORMAL
- en: Tests verify the functionality of your programs, while benchmarks verify the
    performance of your code. You should use both in your testing strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Benchmarks can also be run with the `go test` command, but we have to specify
    to the runner that we are interested in benchmarks with the `–bench` flag. We
    must supply a regular expression that matches the packages that we want to run.
    We can run all benchmarks by matching all packages in the current directory using
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `testing.B` type also has access to logging errors and signaling test failures,
    just as we saw in the introduction to the `testing.T` type: `b.Error`, `b.Errorf`,
    `b.Fatal`, and `b.Fatalf`. Just like tests, benchmarks live in test files, which
    must have the `_test.go` suffix to be detected by the Go test runner.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write a benchmark for our `Add` function in the `engine_test.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `BenchmarkAdd` example runs the `Add` function with the parameters in a
    loop for `b.N` times. Go’s test runner controls the value of `N` and will increase
    it until it is satisfied that the numbers it has measured are stable.
  prefs: []
  type: TYPE_NORMAL
- en: As with all performance tests, you should be wary of running benchmarks on your
    local machine. You might measure some large variations in measurement according
    to what your computer is processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we run our benchmark to see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the benchmark run highlights the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The name of the benchmark: `BenchmarkAdd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The number of CPU cores used to run the benchmark, added as a suffix to the
    test name: `8`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How many times the benchmark was executed: `1000000000`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The average amount of time that an individual test iteration took, measured
    in nanoseconds: `0.2684 ns/op`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our function is very simple, which is why it has a very low running time. We
    will explore more complex examples of benchmarks in [*Chapter 8*](B18371_08.xhtml#_idTextAnchor179),
    *Testing* *Microservice Architectures*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered all the unit testing essentials that we will need
    to get started with TDD in Go. We began by introducing Go modules and packages,
    as well as where test files are placed and how they declare their additional test
    packages. You learned about the most important methods in Go’s `testing` package
    and started writing some simple unit tests with it. Then, we explored ways to
    reduce code duplication by making use of setup and teardown functions, as well
    as how to better organize tests using subtests. Finally, we learned how to write
    and run benchmarks, which are an important part of any testing strategy.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B18371_03.xhtml#_idTextAnchor061), *Mocking and Assertion Frameworks*,
    we will write more complicated tests, which require dependencies. We will explore
    some popular frameworks and begin to use them to write tests that are closer to
    real-world examples.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: In Go, what is the difference between a module and a package?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the additional test package? What are some of the advantages of using
    it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the requirements for the test signature?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are subtests and how do you create them?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a benchmark? How do you write one?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: The official documentation for the testing package is available at [https://pkg.go.dev/testing](https://pkg.go.dev/testing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Art of Unit Testing*, by Roy Osherove, published by Manning Publications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Profiling Go Programs* is available on the Go blog at [https://go.dev/blog/pprof](https://go.dev/blog/pprof)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
