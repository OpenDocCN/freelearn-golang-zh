- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Unit Testing Essentials
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试要素
- en: In the previous chapter, we learned all about the iterative process of writing
    tests alongside code using TDD, as well as how it fits into the **Agile project
    methodology**. We covered the **red, green, refactor approach**, which requires
    frequent switching between source code and test code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了使用TDD编写测试与代码的迭代过程，以及它如何适应**敏捷项目管理方法**。我们介绍了**红、绿、重构方法**，它要求频繁地在源代码和测试代码之间切换。
- en: When first starting with TDD, following a prescribed process for writing code
    may seem like an artificial way of working, but it soon becomes second nature
    with practice. In this chapter, we will learn all the Go fundamentals required
    to begin putting everything else we have learned to use. We will begin to write
    unit tests with Go’s `testing` package, focusing on the test writing syntax and
    process. This chapter will allow us to get hands-on experience with all the concepts
    we have explored so far.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当刚开始使用TDD时，遵循编写代码的既定流程可能看起来像是一种人为的工作方式，但随着实践，它很快就会变得自然而然。在本章中，我们将学习所有必要的Go基础知识，以便开始将我们所学的一切应用到实践中。我们将开始使用Go的`testing`包编写单元测试，重点关注测试编写语法和过程。本章将使我们能够亲身体验到目前为止所探索的所有概念。
- en: As we saw from the **testing pyramid** in [*Chapter 1*](B18371_01.xhtml#_idTextAnchor015),
    *Getting to Grips with Test-Driven Development*, **unit tests** are the most numerous.
    They are used to verify the functionality of a single unit, in isolation. We will
    begin our exploration of TDD and Go testing by implementing unit tests.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第一章*](B18371_01.xhtml#_idTextAnchor015)“掌握测试驱动开发”中看到的**测试金字塔**，**单元测试**是最多的。它们用于验证单个单元的功能，在隔离状态下。我们将通过实现单元测试来开始我们对TDD和Go测试的探索。
- en: The Go programming language was created by the team at Google to allow developers
    to write simple and efficient software, which they felt was not achievable with
    the tools they had available at the time. This principle of simplicity is echoed
    throughout the entire language, including its test writing and running functionality.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Go编程语言是由谷歌团队创建的，旨在让开发者能够编写简单而高效的软件，他们认为在当时他们所拥有的工具无法实现这一点。这种简洁的原则贯穿于整个语言，包括其测试编写和运行功能。
- en: The Go standard library provides the `testing` package, which provides the essentials
    we need for writing automated tests. Tests are simply functions that satisfy certain
    conventions and signatures, making it easier for developers to write code using
    the same strategies and mechanisms as they write their source code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准库提供了`testing`包，它为我们编写自动化测试提供了必需的功能。测试只是满足某些约定和签名的函数，这使得开发者能够使用与编写源代码相同的策略和机制来编写代码。
- en: The Go toolchain provides a single `go test` command for running all the tests
    that we have defined. This simple yet powerful command also provides functionality
    for running benchmarks, which we can use to examine the performance of a given
    component.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Go工具链提供了一个单一的`go test`命令来运行我们定义的所有测试。这个简单而强大的命令还提供了运行基准测试的功能，我们可以用它来检查给定组件的性能。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: The Go package as the **Unit Under** **Test** (**UUT**)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为**被测试单元**（**UUT**）的Go包
- en: The fundamentals of working with Go’s testing package
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Go测试包的基本原理
- en: Test setup and teardown
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试设置和清理
- en: Grouping tests into suites with subtests
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将测试分组为包含子测试的套件
- en: The difference between a test and a benchmark
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试与基准测试之间的区别
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need to have **Go version 1.19** or later installed to run the code
    samples in this chapter. The installation process is described in the official
    Go documentation at [https://go.dev/doc/install](https://go.dev/doc/install).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装**Go版本1.19**或更高版本才能运行本章中的代码示例。安装过程在官方Go文档[https://go.dev/doc/install](https://go.dev/doc/install)中有描述。
- en: The code examples included in this book are publicly available at [https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter02](https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter02).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本书包含的代码示例在[https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter02](https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter02)上公开提供。
- en: The unit under test
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 被测试单元
- en: In [*Chapter 1*](B18371_01.xhtml#_idTextAnchor015), *Getting to Grips with Test-Driven
    Development*, we discussed the structure of tests using the **Arrange-Act-Assert**
    (**AAA**) pattern. We also briefly mentioned that the Arrange step sets up the
    **Unit Under Test** (**UUT**) and its dependencies. The test then exercises and
    verifies the functionality of the UUT.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](B18371_01.xhtml#_idTextAnchor015)《掌握测试驱动开发》中，我们讨论了使用**安排-行动-断言**（**AAA**）模式测试的结构。我们还简要提到了安排步骤设置了**被测试单元**（**UUT**）及其依赖项。然后测试会执行并验证UUT的功能。
- en: In Go, source code is organized into packages and modules. We will begin by
    exploring what these are and how they work and then look at how test files fit
    into this structure. A solid understanding of the power of packages will set the
    scene for us to begin considering not only *how* to write tests, but *what* to
    test.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，源代码被组织成包和模块。我们将首先探讨这些是什么以及它们是如何工作的，然后看看测试文件如何融入这个结构。对包的强大功能的深入了解将为我们考虑不仅*如何*编写测试，还要*测试什么*奠定基础。
- en: Modules and packages
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块和包
- en: If you have worked with Go for a while, you might be familiar with Go’s **module
    system**, which was introduced as the default dependency management solution in
    **Go 1.13**. The latest Go version at the time of writing is **version 1.19**,
    so the module system has been the standard solution for some time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经使用Go有一段时间了，你可能熟悉Go的**模块系统**，该系统在**Go 1.13**中被引入作为默认的依赖管理解决方案。撰写本文时的最新Go版本是**版本1.19**，因此模块系统已经是一段时间的标准解决方案了。
- en: Modules
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块
- en: A **module** is a collection of packages that are distributed and released together.
    The name of the module should be representative of its functionality, as well
    as where to find it. The Go toolchain provides support for popular code hosting
    solutions such as GitHub and Bitbucket and can issue the correct requests for
    downloading dependencies from their version control systems.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块**是一组一起分发和发布的包。模块的名称应该代表其功能，以及在哪里可以找到它。Go工具链为GitHub和Bitbucket等流行的代码托管解决方案提供支持，并可以发出从它们的版本控制系统下载依赖项的正确请求。'
- en: 'Modules are declared by placing a `go.mod` file at the root of the project
    directory. A new module can be initialized by running the `go mod init` command
    with a module path as a parameter. We can initialize the module for all our code
    examples by running the following command in the Terminal:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 模块通过在项目目录的根目录放置一个`go.mod`文件来声明。可以通过运行带有模块路径参数的`go mod init`命令来初始化一个新的模块。我们可以通过在终端中运行以下命令来初始化所有代码示例的模块：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The module path we have provided is the same as the GitHub repository path.
    The generated file only contains two lines – one for the module path and one for
    the version of Go required:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供的模块路径与GitHub仓库路径相同。生成的文件只包含两行——一行是模块路径，另一行是所需的Go版本：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In general, the `go.mod` file contains these properties:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`go.mod`文件包含以下属性：
- en: The module path
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块路径
- en: The version of Go required for the project
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目所需的Go版本
- en: Any external dependencies that need to be imported when building the project
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建项目时需要导入的任何外部依赖项
- en: Since our project is empty for now, our module’s file does not specify any external
    dependencies. The packages of the standard library do not need to be declared
    as dependencies. This file will be automatically updated with dependencies once
    they are used in the source code of the module.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的项目目前是空的，我们的模块文件没有指定任何外部依赖。标准库的包不需要声明为依赖项。一旦在模块的源代码中使用，此文件将自动更新依赖项。
- en: The generated go.mod file
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的go.mod文件
- en: The `go.mod` file is generated, but not read-only. However, as a rule of thumb,
    you should avoid editing the `go.mod` file manually. In general, developers edit
    it only to change version numbers, not to manually change its entries. You can
    also recreate it any time with the `go mod` `init` command.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`go.mod`文件是自动生成的，但不是只读的。然而，作为一个经验法则，你应该避免手动编辑`go.mod`文件。通常，开发者只编辑它来更改版本号，而不是手动更改其条目。你也可以随时使用`go
    mod init`命令重新创建它。'
- en: Packages
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包
- en: While modules are a fantastic way to bundle and release projects, most production
    systems would be almost impossible to maintain or understand if they did not have
    any internal organization or hierarchy. This is where Go packages come in to help
    us provide this much-needed structure.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然模块是捆绑和发布项目的绝佳方式，但如果它们没有任何内部组织或层次结构，大多数生产系统几乎不可能维护或理解。这就是Go包发挥作用帮助我们提供这种急需的结构的地方。
- en: Go source code is organized into `package` keyword. All the names defined in
    the source file are then added to the declared package.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Go源代码组织到 `package` 关键字中。然后，源文件中定义的所有名称都添加到声明的包中。
- en: 'Looking back at the simple terminal calculator example from [*Chapter 1*](B18371_01.xhtml#_idTextAnchor015),
    *Getting to Grips with Test-Driven Development*, we can specify a package and
    source code structure for it, as seen in *Figure 2**.1*:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾简单终端计算器示例，见[*第1章*](B18371_01.xhtml#_idTextAnchor015)，“掌握测试驱动开发”，我们可以为它指定一个包和源代码结构，如图*2**.1*所示：
- en: '![Figure 2.1 – The module, packages, and source files of the simple Terminal
    calculator ](img/Figure_2.01_B18371.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 简单终端计算器的模块、包和源文件](img/Figure_2.01_B18371.jpg)'
- en: Figure 2.1 – The module, packages, and source files of the simple Terminal calculator
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 简单终端计算器的模块、包和源文件
- en: 'The module contains three packages, each containing specialized functionality:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 模块包含三个包，每个包都包含专门的功能：
- en: The `input` package contains an input parser and validation functionality. It
    has dependencies on the `calculator` and `format` packages.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`input` 包包含输入解析和验证功能。它依赖于 `calculator` 和 `format` 包。'
- en: The `calculator` package contains all the calculation engine logic, providing
    functionality for all the operations that the calculator provides. It has a dependency
    on the `format` package.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculator` 包包含所有计算引擎逻辑，为计算器提供的所有操作提供功能。它依赖于 `format` 包。'
- en: The `format` package contains formatting logic for results and errors. It has
    no dependencies on our existing packages.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format` 包包含结果和错误的格式化逻辑。它不依赖于我们现有的任何包。'
- en: Package naming is important
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 包命名很重要
- en: Package names should be representative of the functionality they provide so
    that other code may reference them. Package names should be short and descriptive.
    They should also be meaningful when used along with the names of the types and
    functions they provide.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 包名应该能够代表它们提供的功能，以便其他代码可以引用它们。包名应该简短且描述性强。当与它们提供的类型和函数名称一起使用时，它们也应该是有意义的。
- en: 'The `format` package is at the bottom of our package hierarchy, and we can
    begin by defining it and its result formatting capabilities immediately. Looking
    at the contents of its `result.go` source file, we can see its simple definition:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`format` 包位于我们的包层次结构的底部，我们可以立即定义它及其结果格式化功能。查看其 `result.go` 源文件的内容，我们可以看到其简单的定义：'
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This package defines a `Result` function that outputs a formatted string of
    the given expression and result. We added the return of an empty string to ensure
    the code compiles until we are ready to begin implementation with TDD. The `error.go`
    file is similarly defined and has been omitted for brevity.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此包定义了一个 `Result` 函数，该函数输出给定表达式的格式化字符串和结果。我们添加了返回空字符串，以确保代码在准备开始使用TDD进行实现之前可以编译。`error.go`
    文件以类似的方式定义，为了简洁起见，已省略。
- en: 'Looking at the calculator engine in more detail, the contents of the `engine.go`
    source file can begin like so:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细地查看计算器引擎，`engine.go` 源文件的内容可以开始如下：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We begin with the `package calculator` definition, adding the source file and
    all its definitions to the `calculator` package. Then, we create an `Engine` type
    that will contain all the dependencies of the calculator. After these few lines,
    we can begin to define methods for all the operations that the engine needs to
    provide. The `Add` method of the `Engine` type is an example of what the definition
    of the addition operation is.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `package calculator` 定义开始，将源文件及其所有定义添加到 `calculator` 包中。然后，我们创建一个 `Engine`
    类型，它将包含计算器的所有依赖项。在这些几行之后，我们可以开始定义引擎需要提供的所有操作的方法。`Engine` 类型的 `Add` 方法是加法操作定义的一个示例。
- en: Those of you who are eagle-eyed will notice that the types, methods, and functions
    have been defined with a capital letter. This makes them **exported names**.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 那些细心的读者会注意到类型、方法和函数都是以大写字母定义的。这使得它们成为**导出名称**。
- en: Visibility outside of the package
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 包外的可见性
- en: Only the exported names of a package are visible for usage outside of their
    defined package. Unlike other languages, there are no visibility modifiers in
    Go. In the code examples for the `format` and `calculator` packages, we need their
    functionality to be available outside of their respective packages, so this is
    why they have been exported and defined with a capital letter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 只有包导出的名称在定义的包外部可见。与其它语言不同，Go 中没有可见性修饰符。在 `format` 和 `calculator` 包的代码示例中，我们需要它们的功能在各自的包外部可用，这就是为什么它们被导出并且以大写字母定义的原因。
- en: A package can declare a dependency on another package by using the `import`
    keyword. We can then reference the variables, types, and functions of the imported
    package by qualifying them with the package name and the **dot** **operator**
    (**.**).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包可以通过使用 `import` 关键字声明对另一个包的依赖。然后我们可以通过使用包名和**点操作符**（**.**）来限定它们，从而引用导入包的变量、类型和函数。
- en: 'With some exceptions, there can only be one single package name per directory.
    The declaration of the new `input` package will also require the creation of a
    new directory. The declaration of `Parser`, which has a dependency on the `Engine`
    type, looks like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了某些例外情况，每个目录只能有一个单个包名。新 `input` 包的声明也将需要创建一个新的目录。具有对 `Engine` 类型依赖的 `Parser`
    的声明看起来如下：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`Parser` is declared as part of `package input`. The `Parser` type needs the
    functionality of the `Calculator` type, so it imports the `calculator` package.
    As mentioned, the reference to `calculator.Engine` is qualified using its provided
    package and the dot operator. This lets the compiler know that the type referenced
    is coming from an imported package, not the current package.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parser` 被声明为 `package input` 的一部分。`Parser` 类型需要 `Calculator` 类型的功能，因此它导入了
    `calculator` 包。如前所述，对 `calculator.Engine` 的引用是通过其提供的包和点操作符来限定的。这使编译器知道引用的类型来自导入的包，而不是当前包。'
- en: 'The highlighted import path consists of three parts:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的导入路径由三部分组成：
- en: 'The module that the package belongs to: [github.com/PacktPublishing/Test-Driven-Development-in-Go](http://github.com/PacktPublishing/Test-Driven-Development-in-Go)'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包所属的模块：[github.com/PacktPublishing/Test-Driven-Development-in-Go](http://github.com/PacktPublishing/Test-Driven-Development-in-Go)
- en: 'The sub-directory path from the root of the module: `chapter02`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从模块根目录开始的子目录路径：`chapter02`
- en: 'The name of the imported package: `calculator`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入包的名称：`calculator`
- en: The power of Go packages
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go 包的力量
- en: 'Packages are a powerful and central concept to Go. They allow developers to
    do the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 包是 Go 中的一个强大且核心的概念。它们允许开发者执行以下操作：
- en: '**Group components**: When named well, packages provide an easy way to understand,
    uniquely group, and document multiple components that share the same functionality.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分组组件**：当命名得当，包提供了一种简单的方法来理解、唯一分组和记录具有相同功能的多组件。'
- en: '**Encapsulate code**: Since only exported methods are visible to external code,
    packages are the most important encapsulation mechanism in Go. They give developers
    fine-grained control over exactly what is available for use outside of the package.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装代码**：由于只有导出方法对外部代码可见，因此包是 Go 中最重要的封装机制。它们为开发者提供了对包外部可用的精确控制。'
- en: '**Reuse code**: Packages provide modularity to our programs, allowing us to
    reuse code in multiple places by providing a way for users to import them. The
    ability to leverage code from outside the current module allows developers to
    share the same solutions, without reinventing the wheel.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重用代码**：包为我们提供了模块化，通过提供用户导入的方式，使我们能够在多个地方重用代码。利用当前模块外部的代码的能力允许开发者共享相同的解决方案，而不必重新发明轮子。'
- en: '**Easily manage dependencies**: Go’s module system follows **Semantic Versioning**
    (**SemVer**), which uses three primary numbers to manage imported dependencies:
    the major, the minor, and the patch version. This allows developers to pin dependencies
    to a certain version, as well as easily know when they need to upgrade to a newer
    version.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻松管理依赖项**：Go 的模块系统遵循**语义版本控制**（**SemVer**），它使用三个主要数字来管理导入的依赖项：主版本、次要版本和补丁版本。这允许开发者将依赖项固定到特定版本，并且可以轻松地知道何时需要升级到较新版本。'
- en: 'Now that we understand the fundamentals of modules and packages, let’s turn
    our attention toward where testing fits into the codebase and its packages. Notice
    that the methods of the `Engine` and `Parser` custom types do not have any code
    implemented yet: this is because TDD is all about writing tests first!'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了模块和包的基本原理，让我们将注意力转向测试在代码库及其包中的位置。请注意，`Engine`和`Parser`自定义类型的方法还没有实现任何代码：这是因为测试驱动开发（TDD）的全部内容就是先编写测试！
- en: Packages as APIs
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将包作为API
- en: Due to their encapsulation and modularity properties, packages enable developers
    to build and structure their code using similar techniques as when designing external
    APIs, by choosing the signatures and functions they want to provide to external
    users.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们的封装和模块化特性，包使得开发者能够使用与设计外部API时类似的技术来构建和结构化他们的代码，通过选择他们想要提供给外部用户的签名和函数。
- en: Test file naming and placement
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试文件命名和放置
- en: Unlike other programming languages, test files live alongside the source code
    in Go. All test files must end with the `_test.go` suffix. Go’s test runner scans
    the codebase for these test files and runs them accordingly. The test runner is
    part of the Go toolchain and can be invoked using the `go` `test` command.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他编程语言不同，在Go语言中，测试文件与源代码位于同一目录下。所有测试文件都必须以`_test.go`后缀结尾。Go的测试运行器会扫描代码库中的这些测试文件并相应地运行它们。测试运行器是Go工具链的一部分，可以通过`go
    test`命令调用。
- en: '*Figure 2**.2* presents the directory structure of the simple terminal calculator
    discussed so far:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.2* 展示了迄今为止讨论的简单终端计算器的目录结构：'
- en: '![Figure 2.2 – The directory structure of the simple Terminal calculator ](img/Figure_2.02_B18371.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 简单终端计算器的目录结构](img/Figure_2.02_B18371.jpg)'
- en: Figure 2.2 – The directory structure of the simple Terminal calculator
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 简单终端计算器的目录结构
- en: All the code that we will be discussing in this chapter can be found in the
    `chapter02` directory of the dedicated repository corresponding to this book.
    Then, inside this directory, we have three further directories for `format`, `calculator`,
    and `input`, which each contain their source code files and corresponding test
    files.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将要讨论的所有代码都可以在对应本书的专用仓库的`chapter02`目录中找到。然后，在这个目录内部，我们有三个进一步的目录，分别是`format`、`calculator`和`input`，每个目录都包含其源代码文件和相应的测试文件。
- en: Naming test files
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 测试文件命名
- en: While test files need to end with the `_test.go` suffix, matching the rest of
    their name to their corresponding source code file is not enforced. However, it
    is highly recommended that you use the source filename and then append the test
    suffix. This will also ensure that the two files stay together when sorted lexicographically.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然测试文件需要以`_test.go`后缀结尾，但与相应源代码文件匹配的名称并不强制执行。然而，强烈建议您使用源文件名，然后添加测试后缀。这将确保在按字典顺序排序时，两个文件保持在一起。
- en: The source files and test files live directly next to each other, in the same
    directory, making it even easier for developers to swap between writing implementation
    code and test code when practicing TDD. Some editing tools can even do this with
    a keyboard shortcut!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 源文件和测试文件直接相邻，位于同一目录下，这使得开发者在练习测试驱动开发（TDD）时，在编写实现代码和测试代码之间切换变得更加容易。一些编辑工具甚至可以通过键盘快捷键完成这项操作！
- en: Additional test packages
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 额外的测试包
- en: Although test files are named the same as their corresponding source files and
    live in the same directory, the package structure will tell a different story.
    We previously mentioned that, with some exceptions, only one package may be declared
    per directory. Test files are one of these exceptions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管测试文件与相应的源文件具有相同的名称，并且位于同一目录下，但包结构会讲述一个不同的故事。我们之前提到，除了一些例外，每个目录只能声明一个包。测试文件就是这些例外之一。
- en: Test files are allowed to declare an additional test package, matching the source
    files package with `_test` appended. From a visibility perspective, this test
    package is the same as any other package and will need to import the packages
    that it wishes to have access to. It will also only have access to the exported
    names of its imported packages.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 测试文件允许声明一个额外的测试包，与源文件包匹配，并在其后添加`_test`。从可见性的角度来看，这个测试包与其他任何包相同，并且需要导入它希望访问的包。它也只会访问其导入包的导出名称。
- en: Test packages as a recommended practice
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 将测试包作为推荐实践
- en: The usage of the dedicated `_test` package is not enforced in Go, but it is
    recommended. Whenever possible, you should declare your tests in a dedicated test
    package.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，没有强制使用专用`_test`包，但这是推荐的。只要可能，你应该在专用测试包中声明你的测试。
- en: '*Figure 2**.3* depicts the separate definitions of test packages in the simple
    Terminal calculator:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.3*描述了简单终端计算器中测试包的独立定义：'
- en: '![Figure 2.3 – The package and directory structure of the simple calculator
    ](img/Figure_2.03_B18371.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – 简单计算器的包和目录结构](img/Figure_2.03_B18371.jpg)'
- en: Figure 2.3 – The package and directory structure of the simple calculator
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 简单计算器的包和目录结构
- en: 'The dedicated test package is defined in the same directory as the source package,
    achieving full separation between the source and test code. Using the dedicated
    test package brings the following advantages:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 专用测试包与源包位于同一目录下，实现了源代码和测试代码的完全分离。使用专用测试包有以下优点：
- en: '**Prevents brittle tests**: Restricting access to only exported functionality
    does not give test code visibility into package internals, such as state variables,
    which would otherwise cause inconsistent results.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**防止脆弱的测试**：仅允许访问导出功能，不会让测试代码看到包的内部，例如状态变量，否则会导致结果不一致。'
- en: '**Separates test and core package dependencies**: The test package allows the
    test to import any dependencies required, without adding those dependencies to
    the core package. In practice, test code will often have its own dedicated verifiers
    and functionality, which we would not want to be visible to production code. The
    test package is a seamless way to guarantee separation.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分离测试和核心包依赖**：测试包允许测试导入所需的任何依赖，而不会将这些依赖添加到核心包中。在实践中，测试代码通常会拥有自己的专用验证器和功能，我们不希望这些对生产代码可见。测试包是一种无缝保证分离的方式。'
- en: '**Allows developers to integrate with their own packages**: We previously mentioned
    that packages allow developers to build their internal code as small APIs. Writing
    tests from a dedicated test package allows developers to see how easy it is to
    integrate with their designed external interfaces, ensuring that their code is
    maintainable.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**允许开发者与自己的包集成**：我们之前提到，包允许开发者将内部代码构建成小的API。从专用测试包编写测试可以让开发者看到与外部接口集成的简便性，确保代码可维护。'
- en: '*Figure 2**.4* shows the updated module, packages, source, and test files of
    the simple Terminal calculator, which now uses `_test` packages:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.4*显示了更新后的模块、包、源文件和测试文件，现在使用的是`_test`包：'
- en: '![Figure 2.4 – The module, packages, source, and test files of the simple Terminal
    calculator ](img/Figure_2.04_B18371.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – 简单终端计算器的模块、包、源文件和测试文件](img/Figure_2.04_B18371.jpg)'
- en: Figure 2.4 – The module, packages, source, and test files of the simple Terminal
    calculator
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 简单终端计算器的模块、包、源文件和测试文件
- en: 'Let’s describe the dependencies between the packages in terms of the AAA pattern
    that we know from [*Chapter 1*](B18371_01.xhtml#_idTextAnchor015), *Getting to
    Grips with Test-Driven Development*. The **Arrange** and **Assert** steps are
    performed on the UUT and are conveniently defined in the correspondingly named
    package:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用我们从[*第一章*](B18371_01.xhtml#_idTextAnchor015)，“掌握测试驱动开发”中了解到的AAA模式来描述包之间的依赖关系。**安排**和**断言**步骤在UUT上执行，并且方便地在相应命名的包中定义：
- en: The `format` package does not have any dependencies on other packages. As a
    result, the `format_test` package performs all three steps on the `format` package.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format`包没有对其他包的依赖。因此，`format_test`包在`format`包上执行所有三个步骤。'
- en: The `calculator` package has a dependency on the `format` package. As a result,
    the `calculator_test` package arranges the dependencies from the `format` package.
    Then, it performs the Act and Assert steps on the `calculator` package.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculator`包依赖于`format`包。因此，`calculator_test`包安排了来自`format`包的依赖。然后，它在`calculator`包上执行操作和断言步骤。'
- en: Finally, the `input` package has a dependency on the `calculator` and `input`
    packages. As a result, the `input_test` package arranges the dependencies of the
    `input` package, which are provided by the `calculator` and `input` packages.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`input`包依赖于`calculator`和`input`包。因此，`input_test`包安排了由`calculator`和`input`包提供的`input`包的依赖。
- en: This section has given you an introduction to the Go module system and discussed
    how to place and name tests in the overall codebase. Now, let’s look at how to
    implement tests in Go.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本节为您介绍了Go模块系统，并讨论了如何在整体代码库中放置和命名测试。现在，让我们看看如何在Go中实现测试。
- en: Working with the testing package
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用测试包
- en: The standard library provides the `testing` package, which contains the essentials
    we need for writing and running tests. In this section, we will explore how to
    use it and begin to apply it so that we can write tests for our simple terminal
    calculator example.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了`testing`包，其中包含我们编写和运行测试所需的要素。在本节中，我们将探讨如何使用它，并开始应用它，以便我们可以为我们的简单终端计算器示例编写测试。
- en: The testing package
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试包
- en: The `testing` package provides support for testing Go code. It must be imported
    by all test code as this is the way to interact with the test runner. At a glance,
    the `testing` package seems very simplistic, but it fits with Go’s language design.
    Packages should be small, focused, and have a limited number of dependencies.
    This should make them easy to test with a relatively simple testing library.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`testing` 包为测试Go代码提供支持。所有测试代码都必须导入它，因为这是与测试运行器交互的方式。乍一看，`testing` 包似乎非常简单，但它与Go的语言设计相匹配。包应该小巧、专注，并且依赖项有限。这应该使它们能够通过相对简单的测试库轻松进行测试。'
- en: 'Here are some of the important types from the `testing` library that we will
    be using:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些我们将使用的重要类型，来自`testing`库：
- en: '`testing.T`: All tests must use this type to interact with the test runner.
    It contains a method for declaring failing tests, skipping tests, and running
    tests in parallel. We will look at and begin to use these methods in this section.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testing.T`：所有测试都必须使用此类型与测试运行器交互。它包含声明失败测试、跳过测试和并行运行测试的方法。在本节中，我们将查看并开始使用这些方法。'
- en: '`testing.B`: Analogous to the test runner, this type is Go’s **benchmark**
    runner. It has the same methods for failing tests, skipping tests, and running
    benchmarks in parallel. Benchmarks are special kinds of tests that are used for
    verifying the performance of your code, as opposed to its functionality. We will
    explore benchmarks later in this chapter.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testing.B`：类似于测试运行器，此类型是Go的**基准测试**运行器。它具有失败测试、跳过测试和并行运行基准测试的相同方法。基准测试是特殊类型的测试，用于验证代码的性能，而不是其功能。我们将在本章后面探索基准测试。'
- en: '`testing.F`: This type is used to set up and run `testing.T` type to provide
    test-running functionality. Fuzz tests are special kinds of tests that use random
    inputs to find edge cases and bugs in our code. We will explore fuzz tests further
    in [*Chapter 10*](B18371_10.xhtml#_idTextAnchor218), *Testing* *Edge Cases*.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testing.F`：此类型用于设置和运行`testing.T`类型，以提供测试运行功能。模糊测试是特殊类型的测试，使用随机输入来查找代码中的边缘情况和错误。我们将在[*第10章*](B18371_10.xhtml#_idTextAnchor218)，*测试边缘情况*中进一步探索模糊测试。'
- en: The testing package is used in all tests
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 测试包在所有测试中使用
- en: The `testing` package must be imported by all tests as it is the only way to
    interact with Go’s test runner. As previously discussed, test filenames must end
    with the `_test.go` suffix, but tests will only be run if they use the `testing`
    package. Tests must also satisfy a standard test signature, which is explained
    in the next section, *Working with the* *testing package*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`testing`包必须由所有测试导入，因为这是与Go的测试运行器交互的唯一方式。如前所述，测试文件名必须以`_test.go`后缀结尾，但只有使用`testing`包的测试才会运行。测试还必须满足标准测试签名，这将在下一节*使用测试包*中解释。'
- en: Now, let’s have a look at the `testing.T` type in a little bit more detail since
    it will be the focus of our exploration in this chapter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地看看`testing.T`类型，因为它将是本章探索的重点。
- en: '*Figure 2**.5* presents a summary of some of the methods we will discuss:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2**.5* 总结了我们将要讨论的一些方法：'
- en: '![Figure 2.5 – The logging, failing, and skipping methods of the testing.T
    type ](img/Figure_2.05_B18371.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – testing.T类型的日志记录、失败和跳过方法](img/Figure_2.05_B18371.jpg)'
- en: Figure 2.5 – The logging, failing, and skipping methods of the testing.T type
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – testing.T类型的日志记录、失败和跳过方法
- en: 'It exposes the following methods for logging, skipping, and failing tests that
    are important to understand:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 它公开了以下用于日志记录、跳过和失败测试的方法，这些方法非常重要：
- en: '`t.Log(args)`: This prints the given arguments to the error log after the test
    has finished executing.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t.Log(args)`：在测试执行完毕后，将给定的参数打印到错误日志中。'
- en: '`t.Logf(format, args)`: This has the same functionality as the `t.Log` method,
    but allows the arguments to be formatted before printing.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t.Logf(format, args)`: 它与 `t.Log` 方法的功能相同，但允许在打印之前格式化参数。'
- en: '`t.Fail()`: This marks the current test as failed but continues execution until
    the end.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t.Fail()`: 这将当前测试标记为失败但继续执行直到结束。'
- en: '`t.FailNow()`: This marks the current test as failed and immediately stops
    the execution of the current test. The next test will be run while continuing
    the suite.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t.FailNow()`: 这将当前测试标记为失败并立即停止当前测试的执行。下一个测试将在继续套件时运行。'
- en: '`t.Error(args)`: This is equivalent to calling `t.Log(args)` and `t.Fail()`.
    This method makes it convenient to log an error to the error log and mark the
    current test as failed.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t.Error(args)`: 这与调用 `t.Log(args)` 和 `t.Fail()` 等效。此方法使得将错误记录到错误日志并标记当前测试为失败变得方便。'
- en: '`t.Errorf(format, args)`: This is equivalent to calling `t.Logf(format, args)`
    and `t.Fail()`. This method makes it convenient to fail a test, then format and
    print an error line in one call.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t.Errorf(format, args)`: 这与调用 `t.Logf(format, args)` 和 `t.Fail()` 等效。此方法使得在单个调用中失败一个测试、格式化和打印错误行变得方便。'
- en: '`t.Fatal(args)`: This is equivalent to calling `t.Log(args)` and `t.FailNow()`.
    This method makes it convenient to fail a test and print an error line in one
    call.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t.Fatal(args)`: 这与调用 `t.Log(args)` 和 `t.FailNow()` 等效。此方法使得在单个调用中失败测试并打印错误行变得方便。'
- en: '`t.Fatalf(format, args)`: This is equivalent to calling `t.Logf(format, args)`
    and `t.FailNow()`. This method makes it convenient to fail a test, then format
    and print an error line in one method call.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t.Fatalf(format, args)`: 这与调用 `t.Logf(format, args)` 和 `t.FailNow()` 等效。此方法使得在单个方法调用中失败测试并打印错误行变得方便。'
- en: '`t.SkipNow()`: This marks the current test as skipped and immediately stops
    its execution. Note that if the test has already been marked as failed, then it
    remains failed, not skipped.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t.SkipNow()`: 这将当前测试标记为跳过并立即停止其执行。注意，如果测试已经被标记为失败，则它保持失败状态，而不是跳过。'
- en: '`t.Skip(args)`: This is equivalent to calling `t.Log(args)`, followed by `t.SkipNow()`.
    This method makes it convenient to skip a test and print an error line in one
    call.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t.Skip(args)`: 这与调用 `t.Log(args)`，然后调用 `t.SkipNow()` 等效。此方法使得在单个调用中跳过测试并打印错误行变得方便。'
- en: '`T.Skipf(format, args)`: This is equivalent to calling `t.Logf(format, args)`,
    followed by `t.SkipNow()`. This method makes it convenient to skip a test, then
    format and print an error line in one call.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T.Skipf(format, args)`: 这与调用 `t.Logf(format, args)`，然后调用 `t.SkipNow()` 等效。此方法使得在单个调用中跳过测试、格式化和打印错误行变得方便。'
- en: In general, developers use the convenience methods presented previously when
    writing their tests, as opposed to invoking `t.Fail()`, `t.FailNow()`, or `t.SkipNow()`
    explicitly. Going forward, we will make use of them as we begin to write our test
    code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，开发者在编写测试时使用前面提供的便利方法，而不是显式调用 `t.Fail()`、`t.FailNow()` 或 `t.SkipNow()`。从现在开始，我们将开始编写测试代码时使用它们。
- en: Another thing you might be wondering about is whether the `testing` package
    provides any assertion functionality. It does not provide any inbuilt assertions,
    so we will need to compare values ourselves. We will explore third-party assertion
    libraries further in [*Chapter 3*](B18371_03.xhtml#_idTextAnchor061), *Mocking
    and* *Assertion Frameworks*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件你可能想知道的事情是 `testing` 包是否提供任何断言功能。它不提供任何内置断言，因此我们需要自己比较值。我们将在 [*第 3 章*](B18371_03.xhtml#_idTextAnchor061)，*Mocking
    和断言框架* 中进一步探讨第三方断言库。
- en: Test signatures
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试签名
- en: 'The `testing` package is used for writing unit tests, which are placed in their
    own test files. Go tests are functions that satisfy the following signature:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`testing` 包用于编写单元测试，这些测试放在它们自己的测试文件中。Go 测试是满足以下签名的函数：'
- en: '[PRE5]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This test signature highlights the following requirements for Go tests:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试签名突出了 Go 测试的以下要求：
- en: Tests are exported functions whose name begins with `Test`.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试是名称以 `Test` 开头的导出函数。
- en: Test names can have an additional suffix that specifies what the test is covering.
    The suffix must also begin with a capital letter, as we can see specified by `Name`
    in the test signature, which doubles as the test name.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试名称可以有一个附加后缀，指定测试覆盖的内容。后缀也必须以大写字母开头，正如我们在测试签名中看到的 `Name` 所指定的那样，它同时作为测试名称。
- en: Tests must take in a single parameter of the `*testing.T` type. As we’ve explained
    so far, this will be how the test interacts with the test runner. You can name
    the testing parameter however you want, but Go developers typically use `t` to
    denote it.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试必须接受一个`*testing.T`类型的单个参数。正如我们迄今为止所解释的，这将是如何测试与测试运行器交互的方式。您可以随意命名测试参数，但Go开发者通常使用`t`来表示它。
- en: Tests must not have a return type.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试不得有返回类型。
- en: Go tests are just functions
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Go测试只是函数
- en: As we can see, tests are simply functions that satisfy a certain signature.
    The Go test tool scans the code base for these special functions in the `_test.go`
    files and runs them accordingly.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，测试只是满足特定签名的函数。Go测试工具扫描代码库中`_test.go`文件中的这些特殊函数，并相应地运行它们。
- en: Inside these test functions, we can define and implement our test code using
    the AAA pattern. You should keep the scope of your test small, preferring to write
    several tests rather than writing one large, potentially brittle test.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些测试函数内部，我们可以使用AAA模式定义和实现我们的测试代码。您应该保持测试范围的小型化，更倾向于编写多个测试，而不是编写一个大型、可能脆弱的测试。
- en: 'Just like package names, test names are very important, so we need to give
    them some special consideration. Having effectively named tests can bring developers
    some important advantages:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 就像包名一样，测试名称非常重要，因此我们需要给予它们一些特别的考虑。拥有有效命名的测试可以为开发者带来一些重要的优势：
- en: '**Documentation and understanding**: A suite of effectively named tests will
    help newcomers understand how a particular piece of code is supposed to work.
    As they are easy to change, they also allow you to explore the behavior of the
    code under a variety of conditions.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档和理解**：一套有效命名的测试将帮助新来者理解特定代码应该如何工作。由于它们易于更改，它们还允许您在多种条件下探索代码的行为。'
- en: '**Refactoring support**: The test name sets the intention of the test; then,
    its implementation simply executes it. Once the code has been refactored, the
    test implementation may change, but the intention of the test, conveyed by its
    name, remains. Well-named tests can support code refactoring, which might need
    to change the test implementation/execution. We will discuss code refactoring
    strategies further in [*Chapter 7*](B18371_07.xhtml#_idTextAnchor162), *Refactoring*
    *in Go*.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重构支持**：测试名称设定了测试的意图；然后，其实施简单地执行它。一旦代码被重构，测试实现可能会改变，但测试的意图，通过其名称传达，仍然保持不变。命名良好的测试可以支持代码重构，这可能会需要更改测试实现/执行。我们将在[*第七章*](B18371_07.xhtml#_idTextAnchor162)
    *Go中的重构*中进一步讨论代码重构策略。'
- en: '**Consistency**: Setting a standard for how tests should be named and structured
    throughout your code base will make it easier for you to know what to expect,
    reducing cognitive load when reading code.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：在整个代码库中为测试命名和结构设置一个标准，将使您更容易了解预期内容，减少阅读代码时的认知负荷。'
- en: 'Other than the special signature we’ve just seen, Go does not enforce any other
    naming standards. The consensus in the Go community is that they should be easily
    understood and concise. The Go standard library ties tests with the name of the
    function that they test: the UUT. The test name simply follows the `TestUnitUnderTest`
    structure. For example, a test for the `Add` function will be named `TestAdd`.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们刚刚看到的特殊签名之外，Go不强制执行任何其他命名标准。Go社区的一致意见是，它们应该是易于理解和简洁的。Go标准库将测试与它们测试的函数名称（UUT）相关联。测试名称简单地遵循`TestUnitUnderTest`结构。例如，对`Add`函数的测试将被命名为`TestAdd`。
- en: Another common approach is to name the tests using a **Behavior-Driven Development**
    (**BDD**) style approach. We will explore BDD tests in detail in [*Chapter 5*](B18371_05.xhtml#_idTextAnchor124),
    *Performing* *Integration Testing*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的方法是使用**行为驱动开发**（**BDD**）风格的命名方法。我们将在[*第五章*](B18371_05.xhtml#_idTextAnchor124)
    *执行* *集成测试*中详细探讨BDD测试。
- en: In this naming approach, the name of the test follows the structure of `TestUnitUnderTest_PreconditionsOrInputs_ExpectedOutput`.
    For example, a test for the function will be named `TestAdd_TwoNegativeNumbers_NegativeResults`
    if it tests adding two negative numbers together.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种命名方法中，测试名称遵循`TestUnitUnderTest_PreconditionsOrInputs_ExpectedOutput`的结构。例如，如果测试一个函数，测试将被命名为`TestAdd_TwoNegativeNumbers_NegativeResults`，如果它测试两个负数相加。
- en: 'While the BDD style naming pattern is a lot more precise, it goes against the
    principle of simplicity and conciseness that is so central to Go. We will use
    the simpler approach: naming the test after its UUT. We will see how we can achieve
    the extra precision of preconditions and expected output using subtests later
    in this chapter.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 BDD 风格的命名模式更加精确，但它违背了 Go 的核心原则——简洁性。我们将使用更简单的方法：将测试命名为其 UUT（单元待测）的名称。我们将在本章后面看到如何使用子测试实现额外的精确性，包括前置条件和预期输出。
- en: Running tests
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行测试
- en: One of the commands of the Go toolchain is the `go test` command. We’ve previously
    mentioned that it is Go’s test runner and that we will use it to execute tests.
    We’ll look at how to use it in more detail in this section.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Go 工具链中的一个命令是 `go test` 命令。我们之前提到过，它是 Go 的测试运行器，我们将使用它来执行测试。我们将在本节中更详细地介绍如何使用它。
- en: 'Inside the `_test.go` files, the test runner will treat three kinds of functions
    especially:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `_test.go` 文件中，测试运行器会特别处理三种类型的函数：
- en: '`Test`. We have covered test functions at length in this section.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Test`。我们在本节中详细介绍了测试函数。'
- en: '`Benchmark`. We will cover these in the *Difference between a test and a benchmark*
    section of this chapter.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Benchmark`。我们将在本章的**测试与基准测试的区别**部分介绍这些内容。'
- en: '`Example`. These are outside the scope of our discussion in this book.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Example`。这些内容超出了本书的讨论范围。'
- en: The test runner will look for files that end in `_test.go`, build them into
    their own packages, and then link them in the test binary.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行器将寻找以 `_test.go` 结尾的文件，将它们构建成自己的包，然后将它们链接到测试二进制文件中。
- en: The output of the `go test` command will print out all the test failures of
    the executed tests to the standard output. You can add a `–v` flag, which is short
    for verbose, to get it to print the name and execution time of all tests, including
    passed tests.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`go test` 命令的输出将打印出已执行测试的所有测试失败到标准输出。你可以添加一个 `–v` 标志，它是详细输出的简称，以使其打印出所有测试的名称和执行时间，包括通过测试。'
- en: 'Tests are executed and output in lexicographic order. Here is the output from
    our `engine_test.go`, which contains tests for the operations of the calculator,
    implemented in `engine.go`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 测试将按字典顺序执行和输出。以下是我们的 `engine_test.go` 的输出，其中包含在 `engine.go` 中实现的计算器操作的测试：
- en: '[PRE6]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Test failures are marked in the output with the `FAIL` keyword and any error
    messages are printed to the standard output. In our example, we have a failing
    test: `TestAdd`. As we saw in the previous section, we can print informative error
    messages and fail tests using a variety of methods from the `testing.T` type,
    which we have access to in all tests from the parameter of the test signature.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 测试失败在输出中以 `FAIL` 关键字标记，任何错误消息都会打印到标准输出。在我们的例子中，我们有一个失败的测试：`TestAdd`。正如我们在上一节中看到的，我们可以使用
    `testing.T` 类型提供的各种方法来打印信息性错误消息并使测试失败，我们可以在所有测试的测试签名参数中访问它。
- en: At the end of the test output, we can see the outcome of the entire test run,
    as well as the time it took to run. We can also see the running time for each
    test.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试输出的末尾，我们可以看到整个测试运行的输出结果以及运行时间。我们还可以看到每个测试的运行时间。
- en: 'The test runner supports two running modes:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行器支持两种运行模式：
- en: When the command has no package specifications, it will build and run all tests
    in the current directory. This is known as `go` `test –v`.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当命令没有包指定时，它将构建并运行当前目录中的所有测试。这被称为 `go test –v`。
- en: When the command has package specifications, it will build and run all tests
    matching the specific package arguments. This is known as **package list mode**.
    Developers usually run their tests in this mode for large projects as it can be
    cumbersome to change between directories and run the tests in each of them using
    local directory mode.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当命令有包指定时，它将构建并运行所有匹配特定包参数的测试。这被称为**包列表模式**。开发者通常在大型项目中使用此模式运行测试，因为使用本地目录模式在目录之间切换并运行每个目录中的测试可能会很繁琐。
- en: 'We can easily specify what tests to run by providing these properties:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过提供以下属性轻松指定要运行的测试：
- en: '`go test engine_test` will run the tests from the `engine_test` package from
    anywhere in the project directory.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go test engine_test` 将从项目目录中的任何位置运行 `engine_test` 包中的测试。'
- en: '`go test ./...` will run all the tests in the project, regardless of where
    it’s being run from.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go test ./...` 将运行项目中的所有测试，无论从哪里运行。'
- en: '`go test ./chapter02` will run all the tests in the `chapter02` subdirectory
    of the current path, but will not traverse to further nested directories.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go test ./chapter02` 将运行当前路径下 `chapter02` 子目录中的所有测试，但不会遍历到更深的嵌套目录。'
- en: '`–run``go test –run "^engine"` will run all packages that begin with the word
    `engine`. A subdirectory path can also be provided alongside the test name.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`–run` `go test –run "^engine"` 将运行以单词 `engine` 开头的所有包。也可以在测试名称旁边提供子目录路径。'
- en: '`–run``go test –run TestAdd` will only the test specified. A subdirectory path
    can also be provided alongside the test name.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`–run` `go test –run TestAdd` 将仅运行指定的测试。也可以在测试名称旁边提供子目录路径。'
- en: The Go test runner can cache successful test results to avoid wasting resources
    by rerunning tests on code that has not changed. Being able to cache successful
    test results is disabled by default when running in local directory mode, but
    enabled in package list mode.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Go 测试运行器可以缓存成功的测试结果，以避免在代码未更改的情况下重新运行测试而浪费资源。在本地目录模式下运行时，默认禁用缓存成功的测试结果，但在包列表模式下启用。
- en: 'As you can see, the output of the `go test –v ./...` command, which triggers
    package list mode, will mark the cached results with `(cached)` on their corresponding
    output line:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，触发包列表模式的 `go test –v ./...` 命令的输出，将缓存的结果在其对应输出行上标记为 `(cached)`：
- en: '[PRE7]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that only successful test runs can be cached. Test failures will be run
    every time until they pass, at which point they can be cached.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只有成功的测试运行可以被缓存。测试失败将每次运行，直到通过，此时它们可以被缓存。
- en: Writing tests
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写测试
- en: So far, we have examined the structure of packages, where test files fit into
    their structure, as well as become acquainted with Go’s testing package and test
    signatures. Now, let’s take everything we have learned and begin applying it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经检查了包的结构，测试文件如何融入其结构，以及熟悉了Go的测试包和测试签名。现在，让我们将我们所学的一切应用到实践中。
- en: 'With the knowledge we have of how to test code works in Go, we can expand on
    the **red, green, refactor** approach with more specific steps. *Figure 2**.6*
    shows the expanded flow of TDD in Go for new functionality:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们了解如何在Go中测试代码之后，我们可以通过更具体的步骤来扩展 **红、绿、重构** 方法。*图2.6* 显示了Go中针对新功能扩展的TDD流程：
- en: '![Figure 2.6 – Expanded TDD flow in Go ](img/Figure_2.06_B18371.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – Go中扩展的TDD流程](img/Figure_2.06_B18371.jpg)'
- en: Figure 2.6 – Expanded TDD flow in Go
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – Go中扩展的TDD流程
- en: 'We can describe the test writing process with the following steps:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下步骤来描述测试编写过程：
- en: '`_test.go` file corresponding to the test that you will be implementing in
    this new directory. This will ensure that you have a place to begin writing test
    code alongside implementation code. As previously mentioned, while Go does not
    enforce the usage of the external test package, you should use one whenever possible.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`_test.go` 文件对应于您将在新目录中实现的测试。这将确保您有一个地方可以开始编写测试代码，同时编写实现代码。如前所述，虽然Go不强制使用外部测试包，但您应该尽可能使用它。'
- en: '`.go` files are immediately compiled. At this point, you will begin reflecting
    on the structure of your code, as we did with the simple terminal calculator at
    the beginning of this chapter.'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.go` 文件会立即编译。此时，您将开始反思您代码的结构，就像我们在本章开头的简单终端计算器中所做的那样。'
- en: '**Write the test signature for the new functionality**: While in the test file,
    you can create the new test, named after the UUT you will be testing. The test
    signature will also require you to import the testing package, getting you ready
    to write your test code.'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为新功能编写测试签名**：在测试文件中，您可以创建新的测试，以您将要测试的UUT命名。测试签名还将要求您导入测试包，为您编写测试代码做好准备。'
- en: '**Write the definitions of your UUT**: Inside your previously empty source
    file, write the definitions for the custom types, methods, and functions that
    you intend to test. This will allow you to settle on the signatures or API of
    your UUT, then structure your test accordingly. As we did in the simple terminal
    calculator, return empty or zero values according to the signature of your methods
    to ensure your code compiles.'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编写您的UUT定义**：在您之前为空的源文件中，编写您打算测试的自定义类型、方法和函数的定义。这将使您能够确定UUT的签名或API，然后相应地构建测试。正如我们在本章开头的简单终端计算器中所做的那样，根据您的方法签名返回空值或零值，以确保您的代码可以编译。'
- en: '**Set up your test scenario**: Starting with the simplest test cases first,
    write your test using the AAA approach, invoking the previously defined signatures
    of your UUT. This is the reason we created the signatures and returned dummy values
    for the code to compile.'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置您的测试场景**：从最简单的测试用例开始，使用AAA方法编写测试，调用您UUT之前定义的签名。这也是我们创建签名并返回占位符值以使代码编译的原因。'
- en: '`go test` command in the directory of your new package.'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您新包的目录中执行`go test`命令。
- en: '**Implement the functionality required by your test scenario**: Going back
    to your UUT, write just enough code to satisfy your newest test scenario. This
    will require changing some of your dummy code.'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实现测试场景所需的功能**：回到您的UUT，编写足够的代码来满足您最新的测试场景。这可能需要更改一些您的占位符代码。'
- en: '`go test` command. Your new test should now pass.'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`go test`命令。您的新测试现在应该通过。
- en: '**Refactor your newest test and code**: Look for any improvements you can make
    to your source and test code. Improvements should be frequent and small, so make
    sure to take the time to review your code.'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重构最新的测试和代码**：寻找您可以改进源代码和测试代码的地方。改进应该是频繁且小的，所以请确保花时间审查您的代码。'
- en: '**Run your test to see it pass**: Your new test should continue to pass after
    this refactoring.'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行测试以查看它通过**：在重构后，您的新测试应该继续通过。'
- en: Repeat all of these steps as many times as required until all the functionality
    is implemented. You will define your UUT signatures and tests as required, starting
    from the simplest functionality and working forward.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复所有这些步骤，直到所有功能都实现。您将根据需要定义UUT签名和测试，从最简单的功能开始，逐步推进。
- en: As expected, the TDD process requires frequent changes between the source and
    test code. Test runs should always fail first, then pass as we implement and refactor
    the source code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，TDD过程需要在源代码和测试代码之间进行频繁的更改。测试运行应该首先失败，然后在我们实现和重构源代码时通过。
- en: Use case – implementing the calculator engine
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例 – 实现计算器引擎
- en: Let’s use our established working practice to write and implement the functionality
    of the calculator that we will define in `engine.go`. This will also give us some
    hands-on experience with the `testing` package.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们建立的工作习惯来编写和实现我们在`engine.go`中定义的计算器功能。这也会给我们一些使用`testing`包的实践经验。
- en: Step 1 – creating the test file and test package
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一步 – 创建测试文件和测试包
- en: As we saw in *Figure 2**.2*, we will create a directory named `calculator` where
    we will place the corresponding calculator engine files.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*图2.2*中看到的，我们将创建一个名为`calculator`的目录，我们将放置相应的计算器引擎文件。
- en: 'We will create the `engine_test.go` test file and declare the external `calculator_test`
    package:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建`engine_test.go`测试文件并声明外部`calculator_test`包：
- en: '[PRE8]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At this point, the test file only contains a single line, and there are no compile
    errors.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，测试文件只包含一行，并且没有编译错误。
- en: Step 2 – creating the source code file and package
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二步 – 创建源代码文件和包
- en: 'In the same directory, we must create the `engine.go` file and declare the
    calculator package, which matches the already declared external test package:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一目录中，我们必须创建`engine.go`文件并声明计算器包，该包与已声明的外部测试包相匹配：
- en: '[PRE9]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: At this point, the source code file also contains a single line and there are
    no compile errors.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，源代码文件也只包含一行，并且没有编译错误。
- en: Step 3 – writing the test signature for the new functionality
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第三步 – 为新功能编写测试签名
- en: 'We will begin by testing and implementing the calculator addition functionality,
    as that is the simplest function. In the `engine_test.go` file, add a new test
    corresponding to the Go test signature and import the `testing` package:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从测试和实现计算器的加法功能开始，因为这个函数最简单。在`engine_test.go`文件中，添加一个与Go测试签名对应的新测试，并导入`testing`包：
- en: '[PRE10]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As its name and package indicate, we will be testing the `Add` function or method
    of the `calculator` package. With just these few lines of code, we already have
    a decent indication of what this test will cover. This is a very powerful mechanism.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称和包所示，我们将测试`calculator`包的`Add`函数或方法。仅仅这几行代码，我们已经有了一个很好的指示，这个测试将涵盖什么。这是一个非常强大的机制。
- en: Step 4 – writing the definitions of your UUT
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第四步 – 编写您的UUT的定义
- en: 'Here, we will add stubbed definitions of the UUT to the source file so that
    we can invoke them in our newly written code. While this is a small departure
    from writing no code that does not have corresponding test code, it will make
    it easier for us to reference the code in test code from any code editor. In the
    `engine.go` file, we must add stubs for the `Engine` custom type and the `Add`
    method:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将把待测单元（UUT）的存根定义添加到源文件中，以便我们可以在新编写的代码中调用它们。虽然这稍微偏离了编写没有对应测试代码的代码，但它将使我们更容易在任何代码编辑器中从测试代码中引用代码。在`engine.go`文件中，我们必须为`Engine`自定义类型和`Add`方法添加存根：
- en: '[PRE11]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We return a dummy value of `0` to ensure that the code continues to compile.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回一个虚拟值`0`以确保代码可以继续编译。
- en: Step 5 – setting up your test scenario
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第5步 – 设置你的测试场景
- en: 'Going back to the test code, we will add a simple test scenario to the `TestAdd`
    function, which is currently empty. In the `engine_test.go` file, we will add
    testing code that was written using the AAA pattern, as indicated by the comments
    corresponding with each step:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 回到测试代码，我们将向`TestAdd`函数添加一个简单的测试场景，该函数目前为空。在`engine_test.go`文件中，我们将添加使用AAA模式编写的测试代码，如每个步骤对应的注释所示：
- en: '[PRE12]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the Arrange step, `TestAdd` creates an instance of `calculator.Engine`, which
    requires the calculator package to be imported inside the test file.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在安排步骤中，`TestAdd`创建了一个`calculator.Engine`实例，这需要在测试文件中导入计算器包。
- en: In the Act step, we invoke the `Add` method on the created `Engine` instance
    and pass it the two inputs that we will be using in this step.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在行为步骤中，我们在创建的`Engine`实例上调用`Add`方法，并传递我们将在此步骤中使用的两个输入。
- en: Finally, in the Assert step, we compare the actual and expected values in an
    `if` statement and call for the test failure using `t.Errorf` if they do not match.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在断言步骤中，我们使用`if`语句比较实际值和预期值，并在它们不匹配时使用`t.Errorf`调用测试失败。
- en: Step 6 – running your test to see if it fails
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第6步 – 运行测试以查看是否失败
- en: 'Starting with a failing test is very important to the TDD philosophy since
    it ensures that our test is actually being run and does not pass falsely. We can
    run our test:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个失败的测试开始对于TDD哲学非常重要，因为它确保我们的测试实际上正在运行并且不会错误地通过。我们可以运行我们的测试：
- en: '[PRE13]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The test fails and our informative error message is printed out to the terminal.
    The test is expected to fail since our method is currently only returning the
    dummy value. With that, we have completed the **red** phase of the red, green,
    refactor approach.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 测试失败了，并且我们的信息性错误消息被打印到终端。由于我们的方法目前只返回虚拟值，测试预期会失败。至此，我们已经完成了红、绿、重构方法中的**红**阶段。
- en: Step 7 – implementing the functionality required by your test scenario
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第7步 – 实现测试场景所需的函数
- en: 'With the failing `TestAdd` in place, it’s time to implement the functionality
    required to make it pass. In the `engine.go` file, we must change the `Add` method
    to remove the dummy value return:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置失败的`TestAdd`之后，现在是时候实现使其通过所需的函数了。在`engine.go`文件中，我们必须将`Add`方法更改为移除返回的虚拟值：
- en: '[PRE14]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Add` method will now use the input parameters and return their addition
    result.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`Add`方法现在将使用输入参数并返回它们的加法结果。'
- en: Step 8 – running your test to see if it passes
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第8步 – 运行测试以查看是否通过
- en: 'Exactly like in *Step 6 – running your test to see if it fails*, we will run
    the test:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在第6步 – 运行测试以查看是否失败中一样，我们将运行测试：
- en: '[PRE15]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The test is now passing and we have verified that our code satisfies the test
    requirements. With that, we have completed the **green** phase of the red, green,
    refactor approach.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 测试现在通过了，并且我们已经验证了我们的代码满足测试要求。至此，我们已经完成了红、绿、重构方法中的**绿**阶段。
- en: Step 9 – refactoring your newest test and code
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第9步 – 重构你的最新测试和代码
- en: 'This step is not guaranteed to take place. We can improve our test code by
    extracting variables that allow us to clean up the test code, removing the need
    for us to repeat hardcoded values:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步不一定发生。我们可以通过提取变量来改进我们的测试代码，这些变量允许我们清理测试代码，消除我们重复硬编码值的需求：
- en: '[PRE16]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the Arrange section, we now declare three variables for our inputs and expected
    output. We make use of these variables throughout the test, passing them to the
    UUT as well as to the formatted error message.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在安排部分，我们现在声明了三个变量用于我们的输入和预期输出。我们在整个测试中使用这些变量，将它们传递给UUT以及格式化的错误消息。
- en: Step 10 – re-running your test to see if it passes
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第10步 – 重新运行测试以查看是否通过
- en: 'Exactly like in *Step 8 – running your test to see if it passes*, we must run
    the test:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在第8步 – 运行测试以查看是否通过中一样，我们必须运行测试：
- en: '[PRE17]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The test is now passing and we have verified that our refactoring has not broken
    any implemented functionality. With that, we have completed the **refactor** phase
    of the red, green, refactor approach.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 测试现在通过了，并且我们已经验证了我们的重构没有破坏任何已实现的功能。至此，我们已经完成了红、绿、重构方法中的**重构**阶段。
- en: These steps can now be repeated for all the other operations of the simple terminal
    calculator. You can go ahead and implement them, which will allow you to practice
    using TDD in Go. Next, we’ll explore how to streamline our test writing processing
    using test setup and teardown.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤现在可以重复用于简单终端计算器的所有其他操作。你可以继续实现它们，这将使你能够在Go中使用TDD进行实践。接下来，我们将探讨如何通过测试设置和清理来简化我们的测试编写过程。
- en: Test setup and teardown
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试设置和清理
- en: We’ve written our first example of a test and source code by leveraging an external
    test package and the `testing.T` type. This has worked very well for our simple
    example, but, as we begin to ramp up and write more tests, it can be cumbersome
    to continue repeating the same test setup and cleanup. In this section, we will
    explore what functionality the `testing` package offers to streamline this process
    for us.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过利用外部测试包和`testing.T`类型编写了我们的第一个测试和源代码示例。这对于我们的简单示例来说效果很好，但随着我们开始增加测试并编写更多测试，重复相同的测试设置和清理可能会变得繁琐。在本节中，我们将探讨`testing`包为我们提供的功能，以简化这一过程。
- en: The TestMain approach
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试主方法
- en: '`TestMain`. This is a feature that is often underutilized, but it gives us
    great flexibility when it comes to setup and teardown code. The signature of this
    test is as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestMain`. 这是一个经常被低估的功能，但在设置和清理代码方面提供了极大的灵活性。这个测试的签名如下：'
- en: '[PRE18]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Unlike other tests, the name of this test is fixed and it takes in the `*testing.M`
    type as its only parameter, as opposed to `*testing.T` as other tests do. Once
    you override it, the code in this method will give you more control over how your
    tests run. The `TestMain` method will be run before any of the other tests in
    this package.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他测试不同，这个测试的名称是固定的，它接受`*testing.M`类型作为其唯一参数，而不是像其他测试那样接受`*testing.T`。一旦你覆盖了它，这个方法中的代码将为你提供更多控制测试运行的方式。`TestMain`方法将在本包中的其他任何测试之前运行。
- en: One TestMain function per package
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 每个包一个`TestMain`函数
- en: As names need to be unique inside a package, you will only be able to define
    one `TestMain` function per package. You should be mindful that this method will
    control how all the tests inside the given package run, not just those in the
    given file.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在包内部名称需要唯一，你将只能在每个包中定义一个`TestMain`函数。你应该注意，这个方法将控制给定包中所有测试的运行方式，而不仅仅是给定文件中的测试。
- en: The `testing.M` type is much smaller than the `testing.T` type and exposes a
    method called `Run()`, which allows us to run the tests in the given package and
    returns an exit code.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`testing.M`类型比`testing.T`类型小得多，它公开了一个名为`Run()`的方法，允许我们运行给定包中的测试，并返回一个退出代码。'
- en: 'The usage of this function is simple:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的使用很简单：
- en: '[PRE19]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code sample outlines a simple recipe:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例概述了一个简单的配方：
- en: '`TestMain` **signature**: Write the correct name and signature of the test
    in your test file. In general, you should place this definition as high up at
    the beginning of the file as possible.'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TestMain`**签名**：在你的测试文件中写下正确的测试名称和签名。一般来说，你应该尽可能将这个定义放在文件的开头部分。'
- en: '`setup()` function and calling that instead of writing the code directly into
    your test function. This will help with the readability of your test file. All
    of these statements will run before your tests are executed.'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setup()`函数和调用它而不是直接将代码写入测试函数中。这将有助于提高测试文件的可读性。所有这些语句将在测试执行之前运行。'
- en: '`Run()``m.` `Run()` and save the exit value returned from this function inside
    a variable, named `e` in our code sample. It is at this point that the tests will
    run and the exit value will report whether your tests have failed.'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Run()`和将此函数返回的退出值保存在一个变量中，在我们的代码示例中命名为`e`。此时，测试将运行，退出值将报告测试是否失败。'
- en: '`Run()` method. I also recommend creating a separate function named `teardown`,
    as opposed to writing the code directly into your `TestMain` code block. All of
    these statements will run after your tests are executed.'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Run()`方法。我还建议创建一个名为`teardown`的单独函数，而不是直接将代码写入`TestMain`代码块中。所有这些语句将在测试执行后运行。'
- en: '`os.Exit` function. If you forget to add this part of the main function, you
    might get false positives reported to your test runner.'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`os.Exit`函数。如果你忘记在主函数中添加这部分，你的测试运行器可能会报告错误。'
- en: 'We implement the same recipe in our calculator example, defining the `TestMain`
    function alongside `TestAdd` in the `engine_test.go` file:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的计算器示例中实现了相同的配方，在`engine_test.go`文件中定义了`TestMain`函数和`TestAdd`：
- en: '[PRE20]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `setup()` and `teardown()` functions simply print two lines to the Terminal.
    Running the test shows us the following output:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup()`和`teardown()`函数只是简单地打印两行到终端。运行测试会显示以下输出：'
- en: '[PRE21]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we can see from the test output, the setup and teardown log lines are printed
    around the test run output, before and after.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 从测试输出中我们可以看到，设置和拆解日志行是在测试运行输出之前和之后打印的。
- en: init functions
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化函数
- en: The second option you have available to ensure that the test setup runs correctly
    is to use `init` functions. It is often the case with unit tests that no teardown
    logic is required, only setup logic. In these cases, where you simply want to
    ensure that some logic is run before the tests, you might want to opt for a less
    cumbersome approach than `TestMain`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用的第二个选项来确保测试设置正确运行是使用`init`函数。在单元测试中，通常不需要拆解逻辑，只需要设置逻辑。在这些情况下，如果你只是想确保在测试之前运行某些逻辑，你可能想选择比`TestMain`更简单的方法。
- en: 'Unlike the `TestMain` approach, the `init` functions are not specifically restricted
    to test code. The signature of the `init` function looks like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 与`TestMain`方法不同，`init`函数并不特别限制于测试代码。`init`函数的签名如下：
- en: '[PRE22]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The name of the `init` function is fixed and it takes no parameters. This function
    will be called before any main function, regardless of whether that main function
    is in the source code or the special test runner main function.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`函数的名称是固定的，它不接受任何参数。这个函数将在任何主函数之前被调用，无论这个主函数是在源代码中还是在特殊的测试运行程序主函数中。'
- en: Multiple init functions per package
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 每个包中可以有多个初始化函数
- en: Unlike other names, multiple `init` functions are allowed per package. However,
    you should be mindful that they will all be called before the main runner. When
    multiple `init` functions are defined in the same file, they are run in definition
    order. On the other hand, when they are defined in multiple files, they are run
    in the lexicographic order of their filenames.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他名称不同，每个包允许有多个`init`函数。然而，你应该注意，它们都会在主运行程序之前被调用。当在同一个文件中定义多个`init`函数时，它们会按照定义顺序运行。另一方面，当它们在多个文件中定义时，它们会按照文件名的字典顺序运行。
- en: 'We will define an `init` function, alongside `TestMain` and `TestAdd`, in the
    `engine_test.go` file:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`engine_test.go`文件中定义一个`init`函数，与`TestMain`和`TestAdd`一起：
- en: '[PRE23]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `init()` function simply prints another line to the Terminal. Running the
    test shows us the following output:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`init()`函数只是简单地打印另一行到终端。运行测试会显示以下输出：'
- en: '[PRE24]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we can see from the test run output, the `init` setup is run before the `TestMain`
    setup. The logline defined in the `init` function is printed before any other
    code is executed.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 从测试运行输出中我们可以看到，`init`设置是在`TestMain`设置之前运行的。在执行任何其他代码之前，`init`函数中定义的日志行被打印出来。
- en: Deferred functions
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延迟函数
- en: We can make use of `init` functions, this is a construct that does not only
    exist in test code.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用`init`函数，这是一个不仅存在于测试代码中的结构。
- en: 'In Go, deferred functions are declared using the `defer` statement. Once this
    is applied to a function call, the function will only be executed once the surrounding
    function call has been completed, either successfully or using a panic. For example,
    we can defer the teardown function like so:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，使用`defer`语句声明延迟函数。一旦应用于函数调用，该函数将在周围函数调用完成后执行，无论是成功还是使用panic。例如，我们可以这样延迟拆解函数：
- en: '[PRE25]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Deferred function definitions
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟函数定义
- en: We can apply the `defer` statement to named functions or **anonymous functions**
    defined inline. It is Go convention to define your deferred functions at the top
    of the enclosing function. This will ensure that the function will be deferred
    before any errors can occur and stop the deferral.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`defer`语句应用于命名函数或内联定义的**匿名函数**。在Go中，将延迟函数定义在封装函数的顶部是惯例。这将确保在发生错误并停止延迟之前，函数将被延迟。
- en: The approaches we’ve seen so far are made up of Go’s language constructs, but
    they can be cumbersome to keep defining and have the disadvantage of creating
    package-level changes. Deferred functions give us fine-grained control, making
    changes only to the test where they are invoked. However, the disadvantages are
    that we need to remember to add them to each test and that we can only use this
    approach for teardown, not setup logic. You should weigh the advantages and disadvantages
    of each mechanism as you begin to write more tests.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止看到的方法由Go语言构造组成，但它们在定义时可能会变得繁琐，并且有创建包级更改的缺点。延迟函数为我们提供了细粒度的控制，只对调用它们的测试进行更改。然而，缺点是我们需要记住将它们添加到每个测试中，并且我们只能使用这种方法进行拆卸，而不是设置逻辑。在开始编写更多测试时，你应该权衡每种机制的优势和劣势。
- en: 'Let’s modify the `TestAdd` function in the `engine_test.go` file to add a deferred
    function, leaving the `TestMain` and `init` functions already defined in this
    test file unchanged:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改`engine_test.go`文件中的`TestAdd`函数，添加一个延迟函数，同时保持该测试文件中已定义的`TestMain`和`init`函数不变：
- en: '[PRE26]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The deferred function simply prints out another log line to the Terminal. Running
    the test shows us the following output:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟函数只是简单地打印另一条日志行到终端。运行测试会显示以下输出：
- en: '[PRE27]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As we can see from the test run output, the deferred teardown call is executed
    before the `TestMain` function’s teardown step. This is expected due to the invocation
    order of deferred functions.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从测试运行输出中可以看到，延迟拆卸调用是在`TestMain`函数的拆卸步骤之前执行的。这是由于延迟函数的调用顺序所致。
- en: '*Figure 2**.7* depicts a summary of the order in which all the setup and teardown
    mechanisms we’ve looked at will execute:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2**.7*展示了所有我们查看的设置和拆卸机制将执行的顺序总结：'
- en: '![Figure 2.7 – Summary of the order of setup and teardown mechanisms ](img/Figure_2.07_B18371.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – 设置和拆卸机制的顺序总结](img/Figure_2.07_B18371.jpg)'
- en: Figure 2.7 – Summary of the order of setup and teardown mechanisms
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 设置和拆卸机制的顺序总结
- en: 'The order verifies what we’ve seen with our terminal output:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序验证了我们通过终端输出看到的内容：
- en: The tests kick off with the `go test` command, as we’ve become used to running
    them so far.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试是通过`go test`命令启动的，因为我们迄今为止已经习惯了这样运行它们。
- en: The `init` functions execute before the temporary main program of the tests.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`init`函数在测试的临时主程序之前执行。'
- en: Once the tests are ready to execute, the `TestMain` function starts and its
    setup functions execute.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦测试准备就绪要执行，`TestMain`函数开始，并执行其设置函数。
- en: The tests are then run by invoking `m.Run()` from `TestMain`.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过从`TestMain`中调用`m.Run()`来运行测试。
- en: Once all the tests have been run, the deferred functions defined inside the
    scope of the tests are executed.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦所有测试都已运行，测试范围内定义的延迟函数将被执行。
- en: Once the tests and their functions exit, the `TestMain` function’s teardown
    function is executed.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦测试及其函数退出，`TestMain`函数的拆卸函数将被执行。
- en: Finally, the tests end with the exit value returned from the call to `m.Run()`.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，测试以从`m.Run()`调用返回的退出值结束。
- en: As we begin to consider writing tests on a larger scale, we will also need a
    way to separate tests according to a smaller test scope and different scenarios.
    In the next section, we’ll see how to achieve that using **subtests**.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始考虑编写更大规模的测试时，我们还需要一种方法来根据更小的测试范围和不同的场景来分离测试。在下一节中，我们将看到如何使用**子测试**来实现这一点。
- en: Operating with subtests
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用子测试操作
- en: In TDD, the test scope should be small, and the outcome should be easy to understand.
    We explored TDD best practices in [*Chapter 1*](B18371_01.xhtml#_idTextAnchor015),
    *Getting to Grips with Test-Driven Development*. To achieve these best practices,
    we need separation between test scenarios.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在TDD（测试驱动开发）中，测试范围应该小，结果应该易于理解。我们在[*第一章*](B18371_01.xhtml#_idTextAnchor015)中探讨了TDD的最佳实践，即*掌握测试驱动开发*。为了实现这些最佳实践，我们需要在测试场景之间进行分离。
- en: 'Let’s consider the example of the `TestAdd` function that we have worked with
    so far. It currently tests adding two positive numbers, but we will extend it
    to cover negative inputs. With the knowledge we have so far, we have two options:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下我们迄今为止一直在使用的`TestAdd`函数的例子。它目前测试的是两个正数的相加，但我们将扩展它以涵盖负数输入。根据我们迄今为止的知识，我们有两种选择：
- en: '`TestAdd` **to verify the new scenario**: This approach will make the Assert
    step longer, but it has the advantage of reusing the previous steps.'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TestAdd` **用于验证新场景**：这种方法会使断言步骤变长，但它有重用先前步骤的优势。'
- en: '`TestAdd` as is, but it has the disadvantage of us having to redefine and re-execute
    the Arrange and Act steps of the existing test.'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TestAdd`本身，但它有一个缺点，那就是我们必须重新定义和重新执行现有测试的安排和执行步骤。'
- en: 'If we choose to go with the second option, we will have to name the new test
    something different. We will name it `TestAdd_Negative` to signify that we will
    be testing negative inputs in this test. However, this doesn’t fall in line with
    the naming of the existing `TestAdd` function, so we will have to rename the existing
    test to `TestAdd_Positive`. As expected, running the tests will output the result
    on different lines:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择第二个选项，我们就必须给新的测试取一个不同的名字。我们将命名为`TestAdd_Negative`，以表明在这个测试中将测试负输入。然而，这并不符合现有`TestAdd`函数的命名规范，因此我们必须将现有测试重命名为`TestAdd_Positive`。正如预期的那样，运行测试将在不同的行上输出结果：
- en: '[PRE28]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We want to have a small self-contained test, but it would be cumbersome to continue
    to define new tests, potentially having to change the name of existing tests for
    each new edge case or scenario we test. Go provides us with a more elegant solution
    to this common problem, which we will cover in the next section.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望有一个小型的自包含测试，但继续定义新的测试会很麻烦，可能需要为每个新的边缘情况或测试场景更改现有测试的名称。Go为我们提供了一个更优雅的解决方案来解决这个问题，我们将在下一节中介绍。
- en: Implementing subtests
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现子测试
- en: 'The `testing.T` type provides the `Run(name string, f func(t *testing.T)) bool`
    method, which takes in two parameters:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`testing.T`类型提供了`Run(name string, f func(t *testing.T)) bool`方法，它接受两个参数：'
- en: A name parameter of the `string` type
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`string`类型的名称参数
- en: A function that takes in a single parameter of the `*``testing.T` type
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个接受单个`*testing.T`类型参数的函数
- en: 'Once passed to the `Run` method, the test runner will run the function as a
    subtest of the current tests, allowing us to create a test hierarchy, each with
    its own separation. Since the enclosing test and the subtests share the same instance
    of `testing.T`, a subtest failure will cause the enclosing test to fail as well.
    This behavior gives us the ability to create multi-layered test hierarchies according
    to our needs. Taking the example of adding positive and negative inputs as test
    scenarios, we can refactor `TestAdd` to take advantage of the power of subtests:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦传递给`Run`方法，测试运行器将作为当前测试的子测试运行该函数，允许我们创建具有各自分离的测试层次结构。由于封装测试和子测试共享同一个`testing.T`实例，子测试的失败将导致封装测试失败。这种行为使我们能够根据需要创建多层测试层次结构。以添加正负输入作为测试场景为例，我们可以重构`TestAdd`以利用子测试的力量：
- en: '[PRE29]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We create an `actAssert` function that takes in the inputs and expected output
    as parameters. This function will perform the Act and Assert steps without having
    to repeat them. Then, we create two subtests using the `t.Run` method we’ve seen
    before. The name of each subtest indicates what scenario it will cover. Running
    the tests will produce the following result:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`actAssert`函数，该函数接受输入和预期输出作为参数。这个函数将执行执行和断言步骤，而无需重复它们。然后，我们使用之前看到的`t.Run`方法创建两个子测试。每个子测试的名称都表明它将覆盖什么场景。运行测试将产生以下结果：
- en: '[PRE30]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As we can see from the output, the subtests are nested under the enclosing test.
    By leveraging subtests, we now have a convenient way to create tests that share
    the Arrange step, but can also be easily extended with more scenarios without
    the need to rename tests.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从输出中看到的那样，子测试嵌套在封装测试之下。通过利用子测试，我们现在有了一个方便的方式来创建共享安排步骤的测试，同时也可以轻松地扩展更多场景，而无需重命名测试。
- en: We will discuss the related technique of **table-driven testing**, which leverages
    the power of subtests, in [*Chapter 4*](B18371_04.xhtml#_idTextAnchor085), *Building
    Efficient* *Test Suites*.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第四章*](B18371_04.xhtml#_idTextAnchor085)，“构建高效测试套件”中讨论相关的技术**表格驱动测试**，它利用子测试的力量。
- en: Code coverage
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: Now that we know how to write tests that cover different scenarios and how to
    run them, we can have a look at what our **code coverage** is. As we remember
    from [*Chapter 1*](B18371_01.xhtml#_idTextAnchor015), *Getting to Grips with Test-Driven
    Development*, this important metric measures what percentage of your code is exercised
    by tests.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何编写覆盖不同场景的测试以及如何运行它们，我们可以看看我们的**代码覆盖率**。正如我们从[*第一章*](B18371_01.xhtml#_idTextAnchor015)，“掌握测试驱动开发”，这个重要指标衡量了你的代码中有多少百分比被测试执行。
- en: The `go test` command has a `–cover` flag, which computes the code coverage
    profile of the given package. It also offers the possibility of saving the profile
    to a file by passing a file path to the `-coverprofile` flag. We will then see
    how to view these saved coverage profiles.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`go test` 命令有一个 `–cover` 标志，它计算给定包的代码覆盖率配置文件。它还提供了通过传递文件路径给 `-coverprofile`
    标志将配置文件保存到文件中的可能性。然后我们将看到如何查看这些保存的覆盖率配置文件。'
- en: 'Let’s run it for our calculator:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的计算器运行它：
- en: '[PRE31]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This command prints out the coverage percentage after running all the tests.
    We are currently measuring coverage of 100% since our `Add` function is very simple.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在运行所有测试后打印出覆盖率百分比。我们目前测量到的覆盖率是 100%，因为我们的 `Add` 函数非常简单。
- en: Now, let’s save the code coverage profile to a file using `go test ./chapter02/calculator
    -coverprofile=calcCover.out`. This will create the `calcCover.out` file in the
    current directory. We can view this file visually using another tool in the Go
    toolchain. Running `go tool cover -html=calcCover.out` will open a new window
    in your browser to display the coverage profile visually.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 `go test ./chapter02/calculator -coverprofile=calcCover.out` 命令将代码覆盖率配置文件保存到文件中。这将创建当前目录下的
    `calcCover.out` 文件。我们可以使用 Go 工具链中的另一个工具来可视化查看此文件。运行 `go tool cover -html=calcCover.out`
    将在浏览器中打开一个新窗口以可视化显示覆盖率配置文件。
- en: '*Figure 2**.8* shows the visual representation of our cover profile, which
    shows that the `Add` method is covered by tests:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2.8* 显示了我们的覆盖率配置文件的视觉表示，它显示 `Add` 方法被测试覆盖：'
- en: '![Figure 2.8 – The visual representation of the saved profile ](img/Figure_2.08_B18371.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – 保存配置文件的视觉表示](img/Figure_2.08_B18371.jpg)'
- en: Figure 2.8 – The visual representation of the saved profile
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – 保存配置文件的视觉表示
- en: That covers all the essentials we need to know to begin writing Go tests with
    TDD. The last thing we need to tackle is how to write and use benchmarks.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了我们需要了解的所有基本知识，以便开始使用 TDD 编写 Go 测试。最后我们需要解决的是如何编写和使用基准测试。
- en: The difference between a test and a benchmark
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试与基准之间的区别
- en: 'The last concept we will be looking at in this chapter is `testing.B` type.
    They have a signature very similar to tests:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将探讨的最后一个概念是 `testing.B` 类型。它们的签名与测试非常相似：
- en: '[PRE32]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The signature highlights the following requirements for Go benchmarks:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 签名突出了 Go 基准测试的以下要求：
- en: Benchmarks are exported functions whose name begins with `Benchmark`.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基准测试是名称以 `Benchmark` 开头的导出函数。
- en: Benchmark names can have an additional suffix that specifies what the test is
    covering. The suffix must also begin with a capital letter, as we can see with
    `Name`.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基准测试的名称可以有一个额外的后缀，用于指定测试覆盖的内容。后缀也必须以大写字母开头，正如我们在 `Name` 中看到的那样。
- en: Benchmarks must take in a single parameter of the `*testing.B` type. As we’ve
    explained so far, this will be how the test interacts with the test runner. You
    can name the testing parameter however you want, but Go developers typically use
    `b` to denote it.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基准测试必须接受一个 `*testing.B` 类型的单个参数。正如我们迄今为止所解释的，这将是如何测试与测试运行器交互的方式。你可以随意命名测试参数，但
    Go 开发者通常使用 `b` 来表示它。
- en: Benchmarks must not have a return type.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基准测试不能有返回类型。
- en: Benchmarks are an important Go profiling tool
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试是 Go 性能分析的重要工具
- en: Tests verify the functionality of your programs, while benchmarks verify the
    performance of your code. You should use both in your testing strategy.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 测试验证程序的函数性，而基准测试验证代码的性能。你应该在测试策略中使用两者。
- en: 'Benchmarks can also be run with the `go test` command, but we have to specify
    to the runner that we are interested in benchmarks with the `–bench` flag. We
    must supply a regular expression that matches the packages that we want to run.
    We can run all benchmarks by matching all packages in the current directory using
    this command:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `go test` 命令运行基准测试，但我们必须通过 `–bench` 标志告诉运行器我们感兴趣的是基准测试。我们必须提供一个正则表达式来匹配我们想要运行的包。我们可以使用以下命令运行当前目录下所有包的基准测试：
- en: '[PRE33]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `testing.B` type also has access to logging errors and signaling test failures,
    just as we saw in the introduction to the `testing.T` type: `b.Error`, `b.Errorf`,
    `b.Fatal`, and `b.Fatalf`. Just like tests, benchmarks live in test files, which
    must have the `_test.go` suffix to be detected by the Go test runner.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`testing.B` 类型还可以访问记录错误和指示测试失败，就像我们在 `testing.T` 类型的介绍中看到的那样：`b.Error`、`b.Errorf`、`b.Fatal`
    和 `b.Fatalf`。就像测试一样，基准测试位于测试文件中，这些文件必须具有 `_test.go` 后缀才能被 Go 测试运行器检测到。'
- en: 'Let’s write a benchmark for our `Add` function in the `engine_test.go` file:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `engine_test.go` 文件中为我们的 `Add` 函数编写一个基准测试：
- en: '[PRE34]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `BenchmarkAdd` example runs the `Add` function with the parameters in a
    loop for `b.N` times. Go’s test runner controls the value of `N` and will increase
    it until it is satisfied that the numbers it has measured are stable.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`BenchmarkAdd`示例通过循环将`Add`函数的参数运行`b.N`次。Go的测试运行器控制`N`的值，并将增加它，直到它满意所测量的数值是稳定的。'
- en: As with all performance tests, you should be wary of running benchmarks on your
    local machine. You might measure some large variations in measurement according
    to what your computer is processing.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有性能测试一样，你应该小心在本地机器上运行基准测试。根据你的计算机正在处理的内容，你可能会测量一些较大的测量变化。
- en: 'Now, we run our benchmark to see the following output:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们运行基准测试以查看以下输出：
- en: '[PRE35]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output of the benchmark run highlights the following:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试运行的输出突出了以下内容：
- en: 'The name of the benchmark: `BenchmarkAdd`'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基准测试的名称：`BenchmarkAdd`
- en: 'The number of CPU cores used to run the benchmark, added as a suffix to the
    test name: `8`'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行基准测试所使用的CPU核心数，作为测试名称的后缀：`8`
- en: 'How many times the benchmark was executed: `1000000000`'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基准测试执行了多少次：`1000000000`
- en: 'The average amount of time that an individual test iteration took, measured
    in nanoseconds: `0.2684 ns/op`'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个测试迭代平均耗时，以纳秒为单位：`0.2684 ns/op`
- en: Our function is very simple, which is why it has a very low running time. We
    will explore more complex examples of benchmarks in [*Chapter 8*](B18371_08.xhtml#_idTextAnchor179),
    *Testing* *Microservice Architectures*.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能非常简单，这就是为什么它的运行时间非常低。我们将在[*第8章*](B18371_08.xhtml#_idTextAnchor179)，*测试*
    *微服务架构*中探索更复杂的基准测试示例。
- en: Summary
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered all the unit testing essentials that we will need
    to get started with TDD in Go. We began by introducing Go modules and packages,
    as well as where test files are placed and how they declare their additional test
    packages. You learned about the most important methods in Go’s `testing` package
    and started writing some simple unit tests with it. Then, we explored ways to
    reduce code duplication by making use of setup and teardown functions, as well
    as how to better organize tests using subtests. Finally, we learned how to write
    and run benchmarks, which are an important part of any testing strategy.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了所有我们将需要开始使用Go进行TDD的单元测试基本知识。我们首先介绍了Go模块和包，以及测试文件放置的位置以及它们如何声明额外的测试包。你了解了Go的`testing`包中最重要的一些方法，并开始使用它编写一些简单的单元测试。然后，我们探讨了通过使用设置和清理函数来减少代码重复的方法，以及如何使用子测试更好地组织测试。最后，我们学习了如何编写和运行基准测试，这是任何测试策略的重要组成部分。
- en: In [*Chapter 3*](B18371_03.xhtml#_idTextAnchor061), *Mocking and Assertion Frameworks*,
    we will write more complicated tests, which require dependencies. We will explore
    some popular frameworks and begin to use them to write tests that are closer to
    real-world examples.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B18371_03.xhtml#_idTextAnchor061)，*模拟和断言框架*中，我们将编写更复杂的测试，这些测试需要依赖项。我们将探讨一些流行的框架，并开始使用它们编写更接近真实世界示例的测试。
- en: Questions
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章知识的掌握：
- en: In Go, what is the difference between a module and a package?
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Go中，模块和包之间有什么区别？
- en: What is the additional test package? What are some of the advantages of using
    it?
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 附加测试包是什么？使用它的优点有哪些？
- en: What are the requirements for the test signature?
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试签名的要求是什么？
- en: What are subtests and how do you create them?
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子测试是什么？你如何创建它们？
- en: What is a benchmark? How do you write one?
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是基准测试？你如何编写一个？
- en: Further reading
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章所涵盖的主题，请查看以下资源：
- en: The official documentation for the testing package is available at [https://pkg.go.dev/testing](https://pkg.go.dev/testing)
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试包的官方文档可在[https://pkg.go.dev/testing](https://pkg.go.dev/testing)找到
- en: '*The Art of Unit Testing*, by Roy Osherove, published by Manning Publications'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《单元测试的艺术》，由Roy Osherove撰写，由Manning Publications出版
- en: '*Profiling Go Programs* is available on the Go blog at [https://go.dev/blog/pprof](https://go.dev/blog/pprof)'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Go程序分析》可在Go博客上找到：[https://go.dev/blog/pprof](https://go.dev/blog/pprof)
