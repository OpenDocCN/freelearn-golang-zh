<html><head></head><body>
<div id="_idContainer033">
<h1 class="chapter-number" id="_idParaDest-61"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-62"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.2.1">Mocking and Assertion Frameworks</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we explored the fundamentals of writing tests in Go. </span><span class="koboSpan" id="kobo.3.2">We explored the importance of packages, the organization of test files alongside source code, and how to use Go’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.4.1">testing</span></strong><span class="koboSpan" id="kobo.5.1"> package to write tests </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">and benchmarks.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">We demonstrated the concepts and fundamentals of writing tests in Go with code samples from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.8.1">Calculator</span></strong><span class="koboSpan" id="kobo.9.1"> use case. </span><span class="koboSpan" id="kobo.9.2">The simple examples we have looked at so far have not included any external dependencies, which can make test setup and verification much </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">more complex.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">In this chapter, we will begin to look at how we can isolate the unit under test from its dependencies, keeping testing and assertions as simple and fast as possible. </span><span class="koboSpan" id="kobo.11.2">The easiest way to achieve this in Go is by leveraging the power </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">of interfaces.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">We will expand upon the </span><strong class="source-inline"><span class="koboSpan" id="kobo.14.1">Calculator</span></strong><span class="koboSpan" id="kobo.15.1"> example by introducing dependencies to our main components. </span><span class="koboSpan" id="kobo.15.2">Then, we will learn how to generate mocks for these dependencies of the </span><strong class="bold"><span class="koboSpan" id="kobo.16.1">unit under test</span></strong><span class="koboSpan" id="kobo.17.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.18.1">UUT</span></strong><span class="koboSpan" id="kobo.19.1">), enabling us to control </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">their behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.21.1">Then, we will explore some external, open source assertion libraries that are often used by Go engineers. </span><span class="koboSpan" id="kobo.21.2">Up until now, we have written some simple assertions ourselves. </span><span class="koboSpan" id="kobo.21.3">This can be repetitive and limiting. </span><span class="koboSpan" id="kobo.21.4">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.22.1">testify</span></strong><span class="koboSpan" id="kobo.23.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.24.1">ginkgo</span></strong><span class="koboSpan" id="kobo.25.1"> assertion libraries are two popular choices that can be used to supplement Go’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.26.1">testing</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.27.1"> package.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">Finally, we will turn away from exploring test code and mechanisms and look at design techniques for writing testable code by reviewing the </span><strong class="bold"><span class="koboSpan" id="kobo.29.1">SOLID</span></strong><span class="koboSpan" id="kobo.30.1"> principles of object-oriented design. </span><span class="koboSpan" id="kobo.30.2">We will learn what they are and how they can be applied when </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">writing code.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.34.1">Using interfaces to </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">wrap dependencies</span></span></li>
<li><span class="koboSpan" id="kobo.36.1">How to generate and use mocks to test code </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">in isolation</span></span></li>
<li><span class="koboSpan" id="kobo.38.1">The usage of popular </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">assertion frameworks</span></span></li>
<li><span class="koboSpan" id="kobo.40.1">What the </span><strong class="bold"><span class="koboSpan" id="kobo.41.1">SOLID</span></strong><span class="koboSpan" id="kobo.42.1"> design </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">principles are</span></span></li>
<li><span class="koboSpan" id="kobo.44.1">Best practices for writing </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">testable code</span></span></li>
</ul>
<h1 id="_idParaDest-63"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.46.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.47.1">You will need to have </span><strong class="bold"><span class="koboSpan" id="kobo.48.1">Go version 1.19</span></strong><span class="koboSpan" id="kobo.49.1"> or later installed to run the code samples in this chapter. </span><span class="koboSpan" id="kobo.49.2">The installation process is described on the official Go documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">at </span></span><a href="https://go.dev/doc/install"><span class="No-Break"><span class="koboSpan" id="kobo.51.1">https://go.dev/doc/install</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.52.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.53.1">The code examples included in this book are publicly available </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">at </span></span><a href="https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter03"><span class="No-Break"><span class="koboSpan" id="kobo.55.1">https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter03</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.56.1">.</span></span></p>
<h1 id="_idParaDest-64"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.57.1">Interfaces as dependencies</span></h1>
<p><span class="koboSpan" id="kobo.58.1">As always, implementing and </span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.59.1">exploring unit testing techniques begins with exploring code writing techniques. </span><span class="koboSpan" id="kobo.59.2">This is a theme we will see regularly throughout this book. </span><span class="koboSpan" id="kobo.59.3">We cannot study testing in isolation. </span><span class="koboSpan" id="kobo.59.4">It requires insight into the code design and its </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">intended purpose.</span></span></p>
<p><span class="koboSpan" id="kobo.61.1">In this section, we will look </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.62.1">at the concept of </span><strong class="bold"><span class="koboSpan" id="kobo.63.1">software dependencies</span></strong><span class="koboSpan" id="kobo.64.1"> and how to manage them. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.65.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.66.1">.1</span></em><span class="koboSpan" id="kobo.67.1"> depicts the three main types </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">of dependencies:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<span class="koboSpan" id="kobo.69.1"><img alt="Figure 3.1 – Types of dependencies from the point of view of the UUT " src="image/Figure_3.1_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.70.1">Figure 3.1 – Types of dependencies from the point of view of the UUT</span></p>
<p><span class="koboSpan" id="kobo.71.1">From the viewpoint of the UUT, the</span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.72.1"> four main types of dependencies are </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.74.1">Direct internal dependencies</span></strong><span class="koboSpan" id="kobo.75.1">: These contain internal functionality that your </span><strong class="bold"><span class="koboSpan" id="kobo.76.1">UUT</span></strong><span class="koboSpan" id="kobo.77.1"> imports. </span><span class="koboSpan" id="kobo.77.2">These dependencies could be defined in the same package or module as </span><strong class="bold"><span class="koboSpan" id="kobo.78.1">UUT</span></strong><span class="koboSpan" id="kobo.79.1">, but are required to deliver </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">its functionality.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.81.1">Transitive internal dependencies</span></strong><span class="koboSpan" id="kobo.82.1">: These contain internal functionality that the </span><strong class="bold"><span class="koboSpan" id="kobo.83.1">Direct internal dependency</span></strong><span class="koboSpan" id="kobo.84.1"> parts of your </span><strong class="bold"><span class="koboSpan" id="kobo.85.1">UUT</span></strong><span class="koboSpan" id="kobo.86.1"> import. </span><span class="koboSpan" id="kobo.86.2">These dependencies could also be defined in the same package </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">or module.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.88.1">Direct external dependencies</span></strong><span class="koboSpan" id="kobo.89.1">: These contain third-party functionality that your </span><strong class="bold"><span class="koboSpan" id="kobo.90.1">UUT</span></strong><span class="koboSpan" id="kobo.91.1"> imports. </span><span class="koboSpan" id="kobo.91.2">These could be libraries or service APIs that you might rely on, but which are not contained in your </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">current module.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.93.1">Transitive external dependencies</span></strong><span class="koboSpan" id="kobo.94.1">: These contain external functionality that your </span><strong class="bold"><span class="koboSpan" id="kobo.95.1">Direct external dependencies</span></strong><span class="koboSpan" id="kobo.96.1"> rely on, but which are in a separate module. </span><span class="koboSpan" id="kobo.96.2">Due to the way that Go builds the source code and required libraries into runnable executables, these transitive dependencies will also be contained alongside your code during </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">application release.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.98.1">The dependencies of the UUT </span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.99.1">are required for the UUT to be able to correctly deliver its functionality. </span><span class="koboSpan" id="kobo.99.2">Consequently, they are also required to completely test its functionality. </span><span class="koboSpan" id="kobo.99.3">We will explore techniques for handling code dependencies throughout this section </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">and chapter.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.101.1">Don’t reinvent the wheel</span></p>
<p class="callout"><span class="koboSpan" id="kobo.102.1">Writing code that relies on dependencies is a normal, and recommended, practice for software design. </span><span class="koboSpan" id="kobo.102.2">It allows us to reuse behavior and implementation in multiple places. </span><span class="koboSpan" id="kobo.102.3">This, coupled with Go’s powerful module and package system, makes it easy and fast to write complex code. </span><span class="koboSpan" id="kobo.102.4">We explored Go’s modules and packages in </span><a href="B18371_02.xhtml#_idTextAnchor035"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.103.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.104.1">, </span><em class="italic"><span class="koboSpan" id="kobo.105.1">Unit </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.106.1">Testing Essentials</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">.</span></span></p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.108.1">Dependency injection</span></h2>
<p><span class="koboSpan" id="kobo.109.1">One popular and common technique for handling dependencies in code is the concept of </span><strong class="bold"><span class="koboSpan" id="kobo.110.1">dependency injection</span></strong><span class="koboSpan" id="kobo.111.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.112.1">DI</span></strong><span class="koboSpan" id="kobo.113.1">). </span><span class="koboSpan" id="kobo.113.2">This is a simple yet effective design pattern for creating loosely coupled code, which</span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.114.1"> allows us to implement code without the concerns of </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">its dependencies.</span></span></p>
<p><span class="koboSpan" id="kobo.116.1">DI is a style of writing code in which the UUT or function receives other types or functions that it depends on during initialization. </span><span class="koboSpan" id="kobo.116.2">Fundamentally, DI is nothing more than passing the correct parameters to a function, which then uses these to create </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">the UUT.</span></span></p>
<p><span class="koboSpan" id="kobo.118.1">This technique is one of the principles </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.119.1">of SOLID design, namely the letter </span><em class="italic"><span class="koboSpan" id="kobo.120.1">D</span></em><span class="koboSpan" id="kobo.121.1">, which stands for the principle of </span><strong class="bold"><span class="koboSpan" id="kobo.122.1">dependency inversion</span></strong><span class="koboSpan" id="kobo.123.1">. </span><span class="koboSpan" id="kobo.123.2">We will explore all the principles later in this chapter, in the </span><em class="italic"><span class="koboSpan" id="kobo.124.1">Writing testable </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.125.1">code</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.126.1"> section.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.127.1">Why is it called injection?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.128.1">The term </span><em class="italic"><span class="koboSpan" id="kobo.129.1">injection</span></em><span class="koboSpan" id="kobo.130.1"> simply signifies that the</span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.131.1"> dependencies are not created by the UUT that requires them but passed to it from further up the stack. </span><span class="koboSpan" id="kobo.131.2">They can be injected either by constructor/function injection or by the use </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">of frameworks.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.133.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.134.1">.2</span></em><span class="koboSpan" id="kobo.135.1"> describes the main steps of what DI </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">typically entails:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<span class="koboSpan" id="kobo.137.1"><img alt="Figure 3.2 – The main steps of dependency injection " src="image/Figure_3.2_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.138.1">Figure 3.2 – The main steps of dependency injection</span></p>
<p><span class="koboSpan" id="kobo.139.1">We can see the following sequence </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">of calls:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.141.1">At the start, we begin by attempting to </span><strong class="bold"><span class="koboSpan" id="kobo.142.1">Initialize the UUT</span></strong><span class="koboSpan" id="kobo.143.1">. </span><span class="koboSpan" id="kobo.143.2">In Go, the UUT is usually a </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">struct</span></strong><span class="koboSpan" id="kobo.145.1">. </span><span class="koboSpan" id="kobo.145.2">We already know that Go structs do not provide constructors, so the</span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.146.1"> initialization process will involve inspecting the dependencies that the UUT requires. </span><span class="koboSpan" id="kobo.146.2">We will see techniques for making the need for dependencies explicit in the </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">next section.</span></span></li>
<li><span class="koboSpan" id="kobo.148.1">If the UUT has any direct dependencies, then we will </span><strong class="bold"><span class="koboSpan" id="kobo.149.1">Request the direct dependency</span></strong><span class="koboSpan" id="kobo.150.1">. </span><span class="koboSpan" id="kobo.150.2">This direct dependency will also typically be a </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">struct</span></strong><span class="koboSpan" id="kobo.152.1">, either from the same module or another </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">external module.</span></span></li>
<li><span class="koboSpan" id="kobo.154.1">When initializing the direct dependency, we might discover transitive dependencies that the direct dependencies need during initialization. </span><span class="koboSpan" id="kobo.154.2">We will then </span><strong class="bold"><span class="koboSpan" id="kobo.155.1">Request the </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.156.1">transitive dependency</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.158.1">The dependency request process is repeated for all direct and </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">transitive dependencies.</span></span></li>
<li><span class="koboSpan" id="kobo.160.1">Once each dependency has been successfully created, it is injected into the creation of the previous</span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.161.1"> dependency or the UUT, if it is a </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">direct dependency.</span></span></li>
</ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.163.1">The dependency graph</span></p>
<p class="callout"><span class="koboSpan" id="kobo.164.1">Due to the way that </span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.165.1">dependencies need to be created and then, in turn, injected, this process is known as </span><em class="italic"><span class="koboSpan" id="kobo.166.1">constructing the dependency graph</span></em><span class="koboSpan" id="kobo.167.1">. </span><span class="koboSpan" id="kobo.167.2">This is a directed, acyclic graph. </span><span class="koboSpan" id="kobo.167.3">This graph allows the compiler to start at the root and then traverse it while building all the custom types it requires while running the </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">main program.</span></span></p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.169.1">Implementing dependency injection</span></h2>
<p><span class="koboSpan" id="kobo.170.1">While introducing DI, we briefly mentioned </span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.171.1">that structs do not have constructors and therefore this process might require the investigation of the properties and fields of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">struct</span></strong><span class="koboSpan" id="kobo.173.1">. </span><span class="koboSpan" id="kobo.173.2">Let us have a look at how we can implement DI </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">in Go.</span></span></p>
<p><span class="koboSpan" id="kobo.175.1">Fundamentally, there are two ways we can go about </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">injecting dependencies:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.177.1">Constructor injection</span></strong><span class="koboSpan" id="kobo.178.1">: This consists of passing all the required dependencies to a special constructor function, which will then return an instance of the UUT </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">struct</span></strong><span class="koboSpan" id="kobo.180.1">. </span><span class="koboSpan" id="kobo.180.2">This is an intuitive way to</span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.181.1"> construct instances, but it does require that all dependencies be created before the invocation of </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">the function.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.183.1">Property/method injection</span></strong><span class="koboSpan" id="kobo.184.1">: This consists of creating the UUT </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">struct</span></strong><span class="koboSpan" id="kobo.186.1"> and then setting the fields of the dependencies as you require them. </span><span class="koboSpan" id="kobo.186.2">This can either be done by directly setting them </span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.187.1">as fields on the UUT instance, or by invoking setter methods that set them on the fields. </span><span class="koboSpan" id="kobo.187.2">The dependencies are not immutable, so they do not require the UUT instance to be recreated as they are set. </span><span class="koboSpan" id="kobo.187.3">This way of creating the UUT and its dependencies does not require that all dependencies be created before initializing and beginning to use the UUT, but it also does not guarantee that all the dependencies will be set by a certain time, nor does it guarantee they </span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.188.1">won’t be changed later. </span><span class="koboSpan" id="kobo.188.2">This could require more application code for </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">nil</span></strong><span class="koboSpan" id="kobo.190.1"> value checks, as well as other subtle bugs if </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">dependencies change.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.192.1">Then, each method can be used in </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">two ways:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.194.1">Manual invocation</span></strong><span class="koboSpan" id="kobo.195.1">: This means that we call and create the UUT struct and its dependencies manually. </span><span class="koboSpan" id="kobo.195.2">In this process, you have full control over the creation and invocation of dependencies, but they can become difficult to manage for </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">larger codebases.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.197.1">Dependency injection frameworks</span></strong><span class="koboSpan" id="kobo.198.1">: This means that you import another dependency into your project that can automate this process using advanced techniques such as reflection or code generation, which then leverage the dependency graph to</span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.199.1"> create the dependencies in the correct sequence. </span><span class="koboSpan" id="kobo.199.2">This method is much more sustainable for </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">large codebases.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.201.1">When it comes to DI frameworks, there are two popular open source choices that you can use in </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">your code:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">dig</span></strong><span class="koboSpan" id="kobo.204.1">: This uses reflection to build your dependency graph and successfully construct your instances. </span><span class="koboSpan" id="kobo.204.2">You can read about how to use it </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">at </span></span><a href="https://github.com/uber-go/dig"><span class="No-Break"><span class="koboSpan" id="kobo.206.1">https://github.com/uber-go/dig</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.207.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">wire</span></strong><span class="koboSpan" id="kobo.209.1">: This uses reflection and code generation for DI. </span><span class="koboSpan" id="kobo.209.2">You can read about how to use it </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">at </span></span><a href="https://github.com/google/wire"><span class="No-Break"><span class="koboSpan" id="kobo.211.1">https://github.com/google/wire</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.212.1">.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.213.1">Reducing complexity</span></p>
<p class="callout"><span class="koboSpan" id="kobo.214.1">Remember that one of the core principles of Go code and software design is simplicity. </span><span class="koboSpan" id="kobo.214.2">You should keep your code as simple as possible, avoiding the lengthy constructors that have been seen in other </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">legacy languages.</span></span></p>
<p><span class="koboSpan" id="kobo.216.1">When it comes to dependencies, they are usually represented using corresponding interface types. </span><span class="koboSpan" id="kobo.216.2">This is an approach unique to Go, regardless of how you choose to inject your dependencies. </span><span class="koboSpan" id="kobo.216.3">Let us look at their role in software design a little bit </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">more closely.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.218.1">Interfaces</span></strong><span class="koboSpan" id="kobo.219.1"> are</span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.220.1"> named collections of zero </span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.221.1">or more methods. </span><span class="koboSpan" id="kobo.221.2">Here are some key highlights of </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">their behavior:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.223.1">The y are the primary way</span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.224.1"> we can achieve </span><strong class="bold"><span class="koboSpan" id="kobo.225.1">polymorphism</span></strong><span class="koboSpan" id="kobo.226.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">in Go.</span></span></li>
<li><span class="koboSpan" id="kobo.228.1">The compiler enforces them and implicitly casts a </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">struct</span></strong><span class="koboSpan" id="kobo.230.1"> to its </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">corresponding interface.</span></span></li>
<li><span class="koboSpan" id="kobo.232.1">To implement an interface, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">struct</span></strong><span class="koboSpan" id="kobo.234.1"> needs to implement its </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">defined methods.</span></span></li>
<li><span class="koboSpan" id="kobo.236.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">struct</span></strong><span class="koboSpan" id="kobo.238.1"> can implement multiple interfaces, so long as it satisfies its </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">method signatures.</span></span></li>
<li><span class="koboSpan" id="kobo.240.1">An interface with zero methods is the empty interface and its type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">interface</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.242.1">{}</span></strong><span class="koboSpan" id="kobo.243.1">. </span><span class="koboSpan" id="kobo.243.2">This is useful in certain cases, but the interfaces you create will have one or </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">more methods.</span></span></li>
<li><span class="koboSpan" id="kobo.245.1">The zero value of interfaces is nil. </span><span class="koboSpan" id="kobo.245.2">We will need to handle this in our code as we begin to use interfaces to wrap around </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">our dependencies.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.247.1">Interfaces define methods, not functions</span></p>
<p class="callout"><span class="koboSpan" id="kobo.248.1">Remember that interfaces define methods, not functions. </span><span class="koboSpan" id="kobo.248.2">As we’ve seen with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">Engine</span></strong><span class="koboSpan" id="kobo.250.1"> definition, methods that correspond to the signature of the interface will need to be defined on the struct we want to use in place of </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">this interface.</span></span></p>
<p><span class="koboSpan" id="kobo.252.1">Let us look at a DI example; this can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">chapter03/di/manual/calculator.go</span></strong><span class="koboSpan" id="kobo.254.1">. </span><span class="koboSpan" id="kobo.254.2">We can define a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">Adder</span></strong><span class="koboSpan" id="kobo.256.1"> interface with the </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">following snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.258.1">
type Adder interface {
</span><strong class="bold"><span class="koboSpan" id="kobo.259.1">  Add(x, y float64) float64</span></strong><span class="koboSpan" id="kobo.260.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.261.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">Adder</span></strong><span class="koboSpan" id="kobo.263.1"> interface defines the </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">Add</span></strong><span class="koboSpan" id="kobo.265.1"> method. </span><span class="koboSpan" id="kobo.265.2">Note that this method takes in two </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">float64</span></strong><span class="koboSpan" id="kobo.267.1"> parameters and returns one </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">float64</span></strong><span class="koboSpan" id="kobo.269.1"> return value. </span><span class="koboSpan" id="kobo.269.2">In our case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">Engine</span></strong><span class="koboSpan" id="kobo.271.1"> will satisfy this interface as it implements </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">this method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.273.1">
func (e Engine)</span><strong class="bold"><span class="koboSpan" id="kobo.274.1"> Add(x, y float64) float64</span></strong><span class="koboSpan" id="kobo.275.1"> {
  return x + y
}</span></pre>
<p><span class="koboSpan" id="kobo.276.1">When we initialize </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">Engine</span></strong><span class="koboSpan" id="kobo.278.1">, we can return the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">Engine</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.280.1"> struct:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.281.1">
func NewEngine() </span><strong class="bold"><span class="koboSpan" id="kobo.282.1">*Engine</span></strong><span class="koboSpan" id="kobo.283.1"> {
  return &amp;Engine{}
}</span></pre>
<p><span class="koboSpan" id="kobo.284.1">A simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">Calculator</span></strong><span class="koboSpan" id="kobo.286.1"> then makes use of this </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">Engine</span></strong><span class="koboSpan" id="kobo.288.1"> for its adder functionality and prints out </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">the result:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.290.1">
type Calculator struct {
  Adder Adder
}
func </span><strong class="bold"><span class="koboSpan" id="kobo.291.1">NewCalculator(a Adder) *Calculator</span></strong><span class="koboSpan" id="kobo.292.1"> {
  return &amp;Calculator{Adder: a}
}
func (c Calculator) PrintAdd(x, y float64) {
  fmt.Println("Result:", c.Adder.Add(x, y))
}</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">Engine</span></strong><span class="koboSpan" id="kobo.294.1"> is a dependency of </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">Calculator</span></strong><span class="koboSpan" id="kobo.296.1">, so it is a parameter of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">NewCalculator</span></strong><span class="koboSpan" id="kobo.298.1"> function. </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">Adder</span></strong><span class="koboSpan" id="kobo.300.1"> is then invoked inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">PrintAdd</span></strong><span class="koboSpan" id="kobo.302.1"> method, where its functionality is required. </span><span class="koboSpan" id="kobo.302.2">Therefore, the initialization process of </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">Calculator</span></strong><span class="koboSpan" id="kobo.304.1"> requires an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">Engine</span></strong><span class="koboSpan" id="kobo.306.1"> to be created </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">to compile:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.308.1">
 func main() {
</span><strong class="bold"><span class="koboSpan" id="kobo.309.1">  engine := NewEngine()</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.310.1">  calc := NewCalculator(engine)</span></strong><span class="koboSpan" id="kobo.311.1">
  calc.PrintAdd(2.5, 6.3)
}</span></pre>
<p><span class="koboSpan" id="kobo.312.1">This example uses the </span><em class="italic"><span class="koboSpan" id="kobo.313.1">manual invocation</span></em><span class="koboSpan" id="kobo.314.1"> of DI. </span><span class="koboSpan" id="kobo.314.2">As the dependency graph grows in size and complexity, this initialization function will become increasingly cumbersome and require changes. </span><span class="koboSpan" id="kobo.314.3">This is</span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.315.1"> where DI frameworks can help simplify </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">our code.</span></span></p>
<p><span class="koboSpan" id="kobo.317.1">Using the previously introduced </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">wire</span></strong><span class="koboSpan" id="kobo.319.1"> framework, we can define an </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">InitCalc</span></strong><span class="koboSpan" id="kobo.321.1"> function in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">/chapter03/di/wire/wire.go</span></strong><span class="koboSpan" id="kobo.323.1"> file, which will take care of initializing </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">Calculator</span></strong><span class="koboSpan" id="kobo.325.1"> with </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">its </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">Engine</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.329.1">//go:build wireinject</span></strong><span class="koboSpan" id="kobo.330.1">
package main
import "github.com/google/wire"
var Set = wire.NewSet(NewEngine, wire.Bind(new(Adder), new(*Engine)), NewCalculator)
func InitCalc() *Calculator {
  wire.Build(Set)
  return nil
}</span></pre>
<p><span class="koboSpan" id="kobo.331.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">wire.Build</span></strong><span class="koboSpan" id="kobo.333.1"> function takes in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">Set</span></strong><span class="koboSpan" id="kobo.335.1"> that matches the </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">Adder</span></strong><span class="koboSpan" id="kobo.337.1"> interface to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">Engine</span></strong><span class="koboSpan" id="kobo.339.1"> struct. </span><span class="koboSpan" id="kobo.339.2">At the top of the file, we make use of a build tag to exclude this file from the final binary, and use the generated replacement file when we run </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">our application.</span></span></p>
<p><span class="koboSpan" id="kobo.341.1">Next, we must install the wire tool and run it in the </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">correct directory:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.343.1">
$ go install github.com/google/wire/cmd/wire@latest
$ cd chapter03/di/wire &amp;&amp; wire
wire: github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter03/di/wire: wrote /Users/adelinasimion/code/Test-Driven-Development-in-Go/chapter03/di/wire/</span><strong class="bold"><span class="koboSpan" id="kobo.344.1">wire_gen.go</span></strong></pre>
<p><span class="koboSpan" id="kobo.345.1">This command generates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">wire_gen.go</span></strong><span class="koboSpan" id="kobo.347.1"> file, which contains the implementation of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">InitCalc</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.349.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.350.1">
func InitCalc() *Calculator {
  adder := NewEngine()
  calculator := NewCalculator(adder)
  return calculator
}</span></pre>
<p><span class="koboSpan" id="kobo.351.1">This function contains the dependency creation code that we had previously written by hand. </span><span class="koboSpan" id="kobo.351.2">As it is now maintained and generated by wire, changes will not have to be maintained manually</span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.352.1"> and the main function is </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">now simpler:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.354.1">
func main() {
  calc := InitCalc()
  calc.PrintAdd(2.5, 6.3)
}</span></pre>
<p><span class="koboSpan" id="kobo.355.1">Finally, we can build the application, generating the initialization function and binding it into the Go binary. </span><span class="koboSpan" id="kobo.355.2">Then, we can run the executable </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">as usual:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.357.1">
$ go build./chapter03/di/wire
$ ./wire
Result: 8.8</span></pre>
<p><span class="koboSpan" id="kobo.358.1">DI frameworks simplify the code we write and maintain but do require adding new steps to the build process, as well as an extra cognitive load when first starting with them. </span><span class="koboSpan" id="kobo.358.2">We explored how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">wire</span></strong><span class="koboSpan" id="kobo.360.1"> DI library works in this section, but we will be using manual injection going forward so that we have more control and can explore the code </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">together better.</span></span></p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.362.1">Use case – continued implementation of the calculator</span></h2>
<p><span class="koboSpan" id="kobo.363.1">In this section, we will make use of the techniques </span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.364.1">we have seen so far to expand upon the implementation of the calculator from </span><a href="B18371_02.xhtml#_idTextAnchor035"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.365.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.366.1">, </span><em class="italic"><span class="koboSpan" id="kobo.367.1">Unit </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.368.1">Testing Essentials</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.370.1">Setting aside the correct </span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.371.1">procedure of </span><strong class="bold"><span class="koboSpan" id="kobo.372.1">test-driven development</span></strong><span class="koboSpan" id="kobo.373.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.374.1">TDD</span></strong><span class="koboSpan" id="kobo.375.1">), let us consider this sketched implementation</span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.376.1"> of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">input.Parse</span><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.378.1">r</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.379.1"> struct:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.380.1">type Parser struct {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.381.1">  </span></strong><strong class="bold"><span class="koboSpan" id="kobo.382.1">engine    *calculator.Engine</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.383.1">  validator *Validator</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.384.1">}</span></strong><span class="koboSpan" id="kobo.385.1">
// ProcessExpression parses an expression and sends it to
// the calculator
func (p *Parser) </span><strong class="bold"><span class="koboSpan" id="kobo.386.1">ProcessExpression(expr string) (*string, </span><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.387.1">error)</span></strong><span class="koboSpan" id="kobo.388.1"> {
  operation, err := p.ge</span><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.389.1">tOperation(expr)
  if err != nil {
    return nil, format.Error(expr, err)
  }
</span><strong class="bold"><span class="koboSpan" id="kobo.390.1">  return p.engine.ProcessOperation(*operation)</span></strong><span class="koboSpan" id="kobo.391.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.392.1">As we know from </span><a href="B18371_02.xhtml#_idTextAnchor035"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.393.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.394.1">, </span><em class="italic"><span class="koboSpan" id="kobo.395.1">Unit Testing Essentials</span></em><span class="koboSpan" id="kobo.396.1">, where we first looked at this example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">Parser</span></strong><span class="koboSpan" id="kobo.398.1"> depends on </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">Validator</span></strong><span class="koboSpan" id="kobo.400.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">calculator.Engine</span></strong><span class="koboSpan" id="kobo.402.1">. </span><span class="koboSpan" id="kobo.402.2">These two structs are the direct dependencies of </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">Parser</span></strong><span class="koboSpan" id="kobo.404.1">. </span><span class="koboSpan" id="kobo.404.2">Then, these dependencies are used to deliver the functionality of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">ProcessExpression</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.406.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.407.1">Regardless of whether we use third-party DI frameworks or we create the corresponding structs manually, writing tests for this relatively simple code </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">snippet involves:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.409.1">Initializing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">Parser</span></strong><span class="koboSpan" id="kobo.411.1"> struct with all its direct and transitive dependencies. </span><span class="koboSpan" id="kobo.411.2">This could involve a lengthy setup, with external dependencies that might extend the scope of </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">the test.</span></span></li>
<li><span class="koboSpan" id="kobo.413.1">Once these main building blocks have been created, we need to set up their pre-condition state. </span><span class="koboSpan" id="kobo.413.2">This could involve an even more complicated setup, which could have unintended consequences </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">as well.</span></span></li>
<li><span class="koboSpan" id="kobo.415.1">When it comes to verification, we might need to assert the internal state of dependencies to ensure that they are behaving as expected. </span><span class="koboSpan" id="kobo.415.2">This reliance on the internal state of dependencies would then make the tests more brittle since changes to the dependencies would break </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">the tests.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.417.1">Now that we understand how to build code that requires direct dependencies, we will begin to explore</span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.418.1"> mechanisms that can help us in testing such dependencies. </span><span class="koboSpan" id="kobo.418.2">We will leverage Go development tools to make testing and </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">assertions easier.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.420.1">Controlling test scope</span></p>
<p class="callout"><span class="koboSpan" id="kobo.421.1">When it comes to types that have many dependencies, the scope of the test setup and assertion can increase beyond the UUT. </span><span class="koboSpan" id="kobo.421.2">We need a mechanism that allows us to test the UUT in isolation, which also has the benefit of keeping the test </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">scope small.</span></span></p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.423.1">Exploring mocks</span></h1>
<p><span class="koboSpan" id="kobo.424.1">In this section, we will explore one of the mechanisms that allows us to test code that relies on dependencies. </span><span class="koboSpan" id="kobo.424.2">We</span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.425.1"> will see how to use and generate mocks, allowing us to verify the UUT in isolation from the behavior of </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">its dependencies.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.427.1">Mocks</span></strong><span class="koboSpan" id="kobo.428.1"> are sometimes known as </span><strong class="bold"><span class="koboSpan" id="kobo.429.1">test doubles</span></strong><span class="koboSpan" id="kobo.430.1"> and are a simple but powerful concept. </span><span class="koboSpan" id="kobo.430.2">They satisfy the</span><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.431.1"> interfaces</span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.432.1"> but are fake versions of the real implementations. </span><span class="koboSpan" id="kobo.432.2">We have full control over these fake implementations, giving us the freedom to control their behavior. </span><span class="koboSpan" id="kobo.432.3">However, if the real implementation changes and our mocks do not, then our tests will give us </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">false confidence.</span></span></p>
<p><span class="koboSpan" id="kobo.434.1">In Go, we have the following different </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">mocking options:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.436.1">Function substitution</span></strong><span class="koboSpan" id="kobo.437.1">: This means sending replacement fake functions to the UUT. </span><span class="koboSpan" id="kobo.437.2">This is easy to do in Go, which </span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.438.1">has native support for </span><strong class="bold"><span class="koboSpan" id="kobo.439.1">higher-order functions</span></strong><span class="koboSpan" id="kobo.440.1">. </span><span class="koboSpan" id="kobo.440.2">We can override function variables and</span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.441.1"> parameters, replacing the behavior of </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">the UUT.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.443.1">Interface substitution</span></strong><span class="koboSpan" id="kobo.444.1">: This means injecting fake versions of the interfaces that the UUT depends on. </span><span class="koboSpan" id="kobo.444.2">These</span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.445.1"> are fake stubbed implementations that satisfy the interfaces of the real implementation. </span><span class="koboSpan" id="kobo.445.2">They can then be used to replace the full implementations, without the UUT even being aware </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">of it.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.447.1">Higher-order function refresher</span></p>
<p class="callout"><span class="koboSpan" id="kobo.448.1">A higher-order function is a </span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.449.1">function that either takes in another function as a parameter or returns a function. </span><span class="koboSpan" id="kobo.449.2">Go functions are just like any </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">other type.</span></span></p>
<p><span class="koboSpan" id="kobo.451.1">The use of function</span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.452.1"> substitution is less prevalent than interface substitution and should be used sparingly since it can make code </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">less readable.</span></span></p>
<p><span class="koboSpan" id="kobo.454.1">Now, let us change our code to be </span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.455.1">able to take advantage of </span><strong class="bold"><span class="koboSpan" id="kobo.456.1">interface substitution</span></strong><span class="koboSpan" id="kobo.457.1">. </span><span class="koboSpan" id="kobo.457.2">First, we will define the two interfaces that we will </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">be calling:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.459.1">
// OperationProcessor is the interface for processing
// mathematical expressions
</span><strong class="bold"><span class="koboSpan" id="kobo.460.1">type OperationProcessor interface</span></strong><span class="koboSpan" id="kobo.461.1"> {
  ProcessOperation(operation *calculator.Operation) (*string, error)
}
// ValidationHelper is the interface for input validation
</span><strong class="bold"><span class="koboSpan" id="kobo.462.1">type ValidationHelper interface </span></strong><span class="koboSpan" id="kobo.463.1">{
  CheckInput(operator string, operands []float64) error
}</span></pre>
<p><span class="koboSpan" id="kobo.464.1">The following points describe the </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">preceding code:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.466.1">We begin by defining interfaces for the external functionality that we want to leverage in the UUT. </span><span class="koboSpan" id="kobo.466.2">In our case, the UUT is </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">input.Parser</span></strong><span class="koboSpan" id="kobo.468.1"> and we will need </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">two dependencies:</span></span><ul><li><span class="koboSpan" id="kobo.470.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">OperationProcessor</span></strong><span class="koboSpan" id="kobo.472.1"> interface wraps around the </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">ProcessOperation</span></strong><span class="koboSpan" id="kobo.474.1"> method. </span><span class="koboSpan" id="kobo.474.2">This functionality will be satisfied by </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">calculator.Engine</span></strong><span class="koboSpan" id="kobo.476.1"> and will calculate the mathematical result of the parsed operator </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">and operands.</span></span></li><li><span class="koboSpan" id="kobo.478.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">ValidationHelper</span></strong><span class="koboSpan" id="kobo.480.1"> interface wraps around the </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">CheckInput</span></strong><span class="koboSpan" id="kobo.482.1"> method. </span><span class="koboSpan" id="kobo.482.2">This functionality will be satisfied by </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">input.Validator</span></strong><span class="koboSpan" id="kobo.484.1"> and will ensure that </span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.485.1">the user-supplied input can </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">be processed.</span></span></li></ul></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.487.1">Exported dependency interfaces</span></p>
<p class="callout"><span class="koboSpan" id="kobo.488.1">Note that the interfaces wrapping around dependencies have been exported, as can be seen by their capitalized names. </span><span class="koboSpan" id="kobo.488.2">It is common practice for interfaces to be exported and their corresponding structs to stay inside the package scope. </span><span class="koboSpan" id="kobo.488.3">This allows us to have fine-grained control over what functionality is exposed outside of the </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">current package.</span></span></p>
<p><span class="koboSpan" id="kobo.490.1">Then, we wrap the dependencies of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">input.Parser</span></strong><span class="koboSpan" id="kobo.492.1"> type with the newly </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">defined interfaces:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.494.1">
// Parser is responsible for converting input to
// mathematical operations
type Parser struct {
</span><strong class="bold"><span class="koboSpan" id="kobo.495.1">  engine    </span></strong><strong class="bold"><span class="koboSpan" id="kobo.496.1">OperationProcessor</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.497.1">  validator ValidationHelper</span></strong><span class="koboSpan" id="kobo.498.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.499.1">As we discussed in the previous section, </span><em class="italic"><span class="koboSpan" id="kobo.500.1">Interfaces as dependencies</span></em><span class="koboSpan" id="kobo.501.1">, Go dependencies are usually represented as interfaces, instead of struct types. </span><span class="koboSpan" id="kobo.501.2">This allows us to inject any type that satisfies the given interface, as opposed to only the concrete </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">struct</span></strong><span class="koboSpan" id="kobo.503.1">. </span><span class="koboSpan" id="kobo.503.2">This is a very </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">powerful mechanism.</span></span></p>
<p><span class="koboSpan" id="kobo.505.1">Another big advantage of using interfaces to represent dependencies is that they allow us to break the dependencies between packages, and write </span><strong class="bold"><span class="koboSpan" id="kobo.506.1">loosely </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.507.1">coupled code</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.509.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.510.1">.3</span></em><span class="koboSpan" id="kobo.511.1"> depicts how we can break </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">hard dependencies:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer030">
<span class="koboSpan" id="kobo.513.1"><img alt="Figure 3.3 – Creating loosely coupled code using interfaces " src="image/Figure_3.3_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.514.1">Figure 3.3 – Creating loosely coupled code using interfaces</span></p>
<p><span class="koboSpan" id="kobo.515.1">As we can see, representing dependencies by using internally defined interfaces allows us to break the hard dependencies between modules. </span><span class="koboSpan" id="kobo.515.2">The underlying external </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">struct</span></strong><span class="koboSpan" id="kobo.517.1"> that satisfies</span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.518.1"> this interface can be created and injected into the UUT outside this package, without introducing a </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">hard dependency.</span></span></p>
<p><span class="koboSpan" id="kobo.520.1">Furthermore, since structs can satisfy multiple interfaces, they also give us the flexibility to reduce the scope of operations that we want to have access to inside the UUT. </span><span class="koboSpan" id="kobo.520.2">This is particularly useful when working with large SDKs or complex external APIs, where we might not want to define or mock all </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">the functions.</span></span></p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.522.1">Mocking frameworks</span></h2>
<p><span class="koboSpan" id="kobo.523.1">Now that we have refactored the code to leverage the power of interfaces and create loosely coupled code, let us see how we can make use of their power during testing </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.525.1">When it comes to creating mocks, two popular mocking frameworks allow us to easily generate and assert </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">on </span></span><span class="No-Break"><a id="_idIndexMarker239"/></span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">mocks:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">golang/mock</span></strong><span class="koboSpan" id="kobo.529.1"> is an open source framework that was first released in March 2011. </span><span class="koboSpan" id="kobo.529.2">You can read all about it at </span><a href="https://github.com/golang/mock"><span class="koboSpan" id="kobo.530.1">https://github.com/golang/mock</span></a><span class="koboSpan" id="kobo.531.1">. </span><span class="koboSpan" id="kobo.531.2">It consists of a mocking package and a code generation </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">tool, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">mockgen</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">testify/mock</span></strong><span class="koboSpan" id="kobo.536.1"> is an open source framework that was released in October 2012. </span><span class="koboSpan" id="kobo.536.2">You can read all about it at </span><a href="https://github.com/stretchr/testify/#mock-package"><span class="koboSpan" id="kobo.537.1">https://github.com/stretchr/testify/#mock-package</span></a><span class="koboSpan" id="kobo.538.1">. </span><span class="koboSpan" id="kobo.538.2">Just like </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">golang/mock</span></strong><span class="koboSpan" id="kobo.540.1">, it consists of a mocking package and a code generation </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">tool, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">mockery</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.544.1">The two frameworks offer a lot of similar functionality, so choosing one can seem like a bit of an arbitrary choice. </span><span class="koboSpan" id="kobo.544.2">At the time of writing, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">testify/mock</span></strong><span class="koboSpan" id="kobo.546.1"> package has been imported by over 13,000 packages (see </span><a href="https://pkg.go.dev/github.com/stretchr/testify/mock?tab=importedby"><span class="koboSpan" id="kobo.547.1">https://pkg.go.dev/github.com/stretchr/testify/mock?tab=importedby</span></a><span class="koboSpan" id="kobo.548.1">), while the </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">golang/mock</span></strong><span class="koboSpan" id="kobo.550.1"> package has been imported by over 12,000 packages (see </span><a href="https://pkg.go.dev/github.com/golang/mock/gomock?tab=importedby"><span class="koboSpan" id="kobo.551.1">https://pkg.go.dev/github.com/golang/mock/gomock?tab=importedby</span></a><span class="koboSpan" id="kobo.552.1">). </span><span class="koboSpan" id="kobo.552.2">This further underlines that they are two very popular frameworks for </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">Go developers.</span></span></p>
<p><span class="koboSpan" id="kobo.554.1">As we will see in the next section, </span><em class="italic"><span class="koboSpan" id="kobo.555.1">Working with assertion frameworks</span></em><span class="koboSpan" id="kobo.556.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">testify</span></strong><span class="koboSpan" id="kobo.558.1"> also provides a very powerful and popular assertion framework. </span><span class="koboSpan" id="kobo.558.2">Therefore, we will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">testify/mock</span></strong><span class="koboSpan" id="kobo.560.1"> as our mocking solution throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.562.1">To use this framework, you will need to install its two main components by running these commands, which are correct at the time </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">of writing:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.564.1">
$ go get github.com/stretchr/testify
$ go install github.com/vektra/mockery/v2@latest</span></pre>
<p><span class="koboSpan" id="kobo.565.1">These two commands will set up the framework for us to use going forward. </span><span class="koboSpan" id="kobo.565.2">Make sure you run these two commands to be able to follow along with the code examples provided throughout this book. </span><span class="koboSpan" id="kobo.565.3">While we will use this framework for mocking, the concepts discussed apply to </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">golang/mock</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.567.1">as well.</span></span></p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.568.1">Generating mocks</span></h2>
<p><span class="koboSpan" id="kobo.569.1">So far, we have</span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.570.1"> prepared our dependencies, selected a mocking framework, and then installed it. </span><span class="koboSpan" id="kobo.570.2">Now, let us learn how to put it to use. </span><span class="koboSpan" id="kobo.570.3">We previously mentioned that </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">testify</span></strong><span class="koboSpan" id="kobo.572.1"> provides a code-generation tool for creating mocks. </span><span class="koboSpan" id="kobo.572.2">This tool makes it easy to generate boilerplate mock code so that we do not need to create and maintain it </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">by hand.</span></span></p>
<p><span class="koboSpan" id="kobo.574.1">Mock generation in </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">testify</span></strong><span class="koboSpan" id="kobo.576.1"> does not require any special annotations. </span><span class="koboSpan" id="kobo.576.2">Mocks can be generated for interfaces and functions, making</span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.577.1"> them suitable</span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.578.1"> for both </span><strong class="bold"><span class="koboSpan" id="kobo.579.1">function substitution</span></strong><span class="koboSpan" id="kobo.580.1"> and </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.581.1">interface substitution</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.583.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">mockery</span></strong><span class="koboSpan" id="kobo.585.1"> command has support for a variety of flags. </span><span class="koboSpan" id="kobo.585.2">Here are some common ones you </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">might see:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.587.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">--dir string</span></strong><span class="koboSpan" id="kobo.589.1"> flag specifies the directory in which to look for interfaces </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">to mock.</span></span></li>
<li><span class="koboSpan" id="kobo.591.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">--all</span></strong><span class="koboSpan" id="kobo.593.1"> flag specifies to search for through all subdirectories and </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">generate mocks.</span></span></li>
<li><span class="koboSpan" id="kobo.595.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">--name string</span></strong><span class="koboSpan" id="kobo.597.1"> flag specifies the name or regular expression to match while searching for interfaces to </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">generate mocks.</span></span></li>
<li><span class="koboSpan" id="kobo.599.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">--output string</span></strong><span class="koboSpan" id="kobo.601.1"> flag specifies the directory to place generated mocks into. </span><span class="koboSpan" id="kobo.601.2">By default, this is configured to </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">be </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">/mocks</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.605.1">You can see all the other options available for this command by using </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">mockery –help</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.608.1">We can now generate mocks for</span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.609.1"> our interfaces by using the </span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.611.1">
$ mockery --dir "chapter03" --output "chapter03/mocks" --all</span></pre>
<p><span class="koboSpan" id="kobo.612.1">This command looks for all interfaces in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">chapter03</span></strong><span class="koboSpan" id="kobo.614.1"> directory and all its subdirectories and places the generated files in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">chapter03/mocks</span></strong><span class="koboSpan" id="kobo.616.1"> directory. </span><span class="koboSpan" id="kobo.616.2">The output of this command should look </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">like this:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.618.1">
11 Sep 22 17:38 BST INF Starting mockery dry-run=false version=v2.14.0
11 Sep 22 17:38 BST INF Walking dry-run=false version=v2.14.0
11 Sep 22 17:38 BST INF Generating mock dry-run=false </span><strong class="bold"><span class="koboSpan" id="kobo.619.1">interface=OperationProcessor</span></strong><span class="koboSpan" id="kobo.620.1"> qualified-name=github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter03/input version=v2.14.0
11 Sep 22 17:38 BST INF Generating mock dry-run=false </span><strong class="bold"><span class="koboSpan" id="kobo.621.1">interface=ValidationHelper</span></strong><span class="koboSpan" id="kobo.622.1"> qualified-name=github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter03/input version=v2.14.0</span></pre>
<p><span class="koboSpan" id="kobo.623.1">As we can see from the output, our two interfaces, </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">OperationProcessor</span></strong><span class="koboSpan" id="kobo.625.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">ValidationHelper</span></strong><span class="koboSpan" id="kobo.627.1">, have</span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.628.1"> been detected and mocks have been generated for them. </span><span class="koboSpan" id="kobo.628.2">The generated files will contain structs that will satisfy the </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">defined interfaces:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.630.1">
// OperationProcessor is an autogenerated mock type for the
// OperationProcessor type
  type OperationProcessor struct {
</span><strong class="bold"><span class="koboSpan" id="kobo.631.1">  mock.Mock</span></strong><span class="koboSpan" id="kobo.632.1">
}
// ProcessOperation provides a mock function with given
// fields: operation
func (_m *OperationProcessor) ProcessOperation(operation calculator.Operation) (*string, error) {
  ret :=_m.Called(operation)
// implementation code
}</span></pre>
<p><span class="koboSpan" id="kobo.633.1">The generated structs also contain a nested struct of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">mock.Mock</span></strong><span class="koboSpan" id="kobo.635.1"> type. </span><span class="koboSpan" id="kobo.635.2">This provides functionality for asserting activity on the mock. </span><span class="koboSpan" id="kobo.635.3">This functionality is important when verifying mocks, which we will </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">explore next.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.637.1">Regenerating mocks</span></p>
<p class="callout"><span class="koboSpan" id="kobo.638.1">It is common for </span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.639.1">engineering teams to add the mock generation to the specification of their Docker files. </span><span class="koboSpan" id="kobo.639.2">This will allow the mocks to be generated as part of the CI/CD pipeline and be used during the </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">build process.</span></span></p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.641.1">Verifying mocks</span></h2>
<p><span class="koboSpan" id="kobo.642.1">We are </span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.643.1">now ready to begin writing tests for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">Parser</span></strong><span class="koboSpan" id="kobo.645.1"> struct, which uses the generated mocks that we’ve created. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.646.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.647.1">.4</span></em><span class="koboSpan" id="kobo.648.1"> depicts the steps that we follow to write </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">the tests:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer031">
<span class="koboSpan" id="kobo.650.1"><img alt="Figure 3.4 – Writing tests using mocks " src="image/Figure_3.4_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.651.1">Figure 3.4 – Writing tests using mocks</span></p>
<p><span class="koboSpan" id="kobo.652.1">The rough procedure of how our tests will look like using the generated mocks is </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">as follows:</span></span></p>
<ol>
<li value="1"><strong class="bold"><span class="koboSpan" id="kobo.654.1">Create mocks</span></strong><span class="koboSpan" id="kobo.655.1">: We create the mock structs in the </span><strong class="bold"><span class="koboSpan" id="kobo.656.1">Arrange</span></strong><span class="koboSpan" id="kobo.657.1"> step of our test. </span><span class="koboSpan" id="kobo.657.2">The mock will be separated from any transitive dependencies, so it will be easy to initialize. </span><span class="koboSpan" id="kobo.657.3">At this point, we should have as many mocks as there are direct dependencies of </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">the UUT.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.659.1">Inject mocks in the UUT</span></strong><span class="koboSpan" id="kobo.660.1">: We inject the mock while creating the UUT in the </span><strong class="bold"><span class="koboSpan" id="kobo.661.1">Arrange</span></strong><span class="koboSpan" id="kobo.662.1"> step of our test. </span><span class="koboSpan" id="kobo.662.2">Since the mocks satisfy the interfaces of the real dependencies, the UUT is not aware of whether it is receiving a real dependency or </span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">a mock.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.664.1">Set expectations using the </span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">On</span></strong><strong class="bold"><span class="koboSpan" id="kobo.666.1"> method</span></strong><span class="koboSpan" id="kobo.667.1">: We invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">On</span></strong><span class="koboSpan" id="kobo.669.1"> method on the mock to set up any expectations of the mock behavior. </span><span class="koboSpan" id="kobo.669.2">We also set up any expected parameter invocations and return values. </span><span class="koboSpan" id="kobo.669.3">This concludes the </span><strong class="bold"><span class="koboSpan" id="kobo.670.1">Arrange</span></strong><span class="koboSpan" id="kobo.671.1"> step of </span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">your test.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.673.1">Invoke the methods on the UUT</span></strong><span class="koboSpan" id="kobo.674.1">: We write the </span><strong class="bold"><span class="koboSpan" id="kobo.675.1">Act</span></strong><span class="koboSpan" id="kobo.676.1"> section of our test as normal. </span><span class="koboSpan" id="kobo.676.2">The UUT is unaware that it will be using a mock during its operation, so any method invocations will function </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">as normal.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.678.1">Invoke the </span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">AssertExpectations</span></strong><strong class="bold"><span class="koboSpan" id="kobo.680.1"> method</span></strong><span class="koboSpan" id="kobo.681.1">: Finally, in the </span><strong class="bold"><span class="koboSpan" id="kobo.682.1">Assert</span></strong><span class="koboSpan" id="kobo.683.1"> section of our test, invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">AssertExpectations</span></strong><span class="koboSpan" id="kobo.685.1"> method on all of the mocks to ensure that all the previously declared expectations </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">are verified.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.687.1">The usage of mocks is</span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.688.1"> very simple and integrates well with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">testing</span></strong><span class="koboSpan" id="kobo.690.1"> library. </span><span class="koboSpan" id="kobo.690.2">Let us have a look at a simple test of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">Parser</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.692.1"> type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.693.1">
func TestProcessExpression(t *testing.T) {
  t.Run("valid input", func(t *testing.T) {
    // Arrange
    expr := "2 + 3"
    operator := "+"
    operands := []float64{2.0, 3.0}
    expectedResult := "2 + 3 = 5.5"
    engine := mocks.NewOperationProcessor(t)
    validator := mocks.NewValidationHelper(t)
    parser := input.NewParser(engine, validator)
</span><strong class="bold"><span class="koboSpan" id="kobo.694.1">    validator.On("CheckInput", operator,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.695.1">      operands).Return(nil).Once()</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.696.1">    engine.On("ProcessOperation", &amp;calculator.Operation{</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.697.1">      Expression: expr,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.698.1">      Operator: operator,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.699.1">      Operands: operands,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.700.1">    </span></strong><strong class="bold"><span class="koboSpan" id="kobo.701.1">}).Return(expectedResult).Once()</span></strong><span class="koboSpan" id="kobo.702.1">
  // Act
  result,err := parser.ProcessExpression(expr)
  // Assert
  // other assertions
</span><strong class="bold"><span class="koboSpan" id="kobo.703.1">  validator.AssertExpectations(t)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.704.1">  engine.AssertExpectations(t)</span></strong><span class="koboSpan" id="kobo.705.1">
  })
}</span></pre>
<p><span class="koboSpan" id="kobo.706.1">The simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">TestProcessExpression</span></strong><span class="koboSpan" id="kobo.708.1"> highlights the usage of mocks in test writing. </span><span class="koboSpan" id="kobo.708.2">The usage of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">On</span></strong><span class="koboSpan" id="kobo.710.1"> method allows us to easily configure expected behavior for all mocked </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">direct </span></span><span class="No-Break"><a id="_idIndexMarker248"/></span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">dependencies.</span></span></p>
<p><span class="koboSpan" id="kobo.713.1">As demonstrated, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">On</span></strong><span class="koboSpan" id="kobo.715.1"> method can be used to specify detailed expectations. </span><span class="koboSpan" id="kobo.715.2">Here are some of the ones you will </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">often encounter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.717.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.718.1">function name</span></strong><span class="koboSpan" id="kobo.719.1"> is specified during the call of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">On</span></strong><span class="koboSpan" id="kobo.721.1"> method itself. </span><span class="koboSpan" id="kobo.721.2">The first parameter of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">On</span></strong><span class="koboSpan" id="kobo.723.1"> method is the name of the function that should </span><span class="No-Break"><span class="koboSpan" id="kobo.724.1">be mocked.</span></span></li>
<li><span class="koboSpan" id="kobo.725.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.726.1">function parameters</span></strong><span class="koboSpan" id="kobo.727.1"> are also specified as parameters to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">On</span></strong><span class="koboSpan" id="kobo.729.1"> method. </span><span class="koboSpan" id="kobo.729.2">The arguments can be specific values or we can assert their type using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">mock.AnythingOfType</span></strong><span class="koboSpan" id="kobo.731.1"> function. </span><span class="koboSpan" id="kobo.731.2">We can also use </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">mock.Anything</span></strong><span class="koboSpan" id="kobo.733.1"> if we don’t care about making any validation of the given argument, but this should be used sparingly because the intention behind the test might be hard to </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">understand later.</span></span></li>
<li><span class="koboSpan" id="kobo.735.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.736.1">return values</span></strong><span class="koboSpan" id="kobo.737.1"> are specified with the chained </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">Return</span></strong><span class="koboSpan" id="kobo.739.1"> method, which is invoked after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">On</span></strong><span class="koboSpan" id="kobo.741.1"> method. </span><span class="koboSpan" id="kobo.741.2">It allows you to return specific values if the specified method is invoked with the configured </span><span class="No-Break"><span class="koboSpan" id="kobo.742.1">function parameters.</span></span></li>
<li><span class="koboSpan" id="kobo.743.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.744.1">invocation count</span></strong><span class="koboSpan" id="kobo.745.1"> is also specified using chained methods after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">On</span></strong><span class="koboSpan" id="kobo.747.1"> method. </span><span class="koboSpan" id="kobo.747.2">There are shorthand methods for </span><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">Once</span></strong><span class="koboSpan" id="kobo.749.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">Twice</span></strong><span class="koboSpan" id="kobo.751.1">; otherwise, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">Times</span></strong><span class="koboSpan" id="kobo.753.1"> method can be used to specify a custom invocation count. </span><span class="koboSpan" id="kobo.753.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">Unset</span></strong><span class="koboSpan" id="kobo.755.1"> method can be used to specify that a mock handler should not </span><span class="No-Break"><span class="koboSpan" id="kobo.756.1">be called.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.757.1">Verifying expectations</span></p>
<p class="callout"><span class="koboSpan" id="kobo.758.1">Remember to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">AssertExpectations</span></strong><span class="koboSpan" id="kobo.760.1"> method on each of your mocks if you want to assert that they have been called according to the expectations laid out by your </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">On</span></strong><span class="koboSpan" id="kobo.762.1"> methods. </span><span class="koboSpan" id="kobo.762.2">This gives you fine-grained control over how the UUT interacts with </span><span class="No-Break"><span class="koboSpan" id="kobo.763.1">its dependencies.</span></span></p>
<p><span class="koboSpan" id="kobo.764.1">Consider how much code</span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.765.1"> you would have to write to set up custom types according to preconditions and then also verify that dependencies have been invoked according to expectations. </span><span class="koboSpan" id="kobo.765.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">testify/mock</span></strong><span class="koboSpan" id="kobo.767.1"> library makes it easy for us to leverage the power of mocks in a unified way across all </span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">our projects.</span></span></p>
<h1 id="_idParaDest-72"><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.769.1">Working with assertion frameworks</span></h1>
<p><span class="koboSpan" id="kobo.770.1">While the </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">testify/mock</span></strong><span class="koboSpan" id="kobo.772.1"> functionality</span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.773.1"> is useful for creating mocks, </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">testify</span></strong><span class="koboSpan" id="kobo.775.1"> is best known for its assertion framework. </span><span class="koboSpan" id="kobo.775.2">In this section, we will explore some common assertion frameworks and how we can use them to further streamline and expand </span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">our tests.</span></span></p>
<p><span class="koboSpan" id="kobo.777.1">So far, we have been writing our verifications using </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">if</span></strong><span class="koboSpan" id="kobo.779.1"> statements and invoking the correct failure method on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">testing.T</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.781.1"> parameter:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.782.1">
// Assert
if err != nil {
  t.Fatal(err)
}</span></pre>
<p><span class="koboSpan" id="kobo.783.1">This approach is simple, but it does have the </span><span class="No-Break"><span class="koboSpan" id="kobo.784.1">following disadvantages:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.785.1">Repetition</span></strong><span class="koboSpan" id="kobo.786.1">: A lengthy or complex</span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.787.1"> test will end up making multiple assertions. </span><span class="koboSpan" id="kobo.787.2">We will then have to repeat this error assertion block multiple times, making the </span><span class="No-Break"><span class="koboSpan" id="kobo.788.1">test verbose.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.789.1">Difficult to make advanced assertions</span></strong><span class="koboSpan" id="kobo.790.1">: We want to have the same fine-grained control over the verifications we undertake on our mocks throughout the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.791.1">the test.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.792.1">Completely different approach to other languages</span></strong><span class="koboSpan" id="kobo.793.1">: This approach is completely different from other programming languages, which have powerful mocking and assertion frameworks. </span><span class="koboSpan" id="kobo.793.2">Java’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">JUnit</span></strong><span class="koboSpan" id="kobo.795.1"> is such </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">an example.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.797.1">While the Go standard library </span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.798.1">does not provide functionality for assertions, two popular assertion frameworks provide </span><span class="No-Break"><span class="koboSpan" id="kobo.799.1">this functionality:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.800.1">testify</span></strong><span class="koboSpan" id="kobo.801.1"> is an open source assertion framework that provides an easy-to-use and powerful assertion package. </span><span class="koboSpan" id="kobo.801.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.802.1">assert</span></strong><span class="koboSpan" id="kobo.803.1"> package provides this functionality. </span><span class="koboSpan" id="kobo.803.2">You can read about it </span><span class="No-Break"><span class="koboSpan" id="kobo.804.1">at </span></span><a href="https://github.com/stretchr/testify#assert-package"><span class="No-Break"><span class="koboSpan" id="kobo.805.1">https://github.com/stretchr/testify#assert-package</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.806.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">ginkgo</span></strong><span class="koboSpan" id="kobo.808.1"> is an open source assertion</span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.809.1"> framework that provides </span><strong class="bold"><span class="koboSpan" id="kobo.810.1">behavior-driven development</span></strong><span class="koboSpan" id="kobo.811.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.812.1">BDD</span></strong><span class="koboSpan" id="kobo.813.1">) style test</span><a href="https://github.com/onsi/ginkgo"><span class="koboSpan" id="kobo.814.1"> writing and assertions. </span><span class="koboSpan" id="kobo.814.2">You c</span></a><span class="koboSpan" id="kobo.815.1">an read about it at </span><a href="https://github.com/onsi/ginkgo"><span class="koboSpan" id="kobo.816.1">https://github.com/onsi/ginkgo</span></a><span class="koboSpan" id="kobo.817.1">. </span><span class="koboSpan" id="kobo.817.2">Adopting this style of testing allows developers to write tests that read like </span><span class="No-Break"><span class="koboSpan" id="kobo.818.1">natural language.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.819.1">We will discuss BDD style tests in </span><a href="B18371_05.xhtml#_idTextAnchor124"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.820.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.821.1">, </span><em class="italic"><span class="koboSpan" id="kobo.822.1">Performing Integration Testing</span></em><span class="koboSpan" id="kobo.823.1">. </span><span class="koboSpan" id="kobo.823.2">Therefore, we will reserve the discussion of writing this type of test until then. </span><span class="koboSpan" id="kobo.823.3">We will continue our current exploration with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">testify</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.825.1"> framework.</span></span></p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.826.1">Using testify</span></h2>
<p><span class="koboSpan" id="kobo.827.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">assert</span></strong><span class="koboSpan" id="kobo.829.1"> package provides </span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.830.1">many useful functions for creating fine-grained assertions. </span><span class="koboSpan" id="kobo.830.2">Here are some of the ones that you will </span><span class="No-Break"><span class="koboSpan" id="kobo.831.1">encounter often:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.832.1">Equality assertions</span></strong><span class="koboSpan" id="kobo.833.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">assert.Equal</span></strong><span class="koboSpan" id="kobo.835.1"> function allows you to check whether two objects are equal. </span><span class="koboSpan" id="kobo.835.2">If the</span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.836.1"> types checked are pointer-based, a value check on the reference values will be conducted. </span><span class="koboSpan" id="kobo.836.2">The opposite function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">assert.NotEqual</span></strong><span class="koboSpan" id="kobo.838.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.839.1">also exists:</span></span><pre class="console"><span class="koboSpan" id="kobo.840.1">
assert.Equal(t, expected, actual)</span></pre><pre class="console"><span class="koboSpan" id="kobo.841.1">
assert.NotEqual(t, expected, actual)</span></pre></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.842.1">Nil assertions</span></strong><span class="koboSpan" id="kobo.843.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">assert.Equal</span></strong><span class="koboSpan" id="kobo.845.1"> function should not be used for nil values. </span><span class="koboSpan" id="kobo.845.2">Instead, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">assert.Nil</span></strong><span class="koboSpan" id="kobo.847.1"> method </span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.848.1">should be used. </span><span class="koboSpan" id="kobo.848.2">The </span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.849.1">opposite function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">assert.NotNil</span></strong><span class="koboSpan" id="kobo.851.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.852.1">also exists:</span></span><pre class="console"><span class="koboSpan" id="kobo.853.1">
assert.Nil(t, actual)</span></pre><pre class="console"><span class="koboSpan" id="kobo.854.1">
assert.NotNil(t, actual)</span></pre></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.855.1">Contains assertions</span></strong><span class="koboSpan" id="kobo.856.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">assert.Contains</span></strong><span class="koboSpan" id="kobo.858.1"> function verifies that a specified value is contained inside</span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.859.1"> a string, list, or map. </span><span class="koboSpan" id="kobo.859.2">The opposite function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">assert.NotContains</span></strong><span class="koboSpan" id="kobo.861.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.862.1">also exists:</span></span><pre class="console"><span class="koboSpan" id="kobo.863.1">
assert.Contains(t, collection, element)</span></pre><pre class="console"><span class="koboSpan" id="kobo.864.1">
assert.NotContains(t, collection, element)</span></pre></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.865.1">Subset assertions</span></strong><span class="koboSpan" id="kobo.866.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">assert.Subset</span></strong><span class="koboSpan" id="kobo.868.1"> function verifies that all the values in a specified subset are </span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.869.1">contained in a specified list. </span><span class="koboSpan" id="kobo.869.2">The opposite function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">assert.NotSubset</span></strong><span class="koboSpan" id="kobo.871.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.872.1">also exists:</span></span><pre class="console"><span class="koboSpan" id="kobo.873.1">
assert.Subset(t, list, subset)</span></pre><pre class="console"><span class="koboSpan" id="kobo.874.1">
assert.NotSubset(t, list, subset)</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.875.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">testify/require</span></strong><span class="koboSpan" id="kobo.877.1"> package also provides the same assertions, but will terminate the test in the case that an assertion fails. </span><span class="koboSpan" id="kobo.877.2">This package should be used in the case of fatal </span><span class="No-Break"><span class="koboSpan" id="kobo.878.1">test errors.</span></span></p>
<p><span class="koboSpan" id="kobo.879.1">For example, we can replace our previous </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">if</span></strong><span class="koboSpan" id="kobo.881.1"> statement, which makes a call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.882.1">t.Fatal</span></strong><span class="koboSpan" id="kobo.883.1">, with the following single line </span><span class="No-Break"><span class="koboSpan" id="kobo.884.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.885.1">
require.Nil(t, err)</span></pre>
<p class="callout-heading"><span class="koboSpan" id="kobo.886.1">Augmenting the testing package</span></p>
<p class="callout"><span class="koboSpan" id="kobo.887.1">You should use assertion frameworks to complement the simplicity of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.888.1">testing</span></strong><span class="koboSpan" id="kobo.889.1"> package. </span><span class="koboSpan" id="kobo.889.2">As you begin to write more Go code, you should familiarize yourself with the assertion frameworks functionality and begin to use them in </span><span class="No-Break"><span class="koboSpan" id="kobo.890.1">your tests.</span></span></p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.891.1">Asserting errors</span></h2>
<p><span class="koboSpan" id="kobo.892.1">One final aspect to</span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.893.1"> cover when discussing assertions is how to verify errors. </span><span class="koboSpan" id="kobo.893.2">Sometimes, we want to verify not only that an error occurs, but that the correct error message is also returned. </span><span class="koboSpan" id="kobo.893.3">You should ensure that your tests verify such error messages </span><span class="No-Break"><span class="koboSpan" id="kobo.894.1">when appropriate.</span></span></p>
<p><span class="koboSpan" id="kobo.895.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">assert.Equal</span><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.897.1">Error</span></strong><span class="koboSpan" id="kobo.898.1"> function verifies that a returned error is not </span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">nil</span></strong><span class="koboSpan" id="kobo.900.1"> and that its message is equal to the provided string. </span><span class="koboSpan" id="kobo.900.2">This will make it easy to verify your error messages</span><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.901.1">. </span><span class="koboSpan" id="kobo.901.2">As with all the functions we have seen so far, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">require</span></strong><span class="koboSpan" id="kobo.903.1"> package also provides </span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">this function.</span></span></p>
<p><span class="koboSpan" id="kobo.905.1">Let us look at an example that verifies an </span><span class="No-Break"><span class="koboSpan" id="kobo.906.1">error scenario:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.907.1">
t.Run("invalid operation", func(t *testing.T) {
  // Arrange
  expr := "2 % 3"
  operator := "%"
  operands := []float64{2.0, 3.0}
</span><strong class="bold"><span class="koboSpan" id="kobo.908.1">  expectedErrMsg := "bad operator"</span></strong><span class="koboSpan" id="kobo.909.1">
  engine := mocks.NewOperationProcessor(t)
  validator := mocks.NewValidationHelper(t)
  parser := input.NewParser(engine, validator)
</span><strong class="bold"><span class="koboSpan" id="kobo.910.1">  </span></strong><strong class="bold"><span class="koboSpan" id="kobo.911.1">validator.On("CheckInput", operator, operands).</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.912.1">    Return(fmt.Errorf(expectedErrMsg)).Once()</span></strong><span class="koboSpan" id="kobo.913.1">
  // Act
  result, err := parser.ProcessExpression(expr)
  // Assert
</span><strong class="bold"><span class="koboSpan" id="kobo.914.1">  require.NotNil(t, err)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.915.1">  require.Nil(t, result)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.916.1">  assert.Contains(t, err.Error(), expr)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.917.1">  assert.Contains(t, err.Error(), expectedErrMsg)</span></strong><span class="koboSpan" id="kobo.918.1">
  validator.AssertExpectations(t)
  })</span></pre>
<p><span class="koboSpan" id="kobo.919.1">The test creates a </span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.920.1">variable called </span><strong class="source-inline"><span class="koboSpan" id="kobo.921.1">expectedErrMsg</span></strong><span class="koboSpan" id="kobo.922.1">, which represents the error message that the mock will return. </span><span class="koboSpan" id="kobo.922.2">This message is then passed to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.923.1">assert.Contains</span></strong><span class="koboSpan" id="kobo.924.1"> function, which will verify it against the error returned by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">ProcessExpression</span></strong><span class="koboSpan" id="kobo.926.1"> method invoked on </span><span class="No-Break"><span class="koboSpan" id="kobo.927.1">the UUT.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.928.1">Custom error types</span></p>
<p class="callout"><span class="koboSpan" id="kobo.929.1">You can also create your own custom error types instead of relying solely on Go’s built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">error</span></strong><span class="koboSpan" id="kobo.931.1"> type. </span><span class="koboSpan" id="kobo.931.2">This will provide you with type safety on error checking, instead of relying on error messages, which might change and make your </span><span class="No-Break"><span class="koboSpan" id="kobo.932.1">tests brittle.</span></span></p>
<p><span class="koboSpan" id="kobo.933.1">Mocks and assertion frameworks are tools that we use to easily write tests. </span><span class="koboSpan" id="kobo.933.2">However, even the most skilled test writer will struggle to test code that is badly designed. </span><span class="koboSpan" id="kobo.933.3">The iterative nature of TDD together with good software design principles will result in testable, </span><span class="No-Break"><span class="koboSpan" id="kobo.934.1">maintainable code.</span></span></p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.935.1">Writing testable code</span></h1>
<p><span class="koboSpan" id="kobo.936.1">The final aspect we will cover in</span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.937.1"> this chapter is how to write testable code using the </span><strong class="bold"><span class="koboSpan" id="kobo.938.1">SOLID</span></strong><span class="koboSpan" id="kobo.939.1"> software design principles. </span><span class="koboSpan" id="kobo.939.2">As we have seen multiple times already, well-designed code is also easy-to-test code. </span><span class="koboSpan" id="kobo.939.3">Application code that is difficult to test is often a sign that the application will be hard to change </span><span class="No-Break"><span class="koboSpan" id="kobo.940.1">and maintain.</span></span></p>
<p><span class="koboSpan" id="kobo.941.1">These five powerful principles were introduced in a paper by Robert C. </span><span class="koboSpan" id="kobo.941.2">Martin in 2000, then later published in his book </span><em class="italic"><span class="koboSpan" id="kobo.942.1">Agile Software Development, Principles, Patterns, and Practices</span></em><span class="koboSpan" id="kobo.943.1">. </span><span class="koboSpan" id="kobo.943.2">These principles help Agile teams deliver maintainable, </span><span class="No-Break"><span class="koboSpan" id="kobo.944.1">easy-to-refactor code.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.945.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.946.1">.5</span></em><span class="koboSpan" id="kobo.947.1"> summarizes the SOLID </span><a id="_idIndexMarker263"/><span class="No-Break"><span class="koboSpan" id="kobo.948.1">design principles:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<span class="koboSpan" id="kobo.949.1"><img alt="Figure 3.5 – The SOLID design principles " src="image/Figure_3.5_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.950.1">Figure 3.5 – The SOLID design principles</span></p>
<p><span class="koboSpan" id="kobo.951.1">Let us recap the SOLID principles and what they mean for </span><span class="No-Break"><span class="koboSpan" id="kobo.952.1">test writing:</span></span></p>
<ol>
<li value="1"><strong class="bold"><span class="koboSpan" id="kobo.953.1">Single Responsibility Principle</span></strong><span class="koboSpan" id="kobo.954.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.955.1">SRP</span></strong><span class="koboSpan" id="kobo.956.1">): For this, entities should have a single job and a single reason to </span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.957.1">change. </span><span class="koboSpan" id="kobo.957.2">This principle will keep testing code simple since the scope of the functionality provided by the class is small. </span><span class="koboSpan" id="kobo.957.3">We can then focus our efforts on covering edge cases, as opposed to covering a large number </span><span class="No-Break"><span class="koboSpan" id="kobo.958.1">of methods.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.959.1">Open-Closed Principle</span></strong><span class="koboSpan" id="kobo.960.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.961.1">OCP</span></strong><span class="koboSpan" id="kobo.962.1">): For this, entities should be open for extension, but closed for modification. </span><span class="koboSpan" id="kobo.962.2">This principle translates to ensuring that code changes extend but don’t </span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.963.1">break existing behavior. </span><span class="koboSpan" id="kobo.963.2">Code that is backward-compatible by design will not require numerous test changes. </span><span class="koboSpan" id="kobo.963.3">Instead, the new/extended functionality can be covered by new test cases, ensuring that the test suite continues to </span><span class="No-Break"><span class="koboSpan" id="kobo.964.1">be stable.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.965.1">Liskov Substitution Principle</span></strong><span class="koboSpan" id="kobo.966.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.967.1">LSP</span></strong><span class="koboSpan" id="kobo.968.1">): For this, every subclass or derived class should satisfy the behavior of its parent or base class. </span><span class="koboSpan" id="kobo.968.2">Since Go does not have inheritance, you might be tempted to conclude that it does not apply. </span><span class="koboSpan" id="kobo.968.3">However, we achieve</span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.969.1"> polymorphism using interfaces, so we can</span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.970.1"> express this principle in terms of the contracts they set. </span><span class="koboSpan" id="kobo.970.2">Code that maintains substitutable interfaces will be easy to test, as it will again not require many test changes to the </span><span class="No-Break"><span class="koboSpan" id="kobo.971.1">existing suite.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.972.1">Interface Segregation Principle</span></strong><span class="koboSpan" id="kobo.973.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.974.1">ISP</span></strong><span class="koboSpan" id="kobo.975.1">): For this, client code should not be forced to implement methods </span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.976.1">or interfaces that it does not use. </span><span class="koboSpan" id="kobo.976.2">This principle encourages the usage of small interfaces, which only wrap around a single responsibility. </span><span class="koboSpan" id="kobo.976.3">Interfaces should be defined on the side of the client/calling code, which should only define interface methods for the functionality they are interested in using. </span><span class="koboSpan" id="kobo.976.4">Small interfaces lead to small mocks, which, in turn, lead to simple test setups </span><span class="No-Break"><span class="koboSpan" id="kobo.977.1">and assertions.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.978.1">Dependency Inversion Principle</span></strong><span class="koboSpan" id="kobo.979.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.980.1">DIP</span></strong><span class="koboSpan" id="kobo.981.1">): For this, entities should depend on abstractions, not concretions. </span><span class="koboSpan" id="kobo.981.2">This</span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.982.1"> principle encourages using interfaces to represent dependencies. </span><span class="koboSpan" id="kobo.982.2">We discussed this principle in the </span><em class="italic"><span class="koboSpan" id="kobo.983.1">Dependency injection</span></em><span class="koboSpan" id="kobo.984.1"> section of this chapter. </span><span class="koboSpan" id="kobo.984.2">We saw that using this technique in combination with the power of interfaces will produce loosely coupled code that is easier to test, due to fewer out-of-package dependencies that need to be </span><span class="No-Break"><span class="koboSpan" id="kobo.985.1">set up.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.986.1">As we have seen, interfaces are central to the implementation of SOLID principles in Go. </span><span class="koboSpan" id="kobo.986.2">They should be used to write code that is easy to maintain and refactor. </span><span class="koboSpan" id="kobo.986.3">Since refactoring is a central part of the TDD practice, easy-to-refactor code will also be easy to </span><span class="No-Break"><span class="koboSpan" id="kobo.987.1">test code.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.988.1">The SOLID entity</span></p>
<p class="callout"><span class="koboSpan" id="kobo.989.1">Remember that in Go the entity should be the package, not the struct. </span><span class="koboSpan" id="kobo.989.2">Packages provide their own APIs, which establish their own contracts and interfaces. </span><span class="koboSpan" id="kobo.989.3">Keep the SOLID principles in mind when designing your </span><span class="No-Break"><span class="koboSpan" id="kobo.990.1">package APIs.</span></span></p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.991.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.992.1">In this chapter, we expanded on unit testing essentials by learning how to handle code dependencies. </span><span class="koboSpan" id="kobo.992.2">We began by introducing DI and exploring different approaches to how this is done in Go. </span><span class="koboSpan" id="kobo.992.3">You learned how to use mocks to have fine-grained control over the preconditions that your test runs in, as well as how to generate them using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.993.1">testify/mock</span></strong><span class="koboSpan" id="kobo.994.1"> framework. </span><span class="koboSpan" id="kobo.994.2">Then, we explored different assertion frameworks and how to use them to streamline our tests. </span><span class="koboSpan" id="kobo.994.3">Finally, we discussed the SOLID principles, which will help us to write </span><span class="No-Break"><span class="koboSpan" id="kobo.995.1">testable code.</span></span></p>
<p><span class="koboSpan" id="kobo.996.1">In </span><a href="B18371_04.xhtml#_idTextAnchor085"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.997.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.998.1">, </span><em class="italic"><span class="koboSpan" id="kobo.999.1">Building Efficient Test Suites</span></em><span class="koboSpan" id="kobo.1000.1">, we will begin to look at our tests as a collection, ensuring they complement each other and cover edge cases. </span><span class="koboSpan" id="kobo.1000.2">We will also explore the popular Go technique of </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1001.1">table-driven testing</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1002.1">.</span></span></p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.1003.1">Questions</span></h1>
<p><span class="koboSpan" id="kobo.1004.1">Answer the following questions to test your knowledge of </span><span class="No-Break"><span class="koboSpan" id="kobo.1005.1">this chapter:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1006.1">Continue the existing implementation of the simple calculator by implementing and testing the </span><span class="No-Break"><span class="koboSpan" id="kobo.1007.1">remaining operations:</span></span><ul><li><span class="No-Break"><span class="koboSpan" id="kobo.1008.1">Subtraction</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.1009.1">Multiplication</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.1010.1">Division</span></span></li></ul></li>
<li><span class="koboSpan" id="kobo.1011.1">Ensure that you use all the techniques we have used so far to produce </span><span class="No-Break"><span class="koboSpan" id="kobo.1012.1">well-tested code.</span></span></li>
</ol>
<h1 id="_idParaDest-78"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.1013.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.1014.1">To learn more about the topics that were covered in this chapter, take a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.1015.1">following resources:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.1016.1">Clean Architecture: A Craftsman’s Guide to Software Structure and Design: A Craftsman’s Guide to Software Structure and Design</span></em><span class="koboSpan" id="kobo.1017.1">, Robert C. </span><span class="koboSpan" id="kobo.1017.2">Martin, published </span><span class="No-Break"><span class="koboSpan" id="kobo.1018.1">by Addison-Wesley</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1019.1">Design patterns: elements of reusable object-oriented software</span></em><span class="koboSpan" id="kobo.1020.1">, Erich Gamma et al., published by </span><span class="No-Break"><span class="koboSpan" id="kobo.1021.1">Addison Wesley</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1022.1">Compile-time Dependency Injection With Go Cloud’s Wire</span></em><span class="koboSpan" id="kobo.1023.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1024.1">The Go blog</span></em><span class="koboSpan" id="kobo.1025.1">, available </span><span class="No-Break"><span class="koboSpan" id="kobo.1026.1">at </span></span><a href="https://go.dev/blog/wire"><span class="No-Break"><span class="koboSpan" id="kobo.1027.1">https://go.dev/blog/wire</span></span></a></li>
</ul>
</div>
</body></html>