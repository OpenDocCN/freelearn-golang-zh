["```go\ntype Adder interface {\n  Add(x, y float64) float64\n}\n```", "```go\nfunc (e Engine) Add(x, y float64) float64 {\n  return x + y\n}\n```", "```go\nfunc NewEngine() *Engine {\n  return &Engine{}\n}\n```", "```go\ntype Calculator struct {\n  Adder Adder\n}\nfunc NewCalculator(a Adder) *Calculator {\n  return &Calculator{Adder: a}\n}\nfunc (c Calculator) PrintAdd(x, y float64) {\n  fmt.Println(\"Result:\", c.Adder.Add(x, y))\n}\n```", "```go\n func main() {\n  engine := NewEngine()\n  calc := NewCalculator(engine)\n  calc.PrintAdd(2.5, 6.3)\n}\n```", "```go\n//go:build wireinject\npackage main\nimport \"github.com/google/wire\"\nvar Set = wire.NewSet(NewEngine, wire.Bind(new(Adder), new(*Engine)), NewCalculator)\nfunc InitCalc() *Calculator {\n  wire.Build(Set)\n  return nil\n}\n```", "```go\n$ go install github.com/google/wire/cmd/wire@latest\n$ cd chapter03/di/wire && wire\nwire: github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter03/di/wire: wrote /Users/adelinasimion/code/Test-Driven-Development-in-Go/chapter03/di/wire/wire_gen.go\n```", "```go\nfunc InitCalc() *Calculator {\n  adder := NewEngine()\n  calculator := NewCalculator(adder)\n  return calculator\n}\n```", "```go\nfunc main() {\n  calc := InitCalc()\n  calc.PrintAdd(2.5, 6.3)\n}\n```", "```go\n$ go build./chapter03/di/wire\n$ ./wire\nResult: 8.8\n```", "```go\ntype Parser struct {\nengine    *calculator.Engine\n  validator *Validator\n}\n// ProcessExpression parses an expression and sends it to\n// the calculator\nfunc (p *Parser) ProcessExpression(expr string) (*string, error) {\n  operation, err := p.getOperation(expr)\n  if err != nil {\n    return nil, format.Error(expr, err)\n  }\n  return p.engine.ProcessOperation(*operation)\n}\n```", "```go\n// OperationProcessor is the interface for processing\n// mathematical expressions\ntype OperationProcessor interface {\n  ProcessOperation(operation *calculator.Operation) (*string, error)\n}\n// ValidationHelper is the interface for input validation\ntype ValidationHelper interface {\n  CheckInput(operator string, operands []float64) error\n}\n```", "```go\n// Parser is responsible for converting input to\n// mathematical operations\ntype Parser struct {\n  engine    OperationProcessor\n  validator ValidationHelper\n}\n```", "```go\n$ go get github.com/stretchr/testify\n$ go install github.com/vektra/mockery/v2@latest\n```", "```go\n$ mockery --dir \"chapter03\" --output \"chapter03/mocks\" --all\n```", "```go\n11 Sep 22 17:38 BST INF Starting mockery dry-run=false version=v2.14.0\n11 Sep 22 17:38 BST INF Walking dry-run=false version=v2.14.0\n11 Sep 22 17:38 BST INF Generating mock dry-run=false interface=OperationProcessor qualified-name=github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter03/input version=v2.14.0\n11 Sep 22 17:38 BST INF Generating mock dry-run=false interface=ValidationHelper qualified-name=github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter03/input version=v2.14.0\n```", "```go\n// OperationProcessor is an autogenerated mock type for the\n// OperationProcessor type\n  type OperationProcessor struct {\n  mock.Mock\n}\n// ProcessOperation provides a mock function with given\n// fields: operation\nfunc (_m *OperationProcessor) ProcessOperation(operation calculator.Operation) (*string, error) {\n  ret :=_m.Called(operation)\n// implementation code\n}\n```", "```go\nfunc TestProcessExpression(t *testing.T) {\n  t.Run(\"valid input\", func(t *testing.T) {\n    // Arrange\n    expr := \"2 + 3\"\n    operator := \"+\"\n    operands := []float64{2.0, 3.0}\n    expectedResult := \"2 + 3 = 5.5\"\n    engine := mocks.NewOperationProcessor(t)\n    validator := mocks.NewValidationHelper(t)\n    parser := input.NewParser(engine, validator)\n    validator.On(\"CheckInput\", operator,\n      operands).Return(nil).Once()\n    engine.On(\"ProcessOperation\", &calculator.Operation{\n      Expression: expr,\n      Operator: operator,\n      Operands: operands,\n}).Return(expectedResult).Once()\n  // Act\n  result,err := parser.ProcessExpression(expr)\n  // Assert\n  // other assertions\n  validator.AssertExpectations(t)\n  engine.AssertExpectations(t)\n  })\n}\n```", "```go\n// Assert\nif err != nil {\n  t.Fatal(err)\n}\n```", "```go\n    assert.Equal(t, expected, actual)\n    ```", "```go\n    assert.NotEqual(t, expected, actual)\n    ```", "```go\n    assert.Nil(t, actual)\n    ```", "```go\n    assert.NotNil(t, actual)\n    ```", "```go\n    assert.Contains(t, collection, element)\n    ```", "```go\n    assert.NotContains(t, collection, element)\n    ```", "```go\n    assert.Subset(t, list, subset)\n    ```", "```go\n    assert.NotSubset(t, list, subset)\n    ```", "```go\nrequire.Nil(t, err)\n```", "```go\nt.Run(\"invalid operation\", func(t *testing.T) {\n  // Arrange\n  expr := \"2 % 3\"\n  operator := \"%\"\n  operands := []float64{2.0, 3.0}\n  expectedErrMsg := \"bad operator\"\n  engine := mocks.NewOperationProcessor(t)\n  validator := mocks.NewValidationHelper(t)\n  parser := input.NewParser(engine, validator)\nvalidator.On(\"CheckInput\", operator, operands).\n    Return(fmt.Errorf(expectedErrMsg)).Once()\n  // Act\n  result, err := parser.ProcessExpression(expr)\n  // Assert\n  require.NotNil(t, err)\n  require.Nil(t, result)\n  assert.Contains(t, err.Error(), expr)\n  assert.Contains(t, err.Error(), expectedErrMsg)\n  validator.AssertExpectations(t)\n  })\n```"]