- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mocking and Assertion Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we explored the fundamentals of writing tests in Go.
    We explored the importance of packages, the organization of test files alongside
    source code, and how to use Go’s `testing` package to write tests and benchmarks.
  prefs: []
  type: TYPE_NORMAL
- en: We demonstrated the concepts and fundamentals of writing tests in Go with code
    samples from the `Calculator` use case. The simple examples we have looked at
    so far have not included any external dependencies, which can make test setup
    and verification much more complex.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will begin to look at how we can isolate the unit under
    test from its dependencies, keeping testing and assertions as simple and fast
    as possible. The easiest way to achieve this in Go is by leveraging the power
    of interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: We will expand upon the `Calculator` example by introducing dependencies to
    our main components. Then, we will learn how to generate mocks for these dependencies
    of the **unit under test** (**UUT**), enabling us to control their behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will explore some external, open source assertion libraries that are
    often used by Go engineers. Up until now, we have written some simple assertions
    ourselves. This can be repetitive and limiting. The `testify` and `ginkgo` assertion
    libraries are two popular choices that can be used to supplement Go’s `testing`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will turn away from exploring test code and mechanisms and look
    at design techniques for writing testable code by reviewing the **SOLID** principles
    of object-oriented design. We will learn what they are and how they can be applied
    when writing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using interfaces to wrap dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to generate and use mocks to test code in isolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The usage of popular assertion frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the **SOLID** design principles are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices for writing testable code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need to have **Go version 1.19** or later installed to run the code
    samples in this chapter. The installation process is described on the official
    Go documentation at [https://go.dev/doc/install](https://go.dev/doc/install).
  prefs: []
  type: TYPE_NORMAL
- en: The code examples included in this book are publicly available at [https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter03](https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces as dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As always, implementing and exploring unit testing techniques begins with exploring
    code writing techniques. This is a theme we will see regularly throughout this
    book. We cannot study testing in isolation. It requires insight into the code
    design and its intended purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will look at the concept of **software dependencies** and
    how to manage them. *Figure 3**.1* depicts the three main types of dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Types of dependencies from the point of view of the UUT ](img/Figure_3.1_B18371.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Types of dependencies from the point of view of the UUT
  prefs: []
  type: TYPE_NORMAL
- en: 'From the viewpoint of the UUT, the four main types of dependencies are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Direct internal dependencies**: These contain internal functionality that
    your **UUT** imports. These dependencies could be defined in the same package
    or module as **UUT**, but are required to deliver its functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transitive internal dependencies**: These contain internal functionality
    that the **Direct internal dependency** parts of your **UUT** import. These dependencies
    could also be defined in the same package or module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Direct external dependencies**: These contain third-party functionality that
    your **UUT** imports. These could be libraries or service APIs that you might
    rely on, but which are not contained in your current module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transitive external dependencies**: These contain external functionality
    that your **Direct external dependencies** rely on, but which are in a separate
    module. Due to the way that Go builds the source code and required libraries into
    runnable executables, these transitive dependencies will also be contained alongside
    your code during application release.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dependencies of the UUT are required for the UUT to be able to correctly
    deliver its functionality. Consequently, they are also required to completely
    test its functionality. We will explore techniques for handling code dependencies
    throughout this section and chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t reinvent the wheel
  prefs: []
  type: TYPE_NORMAL
- en: Writing code that relies on dependencies is a normal, and recommended, practice
    for software design. It allows us to reuse behavior and implementation in multiple
    places. This, coupled with Go’s powerful module and package system, makes it easy
    and fast to write complex code. We explored Go’s modules and packages in [*Chapter
    2*](B18371_02.xhtml#_idTextAnchor035), *Unit* *Testing Essentials*.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One popular and common technique for handling dependencies in code is the concept
    of **dependency injection** (**DI**). This is a simple yet effective design pattern
    for creating loosely coupled code, which allows us to implement code without the
    concerns of its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: DI is a style of writing code in which the UUT or function receives other types
    or functions that it depends on during initialization. Fundamentally, DI is nothing
    more than passing the correct parameters to a function, which then uses these
    to create the UUT.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is one of the principles of SOLID design, namely the letter *D*,
    which stands for the principle of **dependency inversion**. We will explore all
    the principles later in this chapter, in the *Writing testable* *code* section.
  prefs: []
  type: TYPE_NORMAL
- en: Why is it called injection?
  prefs: []
  type: TYPE_NORMAL
- en: The term *injection* simply signifies that the dependencies are not created
    by the UUT that requires them but passed to it from further up the stack. They
    can be injected either by constructor/function injection or by the use of frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.2* describes the main steps of what DI typically entails:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – The main steps of dependency injection ](img/Figure_3.2_B18371.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – The main steps of dependency injection
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the following sequence of calls:'
  prefs: []
  type: TYPE_NORMAL
- en: At the start, we begin by attempting to `struct`. We already know that Go structs
    do not provide constructors, so the initialization process will involve inspecting
    the dependencies that the UUT requires. We will see techniques for making the
    need for dependencies explicit in the next section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the UUT has any direct dependencies, then we will `struct`, either from the
    same module or another external module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When initializing the direct dependency, we might discover transitive dependencies
    that the direct dependencies need during initialization. We will then **Request
    the** **transitive dependency**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The dependency request process is repeated for all direct and transitive dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once each dependency has been successfully created, it is injected into the
    creation of the previous dependency or the UUT, if it is a direct dependency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The dependency graph
  prefs: []
  type: TYPE_NORMAL
- en: Due to the way that dependencies need to be created and then, in turn, injected,
    this process is known as *constructing the dependency graph*. This is a directed,
    acyclic graph. This graph allows the compiler to start at the root and then traverse
    it while building all the custom types it requires while running the main program.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing dependency injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While introducing DI, we briefly mentioned that structs do not have constructors
    and therefore this process might require the investigation of the properties and
    fields of a `struct`. Let us have a look at how we can implement DI in Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fundamentally, there are two ways we can go about injecting dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`struct`. This is an intuitive way to construct instances, but it does require
    that all dependencies be created before the invocation of the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`struct` and then setting the fields of the dependencies as you require them.
    This can either be done by directly setting them as fields on the UUT instance,
    or by invoking setter methods that set them on the fields. The dependencies are
    not immutable, so they do not require the UUT instance to be recreated as they
    are set. This way of creating the UUT and its dependencies does not require that
    all dependencies be created before initializing and beginning to use the UUT,
    but it also does not guarantee that all the dependencies will be set by a certain
    time, nor does it guarantee they won’t be changed later. This could require more
    application code for `nil` value checks, as well as other subtle bugs if dependencies
    change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, each method can be used in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Manual invocation**: This means that we call and create the UUT struct and
    its dependencies manually. In this process, you have full control over the creation
    and invocation of dependencies, but they can become difficult to manage for larger
    codebases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency injection frameworks**: This means that you import another dependency
    into your project that can automate this process using advanced techniques such
    as reflection or code generation, which then leverage the dependency graph to
    create the dependencies in the correct sequence. This method is much more sustainable
    for large codebases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When it comes to DI frameworks, there are two popular open source choices that
    you can use in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dig`: This uses reflection to build your dependency graph and successfully
    construct your instances. You can read about how to use it at [https://github.com/uber-go/dig](https://github.com/uber-go/dig).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wire`: This uses reflection and code generation for DI. You can read about
    how to use it at [https://github.com/google/wire](https://github.com/google/wire).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing complexity
  prefs: []
  type: TYPE_NORMAL
- en: Remember that one of the core principles of Go code and software design is simplicity.
    You should keep your code as simple as possible, avoiding the lengthy constructors
    that have been seen in other legacy languages.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to dependencies, they are usually represented using corresponding
    interface types. This is an approach unique to Go, regardless of how you choose
    to inject your dependencies. Let us look at their role in software design a little
    bit more closely.
  prefs: []
  type: TYPE_NORMAL
- en: '**Interfaces** are named collections of zero or more methods. Here are some
    key highlights of their behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: The y are the primary way we can achieve **polymorphism** is in Go.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The compiler enforces them and implicitly casts a `struct` to its corresponding
    interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To implement an interface, a `struct` needs to implement its defined methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `struct` can implement multiple interfaces, so long as it satisfies its method
    signatures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interface with zero methods is the empty interface and its type is `interface`
    `{}`. This is useful in certain cases, but the interfaces you create will have
    one or more methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The zero value of interfaces is nil. We will need to handle this in our code
    as we begin to use interfaces to wrap around our dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces define methods, not functions
  prefs: []
  type: TYPE_NORMAL
- en: Remember that interfaces define methods, not functions. As we’ve seen with the
    `Engine` definition, methods that correspond to the signature of the interface
    will need to be defined on the struct we want to use in place of this interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at a DI example; this can be found in the `chapter03/di/manual/calculator.go`.
    We can define a simple `Adder` interface with the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Adder` interface defines the `Add` method. Note that this method takes
    in two `float64` parameters and returns one `float64` return value. In our case,
    `Engine` will satisfy this interface as it implements this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When we initialize `Engine`, we can return the `Engine` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple `Calculator` then makes use of this `Engine` for its adder functionality
    and prints out the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`Engine` is a dependency of `Calculator`, so it is a parameter of the `NewCalculator`
    function. `Adder` is then invoked inside the `PrintAdd` method, where its functionality
    is required. Therefore, the initialization process of `Calculator` requires an
    instance of `Engine` to be created to compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This example uses the *manual invocation* of DI. As the dependency graph grows
    in size and complexity, this initialization function will become increasingly
    cumbersome and require changes. This is where DI frameworks can help simplify
    our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the previously introduced `wire` framework, we can define an `InitCalc`
    function in the `/chapter03/di/wire/wire.go` file, which will take care of initializing
    `Calculator` with its `Engine`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This `wire.Build` function takes in the `Set` that matches the `Adder` interface
    to the `Engine` struct. At the top of the file, we make use of a build tag to
    exclude this file from the final binary, and use the generated replacement file
    when we run our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we must install the wire tool and run it in the correct directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This command generates the `wire_gen.go` file, which contains the implementation
    of the `InitCalc` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This function contains the dependency creation code that we had previously
    written by hand. As it is now maintained and generated by wire, changes will not
    have to be maintained manually and the main function is now simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can build the application, generating the initialization function
    and binding it into the Go binary. Then, we can run the executable as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: DI frameworks simplify the code we write and maintain but do require adding
    new steps to the build process, as well as an extra cognitive load when first
    starting with them. We explored how the `wire` DI library works in this section,
    but we will be using manual injection going forward so that we have more control
    and can explore the code together better.
  prefs: []
  type: TYPE_NORMAL
- en: Use case – continued implementation of the calculator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will make use of the techniques we have seen so far to expand
    upon the implementation of the calculator from [*Chapter 2*](B18371_02.xhtml#_idTextAnchor035),
    *Unit* *Testing Essentials*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting aside the correct procedure of `input.Parser` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we know from [*Chapter 2*](B18371_02.xhtml#_idTextAnchor035), *Unit Testing
    Essentials*, where we first looked at this example, `Parser` depends on `Validator`
    and `calculator.Engine`. These two structs are the direct dependencies of `Parser`.
    Then, these dependencies are used to deliver the functionality of the `ProcessExpression`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of whether we use third-party DI frameworks or we create the corresponding
    structs manually, writing tests for this relatively simple code snippet involves:'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the `Parser` struct with all its direct and transitive dependencies.
    This could involve a lengthy setup, with external dependencies that might extend
    the scope of the test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once these main building blocks have been created, we need to set up their pre-condition
    state. This could involve an even more complicated setup, which could have unintended
    consequences as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it comes to verification, we might need to assert the internal state of
    dependencies to ensure that they are behaving as expected. This reliance on the
    internal state of dependencies would then make the tests more brittle since changes
    to the dependencies would break the tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we understand how to build code that requires direct dependencies,
    we will begin to explore mechanisms that can help us in testing such dependencies.
    We will leverage Go development tools to make testing and assertions easier.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling test scope
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to types that have many dependencies, the scope of the test setup
    and assertion can increase beyond the UUT. We need a mechanism that allows us
    to test the UUT in isolation, which also has the benefit of keeping the test scope
    small.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring mocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore one of the mechanisms that allows us to test
    code that relies on dependencies. We will see how to use and generate mocks, allowing
    us to verify the UUT in isolation from the behavior of its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mocks** are sometimes known as **test doubles** and are a simple but powerful
    concept. They satisfy the interfaces but are fake versions of the real implementations.
    We have full control over these fake implementations, giving us the freedom to
    control their behavior. However, if the real implementation changes and our mocks
    do not, then our tests will give us false confidence.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Go, we have the following different mocking options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Function substitution**: This means sending replacement fake functions to
    the UUT. This is easy to do in Go, which has native support for **higher-order
    functions**. We can override function variables and parameters, replacing the
    behavior of the UUT.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface substitution**: This means injecting fake versions of the interfaces
    that the UUT depends on. These are fake stubbed implementations that satisfy the
    interfaces of the real implementation. They can then be used to replace the full
    implementations, without the UUT even being aware of it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order function refresher
  prefs: []
  type: TYPE_NORMAL
- en: A higher-order function is a function that either takes in another function
    as a parameter or returns a function. Go functions are just like any other type.
  prefs: []
  type: TYPE_NORMAL
- en: The use of function substitution is less prevalent than interface substitution
    and should be used sparingly since it can make code less readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us change our code to be able to take advantage of **interface substitution**.
    First, we will define the two interfaces that we will be calling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following points describe the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by defining interfaces for the external functionality that we want
    to leverage in the UUT. In our case, the UUT is `input.Parser` and we will need
    two dependencies:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `OperationProcessor` interface wraps around the `ProcessOperation` method.
    This functionality will be satisfied by `calculator.Engine` and will calculate
    the mathematical result of the parsed operator and operands.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ValidationHelper` interface wraps around the `CheckInput` method. This
    functionality will be satisfied by `input.Validator` and will ensure that the
    user-supplied input can be processed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Exported dependency interfaces
  prefs: []
  type: TYPE_NORMAL
- en: Note that the interfaces wrapping around dependencies have been exported, as
    can be seen by their capitalized names. It is common practice for interfaces to
    be exported and their corresponding structs to stay inside the package scope.
    This allows us to have fine-grained control over what functionality is exposed
    outside of the current package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we wrap the dependencies of the `input.Parser` type with the newly defined
    interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As we discussed in the previous section, *Interfaces as dependencies*, Go dependencies
    are usually represented as interfaces, instead of struct types. This allows us
    to inject any type that satisfies the given interface, as opposed to only the
    concrete `struct`. This is a very powerful mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Another big advantage of using interfaces to represent dependencies is that
    they allow us to break the dependencies between packages, and write **loosely**
    **coupled code**.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.3* depicts how we can break hard dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Creating loosely coupled code using interfaces ](img/Figure_3.3_B18371.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Creating loosely coupled code using interfaces
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, representing dependencies by using internally defined interfaces
    allows us to break the hard dependencies between modules. The underlying external
    `struct` that satisfies this interface can be created and injected into the UUT
    outside this package, without introducing a hard dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, since structs can satisfy multiple interfaces, they also give us
    the flexibility to reduce the scope of operations that we want to have access
    to inside the UUT. This is particularly useful when working with large SDKs or
    complex external APIs, where we might not want to define or mock all the functions.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have refactored the code to leverage the power of interfaces and
    create loosely coupled code, let us see how we can make use of their power during
    testing as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to creating mocks, two popular mocking frameworks allow us to
    easily generate and assert on mocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`golang/mock` is an open source framework that was first released in March
    2011\. You can read all about it at [https://github.com/golang/mock](https://github.com/golang/mock).
    It consists of a mocking package and a code generation tool, `mockgen`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`testify/mock` is an open source framework that was released in October 2012\.
    You can read all about it at [https://github.com/stretchr/testify/#mock-package](https://github.com/stretchr/testify/#mock-package).
    Just like `golang/mock`, it consists of a mocking package and a code generation
    tool, `mockery`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two frameworks offer a lot of similar functionality, so choosing one can
    seem like a bit of an arbitrary choice. At the time of writing, the `testify/mock`
    package has been imported by over 13,000 packages (see [https://pkg.go.dev/github.com/stretchr/testify/mock?tab=importedby](https://pkg.go.dev/github.com/stretchr/testify/mock?tab=importedby)),
    while the `golang/mock` package has been imported by over 12,000 packages (see
    [https://pkg.go.dev/github.com/golang/mock/gomock?tab=importedby](https://pkg.go.dev/github.com/golang/mock/gomock?tab=importedby)).
    This further underlines that they are two very popular frameworks for Go developers.
  prefs: []
  type: TYPE_NORMAL
- en: As we will see in the next section, *Working with assertion frameworks*, `testify`
    also provides a very powerful and popular assertion framework. Therefore, we will
    use `testify/mock` as our mocking solution throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this framework, you will need to install its two main components by
    running these commands, which are correct at the time of writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: These two commands will set up the framework for us to use going forward. Make
    sure you run these two commands to be able to follow along with the code examples
    provided throughout this book. While we will use this framework for mocking, the
    concepts discussed apply to `golang/mock` as well.
  prefs: []
  type: TYPE_NORMAL
- en: Generating mocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have prepared our dependencies, selected a mocking framework, and
    then installed it. Now, let us learn how to put it to use. We previously mentioned
    that `testify` provides a code-generation tool for creating mocks. This tool makes
    it easy to generate boilerplate mock code so that we do not need to create and
    maintain it by hand.
  prefs: []
  type: TYPE_NORMAL
- en: Mock generation in `testify` does not require any special annotations. Mocks
    can be generated for interfaces and functions, making them suitable for both **function
    substitution** and **interface substitution**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mockery` command has support for a variety of flags. Here are some common
    ones you might see:'
  prefs: []
  type: TYPE_NORMAL
- en: The `--dir string` flag specifies the directory in which to look for interfaces
    to mock.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `--all` flag specifies to search for through all subdirectories and generate
    mocks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `--name string` flag specifies the name or regular expression to match while
    searching for interfaces to generate mocks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `--output string` flag specifies the directory to place generated mocks
    into. By default, this is configured to be `/mocks`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see all the other options available for this command by using `mockery
    –help`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now generate mocks for our interfaces by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This command looks for all interfaces in the `chapter03` directory and all
    its subdirectories and places the generated files in the `chapter03/mocks` directory.
    The output of this command should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the output, our two interfaces, `OperationProcessor` and
    `ValidationHelper`, have been detected and mocks have been generated for them.
    The generated files will contain structs that will satisfy the defined interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The generated structs also contain a nested struct of the `mock.Mock` type.
    This provides functionality for asserting activity on the mock. This functionality
    is important when verifying mocks, which we will explore next.
  prefs: []
  type: TYPE_NORMAL
- en: Regenerating mocks
  prefs: []
  type: TYPE_NORMAL
- en: It is common for engineering teams to add the mock generation to the specification
    of their Docker files. This will allow the mocks to be generated as part of the
    CI/CD pipeline and be used during the build process.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying mocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are now ready to begin writing tests for the `Parser` struct, which uses
    the generated mocks that we’ve created. *Figure 3**.4* depicts the steps that
    we follow to write the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Writing tests using mocks ](img/Figure_3.4_B18371.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Writing tests using mocks
  prefs: []
  type: TYPE_NORMAL
- en: 'The rough procedure of how our tests will look like using the generated mocks
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create mocks**: We create the mock structs in the **Arrange** step of our
    test. The mock will be separated from any transitive dependencies, so it will
    be easy to initialize. At this point, we should have as many mocks as there are
    direct dependencies of the UUT.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Inject mocks in the UUT**: We inject the mock while creating the UUT in the
    **Arrange** step of our test. Since the mocks satisfy the interfaces of the real
    dependencies, the UUT is not aware of whether it is receiving a real dependency
    or a mock.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`On``On` method on the mock to set up any expectations of the mock behavior.
    We also set up any expected parameter invocations and return values. This concludes
    the **Arrange** step of your test.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Invoke the methods on the UUT**: We write the **Act** section of our test
    as normal. The UUT is unaware that it will be using a mock during its operation,
    so any method invocations will function as normal.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`AssertExpectations``AssertExpectations` method on all of the mocks to ensure
    that all the previously declared expectations are verified.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The usage of mocks is very simple and integrates well with the `testing` library.
    Let us have a look at a simple test of the `Parser` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The simple `TestProcessExpression` highlights the usage of mocks in test writing.
    The usage of the `On` method allows us to easily configure expected behavior for
    all mocked direct dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'As demonstrated, the `On` method can be used to specify detailed expectations.
    Here are some of the ones you will often encounter:'
  prefs: []
  type: TYPE_NORMAL
- en: The `On` method itself. The first parameter of the `On` method is the name of
    the function that should be mocked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `On` method. The arguments can be specific values or we can assert their
    type using the `mock.AnythingOfType` function. We can also use `mock.Anything`
    if we don’t care about making any validation of the given argument, but this should
    be used sparingly because the intention behind the test might be hard to understand
    later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Return` method, which is invoked after the `On` method. It allows you to
    return specific values if the specified method is invoked with the configured
    function parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `On` method. There are shorthand methods for `Once` and `Twice`; otherwise,
    the `Times` method can be used to specify a custom invocation count. The `Unset`
    method can be used to specify that a mock handler should not be called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying expectations
  prefs: []
  type: TYPE_NORMAL
- en: Remember to call the `AssertExpectations` method on each of your mocks if you
    want to assert that they have been called according to the expectations laid out
    by your `On` methods. This gives you fine-grained control over how the UUT interacts
    with its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Consider how much code you would have to write to set up custom types according
    to preconditions and then also verify that dependencies have been invoked according
    to expectations. The `testify/mock` library makes it easy for us to leverage the
    power of mocks in a unified way across all our projects.
  prefs: []
  type: TYPE_NORMAL
- en: Working with assertion frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the `testify/mock` functionality is useful for creating mocks, `testify`
    is best known for its assertion framework. In this section, we will explore some
    common assertion frameworks and how we can use them to further streamline and
    expand our tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have been writing our verifications using `if` statements and invoking
    the correct failure method on the `testing.T` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach is simple, but it does have the following disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Repetition**: A lengthy or complex test will end up making multiple assertions.
    We will then have to repeat this error assertion block multiple times, making
    the test verbose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Difficult to make advanced assertions**: We want to have the same fine-grained
    control over the verifications we undertake on our mocks throughout the rest of
    the test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JUnit` is such an example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While the Go standard library does not provide functionality for assertions,
    two popular assertion frameworks provide this functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '`testify` is an open source assertion framework that provides an easy-to-use
    and powerful assertion package. The `assert` package provides this functionality.
    You can read about it at [https://github.com/stretchr/testify#assert-package](https://github.com/stretchr/testify#assert-package).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ginkgo` is an open source assertion framework that provides **behavior-driven
    development** (**BDD**) style test [writing and assertions. You c](https://github.com/onsi/ginkgo)an
    read about it at [https://github.com/onsi/ginkgo](https://github.com/onsi/ginkgo).
    Adopting this style of testing allows developers to write tests that read like
    natural language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss BDD style tests in [*Chapter 5*](B18371_05.xhtml#_idTextAnchor124),
    *Performing Integration Testing*. Therefore, we will reserve the discussion of
    writing this type of test until then. We will continue our current exploration
    with the `testify` framework.
  prefs: []
  type: TYPE_NORMAL
- en: Using testify
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `assert` package provides many useful functions for creating fine-grained
    assertions. Here are some of the ones that you will encounter often:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assert.Equal` function allows you to check whether two objects are equal.
    If the types checked are pointer-based, a value check on the reference values
    will be conducted. The opposite function, `assert.NotEqual`, also exists:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`assert.Equal` function should not be used for nil values. Instead, the `assert.Nil`
    method should be used. The opposite function, `assert.NotNil`, also exists:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`assert.Contains` function verifies that a specified value is contained inside
    a string, list, or map. The opposite function, `assert.NotContains`, also exists:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`assert.Subset` function verifies that all the values in a specified subset
    are contained in a specified list. The opposite function, `assert.NotSubset`,
    also exists:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `testify/require` package also provides the same assertions, but will terminate
    the test in the case that an assertion fails. This package should be used in the
    case of fatal test errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can replace our previous `if` statement, which makes a call
    to `t.Fatal`, with the following single line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Augmenting the testing package
  prefs: []
  type: TYPE_NORMAL
- en: You should use assertion frameworks to complement the simplicity of the `testing`
    package. As you begin to write more Go code, you should familiarize yourself with
    the assertion frameworks functionality and begin to use them in your tests.
  prefs: []
  type: TYPE_NORMAL
- en: Asserting errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One final aspect to cover when discussing assertions is how to verify errors.
    Sometimes, we want to verify not only that an error occurs, but that the correct
    error message is also returned. You should ensure that your tests verify such
    error messages when appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: The `assert.EqualError` function verifies that a returned error is not `nil`
    and that its message is equal to the provided string. This will make it easy to
    verify your error messages. As with all the functions we have seen so far, the
    `require` package also provides this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at an example that verifies an error scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The test creates a variable called `expectedErrMsg`, which represents the error
    message that the mock will return. This message is then passed to the `assert.Contains`
    function, which will verify it against the error returned by the `ProcessExpression`
    method invoked on the UUT.
  prefs: []
  type: TYPE_NORMAL
- en: Custom error types
  prefs: []
  type: TYPE_NORMAL
- en: You can also create your own custom error types instead of relying solely on
    Go’s built-in `error` type. This will provide you with type safety on error checking,
    instead of relying on error messages, which might change and make your tests brittle.
  prefs: []
  type: TYPE_NORMAL
- en: Mocks and assertion frameworks are tools that we use to easily write tests.
    However, even the most skilled test writer will struggle to test code that is
    badly designed. The iterative nature of TDD together with good software design
    principles will result in testable, maintainable code.
  prefs: []
  type: TYPE_NORMAL
- en: Writing testable code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final aspect we will cover in this chapter is how to write testable code
    using the **SOLID** software design principles. As we have seen multiple times
    already, well-designed code is also easy-to-test code. Application code that is
    difficult to test is often a sign that the application will be hard to change
    and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: These five powerful principles were introduced in a paper by Robert C. Martin
    in 2000, then later published in his book *Agile Software Development, Principles,
    Patterns, and Practices*. These principles help Agile teams deliver maintainable,
    easy-to-refactor code.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.5* summarizes the SOLID design principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – The SOLID design principles ](img/Figure_3.5_B18371.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – The SOLID design principles
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us recap the SOLID principles and what they mean for test writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single Responsibility Principle** (**SRP**): For this, entities should have
    a single job and a single reason to change. This principle will keep testing code
    simple since the scope of the functionality provided by the class is small. We
    can then focus our efforts on covering edge cases, as opposed to covering a large
    number of methods.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Open-Closed Principle** (**OCP**): For this, entities should be open for
    extension, but closed for modification. This principle translates to ensuring
    that code changes extend but don’t break existing behavior. Code that is backward-compatible
    by design will not require numerous test changes. Instead, the new/extended functionality
    can be covered by new test cases, ensuring that the test suite continues to be
    stable.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Liskov Substitution Principle** (**LSP**): For this, every subclass or derived
    class should satisfy the behavior of its parent or base class. Since Go does not
    have inheritance, you might be tempted to conclude that it does not apply. However,
    we achieve polymorphism using interfaces, so we can express this principle in
    terms of the contracts they set. Code that maintains substitutable interfaces
    will be easy to test, as it will again not require many test changes to the existing
    suite.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Interface Segregation Principle** (**ISP**): For this, client code should
    not be forced to implement methods or interfaces that it does not use. This principle
    encourages the usage of small interfaces, which only wrap around a single responsibility.
    Interfaces should be defined on the side of the client/calling code, which should
    only define interface methods for the functionality they are interested in using.
    Small interfaces lead to small mocks, which, in turn, lead to simple test setups
    and assertions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Dependency Inversion Principle** (**DIP**): For this, entities should depend
    on abstractions, not concretions. This principle encourages using interfaces to
    represent dependencies. We discussed this principle in the *Dependency injection*
    section of this chapter. We saw that using this technique in combination with
    the power of interfaces will produce loosely coupled code that is easier to test,
    due to fewer out-of-package dependencies that need to be set up.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we have seen, interfaces are central to the implementation of SOLID principles
    in Go. They should be used to write code that is easy to maintain and refactor.
    Since refactoring is a central part of the TDD practice, easy-to-refactor code
    will also be easy to test code.
  prefs: []
  type: TYPE_NORMAL
- en: The SOLID entity
  prefs: []
  type: TYPE_NORMAL
- en: Remember that in Go the entity should be the package, not the struct. Packages
    provide their own APIs, which establish their own contracts and interfaces. Keep
    the SOLID principles in mind when designing your package APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we expanded on unit testing essentials by learning how to handle
    code dependencies. We began by introducing DI and exploring different approaches
    to how this is done in Go. You learned how to use mocks to have fine-grained control
    over the preconditions that your test runs in, as well as how to generate them
    using the `testify/mock` framework. Then, we explored different assertion frameworks
    and how to use them to streamline our tests. Finally, we discussed the SOLID principles,
    which will help us to write testable code.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B18371_04.xhtml#_idTextAnchor085), *Building Efficient Test
    Suites*, we will begin to look at our tests as a collection, ensuring they complement
    each other and cover edge cases. We will also explore the popular Go technique
    of **table-driven testing**.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue the existing implementation of the simple calculator by implementing
    and testing the remaining operations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subtraction
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplication
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Division
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that you use all the techniques we have used so far to produce well-tested
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Clean Architecture: A Craftsman’s Guide to Software Structure and Design:
    A Craftsman’s Guide to Software Structure and Design*, Robert C. Martin, published
    by Addison-Wesley'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Design patterns: elements of reusable object-oriented software*, Erich Gamma
    et al., published by Addison Wesley'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Compile-time Dependency Injection With Go Cloud’s Wire*, *The Go blog*, available
    at [https://go.dev/blog/wire](https://go.dev/blog/wire)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
