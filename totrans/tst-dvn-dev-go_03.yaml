- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Mocking and Assertion Frameworks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟和断言框架
- en: In the previous chapter, we explored the fundamentals of writing tests in Go.
    We explored the importance of packages, the organization of test files alongside
    source code, and how to use Go’s `testing` package to write tests and benchmarks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了在Go中编写测试的基础知识。我们探讨了包的重要性、测试文件与源代码的组织方式，以及如何使用Go的`testing`包编写测试和基准测试。
- en: We demonstrated the concepts and fundamentals of writing tests in Go with code
    samples from the `Calculator` use case. The simple examples we have looked at
    so far have not included any external dependencies, which can make test setup
    and verification much more complex.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`计算器`用例的代码示例展示了编写Go测试的概念和基础知识。我们迄今为止看到的简单示例没有包含任何外部依赖项，这可能会使测试设置和验证变得更加复杂。
- en: In this chapter, we will begin to look at how we can isolate the unit under
    test from its dependencies, keeping testing and assertions as simple and fast
    as possible. The easiest way to achieve this in Go is by leveraging the power
    of interfaces.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始探讨如何将测试单元从其依赖项中隔离出来，使测试和断言尽可能简单和快速。在Go中实现这一点的最简单方法是通过利用接口的力量。
- en: We will expand upon the `Calculator` example by introducing dependencies to
    our main components. Then, we will learn how to generate mocks for these dependencies
    of the **unit under test** (**UUT**), enabling us to control their behavior.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过向主组件引入依赖来扩展`计算器`示例。然后，我们将学习如何为这些**被测试单元**（**UUT**）的依赖项生成模拟，使我们能够控制它们的行为。
- en: Then, we will explore some external, open source assertion libraries that are
    often used by Go engineers. Up until now, we have written some simple assertions
    ourselves. This can be repetitive and limiting. The `testify` and `ginkgo` assertion
    libraries are two popular choices that can be used to supplement Go’s `testing`
    package.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将探索一些外部开源断言库，这些库通常被Go工程师使用。到目前为止，我们自己编写了一些简单的断言。这可能是重复的并且有限制的。`testify`和`ginkgo`断言库是两种流行的选择，可以用来补充Go的`testing`包。
- en: Finally, we will turn away from exploring test code and mechanisms and look
    at design techniques for writing testable code by reviewing the **SOLID** principles
    of object-oriented design. We will learn what they are and how they can be applied
    when writing code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将从探索测试代码和机制转向查看编写可测试代码的设计技术，通过回顾面向对象设计的**SOLID**原则。我们将了解它们是什么以及如何在编写代码时应用它们。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using interfaces to wrap dependencies
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用接口封装依赖项
- en: How to generate and use mocks to test code in isolation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何生成和使用模拟来隔离测试代码
- en: The usage of popular assertion frameworks
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流行断言框架的使用
- en: What the **SOLID** design principles are
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SOLID**设计原则是什么'
- en: Best practices for writing testable code
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写可测试代码的最佳实践
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need to have **Go version 1.19** or later installed to run the code
    samples in this chapter. The installation process is described on the official
    Go documentation at [https://go.dev/doc/install](https://go.dev/doc/install).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装**Go版本1.19**或更高版本才能运行本章中的代码示例。安装过程在官方Go文档[https://go.dev/doc/install](https://go.dev/doc/install)中描述。
- en: The code examples included in this book are publicly available at [https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter03](https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter03).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本书包含的代码示例在[https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter03](https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter03)公开可用。
- en: Interfaces as dependencies
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作为依赖项的接口
- en: As always, implementing and exploring unit testing techniques begins with exploring
    code writing techniques. This is a theme we will see regularly throughout this
    book. We cannot study testing in isolation. It requires insight into the code
    design and its intended purpose.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，实施和探索单元测试技术从探索代码编写技术开始。这是我们将在整本书中经常看到的一个主题。我们不能孤立地研究测试。它需要了解代码设计和其预期目的的洞察。
- en: 'In this section, we will look at the concept of **software dependencies** and
    how to manage them. *Figure 3**.1* depicts the three main types of dependencies:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨**软件依赖项**的概念以及如何管理它们。*图3**.1*展示了三种主要的依赖类型：
- en: '![Figure 3.1 – Types of dependencies from the point of view of the UUT ](img/Figure_3.1_B18371.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 从UUT的角度看依赖类型](img/Figure_3.1_B18371.jpg)'
- en: Figure 3.1 – Types of dependencies from the point of view of the UUT
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 从UUT的角度看依赖类型
- en: 'From the viewpoint of the UUT, the four main types of dependencies are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从UUT的角度看，四种主要的依赖类型如下：
- en: '**Direct internal dependencies**: These contain internal functionality that
    your **UUT** imports. These dependencies could be defined in the same package
    or module as **UUT**, but are required to deliver its functionality.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直接内部依赖**：这些包含UUT导入的内部功能。这些依赖项可以定义在UUT相同的包或模块中，但需要提供其功能。'
- en: '**Transitive internal dependencies**: These contain internal functionality
    that the **Direct internal dependency** parts of your **UUT** import. These dependencies
    could also be defined in the same package or module.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传递内部依赖**：这些包含**直接内部依赖**部分的UUT导入的内部功能。这些依赖项也可以定义在相同的包或模块中。'
- en: '**Direct external dependencies**: These contain third-party functionality that
    your **UUT** imports. These could be libraries or service APIs that you might
    rely on, but which are not contained in your current module.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直接外部依赖**：这些包含UUT导入的第三方功能。这些可能是你可能会依赖的库或服务API，但它们不包含在你的当前模块中。'
- en: '**Transitive external dependencies**: These contain external functionality
    that your **Direct external dependencies** rely on, but which are in a separate
    module. Due to the way that Go builds the source code and required libraries into
    runnable executables, these transitive dependencies will also be contained alongside
    your code during application release.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传递外部依赖**：这些包含你的**直接外部依赖**所依赖的外部功能，但位于单独的模块中。由于Go将源代码和所需库构建成可运行的可执行文件的方式，这些传递依赖也将与应用程序发布时的代码一起包含在内。'
- en: The dependencies of the UUT are required for the UUT to be able to correctly
    deliver its functionality. Consequently, they are also required to completely
    test its functionality. We will explore techniques for handling code dependencies
    throughout this section and chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: UUT的依赖对于UUT能够正确提供其功能是必需的。因此，它们也是完全测试其功能所必需的。在本节和本章中，我们将探讨处理代码依赖的技术。
- en: Don’t reinvent the wheel
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 不要重新发明轮子
- en: Writing code that relies on dependencies is a normal, and recommended, practice
    for software design. It allows us to reuse behavior and implementation in multiple
    places. This, coupled with Go’s powerful module and package system, makes it easy
    and fast to write complex code. We explored Go’s modules and packages in [*Chapter
    2*](B18371_02.xhtml#_idTextAnchor035), *Unit* *Testing Essentials*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 编写依赖于依赖的代码是软件设计中的正常且推荐的做法。它允许我们在多个地方重用行为和实现。结合Go强大的模块和包系统，这使得编写复杂代码变得既容易又快速。我们在[*第2章*](B18371_02.xhtml#_idTextAnchor035)
    *单元测试基础*中探讨了Go的模块和包。
- en: Dependency injection
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入
- en: One popular and common technique for handling dependencies in code is the concept
    of **dependency injection** (**DI**). This is a simple yet effective design pattern
    for creating loosely coupled code, which allows us to implement code without the
    concerns of its dependencies.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 处理代码依赖的一种流行且常见的技术是**依赖注入**（**DI**）的概念。这是一个简单而有效的设计模式，用于创建松散耦合的代码，使我们能够实现代码，而不必担心其依赖。
- en: DI is a style of writing code in which the UUT or function receives other types
    or functions that it depends on during initialization. Fundamentally, DI is nothing
    more than passing the correct parameters to a function, which then uses these
    to create the UUT.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: DI是一种编写代码的风格，其中UUT或函数在初始化期间接收它所依赖的其他类型或函数。从根本上讲，DI不过是将正确的参数传递给一个函数，然后该函数使用这些参数来创建UUT。
- en: This technique is one of the principles of SOLID design, namely the letter *D*,
    which stands for the principle of **dependency inversion**. We will explore all
    the principles later in this chapter, in the *Writing testable* *code* section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术是SOLID设计原则之一，即字母*D*，代表**依赖反转**原则。我们将在本章的*编写可测试代码*部分探讨所有原则。
- en: Why is it called injection?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么叫注入？
- en: The term *injection* simply signifies that the dependencies are not created
    by the UUT that requires them but passed to it from further up the stack. They
    can be injected either by constructor/function injection or by the use of frameworks.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*注入*仅仅表示依赖不是由需要它们的UUT创建的，而是从堆栈更高处传递给它的。它们可以通过构造函数/函数注入或使用框架来实现注入。
- en: '*Figure 3**.2* describes the main steps of what DI typically entails:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3.2* 描述了依赖注入通常涉及的主要步骤：'
- en: '![Figure 3.2 – The main steps of dependency injection ](img/Figure_3.2_B18371.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 依赖注入的主要步骤](img/Figure_3.2_B18371.jpg)'
- en: Figure 3.2 – The main steps of dependency injection
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 依赖注入的主要步骤
- en: 'We can see the following sequence of calls:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到以下调用序列：
- en: At the start, we begin by attempting to `struct`. We already know that Go structs
    do not provide constructors, so the initialization process will involve inspecting
    the dependencies that the UUT requires. We will see techniques for making the
    need for dependencies explicit in the next section.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始时，我们首先尝试 `struct`。我们已经知道 Go 结构体不提供构造函数，因此初始化过程将涉及检查 UUT 所需的依赖项。我们将在下一节中看到如何使依赖项的需求显式化的技术。
- en: If the UUT has any direct dependencies, then we will `struct`, either from the
    same module or another external module.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 UUT 有任何直接依赖项，那么我们将 `struct`，无论是来自同一模块还是另一个外部模块。
- en: When initializing the direct dependency, we might discover transitive dependencies
    that the direct dependencies need during initialization. We will then **Request
    the** **transitive dependency**.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当初始化直接依赖项时，我们可能会发现直接依赖项在初始化过程中需要的传递依赖项。然后我们将**请求****传递依赖项**。
- en: The dependency request process is repeated for all direct and transitive dependencies.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依赖项请求过程会重复对所有直接和传递依赖项进行。
- en: Once each dependency has been successfully created, it is injected into the
    creation of the previous dependency or the UUT, if it is a direct dependency.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦每个依赖项都成功创建，它就会被注入到先前依赖项或 UUT 的创建中，如果它是直接依赖项。
- en: The dependency graph
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖图
- en: Due to the way that dependencies need to be created and then, in turn, injected,
    this process is known as *constructing the dependency graph*. This is a directed,
    acyclic graph. This graph allows the compiler to start at the root and then traverse
    it while building all the custom types it requires while running the main program.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于依赖项需要被创建，然后依次注入，这个过程被称为*构建依赖图*。这是一个有向无环图。这个图允许编译器从根开始，然后在构建主程序运行时所需的所有自定义类型时遍历它。
- en: Implementing dependency injection
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现依赖注入
- en: While introducing DI, we briefly mentioned that structs do not have constructors
    and therefore this process might require the investigation of the properties and
    fields of a `struct`. Let us have a look at how we can implement DI in Go.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍 DI 时，我们简要提到了结构体没有构造函数，因此这个过程可能需要调查 `struct` 的属性和字段。让我们看看我们如何在 Go 中实现 DI。
- en: 'Fundamentally, there are two ways we can go about injecting dependencies:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们可以通过两种方式来处理依赖注入：
- en: '`struct`. This is an intuitive way to construct instances, but it does require
    that all dependencies be created before the invocation of the function.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct`。这是一种构建实例的直观方式，但它确实要求在调用函数之前创建所有依赖项。'
- en: '`struct` and then setting the fields of the dependencies as you require them.
    This can either be done by directly setting them as fields on the UUT instance,
    or by invoking setter methods that set them on the fields. The dependencies are
    not immutable, so they do not require the UUT instance to be recreated as they
    are set. This way of creating the UUT and its dependencies does not require that
    all dependencies be created before initializing and beginning to use the UUT,
    but it also does not guarantee that all the dependencies will be set by a certain
    time, nor does it guarantee they won’t be changed later. This could require more
    application code for `nil` value checks, as well as other subtle bugs if dependencies
    change.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct` 然后根据需要设置依赖项的字段。这可以通过直接在 UUT 实例上设置字段或通过调用设置器方法来设置字段来实现。依赖项不是不可变的，因此它们不需要在设置时重新创建
    UUT 实例。这种创建 UUT 及其依赖项的方式不需要在初始化和开始使用 UUT 之前创建所有依赖项，但它也不保证所有依赖项将在某个时间点设置，也不保证它们以后不会被更改。这可能会需要更多的应用程序代码来检查
    `nil` 值，以及如果依赖项更改，可能会出现其他微妙的错误。'
- en: 'Then, each method can be used in two ways:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每个方法都可以以两种方式使用：
- en: '**Manual invocation**: This means that we call and create the UUT struct and
    its dependencies manually. In this process, you have full control over the creation
    and invocation of dependencies, but they can become difficult to manage for larger
    codebases.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手动调用**：这意味着我们手动调用和创建 UUT 结构体及其依赖项。在这个过程中，你对依赖项的创建和调用有完全的控制权，但对于较大的代码库来说，它们可能难以管理。'
- en: '**Dependency injection frameworks**: This means that you import another dependency
    into your project that can automate this process using advanced techniques such
    as reflection or code generation, which then leverage the dependency graph to
    create the dependencies in the correct sequence. This method is much more sustainable
    for large codebases.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖注入框架**：这意味着你将另一个依赖项导入到你的项目中，可以使用反射或代码生成等高级技术来自动化此过程，然后利用依赖图以正确的顺序创建依赖项。这种方法对于大型代码库来说更加可持续。'
- en: 'When it comes to DI frameworks, there are two popular open source choices that
    you can use in your code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到依赖注入框架时，有两个流行的开源选择，你可以在代码中使用：
- en: '`dig`: This uses reflection to build your dependency graph and successfully
    construct your instances. You can read about how to use it at [https://github.com/uber-go/dig](https://github.com/uber-go/dig).'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dig`：这个工具使用反射来构建你的依赖图并成功构建你的实例。你可以在[https://github.com/uber-go/dig](https://github.com/uber-go/dig)上阅读有关如何使用它的信息。'
- en: '`wire`: This uses reflection and code generation for DI. You can read about
    how to use it at [https://github.com/google/wire](https://github.com/google/wire).'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wire`：这个工具使用反射和代码生成来实现依赖注入。你可以在[https://github.com/google/wire](https://github.com/google/wire)上阅读有关如何使用它的信息。'
- en: Reducing complexity
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 降低复杂性
- en: Remember that one of the core principles of Go code and software design is simplicity.
    You should keep your code as simple as possible, avoiding the lengthy constructors
    that have been seen in other legacy languages.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Go代码和软件设计的核心原则之一是简单性。你应该尽可能保持你的代码简单，避免在其他遗留语言中看到的冗长构造函数。
- en: When it comes to dependencies, they are usually represented using corresponding
    interface types. This is an approach unique to Go, regardless of how you choose
    to inject your dependencies. Let us look at their role in software design a little
    bit more closely.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到依赖项时，它们通常使用相应的接口类型来表示。这是Go特有的方法，无论你选择如何注入依赖项。让我们更仔细地看看它们在软件设计中的作用。
- en: '**Interfaces** are named collections of zero or more methods. Here are some
    key highlights of their behavior:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口**是零个或多个方法的命名集合。以下是它们行为的一些关键要点：'
- en: The y are the primary way we can achieve **polymorphism** is in Go.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Go中，我们实现多态的主要方式是使用接口。
- en: The compiler enforces them and implicitly casts a `struct` to its corresponding
    interface.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器强制执行这些规则，并且隐式地将`struct`转换为相应的接口。
- en: To implement an interface, a `struct` needs to implement its defined methods.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要实现一个接口，一个`struct`需要实现其定义的方法。
- en: A `struct` can implement multiple interfaces, so long as it satisfies its method
    signatures.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`struct`可以实现多个接口，只要它满足其方法签名。
- en: An interface with zero methods is the empty interface and its type is `interface`
    `{}`. This is useful in certain cases, but the interfaces you create will have
    one or more methods.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有零个方法的接口是空接口，其类型是`interface` `{}`。这在某些情况下很有用，但你创建的接口将有一个或多个方法。
- en: The zero value of interfaces is nil. We will need to handle this in our code
    as we begin to use interfaces to wrap around our dependencies.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口的零值是`nil`。在我们开始使用接口来包装依赖项时，我们需要在代码中处理这个问题。
- en: Interfaces define methods, not functions
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接口定义的是方法，而不是函数
- en: Remember that interfaces define methods, not functions. As we’ve seen with the
    `Engine` definition, methods that correspond to the signature of the interface
    will need to be defined on the struct we want to use in place of this interface.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，接口定义的是方法，而不是函数。正如我们在`Engine`定义中看到的，与接口签名相对应的方法需要在我们要使用的`struct`上定义。
- en: 'Let us look at a DI example; this can be found in the `chapter03/di/manual/calculator.go`.
    We can define a simple `Adder` interface with the following snippet:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个依赖注入的例子；这个例子可以在`chapter03/di/manual/calculator.go`中找到。我们可以定义一个简单的`Adder`接口，如下所示：
- en: '[PRE0]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `Adder` interface defines the `Add` method. Note that this method takes
    in two `float64` parameters and returns one `float64` return value. In our case,
    `Engine` will satisfy this interface as it implements this method:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Adder`接口定义了`Add`方法。请注意，这个方法接受两个`float64`参数并返回一个`float64`返回值。在我们的例子中，`Engine`将满足这个接口，因为它实现了这个方法：'
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When we initialize `Engine`, we can return the `Engine` struct:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们初始化`Engine`时，我们可以返回`Engine`结构体：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A simple `Calculator` then makes use of this `Engine` for its adder functionality
    and prints out the result:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的`Calculator`随后使用这个`Engine`来实现其加法功能并打印出结果：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`Engine` is a dependency of `Calculator`, so it is a parameter of the `NewCalculator`
    function. `Adder` is then invoked inside the `PrintAdd` method, where its functionality
    is required. Therefore, the initialization process of `Calculator` requires an
    instance of `Engine` to be created to compile:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Engine` 是 `Calculator` 的依赖，因此它是 `NewCalculator` 函数的参数。`Adder` 在 `PrintAdd`
    方法中被调用，那里需要它的功能。因此，`Calculator` 的初始化过程需要一个 `Engine` 实例来编译：'
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This example uses the *manual invocation* of DI. As the dependency graph grows
    in size and complexity, this initialization function will become increasingly
    cumbersome and require changes. This is where DI frameworks can help simplify
    our code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 本例使用 DI 的*手动调用*。随着依赖图的大小和复杂性的增长，这个初始化函数将变得越来越繁琐，并需要做出改变。这就是 DI 框架可以帮助简化我们的代码的地方。
- en: 'Using the previously introduced `wire` framework, we can define an `InitCalc`
    function in the `/chapter03/di/wire/wire.go` file, which will take care of initializing
    `Calculator` with its `Engine`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前引入的 `wire` 框架，我们可以在 `/chapter03/di/wire/wire.go` 文件中定义一个 `InitCalc` 函数，它将负责使用
    `Engine` 初始化 `Calculator`：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This `wire.Build` function takes in the `Set` that matches the `Adder` interface
    to the `Engine` struct. At the top of the file, we make use of a build tag to
    exclude this file from the final binary, and use the generated replacement file
    when we run our application.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `wire.Build` 函数接受一个 `Set`，将 `Adder` 接口与 `Engine` 结构体匹配。在文件顶部，我们使用构建标签排除此文件，并在运行我们的应用程序时使用生成的替换文件。
- en: 'Next, we must install the wire tool and run it in the correct directory:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须安装 wire 工具并在正确的目录下运行它：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This command generates the `wire_gen.go` file, which contains the implementation
    of the `InitCalc` function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令生成 `wire_gen.go` 文件，其中包含 `InitCalc` 函数的实现：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This function contains the dependency creation code that we had previously
    written by hand. As it is now maintained and generated by wire, changes will not
    have to be maintained manually and the main function is now simpler:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数包含我们之前手动编写的依赖创建代码。由于现在由 wire 维护和生成，因此不需要手动维护，主函数现在更简单：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we can build the application, generating the initialization function
    and binding it into the Go binary. Then, we can run the executable as usual:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以构建应用程序，生成初始化函数并将其绑定到 Go 可执行文件中。然后，我们可以像往常一样运行可执行文件：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: DI frameworks simplify the code we write and maintain but do require adding
    new steps to the build process, as well as an extra cognitive load when first
    starting with them. We explored how the `wire` DI library works in this section,
    but we will be using manual injection going forward so that we have more control
    and can explore the code together better.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: DI 框架简化了我们编写的代码和维护工作，但确实需要在构建过程中添加新步骤，以及在使用它们时增加额外的认知负担。在本节中，我们探讨了 `wire` DI
    库的工作原理，但我们将继续使用手动注入，以便我们能够更好地控制代码并共同探索。
- en: Use case – continued implementation of the calculator
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例 - 计算器的继续实现
- en: In this section, we will make use of the techniques we have seen so far to expand
    upon the implementation of the calculator from [*Chapter 2*](B18371_02.xhtml#_idTextAnchor035),
    *Unit* *Testing Essentials*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将利用迄今为止所学的技术来扩展 *第 2 章* 中计算器实现的实现，*单元测试基础*。
- en: 'Setting aside the correct procedure of `input.Parser` struct:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 除去 `input.Parser` 结构体的正确使用方法：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we know from [*Chapter 2*](B18371_02.xhtml#_idTextAnchor035), *Unit Testing
    Essentials*, where we first looked at this example, `Parser` depends on `Validator`
    and `calculator.Engine`. These two structs are the direct dependencies of `Parser`.
    Then, these dependencies are used to deliver the functionality of the `ProcessExpression`
    method.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从 *第 2 章* 中了解到的，*单元测试基础*，我们首先看到了这个例子，`Parser` 依赖于 `Validator` 和 `calculator.Engine`。这两个结构体是
    `Parser` 的直接依赖。然后，这些依赖被用来实现 `ProcessExpression` 方法的功能。
- en: 'Regardless of whether we use third-party DI frameworks or we create the corresponding
    structs manually, writing tests for this relatively simple code snippet involves:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们使用第三方 DI 框架还是手动创建相应的结构体，为这个相对简单的代码片段编写测试都涉及：
- en: Initializing the `Parser` struct with all its direct and transitive dependencies.
    This could involve a lengthy setup, with external dependencies that might extend
    the scope of the test.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化 `Parser` 结构体及其所有直接和间接依赖。这可能涉及一个漫长的设置过程，可能包含外部依赖，这可能会扩展测试的范围。
- en: Once these main building blocks have been created, we need to set up their pre-condition
    state. This could involve an even more complicated setup, which could have unintended
    consequences as well.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦创建了这些主要构建块，我们需要设置它们的先决状态。这可能涉及一个更复杂的设置，也可能会有意想不到的后果。
- en: When it comes to verification, we might need to assert the internal state of
    dependencies to ensure that they are behaving as expected. This reliance on the
    internal state of dependencies would then make the tests more brittle since changes
    to the dependencies would break the tests.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在验证方面，我们可能需要断言依赖项的内部状态以确保它们按预期行为。这种对依赖项内部状态的依赖会使测试更加脆弱，因为依赖项的变化会破坏测试。
- en: Now that we understand how to build code that requires direct dependencies,
    we will begin to explore mechanisms that can help us in testing such dependencies.
    We will leverage Go development tools to make testing and assertions easier.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何构建需要直接依赖项的代码，我们将开始探索可以帮助我们在测试中测试这些依赖项的机制。我们将利用Go开发工具使测试和断言更容易。
- en: Controlling test scope
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 控制测试范围
- en: When it comes to types that have many dependencies, the scope of the test setup
    and assertion can increase beyond the UUT. We need a mechanism that allows us
    to test the UUT in isolation, which also has the benefit of keeping the test scope
    small.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到具有许多依赖项的类型时，测试设置和断言的范围可能会超出UUT。我们需要一种机制，使我们能够在隔离的情况下测试UUT，这也有利于保持测试范围小。
- en: Exploring mocks
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索模拟
- en: In this section, we will explore one of the mechanisms that allows us to test
    code that relies on dependencies. We will see how to use and generate mocks, allowing
    us to verify the UUT in isolation from the behavior of its dependencies.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一种允许我们测试依赖于依赖项的代码的机制。我们将了解如何使用和生成模拟，从而允许我们在隔离其依赖项的行为的情况下验证UUT。
- en: '**Mocks** are sometimes known as **test doubles** and are a simple but powerful
    concept. They satisfy the interfaces but are fake versions of the real implementations.
    We have full control over these fake implementations, giving us the freedom to
    control their behavior. However, if the real implementation changes and our mocks
    do not, then our tests will give us false confidence.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**模拟**有时也被称为**测试替身**，这是一个简单但强大的概念。它们满足接口，但却是真实实现的假版本。我们对这些假实现有完全的控制权，这给了我们控制它们行为的自由。然而，如果真实实现发生变化而我们的模拟没有变化，那么我们的测试将给我们带来错误的信心。'
- en: 'In Go, we have the following different mocking options:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，我们有以下不同的模拟选项：
- en: '**Function substitution**: This means sending replacement fake functions to
    the UUT. This is easy to do in Go, which has native support for **higher-order
    functions**. We can override function variables and parameters, replacing the
    behavior of the UUT.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数替换**：这意味着向UUT发送替换的假函数。在Go中，这很容易做到，因为Go有对**高阶函数**的原生支持。我们可以覆盖函数变量和参数，替换UUT的行为。'
- en: '**Interface substitution**: This means injecting fake versions of the interfaces
    that the UUT depends on. These are fake stubbed implementations that satisfy the
    interfaces of the real implementation. They can then be used to replace the full
    implementations, without the UUT even being aware of it.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口替换**：这意味着注入依赖于UUT的接口的假版本。这些是满足真实实现接口的假桩实现。然后，它们可以用来替换完整的实现，而UUT甚至不会意识到这一点。'
- en: Higher-order function refresher
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数复习
- en: A higher-order function is a function that either takes in another function
    as a parameter or returns a function. Go functions are just like any other type.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数是一个函数，它要么接受另一个函数作为参数，要么返回一个函数。Go函数就像任何其他类型一样。
- en: The use of function substitution is less prevalent than interface substitution
    and should be used sparingly since it can make code less readable.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 函数替换的使用不如接口替换普遍，应该谨慎使用，因为它可以使代码的可读性降低。
- en: 'Now, let us change our code to be able to take advantage of **interface substitution**.
    First, we will define the two interfaces that we will be calling:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们改变我们的代码，以便能够利用**接口替换**。首先，我们将定义我们将要调用的两个接口：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following points describe the preceding code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点描述了前面的代码：
- en: 'We begin by defining interfaces for the external functionality that we want
    to leverage in the UUT. In our case, the UUT is `input.Parser` and we will need
    two dependencies:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先定义外部功能接口，我们希望在UUT中利用这些功能。在我们的情况下，UUT是`input.Parser`，我们需要两个依赖项：
- en: The `OperationProcessor` interface wraps around the `ProcessOperation` method.
    This functionality will be satisfied by `calculator.Engine` and will calculate
    the mathematical result of the parsed operator and operands.
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OperationProcessor`接口围绕`ProcessOperation`方法。此功能将由`calculator.Engine`实现，并计算解析运算符和操作数的数学结果。'
- en: The `ValidationHelper` interface wraps around the `CheckInput` method. This
    functionality will be satisfied by `input.Validator` and will ensure that the
    user-supplied input can be processed.
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ValidationHelper`接口围绕`CheckInput`方法。此功能将由`input.Validator`实现，并确保用户提供的输入可以被处理。'
- en: Exported dependency interfaces
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 导出的依赖接口
- en: Note that the interfaces wrapping around dependencies have been exported, as
    can be seen by their capitalized names. It is common practice for interfaces to
    be exported and their corresponding structs to stay inside the package scope.
    This allows us to have fine-grained control over what functionality is exposed
    outside of the current package.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，围绕依赖关系的接口已被导出，正如它们的首字母大写名称所示。将接口导出并将相应的结构体保留在包作用域内是一种常见的做法。这使我们能够对当前包之外暴露的功能进行精细控制。
- en: 'Then, we wrap the dependencies of the `input.Parser` type with the newly defined
    interfaces:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`input.Parser`类型的依赖关系用新定义的接口包装起来：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As we discussed in the previous section, *Interfaces as dependencies*, Go dependencies
    are usually represented as interfaces, instead of struct types. This allows us
    to inject any type that satisfies the given interface, as opposed to only the
    concrete `struct`. This is a very powerful mechanism.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一节中讨论的，*作为依赖的接口*，Go依赖通常表示为接口，而不是结构体类型。这允许我们注入任何满足给定接口的类型，而不仅仅是具体的`struct`。这是一个非常强大的机制。
- en: Another big advantage of using interfaces to represent dependencies is that
    they allow us to break the dependencies between packages, and write **loosely**
    **coupled code**.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用接口表示依赖的另一个重大优势是，它们允许我们打破包之间的依赖关系，编写**松散耦合**的代码。
- en: '*Figure 3**.3* depicts how we can break hard dependencies:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.3* 展示了我们可以如何打破硬依赖：'
- en: '![Figure 3.3 – Creating loosely coupled code using interfaces ](img/Figure_3.3_B18371.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 使用接口创建松散耦合的代码](img/Figure_3.3_B18371.jpg)'
- en: Figure 3.3 – Creating loosely coupled code using interfaces
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 使用接口创建松散耦合的代码
- en: As we can see, representing dependencies by using internally defined interfaces
    allows us to break the hard dependencies between modules. The underlying external
    `struct` that satisfies this interface can be created and injected into the UUT
    outside this package, without introducing a hard dependency.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，通过使用内部定义的接口来表示依赖关系，我们可以打破模块之间的硬依赖。满足此接口的底层外部`struct`可以在包外部创建并注入到UUT中，而不会引入硬依赖。
- en: Furthermore, since structs can satisfy multiple interfaces, they also give us
    the flexibility to reduce the scope of operations that we want to have access
    to inside the UUT. This is particularly useful when working with large SDKs or
    complex external APIs, where we might not want to define or mock all the functions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于结构体可以满足多个接口，它们还为我们提供了灵活性，以减少我们希望在UUT内部访问的操作范围。这对于处理大型SDK或复杂的外部API尤其有用，我们可能不想定义或模拟所有函数。
- en: Mocking frameworks
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟框架
- en: Now that we have refactored the code to leverage the power of interfaces and
    create loosely coupled code, let us see how we can make use of their power during
    testing as well.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经重构了代码，利用接口的力量创建松散耦合的代码，让我们看看我们如何在测试期间利用它们的威力。
- en: 'When it comes to creating mocks, two popular mocking frameworks allow us to
    easily generate and assert on mocks:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到创建模拟时，两个流行的模拟框架允许我们轻松生成和断言模拟：
- en: '`golang/mock` is an open source framework that was first released in March
    2011\. You can read all about it at [https://github.com/golang/mock](https://github.com/golang/mock).
    It consists of a mocking package and a code generation tool, `mockgen`.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`golang/mock` 是一个开源框架，它最初于2011年3月发布。您可以在[https://github.com/golang/mock](https://github.com/golang/mock)上了解所有相关信息。它由一个模拟包和一个代码生成工具`mockgen`组成。'
- en: '`testify/mock` is an open source framework that was released in October 2012\.
    You can read all about it at [https://github.com/stretchr/testify/#mock-package](https://github.com/stretchr/testify/#mock-package).
    Just like `golang/mock`, it consists of a mocking package and a code generation
    tool, `mockery`.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testify/mock`是一个开源框架，于2012年10月发布。您可以在[https://github.com/stretchr/testify/#mock-package](https://github.com/stretchr/testify/#mock-package)上阅读所有相关信息。就像`golang/mock`一样，它由一个模拟包和一个代码生成工具`mockery`组成。'
- en: The two frameworks offer a lot of similar functionality, so choosing one can
    seem like a bit of an arbitrary choice. At the time of writing, the `testify/mock`
    package has been imported by over 13,000 packages (see [https://pkg.go.dev/github.com/stretchr/testify/mock?tab=importedby](https://pkg.go.dev/github.com/stretchr/testify/mock?tab=importedby)),
    while the `golang/mock` package has been imported by over 12,000 packages (see
    [https://pkg.go.dev/github.com/golang/mock/gomock?tab=importedby](https://pkg.go.dev/github.com/golang/mock/gomock?tab=importedby)).
    This further underlines that they are two very popular frameworks for Go developers.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个框架提供了很多类似的功能，因此选择其中一个可能看起来有点随意。在撰写本文时，`testify/mock`包已被超过13,000个包导入（见[https://pkg.go.dev/github.com/stretchr/testify/mock?tab=importedby](https://pkg.go.dev/github.com/stretchr/testify/mock?tab=importedby)），而`golang/mock`包已被超过12,000个包导入（见[https://pkg.go.dev/github.com/golang/mock/gomock?tab=importedby](https://pkg.go.dev/github.com/golang/mock/gomock?tab=importedby)）。这进一步强调了它们是Go开发者非常流行的两个框架。
- en: As we will see in the next section, *Working with assertion frameworks*, `testify`
    also provides a very powerful and popular assertion framework. Therefore, we will
    use `testify/mock` as our mocking solution throughout this book.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在下一节“与断言框架一起工作”中将要看到的，`testify`还提供了一个非常强大且流行的断言框架。因此，我们将使用`testify/mock`作为本书中的模拟解决方案。
- en: 'To use this framework, you will need to install its two main components by
    running these commands, which are correct at the time of writing:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此框架，您需要通过运行以下命令安装其两个主要组件，这些命令在撰写本文时是正确的：
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These two commands will set up the framework for us to use going forward. Make
    sure you run these two commands to be able to follow along with the code examples
    provided throughout this book. While we will use this framework for mocking, the
    concepts discussed apply to `golang/mock` as well.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个命令将为我们设置后续使用的框架。请确保运行这两个命令，以便能够跟随本书中提供的代码示例。虽然我们将使用此框架进行模拟，但讨论的概念也适用于`golang/mock`。
- en: Generating mocks
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成模拟
- en: So far, we have prepared our dependencies, selected a mocking framework, and
    then installed it. Now, let us learn how to put it to use. We previously mentioned
    that `testify` provides a code-generation tool for creating mocks. This tool makes
    it easy to generate boilerplate mock code so that we do not need to create and
    maintain it by hand.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经准备好了依赖项，选择了一个模拟框架，然后安装了它。现在，让我们学习如何使用它。我们之前提到`testify`提供了一个用于创建模拟的代码生成工具。这个工具使得生成样板模拟代码变得容易，这样我们就不需要手动创建和维护它。
- en: Mock generation in `testify` does not require any special annotations. Mocks
    can be generated for interfaces and functions, making them suitable for both **function
    substitution** and **interface substitution**.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在`testify`中进行模拟生成不需要任何特殊的注解。可以为接口和函数生成模拟，这使得它们既适用于**函数替换**也适用于**接口替换**。
- en: 'The `mockery` command has support for a variety of flags. Here are some common
    ones you might see:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`mockery`命令支持各种标志。以下是一些您可能会看到的常见标志：'
- en: The `--dir string` flag specifies the directory in which to look for interfaces
    to mock.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--dir string`标志指定了查找要模拟的接口的目录。'
- en: The `--all` flag specifies to search for through all subdirectories and generate
    mocks.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--all`标志指定在所有子目录中搜索并生成模拟。'
- en: The `--name string` flag specifies the name or regular expression to match while
    searching for interfaces to generate mocks.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--name string`标志指定在搜索要生成模拟的接口时匹配的名称或正则表达式。'
- en: The `--output string` flag specifies the directory to place generated mocks
    into. By default, this is configured to be `/mocks`.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--output string`标志指定了放置生成的模拟的目录。默认情况下，这被配置为`/mocks`。'
- en: You can see all the other options available for this command by using `mockery
    –help`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用`mockery –help`来查看此命令的所有其他选项。
- en: 'We can now generate mocks for our interfaces by using the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用以下命令为我们的接口生成模拟：
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This command looks for all interfaces in the `chapter03` directory and all
    its subdirectories and places the generated files in the `chapter03/mocks` directory.
    The output of this command should look like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在`chapter03`目录及其所有子目录中查找所有接口，并将生成的文件放置在`chapter03/mocks`目录中。此命令的输出应如下所示：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As we can see from the output, our two interfaces, `OperationProcessor` and
    `ValidationHelper`, have been detected and mocks have been generated for them.
    The generated files will contain structs that will satisfy the defined interfaces:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中我们可以看到，我们的两个接口，`OperationProcessor` 和 `ValidationHelper`，已经被检测到，并且为它们生成了模拟。生成的文件将包含满足定义的接口的结构体：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The generated structs also contain a nested struct of the `mock.Mock` type.
    This provides functionality for asserting activity on the mock. This functionality
    is important when verifying mocks, which we will explore next.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的结构体还包含一个嵌套的`mock.Mock`类型的结构体。这提供了对模拟活动进行断言的功能。当验证模拟时，这种功能很重要，我们将在下一部分探讨。
- en: Regenerating mocks
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 重新生成模拟
- en: It is common for engineering teams to add the mock generation to the specification
    of their Docker files. This will allow the mocks to be generated as part of the
    CI/CD pipeline and be used during the build process.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于工程团队来说，将模拟生成添加到他们的Docker文件规范中是很常见的。这将允许模拟作为CI/CD管道的一部分生成，并在构建过程中使用。
- en: Verifying mocks
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证模拟
- en: 'We are now ready to begin writing tests for the `Parser` struct, which uses
    the generated mocks that we’ve created. *Figure 3**.4* depicts the steps that
    we follow to write the tests:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始编写针对`Parser`结构体的测试了，它使用了我们创建的生成的模拟。*图3**.4*展示了我们编写测试时遵循的步骤：
- en: '![Figure 3.4 – Writing tests using mocks ](img/Figure_3.4_B18371.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – 使用模拟编写测试](img/Figure_3.4_B18371.jpg)'
- en: Figure 3.4 – Writing tests using mocks
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 使用模拟编写测试
- en: 'The rough procedure of how our tests will look like using the generated mocks
    is as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用生成的模拟，我们的测试将大致按照以下步骤进行：
- en: '**Create mocks**: We create the mock structs in the **Arrange** step of our
    test. The mock will be separated from any transitive dependencies, so it will
    be easy to initialize. At this point, we should have as many mocks as there are
    direct dependencies of the UUT.'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建模拟**：我们在测试的**安排**步骤中创建模拟结构体。模拟将与任何传递依赖项分离，因此将很容易初始化。在这个时候，我们应该有与UUT的直接依赖项一样多的模拟。'
- en: '**Inject mocks in the UUT**: We inject the mock while creating the UUT in the
    **Arrange** step of our test. Since the mocks satisfy the interfaces of the real
    dependencies, the UUT is not aware of whether it is receiving a real dependency
    or a mock.'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在UUT中注入模拟**：我们在测试的**安排**步骤中创建UUT时注入模拟。由于模拟满足真实依赖项的接口，UUT不会意识到它是在接收真实依赖项还是模拟。'
- en: '`On``On` method on the mock to set up any expectations of the mock behavior.
    We also set up any expected parameter invocations and return values. This concludes
    the **Arrange** step of your test.'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟上设置任何期望的模拟行为。我们还设置任何预期的参数调用和返回值。这完成了测试的**安排**步骤。
- en: '**Invoke the methods on the UUT**: We write the **Act** section of our test
    as normal. The UUT is unaware that it will be using a mock during its operation,
    so any method invocations will function as normal.'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在UUT上调用方法**：我们像平常一样编写测试的**行动**部分。UUT在操作过程中不会意识到它将使用模拟，因此任何方法调用都将按正常方式执行。'
- en: '`AssertExpectations``AssertExpectations` method on all of the mocks to ensure
    that all the previously declared expectations are verified.'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有模拟上调用`AssertExpectations`方法以确保所有之前声明的期望都得到了验证。
- en: 'The usage of mocks is very simple and integrates well with the `testing` library.
    Let us have a look at a simple test of the `Parser` type:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟的使用非常简单，并且与`testing`库很好地集成。让我们看看对`Parser`类型的简单测试：
- en: '[PRE17]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The simple `TestProcessExpression` highlights the usage of mocks in test writing.
    The usage of the `On` method allows us to easily configure expected behavior for
    all mocked direct dependencies.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的`TestProcessExpression`突出了在测试编写中模拟的使用。`On`方法的使用使我们能够轻松地为所有模拟的直接依赖项配置预期行为。
- en: 'As demonstrated, the `On` method can be used to specify detailed expectations.
    Here are some of the ones you will often encounter:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如演示所示，`On`方法可以用来指定详细的期望。以下是一些你经常会遇到的：
- en: The `On` method itself. The first parameter of the `On` method is the name of
    the function that should be mocked.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`On` 方法本身。`On` 方法的第一个参数是要模拟的函数的名称。'
- en: The `On` method. The arguments can be specific values or we can assert their
    type using the `mock.AnythingOfType` function. We can also use `mock.Anything`
    if we don’t care about making any validation of the given argument, but this should
    be used sparingly because the intention behind the test might be hard to understand
    later.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`On` 方法。参数可以是特定值，或者我们可以使用 `mock.AnythingOfType` 函数来断言它们的类型。如果我们不关心对给定参数进行任何验证，也可以使用
    `mock.Anything`，但应该谨慎使用，因为测试背后的意图可能难以在以后理解。'
- en: The `Return` method, which is invoked after the `On` method. It allows you to
    return specific values if the specified method is invoked with the configured
    function parameters.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Return` 方法，在 `On` 方法之后调用。如果指定的方法使用配置的函数参数被调用，它允许你返回特定值。'
- en: The `On` method. There are shorthand methods for `Once` and `Twice`; otherwise,
    the `Times` method can be used to specify a custom invocation count. The `Unset`
    method can be used to specify that a mock handler should not be called.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`On` 方法。有 `Once` 和 `Twice` 的简写方法；否则，可以使用 `Times` 方法来指定自定义调用次数。`Unset` 方法可以用来指定模拟处理程序不应该被调用。'
- en: Verifying expectations
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 验证期望
- en: Remember to call the `AssertExpectations` method on each of your mocks if you
    want to assert that they have been called according to the expectations laid out
    by your `On` methods. This gives you fine-grained control over how the UUT interacts
    with its dependencies.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想断言你的模拟根据 `On` 方法中设定的期望被调用，请记得在每个模拟上调用 `AssertExpectations` 方法。这让你能够对 UUT
    如何与其依赖项交互有细粒度的控制。
- en: Consider how much code you would have to write to set up custom types according
    to preconditions and then also verify that dependencies have been invoked according
    to expectations. The `testify/mock` library makes it easy for us to leverage the
    power of mocks in a unified way across all our projects.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑你需要编写多少代码来设置符合预条件的自定义类型，然后根据期望验证依赖项是否已被调用。`testify/mock` 库使我们能够以统一的方式在我们的所有项目中利用模拟的强大功能。
- en: Working with assertion frameworks
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与断言框架一起工作
- en: While the `testify/mock` functionality is useful for creating mocks, `testify`
    is best known for its assertion framework. In this section, we will explore some
    common assertion frameworks and how we can use them to further streamline and
    expand our tests.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `testify/mock` 功能对于创建模拟很有用，但 `testify` 最出名的是其断言框架。在本节中，我们将探讨一些常见的断言框架以及我们如何使用它们来进一步精简和扩展我们的测试。
- en: 'So far, we have been writing our verifications using `if` statements and invoking
    the correct failure method on the `testing.T` parameter:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用 `if` 语句编写我们的验证，并在 `testing.T` 参数上调用正确的失败方法：
- en: '[PRE18]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This approach is simple, but it does have the following disadvantages:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法很简单，但确实有以下缺点：
- en: '**Repetition**: A lengthy or complex test will end up making multiple assertions.
    We will then have to repeat this error assertion block multiple times, making
    the test verbose.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重复**：一个长或复杂的测试最终会做出多个断言。然后我们不得不多次重复这个错误断言块，使得测试变得冗长。'
- en: '**Difficult to make advanced assertions**: We want to have the same fine-grained
    control over the verifications we undertake on our mocks throughout the rest of
    the test.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**难以做出高级断言**：我们希望在测试的其余部分对我们在模拟上进行的验证拥有相同的细粒度控制。'
- en: '`JUnit` is such an example.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JUnit` 是一个例子。'
- en: 'While the Go standard library does not provide functionality for assertions,
    two popular assertion frameworks provide this functionality:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Go 标准库没有提供断言功能，但两个流行的断言框架提供了这个功能：
- en: '`testify` is an open source assertion framework that provides an easy-to-use
    and powerful assertion package. The `assert` package provides this functionality.
    You can read about it at [https://github.com/stretchr/testify#assert-package](https://github.com/stretchr/testify#assert-package).'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testify` 是一个开源断言框架，它提供了一个易于使用且功能强大的断言包。`assert` 包提供了这个功能。你可以在 [https://github.com/stretchr/testify#assert-package](https://github.com/stretchr/testify#assert-package)
    上了解它。'
- en: '`ginkgo` is an open source assertion framework that provides **behavior-driven
    development** (**BDD**) style test [writing and assertions. You c](https://github.com/onsi/ginkgo)an
    read about it at [https://github.com/onsi/ginkgo](https://github.com/onsi/ginkgo).
    Adopting this style of testing allows developers to write tests that read like
    natural language.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ginkgo` 是一个开源断言框架，它提供了行为驱动开发（**BDD**）风格的测试[编写和断言]。你可以在 [https://github.com/onsi/ginkgo](https://github.com/onsi/ginkgo)
    上了解它。采用这种测试风格允许开发者编写读起来像自然语言的测试。'
- en: We will discuss BDD style tests in [*Chapter 5*](B18371_05.xhtml#_idTextAnchor124),
    *Performing Integration Testing*. Therefore, we will reserve the discussion of
    writing this type of test until then. We will continue our current exploration
    with the `testify` framework.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第5章*](B18371_05.xhtml#_idTextAnchor124)，*执行集成测试* 中讨论 BDD 风格的测试。因此，我们将把编写此类测试的讨论留到那时。我们将继续使用
    `testify` 框架进行当前的探索。
- en: Using testify
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 testify
- en: 'The `assert` package provides many useful functions for creating fine-grained
    assertions. Here are some of the ones that you will encounter often:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert` 包提供了许多用于创建细粒度断言的有用函数。以下是一些你经常会遇到的：'
- en: '`assert.Equal` function allows you to check whether two objects are equal.
    If the types checked are pointer-based, a value check on the reference values
    will be conducted. The opposite function, `assert.NotEqual`, also exists:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert.Equal` 函数允许你检查两个对象是否相等。如果检查的类型是基于指针的，将对引用值进行值检查。其相反函数，`assert.NotEqual`，也存在：'
- en: '[PRE19]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`assert.Equal` function should not be used for nil values. Instead, the `assert.Nil`
    method should be used. The opposite function, `assert.NotNil`, also exists:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert.Equal` 函数不应用于空值。相反，应该使用 `assert.Nil` 方法。其相反函数，`assert.NotNil`，也存在：'
- en: '[PRE21]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`assert.Contains` function verifies that a specified value is contained inside
    a string, list, or map. The opposite function, `assert.NotContains`, also exists:'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert.Contains` 函数验证指定值是否包含在字符串、列表或映射中。其相反函数，`assert.NotContains`，也存在：'
- en: '[PRE23]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`assert.Subset` function verifies that all the values in a specified subset
    are contained in a specified list. The opposite function, `assert.NotSubset`,
    also exists:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert.Subset` 函数验证指定子集中的所有值是否包含在指定的列表中。其相反函数，`assert.NotSubset`，也存在：'
- en: '[PRE25]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `testify/require` package also provides the same assertions, but will terminate
    the test in the case that an assertion fails. This package should be used in the
    case of fatal test errors.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`testify/require` 包也提供了相同的断言，但如果断言失败，将终止测试。在这种情况下，应使用此包。'
- en: 'For example, we can replace our previous `if` statement, which makes a call
    to `t.Fatal`, with the following single line of code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以用以下单行代码替换我们之前的 `if` 语句，该语句调用 `t.Fatal`：
- en: '[PRE27]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Augmenting the testing package
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展测试包
- en: You should use assertion frameworks to complement the simplicity of the `testing`
    package. As you begin to write more Go code, you should familiarize yourself with
    the assertion frameworks functionality and begin to use them in your tests.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用断言框架来补充 `testing` 包的简单性。当你开始编写更多的 Go 代码时，你应该熟悉断言框架的功能，并开始在测试中使用它们。
- en: Asserting errors
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断言错误
- en: One final aspect to cover when discussing assertions is how to verify errors.
    Sometimes, we want to verify not only that an error occurs, but that the correct
    error message is also returned. You should ensure that your tests verify such
    error messages when appropriate.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论断言时需要覆盖的最后一个方面是如何验证错误。有时，我们不仅想验证错误发生，还想验证返回了正确的错误消息。你应该确保在适当的时候，你的测试验证此类错误消息。
- en: The `assert.EqualError` function verifies that a returned error is not `nil`
    and that its message is equal to the provided string. This will make it easy to
    verify your error messages. As with all the functions we have seen so far, the
    `require` package also provides this function.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert.EqualError` 函数验证返回的错误不是 `nil`，并且其消息与提供的字符串相等。这将使验证错误消息变得容易。与迄今为止我们看到的所有函数一样，`require`
    包也提供了此功能。'
- en: 'Let us look at an example that verifies an error scenario:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个验证错误场景的例子：
- en: '[PRE28]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The test creates a variable called `expectedErrMsg`, which represents the error
    message that the mock will return. This message is then passed to the `assert.Contains`
    function, which will verify it against the error returned by the `ProcessExpression`
    method invoked on the UUT.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 测试创建了一个名为 `expectedErrMsg` 的变量，它代表模拟将返回的错误消息。然后，将此消息传递给 `assert.Contains` 函数，该函数将对其进行验证，以与在
    UUT 上调用的 `ProcessExpression` 方法返回的错误进行比较。
- en: Custom error types
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义错误类型
- en: You can also create your own custom error types instead of relying solely on
    Go’s built-in `error` type. This will provide you with type safety on error checking,
    instead of relying on error messages, which might change and make your tests brittle.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以创建自己的自定义错误类型，而不是仅仅依赖于 Go 的内置 `error` 类型。这将为你提供错误检查的类型安全性，而不是依赖于可能会改变并使你的测试变得脆弱的错误消息。
- en: Mocks and assertion frameworks are tools that we use to easily write tests.
    However, even the most skilled test writer will struggle to test code that is
    badly designed. The iterative nature of TDD together with good software design
    principles will result in testable, maintainable code.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟和断言框架是我们用来轻松编写测试的工具。然而，即使是最熟练的测试编写者也会发现测试设计糟糕的代码很困难。TDD 的迭代性质与良好的软件设计原则相结合，将导致可测试、可维护的代码。
- en: Writing testable code
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写可测试的代码
- en: The final aspect we will cover in this chapter is how to write testable code
    using the **SOLID** software design principles. As we have seen multiple times
    already, well-designed code is also easy-to-test code. Application code that is
    difficult to test is often a sign that the application will be hard to change
    and maintain.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论的最后一个方面是如何使用 **SOLID** 软件设计原则来编写可测试的代码。正如我们已经多次看到的，设计良好的代码也是易于测试的代码。难以测试的应用程序代码通常是应用程序难以更改和维护的迹象。
- en: These five powerful principles were introduced in a paper by Robert C. Martin
    in 2000, then later published in his book *Agile Software Development, Principles,
    Patterns, and Practices*. These principles help Agile teams deliver maintainable,
    easy-to-refactor code.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这五个强大的原则是在 Robert C. Martin 2000 年发表的一篇论文中提出的，后来发表在他的书 *敏捷软件开发：原则、模式和实践* 中。这些原则帮助敏捷团队交付可维护、易于重构的代码。
- en: '*Figure 3**.5* summarizes the SOLID design principles:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3*.5 总结了 SOLID 设计原则：'
- en: '![Figure 3.5 – The SOLID design principles ](img/Figure_3.5_B18371.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – SOLID 设计原则](img/Figure_3.5_B18371.jpg)'
- en: Figure 3.5 – The SOLID design principles
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – SOLID 设计原则
- en: 'Let us recap the SOLID principles and what they mean for test writing:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下 SOLID 原则及其对测试写作的意义：
- en: '**Single Responsibility Principle** (**SRP**): For this, entities should have
    a single job and a single reason to change. This principle will keep testing code
    simple since the scope of the functionality provided by the class is small. We
    can then focus our efforts on covering edge cases, as opposed to covering a large
    number of methods.'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**单一职责原则**（**SRP**）：为此，实体应该只有一个职责和一个变更的理由。这个原则将使测试代码保持简单，因为类提供的功能范围较小。然后我们可以集中精力覆盖边缘情况，而不是覆盖大量方法。'
- en: '**Open-Closed Principle** (**OCP**): For this, entities should be open for
    extension, but closed for modification. This principle translates to ensuring
    that code changes extend but don’t break existing behavior. Code that is backward-compatible
    by design will not require numerous test changes. Instead, the new/extended functionality
    can be covered by new test cases, ensuring that the test suite continues to be
    stable.'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**开放封闭原则**（**OCP**）：为此，实体应该对扩展开放，但对修改封闭。这个原则意味着确保代码更改扩展但不破坏现有行为。设计上向后兼容的代码将不需要进行大量的测试更改。相反，新的/扩展的功能可以通过新的测试用例来覆盖，从而确保测试套件保持稳定。'
- en: '**Liskov Substitution Principle** (**LSP**): For this, every subclass or derived
    class should satisfy the behavior of its parent or base class. Since Go does not
    have inheritance, you might be tempted to conclude that it does not apply. However,
    we achieve polymorphism using interfaces, so we can express this principle in
    terms of the contracts they set. Code that maintains substitutable interfaces
    will be easy to test, as it will again not require many test changes to the existing
    suite.'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**里氏替换原则**（**LSP**）：为此，每个子类或派生类都应该满足其父类或基类的行为。由于 Go 没有继承，你可能会倾向于得出结论，它不适用。然而，我们使用接口来实现多态，因此我们可以用它们设置的合约来表述这个原则。维护可替换接口的代码将很容易测试，因为它将再次不需要对现有套件进行许多测试更改。'
- en: '**Interface Segregation Principle** (**ISP**): For this, client code should
    not be forced to implement methods or interfaces that it does not use. This principle
    encourages the usage of small interfaces, which only wrap around a single responsibility.
    Interfaces should be defined on the side of the client/calling code, which should
    only define interface methods for the functionality they are interested in using.
    Small interfaces lead to small mocks, which, in turn, lead to simple test setups
    and assertions.'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**接口隔离原则**（**ISP**）：为此，客户端代码不应被迫实现它不使用的方法或接口。这个原则鼓励使用小型接口，这些接口只围绕单一职责进行包装。接口应该在客户端/调用代码的一侧定义，它应该只为它感兴趣使用的功能定义接口方法。小型接口导致小型模拟，进而导致简单的测试设置和断言。'
- en: '**Dependency Inversion Principle** (**DIP**): For this, entities should depend
    on abstractions, not concretions. This principle encourages using interfaces to
    represent dependencies. We discussed this principle in the *Dependency injection*
    section of this chapter. We saw that using this technique in combination with
    the power of interfaces will produce loosely coupled code that is easier to test,
    due to fewer out-of-package dependencies that need to be set up.'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**依赖倒置原则**（**DIP**）：为此，实体应该依赖于抽象，而不是具体实现。这个原则鼓励使用接口来表示依赖。我们在本章的 *依赖注入* 部分讨论了这一原则。我们看到了使用这种技术与接口的力量相结合将产生松散耦合的代码，这使得测试更容易，因为需要设置的包外依赖更少。'
- en: As we have seen, interfaces are central to the implementation of SOLID principles
    in Go. They should be used to write code that is easy to maintain and refactor.
    Since refactoring is a central part of the TDD practice, easy-to-refactor code
    will also be easy to test code.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，接口是实现 Go 中 SOLID 原则的关键。它们应该被用来编写易于维护和重构的代码。由于重构是 TDD 实践的核心部分，易于重构的代码也将是易于测试的代码。
- en: The SOLID entity
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID 实体
- en: Remember that in Go the entity should be the package, not the struct. Packages
    provide their own APIs, which establish their own contracts and interfaces. Keep
    the SOLID principles in mind when designing your package APIs.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在 Go 中，实体应该是包，而不是结构体。包提供它们自己的 API，这些 API 建立了自己的契约和接口。在设计你的包 API 时，请牢记 SOLID
    原则。
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we expanded on unit testing essentials by learning how to handle
    code dependencies. We began by introducing DI and exploring different approaches
    to how this is done in Go. You learned how to use mocks to have fine-grained control
    over the preconditions that your test runs in, as well as how to generate them
    using the `testify/mock` framework. Then, we explored different assertion frameworks
    and how to use them to streamline our tests. Finally, we discussed the SOLID principles,
    which will help us to write testable code.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过学习如何处理代码依赖来扩展了单元测试的基础知识。我们首先介绍了依赖注入并探讨了在 Go 中如何实现的不同方法。你学习了如何使用模拟来对测试运行的前置条件进行精细控制，以及如何使用
    `testify/mock` 框架生成它们。然后，我们探讨了不同的断言框架以及如何使用它们来简化我们的测试。最后，我们讨论了 SOLID 原则，这将帮助我们编写可测试的代码。
- en: In [*Chapter 4*](B18371_04.xhtml#_idTextAnchor085), *Building Efficient Test
    Suites*, we will begin to look at our tests as a collection, ensuring they complement
    each other and cover edge cases. We will also explore the popular Go technique
    of **table-driven testing**.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 4 章*](B18371_04.xhtml#_idTextAnchor085) *构建高效的测试套件* 中，我们将开始将我们的测试视为一个集合，确保它们相互补充并覆盖边缘情况。我们还将探索流行的
    Go 技术 **表格驱动测试**。
- en: Questions
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章知识点的掌握：
- en: 'Continue the existing implementation of the simple calculator by implementing
    and testing the remaining operations:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过实现和测试剩余的操作来继续现有的简单计算器的实现：
- en: Subtraction
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减法
- en: Multiplication
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘法
- en: Division
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除法
- en: Ensure that you use all the techniques we have used so far to produce well-tested
    code.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你使用我们迄今为止所使用过的所有技术来生成经过良好测试的代码。
- en: Further reading
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章所涉及主题的信息，请查看以下资源：
- en: '*Clean Architecture: A Craftsman’s Guide to Software Structure and Design:
    A Craftsman’s Guide to Software Structure and Design*, Robert C. Martin, published
    by Addison-Wesley'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*整洁架构：软件结构与设计的工匠指南*》，罗伯特·C·马丁，由 Addison-Wesley 出版
- en: '*Design patterns: elements of reusable object-oriented software*, Erich Gamma
    et al., published by Addison Wesley'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*设计模式：可重用面向对象软件的元素*》，埃里希·伽玛等，由 Addison Wesley 出版
- en: '*Compile-time Dependency Injection With Go Cloud’s Wire*, *The Go blog*, available
    at [https://go.dev/blog/wire](https://go.dev/blog/wire)'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*使用 Go Cloud 的 Wire 进行编译时依赖注入*》，*Go 博客*，可在 [https://go.dev/blog/wire](https://go.dev/blog/wire)
    获取
