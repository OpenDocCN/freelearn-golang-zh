<html><head></head><body>
<div id="_idContainer042">
<h1 class="chapter-number" id="_idParaDest-79"><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-80"><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.2.1">Building Efficient Test Suites</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we learned how to supplement the functionality of Go’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.4.1">testing</span></strong><span class="koboSpan" id="kobo.5.1"> package with third-party libraries. </span><span class="koboSpan" id="kobo.5.2">These libraries make it easier to mock the dependencies of the </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">Unit Under Test</span></strong><span class="koboSpan" id="kobo.7.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.8.1">UUT</span></strong><span class="koboSpan" id="kobo.9.1">) and create assertions in these tests. </span><span class="koboSpan" id="kobo.9.2">Mocks are essential building blocks to being able to easily write test code for well-designed implementation code, according to the </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">SOLID</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.11.1">design principles.</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">In practice, developers identify edge cases of their requirements and implementations, ensuring a good </span><strong class="bold"><span class="koboSpan" id="kobo.13.1">code coverage</span></strong><span class="koboSpan" id="kobo.14.1"> percentage, which we discussed in </span><a href="B18371_02.xhtml#_idTextAnchor035"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.15.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.16.1">, </span><em class="italic"><span class="koboSpan" id="kobo.17.1">Unit Testing Essentials</span></em><span class="koboSpan" id="kobo.18.1">. </span><span class="koboSpan" id="kobo.18.2">In this chapter, we will learn how to create </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">test suites.</span></span></p>
<p><span class="koboSpan" id="kobo.20.1">One popular technique for constructing test suites in Go is </span><strong class="bold"><span class="koboSpan" id="kobo.21.1">table-driven testing</span></strong><span class="koboSpan" id="kobo.22.1">. </span><span class="koboSpan" id="kobo.22.2">We will learn how to build tables that cover edge cases and exercise the UUT with a variety of inputs, ensuring that the UUT has a stable implementation. </span><span class="koboSpan" id="kobo.22.3">We will also leverage some of the techniques we’ve explored so far, such as test setup, subtests, </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">and mocks.</span></span></p>
<p><span class="koboSpan" id="kobo.24.1">One of the most popular usages of Go is to build web applications, and in this chapter, we will explore how to build and test just that. </span><span class="koboSpan" id="kobo.24.2">We will move on from the simple calculator example that we have looked at so far and look at a new use case: the </span><strong class="source-inline"><span class="koboSpan" id="kobo.25.1">BookSwap</span></strong><span class="koboSpan" id="kobo.26.1"> application. </span><span class="koboSpan" id="kobo.26.2">This service will allow users to create book listings they wish to swap, allowing others to </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">borrow them.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">This example will involve building a REST API with Go’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.29.1">net/http</span></strong><span class="koboSpan" id="kobo.30.1"> package and learning how to test it. </span><span class="koboSpan" id="kobo.30.2">It is particularly important to cover edge cases when dealing with user input, so we will test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.31.1">BookSwap</span></strong><span class="koboSpan" id="kobo.32.1"> API using the techniques covered </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">so far.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">In this chapter, we will cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.36.1">What edge cases are and how to </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">identify them</span></span></li>
<li><span class="koboSpan" id="kobo.38.1">How to test web applications and APIs, which may rely on </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">external services</span></span></li>
<li><span class="koboSpan" id="kobo.40.1">The popular Go testing technique of </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">table-driven testing</span></span></li>
<li><span class="koboSpan" id="kobo.42.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.43.1">BookSwap</span></strong><span class="koboSpan" id="kobo.44.1"> use </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">case application</span></span></li>
</ul>
<h1 id="_idParaDest-81"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.46.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.47.1">You will need to have </span><strong class="bold"><span class="koboSpan" id="kobo.48.1">Go version 1.19</span></strong><span class="koboSpan" id="kobo.49.1"> or later installed to run the code samples in this chapter. </span><span class="koboSpan" id="kobo.49.2">The installation process is described in the official Go documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">at </span></span><a href="https://go.dev/doc/install"><span class="No-Break"><span class="koboSpan" id="kobo.51.1">https://go.dev/doc/install</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.52.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.53.1">The code examples included in this book are publicly available </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">at </span></span><a href="https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter04"><span class="No-Break"><span class="koboSpan" id="kobo.55.1">https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter04</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.56.1">.</span></span></p>
<h1 id="_idParaDest-82"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.57.1">Testing multiple conditions</span></h1>
<p><span class="koboSpan" id="kobo.58.1">So far, we have covered how to structure and write tests. </span><span class="koboSpan" id="kobo.58.2">However, developers need to </span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.59.1">know </span><em class="italic"><span class="koboSpan" id="kobo.60.1">what</span></em><span class="koboSpan" id="kobo.61.1"> aspects of their code to test, as well as </span><em class="italic"><span class="koboSpan" id="kobo.62.1">how</span></em><span class="koboSpan" id="kobo.63.1"> to test them. </span><span class="koboSpan" id="kobo.63.2">Remember that the lower we go on the </span><strong class="bold"><span class="koboSpan" id="kobo.64.1">testing pyramid</span></strong><span class="koboSpan" id="kobo.65.1">, the cheaper and </span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.66.1">faster the tests are to run. </span><span class="koboSpan" id="kobo.66.2">Therefore, it is important for developers to know how to exercise their code as low in their stack as possible. </span><span class="koboSpan" id="kobo.66.3">In this chapter, we’ll </span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.67.1">focus on covering edge cases as part of our developer </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.68.1">testing strategy</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">As discussed in </span><a href="B18371_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.71.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.72.1">, </span><em class="italic"><span class="koboSpan" id="kobo.73.1">Getting to Grips with Test-Driven Development</span></em><span class="koboSpan" id="kobo.74.1">, automated tests should be based on the system requirements we implement. </span><span class="koboSpan" id="kobo.74.2">In general, system requirements will focus on the specification of the success scenarios and system functionality additions. </span><span class="koboSpan" id="kobo.74.3">Designing your testing strategy around these requirements serves the primary purpose of ensuring that your system satisfies its </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">functional requirements.</span></span></p>
<p><span class="koboSpan" id="kobo.76.1">A secondary purpose of </span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.77.1">your testing strategy should be to verify the behavior and robustness of your system-under-failure cases, such as incorrect/unexpected input, transient errors, or slow responses. </span><span class="koboSpan" id="kobo.77.2">Developers need to ensure that their systems are able to gracefully handle all sorts of </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">operating conditions.</span></span></p>
<p><span class="koboSpan" id="kobo.79.1">We will learn how to identify these conditions and apply the testing techniques we’ve learned so far to devise testing strategies that give us confidence in our solutions, regardless of the inputs and the conditions our system </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">operates in.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.81.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.82.1">.1</span></em><span class="koboSpan" id="kobo.83.1"> shows the dual nature of testing, comprising positive and negative tests, to ensure that both functionality and error handling is correctly implemented in </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">our systems:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer034">
<span class="koboSpan" id="kobo.85.1"><img alt="Figure 4.1 – The two types of tests " src="image/Figure_4.01_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.86.1">Figure 4.1 – The two types of tests</span></p>
<p><span class="koboSpan" id="kobo.87.1">The two types </span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.88.1">of tests are </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.90.1">Positive tests</span></strong><span class="koboSpan" id="kobo.91.1">, which use valid input for the UUT and verify that the expected result is returned </span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.92.1">from the UUT. </span><span class="koboSpan" id="kobo.92.2">This type of test ensures that the </span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.93.1">application behaves correctly according to the functional requirements. </span><span class="koboSpan" id="kobo.93.2">Positive tests cover </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">the following:</span></span><ul><li><span class="koboSpan" id="kobo.95.1">How the </span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.96.1">UUT handles </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">valid input</span></span></li><li><span class="koboSpan" id="kobo.98.1">How the UUT behaves in </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">expected scenarios</span></span></li><li><span class="koboSpan" id="kobo.100.1">How the UUT satisfies </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">system requirements</span></span></li></ul></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.102.1">Negative tests</span></strong><span class="koboSpan" id="kobo.103.1">, which use invalid input for the UUT and verify that an error is returned from </span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.104.1">the UUT. </span><span class="koboSpan" id="kobo.104.2">This type of test ensures that the application </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.105.1">can gracefully handle invalid input, with meaningful errors and avoiding crashes. </span><span class="koboSpan" id="kobo.105.2">Negative tests cover </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">the following:</span></span><ul><li><span class="koboSpan" id="kobo.107.1">How the UUT handles </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">invalid input</span></span></li><li><span class="koboSpan" id="kobo.109.1">How the UUT behaves in </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">unexpected scenarios</span></span></li><li><span class="koboSpan" id="kobo.111.1">How the UUT behaves outside of </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">system requirements</span></span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.113.1">Each of these tests is comprised of different types of test scenarios of varying complexity, based on the values of input variables and </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">their combinations.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.115.1">The importance of negative tests</span></p>
<p class="callout"><span class="koboSpan" id="kobo.116.1">Both positive and </span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.117.1">negative tests are equally important for production </span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.118.1">systems. </span><span class="koboSpan" id="kobo.118.2">Error handling is an important part of the user journey. </span><span class="koboSpan" id="kobo.118.3">We want users to receive meaningful messages in the case of errors, as well as recover successfully in the case of slowdowns </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">or outages.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.120.1">Happy path testing</span></strong><span class="koboSpan" id="kobo.121.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.122.1">happy flow testing</span></strong><span class="koboSpan" id="kobo.123.1"> is the verification of the default success scenario without any </span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.124.1">errors or exceptions. </span><span class="koboSpan" id="kobo.124.2">Covering the default and </span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.125.1">requirement-specific scenarios ensures that the system behaves well in ideal scenarios. </span><span class="koboSpan" id="kobo.125.2">However, as developers, we need to know more than the ideal behavior of </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">our systems.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.127.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.128.1">.2</span></em><span class="koboSpan" id="kobo.129.1"> depicts the different types of test cases for a given input parameter of our system. </span><span class="koboSpan" id="kobo.129.2">The different types of test cases cover the entire range of possible input </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">parameter values:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer035">
<span class="koboSpan" id="kobo.131.1"><img alt="Figure 4.2 – The types of test cases of a given input variable " src="image/Figure_4.02_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.132.1">Figure 4.2 – The types of test cases of a given input variable</span></p>
<p><span class="koboSpan" id="kobo.133.1">A good testing strategy should cover the following four major types of test cases of a given </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">input variable:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.135.1">Base cases</span></strong><span class="koboSpan" id="kobo.136.1"> occur at the </span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.137.1">expected values of an operating parameter. </span><span class="koboSpan" id="kobo.137.2">For example, given an input parameter representing a name, a base case for it would be a short valid string value. </span><span class="koboSpan" id="kobo.137.3">These cases are often defined in the system requirements and make up the scenarios of the happy path </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">testing strategy.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.139.1">Edge cases</span></strong><span class="koboSpan" id="kobo.140.1"> occur at the extreme of an operating parameter. </span><span class="koboSpan" id="kobo.140.2">For example, given a </span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.141.1">string input parameter, some edge cases for it would be an empty string value, a multiline string, or a string with </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">special characters.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.143.1">Boundary cases</span></strong><span class="koboSpan" id="kobo.144.1"> occur on either side of an edge case, approaching the extreme </span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.145.1">values of an operating parameter. </span><span class="koboSpan" id="kobo.145.2">These cases are particularly important for asserting values that must have a particular value. </span><span class="koboSpan" id="kobo.145.3">For example, given a numeric input parameter representing temperature for a water temperature measurement application, we could boundary-test its values around the water freezing point and water </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">boiling point.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.147.1">As demonstrated by these examples, edge cases are often based on the data type of the input/user </span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.148.1">parameter, as well as their purpose. </span><span class="koboSpan" id="kobo.148.2">We will explore other types of parameters and how to identify their extreme/edge-case values in the </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">next section.</span></span></p>
<p><span class="koboSpan" id="kobo.150.1">Systems will often operate on multiple input variables. </span><span class="koboSpan" id="kobo.150.2">The combinations of input variables and their edge cases can result in different </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">system behavior.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.152.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.153.1">.3</span></em><span class="koboSpan" id="kobo.154.1"> demonstrates the final type of test case, which tests the particular scenario of multiple edge cases of </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">input variables:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer036">
<span class="koboSpan" id="kobo.156.1"><img alt="Figure 4.3 – Corner cases " src="image/Figure_4.03_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.157.1">Figure 4.3 – Corner cases</span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.158.1">Corner cases</span></strong><span class="koboSpan" id="kobo.159.1"> occur at </span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.160.1">extremes or edge cases of multiple operating parameters. </span><span class="koboSpan" id="kobo.160.2">Any combination of edge cases between the two types of input variables would result in a corner case. </span><span class="koboSpan" id="kobo.160.3">For example, given multiple string input parameters, we would achieve a corner case by a combination of any of the edge cases of </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">these parameters.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.162.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.163.1">.4</span></em><span class="koboSpan" id="kobo.164.1"> demonstrates the test case combinations of two </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">input variables:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer037">
<span class="koboSpan" id="kobo.166.1"><img alt="Figure 4.4 – Combining two input variables in a testing strategy " src="image/Figure_4.04_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.167.1">Figure 4.4 – Combining two input variables in a testing strategy</span></p>
<p><span class="koboSpan" id="kobo.168.1">As the number of input parameters of our system increases, the number of combinations of edge cases increases, resulting in a large number of corner cases that must be tested. </span><span class="koboSpan" id="kobo.168.2">In </span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.169.1">order to minimize test writing and maintenance efforts, it’s important to identify the subset of user-accessible scenarios from the entirety of possible test scenarios. </span><span class="koboSpan" id="kobo.169.2">These should be prioritized in the testing strategy, and testing can then be extended as the project becomes </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">more mature.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.171.1">The difference between edge and corner cases</span></p>
<p class="callout"><span class="koboSpan" id="kobo.172.1">The terms </span><em class="italic"><span class="koboSpan" id="kobo.173.1">edge case</span></em><span class="koboSpan" id="kobo.174.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.175.1">corner case</span></em><span class="koboSpan" id="kobo.176.1"> are often used interchangeably. </span><span class="koboSpan" id="kobo.176.2">One easy way to remember the </span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.177.1">difference is that an edge case pushes the </span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.178.1">extremes of a parameter, while a corner case combines these extremes by pushing the user to a </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">corner configuration.</span></span></p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.180.1">Identifying edge cases</span></h2>
<p><span class="koboSpan" id="kobo.181.1">There is no particular </span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.182.1">well-defined procedure for identifying edge cases for variables and algorithms. </span><span class="koboSpan" id="kobo.182.2">This is where the experience of software testers and engineers makes a big difference, as they can intuitively identify edge cases of code and requirements upon inspection. </span><span class="koboSpan" id="kobo.182.3">We can, however, make some recommendations of what to watch </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">out for.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.184.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.185.1">.5</span></em><span class="koboSpan" id="kobo.186.1"> demonstrates special cases based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">variable type:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer038">
<span class="koboSpan" id="kobo.188.1"><img alt="Figure 4.5 – Special cases of different variable types " src="image/Figure_4.05_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.189.1">Figure 4.5 – Special cases of different variable types</span></p>
<p><span class="koboSpan" id="kobo.190.1">The special cases of variable types are </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.192.1">String-type variables have the following </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">special cases:</span></span><ul><li><span class="koboSpan" id="kobo.194.1">An empty </span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.195.1">or zero </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">character string—</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">""</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">.</span></span></li><li><span class="koboSpan" id="kobo.199.1">A long string, which exceeds the expected length of the base-case valid string—</span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">"a very very very very </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">long string"</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">.</span></span></li><li><span class="koboSpan" id="kobo.203.1">A string containing special characters, including Unicode characters and special accent characters—</span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">"a $</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">p€¢iał string!"</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">.</span></span></li><li><span class="koboSpan" id="kobo.207.1">A multiline string containing new line delimiters—</span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">"a multi \n line string"</span></strong><span class="koboSpan" id="kobo.209.1">. </span><span class="koboSpan" id="kobo.209.2">Remember that Go allows the definition of raw string literals by the use of backticks, which can also contain other </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">special characters.</span></span></li></ul></li>
<li><span class="koboSpan" id="kobo.211.1">Numeric-type variables </span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.212.1">have the following </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">special cases:</span></span><ul><li><span class="koboSpan" id="kobo.214.1">A </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">zero value—</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">.</span></span></li><li><span class="koboSpan" id="kobo.218.1">The minimum and maximum values are according to the numeric type. </span><span class="koboSpan" id="kobo.218.2">For example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">int8</span></strong><span class="koboSpan" id="kobo.220.1"> type has a minimum value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">–128</span></strong><span class="koboSpan" id="kobo.222.1"> and a maximum value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">127</span></strong><span class="koboSpan" id="kobo.224.1">, while the </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">uint8</span></strong><span class="koboSpan" id="kobo.226.1"> type has a minimum value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">0</span></strong><span class="koboSpan" id="kobo.228.1"> and a maximum value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">255</span></strong><span class="koboSpan" id="kobo.230.1">. </span><span class="koboSpan" id="kobo.230.2">These values increase according to the memory allocation of the </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">given type.</span></span></li><li><span class="koboSpan" id="kobo.232.1">Positive and negative numeric values may also require special handling, according to the logic of </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">the UUT.</span></span></li></ul></li>
<li><span class="koboSpan" id="kobo.234.1">Custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">struct</span></strong><span class="koboSpan" id="kobo.236.1"> types have </span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.237.1">the following </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">special cases:</span></span><ul><li><span class="koboSpan" id="kobo.239.1">The zero value of the custom struct, with no initialization—</span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">a := </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">MyType{}</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">.</span></span></li><li><span class="koboSpan" id="kobo.243.1">The nil value of the type, if passed by a pointer—</span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">var </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">a *MyType</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">.</span></span></li><li><span class="koboSpan" id="kobo.247.1">Combinations of initialized and uninitialized fields of the given type—</span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">a := MyType{ field1: "Value"}</span></strong><span class="koboSpan" id="kobo.249.1">. </span><span class="koboSpan" id="kobo.249.2">Testing these combinations can reveal whether any fields should be added to initialization/constructor functions. </span><span class="koboSpan" id="kobo.249.3">While </span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.250.1">Go does not provide default implementations of constructors, it is common to declare package - scoped functions that initialize an instance and return it—</span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">func NewMyType(v </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">string) *MyType</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">.</span></span></li></ul></li>
<li><span class="koboSpan" id="kobo.254.1">Collection types </span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.255.1">wrap around Go’s in-built collection types—arrays, slices, </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">and maps:</span></span><ul><li><span class="koboSpan" id="kobo.257.1">Zero-element or empty collection—</span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">c := []</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">int{}</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">.</span></span></li><li><span class="koboSpan" id="kobo.261.1">One-element or single-element collection—</span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">c := []</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">int{0}</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">.</span></span></li><li><span class="koboSpan" id="kobo.265.1">Nil value or collection with no allocated memory—</span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">var </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">c []int</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">.</span></span></li><li><span class="koboSpan" id="kobo.269.1">Duplicate elements—</span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">c := []</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">int{0, 0}</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">.</span></span></li><li><span class="koboSpan" id="kobo.273.1">Collection with a large number of elements—</span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">var </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">c [999]int</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">.</span></span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.277.1">The special cases of each variable type should inform your decision as to which edge cases you should </span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.278.1">attempt to cover, but you should extend your edge cases to cover the boundaries of any system requirements and </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">edge cases.</span></span></p>
<p><span class="koboSpan" id="kobo.280.1">When formulating your test cases, you should break down the UUT into small logical blocks, identify their inputs and their edge cases, then construct your test suites to verify these cases accordingly. </span><span class="koboSpan" id="kobo.280.2">We will learn how to easily write test suites using table-driven testing later on in </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">this chapter.</span></span></p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.282.1">External services</span></h2>
<p><span class="koboSpan" id="kobo.283.1">Now that we understand how to identify the edge cases of input </span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.284.1">parameters based on their type and system requirements, we can now turn our attention to testing with external services. </span><span class="koboSpan" id="kobo.284.2">As discussed in </span><a href="B18371_03.xhtml#_idTextAnchor061"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.285.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.286.1">, </span><em class="italic"><span class="koboSpan" id="kobo.287.1">Mocking and Assertion Frameworks</span></em><span class="koboSpan" id="kobo.288.1">, any direct dependencies of the UUT should be mocked, allowing us to test the UUT </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">in isolation.</span></span></p>
<p><span class="koboSpan" id="kobo.290.1">As the Go package provides us with an easy way to build small, self-contained APIs, we can treat all dependencies as external services. </span><span class="koboSpan" id="kobo.290.2">These dependencies can be divided into </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">two categories:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.292.1">Internal system dependencies</span></strong><span class="koboSpan" id="kobo.293.1"> are located inside the system we are testing, whether </span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.294.1">inside the same service or not. </span><span class="koboSpan" id="kobo.294.2">We have full control of </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">these dependencies.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.296.1">External system dependencies</span></strong><span class="koboSpan" id="kobo.297.1"> are located outside the system we are testing, providing </span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.298.1">extra functionality such as a database or third-party functionality. </span><span class="koboSpan" id="kobo.298.2">We do not have full control of </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">these dependencies.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.300.1">Always mock external system dependencies</span></p>
<p class="callout"><span class="koboSpan" id="kobo.301.1">As we do not control system dependencies, testing against their live/real versions could introduce brittleness and extra costs to our test suites. </span><span class="koboSpan" id="kobo.301.2">With the exception of databases, you should always mock your external system dependencies. </span><span class="koboSpan" id="kobo.301.3">We will explore database testing further in </span><a href="B18371_05.xhtml#_idTextAnchor124"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.302.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.303.1">, </span><em class="italic"><span class="koboSpan" id="kobo.304.1">Performing </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.305.1">Integration Testing</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.307.1">When it comes to edge cases of external system dependencies, these APIs will most often connect with </span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.308.1">our system using some kind of network connection. </span><span class="koboSpan" id="kobo.308.2">Their edge cases are heavily influenced by </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">this connection.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.310.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.311.1">.6</span></em><span class="koboSpan" id="kobo.312.1"> depicts the possible errors that can happen in the integration between the UUT and the </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">external service:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer039">
<span class="koboSpan" id="kobo.314.1"><img alt="Figure 4.6 – Possible errors in communication between the UUT and external service " src="image/Figure_4.06_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.315.1">Figure 4.6 – Possible errors in communication between the UUT and external service</span></p>
<p><span class="koboSpan" id="kobo.316.1">When each part of the exchange is happening over a network, both the request and response need to be tolerant of delays </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">and retries:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.318.1">The external service may error out and respond with an internal service error. </span><span class="koboSpan" id="kobo.318.2">In this case, the UUT will need to handle a full outage and serve a </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">default response.</span></span></li>
<li><span class="koboSpan" id="kobo.320.1">The request may take a long time to be delivered to the external service. </span><span class="koboSpan" id="kobo.320.2">In this case, the UUT will need to wait for the response for a pre-defined amount of time and then consider the request failed. </span><span class="koboSpan" id="kobo.320.3">The UUT may then decide to retry this request to fetch </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">any resources.</span></span></li>
<li><span class="koboSpan" id="kobo.322.1">The response from the external service may not arrive at all. </span><span class="koboSpan" id="kobo.322.2">In this case, the UUT will need to retry the whole request cycle and handle this duplicate flow in the </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">application logic.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.324.1">Errors are an inevitable </span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.325.1">part of writing code and running applications, especially those relying on external services for </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">their functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.327.1">Modern systems will rely on many types of external APIs, which can communicate over REST APIs, RPC calls, or even asynchronously through event buses. </span><span class="koboSpan" id="kobo.327.2">The testing concerns of these integrations are similar, as the communication between the UUT and the external service will be the most error-prone part of </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">the integration.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.329.1">Idempotence as design</span></p>
<p class="callout"><span class="koboSpan" id="kobo.330.1">In API design, idempotent operations can be called repeatedly without changing the initial result. </span><span class="koboSpan" id="kobo.330.2">It is considered good practice to design all operations as idempotent to ensure that operations can be retried in the case of </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">error recovery.</span></span></p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.332.1">Error-handling refresher</span></h2>
<p><span class="koboSpan" id="kobo.333.1">Up until now, we’ve </span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.334.1">discussed how to identify possible edge cases and write tests for them, but resilience and error handling begins with the implementation of the UUT. </span><span class="koboSpan" id="kobo.334.2">This is especially true for Go developers, where the language design requires the explicit handling of error cases. </span><span class="koboSpan" id="kobo.334.3">Let us supplement our discussion of edge case identification and error case testing with a brief summary of error handling </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">in Go.</span></span></p>
<p><span class="koboSpan" id="kobo.336.1">Error handling plays a vital role in writing Go code. </span><span class="koboSpan" id="kobo.336.2">The Go team has opted for explicit error handling with the built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">error</span></strong><span class="koboSpan" id="kobo.338.1"> type, in order to avoid exceptions and </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">try-catch-finally</span></strong><span class="koboSpan" id="kobo.340.1"> style blocks, which can cause brittle and </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">error-prone code.</span></span></p>
<p><span class="koboSpan" id="kobo.342.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">error</span></strong><span class="koboSpan" id="kobo.344.1"> type is a </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">simple interface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.346.1">
type error interface {
</span><strong class="bold"><span class="koboSpan" id="kobo.347.1">  Error() string</span></strong><span class="koboSpan" id="kobo.348.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.349.1">This interface also makes it easy for us to create our own custom error types, which just need to </span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.350.1">implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">Error() string</span></strong><span class="koboSpan" id="kobo.352.1"> method. </span><span class="koboSpan" id="kobo.352.2">Errors are returned </span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.353.1">just as any other value, most commonly using </span><strong class="bold"><span class="koboSpan" id="kobo.354.1">multiple return values</span></strong><span class="koboSpan" id="kobo.355.1">, and they are handled just like any other </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">return value.</span></span></p>
<p><span class="koboSpan" id="kobo.357.1">For example, we’ve already seen the </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">Parser</span></strong><span class="koboSpan" id="kobo.359.1"> calculator return an error, in the case of an invalid </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">mathematical expression:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.361.1">
func (p *Parser) ProcessExpression(expr string) error</span></pre>
<p><span class="koboSpan" id="kobo.362.1">The zero value of the error type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">nil</span></strong><span class="koboSpan" id="kobo.364.1">. </span><span class="koboSpan" id="kobo.364.2">Most commonly, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">nil</span></strong><span class="koboSpan" id="kobo.366.1"> error value will signal that no issues have occurred </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">during execution.</span></span></p>
<p><span class="koboSpan" id="kobo.368.1">It is common practice to handle errors first in the code by calling the possibly </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">failing expression:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.370.1">
if err := parser.ProcessExpression(*expr); </span><strong class="bold"><span class="koboSpan" id="kobo.371.1">err != nil </span></strong><span class="koboSpan" id="kobo.372.1">{
  log.Fatal(err)
}</span></pre>
<p><span class="koboSpan" id="kobo.373.1">In this example, we initialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">err</span></strong><span class="koboSpan" id="kobo.375.1"> variable at the same time as the call to the erroring function, limiting the scope of the variable to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">if</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.377.1">statement block.</span></span></p>
<p><span class="koboSpan" id="kobo.378.1">Note that we check for the presence of an error, not its absence. </span><span class="koboSpan" id="kobo.378.2">In the case of </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">err != nil</span></strong><span class="koboSpan" id="kobo.380.1">, we simply kill the application with a call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">log.Fatal</span></strong><span class="koboSpan" id="kobo.382.1"> function. </span><span class="koboSpan" id="kobo.382.2">This is the typical way we handle errors </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">in Go.</span></span></p>
<p><span class="koboSpan" id="kobo.384.1">Handling errors explicitly with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">error</span></strong><span class="koboSpan" id="kobo.386.1"> type has the </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">following advantages:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.388.1">Guarantees that error cases are handled, avoiding any later panics or nil pointers</span></strong><span class="koboSpan" id="kobo.389.1">: Handling errors </span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.390.1">first, at the top of the function code, reduces checks for valid data later on in the function code. </span><span class="koboSpan" id="kobo.390.2">This can help simplify code </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">execution flow.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.392.1">Makes it easy to see which error scenarios we need to cover in our testing strategy</span></strong><span class="koboSpan" id="kobo.393.1">: The function signature will show which methods and functions can produce errors, forcing calling code to handle </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">them explicitly.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.395.1">Gives us a unified way of representing error states and returning error messages</span></strong><span class="koboSpan" id="kobo.396.1">: The built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">error</span></strong><span class="koboSpan" id="kobo.398.1"> type gives all Go codebases a unified way of representing error states, which makes it easy to construct and return </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">user-facing errors.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.400.1">However, some developers find the error-checking code blocks repetitive and verbose. </span><span class="koboSpan" id="kobo.400.2">A common criticism is that they need to handle all errors, even those that are relatively unlikely to happen. </span><span class="koboSpan" id="kobo.400.3">Error return values may be disregarded by using the </span><strong class="bold"><span class="koboSpan" id="kobo.401.1">blank identifier</span></strong><span class="koboSpan" id="kobo.402.1"> (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">_</span></strong><span class="koboSpan" id="kobo.404.1"> operator) or not </span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.405.1">assigning the return value to any variable, but this is </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">commonly discouraged.</span></span></p>
<p><span class="koboSpan" id="kobo.407.1">You can make your own opinions on Go’s explicit error handling, but we will use it throughout this book as it is a convention and standard practice for how we </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">write Go.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.409.1">Handling errors first but returning them as the last parameter</span></p>
<p class="callout"><span class="koboSpan" id="kobo.410.1">In a function with multiple return values, remember that the error type is typically the last return value. </span><span class="koboSpan" id="kobo.410.2">You should then handle the error case first, returning in the case of abnormal scenarios, and keeping your code </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">minimally indented.</span></span></p>
<h1 id="_idParaDest-86"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.412.1">Table-driven testing in action</span></h1>
<p><span class="koboSpan" id="kobo.413.1">Now that we have discussed the fundamentals of identifying edge cases and handling errors, we can </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.414.1">begin to look at how to build test suites that cover a variety of scenarios. </span><span class="koboSpan" id="kobo.414.2">A popular technique in Go is to use </span><strong class="bold"><span class="koboSpan" id="kobo.415.1">table-driven testing</span></strong><span class="koboSpan" id="kobo.416.1">. </span><span class="koboSpan" id="kobo.416.2">This technique uses the fundamentals we’ve learned so far to structure test suites that cover a variety </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">of scenarios.</span></span></p>
<p><span class="koboSpan" id="kobo.418.1">Let us begin with a simple example to demonstrate the test-writing process. </span><span class="koboSpan" id="kobo.418.2">We will implement a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">Divide</span></strong><span class="koboSpan" id="kobo.420.1"> mathematical operation that does </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.422.1">Returns the result formatted as a string to two </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">decimal points</span></span></li>
<li><span class="koboSpan" id="kobo.424.1">Returns an error in the case that the divisor </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">is 0</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.426.1">From the preceding requirement, we can formulate the following signature for this </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">new operation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.428.1">
func Divide(x, y int8) </span><strong class="bold"><span class="koboSpan" id="kobo.429.1">(*string, error)</span></strong></pre>
<p><span class="koboSpan" id="kobo.430.1">We remember that the minimum value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">int8</span></strong><span class="koboSpan" id="kobo.432.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">–128</span></strong><span class="koboSpan" id="kobo.434.1"> and the maximum value </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">127</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.438.1">As previously discussed, we make use of multiple return values to encourage explicit error handling in the </span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.439.1">calling code. </span><span class="koboSpan" id="kobo.439.2">Based on the functionality requirements and the lessons learned from the previous </span><em class="italic"><span class="koboSpan" id="kobo.440.1">Identifying edge cases</span></em><span class="koboSpan" id="kobo.441.1"> section, we can identify the following </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">test cases:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.443.1">Base cases</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">:</span></span><ul><li><span class="koboSpan" id="kobo.445.1">Two positive </span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.446.1">values for </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">x</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.448.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">y</span></strong></span></li><li><span class="koboSpan" id="kobo.450.1">Two negative values for </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">x</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.452.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">y</span></strong></span></li></ul></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.454.1">Edge cases</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">:</span></span><ul><li><span class="koboSpan" id="kobo.456.1">Equal values for </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">x</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.458.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">y</span></strong></span></li><li><span class="koboSpan" id="kobo.460.1">Maximum </span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.461.1">value for </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">x</span></strong><span class="koboSpan" id="kobo.463.1"> and positive value </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">y</span></strong></span></li><li><span class="koboSpan" id="kobo.466.1">Minimum value for </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">x</span></strong><span class="koboSpan" id="kobo.468.1"> and positive value </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">y</span></strong></span></li><li><span class="koboSpan" id="kobo.471.1">A zero value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">x</span></strong><span class="koboSpan" id="kobo.473.1"> and a nonzero value </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">y</span></strong></span></li><li><span class="koboSpan" id="kobo.476.1">A positive value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">x</span></strong><span class="koboSpan" id="kobo.478.1"> and a zero value </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">y</span></strong></span></li></ul></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.481.1">Corner cases</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">:</span></span><ul><li><span class="koboSpan" id="kobo.483.1">Zero </span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.484.1">values for </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">x</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.486.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">y</span></strong></span></li><li><span class="koboSpan" id="kobo.488.1">Maximum values for </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">x</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.490.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">y</span></strong></span></li><li><span class="koboSpan" id="kobo.492.1">Minimum values for </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">x</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.494.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">y</span></strong></span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.496.1">In </span><a href="B18371_02.xhtml#_idTextAnchor035"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.497.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.498.1">, </span><em class="italic"><span class="koboSpan" id="kobo.499.1">Unit Testing Essentials</span></em><span class="koboSpan" id="kobo.500.1">, we saw how to write tests and implement different scenarios with subtests. </span><span class="koboSpan" id="kobo.500.2">This involves declaring a shared test setup and declaring a subtest for each case. </span><span class="koboSpan" id="kobo.500.3">For example, the implementation of the first test case could look </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.502.1">
func TestDivide(t *testing.T) {
  t.Run(</span><strong class="bold"><span class="koboSpan" id="kobo.503.1">"positive x, positive y"</span></strong><span class="koboSpan" id="kobo.504.1">, func(t *testing.T) {
</span><strong class="bold"><span class="koboSpan" id="kobo.505.1">    x, y := int8(8), int8(4)</span></strong><span class="koboSpan" id="kobo.506.1">
    r, err := table.Divide(x, y)
</span><strong class="bold"><span class="koboSpan" id="kobo.507.1">    assert.Nil(t, err)</span></strong><span class="koboSpan" id="kobo.508.1">
    assert.Equal(t, </span><strong class="bold"><span class="koboSpan" id="kobo.509.1">"2.00"</span></strong><span class="koboSpan" id="kobo.510.1">, *r)
  })
}</span></pre>
<p><span class="koboSpan" id="kobo.511.1">As we can see from the highlighted lines in this code snippet, the following components are the ones that </span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.512.1">change according to the test case we </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">are running:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.514.1">The name of the test case, which will make our test output easy </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">to read</span></span></li>
<li><span class="koboSpan" id="kobo.516.1">The inputs that will change values according to the test case we </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">are running</span></span></li>
<li><span class="koboSpan" id="kobo.518.1">The expected result value and error value according to the test case we </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">are running</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.520.1">As can be seen from the previous snippet, there is quite a bit of boilerplate code that can be reused across </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">test cases:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.522.1">The declaration of the test function and any required </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">UUT setup</span></span></li>
<li><span class="koboSpan" id="kobo.524.1">The declaration of the subtest and its nested </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">testing function</span></span></li>
<li><span class="koboSpan" id="kobo.526.1">The invocation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">Divide</span></strong><span class="koboSpan" id="kobo.528.1"> function with its </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">input values</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.530.1">As the interaction with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">*testing.T</span></strong><span class="koboSpan" id="kobo.532.1"> object is the most verbose part of the test implementation, a shorter and simpler alternative to test cases is to use table-driven tests, which we will learn all about in the </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">next section.</span></span></p>
<p><span class="koboSpan" id="kobo.534.1">Implementing table-driven tests has a very simple recipe. </span><span class="koboSpan" id="kobo.534.2">We will use the example of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">Divide</span></strong><span class="koboSpan" id="kobo.536.1"> function </span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.537.1">from the previous section to demonstrate </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">each step.</span></span></p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.539.1">Step 1 – declaring the function signature</span></h2>
<p><span class="koboSpan" id="kobo.540.1">We begin </span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.541.1">by declaring the function signature </span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.542.1">that we have presented previously and writing only enough code to make the </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">code compile:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.544.1">
package table
func Divide (x, y int8) </span><strong class="bold"><span class="koboSpan" id="kobo.545.1">(*string, error)</span></strong><span class="koboSpan" id="kobo.546.1"> {
</span><strong class="bold"><span class="koboSpan" id="kobo.547.1">     return nil, nil</span></strong><span class="koboSpan" id="kobo.548.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.549.1">The signature of the function returns a pointer to a string and an error. </span><span class="koboSpan" id="kobo.549.2">In practice, we expect only one of the two values to ever </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">be </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">nil</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.553.1">In the normal flow, the result string will be non-nil, and the error value will </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">be nil</span></span></li>
<li><span class="koboSpan" id="kobo.555.1">In the abnormal flow, the result string will be nil, and the error value will </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">be non-nil</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.557.1">Therefore, by setting </span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.558.1">both values to nil, we will guarantee that there will be no </span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.559.1">accidentally passing test cases. </span><span class="koboSpan" id="kobo.559.2">This helps us begin the red phase of the </span><strong class="bold"><span class="koboSpan" id="kobo.560.1">red-green-refactor</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.561.1">test-driven development</span></strong><span class="koboSpan" id="kobo.562.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.563.1">TDD</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">) process.</span></span></p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.565.1">Step 2 – declaring a structure for our test case</span></h2>
<p><span class="koboSpan" id="kobo.566.1">The first step </span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.567.1">of writing test code is to </span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.568.1">declare a custom type to wrap around our test case. </span><span class="koboSpan" id="kobo.568.2">The </span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.569.1">purpose of this structure is to hold the inputs and expected outputs of the test case. </span><span class="koboSpan" id="kobo.569.2">Generally, this type is declared inside the scope of the function test, but it can also be shared </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">across tests.</span></span></p>
<p><span class="koboSpan" id="kobo.571.1">The test case of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">Divide</span></strong><span class="koboSpan" id="kobo.573.1"> function looks </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.575.1">
func TestDivide(t *testing.T) {
  type testCase struct {
    x, y    int8
    wantErr error
    want    *string
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.576.1">This custom </span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.577.1">type is a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">struct</span></strong><span class="koboSpan" id="kobo.579.1"> type </span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.580.1">that wraps around </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">x</span></strong><span class="koboSpan" id="kobo.582.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">y</span></strong><span class="koboSpan" id="kobo.584.1">—the two inputs of </span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.585.1">the function and the two expected results of the function—the formatted result and the possible returned error. </span><span class="koboSpan" id="kobo.585.2">Note that in Go it is customary to name the expected result as </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">want</span></strong><span class="koboSpan" id="kobo.587.1"> or with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">want</span></strong><span class="koboSpan" id="kobo.589.1"> prefix. </span><span class="koboSpan" id="kobo.589.2">This is different from other languages, where the naming convention begins with the </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">word </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">expected</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">.</span></span></p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.593.1">Step 3 – creating our test-case collection</span></h2>
<p><span class="koboSpan" id="kobo.594.1">Now that we </span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.595.1">have a way to express our test cases, we can begin to </span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.596.1">create a collection of all the cases we want to test for our function. </span><span class="koboSpan" id="kobo.596.2">Based on the two base cases that we identified for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">Divide</span></strong><span class="koboSpan" id="kobo.598.1"> function in the previous sect</span><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.599.1">ion, we can create the following </span><a id="_idTextAnchor097"/><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">tests</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.601.1"> collection:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.602.1">
tests := map[string]testCase{
  "pos x, pos y":   {x: 8, y: 4, want: "2.00"},
  "neg x, neg y":   {x: -4, y: -8, want: "0.50"},
}</span></pre>
<p><span class="koboSpan" id="kobo.603.1">We prefer to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">map</span></strong><span class="koboSpan" id="kobo.605.1"> to add a corresponding name to the test case, which allows us to add the name as a key and the test case as a value. </span><span class="koboSpan" id="kobo.605.2">An alternative solution is to use a slice and save the name of the test case as a field in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">testCase</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.607.1"> type.</span></span></p>
<p><span class="koboSpan" id="kobo.608.1">Note that we don’t provide a value to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">wantErr</span></strong><span class="koboSpan" id="kobo.610.1"> field in the previous test case, as the base cases do not require the verification of errors. </span><span class="koboSpan" id="kobo.610.2">The zero value of the error type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">nil</span></strong><span class="koboSpan" id="kobo.612.1">, so not setting a value for it will be equivalent to declaring a happy path </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">test case.</span></span></p>
<p><span class="koboSpan" id="kobo.614.1">We can further optimize our implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">tests</span></strong><span class="koboSpan" id="kobo.616.1"> map by using anonymous </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">struct</span></strong><span class="koboSpan" id="kobo.618.1"> types for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">testCase</span></strong><span class="koboSpan" id="kobo.620.1"> type to reduce boilerp</span><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.621.1">late and keep the scope of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">testCase</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.623.1">type small:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.624.1">
tests := map[string]stru</span><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.625.1">ct {
  x, y int
  wantErr error
  want string
</span><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.626.1">}{
  "pos x, pos y": {x: 8, y: 4, want: "2.00"},
  "neg x, neg y": {x: -4, y: -8, want: "0.50"},
}</span></pre>
<p><span class="koboSpan" id="kobo.627.1">This can further </span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.628.1">shorten the test declaration but will not allow us </span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.629.1">to share the </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">testCase</span></strong><span class="koboSpan" id="kobo.631.1"> type </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">between tests.</span></span></p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.633.1">Step 4 – executing each test</span></h2>
<p><span class="koboSpan" id="kobo.634.1">With our table </span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.635.1">of tests in place, we will execute </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.636.1">each test case as a subtest. </span><span class="koboSpan" id="kobo.636.2">We will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">range</span></strong><span class="koboSpan" id="kobo.638.1"> statement to loop through the map of tests, which will return the name of the test case and the test case instance itself. </span><span class="koboSpan" id="kobo.638.2">Then, we pass the test name as the subtest name and use the test case during the test setup </span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">and execution:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.640.1">
for name, tc := range tests {
   t.Run(name, func(t *testing.T) {
         // Test execution
   })
}</span></pre>
<p><span class="koboSpan" id="kobo.641.1">This step allows us to set up the interaction with the test runner in one single block for the entire test </span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.642.1">suite. </span><span class="koboSpan" id="kobo.642.2">Remember that each subtest is its </span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.643.1">own function, so we can individually fail tests or stop the execution of the entire test suite using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">testing.T</span></strong><span class="koboSpan" id="kobo.645.1"> helpers that we have explored in </span><a href="B18371_02.xhtml#_idTextAnchor035"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.646.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.647.1">, </span><em class="italic"><span class="koboSpan" id="kobo.648.1">Unit </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.649.1">Testing Essentials</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.650.1">.</span></span></p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.651.1">Step 5 – implementing the test assertions</span></h2>
<p><span class="koboSpan" id="kobo.652.1">Once we have </span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.653.1">set up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">tests</span></strong><span class="koboSpan" id="kobo.655.1"> map and its interaction </span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.656.1">with the test runner, we can begin to implement the testing logic based on the inputs and outputs defined in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">testCase</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.658.1"> type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.659.1">
for name, tc</span><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.660.1"> := range tests {
  t.Run(name, fun</span><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.661.1">c(t *testing.T) {
</span><strong class="bold"><span class="koboSpan" id="kobo.662.1">    x, y := int8(tc.x), int8(tc.y)</span></strong><span class="koboSpan" id="kobo.663.1">
    r, err := table.Divide(x, y)
</span><strong class="bold"><span class="koboSpan" id="kobo.664.1">    if tc.wantErr != nil {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.665.1">      assert.Equal(t, tc.wantErr, err)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.666.1">      return</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.667.1">    }</span></strong><span class="koboSpan" id="kobo.668.1">
    assert.Nil(t, err)
    assert.Equal(t, tc.want, *r)
  })
}</span></pre>
<p><span class="koboSpan" id="kobo.669.1">Based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">tc</span></strong><span class="koboSpan" id="kobo.671.1"> test case value retrieved from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">tests</span></strong><span class="koboSpan" id="kobo.673.1"> map, we use its values of </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">x</span></strong><span class="koboSpan" id="kobo.675.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">y</span></strong><span class="koboSpan" id="kobo.677.1"> to invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">Divide</span></strong><span class="koboSpan" id="kobo.679.1"> function. </span><span class="koboSpan" id="kobo.679.2">Then, we verify the error value and the result value from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">tc</span></strong><span class="koboSpan" id="kobo.681.1"> test case as well. </span><span class="koboSpan" id="kobo.681.2">Note that, just as we do with error handling, we verify the error value first and return from the test in the case of the </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">error case.</span></span></p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.683.1">Step 6 – running the failing test</span></h2>
<p><span class="koboSpan" id="kobo.684.1">Our table-driven </span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.685.1">test suite has successfully been implemented in five </span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.686.1">easy steps! </span><span class="koboSpan" id="kobo.686.2">The basics of running tests and assertions are in place, so we can now run the tests and see them fail. </span><span class="koboSpan" id="kobo.686.3">We can now run the</span><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.687.1"> test with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">go test</span></strong><span class="koboSpan" id="kobo.689.1"> command, as we have done </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">so far:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.691.1">
$  go test -run TestDivide ./chapter04/table -v
--- FAIL: TestDivide (0.00s)
  --- FAIL: TestDivide/pos_x,_pos_y (0.00s)</span></pre>
<p><span class="koboSpan" id="kobo.692.1">As we can see from the output, all the tests are run in their own subtest with the given scenario name passed to the test runner. </span><span class="koboSpan" id="kobo.692.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">–v</span></strong><span class="koboSpan" id="kobo.694.1"> flag is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">verbose</span></strong><span class="koboSpan" id="kobo.696.1"> flag, which will show the full output of all the tests that </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">are run.</span></span></p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.698.1">Step 7 – implementing the base cases</span></h2>
<p><span class="koboSpan" id="kobo.699.1">We now </span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.700.1">begin to implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">Divide</span></strong><span class="koboSpan" id="kobo.702.1"> function happy path </span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.703.1">cases. </span><span class="koboSpan" id="kobo.703.2">We will write two simple lines of </span><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.704.1">code that will allow the tests of the b</span><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.705.1">ase cases </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">to pass:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.707.1">
func Divide</span><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.708.1">(x, y int8) (*string, error) {
  r := float64(x) / float64(y)
  result := fmt.Sprintf("%.2f", r)
  return &amp;result, nil
}</span></pre>
<p><span class="koboSpan" id="kobo.709.1">These two lines of code will handle the normal program flow. </span><span class="koboSpan" id="kobo.709.2">We then rerun the base c</span><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.710.1">ase tests that we have written so far and see </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">them pass:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.712.1">
$  go test -run TestDivide ./chapter04/table -v
--- PASS: TestDivide (0.00s)
  --- PASS: TestDivide/pos_x,_pos_y (0.00s)
  --- PASS: TestDivide/neg_x,_neg_y (0.00s)</span></pre>
<p><span class="koboSpan" id="kobo.713.1">Once these tests pass, we enter the green phase of the red-green-refactor </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">TDD process.</span></span></p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.715.1">Step 8 – expanding the test case collection</span></h2>
<p><span class="koboSpan" id="kobo.716.1">With </span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.717.1">the base case tests passing, it’s time to </span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.718.1">expand our test case collection to include error cases. </span><span class="koboSpan" id="kobo.718.2">Based on the 10 test cases that we identified for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">Divide</span></strong><span class="koboSpan" id="kobo.720.1"> function in the previous </span><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.721.1">section, we can add the following cases to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">tests</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.723.1"> collection:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.724.1">
tests := map[string]struct {
  x, y int
  wantErr error
  want string
}{
  "pos x, pos y":   {x: 8, y: 4, want: "2.00"},
  "neg x, neg y":   {x: -4, y: -8, want: "0.50"},
</span><strong class="bold"><span class="koboSpan" id="kobo.725.1">  "equal x, y":     {x: 4, y: 4, want: "1.00"},</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.726.1">  "max x, pos y":   {x: 127, y: 2, want: "63.50"},</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.727.1">  "min x, pos y":   {x: -128, y: 2, want: "-64.00"},</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.728.1">  "zero x, pos y":</span></strong><strong class="bold"><span class="koboSpan" id="kobo.729.1">  {x: 0, y: 2, want: "0.00"},</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.730.1">  "pos x, zero y":  {x: 10, y: 0, wantErr:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.731.1">    errors.New("cannot divide by 0")},</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.732.1">  "zero x, zero y": {x: 0, y: 0, wantErr:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.733.1">    errors.New("cannot divide by 0")},</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.734.1">  "max x, max y":   {x: 127, y: 127, want: "1.00"},</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.735.1">  "min x, min y":   {x: -128, y: -128, want: "1.00"},</span></strong><span class="koboSpan" id="kobo.736.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.737.1">In practice, we would expand each of the edge and corner cases one at a time, ensuring that each of them passes. </span><span class="koboSpan" id="kobo.737.2">However, we will add them all in one step, for the purpose </span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">of brevity.</span></span></p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.739.1">Step 9 – expanding functional code</span></h2>
<p><span class="koboSpan" id="kobo.740.1">As expected, the </span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.741.1">new error edge cases will fail when run with </span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.742.1">the typical </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">go test</span></strong><span class="koboSpan" id="kobo.744.1"> command, prompting us to implement functional code. </span><span class="koboSpan" id="kobo.744.2">We expand our </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">Divide</span></strong><span class="koboSpan" id="kobo.746.1"> function to handle the error case described in the </span><span class="No-Break"><span class="koboSpan" id="kobo.747.1">user requirements:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.748.1">
func Divide(x, y int8) (*string, error) {
</span><strong class="bold"><span class="koboSpan" id="kobo.749.1">  if y == 0 {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.750.1">    return nil, errors.New("cannot divide by 0")</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.751.1">  }</span></strong><span class="koboSpan" id="kobo.752.1">
  r := float64(x) / float64(y)
  result := fmt.Sprintf("%.2f", r)
  return &amp;result, nil
}</span></pre>
<p><span class="koboSpan" id="kobo.753.1">As usual, the error case is handled at the top of the function, keeping the code minimally indented. </span><span class="koboSpan" id="kobo.753.2">Note that we initialize an error using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">errors.New</span></strong><span class="koboSpan" id="kobo.755.1"> function, which takes in a message. </span><span class="koboSpan" id="kobo.755.2">We can initialize errors in other ways </span><span class="No-Break"><span class="koboSpan" id="kobo.756.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.757.1">The final step is to run our fully i</span><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.758.1">mplemented table-driven test suite using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">go </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">test</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.761.1"> command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.762.1">
$ go test -run TestDivide ./chapter04/table -v
</span><strong class="bold"><span class="koboSpan" id="kobo.763.1">--- PASS: TestDivide (0.00s)</span></strong><span class="koboSpan" id="kobo.764.1">
  --- PASS: TestDivide/zero_x,_pos_y (0.00s)
  --- PASS: TestDivide/max_x,_max_y (0.00s)
  --- PASS: TestDivide/max_x,_pos_y (0.00s)
  --- PASS: TestDivide/min_x,_pos_y (0.00s)
  --- PASS: TestDivide/equal_x,_y (0.00s)
  --- PASS: TestDivide/min_x,_min_y (0.00s)
  --- PASS: TestDivide/pos_x,_zero_y (0.00s)
  --- PASS: TestDivide/zero_x,_zero_y (0.00s)
  --- PASS: TestDivide/pos_x,_pos_y (0.00s)
  --- PASS: TestDivide/neg_x,_neg_y (0.00s)
PASS ok      github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter04/table        0.298s</span></pre>
<p><span class="koboSpan" id="kobo.765.1">As we can see from the output, all the tests are run successfully in their own subtest, with the given </span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.766.1">scenario name passed to the test runner. </span><span class="koboSpan" id="kobo.766.2">Our first </span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.767.1">table-driven test suite has been successfully implemented. </span><span class="koboSpan" id="kobo.767.2">This is a common testing technique that you will often use when you write Go code, so it’s important to master </span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">its methods.</span></span></p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.769.1">Parallelization</span></h2>
<p><span class="koboSpan" id="kobo.770.1">By default, all the </span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.771.1">tests in each package will be run sequentially, but </span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.772.1">tests from multiple packages will run in parallel. </span><span class="koboSpan" id="kobo.772.2">As the number of tests increases, the sequential test execution time of a given package can increase </span><span class="No-Break"><span class="koboSpan" id="kobo.773.1">as well.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.774.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.775.1">.7</span></em><span class="koboSpan" id="kobo.776.1"> demonstrates </span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.777.1">the behavior of </span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.778.1">sequential and parallel </span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">test runs:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<span class="koboSpan" id="kobo.780.1"><img alt="Figure 4.7 – Sequential versus parallel test runs " src="image/Figure_4.07_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.781.1">Figure 4.7 – Sequential versus parallel test runs</span></p>
<p><span class="koboSpan" id="kobo.782.1">The test run life cycle is set </span><span class="No-Break"><span class="koboSpan" id="kobo.783.1">out here:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.784.1">The tests begin running. </span><span class="koboSpan" id="kobo.784.2">Tests in different packages run in parallel—tests in </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">package A</span></strong><span class="koboSpan" id="kobo.786.1"> can run at the same time as tests in </span><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">package B</span></strong><span class="koboSpan" id="kobo.788.1">. </span><span class="koboSpan" id="kobo.788.2">This allows us to reduce </span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">running time.</span></span></li>
<li><span class="koboSpan" id="kobo.790.1">By default, test cases in the same package run sequentially. </span><span class="koboSpan" id="kobo.790.2">This is demonstrated by the tests in </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">package A</span></strong><span class="koboSpan" id="kobo.792.1">—</span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">TestCase 1</span></strong><span class="koboSpan" id="kobo.794.1"> needs to complete before </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">TestCase 2</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.796.1">can run.</span></span></li>
<li><span class="koboSpan" id="kobo.797.1">The test cases in the same package can be configured to run in parallel. </span><span class="koboSpan" id="kobo.797.2">This is demonstrated by the tests in </span><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">package B</span></strong><span class="koboSpan" id="kobo.799.1">—</span><strong class="source-inline"><span class="koboSpan" id="kobo.800.1">TestCase 1</span></strong><span class="koboSpan" id="kobo.801.1"> can run concurrently with </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.802.1">TestCase 2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.804.1">The number of tests that we can run in parallel is limited by the resources available to the test runner, but parallelizing test runs is a great way to reduce the test run time, which can further reduce the feedback cycle of </span><span class="No-Break"><span class="koboSpan" id="kobo.805.1">CI/CD pipelines.</span></span></p>
<p><span class="koboSpan" id="kobo.806.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">*testing.T</span></strong><span class="koboSpan" id="kobo.808.1"> type provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">t.Parallel()</span></strong><span class="koboSpan" id="kobo.810.1"> method, which allows us to specify which tests can be run in parallel with other parallel marked tests from the same package. </span><span class="koboSpan" id="kobo.810.2">As the </span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.811.1">subtests of our table-driven test run </span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.812.1">independently, we need to mark each as parallel and not just the </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">top-level test.</span></span></p>
<p><span class="koboSpan" id="kobo.814.1">The ability to mark certain tests for parallelization is particularly useful together with table-driven tests, which contain independently running test cases. </span><span class="koboSpan" id="kobo.814.2">We can easily adjust our table-driven tests to run in parallel with two short lines </span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.816.1">
for name, rtc := range tests {
</span><strong class="bold"><span class="koboSpan" id="kobo.817.1">  tc := rtc</span></strong><span class="koboSpan" id="kobo.818.1">
  t.Run(name, func(t *testing.T) {
</span><strong class="bold"><span class="koboSpan" id="kobo.819.1">    t.Parallel()</span></strong><span class="koboSpan" id="kobo.820.1">
    x, y := int8(tc.x), int8(tc.y)
    r, err := table.Divide(x, y)
    if tc.wantErr != nil {
      assert.Equal(t, tc.wantErr, err)
      return
    }
    assert.Nil(t, err)
    assert.Equal(t, tc.want, *r)
     })
}</span></pre>
<p><span class="koboSpan" id="kobo.821.1">We assign the current test case to a local </span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">tc</span></strong><span class="koboSpan" id="kobo.823.1"> variable to capture the test case range variable. </span><span class="koboSpan" id="kobo.823.2">This is required as the subtest will now run in a goroutine under the hood. </span><span class="koboSpan" id="kobo.823.3">We need to create a copy of the current value of the test case to the subtest closure, as opposed to the changing range </span><span class="No-Break"><span class="koboSpan" id="kobo.824.1">return value.</span></span></p>
<p><span class="koboSpan" id="kobo.825.1">The second change we have made is to add the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">t.Parallel()</span></strong><span class="koboSpan" id="kobo.827.1"> in the subtest, marking each of the subtests as allowed to be run </span><span class="No-Break"><span class="koboSpan" id="kobo.828.1">in parallel.</span></span></p>
<p><span class="koboSpan" id="kobo.829.1">By default, the </span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.830.1">number of binaries that can run in parallel is equal </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.831.1">to the number of CPUs. </span><span class="koboSpan" id="kobo.831.2">This variable can be overridden by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">–parallel</span></strong><span class="koboSpan" id="kobo.833.1"> flag, available on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">go </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">test</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.836.1"> command.</span></span></p>
<p><span class="koboSpan" id="kobo.837.1">With our table-driven tests marked as parallel, we can run our tests again using </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">go test</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.839.1">:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.840.1">
$  go test -run TestDivide ./chapter04/table -v
=== RUN   TestDivide
=== RUN   TestDivide/pos_x,_pos_y
=== PAUSE TestDivide/pos_x,_pos_y
=== RUN   TestDivide/neg_x,_neg_y
=== PAUSE TestDivide/neg_x,_neg_y
=== CONT  TestDivide/pos_x,_pos_y
=== CONT  TestDivide/neg_x,_neg_y
--- PASS: TestDivide (0.00s)
  --- PASS: TestDivide/pos_x,_pos_y (0.00s)
  --- PASS: TestDivide/neg_x,_neg_y (0.00s) 
ok      github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter04/table        0.223s</span></pre>
<p><span class="koboSpan" id="kobo.841.1">The output of the test </span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.842.1">run has been shortened. </span><span class="koboSpan" id="kobo.842.2">As we can </span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.843.1">see from the interleaving output, the tests are now running in parallel, in an interleaving manner: run, pause, </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">and continue.</span></span></p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.845.1">Advantages and disadvantages of table-driven testing</span></h2>
<p><span class="koboSpan" id="kobo.846.1">This brings us to the end of our exploration of table-driven testing. </span><span class="koboSpan" id="kobo.846.2">Let us conclude with a short discussion of its advantages and disadvantages. </span><span class="koboSpan" id="kobo.846.3">Table-driven tests are best suited to scenarios that cover a variety of test cases with different inputs </span><span class="No-Break"><span class="koboSpan" id="kobo.847.1">and outputs.</span></span></p>
<h3><span class="koboSpan" id="kobo.848.1">Advantages</span></h3>
<p><span class="koboSpan" id="kobo.849.1">Table-driven tests have the </span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">following advantages:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.851.1">Provide a concise </span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.852.1">way to define and run multiple test cases, which reduces </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">boilerplate code</span></span></li>
<li><span class="koboSpan" id="kobo.854.1">Easy to add and remove new tests by simply modifying the collection of </span><span class="No-Break"><span class="koboSpan" id="kobo.855.1">test cases</span></span></li>
<li><span class="koboSpan" id="kobo.856.1">As all of the test cases are run using the same surrounding code, we can easily refactor the test setup and </span><span class="No-Break"><span class="koboSpan" id="kobo.857.1">assertion code</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.858.1">Disadvantages</span></h3>
<p><span class="koboSpan" id="kobo.859.1">Here are some disadvantages of </span><span class="No-Break"><span class="koboSpan" id="kobo.860.1">table-driven tests:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.861.1">As all the test </span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.862.1">cases are run identically, it may be difficult to create even small variations of the test setup and </span><span class="No-Break"><span class="koboSpan" id="kobo.863.1">assertion code.</span></span></li>
<li><span class="koboSpan" id="kobo.864.1">Table-driven tests are not suitable for test cases that require different test setup and teardown logic. </span><span class="koboSpan" id="kobo.864.2">They also make it difficult to use mocks, which must </span><span class="No-Break"><span class="koboSpan" id="kobo.865.1">behave differently.</span></span></li>
<li><span class="koboSpan" id="kobo.866.1">Some developers argue that table-driven tests are difficult to read. </span><span class="koboSpan" id="kobo.866.2">While the name of the test case allows us to name each test, the code is not readable, especially </span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.867.1">when compared to the </span><strong class="bold"><span class="koboSpan" id="kobo.868.1">behavior-driven development</span></strong><span class="koboSpan" id="kobo.869.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.870.1">BDD</span></strong><span class="koboSpan" id="kobo.871.1">) style </span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.872.1">of </span><span class="No-Break"><span class="koboSpan" id="kobo.873.1">writing tests.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.874.1">When implemented correctly, table-driven tests are a great way to test your code across a variety of scenarios and edge cases. </span><span class="koboSpan" id="kobo.874.2">They help us create a uniform way of running tests, which also makes it easy to maintain and refactor test code. </span><span class="koboSpan" id="kobo.874.3">Many developers advocate implementing your tests as table-driven tests from the very beginning, even if you don’t have many test cases when you get started. </span><span class="koboSpan" id="kobo.874.4">As your code matures, you will have an easy way to add new </span><span class="No-Break"><span class="koboSpan" id="kobo.875.1">test cases.</span></span></p>
<p><span class="koboSpan" id="kobo.876.1">If you have large variations in test setup, you can use different tests and dedicated subtests to group </span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">your tests.</span></span></p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.878.1">Use case – the BookSwap application</span></h1>
<p><span class="koboSpan" id="kobo.879.1">One of the most popular use cases of Go is for building web applications. </span><span class="koboSpan" id="kobo.879.2">Therefore, it is important to know how </span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.880.1">to build and test web applications. </span><span class="koboSpan" id="kobo.880.2">We will learn how to build our first use case web application: the </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">BookSwap</span></strong><span class="koboSpan" id="kobo.882.1"> application. </span><span class="koboSpan" id="kobo.882.2">We will explore and test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">BookSwap</span></strong><span class="koboSpan" id="kobo.884.1"> application in this and the </span><span class="No-Break"><span class="koboSpan" id="kobo.885.1">following chapters.</span></span></p>
<p><span class="koboSpan" id="kobo.886.1">This simple application allows users to sign up and register which books they have available. </span><span class="koboSpan" id="kobo.886.2">Other users can sign up for the application and view other users’ available books. </span><span class="koboSpan" id="kobo.886.3">They can then request to borrow a book from another user. </span><span class="koboSpan" id="kobo.886.4">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">BookSwap</span></strong><span class="koboSpan" id="kobo.888.1"> application then generates an order and sends it to the posting service for wrapping </span><span class="No-Break"><span class="koboSpan" id="kobo.889.1">and shipping.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.890.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.891.1">.8</span></em><span class="koboSpan" id="kobo.892.1"> depicts an overview of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">BookSwap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.894.1"> application:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer041">
<span class="koboSpan" id="kobo.895.1"><img alt="Figure 4.8 – Overview of the book swap web application " src="image/Figure_4.08_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.896.1">Figure 4.8 – Overview of the book swap web application</span></p>
<p><span class="koboSpan" id="kobo.897.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">BookSwap</span></strong><span class="koboSpan" id="kobo.899.1"> web application has some </span><span class="No-Break"><span class="koboSpan" id="kobo.900.1">simple components:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.901.1">The user interacts </span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.902.1">with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.903.1">UserService</span></strong><span class="koboSpan" id="kobo.904.1"> service endpoints. </span><span class="koboSpan" id="kobo.904.2">It exposes a few simple endpoints that provide all the functionality the </span><span class="No-Break"><span class="koboSpan" id="kobo.905.1">application requires:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">GET /</span></strong><span class="koboSpan" id="kobo.907.1"> returns a welcome message and all the book listings available in the application. </span><span class="koboSpan" id="kobo.907.2">This endpoint will serve as the application home page, which will show all the available books that users can swap. </span><span class="koboSpan" id="kobo.907.3">For completion, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.908.1">GET /books</span></strong><span class="koboSpan" id="kobo.909.1"> endpoint will also return a list of </span><span class="No-Break"><span class="koboSpan" id="kobo.910.1">available books.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">POST /users</span></strong><span class="koboSpan" id="kobo.912.1"> creates a new user. </span><span class="koboSpan" id="kobo.912.2">The user will receive a unique </span><strong class="source-inline"><span class="koboSpan" id="kobo.913.1">userID</span></strong><span class="koboSpan" id="kobo.914.1"> value, which they will need to remember for further interactions. </span><span class="koboSpan" id="kobo.914.2">For the sake of simplicity, we will not handle user authentication or any </span><span class="No-Break"><span class="koboSpan" id="kobo.915.1">security concerns.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.916.1">GET /users/{id}</span></strong><span class="koboSpan" id="kobo.917.1"> returns the book listings of the given user. </span><span class="koboSpan" id="kobo.917.2">This endpoint will serve as the profile page of a </span><span class="No-Break"><span class="koboSpan" id="kobo.918.1">given user.</span></span></li></ul></li>
<li><span class="koboSpan" id="kobo.919.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.920.1">UserService</span></strong><span class="koboSpan" id="kobo.921.1"> service relies on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">BookService</span></strong><span class="koboSpan" id="kobo.923.1">. </span><span class="koboSpan" id="kobo.923.2">It manages the details and statuses of all the books available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.924.1">BookSwap</span></strong><span class="koboSpan" id="kobo.925.1"> web application. </span><span class="koboSpan" id="kobo.925.2">It exposes the </span><span class="No-Break"><span class="koboSpan" id="kobo.926.1">following endpoints:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.927.1">POST /books</span></strong><span class="koboSpan" id="kobo.928.1"> creates a new book listing on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.929.1">BookSwap</span></strong><span class="koboSpan" id="kobo.930.1"> service. </span><span class="koboSpan" id="kobo.930.2">This request will take the details of the book to create a JSON </span><span class="No-Break"><span class="koboSpan" id="kobo.931.1">request body.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">POST /books/{id}?user={userId}</span></strong><span class="koboSpan" id="kobo.933.1"> creates a new request for a particular book and given user. </span><span class="koboSpan" id="kobo.933.2">This will create a request to send the given book to a </span><span class="No-Break"><span class="koboSpan" id="kobo.934.1">new user.</span></span></li></ul></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.935.1">BookService</span></strong><span class="koboSpan" id="kobo.936.1"> has a dependency on the external posting service, which handles the creation of </span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.937.1">mail stamps and issues a request for packaging. </span><span class="koboSpan" id="kobo.937.2">Once </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">PostingService</span></strong><span class="koboSpan" id="kobo.939.1"> has handled the order request, we can mark the book as swapped and update its </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">ownerID</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.941.1"> value.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.942.1">You can explore the full </span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.943.1">implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">BookSwap</span></strong><span class="koboSpan" id="kobo.945.1"> application on our GitHub repository. </span><span class="koboSpan" id="kobo.945.2">The application is implemented using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.946.1">net/http</span></strong><span class="koboSpan" id="kobo.947.1"> package in the standard library. </span><span class="koboSpan" id="kobo.947.2">We will explore some relevant parts of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.948.1">BookSwap</span></strong><span class="koboSpan" id="kobo.949.1"> web application in this chapter, which showcase what we have learned in </span><span class="No-Break"><span class="koboSpan" id="kobo.950.1">this chapter.</span></span></p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.951.1">Testing BookService</span></h2>
<p><span class="koboSpan" id="kobo.952.1">We will represent </span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.953.1">books as a very simple data type that uses JSON tags to format its contents for display on REST APIs, which serve </span><span class="No-Break"><span class="koboSpan" id="kobo.954.1">JSON data:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.955.1">
type Book struct {
</span><strong class="bold"><span class="koboSpan" id="kobo.956.1">  ID         string `json:"id"`</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.957.1">  Name</span></strong><strong class="bold"><span class="koboSpan" id="kobo.958.1">       string `json:"name"`</span></strong><span class="koboSpan" id="kobo.959.1">
  Author     string `json:"author"`
  OwnerID    string `json:"owner_id"`
  Status     string `json:"status"`
}</span></pre>
<p><span class="koboSpan" id="kobo.960.1">While REST APIs don’t have to operate on JSON data, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.961.1">application/json</span></strong><span class="koboSpan" id="kobo.962.1"> data format is the most used. </span><span class="koboSpan" id="kobo.962.2">The book has </span><strong class="source-inline"><span class="koboSpan" id="kobo.963.1">OwnerID</span></strong><span class="koboSpan" id="kobo.964.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.965.1">Status</span></strong><span class="koboSpan" id="kobo.966.1">, which shows whether the book is available </span><span class="No-Break"><span class="koboSpan" id="kobo.967.1">for swaps.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.968.1">BookService</span></strong><span class="koboSpan" id="kobo.969.1"> is a very simple service that manages books. </span><span class="koboSpan" id="kobo.969.2">It will need to be able to retrieve and </span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.970.1">manage books with six </span><span class="No-Break"><span class="koboSpan" id="kobo.971.1">simple methods:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.972.1">
// NewBookService initializes a BookService given its
// dependencies.
</span><span class="koboSpan" id="kobo.972.2">func NewBookService(initial []Book, ps PostingService) *BookService
// Get returns a given book or error if none exists.
</span><span class="koboSpan" id="kobo.972.3">func (bs *BookService) Get(id string) (*Book, error)
// Upsert creates or updates a book.
</span><span class="koboSpan" id="kobo.972.4">func (bs *BookService) Upsert(b Book) Book
// List returns the list of available books.
</span><span class="koboSpan" id="kobo.972.5">func (bs *BookService) List() []Book
// ListByUser returns the list of books for a given user.
</span><span class="koboSpan" id="kobo.972.6">func (bs *BookService) ListByUser(userID string) []Book
// SwapBook checks whether a book is available and, if
// possible, marks it as swapped.
</span><span class="koboSpan" id="kobo.972.7">func (bs *BookService) SwapBook(bookID, userID string)(*Book, error)</span></pre>
<p><span class="koboSpan" id="kobo.973.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.974.1">NewBookService</span></strong><span class="koboSpan" id="kobo.975.1"> method initializes </span><strong class="source-inline"><span class="koboSpan" id="kobo.976.1">BookService</span></strong><span class="koboSpan" id="kobo.977.1"> with a given list of books and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.978.1">PostingService</span></strong><span class="koboSpan" id="kobo.979.1"> service. </span><span class="koboSpan" id="kobo.979.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.980.1">Get</span></strong><span class="koboSpan" id="kobo.981.1"> method attempts to find a book for a given ID, returning an error if not found. </span><span class="koboSpan" id="kobo.981.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.982.1">Upsert</span></strong><span class="koboSpan" id="kobo.983.1"> method creates a new book entry or updates the entry if the given ID is already found. </span><span class="koboSpan" id="kobo.983.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.984.1">List</span></strong><span class="koboSpan" id="kobo.985.1"> operation returns all the books that are available for loan. </span><strong class="source-inline"><span class="koboSpan" id="kobo.986.1">ListByUser</span></strong><span class="koboSpan" id="kobo.987.1"> filters all books for a given owner, allowing us to power the home page of a given user. </span><strong class="source-inline"><span class="koboSpan" id="kobo.988.1">SwapBook</span></strong><span class="koboSpan" id="kobo.989.1"> is a function that wraps around </span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.990.1">availability, checking and updating the owner ID of a given book in case of a </span><span class="No-Break"><span class="koboSpan" id="kobo.991.1">swap request.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.992.1">BookService</span></strong><span class="koboSpan" id="kobo.993.1"> will save the book entries on a map with their ID as </span><span class="No-Break"><span class="koboSpan" id="kobo.994.1">the key:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.995.1">
type BookService struct {
</span><strong class="bold"><span class="koboSpan" id="kobo.996.1">     books map[string]Book</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.997.1">     ps    PostingService</span></strong><span class="koboSpan" id="kobo.998.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.999.1">The map will facilitate lookup operations, which will be required for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1000.1">BookSwap</span></strong><span class="koboSpan" id="kobo.1001.1"> application. </span><span class="koboSpan" id="kobo.1001.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1002.1">Get</span></strong><span class="koboSpan" id="kobo.1003.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1004.1">List</span></strong><span class="koboSpan" id="kobo.1005.1"> operations are expected to be the most popular, as they will appear on the homepage and </span><span class="No-Break"><span class="koboSpan" id="kobo.1006.1">profile pages.</span></span></p>
<p><span class="koboSpan" id="kobo.1007.1">Let us have a look at how we can formulate the table-driven tests for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1008.1">Get</span></strong><span class="koboSpan" id="kobo.1009.1"> operation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1010.1">BookService</span></strong><span class="koboSpan" id="kobo.1011.1">. </span><span class="koboSpan" id="kobo.1011.2">We declare a test with two corresponding subtests—one for an initial amount of books and one for an empty </span><span class="No-Break"><span class="koboSpan" id="kobo.1012.1">book map:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1013.1">
func TestGetBook(t *testing.T) {
</span><strong class="bold"><span class="koboSpan" id="kobo.1014.1">  t.Run("initial books", func(t *testing.T) {</span></strong><span class="koboSpan" id="kobo.1015.1">
   // Books are available in the BookService
  })
</span><strong class="bold"><span class="koboSpan" id="kobo.1016.1">  t.Run("empty books", func(t *testing.T) {</span></strong><span class="koboSpan" id="kobo.1017.1">
    // No books in the BookService
  })
}</span></pre>
<p><span class="koboSpan" id="kobo.1018.1">We use two different subtests for the two cases, as they require two different test setups. </span><span class="koboSpan" id="kobo.1018.2">As we have discussed, table-driven tests are not suitable for scenarios that require different setup conditions. </span><span class="koboSpan" id="kobo.1018.3">We begin by creating a sample book and creating a new </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1019.1">BookService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1020.1"> instance:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1021.1">
eb := db.Book{
  ID: uuid.New().String(),
  Name: "Existing book",
  Status: db.Available.String(),
}
bs := db.NewBookService([]db.Book{eb}, nil)</span></pre>
<p><span class="koboSpan" id="kobo.1022.1">This starting </span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.1023.1">point will be shared by all test cases in this subtest. </span><span class="koboSpan" id="kobo.1023.2">Note that we pass a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">nil</span></strong><span class="koboSpan" id="kobo.1025.1"> value as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1026.1">PostingService</span></strong><span class="koboSpan" id="kobo.1027.1"> service, as it will not be tested by these tests. </span><span class="koboSpan" id="kobo.1027.2">Then, we implement a table-driven test with three scenarios in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1028.1">first subtest:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1029.1">
tests := map[string]struct {
  id string
  want db.Book
  wantErr error
}{
</span><strong class="bold"><span class="koboSpan" id="kobo.1030.1">  "existing book": {id: eb.ID, want: eb},</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1031.1">  "no book found": {id: "not-found", wantErr:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1032.1">    errors.New("no book found")},</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1033.1">  "empty id": {id: "", wantErr: errors.New("no book</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1034.1">    found")},</span></strong><span class="koboSpan" id="kobo.1035.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.1036.1">The three cases consist of finding an existing book, looking for a book that is not found in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1037.1">BookService</span></strong><span class="koboSpan" id="kobo.1038.1">, and looking for an empty ID. </span><span class="koboSpan" id="kobo.1038.2">Then, we loop through the test cases and run the assertions according to the inputs and expectations of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1039.1">test case:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1040.1">
for name, tc := range tests {
  t.Run(name, func(t *testing.T) {
</span><strong class="bold"><span class="koboSpan" id="kobo.1041.1">    b, err := bs.Get(tc.id)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1042.1">    if tc.wantErr != nil {</span></strong><span class="koboSpan" id="kobo.1043.1">
     assert.Equal(t, tc.wantErr, err)
     assert.Nil(t, b)
     return
    }
    assert.Nil(t, err)
    assert.Equal(t, tc.want, *b)
  })
}</span></pre>
<p><span class="koboSpan" id="kobo.1044.1">Just as we did in the </span><em class="italic"><span class="koboSpan" id="kobo.1045.1">Table-driven testing in action</span></em><span class="koboSpan" id="kobo.1046.1"> section, we loop through the map of test cases and handle the error cases first. </span><span class="koboSpan" id="kobo.1046.2">Remember to verify all the wanted </span><span class="No-Break"><span class="koboSpan" id="kobo.1047.1">return </span></span><span class="No-Break"><a id="_idIndexMarker368"/></span><span class="No-Break"><span class="koboSpan" id="kobo.1048.1">values.</span></span></p>
<p><span class="koboSpan" id="kobo.1049.1">In the second subtest, named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1050.1">"empty books"</span></strong><span class="koboSpan" id="kobo.1051.1">, we have run a single test and performed the required verifications on a different </span><span class="No-Break"><span class="koboSpan" id="kobo.1052.1">UUT instance:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1053.1">
t.Run("empty books", func(t *testing.T) {
     bs := db.NewBookService([]db.Book{})
</span><strong class="bold"><span class="koboSpan" id="kobo.1054.1">     b, err := bs.Get("id")</span></strong><span class="koboSpan" id="kobo.1055.1">
     assert.Equal(t, errors.New("no book found"), err)
     assert.Nil(t, b)
})</span></pre>
<p><span class="koboSpan" id="kobo.1056.1">We could have potentially implemented table-driven tests for the second subtest as well, but we have opted to include a single test here to keep the code </span><span class="No-Break"><span class="koboSpan" id="kobo.1057.1">snippets concise.</span></span></p>
<p><span class="koboSpan" id="kobo.1058.1">Finally, we run our tests using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1059.1">go test</span></strong><span class="koboSpan" id="kobo.1060.1"> command to ensure that they </span><span class="No-Break"><span class="koboSpan" id="kobo.1061.1">are passing:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1062.1">
$ go test -run TestGetBook ./chapter04/db -v
=== RUN   TestGetBook
--- PASS: TestGetBook (0.00s)
  --- PASS: TestGetBook/initial_books (0.00s)
</span><strong class="bold"><span class="koboSpan" id="kobo.1063.1">  --- PASS: TestGetBook/initial_books/existing_book (0.00s)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1064.1">  --- PASS: TestGetBook/initial_books/no_book_found (0.00s)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1065.1">  --- PASS: TestGetBook/initial_books/empty_id (0.00s)</span></strong><span class="koboSpan" id="kobo.1066.1">
  --- PASS: TestGetBook/empty_books (0.00s)
PASS 
ok      github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter04/db   0.217s</span></pre>
<p><span class="koboSpan" id="kobo.1067.1">Note that the output </span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.1068.1">shows the nesting of the two different subtests. </span><span class="koboSpan" id="kobo.1068.2">This allows us to build detailed test hierarchies. </span><span class="koboSpan" id="kobo.1068.3">We will continue to explore and test other parts of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1069.1">BookSwap</span></strong><span class="koboSpan" id="kobo.1070.1"> application in the next few chapters, so there will be plenty of time to </span><span class="No-Break"><span class="koboSpan" id="kobo.1071.1">explore it.</span></span></p>
<h1 id="_idParaDest-100"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.1072.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1073.1">In this chapter, we explored how to identify edge cases and write test suites that cover multiple conditions. </span><span class="koboSpan" id="kobo.1073.2">We began with how to identify edge cases for systems with input parameters and external services, revising Go’s approach to explicit error handling. </span><span class="koboSpan" id="kobo.1073.3">Then, we learned how to implement table-driven testing. </span><span class="koboSpan" id="kobo.1073.4">This popular technique allows us to test multiple scenarios with a minimal amount of boilerplate code. </span><span class="koboSpan" id="kobo.1073.5">It also allows running test cases in parallel, enabling us to make optimizations for the running of test cases as well. </span><span class="koboSpan" id="kobo.1073.6">Finally, we introduced our new use case—the BookSwap web application. </span><span class="koboSpan" id="kobo.1073.7">This example application will be the focus of the next few chapters, where we will learn how to test one of Go’s most popular use cases: building </span><span class="No-Break"><span class="koboSpan" id="kobo.1074.1">web applications.</span></span></p>
<p><span class="koboSpan" id="kobo.1075.1">In </span><a href="B18371_05.xhtml#_idTextAnchor124"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1076.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.1077.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1078.1">Performing Integration Testing</span></em><span class="koboSpan" id="kobo.1079.1">, we will begin to consider how to use TDD for testing </span><strong class="bold"><span class="koboSpan" id="kobo.1080.1">end-to-end</span></strong><span class="koboSpan" id="kobo.1081.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1082.1">E2E</span></strong><span class="koboSpan" id="kobo.1083.1">) applications, including database testing. </span><span class="koboSpan" id="kobo.1083.2">We will also learn how to use Docker for identical application setup and </span><span class="No-Break"><span class="koboSpan" id="kobo.1084.1">easy teardown.</span></span></p>
<p><span class="koboSpan" id="kobo.1085.1">In </span><a href="B18371_10.xhtml#_idTextAnchor218"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1086.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.1087.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1088.1">Testing Edge Cases</span></em><span class="koboSpan" id="kobo.1089.1">, we will explore other testing techniques, such as fuzz testing and property-driven testing, which can make edge case verification </span><span class="No-Break"><span class="koboSpan" id="kobo.1090.1">even easier.</span></span></p>
<h1 id="_idParaDest-101"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.1091.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.1092.1">What is an edge case? </span><span class="koboSpan" id="kobo.1092.2">What is a </span><span class="No-Break"><span class="koboSpan" id="kobo.1093.1">corner case?</span></span></li>
<li><span class="koboSpan" id="kobo.1094.1">What is an </span><span class="No-Break"><span class="koboSpan" id="kobo.1095.1">idempotent operation?</span></span></li>
<li><span class="koboSpan" id="kobo.1096.1">Explain Go’s explicit </span><span class="No-Break"><span class="koboSpan" id="kobo.1097.1">error handling.</span></span></li>
<li><span class="koboSpan" id="kobo.1098.1">What is table-driven testing? </span><span class="koboSpan" id="kobo.1098.2">What are some of </span><span class="No-Break"><span class="koboSpan" id="kobo.1099.1">its advantages?</span></span></li>
<li><span class="koboSpan" id="kobo.1100.1">How does Go parallelize </span><span class="No-Break"><span class="koboSpan" id="kobo.1101.1">test runs?</span></span></li>
</ol>
<h1 id="_idParaDest-102"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.1102.1">Further reading</span></h1>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.1103.1">Building Microservices Second edition: Designing Fine-Grained Systems</span></em><span class="koboSpan" id="kobo.1104.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1105.1">Sam Newman</span></em><span class="koboSpan" id="kobo.1106.1">, published </span><span class="No-Break"><span class="koboSpan" id="kobo.1107.1">by </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1108.1">O’Reilly</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1109.1">.</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1110.1">Error handling and Go on the Go blog</span></em><span class="koboSpan" id="kobo.1111.1">. </span><span class="koboSpan" id="kobo.1111.2">Available </span><span class="No-Break"><span class="koboSpan" id="kobo.1112.1">at </span></span><a href="https://go.dev/blog/error-handling-and-go"><span class="No-Break"><span class="koboSpan" id="kobo.1113.1">https://go.dev/blog/error-handling-and-go</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1114.1">.</span></span></li>
</ul>
</div>


<div class="Content" id="_idContainer043">
<h1 id="_idParaDest-103"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.1.1">Part 2: Integration and End-to-End Testing with TDD</span></h1>
<p><span class="koboSpan" id="kobo.2.1">With the fundamentals of TDD and Go testing in place, this part moves our focus beyond testing components in isolation. </span><span class="koboSpan" id="kobo.2.2">We explore the importance of integration testing and learn how to write tests using </span><strong class="source-inline"><span class="koboSpan" id="kobo.3.1">httptest</span></strong><span class="koboSpan" id="kobo.4.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.5.1">ginkgo</span></strong><span class="koboSpan" id="kobo.6.1"> to test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.7.1">BookSwap</span></strong><span class="koboSpan" id="kobo.8.1"> web application. </span><span class="koboSpan" id="kobo.8.2">Then, we extend the functionality of the application by adding a database and containerizing it using Docker, which allows us to create identical test setups. </span><span class="koboSpan" id="kobo.8.3">Once the application is extended into a monolithic application, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.9.1">GoDog</span></strong><span class="koboSpan" id="kobo.10.1"> to implement end-to-end testing using BDD-style features. </span><span class="koboSpan" id="kobo.10.2">However, refactoring is an integral part of the development process, often applied to splitting monolithic applications to microservice architectures. </span><span class="koboSpan" id="kobo.10.3">We examine testing microservice integrations using contract testing, implemented using the Pact open-source </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">testing tool.</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">following chapters:</span></span></p>
<ul>
<li><a href="B18371_05.xhtml#_idTextAnchor124"><em class="italic"><span class="koboSpan" id="kobo.14.1">Chapter 5</span></em></a><em class="italic"><span class="koboSpan" id="kobo.15.1">, Performing Integration Testing</span></em></li>
<li><a href="B18371_06.xhtml#_idTextAnchor142"><em class="italic"><span class="koboSpan" id="kobo.16.1">Chapter 6</span></em></a><em class="italic"><span class="koboSpan" id="kobo.17.1">, End-to-End Testing the BookSwap Web Application</span></em></li>
<li><a href="B18371_07.xhtml#_idTextAnchor162"><em class="italic"><span class="koboSpan" id="kobo.18.1">Chapter 7</span></em></a><em class="italic"><span class="koboSpan" id="kobo.19.1">, Refactoring in Go</span></em></li>
<li><a href="B18371_08.xhtml#_idTextAnchor179"><em class="italic"><span class="koboSpan" id="kobo.20.1">Chapter 8</span></em></a><em class="italic"><span class="koboSpan" id="kobo.21.1">, Testing Microservice Architectures</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer044">
</div>
</div>
</body></html>