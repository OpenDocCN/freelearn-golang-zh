- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Efficient Test Suites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to supplement the functionality of Go’s
    `testing` package with third-party libraries. These libraries make it easier to
    mock the dependencies of the **Unit Under Test** (**UUT**) and create assertions
    in these tests. Mocks are essential building blocks to being able to easily write
    test code for well-designed implementation code, according to the **SOLID** design
    principles.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, developers identify edge cases of their requirements and implementations,
    ensuring a good **code coverage** percentage, which we discussed in [*Chapter
    2*](B18371_02.xhtml#_idTextAnchor035), *Unit Testing Essentials*. In this chapter,
    we will learn how to create test suites.
  prefs: []
  type: TYPE_NORMAL
- en: One popular technique for constructing test suites in Go is **table-driven testing**.
    We will learn how to build tables that cover edge cases and exercise the UUT with
    a variety of inputs, ensuring that the UUT has a stable implementation. We will
    also leverage some of the techniques we’ve explored so far, such as test setup,
    subtests, and mocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most popular usages of Go is to build web applications, and in this
    chapter, we will explore how to build and test just that. We will move on from
    the simple calculator example that we have looked at so far and look at a new
    use case: the `BookSwap` application. This service will allow users to create
    book listings they wish to swap, allowing others to borrow them.'
  prefs: []
  type: TYPE_NORMAL
- en: This example will involve building a REST API with Go’s `net/http` package and
    learning how to test it. It is particularly important to cover edge cases when
    dealing with user input, so we will test the `BookSwap` API using the techniques
    covered so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What edge cases are and how to identify them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to test web applications and APIs, which may rely on external services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The popular Go testing technique of table-driven testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `BookSwap` use case application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need to have **Go version 1.19** or later installed to run the code
    samples in this chapter. The installation process is described in the official
    Go documentation at [https://go.dev/doc/install](https://go.dev/doc/install).
  prefs: []
  type: TYPE_NORMAL
- en: The code examples included in this book are publicly available at [https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter04](https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: Testing multiple conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have covered how to structure and write tests. However, developers
    need to know *what* aspects of their code to test, as well as *how* to test them.
    Remember that the lower we go on the **testing pyramid**, the cheaper and faster
    the tests are to run. Therefore, it is important for developers to know how to
    exercise their code as low in their stack as possible. In this chapter, we’ll
    focus on covering edge cases as part of our developer **testing strategy**.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in [*Chapter 1*](B18371_01.xhtml#_idTextAnchor015), *Getting to
    Grips with Test-Driven Development*, automated tests should be based on the system
    requirements we implement. In general, system requirements will focus on the specification
    of the success scenarios and system functionality additions. Designing your testing
    strategy around these requirements serves the primary purpose of ensuring that
    your system satisfies its functional requirements.
  prefs: []
  type: TYPE_NORMAL
- en: A secondary purpose of your testing strategy should be to verify the behavior
    and robustness of your system-under-failure cases, such as incorrect/unexpected
    input, transient errors, or slow responses. Developers need to ensure that their
    systems are able to gracefully handle all sorts of operating conditions.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn how to identify these conditions and apply the testing techniques
    we’ve learned so far to devise testing strategies that give us confidence in our
    solutions, regardless of the inputs and the conditions our system operates in.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4**.1* shows the dual nature of testing, comprising positive and negative
    tests, to ensure that both functionality and error handling is correctly implemented
    in our systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The two types of tests ](img/Figure_4.01_B18371.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – The two types of tests
  prefs: []
  type: TYPE_NORMAL
- en: 'The two types of tests are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Positive tests**, which use valid input for the UUT and verify that the expected
    result is returned from the UUT. This type of test ensures that the application
    behaves correctly according to the functional requirements. Positive tests cover
    the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the UUT handles valid input
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How the UUT behaves in expected scenarios
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How the UUT satisfies system requirements
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Negative tests**, which use invalid input for the UUT and verify that an
    error is returned from the UUT. This type of test ensures that the application
    can gracefully handle invalid input, with meaningful errors and avoiding crashes.
    Negative tests cover the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the UUT handles invalid input
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How the UUT behaves in unexpected scenarios
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How the UUT behaves outside of system requirements
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these tests is comprised of different types of test scenarios of varying
    complexity, based on the values of input variables and their combinations.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of negative tests
  prefs: []
  type: TYPE_NORMAL
- en: Both positive and negative tests are equally important for production systems.
    Error handling is an important part of the user journey. We want users to receive
    meaningful messages in the case of errors, as well as recover successfully in
    the case of slowdowns or outages.
  prefs: []
  type: TYPE_NORMAL
- en: '**Happy path testing** or **happy flow testing** is the verification of the
    default success scenario without any errors or exceptions. Covering the default
    and requirement-specific scenarios ensures that the system behaves well in ideal
    scenarios. However, as developers, we need to know more than the ideal behavior
    of our systems.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4**.2* depicts the different types of test cases for a given input
    parameter of our system. The different types of test cases cover the entire range
    of possible input parameter values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – The types of test cases of a given input variable ](img/Figure_4.02_B18371.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – The types of test cases of a given input variable
  prefs: []
  type: TYPE_NORMAL
- en: 'A good testing strategy should cover the following four major types of test
    cases of a given input variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Base cases** occur at the expected values of an operating parameter. For
    example, given an input parameter representing a name, a base case for it would
    be a short valid string value. These cases are often defined in the system requirements
    and make up the scenarios of the happy path testing strategy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edge cases** occur at the extreme of an operating parameter. For example,
    given a string input parameter, some edge cases for it would be an empty string
    value, a multiline string, or a string with special characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Boundary cases** occur on either side of an edge case, approaching the extreme
    values of an operating parameter. These cases are particularly important for asserting
    values that must have a particular value. For example, given a numeric input parameter
    representing temperature for a water temperature measurement application, we could
    boundary-test its values around the water freezing point and water boiling point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As demonstrated by these examples, edge cases are often based on the data type
    of the input/user parameter, as well as their purpose. We will explore other types
    of parameters and how to identify their extreme/edge-case values in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Systems will often operate on multiple input variables. The combinations of
    input variables and their edge cases can result in different system behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4**.3* demonstrates the final type of test case, which tests the particular
    scenario of multiple edge cases of input variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Corner cases ](img/Figure_4.03_B18371.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Corner cases
  prefs: []
  type: TYPE_NORMAL
- en: '**Corner cases** occur at extremes or edge cases of multiple operating parameters.
    Any combination of edge cases between the two types of input variables would result
    in a corner case. For example, given multiple string input parameters, we would
    achieve a corner case by a combination of any of the edge cases of these parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4**.4* demonstrates the test case combinations of two input variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Combining two input variables in a testing strategy ](img/Figure_4.04_B18371.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Combining two input variables in a testing strategy
  prefs: []
  type: TYPE_NORMAL
- en: As the number of input parameters of our system increases, the number of combinations
    of edge cases increases, resulting in a large number of corner cases that must
    be tested. In order to minimize test writing and maintenance efforts, it’s important
    to identify the subset of user-accessible scenarios from the entirety of possible
    test scenarios. These should be prioritized in the testing strategy, and testing
    can then be extended as the project becomes more mature.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between edge and corner cases
  prefs: []
  type: TYPE_NORMAL
- en: The terms *edge case* and *corner case* are often used interchangeably. One
    easy way to remember the difference is that an edge case pushes the extremes of
    a parameter, while a corner case combines these extremes by pushing the user to
    a corner configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying edge cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no particular well-defined procedure for identifying edge cases for
    variables and algorithms. This is where the experience of software testers and
    engineers makes a big difference, as they can intuitively identify edge cases
    of code and requirements upon inspection. We can, however, make some recommendations
    of what to watch out for.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4**.5* demonstrates special cases based on the variable type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Special cases of different variable types ](img/Figure_4.05_B18371.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Special cases of different variable types
  prefs: []
  type: TYPE_NORMAL
- en: 'The special cases of variable types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'String-type variables have the following special cases:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An empty or zero character string—`""`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A long string, which exceeds the expected length of the base-case valid string—`"a
    very very very very` `long string"`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A string containing special characters, including Unicode characters and special
    accent characters—`"a $``p€¢iał string!"`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A multiline string containing new line delimiters—`"a multi \n line string"`.
    Remember that Go allows the definition of raw string literals by the use of backticks,
    which can also contain other special characters.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Numeric-type variables have the following special cases:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A zero value—`0`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The minimum and maximum values are according to the numeric type. For example,
    the `int8` type has a minimum value of `–128` and a maximum value of `127`, while
    the `uint8` type has a minimum value of `0` and a maximum value of `255`. These
    values increase according to the memory allocation of the given type.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Positive and negative numeric values may also require special handling, according
    to the logic of the UUT.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Custom `struct` types have the following special cases:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The zero value of the custom struct, with no initialization—`a :=` `MyType{}`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The nil value of the type, if passed by a pointer—`var` `a *MyType`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Combinations of initialized and uninitialized fields of the given type—`a :=
    MyType{ field1: "Value"}`. Testing these combinations can reveal whether any fields
    should be added to initialization/constructor functions. While Go does not provide
    default implementations of constructors, it is common to declare package - scoped
    functions that initialize an instance and return it—`func NewMyType(v` `string)
    *MyType`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Collection types wrap around Go’s in-built collection types—arrays, slices,
    and maps:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero-element or empty collection—`c := []``int{}`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: One-element or single-element collection—`c := []``int{0}`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Nil value or collection with no allocated memory—`var` `c []int`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Duplicate elements—`c := []``int{0, 0}`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Collection with a large number of elements—`var` `c [999]int`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The special cases of each variable type should inform your decision as to which
    edge cases you should attempt to cover, but you should extend your edge cases
    to cover the boundaries of any system requirements and edge cases.
  prefs: []
  type: TYPE_NORMAL
- en: When formulating your test cases, you should break down the UUT into small logical
    blocks, identify their inputs and their edge cases, then construct your test suites
    to verify these cases accordingly. We will learn how to easily write test suites
    using table-driven testing later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: External services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we understand how to identify the edge cases of input parameters based
    on their type and system requirements, we can now turn our attention to testing
    with external services. As discussed in [*Chapter 3*](B18371_03.xhtml#_idTextAnchor061),
    *Mocking and Assertion Frameworks*, any direct dependencies of the UUT should
    be mocked, allowing us to test the UUT in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the Go package provides us with an easy way to build small, self-contained
    APIs, we can treat all dependencies as external services. These dependencies can
    be divided into two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Internal system dependencies** are located inside the system we are testing,
    whether inside the same service or not. We have full control of these dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**External system dependencies** are located outside the system we are testing,
    providing extra functionality such as a database or third-party functionality.
    We do not have full control of these dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always mock external system dependencies
  prefs: []
  type: TYPE_NORMAL
- en: As we do not control system dependencies, testing against their live/real versions
    could introduce brittleness and extra costs to our test suites. With the exception
    of databases, you should always mock your external system dependencies. We will
    explore database testing further in [*Chapter 5*](B18371_05.xhtml#_idTextAnchor124),
    *Performing* *Integration Testing*.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to edge cases of external system dependencies, these APIs will
    most often connect with our system using some kind of network connection. Their
    edge cases are heavily influenced by this connection.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4**.6* depicts the possible errors that can happen in the integration
    between the UUT and the external service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Possible errors in communication between the UUT and external
    service ](img/Figure_4.06_B18371.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Possible errors in communication between the UUT and external service
  prefs: []
  type: TYPE_NORMAL
- en: 'When each part of the exchange is happening over a network, both the request
    and response need to be tolerant of delays and retries:'
  prefs: []
  type: TYPE_NORMAL
- en: The external service may error out and respond with an internal service error.
    In this case, the UUT will need to handle a full outage and serve a default response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The request may take a long time to be delivered to the external service. In
    this case, the UUT will need to wait for the response for a pre-defined amount
    of time and then consider the request failed. The UUT may then decide to retry
    this request to fetch any resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The response from the external service may not arrive at all. In this case,
    the UUT will need to retry the whole request cycle and handle this duplicate flow
    in the application logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Errors are an inevitable part of writing code and running applications, especially
    those relying on external services for their functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Modern systems will rely on many types of external APIs, which can communicate
    over REST APIs, RPC calls, or even asynchronously through event buses. The testing
    concerns of these integrations are similar, as the communication between the UUT
    and the external service will be the most error-prone part of the integration.
  prefs: []
  type: TYPE_NORMAL
- en: Idempotence as design
  prefs: []
  type: TYPE_NORMAL
- en: In API design, idempotent operations can be called repeatedly without changing
    the initial result. It is considered good practice to design all operations as
    idempotent to ensure that operations can be retried in the case of error recovery.
  prefs: []
  type: TYPE_NORMAL
- en: Error-handling refresher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up until now, we’ve discussed how to identify possible edge cases and write
    tests for them, but resilience and error handling begins with the implementation
    of the UUT. This is especially true for Go developers, where the language design
    requires the explicit handling of error cases. Let us supplement our discussion
    of edge case identification and error case testing with a brief summary of error
    handling in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling plays a vital role in writing Go code. The Go team has opted
    for explicit error handling with the built-in `error` type, in order to avoid
    exceptions and `try-catch-finally` style blocks, which can cause brittle and error-prone
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `error` type is a simple interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This interface also makes it easy for us to create our own custom error types,
    which just need to implement the `Error() string` method. Errors are returned
    just as any other value, most commonly using **multiple return values**, and they
    are handled just like any other return value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we’ve already seen the `Parser` calculator return an error, in
    the case of an invalid mathematical expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The zero value of the error type is `nil`. Most commonly, a `nil` error value
    will signal that no issues have occurred during execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is common practice to handle errors first in the code by calling the possibly
    failing expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we initialize the `err` variable at the same time as the call
    to the erroring function, limiting the scope of the variable to the `if` statement
    block.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we check for the presence of an error, not its absence. In the case
    of `err != nil`, we simply kill the application with a call to the `log.Fatal`
    function. This is the typical way we handle errors in Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Handling errors explicitly with the `error` type has the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Guarantees that error cases are handled, avoiding any later panics or nil
    pointers**: Handling errors first, at the top of the function code, reduces checks
    for valid data later on in the function code. This can help simplify code execution
    flow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Makes it easy to see which error scenarios we need to cover in our testing
    strategy**: The function signature will show which methods and functions can produce
    errors, forcing calling code to handle them explicitly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error` type gives all Go codebases a unified way of representing error states,
    which makes it easy to construct and return user-facing errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, some developers find the error-checking code blocks repetitive and
    verbose. A common criticism is that they need to handle all errors, even those
    that are relatively unlikely to happen. Error return values may be disregarded
    by using the `_` operator) or not assigning the return value to any variable,
    but this is commonly discouraged.
  prefs: []
  type: TYPE_NORMAL
- en: You can make your own opinions on Go’s explicit error handling, but we will
    use it throughout this book as it is a convention and standard practice for how
    we write Go.
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors first but returning them as the last parameter
  prefs: []
  type: TYPE_NORMAL
- en: In a function with multiple return values, remember that the error type is typically
    the last return value. You should then handle the error case first, returning
    in the case of abnormal scenarios, and keeping your code minimally indented.
  prefs: []
  type: TYPE_NORMAL
- en: Table-driven testing in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have discussed the fundamentals of identifying edge cases and handling
    errors, we can begin to look at how to build test suites that cover a variety
    of scenarios. A popular technique in Go is to use **table-driven testing**. This
    technique uses the fundamentals we’ve learned so far to structure test suites
    that cover a variety of scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us begin with a simple example to demonstrate the test-writing process.
    We will implement a new `Divide` mathematical operation that does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the result formatted as a string to two decimal points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns an error in the case that the divisor is 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From the preceding requirement, we can formulate the following signature for
    this new operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We remember that the minimum value of `int8` is `–128` and the maximum value
    is `127`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As previously discussed, we make use of multiple return values to encourage
    explicit error handling in the calling code. Based on the functionality requirements
    and the lessons learned from the previous *Identifying edge cases* section, we
    can identify the following test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x` and `y`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two negative values for `x` and `y`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x` and `y`*   Maximum value for `x` and positive value for `y`*   Minimum
    value for `x` and positive value for `y`*   A zero value of `x` and a nonzero
    value for `y`*   A positive value of `x` and a zero value for `y`*   `x` and `y`*   Maximum
    values for `x` and `y`*   Minimum values for `x` and `y`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [*Chapter 2*](B18371_02.xhtml#_idTextAnchor035), *Unit Testing Essentials*,
    we saw how to write tests and implement different scenarios with subtests. This
    involves declaring a shared test setup and declaring a subtest for each case.
    For example, the implementation of the first test case could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the highlighted lines in this code snippet, the following
    components are the ones that change according to the test case we are running:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the test case, which will make our test output easy to read
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The inputs that will change values according to the test case we are running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expected result value and error value according to the test case we are
    running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As can be seen from the previous snippet, there is quite a bit of boilerplate
    code that can be reused across test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: The declaration of the test function and any required UUT setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The declaration of the subtest and its nested testing function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The invocation of the `Divide` function with its input values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the interaction with the `*testing.T` object is the most verbose part of
    the test implementation, a shorter and simpler alternative to test cases is to
    use table-driven tests, which we will learn all about in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing table-driven tests has a very simple recipe. We will use the example
    of the `Divide` function from the previous section to demonstrate each step.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – declaring the function signature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We begin by declaring the function signature that we have presented previously
    and writing only enough code to make the code compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The signature of the function returns a pointer to a string and an error. In
    practice, we expect only one of the two values to ever be `nil`:'
  prefs: []
  type: TYPE_NORMAL
- en: In the normal flow, the result string will be non-nil, and the error value will
    be nil
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the abnormal flow, the result string will be nil, and the error value will
    be non-nil
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, by setting both values to nil, we will guarantee that there will
    be no accidentally passing test cases. This helps us begin the red phase of the
    **red-green-refactor** **test-driven development** (**TDD**) process.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – declaring a structure for our test case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step of writing test code is to declare a custom type to wrap around
    our test case. The purpose of this structure is to hold the inputs and expected
    outputs of the test case. Generally, this type is declared inside the scope of
    the function test, but it can also be shared across tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test case of our `Divide` function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This custom type is a simple `struct` type that wraps around `x` and `y`—the
    two inputs of the function and the two expected results of the function—the formatted
    result and the possible returned error. Note that in Go it is customary to name
    the expected result as `want` or with the `want` prefix. This is different from
    other languages, where the naming convention begins with the word `expected`.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – creating our test-case collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a way to express our test cases, we can begin to create a
    collection of all the cases we want to test for our function. Based on the two
    base cases that we identified for the `Divide` function in the previous section,
    we can create the following `tests` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We prefer to use `map` to add a corresponding name to the test case, which allows
    us to add the name as a key and the test case as a value. An alternative solution
    is to use a slice and save the name of the test case as a field in the `testCase`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we don’t provide a value to the `wantErr` field in the previous test
    case, as the base cases do not require the verification of errors. The zero value
    of the error type is `nil`, so not setting a value for it will be equivalent to
    declaring a happy path test case.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can further optimize our implementation of the `tests` map by using anonymous
    `struct` types for our `testCase` type to reduce boilerplate and keep the scope
    of the `testCase` type small:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This can further shorten the test declaration but will not allow us to share
    the `testCase` type between tests.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 – executing each test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With our table of tests in place, we will execute each test case as a subtest.
    We will use the `range` statement to loop through the map of tests, which will
    return the name of the test case and the test case instance itself. Then, we pass
    the test name as the subtest name and use the test case during the test setup
    and execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This step allows us to set up the interaction with the test runner in one single
    block for the entire test suite. Remember that each subtest is its own function,
    so we can individually fail tests or stop the execution of the entire test suite
    using the `testing.T` helpers that we have explored in [*Chapter 2*](B18371_02.xhtml#_idTextAnchor035),
    *Unit* *Testing Essentials*.
  prefs: []
  type: TYPE_NORMAL
- en: Step 5 – implementing the test assertions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we have set up the `tests` map and its interaction with the test runner,
    we can begin to implement the testing logic based on the inputs and outputs defined
    in the `testCase` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Based on the `tc` test case value retrieved from the `tests` map, we use its
    values of `x` and `y` to invoke the `Divide` function. Then, we verify the error
    value and the result value from the `tc` test case as well. Note that, just as
    we do with error handling, we verify the error value first and return from the
    test in the case of the error case.
  prefs: []
  type: TYPE_NORMAL
- en: Step 6 – running the failing test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our table-driven test suite has successfully been implemented in five easy
    steps! The basics of running tests and assertions are in place, so we can now
    run the tests and see them fail. We can now run the test with the `go test` command,
    as we have done so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the output, all the tests are run in their own subtest with
    the given scenario name passed to the test runner. The `–v` flag is the `verbose`
    flag, which will show the full output of all the tests that are run.
  prefs: []
  type: TYPE_NORMAL
- en: Step 7 – implementing the base cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now begin to implement the `Divide` function happy path cases. We will write
    two simple lines of code that will allow the tests of the base cases to pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'These two lines of code will handle the normal program flow. We then rerun
    the base case tests that we have written so far and see them pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Once these tests pass, we enter the green phase of the red-green-refactor TDD
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Step 8 – expanding the test case collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the base case tests passing, it’s time to expand our test case collection
    to include error cases. Based on the 10 test cases that we identified for the
    `Divide` function in the previous section, we can add the following cases to the
    `tests` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In practice, we would expand each of the edge and corner cases one at a time,
    ensuring that each of them passes. However, we will add them all in one step,
    for the purpose of brevity.
  prefs: []
  type: TYPE_NORMAL
- en: Step 9 – expanding functional code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As expected, the new error edge cases will fail when run with the typical `go
    test` command, prompting us to implement functional code. We expand our `Divide`
    function to handle the error case described in the user requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As usual, the error case is handled at the top of the function, keeping the
    code minimally indented. Note that we initialize an error using the `errors.New`
    function, which takes in a message. We can initialize errors in other ways as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step is to run our fully implemented table-driven test suite using
    the `go` `test` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the output, all the tests are run successfully in their own
    subtest, with the given scenario name passed to the test runner. Our first table-driven
    test suite has been successfully implemented. This is a common testing technique
    that you will often use when you write Go code, so it’s important to master its
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Parallelization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, all the tests in each package will be run sequentially, but tests
    from multiple packages will run in parallel. As the number of tests increases,
    the sequential test execution time of a given package can increase as well.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4**.7* demonstrates the behavior of sequential and parallel test runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Sequential versus parallel test runs ](img/Figure_4.07_B18371.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Sequential versus parallel test runs
  prefs: []
  type: TYPE_NORMAL
- en: 'The test run life cycle is set out here:'
  prefs: []
  type: TYPE_NORMAL
- en: The tests begin running. Tests in different packages run in parallel—tests in
    `package A` can run at the same time as tests in `package B`. This allows us to
    reduce running time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, test cases in the same package run sequentially. This is demonstrated
    by the tests in `package A`—`TestCase 1` needs to complete before `TestCase 2`
    can run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test cases in the same package can be configured to run in parallel. This
    is demonstrated by the tests in `package B`—`TestCase 1` can run concurrently
    with `TestCase 2`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of tests that we can run in parallel is limited by the resources
    available to the test runner, but parallelizing test runs is a great way to reduce
    the test run time, which can further reduce the feedback cycle of CI/CD pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: The `*testing.T` type provides the `t.Parallel()` method, which allows us to
    specify which tests can be run in parallel with other parallel marked tests from
    the same package. As the subtests of our table-driven test run independently,
    we need to mark each as parallel and not just the top-level test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ability to mark certain tests for parallelization is particularly useful
    together with table-driven tests, which contain independently running test cases.
    We can easily adjust our table-driven tests to run in parallel with two short
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We assign the current test case to a local `tc` variable to capture the test
    case range variable. This is required as the subtest will now run in a goroutine
    under the hood. We need to create a copy of the current value of the test case
    to the subtest closure, as opposed to the changing range return value.
  prefs: []
  type: TYPE_NORMAL
- en: The second change we have made is to add the call to `t.Parallel()` in the subtest,
    marking each of the subtests as allowed to be run in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the number of binaries that can run in parallel is equal to the
    number of CPUs. This variable can be overridden by the `–parallel` flag, available
    on the `go` `test` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our table-driven tests marked as parallel, we can run our tests again
    using `go test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the test run has been shortened. As we can see from the interleaving
    output, the tests are now running in parallel, in an interleaving manner: run,
    pause, and continue.'
  prefs: []
  type: TYPE_NORMAL
- en: Advantages and disadvantages of table-driven testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This brings us to the end of our exploration of table-driven testing. Let us
    conclude with a short discussion of its advantages and disadvantages. Table-driven
    tests are best suited to scenarios that cover a variety of test cases with different
    inputs and outputs.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Table-driven tests have the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide a concise way to define and run multiple test cases, which reduces boilerplate
    code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to add and remove new tests by simply modifying the collection of test
    cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As all of the test cases are run using the same surrounding code, we can easily
    refactor the test setup and assertion code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are some disadvantages of table-driven tests:'
  prefs: []
  type: TYPE_NORMAL
- en: As all the test cases are run identically, it may be difficult to create even
    small variations of the test setup and assertion code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Table-driven tests are not suitable for test cases that require different test
    setup and teardown logic. They also make it difficult to use mocks, which must
    behave differently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some developers argue that table-driven tests are difficult to read. While the
    name of the test case allows us to name each test, the code is not readable, especially
    when compared to the **behavior-driven development** (**BDD**) style of writing
    tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When implemented correctly, table-driven tests are a great way to test your
    code across a variety of scenarios and edge cases. They help us create a uniform
    way of running tests, which also makes it easy to maintain and refactor test code.
    Many developers advocate implementing your tests as table-driven tests from the
    very beginning, even if you don’t have many test cases when you get started. As
    your code matures, you will have an easy way to add new test cases.
  prefs: []
  type: TYPE_NORMAL
- en: If you have large variations in test setup, you can use different tests and
    dedicated subtests to group your tests.
  prefs: []
  type: TYPE_NORMAL
- en: Use case – the BookSwap application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most popular use cases of Go is for building web applications. Therefore,
    it is important to know how to build and test web applications. We will learn
    how to build our first use case web application: the `BookSwap` application. We
    will explore and test the `BookSwap` application in this and the following chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: This simple application allows users to sign up and register which books they
    have available. Other users can sign up for the application and view other users’
    available books. They can then request to borrow a book from another user. The
    `BookSwap` application then generates an order and sends it to the posting service
    for wrapping and shipping.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4**.8* depicts an overview of the `BookSwap` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Overview of the book swap web application ](img/Figure_4.08_B18371.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – Overview of the book swap web application
  prefs: []
  type: TYPE_NORMAL
- en: 'The `BookSwap` web application has some simple components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The user interacts with the `UserService` service endpoints. It exposes a few
    simple endpoints that provide all the functionality the application requires:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /` returns a welcome message and all the book listings available in the
    application. This endpoint will serve as the application home page, which will
    show all the available books that users can swap. For completion, the `GET /books`
    endpoint will also return a list of available books.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST /users` creates a new user. The user will receive a unique `userID` value,
    which they will need to remember for further interactions. For the sake of simplicity,
    we will not handle user authentication or any security concerns.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /users/{id}` returns the book listings of the given user. This endpoint
    will serve as the profile page of a given user.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `UserService` service relies on the `BookService`. It manages the details
    and statuses of all the books available in the `BookSwap` web application. It
    exposes the following endpoints:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST /books` creates a new book listing on the `BookSwap` service. This request
    will take the details of the book to create a JSON request body.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST /books/{id}?user={userId}` creates a new request for a particular book
    and given user. This will create a request to send the given book to a new user.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BookService` has a dependency on the external posting service, which handles
    the creation of mail stamps and issues a request for packaging. Once `PostingService`
    has handled the order request, we can mark the book as swapped and update its
    `ownerID` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can explore the full implementation of the `BookSwap` application on our
    GitHub repository. The application is implemented using the `net/http` package
    in the standard library. We will explore some relevant parts of the `BookSwap`
    web application in this chapter, which showcase what we have learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Testing BookService
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will represent books as a very simple data type that uses JSON tags to format
    its contents for display on REST APIs, which serve JSON data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: While REST APIs don’t have to operate on JSON data, the `application/json` data
    format is the most used. The book has `OwnerID` and `Status`, which shows whether
    the book is available for swaps.
  prefs: []
  type: TYPE_NORMAL
- en: '`BookService` is a very simple service that manages books. It will need to
    be able to retrieve and manage books with six simple methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `NewBookService` method initializes `BookService` with a given list of books
    and a `PostingService` service. The `Get` method attempts to find a book for a
    given ID, returning an error if not found. The `Upsert` method creates a new book
    entry or updates the entry if the given ID is already found. The `List` operation
    returns all the books that are available for loan. `ListByUser` filters all books
    for a given owner, allowing us to power the home page of a given user. `SwapBook`
    is a function that wraps around availability, checking and updating the owner
    ID of a given book in case of a swap request.
  prefs: []
  type: TYPE_NORMAL
- en: '`BookService` will save the book entries on a map with their ID as the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The map will facilitate lookup operations, which will be required for the `BookSwap`
    application. The `Get` and `List` operations are expected to be the most popular,
    as they will appear on the homepage and profile pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us have a look at how we can formulate the table-driven tests for the `Get`
    operation of the `BookService`. We declare a test with two corresponding subtests—one
    for an initial amount of books and one for an empty book map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We use two different subtests for the two cases, as they require two different
    test setups. As we have discussed, table-driven tests are not suitable for scenarios
    that require different setup conditions. We begin by creating a sample book and
    creating a new `BookService` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This starting point will be shared by all test cases in this subtest. Note
    that we pass a `nil` value as the `PostingService` service, as it will not be
    tested by these tests. Then, we implement a table-driven test with three scenarios
    in the first subtest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The three cases consist of finding an existing book, looking for a book that
    is not found in `BookService`, and looking for an empty ID. Then, we loop through
    the test cases and run the assertions according to the inputs and expectations
    of the test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Just as we did in the *Table-driven testing in action* section, we loop through
    the map of test cases and handle the error cases first. Remember to verify all
    the wanted return values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second subtest, named `"empty books"`, we have run a single test and
    performed the required verifications on a different UUT instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We could have potentially implemented table-driven tests for the second subtest
    as well, but we have opted to include a single test here to keep the code snippets
    concise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we run our tests using the `go test` command to ensure that they are
    passing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that the output shows the nesting of the two different subtests. This allows
    us to build detailed test hierarchies. We will continue to explore and test other
    parts of the `BookSwap` application in the next few chapters, so there will be
    plenty of time to explore it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we explored how to identify edge cases and write test suites
    that cover multiple conditions. We began with how to identify edge cases for systems
    with input parameters and external services, revising Go’s approach to explicit
    error handling. Then, we learned how to implement table-driven testing. This popular
    technique allows us to test multiple scenarios with a minimal amount of boilerplate
    code. It also allows running test cases in parallel, enabling us to make optimizations
    for the running of test cases as well. Finally, we introduced our new use case—the
    BookSwap web application. This example application will be the focus of the next
    few chapters, where we will learn how to test one of Go’s most popular use cases:
    building web applications.'
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B18371_05.xhtml#_idTextAnchor124), *Performing Integration
    Testing*, we will begin to consider how to use TDD for testing **end-to-end**
    (**E2E**) applications, including database testing. We will also learn how to
    use Docker for identical application setup and easy teardown.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 10*](B18371_10.xhtml#_idTextAnchor218), *Testing Edge Cases*, we
    will explore other testing techniques, such as fuzz testing and property-driven
    testing, which can make edge case verification even easier.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is an edge case? What is a corner case?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an idempotent operation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain Go’s explicit error handling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is table-driven testing? What are some of its advantages?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does Go parallelize test runs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Building Microservices Second edition: Designing Fine-Grained Systems*, *Sam
    Newman*, published by *O’Reilly*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Error handling and Go on the Go blog*. Available at [https://go.dev/blog/error-handling-and-go](https://go.dev/blog/error-handling-and-go).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 2: Integration and End-to-End Testing with TDD'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the fundamentals of TDD and Go testing in place, this part moves our focus
    beyond testing components in isolation. We explore the importance of integration
    testing and learn how to write tests using `httptest` and `ginkgo` to test the
    `BookSwap` web application. Then, we extend the functionality of the application
    by adding a database and containerizing it using Docker, which allows us to create
    identical test setups. Once the application is extended into a monolithic application,
    we use `GoDog` to implement end-to-end testing using BDD-style features. However,
    refactoring is an integral part of the development process, often applied to splitting
    monolithic applications to microservice architectures. We examine testing microservice
    integrations using contract testing, implemented using the Pact open-source testing
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18371_05.xhtml#_idTextAnchor124)*, Performing Integration Testing*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B18371_06.xhtml#_idTextAnchor142)*, End-to-End Testing the BookSwap
    Web Application*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18371_07.xhtml#_idTextAnchor162)*, Refactoring in Go*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18371_08.xhtml#_idTextAnchor179)*, Testing Microservice Architectures*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
