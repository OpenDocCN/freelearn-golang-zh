<html><head></head><body>
<div id="_idContainer053">
<h1 class="chapter-number" id="_idParaDest-104"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-105"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.2.1">Performing Integration Testing</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapters, we discussed the broader topic of writing and testing code with </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">test-driven development</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">TDD</span></strong><span class="koboSpan" id="kobo.7.1">), but have kept our implementation focus on unit tests. </span><span class="koboSpan" id="kobo.7.2">As we’ve discussed at length so far, unit tests are at the bottom of the test pyramid, being the most numerous, as they are testing all the different independent parts or units of </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">The concepts we have discussed so far have allowed us to write unit tests that test these units in isolation, across a variety of scenarios. </span><span class="koboSpan" id="kobo.9.2">In </span><a href="B18371_03.xhtml#_idTextAnchor061"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.10.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.11.1">, </span><em class="italic"><span class="koboSpan" id="kobo.12.1">Mocking and Assertion Frameworks</span></em><span class="koboSpan" id="kobo.13.1">, we learned how to make use of frameworks to easily create mocks, which allow us to instantiate units whose dependencies we have full control over. </span><span class="koboSpan" id="kobo.13.2">As discussed in </span><a href="B18371_04.xhtml#_idTextAnchor085"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.14.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.15.1">, </span><em class="italic"><span class="koboSpan" id="kobo.16.1">Building Efficient Test Suites</span></em><span class="koboSpan" id="kobo.17.1">, we learned how to make use of the popular technique of table-driven testing to easily write tests across a variety of cases, including edge and </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">corner cases.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">No matter how well we write our unit tests, they have the limitation that they only verify their limited scope. </span><span class="koboSpan" id="kobo.19.2">In other words, unit tests verify that each unit is working correctly, but not that they integrate and function correctly together. </span><span class="koboSpan" id="kobo.19.3">The integrations between units, which may be developed by different teams, can often be the cause of errors and outages, so it is important to verify that they behave as expected, independently </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">and together.</span></span></p>
<p><span class="koboSpan" id="kobo.21.1">We will now turn our attention to implementing integration testing suites, which will give us the confidence that the functionality that matters will work as intended when multiple units work together. </span><span class="koboSpan" id="kobo.21.2">We will explore how to containerize our applications, ensuring that our tests mimic our production environments and perform as expected. </span></p>
<p><span class="koboSpan" id="kobo.22.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.24.1">The limitations of </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">unit testing</span></span></li>
<li><span class="koboSpan" id="kobo.26.1">The implementation of integration tests </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">in Go</span></span></li>
<li><span class="koboSpan" id="kobo.28.1">Introduction to behavior-driven </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">test writing</span></span></li>
<li><span class="koboSpan" id="kobo.30.1">The importance of </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">database testing</span></span></li>
<li><span class="koboSpan" id="kobo.32.1">Containerization </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">with Docker</span></span></li>
</ul>
<h1 id="_idParaDest-106"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.34.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.35.1">You will need to have </span><strong class="bold"><span class="koboSpan" id="kobo.36.1">Go version 1.19</span></strong><span class="koboSpan" id="kobo.37.1"> or later installed to run the code samples in this chapter. </span><span class="koboSpan" id="kobo.37.2">The installation process is described in the official Go documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">at </span></span><a href="https://go.dev/doc/install"><span class="No-Break"><span class="koboSpan" id="kobo.39.1">https://go.dev/doc/install</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.40.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">The code examples included in this book are publicly available </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">at </span></span><a href="https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter05"><span class="No-Break"><span class="koboSpan" id="kobo.43.1">https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter05</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.44.1">.</span></span></p>
<h1 id="_idParaDest-107"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.45.1">Supplementing unit tests with integration tests</span></h1>
<p><span class="koboSpan" id="kobo.46.1">Unit tests are </span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.47.1">small, fast tests that verify the</span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.48.1"> behavior of a single component. </span><span class="koboSpan" id="kobo.48.2">In Go, the UUT is typically the package, which exposes an API that these fast tests can verify against. </span><span class="koboSpan" id="kobo.48.3">These independent units combine to make up </span><strong class="bold"><span class="koboSpan" id="kobo.49.1">components</span></strong><span class="koboSpan" id="kobo.50.1">, which </span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.51.1">are identifiable parts of a system. </span><span class="koboSpan" id="kobo.51.2">Usually, components have well-defined responsibilities and provide a group of related functions. </span><span class="koboSpan" id="kobo.51.3">A component’s units work together to deliver the </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">component’s functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.53.1">Engineers rely heavily on unit tests in the development phase, and they are an important pillar of TDD, where the testing practice requires the testing code to be written together with the implementation code. </span><span class="koboSpan" id="kobo.53.2">However, they have some limitations that make the remaining tests of the testing pyramid essential. </span><span class="koboSpan" id="kobo.53.3">Therefore, as TDD practitioners, we cannot simply focus on unit tests. </span></p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.54.1">Limitations of unit testing</span></h2>
<p><span class="koboSpan" id="kobo.55.1">The practice of </span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.56.1">verifying functionality with unit tests has been the subject of debate in the engineering community because of its limitations. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.57.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.58.1">.1</span></em><span class="koboSpan" id="kobo.59.1"> presents a summary of their advantages </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">and disadvantages:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer045">
<span class="koboSpan" id="kobo.61.1"><img alt="Figure 5.1 – Advantages and disadvantages of unit testing " src="image/Figure_5.01_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.62.1">Figure 5.1 – Advantages and disadvantages of unit testing</span></p>
<p><span class="koboSpan" id="kobo.63.1">Here are the advantages of </span><a id="_idIndexMarker374"/><span class="No-Break"><span class="koboSpan" id="kobo.64.1">unit tests:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.65.1">Support refactoring</span></strong><span class="koboSpan" id="kobo.66.1">: Unit tests make it easier to refactor code because they provide fast verification of existing functionality. </span><span class="koboSpan" id="kobo.66.2">They decrease the risk associated with changing code, which can lead to breaking existing functionality. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.67.1">Early bug detection</span></strong><span class="koboSpan" id="kobo.68.1">: Unit tests verify the implementation at the development phase before it has been integrated with the existing product and can be tested end-to-end. </span><span class="koboSpan" id="kobo.68.2">This also ensures that bugs don’t propagate to other teams or are accidentally released. </span><span class="koboSpan" id="kobo.68.3">Early bug detection can also lead to shorter development times and reduced project costs. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.69.1">Easier debugging</span></strong><span class="koboSpan" id="kobo.70.1">: Detecting and fixing errors is easier when the tests have a limited scope. </span><span class="koboSpan" id="kobo.70.2">As the </span><strong class="bold"><span class="koboSpan" id="kobo.71.1">UUT</span></strong><span class="koboSpan" id="kobo.72.1"> is tested in isolation from its dependencies, we know that any failing tests are caused either by the test setup or the implementation of the UUT. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.73.1">Better code design</span></strong><span class="koboSpan" id="kobo.74.1">: Poorly designed code is hard to test code and can highlight to developers where their code must be rewritten or refactored. </span><span class="koboSpan" id="kobo.74.2">In practice, unit tests promote better code design because they bring the testing concerns to the </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">development phase.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.76.1">Documentation alongside implementation</span></strong><span class="koboSpan" id="kobo.77.1">: Unit tests serve as detailed documentation for the functionality and behavior of a component. </span><span class="koboSpan" id="kobo.77.2">As tests live alongside the code in Go, they give developers access to it without the use of another</span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.78.1"> documentation system. </span></li>
</ul>
<p><span class="koboSpan" id="kobo.79.1">And these are </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">the disadvantages:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.81.1">Increase the amount of code</span></strong><span class="koboSpan" id="kobo.82.1">: Unit</span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.83.1"> tests increase the code that developers must write early on. </span><span class="koboSpan" id="kobo.83.2">This is problematic for tasks that require prototyping or don’t have well-established requirements. </span><span class="koboSpan" id="kobo.83.3">Developers don’t want to write large amounts of code that then need to be changed alongside the implementation. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.84.1">Increased refactor effort</span></strong><span class="koboSpan" id="kobo.85.1">: While unit tests ensure that refactoring has not broken any existing functionality, causing regressions, the tests themselves must be refactored in the case of changes in requirements. </span><span class="koboSpan" id="kobo.85.2">This can increase the cost of refactoring efforts. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.86.1">Difficult to identify realistic scenarios</span></strong><span class="koboSpan" id="kobo.87.1">: As the codebase grows and functionality becomes more complex, it will be difficult, if not impossible, to test all the execution paths of a component. </span><span class="koboSpan" id="kobo.87.2">However, as unit tests are written based on code and not user requirements, it can be difficult for developers to identify which scenarios are realistic and should be covered. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.88.1">Difficulties testing user interfaces (UIs)</span></strong><span class="koboSpan" id="kobo.89.1">: It is difficult to test UIs with unit tests. </span><span class="koboSpan" id="kobo.89.2">Usually, they verify business logic, as they traditionally do not have libraries available for UI verification. </span></li>
</ul>
<p><span class="koboSpan" id="kobo.90.1">Integration tests are a good way to supplement unit tests, as they address some of the disadvantages and limitations of unit tests highlighted previously. </span><span class="koboSpan" id="kobo.90.2">Next, we will learn how to implement and run them for our </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">Go packages.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.92.1">Unit tests are considered good practice</span></p>
<p class="callout"><span class="koboSpan" id="kobo.93.1">While they do pose some disadvantages, the consensus in the community is that they should be used as part of development practice. </span><span class="koboSpan" id="kobo.93.2">Understanding their limitations highlights what other testing needs we need to cover for the full verification of </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">our system.</span></span></p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.95.1">Implementing integration tests</span></h2>
<p><span class="koboSpan" id="kobo.96.1">Integration tests and </span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.97.1">end-to-end tests are often used interchangeably, but they each have a scope and purpose in the testing pyramid. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.98.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.99.1">.2</span></em><span class="koboSpan" id="kobo.100.1"> depicts the testing pyramid and highlights the difference in scope and speed between integration and end-to-end tests: </span></p>
<div>
<div class="IMG---Figure" id="_idContainer046">
<span class="koboSpan" id="kobo.101.1"><img alt="Figure 5.2 – The distinction between integration and end-to-end tests " src="image/Figure_5.02_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.102.1">Figure 5.2 – The distinction between integration and end-to-end tests</span></p>
<p><span class="koboSpan" id="kobo.103.1">The difference in speed between integration and end-to-end tests is due to the functionality that </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">they cover:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.105.1">Integration tests</span></strong><span class="koboSpan" id="kobo.106.1"> cover one or multiple components, ensuring that the individual components work well as a combined entity. </span><span class="koboSpan" id="kobo.106.2">While the logic of the particular component is verified by its unit tests, the purpose of the integration test is to exercise the conditions at the seams between </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">the components.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.108.1">End-to-end tests</span></strong><span class="koboSpan" id="kobo.109.1"> replicate the</span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.110.1"> usage of the system by the user. </span><span class="koboSpan" id="kobo.110.2">They require starting up all services and dependencies of the system under test. </span><span class="koboSpan" id="kobo.110.3">Then, tests that mimic user behavior are written using helper frameworks. </span><span class="koboSpan" id="kobo.110.4">These tests verify that the system is performing correctly under </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">real-world conditions.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.112.1">So, if end-to-end tests cover more functionality than integration tests and can be automated, why should we bother to implement integration tests? </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.113.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.114.1">.3</span></em><span class="koboSpan" id="kobo.115.1"> depicts some of the </span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.116.1">drawbacks of end-to-end tests and how integration tests </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">address them:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer047">
<span class="koboSpan" id="kobo.118.1"><img alt="Figure 5.3 – Challenges of end-to-end tests " src="image/Figure_5.03_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.119.1">Figure 5.3 – Challenges of end-to-end tests</span></p>
<p><span class="koboSpan" id="kobo.120.1">All of the tests in the testing pyramid work together to address each other’s shortcomings. </span><span class="koboSpan" id="kobo.120.2">In particular, integration </span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.121.1">tests and end-to-end tests work together in unison: </span></p>
<ul>
<li><span class="koboSpan" id="kobo.122.1">Typically, end-to-end tests are performed at </span><strong class="bold"><span class="koboSpan" id="kobo.123.1">the end of the development process</span></strong><span class="koboSpan" id="kobo.124.1">, once the system is relatively stable and can be called end to end. </span><span class="koboSpan" id="kobo.124.2">On the other hand, integration tests can be performed as soon as the individual components are ready, earlier in the development cycle, thereby </span><strong class="bold"><span class="koboSpan" id="kobo.125.1">shortening the feedback loop</span></strong><span class="koboSpan" id="kobo.126.1"> and allowing developers to detect bugs earlier on in the project. </span></li>
<li><span class="koboSpan" id="kobo.127.1">As they require more setup and resources, end-to-end tests are </span><strong class="bold"><span class="koboSpan" id="kobo.128.1">slow and possibly expensive</span></strong><span class="koboSpan" id="kobo.129.1"> to run. </span><span class="koboSpan" id="kobo.129.2">Therefore, engineers might run them as releases and not individual code commits. </span><span class="koboSpan" id="kobo.129.3">On the other hand, integration tests require much less setup, so they are </span><strong class="bold"><span class="koboSpan" id="kobo.130.1">faster and cheaper to run</span></strong><span class="koboSpan" id="kobo.131.1">. </span><span class="koboSpan" id="kobo.131.2">They are often included in the code commit checks. </span></li>
<li><span class="koboSpan" id="kobo.132.1">As previously mentioned, the focus of end-to-end tests is to verify the </span><strong class="bold"><span class="koboSpan" id="kobo.133.1">test user flow and experience</span></strong><span class="koboSpan" id="kobo.134.1"> in real-world scenarios. </span><span class="koboSpan" id="kobo.134.2">On the other hand, integration tests focus on </span><strong class="bold"><span class="koboSpan" id="kobo.135.1">integration with external and internal modules</span></strong><span class="koboSpan" id="kobo.136.1"> in a variety of scenarios, such as negative testing and partial outages. </span><span class="koboSpan" id="kobo.136.2">These can be difficult to set up in end-to-end tests, which require the entire system to </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">be configured.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.138.1">Integration tests are implemented just as unit tests</span></p>
<p class="callout"><span class="koboSpan" id="kobo.139.1">We use the same mechanisms for integration tests. </span><span class="koboSpan" id="kobo.139.2">We make use of setup functions and mocks and table tests to write tests that simply have a larger scope. </span><span class="koboSpan" id="kobo.139.3">Furthermore, integration tests have the same test signature as unit tests. </span></p>
<p><span class="koboSpan" id="kobo.140.1">The setup for integration tests is slightly more complex than unit tests, as multiple components, some of which are external, must be configured and started. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.141.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.142.1">.4 </span></em><span class="koboSpan" id="kobo.143.1">shows a typical example </span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.144.1">of the technologies and configurations we might use: </span></p>
<div>
<div class="IMG---Figure" id="_idContainer048">
<span class="koboSpan" id="kobo.145.1"><img alt="Figure 5.4 – Example configuration of integration tests " src="image/Figure_5.04_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.146.1">Figure 5.4 – Example configuration of integration tests</span></p>
<p><span class="koboSpan" id="kobo.147.1">The various parts of the integration tests that need to be configured are </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.149.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.150.1">Component under test</span></strong><span class="koboSpan" id="kobo.151.1"> part is initialized. </span><span class="koboSpan" id="kobo.151.2">The component under test is larger than the UUT, but it is still self-contained and defined within a single module. </span><span class="koboSpan" id="kobo.151.3">The scope of the integration test is to ensure multiple units work as expected, but they are always contained within the single module under test. </span></li>
<li><span class="koboSpan" id="kobo.152.1">If required, we initialize the </span><strong class="bold"><span class="koboSpan" id="kobo.153.1">Database</span></strong><span class="koboSpan" id="kobo.154.1"> component with a given seed/start position of test data contained inside it. </span><span class="koboSpan" id="kobo.154.2">As they are complex, databases are rarely mocked and will most often be started and populated before the component under test is</span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.155.1"> started. </span><span class="koboSpan" id="kobo.155.2">Database </span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.156.1">start positions are often specified as </span><strong class="bold"><span class="koboSpan" id="kobo.157.1">SQL files</span></strong><span class="koboSpan" id="kobo.158.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.159.1">JSON files</span></strong><span class="koboSpan" id="kobo.160.1">. </span></li>
<li><span class="koboSpan" id="kobo.161.1">Docker makes it easier to configure </span><strong class="bold"><span class="koboSpan" id="kobo.162.1">Real components</span></strong><span class="koboSpan" id="kobo.163.1"> together and is often used for system configuration. </span><span class="koboSpan" id="kobo.163.2">We will look at how to leverage the power of Docker later in this chapter in the </span><em class="italic"><span class="koboSpan" id="kobo.164.1">Spinning up and tearing down environments with Docker</span></em><span class="koboSpan" id="kobo.165.1"> section. </span></li>
<li><span class="koboSpan" id="kobo.166.1">Most often, the component under test will require dependencies for it to start and function correctly. </span><span class="koboSpan" id="kobo.166.2">These dependencies could be internal to the project or external dependencies to the organization, such as a third-party service. </span><span class="koboSpan" id="kobo.166.3">These external dependencies will be mocked, allowing us to test our component with a variety of inputs </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">and conditions.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.168.1">Let’s have a look at an example integration test for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">BookSwap</span></strong><span class="koboSpan" id="kobo.170.1"> application, which we introduced in </span><a href="B18371_04.xhtml#_idTextAnchor085"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.171.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.172.1">, </span><em class="italic"><span class="koboSpan" id="kobo.173.1">Building Efficient Test Suites</span></em><span class="koboSpan" id="kobo.174.1">. </span><span class="koboSpan" id="kobo.174.2">We will write an integration test for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">GET /</span></strong><span class="koboSpan" id="kobo.176.1"> endpoint that will return a welcome message and a list of available books. </span><span class="koboSpan" id="kobo.176.2">It will also allow us to explore testing </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">web applications.</span></span></p>
<p><span class="koboSpan" id="kobo.178.1">The HTTP handler that’s</span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.179.1"> registered to respond to this request is relatively simple: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.180.1">
// Handler contains the handler and all its dependencies.
</span><span class="koboSpan" id="kobo.180.2">type Handler struct {
</span><strong class="bold"><span class="koboSpan" id="kobo.181.1"> bs *db.BookService</span></strong><span class="koboSpan" id="kobo.182.1">
 us *db.UserService
}
// Index is invoked by HTTP GET /.
</span><strong class="bold"><span class="koboSpan" id="kobo.183.1">func (h *Handler) Index(w http.ResponseWriter, r *http.Request) {</span></strong><span class="koboSpan" id="kobo.184.1">
 // Send an HTTP status &amp; a hardcoded message
 resp := &amp;Response{
  Message: "Welcome to the BookSwap service!",
</span><strong class="bold"><span class="koboSpan" id="kobo.185.1">  Books:    h.bs.List(),</span></strong><span class="koboSpan" id="kobo.186.1">
 }
 writeResponse(w, http.StatusOK, resp)
}</span></pre>
<p><span class="koboSpan" id="kobo.187.1">The implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">Handler</span></strong><span class="koboSpan" id="kobo.189.1"> highlights the following implementation details: </span></p>
<ul>
<li><span class="koboSpan" id="kobo.190.1">We create a custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">Handler</span></strong><span class="koboSpan" id="kobo.192.1"> type with all its required dependencies. </span><span class="koboSpan" id="kobo.192.2">In the case of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">BookSwap</span></strong><span class="koboSpan" id="kobo.194.1"> application, we save an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">BookService</span></strong><span class="koboSpan" id="kobo.196.1"> and an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">UserService</span></strong><span class="koboSpan" id="kobo.198.1">. </span></li>
<li><span class="koboSpan" id="kobo.199.1">The handler has a method for each endpoint that it serves. </span><span class="koboSpan" id="kobo.199.2">We create a handler method that takes in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">ResponseWriter</span></strong><span class="koboSpan" id="kobo.201.1"> and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">Request</span></strong><span class="koboSpan" id="kobo.203.1">. </span><span class="koboSpan" id="kobo.203.2">This signature is typical of </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">http.HandlerFunc</span></strong><span class="koboSpan" id="kobo.205.1">, which is an adapter to allow the use of Go functions as HTTP handlers. </span></li>
<li><span class="koboSpan" id="kobo.206.1">We invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">List</span></strong><span class="koboSpan" id="kobo.208.1"> function of </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">BookService</span></strong><span class="koboSpan" id="kobo.210.1"> to fetch the list of books and construct a response. </span><span class="koboSpan" id="kobo.210.2">This custom response is then written to </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">ResponseWriter</span></strong><span class="koboSpan" id="kobo.212.1">, which allows us to easily unmarshal Go structs to HTTP responses. </span></li>
</ul>
<p><span class="koboSpan" id="kobo.213.1">The setup of our handler code is pretty straightforward and will be similar to any code you will write for HTTP </span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.214.1">responses. </span><span class="koboSpan" id="kobo.214.2">But how would we test it? </span><span class="koboSpan" id="kobo.214.3">We could unit test </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">BookService</span></strong><span class="koboSpan" id="kobo.216.1"> and ensure that it functions correctly, but we also need to test that the responses the handlers construct are as expected. </span><span class="koboSpan" id="kobo.216.2">It’s time to write our very first integration test. </span></p>
<p><span class="koboSpan" id="kobo.217.1">The Go standard library has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">httptest</span></strong><span class="koboSpan" id="kobo.219.1"> package (</span><a href="https://pkg.go.dev/net/http/httptest"><span class="koboSpan" id="kobo.220.1">https://pkg.go.dev/net/http/httptest</span></a><span class="koboSpan" id="kobo.221.1">), which allows us to easily test HTTP handlers and clients. </span><span class="koboSpan" id="kobo.221.2">This package contains the functionality for the following: </span></p>
<ul>
<li><span class="koboSpan" id="kobo.222.1">Starting servers with a specific </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">http.HandlerFunc</span></strong><span class="koboSpan" id="kobo.224.1"> with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">httptest.Server</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.226.1"> type.</span></span></li>
<li><span class="koboSpan" id="kobo.227.1">Creating incoming requests to pass to handlers with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">httptest.NewRequest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.229.1"> function.</span></span></li>
<li><span class="koboSpan" id="kobo.230.1">Recording responses with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">httptest.ResponseRecorder</span></strong><span class="koboSpan" id="kobo.232.1"> type for assertions in testing code. </span><span class="koboSpan" id="kobo.232.2">The recorder conforms to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">http.ResponseWriter</span></strong><span class="koboSpan" id="kobo.234.1"> type and can be used in its place in handler code. </span></li>
</ul>
<p><span class="koboSpan" id="kobo.235.1">A simple integration</span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.236.1"> test for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">GET /</span></strong><span class="koboSpan" id="kobo.238.1"> HTTP handler is as follows: </span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.239.1">func TestIndexIntegration(t *testing.T) {</span></strong><span class="koboSpan" id="kobo.240.1">
 // Arrange
 book := db.Book{
  ID: uuid.New().String(),
  Name: "My first integration test",
  Status: db.Available.String(),
 }
</span><strong class="bold"><span class="koboSpan" id="kobo.241.1"> bs := db.NewBookService([]db.Book{book}, nil)</span></strong><span class="koboSpan" id="kobo.242.1">
 h := handlers.NewHandler(bs, nil)
</span><strong class="bold"><span class="koboSpan" id="kobo.243.1"> svr := httptest.NewServer(http.HandlerFunc(h.Index))</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.244.1"> defer svr.Close()</span></strong><span class="koboSpan" id="kobo.245.1">
 // Act
</span><strong class="bold"><span class="koboSpan" id="kobo.246.1"> r, err := http.Get(svr.URL)</span></strong><span class="koboSpan" id="kobo.247.1">
 // Assert
 require.Nil(t, err)
</span><strong class="bold"><span class="koboSpan" id="kobo.248.1"> assert.Equal(t, http.StatusOK, r.StatusCode)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.249.1"> body, err := io.ReadAll(r.Body)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.250.1"> r.Body.Close()</span></strong><span class="koboSpan" id="kobo.251.1">
 require.Nil(t, err)
 </span><strong class="bold"><span class="koboSpan" id="kobo.252.1">var resp handlers.Response</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.253.1"> err = json.Unmarshal(body, &amp;resp)</span></strong><span class="koboSpan" id="kobo.254.1">
 require.Nil(t, err)
 assert.Equal(t, 1, len(resp.Books))
</span><strong class="bold"><span class="koboSpan" id="kobo.255.1"> assert.Contains(t, resp.Books, book)</span></strong><span class="koboSpan" id="kobo.256.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.257.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">TestIndexIntegration</span></strong><span class="koboSpan" id="kobo.259.1"> test is relatively straightforward since it does not require any complex request construction or response verification: </span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.260.1">The signature of the test is just like any other unit test. </span><span class="koboSpan" id="kobo.260.2">It starts with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">Test</span></strong><span class="koboSpan" id="kobo.262.1"> prefix and takes in a single parameter of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">*</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">testing.T</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.265.1"> type.</span></span></li>
<li><span class="koboSpan" id="kobo.266.1">Next, we create an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">BookService</span></strong><span class="koboSpan" id="kobo.268.1"> with a single book as the starting position. </span><span class="koboSpan" id="kobo.268.2">The purpose of the test is to ensure that </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">BookService</span></strong><span class="koboSpan" id="kobo.270.1"> integrates with its handler and returns responses as expected. </span></li>
<li><span class="koboSpan" id="kobo.271.1">We create a new handler with the instantiated </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">BookService</span></strong><span class="koboSpan" id="kobo.273.1">. </span><span class="koboSpan" id="kobo.273.2">Then, we pass the handler to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">httptest.NewServer</span></strong><span class="koboSpan" id="kobo.275.1"> function, which creates and starts a server instance to serve our handler. </span><span class="koboSpan" id="kobo.275.2">We defer the call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">Close</span></strong><span class="koboSpan" id="kobo.277.1"> function, as this server should be shut down at the end of the test execution. </span><span class="koboSpan" id="kobo.277.2">This concludes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">Arrange</span></strong><span class="koboSpan" id="kobo.279.1"> section of our test. </span></li>
<li><span class="koboSpan" id="kobo.280.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">Act</span></strong><span class="koboSpan" id="kobo.282.1"> section of</span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.283.1"> our test is very simple. </span><span class="koboSpan" id="kobo.283.2">We invoke the server at its URL using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">http.Get</span></strong><span class="koboSpan" id="kobo.285.1"> method. </span><span class="koboSpan" id="kobo.285.2">This is the same method that our clients will be using, and the test is not aware that it is calling a special, mocked server.  </span></li>
<li><span class="koboSpan" id="kobo.286.1">Finally, we can run assertions on our response and possible error in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">Assert</span></strong><span class="koboSpan" id="kobo.288.1"> section of our test. </span><span class="koboSpan" id="kobo.288.2">We verify that no error is returned and that the response has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">200 OK</span></strong><span class="koboSpan" id="kobo.290.1"> HTTP </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">status code.</span></span></li>
<li><span class="koboSpan" id="kobo.292.1">Then, we read the body of the response and unmarshal it into our custom response type. </span><span class="koboSpan" id="kobo.292.2">This makes it easier for us to verify the response, but we could have also verified the contents of the response body as a string. </span></li>
<li><span class="koboSpan" id="kobo.293.1">The last assertion verifies that the book instance created in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">Arrange</span></strong><span class="koboSpan" id="kobo.295.1"> section is contained in the custom response. </span><span class="koboSpan" id="kobo.295.2">The test then concludes and the deferred call to the server </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">Close</span></strong><span class="koboSpan" id="kobo.297.1"> function is run, cleaning up the server resources set up by the test. </span></li>
</ol>
<p><span class="koboSpan" id="kobo.298.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">httptest</span></strong><span class="koboSpan" id="kobo.300.1"> package allows us to seamlessly verify the behavior of HTTP handlers and integration tests </span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.301.1">using the same libraries and functions that clients will use. </span><span class="koboSpan" id="kobo.301.2">This allows us to write powerful integration tests. </span></p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.302.1">Running integration tests</span></h2>
<p><span class="koboSpan" id="kobo.303.1">Integration tests </span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.304.1">can be run just like any other unit test that we have been running so far – by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">go test</span></strong><span class="koboSpan" id="kobo.306.1"> command: </span></p>
<pre class="console"><span class="koboSpan" id="kobo.307.1">
$ go test -run TestIndexIntegration ./chapter05/handlers -v
=== RUN   TestIndexIntegration
</span><strong class="bold"><span class="koboSpan" id="kobo.308.1">--- PASS: TestIndexIntegration (1.712s)</span></strong><span class="koboSpan" id="kobo.309.1">
PASS
ok      github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter05/handlers     1.712s</span></pre>
<p><span class="koboSpan" id="kobo.310.1">The test runs successfully since it has the typical signature of a unit test. </span><span class="koboSpan" id="kobo.310.2">However, notice that this integration test takes nearly 2 seconds to run on my machine. </span><span class="koboSpan" id="kobo.310.3">This is the measurement for a particular test run, but I have registered runtimes as high as 4 seconds for just this simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">GET</span></strong><span class="koboSpan" id="kobo.312.1"> request. </span><span class="koboSpan" id="kobo.312.2">As the number of integration tests for a particular application grows, they have the potential to severely slow down our test suites, even if we run them using </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">t.Parallel()</span></strong><span class="koboSpan" id="kobo.314.1">, as we learned in </span><a href="B18371_04.xhtml#_idTextAnchor085"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.315.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.316.1">, </span><em class="italic"><span class="koboSpan" id="kobo.317.1">Building Efficient Test Suites</span></em><span class="koboSpan" id="kobo.318.1">. </span></p>
<p><span class="koboSpan" id="kobo.319.1">It would be great to separate our unit tests and much slower integration tests. </span><span class="koboSpan" id="kobo.319.2">We could then run unit tests for all commits and integration tests for code releases. </span><span class="koboSpan" id="kobo.319.3">There is no perfect, built-in way to signal to the test runner which tests are integration tests, but we can explore a </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">few options.</span></span></p>
<h3><span class="koboSpan" id="kobo.321.1">Short mode</span></h3>
<p><span class="koboSpan" id="kobo.322.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">go test</span></strong><span class="koboSpan" id="kobo.324.1"> command has</span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.325.1"> a built-in flag called </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">-short</span></strong><span class="koboSpan" id="kobo.327.1"> that we can access </span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.328.1">using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">testing.Short()</span></strong><span class="koboSpan" id="kobo.330.1"> function. </span><span class="koboSpan" id="kobo.330.2">This flag allows us to mark long-running tests for skipping by adding a short snippet to their </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">test code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.332.1">
func TestIndexIntegration(t *testing.T) {
</span><strong class="bold"><span class="koboSpan" id="kobo.333.1"> if testing.Short() {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.334.1">  t.Skip("Skipping TestIndexIntegration in short mode.")</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.335.1"> }</span></strong><span class="koboSpan" id="kobo.336.1">
 // testing code continues
} </span></pre>
<p><span class="koboSpan" id="kobo.337.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">t.Skip</span></strong><span class="koboSpan" id="kobo.339.1"> method will ensure that this long-running test will be skipped. </span><span class="koboSpan" id="kobo.339.2">We can then run the tests in short mode by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">–short</span></strong><span class="koboSpan" id="kobo.341.1"> flag to our test command: </span></p>
<pre class="console"><span class="koboSpan" id="kobo.342.1">
$ go test -run TestIndexIntegration ./chapter05/handlers -v -short
=== RUN   TestIndexIntegration
    handlers_test.go:19: Skipping TestIndexIntegration in short mode.
</span><span class="koboSpan" id="kobo.342.2">--- SKIP: TestIndexIntegration (0.00s)
PASS</span></pre>
<p><span class="koboSpan" id="kobo.343.1">As expected, the long-running test is skipped. </span></p>
<p><span class="koboSpan" id="kobo.344.1">The major downside of this approach is that it requires the user to have special knowledge to achieve a fast-running test suite, which should be the default behavior. </span><span class="koboSpan" id="kobo.344.2">There is no built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">–long</span></strong><span class="koboSpan" id="kobo.346.1"> flag that we can use to execute all (including </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">long-running) tests.</span></span></p>
<h3><span class="koboSpan" id="kobo.348.1">Naming conventions</span></h3>
<p><span class="koboSpan" id="kobo.349.1">Another option is to</span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.350.1"> use naming conventions, which would not require any special code functions to be added to any tests. </span><span class="koboSpan" id="kobo.350.2">For example, you could agree with in your team that unit tests will end with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">Unit</span></strong><span class="koboSpan" id="kobo.352.1"> suffix and integration tests with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">Integration</span></strong><span class="koboSpan" id="kobo.354.1"> suffix. </span><span class="koboSpan" id="kobo.354.2">Depending on the length and contents of the file, we could create separate integration and unit test files. </span><span class="koboSpan" id="kobo.354.3">Both unit and integration tests can use the dedicated test package, named with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">_test</span></strong><span class="koboSpan" id="kobo.356.1"> suffix, keeping the source and test code </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">dependencies separated.</span></span></p>
<p><span class="koboSpan" id="kobo.358.1">Then, we can make use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">–run</span></strong><span class="koboSpan" id="kobo.360.1"> flag, which we explored in </span><a href="B18371_02.xhtml#_idTextAnchor035"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.361.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.362.1">, </span><em class="italic"><span class="koboSpan" id="kobo.363.1">Unit Testing Essentials</span></em><span class="koboSpan" id="kobo.364.1">, to instruct the test runner to run a subset of tests based on their name. </span><span class="koboSpan" id="kobo.364.2">We run all unit tests using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">go test -run Unit ./...</span></strong><span class="koboSpan" id="kobo.366.1"> command, which will recursively traverse folders to search for any test that contains the word </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">Unit</span></strong><span class="koboSpan" id="kobo.368.1">. </span><span class="koboSpan" id="kobo.368.2">Analogously, integration tests will be run using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">go test -v -run Integration ./...</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.370.1">command.</span></span></p>
<p><span class="koboSpan" id="kobo.371.1">Unfortunately, this method suffers from the same major downside as short mode, as running the default </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">go test</span></strong><span class="koboSpan" id="kobo.373.1"> command without the </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">–run</span></strong><span class="koboSpan" id="kobo.375.1"> flag will cause all tests to run, including the</span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.376.1"> slower </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">integration tests.</span></span></p>
<h3><span class="koboSpan" id="kobo.378.1">Environment variables</span></h3>
<p><span class="koboSpan" id="kobo.379.1">The last option is to</span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.380.1"> create an environment variable to make up for the lack of a corresponding flag. </span><span class="koboSpan" id="kobo.380.2">Again, we will have to add a short code snippet to our test to verify this </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">environment variable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.382.1">
func TestIndexIntegration(t *testing.T) {
 </span><strong class="bold"><span class="koboSpan" id="kobo.383.1">if os.Getenv("LONG") == "" {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.384.1">  t.Skip("Skipping TestIndexIntegration in short mode.")</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.385.1"> }</span></strong><span class="koboSpan" id="kobo.386.1">
 // testing code continues
}</span></pre>
<p><span class="koboSpan" id="kobo.387.1">We make use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">os.Getenv</span></strong><span class="koboSpan" id="kobo.389.1"> method to read environment variables, which will return empty if the variable has not been defined. </span><span class="koboSpan" id="kobo.389.2">If this variable is empty, we skip the integration test, allowing the default behavior of our test suite to only run fast tests, skipping </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">integration tests.</span></span></p>
<p><span class="koboSpan" id="kobo.391.1">Running integration tests </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">is easy:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.393.1">
$ LONG=true go test -run TestIndexIntegration ./chapter05/handlers -v
=== RUN   TestIndexIntegration
--- PASS: TestIndexIntegration (0.00s)
PASS
ok      github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter05/handlers     0.779s</span></pre>
<p><span class="koboSpan" id="kobo.394.1">Note that this version of the command will only run on </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">CMD</span></strong><span class="koboSpan" id="kobo.396.1"> terminals. </span><span class="koboSpan" id="kobo.396.2">Alternatively, you can set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">LONG</span></strong><span class="koboSpan" id="kobo.398.1"> environment variable to '</span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">true</span></strong><span class="koboSpan" id="kobo.400.1">' in your terminal and then run the preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">go test</span></strong><span class="koboSpan" id="kobo.402.1"> command on its own after </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">setting this.</span></span></p>
<p><span class="koboSpan" id="kobo.404.1">We will make use of the environment variables solution going forward. </span><span class="koboSpan" id="kobo.404.2">The expected default behavior of the test suite is to run fast-running unit tests. </span><span class="koboSpan" id="kobo.404.3">This solution allows us to keep specialized knowledge out of the expected default behavior and makes it easy to run integration tests when required. </span><span class="koboSpan" id="kobo.404.4">It also integrates well with containerization technologies such </span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.405.1">as Docker, which we will explore later in </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">this chapter.</span></span></p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.407.1">Behavior-driven testing</span></h1>
<p><span class="koboSpan" id="kobo.408.1">We have now learned</span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.409.1"> how to supplement unit tests with integration tests, increasing the scope of our component under test. </span><span class="koboSpan" id="kobo.409.2">End-to-end tests have the most scope as they test the entirety of our system. </span><span class="koboSpan" id="kobo.409.3">They are often discussed together with </span><strong class="bold"><span class="koboSpan" id="kobo.410.1">behavior-driven design</span></strong><span class="koboSpan" id="kobo.411.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.412.1">BDD</span></strong><span class="koboSpan" id="kobo.413.1">), which is a branch of TDD that focuses on writing human-readable tests based on user requirements. </span></p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.414.1">Fundamentals of BDD</span></h2>
<p><span class="koboSpan" id="kobo.415.1">The first step of BDD practitioners</span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.416.1"> is to establish a shared vocabulary between the different interested parties: business stakeholders, domain experts, and various other engineering functions. </span></p>
<p><span class="koboSpan" id="kobo.417.1">Based on this shared and well-understood vocabulary, the user requirements are then converted</span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.418.1"> into </span><strong class="bold"><span class="koboSpan" id="kobo.419.1">user acceptance tests</span></strong><span class="koboSpan" id="kobo.420.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.421.1">UATs</span></strong><span class="koboSpan" id="kobo.422.1">). </span><span class="koboSpan" id="kobo.422.2">These tests are end-to-end tests that ensure that system requirements are covered by all </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">new releases.</span></span></p>
<p><span class="koboSpan" id="kobo.424.1">Tests are usually written</span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.425.1"> in the </span><strong class="bold"><span class="koboSpan" id="kobo.426.1">Given-When-Then</span></strong><span class="koboSpan" id="kobo.427.1"> structure, using business language and the shared vocabulary previously established by the business. </span><span class="koboSpan" id="kobo.427.2">A BDD formulation of the integration test for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">GET /</span></strong><span class="koboSpan" id="kobo.429.1"> endpoint we have previously implemented looks like this: </span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.430.1">Story: View the list </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.431.1">of books</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.432.1">Given</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.433.1">a user</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.434.1">When</span></strong><span class="koboSpan" id="kobo.435.1"> the user accesses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">GET /</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.437.1">root endpoint</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.438.1">Then</span></strong><span class="koboSpan" id="kobo.439.1"> the list of available books is returned to </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">the user</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.441.1">The test specification reads like plain English and establishes the main aspects of the </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">test case:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.443.1">Who the main actor of the test case is </span></li>
<li><span class="koboSpan" id="kobo.444.1">What their expected behavior is </span></li>
<li><span class="koboSpan" id="kobo.445.1">What the user will get from the </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">performed action</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.447.1">Note that the test case does not specify any implementation details of the application and instead focuses on </span><em class="italic"><span class="koboSpan" id="kobo.448.1">the behavior</span></em><span class="koboSpan" id="kobo.449.1"> of the application. </span><span class="koboSpan" id="kobo.449.2">Test cases treat the application as a </span><strong class="bold"><span class="koboSpan" id="kobo.450.1">black box</span></strong><span class="koboSpan" id="kobo.451.1">. </span><span class="koboSpan" id="kobo.451.2">This </span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.452.1">simplicity is the power of BDD, where test specifications are not something that only engineers and testing professionals </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">can write.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.454.1">BDD is about bridging gaps</span></p>
<p class="callout"><span class="koboSpan" id="kobo.455.1">The emphasis on shared language and easily readable tests ensures that the gaps between technical and non-technical stakeholders are bridged. </span><span class="koboSpan" id="kobo.455.2">This avoids misunderstandings and delays in the implementation of the system’s </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">intended behavior.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.457.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.458.1">.5</span></em><span class="koboSpan" id="kobo.459.1"> highlights</span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.460.1"> some of the advantages and disadvantages of writing tests </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">using BDD:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer049">
<span class="koboSpan" id="kobo.462.1"><img alt="Figure 5.5 – Advantages and disadvantages of writing BDD tests " src="image/Figure_5.05_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.463.1">Figure 5.5 – Advantages and disadvantages of writing BDD tests</span></p>
<p><span class="koboSpan" id="kobo.464.1">The following are the advantages </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">of BDD:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.466.1">Single source of truth</span></strong><span class="koboSpan" id="kobo.467.1">: The biggest</span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.468.1"> advantage of BDD is that it allows teams to have a single source of truth for the intended behavior of the application. </span><span class="koboSpan" id="kobo.468.2">Furthermore, we have a unified vocabulary to express this behavior across the business. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.469.1">Tests as documentation</span></strong><span class="koboSpan" id="kobo.470.1">: While unit tests can also serve as documentation for the application, BDD tests are easier to read and understand, since they focus on readability. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.471.1">Specific behaviors</span></strong><span class="koboSpan" id="kobo.472.1">: With their Given-When-Then structure, BDD tests encourage writing test cases for specific behavior. </span><span class="koboSpan" id="kobo.472.2">This often helps narrow down larger and potentially vague user requirements that have been established at the beginning of the project. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.473.1">Wider involvement</span></strong><span class="koboSpan" id="kobo.474.1">: Anyone in the team or the business can contribute to the specification of these tests, making it easier to detect any bugs or functional oversights early on. </span></li>
</ul>
<p><span class="koboSpan" id="kobo.475.1">And here are </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">the disadvantages:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.477.1">Time-consuming</span></strong><span class="koboSpan" id="kobo.478.1">: It can be </span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.479.1">time-consuming to get multiple stakeholders together to establish test cases at the beginning of the project. </span><span class="koboSpan" id="kobo.479.2">Furthermore, it can also be time-consuming to maintain these tests during the lifetime of the project. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.480.1">Requires commitment</span></strong><span class="koboSpan" id="kobo.481.1">: The different stakeholders need to commit to taking on the work of specifying and discussing these test cases upfront. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.482.1">Dependent on good BDD practices</span></strong><span class="koboSpan" id="kobo.483.1">: Unless correctly specified together with the correct stakeholders, BDD tests can become ambiguous and difficult to implement. </span><span class="koboSpan" id="kobo.483.2">The successful specification of tests is therefore dependent on good BDD practices in the business. </span></li>
</ul>
<p><span class="koboSpan" id="kobo.484.1">Now that we understand some of the advantages of BDD tests and how to write them, we can turn our attention to implementing them </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">in Go.</span></span></p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.486.1">Implementing BDD tests with Ginkgo</span></h2>
<p><span class="koboSpan" id="kobo.487.1">In </span><a href="B18371_03.xhtml#_idTextAnchor061"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.488.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.489.1">, </span><em class="italic"><span class="koboSpan" id="kobo.490.1">Mocking and Assertion Frameworks</span></em><span class="koboSpan" id="kobo.491.1">, we</span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.492.1"> learned</span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.493.1"> how to create mocks and write assertions with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">testify</span></strong><span class="koboSpan" id="kobo.495.1"> open source testing library. </span><span class="koboSpan" id="kobo.495.2">This allows us to create streamlined unit tests and easily create mocks. </span><span class="koboSpan" id="kobo.495.3">However, a more expressive testing library was required to easily produce BDD-style tests. </span></p>
<p><span class="koboSpan" id="kobo.496.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">ginkgo</span></strong><span class="koboSpan" id="kobo.498.1"> (</span><a href="https://github.com/onsi/ginkgo"><span class="koboSpan" id="kobo.499.1">https://github.com/onsi/ginkgo</span></a><span class="koboSpan" id="kobo.500.1">) project was started in 2013 to fill this need. </span><span class="koboSpan" id="kobo.500.2">It is a testing framework built on top of Go’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">testing</span></strong><span class="koboSpan" id="kobo.502.1"> package and it is designed to help us write expressive BDD tests. </span><span class="koboSpan" id="kobo.502.2">It is used together with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">gomega</span></strong><span class="koboSpan" id="kobo.504.1"> (</span><a href="https://github.com/onsi/gomega"><span class="koboSpan" id="kobo.505.1">https://github.com/onsi/gomega</span></a><span class="koboSpan" id="kobo.506.1">) matcher library, which exposes assertion matchers that we can use in our tests. </span><span class="koboSpan" id="kobo.506.2">This framework received mixed support from the community, as it brought the Ruby way of writing tests to Go. </span><span class="koboSpan" id="kobo.506.3">However, it is currently the default way to write BDD-style tests and it is an important part of our </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">TDD journey.</span></span></p>
<p><span class="koboSpan" id="kobo.508.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">Ginkgo</span></strong><span class="koboSpan" id="kobo.510.1"> library supports Go modules and can easily be installed with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">go install</span></strong><span class="koboSpan" id="kobo.512.1"> command, just </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">like </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">testify</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.516.1">
$ go install github.com/onsi/ginkgo/v2/ginkgo</span></pre>
<p class="callout-heading"><span class="koboSpan" id="kobo.517.1">Ginkgo installation location</span></p>
<p class="callout"><span class="koboSpan" id="kobo.518.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">install</span></strong><span class="koboSpan" id="kobo.520.1"> command will install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">ginkgo</span></strong><span class="koboSpan" id="kobo.522.1"> CLI in your </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">$GOBIN</span></strong><span class="koboSpan" id="kobo.524.1"> path, so ensure that it is set accordingly before you install it. </span><span class="koboSpan" id="kobo.524.2">By default, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">$GOBIN</span></strong><span class="koboSpan" id="kobo.526.1"> path </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">$GOPATH/bin</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.530.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">go get</span></strong><span class="koboSpan" id="kobo.532.1"> command </span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.533.1">then</span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.534.1"> fetches the </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">gomega</span></strong><span class="koboSpan" id="kobo.536.1"> assertion library: </span></p>
<pre class="console"><span class="koboSpan" id="kobo.537.1">
$ go get github.com/onsi/gomega/...</span></pre>
<p><span class="koboSpan" id="kobo.538.1">Ginkgo tests live in </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">_test.go</span></strong><span class="koboSpan" id="kobo.540.1"> files, just like regular unit tests, but they are organized in test suites. </span><span class="koboSpan" id="kobo.540.2">Suites can be compared to the table tests that we previously implemented, where we grouped tests by similar functionality </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">and scenarios.</span></span></p>
<p><span class="koboSpan" id="kobo.542.1">Suites are generated in the current directory using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">ginkgo </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">bootstrap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.545.1"> command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.546.1">
$ cd chapter05/handlers &amp;&amp; ginkgo bootstrap        
Generating ginkgo test suite bootstrap for handlers in:
        handlers_suite_test.go </span></pre>
<p><span class="koboSpan" id="kobo.547.1">The file is named according to the package declared in the current directory. </span><span class="koboSpan" id="kobo.547.2">The generated file contains the package declaration and some essential code for the suite’s declaration. </span><span class="koboSpan" id="kobo.547.3">Note that this command will fail if a suite </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">already exists.</span></span></p>
<p><span class="koboSpan" id="kobo.549.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">bootstrap</span></strong><span class="koboSpan" id="kobo.551.1"> command is a convenient way to generate this boilerplate for us and ensure that all test files have the same basic structure, across our all projects. </span><span class="koboSpan" id="kobo.551.2">It also ensures that our suites’ naming is consistent, so it is a powerful </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">standardization tool.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.553.1">Testing terminology</span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">ginkgo</span></strong><span class="koboSpan" id="kobo.555.1"> uses the same terminology</span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.556.1"> as the </span><strong class="bold"><span class="koboSpan" id="kobo.557.1">Ruby</span></strong><span class="koboSpan" id="kobo.558.1"> community. </span><span class="koboSpan" id="kobo.558.2">A </span><strong class="bold"><span class="koboSpan" id="kobo.559.1">suite</span></strong><span class="koboSpan" id="kobo.560.1"> is a collection of</span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.561.1"> tests that all verify </span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.562.1">the same package. </span><span class="koboSpan" id="kobo.562.2">A test is called a </span><strong class="bold"><span class="koboSpan" id="kobo.563.1">spec</span></strong><span class="koboSpan" id="kobo.564.1">. </span><span class="koboSpan" id="kobo.564.2">We will use the same terminology when referring to </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">ginkgo</span></strong><span class="koboSpan" id="kobo.566.1"> tests going forward. </span></p>
<p><span class="koboSpan" id="kobo.567.1">The generated</span><a id="_idIndexMarker411"/> <strong class="source-inline"><span class="koboSpan" id="kobo.568.1">chapter05/handlers/handlers_suite_test.go</span></strong><span class="koboSpan" id="kobo.569.1">,</span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.570.1"> contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">following code:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.572.1">package handlers_test</span></strong><span class="koboSpan" id="kobo.573.1">
import (
 "testing"
</span><strong class="bold"><span class="koboSpan" id="kobo.574.1"> . </span><span class="koboSpan" id="kobo.574.2">"github.com/onsi/ginkgo/v2"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.575.1"> . </span><span class="koboSpan" id="kobo.575.2">"github.com/onsi/gomega"</span></strong><span class="koboSpan" id="kobo.576.1">
)
func </span><strong class="bold"><span class="koboSpan" id="kobo.577.1">TestHandlers(t *testing.T)</span></strong><span class="koboSpan" id="kobo.578.1"> {
 RegisterFailHandler(Fail)
 RunSpecs(t, "Handlers Suite")
}</span></pre>
<p><span class="koboSpan" id="kobo.579.1">This file contains the necessary information for interacting with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">ginkgo</span></strong><span class="koboSpan" id="kobo.581.1"> runner: </span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.582.1">The suite test file is declared inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">handlers_test</span></strong><span class="koboSpan" id="kobo.584.1"> package corresponding to this directory. </span><span class="koboSpan" id="kobo.584.2">The separate </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">_test</span></strong><span class="koboSpan" id="kobo.586.1"> package ensures that we only test the exported functionality of the source package. </span><span class="koboSpan" id="kobo.586.2">This is essential to writing integration tests that only assert the external behavior of </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">the API.</span></span></li>
<li><span class="koboSpan" id="kobo.588.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">ginkgo</span></strong><span class="koboSpan" id="kobo.590.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">gomega</span></strong><span class="koboSpan" id="kobo.592.1"> libraries are imported using the dot (</span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">.</span></strong><span class="koboSpan" id="kobo.594.1">) operator. </span><span class="koboSpan" id="kobo.594.2">This allows us to have access to test and assertion functionality without having to qualify each function with the package name. </span><span class="koboSpan" id="kobo.594.3">This can be disabled, but it is discouraged by the BDD community, as tests should read as naturally as possible. </span></li>
<li><span class="koboSpan" id="kobo.595.1">The signature of the test is as expected. </span><span class="koboSpan" id="kobo.595.2">The test signature takes in a single parameter of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">*testing.T</span></strong><span class="koboSpan" id="kobo.597.1"> type. </span><span class="koboSpan" id="kobo.597.2">This is the entry point of our generated suite. </span></li>
<li><span class="koboSpan" id="kobo.598.1">The test contains two calls to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">Ginkgo</span></strong><span class="koboSpan" id="kobo.600.1"> test runner. </span><span class="koboSpan" id="kobo.600.2">We will not spend too much time discussing the internals of these functions, but, as all the testing library is open source, you can look up what they do yourself. </span><span class="koboSpan" id="kobo.600.3">The call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">RunSpecs</span></strong><span class="koboSpan" id="kobo.602.1"> instructs the test runner to begin running the suite and execute all </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">existing specs.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.604.1">The suite only </span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.605.1">serves </span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.606.1">as an entry point for the specs to begin executing, which are usually defined in separate test files. </span></p>
<p><span class="koboSpan" id="kobo.607.1">We define </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">ginkgo</span></strong><span class="koboSpan" id="kobo.609.1"> equivalent to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">Index</span></strong><span class="koboSpan" id="kobo.611.1"> endpoint integration test that we previously saw in the </span><em class="italic"><span class="koboSpan" id="kobo.612.1">Implementing integration tests</span></em><span class="koboSpan" id="kobo.613.1"> section in </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">chapter05/handlers/handlers_index_test.go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.617.1">var _ = Describe("Handlers integration", func() {</span></strong><span class="koboSpan" id="kobo.618.1">
 var svr *httptest.Server
 var book db.Book
</span><strong class="bold"><span class="koboSpan" id="kobo.619.1"> BeforeEach(func() {</span></strong><span class="koboSpan" id="kobo.620.1">
  book = db.Book{
   ID: uuid.New().String(),
   Name: "My first integration test",
   Status: db.Available.String(),
  }
  bs := db.NewBookService([]db.Book{book}, nil)
  ha := handlers.NewHandler(bs, nil)
  svr = httptest.NewServer(http.HandlerFunc(ha.Index))
 })
</span><strong class="bold"><span class="koboSpan" id="kobo.621.1"> AfterEach(func() {</span></strong><span class="koboSpan" id="kobo.622.1">
  svr.Close()
 })
</span><strong class="bold"><span class="koboSpan" id="kobo.623.1"> Describe("Index endpoint", func() {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.624.1">  Context("with one existing book", func() {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.625.1">   It("should return book", func() {</span></strong><span class="koboSpan" id="kobo.626.1">
    r, err := http.Get(svr.URL)
</span><strong class="bold"><span class="koboSpan" id="kobo.627.1">    </span></strong><strong class="bold"><span class="koboSpan" id="kobo.628.1">Expect(err).To(BeNil())</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.629.1">    Expect(r.StatusCode).To(Equal(http.StatusOK))</span></strong><span class="koboSpan" id="kobo.630.1">
    // … assertions continue
   })
  })
 })
})</span></pre>
<p><span class="koboSpan" id="kobo.631.1">The Ginkgo </span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.632.1">equivalent</span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.633.1"> of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">Index</span></strong><span class="koboSpan" id="kobo.635.1"> integration test seems quite different from the code we are used to seeing. </span><span class="koboSpan" id="kobo.635.2">Its focus is on setting up the various aspects of the test in an </span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.636.1">easy-to-read </span><strong class="bold"><span class="koboSpan" id="kobo.637.1">spec tree</span></strong><span class="koboSpan" id="kobo.638.1">: </span></p>
<ul>
<li><span class="koboSpan" id="kobo.639.1">We make use of closures to set up our spec hierarchy. </span><span class="koboSpan" id="kobo.639.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">Describe</span></strong><span class="koboSpan" id="kobo.641.1"> function allows us to </span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.642.1">create </span><strong class="bold"><span class="koboSpan" id="kobo.643.1">container nodes</span></strong><span class="koboSpan" id="kobo.644.1">. </span><span class="koboSpan" id="kobo.644.2">Specs must begin with a top-level </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">Describe</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.646.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.647.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">BeforeEach</span></strong><span class="koboSpan" id="kobo.649.1"> function creates </span><strong class="bold"><span class="koboSpan" id="kobo.650.1">setup nodes</span></strong><span class="koboSpan" id="kobo.651.1"> that run before tests. </span><span class="koboSpan" id="kobo.651.2">They are used for extracting </span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.652.1">common setups, allowing us to streamline our tests. </span></li>
<li><span class="koboSpan" id="kobo.653.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">AfterEach</span></strong><span class="koboSpan" id="kobo.655.1"> function creates setup nodes that run after tests. </span><span class="koboSpan" id="kobo.655.2">They allow us to clean up after our specs have run, ensuring that critical resources are cleaned </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">up correctly.</span></span></li>
<li><span class="koboSpan" id="kobo.657.1">We can further define container nodes inside the top-level nodes as required to organize our specs and </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">their scenarios.</span></span></li>
<li><span class="koboSpan" id="kobo.659.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">Context</span></strong><span class="koboSpan" id="kobo.661.1"> function is an alias for </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">Describe</span></strong><span class="koboSpan" id="kobo.663.1"> that allows us to add extra information to our specs to help people understand them. </span><span class="koboSpan" id="kobo.663.2">It also creates container nodes but can be used to </span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">organize information.</span></span></li>
<li><span class="koboSpan" id="kobo.665.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">It</span></strong><span class="koboSpan" id="kobo.667.1"> function allows us to </span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.668.1">define </span><strong class="bold"><span class="koboSpan" id="kobo.669.1">subject nodes</span></strong><span class="koboSpan" id="kobo.670.1">. </span><span class="koboSpan" id="kobo.670.2">These nodes contain the assertions of the subject under test and cannot contain any other nested nodes. </span></li>
<li><span class="koboSpan" id="kobo.671.1">The</span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.672.1"> assertions </span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.673.1">inside the subject nodes are written with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">gomega</span></strong><span class="koboSpan" id="kobo.675.1"> assertion library. </span><span class="koboSpan" id="kobo.675.2">These can be nested just like the assertions of </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">testify</span></strong><span class="koboSpan" id="kobo.677.1"> but take a human-readable form. </span><span class="koboSpan" id="kobo.677.2">All assertions must begin with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">Expect</span></strong><span class="koboSpan" id="kobo.679.1"> function, which wraps an actual value. </span></li>
</ul>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.680.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.681.1">.6</span></em><span class="koboSpan" id="kobo.682.1"> shows a visual representation of the structure of the </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">spec tree:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<span class="koboSpan" id="kobo.684.1"><img alt="Figure 5.6 – The structure of the spec tree " src="image/Figure_5.06_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.685.1">Figure 5.6 – The structure of the spec tree</span></p>
<p><span class="koboSpan" id="kobo.686.1">All tests begin with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">Describe</span></strong><span class="koboSpan" id="kobo.688.1"> container node. </span><span class="koboSpan" id="kobo.688.2">This top-level node can then contain multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">BeforeEach</span></strong><span class="koboSpan" id="kobo.690.1"> setup nodes, multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">AfterEach</span></strong><span class="koboSpan" id="kobo.692.1"> nodes, other </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">Context</span></strong><span class="koboSpan" id="kobo.694.1"> container</span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.695.1"> nodes, and</span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.696.1"> multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">It</span></strong><span class="koboSpan" id="kobo.698.1"> subject nodes. </span><span class="koboSpan" id="kobo.698.2">As we saw in the handlers integration test, these nodes are arranged to build a hierarchy that reflects our </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">test scenario.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.700.1">Nesting rules</span></p>
<p class="callout"><span class="koboSpan" id="kobo.701.1">The spec tree consists of nested container nodes. </span><span class="koboSpan" id="kobo.701.2">Setup nodes can be nested inside them. </span><span class="koboSpan" id="kobo.701.3">Like the behavior of deferred functions, the innermost function will run first. </span><span class="koboSpan" id="kobo.701.4">Then, the others will continue in the same fashion </span><span class="No-Break"><span class="koboSpan" id="kobo.702.1">going outward.</span></span></p>
<p><span class="koboSpan" id="kobo.703.1">Once we have generated our suite and populated it with specs, we can run it by using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">ginkgo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.705.1"> command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.706.1">
$ ginkgo -v ./chapter05/handlers
Running Suite: Handlers Suite
===================================================================
</span><strong class="bold"><span class="koboSpan" id="kobo.707.1">Handlers integration Index endpoint with one existing book</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.708.1">  should return book</span></strong><span class="koboSpan" id="kobo.709.1">
 SUCCESS! </span><span class="koboSpan" id="kobo.709.2">-- 1 Passed | 0 Failed | 0 Pending | 0 Skipped
PASS</span></pre>
<p><span class="koboSpan" id="kobo.710.1">Just like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">go test</span></strong><span class="koboSpan" id="kobo.712.1"> command we have used so far, </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">ginkgo</span></strong><span class="koboSpan" id="kobo.714.1"> also supports the </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">./...</span></strong><span class="koboSpan" id="kobo.716.1"> operator, which will traverse subdirectories and look for suites to run. </span></p>
<p><span class="koboSpan" id="kobo.717.1">As we can see from the output, the container nodes and subject nodes are used to construct meaningful</span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.718.1"> names for the </span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.719.1">spec suite. </span><span class="koboSpan" id="kobo.719.2">Ginkgo allows us to construct test collections with meaningful test outputs. </span><span class="koboSpan" id="kobo.719.3">We will continue to explore it in future chapters. </span></p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.720.1">Understanding database testing</span></h1>
<p><span class="koboSpan" id="kobo.721.1">In the world of testing, databases</span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.722.1"> are often overlooked in literature. </span><span class="koboSpan" id="kobo.722.2">Most applications often assume in-memory data storage, just as we have done with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">BookSwap</span></strong><span class="koboSpan" id="kobo.724.1"> application so far. </span><span class="koboSpan" id="kobo.724.2">However, it is important to understand the difficulties and techniques that we have available when it comes to verifying </span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">our databases.</span></span></p>
<p><span class="koboSpan" id="kobo.726.1">Databases are often seen as external systems or black boxes in our system. </span><span class="koboSpan" id="kobo.726.2">They provide specialized behavior and are often complex systems, which most often cannot fail. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.727.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.728.1">.6</span></em><span class="koboSpan" id="kobo.729.1"> depicts the typical data translation between </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">different formats:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer051">
<span class="koboSpan" id="kobo.731.1"><img alt="Figure 5.7 – The data formats of a typical system " src="image/Figure_5.07_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.732.1">Figure 5.7 – The data formats of a typical system</span></p>
<p><span class="koboSpan" id="kobo.733.1">Data changes formats multiple times in a typical application. </span><span class="koboSpan" id="kobo.733.2">User requests usually enter our system in </span><strong class="bold"><span class="koboSpan" id="kobo.734.1">JSON</span></strong><span class="koboSpan" id="kobo.735.1"> format. </span><span class="koboSpan" id="kobo.735.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.736.1">API layer</span></strong><span class="koboSpan" id="kobo.737.1"> area then translates these requests to the internal application models and sends them further down the stack to the </span><strong class="bold"><span class="koboSpan" id="kobo.738.1">Service layer</span></strong><span class="koboSpan" id="kobo.739.1"> area. </span><span class="koboSpan" id="kobo.739.2">Finally, the </span><strong class="bold"><span class="koboSpan" id="kobo.740.1">Service layer</span></strong><span class="koboSpan" id="kobo.741.1"> area persists these in the database using </span><strong class="bold"><span class="koboSpan" id="kobo.742.1">SQL</span></strong><span class="koboSpan" id="kobo.743.1"> or whatever the expected format of the database is. </span><span class="koboSpan" id="kobo.743.2">Often, </span><strong class="bold"><span class="koboSpan" id="kobo.744.1">NoSQL databases</span></strong><span class="koboSpan" id="kobo.745.1"> will save their data</span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.746.1"> back</span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.747.1"> in </span><strong class="bold"><span class="koboSpan" id="kobo.748.1">JSON</span></strong><span class="koboSpan" id="kobo.749.1"> format and persist it. </span></p>
<p><span class="koboSpan" id="kobo.750.1">We should write tests that cover the following aspects of our database systems: </span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.751.1">Startup and availability</span></strong><span class="koboSpan" id="kobo.752.1">: The </span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.753.1">application should wait for the database to become available and should do so in an efficient manner. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.754.1">Persistence and querying</span></strong><span class="koboSpan" id="kobo.755.1">: Once data is stored in the database, it should be correctly stored and fetched. </span><span class="koboSpan" id="kobo.755.2">This is done by the business logic and should be verified to be implemented correctly. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.756.1">Performance testing</span></strong><span class="koboSpan" id="kobo.757.1">: This type of non-functional testing is important for the database, which typically powers all the requests in the application. </span><span class="koboSpan" id="kobo.757.2">Typical verifications include load testing using large files or results counts, running tests using multiple remote users, and any edge cases regarding the values of the column/field values of the </span><span class="No-Break"><span class="koboSpan" id="kobo.758.1">database payloads.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.759.1">These crucial aspects of our systems should be covered by testing, especially around the points where data formats vary and translations occur. </span><span class="koboSpan" id="kobo.759.2">These format translations can be the cause of bugs and outages. </span><span class="koboSpan" id="kobo.759.3">For example, one field might be a mandatory non-nullable value at the </span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.760.1">database level, but be missing further up </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">the stack.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.762.1">Mocks as databases</span></p>
<p class="callout"><span class="koboSpan" id="kobo.763.1">It might be tempting to assume that a mock would be fitting to wrap around complex external behavior, but the community generally discourages this as an engineering anti-pattern. </span><span class="koboSpan" id="kobo.763.2">End-to-end and integration tests should verify and run against the databases that they use in production to avoid differences in functionality and performance. </span></p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.764.1">Useful libraries</span></h2>
<p><span class="koboSpan" id="kobo.765.1">Fortunately, the Go</span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.766.1"> ecosystem provides some great libraries to allow us to easily integrate databases into our applications. </span><span class="koboSpan" id="kobo.766.2">Here are some Go libraries that you will find useful when integrating databases into your </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">Go applications:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">go-testfixtures</span></strong><span class="koboSpan" id="kobo.769.1"> (</span><a href="https://github.com/go-testfixtures/testfixtures"><span class="koboSpan" id="kobo.770.1">https://github.com/go-testfixtures/testfixtures</span></a><span class="koboSpan" id="kobo.771.1">): An open source library that makes it easy to write functional database tests. </span><span class="koboSpan" id="kobo.771.2">It uses the </span><strong class="bold"><span class="koboSpan" id="kobo.772.1">Ruby on Rails</span></strong><span class="koboSpan" id="kobo.773.1"> way of setting up data samples using </span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">fixtures files.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">golang-migrate</span></strong><span class="koboSpan" id="kobo.776.1"> (</span><a href="https://github.com/golang-migrate/migrate"><span class="koboSpan" id="kobo.777.1">https://github.com/golang-migrate/migrate</span></a><span class="koboSpan" id="kobo.778.1">): An open source library that makes setting up database startup positions easy, without us having to write our own data formats and files. </span><span class="koboSpan" id="kobo.778.2">It supports a variety of SQL and </span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">NoSQL databases.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">go-txdb</span></strong><span class="koboSpan" id="kobo.781.1"> (</span><a href="https://github.com/DATA-DOG/go-txdb"><span class="koboSpan" id="kobo.782.1">https://github.com/DATA-DOG/go-txdb</span></a><span class="koboSpan" id="kobo.783.1">): An open source library that runs database queries in transactions. </span><span class="koboSpan" id="kobo.783.2">Once the tests are complete, transactions are rolled back and data is not persisted. </span><span class="koboSpan" id="kobo.783.3">This allows us to run our tests in isolation on top of a </span><span class="No-Break"><span class="koboSpan" id="kobo.784.1">real database.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">gorm</span></strong><span class="koboSpan" id="kobo.786.1"> (</span><a href="https://github.com/go-gorm/gorm"><span class="koboSpan" id="kobo.787.1">https://github.com/go-gorm/gorm</span></a><span class="koboSpan" id="kobo.788.1">): A popular open source library that provides </span><strong class="bold"><span class="koboSpan" id="kobo.789.1">object-relational mapping</span></strong><span class="koboSpan" id="kobo.790.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.791.1">ORM</span></strong><span class="koboSpan" id="kobo.792.1">). </span><span class="koboSpan" id="kobo.792.2">This developer-friendly library makes it </span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.793.1">easier to convert database types into useful </span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">custom structs.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">bun</span></strong><span class="koboSpan" id="kobo.796.1"> (</span><a href="https://github.com/uptrace/bun"><span class="koboSpan" id="kobo.797.1">https://github.com/uptrace/bun</span></a><span class="koboSpan" id="kobo.798.1">): This is the new, rewritten version of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">go-pg</span></strong><span class="koboSpan" id="kobo.800.1"> (</span><a href="https://github.com/go-pg/pg"><span class="koboSpan" id="kobo.801.1">https://github.com/go-pg/pg</span></a><span class="koboSpan" id="kobo.802.1">) project. </span><span class="koboSpan" id="kobo.802.2">This project provides ORM functionality for multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">SQL databases.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.804.1">The literature on whether to use SQL or NoSQL databases is vast and involves a wide set of recommendations. </span><span class="koboSpan" id="kobo.804.2">We will not start this discussion here, but SQL databases remain the most popular database solutions. </span><span class="koboSpan" id="kobo.804.3">We will focus on how to implement and test SQL databases in our</span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.805.1"> discussions going forward. </span><span class="koboSpan" id="kobo.805.2">We will also see some of the libraries we mentioned in this section in action going forward. </span></p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.806.1">Spinning up and tearing down environments with Docker</span></h1>
<p><span class="koboSpan" id="kobo.807.1">The final topic </span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.808.1">we will </span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.809.1">cover in</span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.810.1"> our</span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.811.1"> exploration of integration and end-to-end </span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.812.1">testing is </span><strong class="bold"><span class="koboSpan" id="kobo.813.1">containerization</span></strong><span class="koboSpan" id="kobo.814.1"> using the popular technology known as Docker. </span><span class="koboSpan" id="kobo.814.2">It provides us with the ability to start up applications in our local and remote environments in the same way. </span></p>
<p><span class="koboSpan" id="kobo.815.1">Docker gives developers the confidence that their applications will behave in the same way across environments, which is particularly useful for managing and deploying </span><span class="No-Break"><span class="koboSpan" id="kobo.816.1">test environments.</span></span></p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.817.1">Fundamentals of Docker</span></h2>
<p><span class="koboSpan" id="kobo.818.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.819.1">container</span></strong><span class="koboSpan" id="kobo.820.1"> is a </span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.821.1">unit of</span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.822.1"> software that bundles up code and all its dependencies, enabling us to run it in multiple environments. </span><span class="koboSpan" id="kobo.822.2">The specification of the container is known</span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.823.1"> as a </span><strong class="bold"><span class="koboSpan" id="kobo.824.1">container image</span></strong><span class="koboSpan" id="kobo.825.1">. </span><span class="koboSpan" id="kobo.825.2">Docker Engine interprets the specification of container images and turns them into containers. </span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.826.1">Containerization versus virtualization</span></p>
<p class="callout"><strong class="bold"><span class="koboSpan" id="kobo.827.1">Virtualization</span></strong><span class="koboSpan" id="kobo.828.1"> refers to</span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.829.1"> running multiple operating systems on a single machine. </span><span class="koboSpan" id="kobo.829.2">Containerization refers to running multiple applications developed in the environment of one operating system on a </span><span class="No-Break"><span class="koboSpan" id="kobo.830.1">single machine.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.831.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.832.1">.7</span></em><span class="koboSpan" id="kobo.833.1"> depicts containers running on the </span><span class="No-Break"><span class="koboSpan" id="kobo.834.1">host environment:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer052">
<span class="koboSpan" id="kobo.835.1"><img alt="Figure 5.8 – Running containers with Docker " src="image/Figure_5.08_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.836.1">Figure 5.8 – Running containers with Docker</span></p>
<p><span class="koboSpan" id="kobo.837.1">Containers are lightweight, allowing multiple containers to run on the same physical hardware. </span><strong class="bold"><span class="koboSpan" id="kobo.838.1">Docker Engine</span></strong><span class="koboSpan" id="kobo.839.1"> oversees managing them and enforcing isolation levels, ensuring that malicious code cannot escape outside of its current namespace, but also importantly ensuring that tests have a realistic level of isolation. </span><span class="koboSpan" id="kobo.839.2">In practice, this means that we can download and run a set of images for complex systems to run on shared hardware. </span></p>
<p><span class="koboSpan" id="kobo.840.1">For example, we could run multiple containers on shared infrastructure: a Go web application, a database, event buses and queues, monitoring, and so on. </span><span class="koboSpan" id="kobo.840.2">All these different technologies </span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.841.1">and images can be managed by a single </span><strong class="bold"><span class="koboSpan" id="kobo.842.1">standardized technology</span></strong><span class="koboSpan" id="kobo.843.1"> with</span><a id="_idIndexMarker445"/> <span class="No-Break"><span class="koboSpan" id="kobo.844.1">Docker Engine.</span></span></p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.845.1">Using Docker</span></h2>
<p><span class="koboSpan" id="kobo.846.1">The concept of</span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.847.1"> containerization does not belong to Docker exclusively, but we will refer only to the usage of Docker going forward. </span><span class="koboSpan" id="kobo.847.2">Docker Engine can easily be installed by following the official documentation available </span><span class="No-Break"><span class="koboSpan" id="kobo.848.1">at </span></span><a href="https://www.docker.com/get-started/"><span class="No-Break"><span class="koboSpan" id="kobo.849.1">https://www.docker.com/get-started/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.850.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.851.1">Docker Engine ships with a powerful CLI that contains two </span><span class="No-Break"><span class="koboSpan" id="kobo.852.1">main commands:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">docker</span></strong><span class="koboSpan" id="kobo.854.1"> deploys and manages a single application or container. </span><span class="koboSpan" id="kobo.854.2">The Docker CLI offers an extensive list of commands and options, some of the most common being these: </span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.855.1">docker pull</span></strong><span class="koboSpan" id="kobo.856.1"> downloads an image from the image repository, named </span><strong class="bold"><span class="koboSpan" id="kobo.857.1">Docker Hub</span></strong><span class="koboSpan" id="kobo.858.1"> (</span><a href="https://hub.docker.com/"><span class="koboSpan" id="kobo.859.1">https://hub.docker.com/</span></a><span class="koboSpan" id="kobo.860.1">). </span><span class="koboSpan" id="kobo.860.2">Once downloaded, the image is available for </span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.861.1">use by </span><span class="No-Break"><span class="koboSpan" id="kobo.862.1">containers locally.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">docker run</span></strong><span class="koboSpan" id="kobo.864.1"> creates a container from an image. </span><span class="koboSpan" id="kobo.864.2">If the image is not available locally, it will be downloaded from the image repository, prolonging the container </span><span class="No-Break"><span class="koboSpan" id="kobo.865.1">startup time.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">docker ps</span></strong><span class="koboSpan" id="kobo.867.1"> lists all the locally running containers. </span><span class="koboSpan" id="kobo.867.2">This command is commonly used to get the unique container ID for each container. </span><span class="koboSpan" id="kobo.867.3">These unique IDs can then be used to reference specific containers in other commands. </span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">docker stop</span></strong><span class="koboSpan" id="kobo.869.1"> instructs the container to shut down, giving it time to gracefully shut down and clean up its resources. </span><span class="koboSpan" id="kobo.869.2">Docker Engine makes use of operating system signals to communicate shutdown to containers. </span><span class="koboSpan" id="kobo.869.3">Containers can then be restarted using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">docker start</span></strong><span class="koboSpan" id="kobo.871.1"> command. </span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">docker kill</span></strong><span class="koboSpan" id="kobo.873.1"> instructs the container to stop its execution immediately, without allowing time for graceful shutdown. </span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">docker exec</span></strong><span class="koboSpan" id="kobo.875.1"> allows</span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.876.1"> us to access a running container. </span><span class="koboSpan" id="kobo.876.2">Since containers are isolated from the rest of the operating system, the only way to have access to its resources and setup is to request access from Docker Engine. </span></li></ul></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">docker compose</span></strong><span class="koboSpan" id="kobo.878.1"> deploys and manages multiple containers within the same single host. </span><span class="koboSpan" id="kobo.878.2">This allows us to configure and start multiple containers with a single command, as opposed to starting them each individually with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">docker</span></strong><span class="koboSpan" id="kobo.880.1"> command. </span><span class="koboSpan" id="kobo.880.2">Another key advantage is that the containers will be running and networking as a single group, making it easy to deploy complex systems across environments. </span><span class="koboSpan" id="kobo.880.3">Some of the most common </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">docker compose</span></strong><span class="koboSpan" id="kobo.882.1"> commands are </span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">as follows:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.884.1">docker compose up</span></strong><span class="koboSpan" id="kobo.885.1"> starts the specified containers of a given </span><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">.yml</span></strong><span class="koboSpan" id="kobo.887.1"> file. </span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.888.1">docker compose ps</span></strong><span class="koboSpan" id="kobo.889.1"> lists the containers of a Compose project, including their statuses and registered ports. </span><span class="koboSpan" id="kobo.889.2">These containers will also be visible when running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.890.1">docker ps</span></strong><span class="koboSpan" id="kobo.891.1"> command, but this command will output more </span><span class="No-Break"><span class="koboSpan" id="kobo.892.1">container information.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">docker compose stop</span></strong><span class="koboSpan" id="kobo.894.1"> instructs running containers to stop, without removing them. </span><span class="koboSpan" id="kobo.894.2">They can then be restarted again using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">docker compose </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">start</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.897.1"> command.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">docker compose kill</span></strong><span class="koboSpan" id="kobo.899.1"> forces containers to immediately stop using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.900.1">SIGKILL</span></strong><span class="koboSpan" id="kobo.901.1"> system signal. </span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.902.1">That’s all the basics we need to know to install Docker Engine and perform some basic tasks with Docker. </span><span class="koboSpan" id="kobo.902.2">In </span><a href="B18371_06.xhtml#_idTextAnchor142"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.903.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.904.1">, </span><em class="italic"><span class="koboSpan" id="kobo.905.1">End-To-End Testing the BookSwap Web Application</span></em><span class="koboSpan" id="kobo.906.1">, we will look at the configuration of the custom Dockerfile for our application, the changes we need to make to our </span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.907.1">existing implementation to make use of a database, and how to run end-to-end tests based on these easy to spin up and tear </span><span class="No-Break"><span class="koboSpan" id="kobo.908.1">down containers.</span></span></p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.909.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.910.1">In this chapter, we moved on from focusing on unit tests, which verify the functionality of code in small isolated units. </span><span class="koboSpan" id="kobo.910.2">We began with an introduction to the importance of integration testing and learned how to write and run integration tests for HTTP handlers using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">httptest</span></strong><span class="koboSpan" id="kobo.912.1"> library. </span><span class="koboSpan" id="kobo.912.2">Then, we learned what the practice of writing BDD-style tests entails and how to implement them using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.913.1">ginkgo</span></strong><span class="koboSpan" id="kobo.914.1"> testing library. </span><span class="koboSpan" id="kobo.914.2">Then, we discussed the importance of testing databases and what useful libraries there are available to us to be able to write these. </span><span class="koboSpan" id="kobo.914.3">Finally, we covered the advantages of containerization and learned how to use Docker and configure services with </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.915.1">docker compose</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.917.1">In </span><a href="B18371_06.xhtml#_idTextAnchor142"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.918.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.919.1">, </span><em class="italic"><span class="koboSpan" id="kobo.920.1">End-To-End Testing the BookSwap Web Application</span></em><span class="koboSpan" id="kobo.921.1">, we will expand on all the fundamentals of the technologies we have learned so far and apply them to test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">BookSwap</span></strong><span class="koboSpan" id="kobo.923.1"> web application. </span><span class="koboSpan" id="kobo.923.2">This will give us good hands-on practice to configure a typical web application that has a simple </span><span class="No-Break"><span class="koboSpan" id="kobo.924.1">database dependency.</span></span></p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.925.1">Questions</span></h1>
<p><span class="koboSpan" id="kobo.926.1">Answer the following questions to test your knowledge of </span><span class="No-Break"><span class="koboSpan" id="kobo.927.1">this chapter:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.928.1">What is the difference between integration tests and </span><span class="No-Break"><span class="koboSpan" id="kobo.929.1">end-to-end tests?</span></span></li>
<li><span class="koboSpan" id="kobo.930.1">What is </span><strong class="bold"><span class="koboSpan" id="kobo.931.1">behavior-driven </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.932.1">design</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.933.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.934.1">BDD</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.935.1">)?</span></span></li>
<li><span class="koboSpan" id="kobo.936.1">Should we mock databases? </span><span class="No-Break"><span class="koboSpan" id="kobo.937.1">Why/why not?</span></span></li>
<li><span class="koboSpan" id="kobo.938.1">What is </span><span class="No-Break"><span class="koboSpan" id="kobo.939.1">a container?</span></span></li>
</ol>
<h1 id="_idParaDest-121"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.940.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.941.1">To learn more about the topics that were covered in this chapter, take a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.942.1">following resources:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.943.1">BDD in Action: Behavior-driven development for the whole software lifecycle</span></em><span class="koboSpan" id="kobo.944.1">, by John Ferguson Smart, published by </span><span class="No-Break"><span class="koboSpan" id="kobo.945.1">Manning Publications</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.946.1">Docker: Up &amp; Running: Shipping Reliable Containers in Production</span></em><span class="koboSpan" id="kobo.947.1">, by Sean Kane and Karl Matthias, published </span><span class="No-Break"><span class="koboSpan" id="kobo.948.1">by O’Reilly</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.949.1">Designing Data-Intensive Applications: The Big Ideas Behind Reliable, Scalable, and Maintainable Systems</span></em><span class="koboSpan" id="kobo.950.1">, by Martin Kleppmann, published </span><span class="No-Break"><span class="koboSpan" id="kobo.951.1">by O’Reilly</span></span></li>
</ul>
</div>
</body></html>