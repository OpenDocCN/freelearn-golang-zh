["```go\n// Handler contains the handler and all its dependencies.\ntype Handler struct {\n bs *db.BookService\n us *db.UserService\n}\n// Index is invoked by HTTP GET /.\nfunc (h *Handler) Index(w http.ResponseWriter, r *http.Request) {\n // Send an HTTP status & a hardcoded message\n resp := &Response{\n  Message: \"Welcome to the BookSwap service!\",\n  Books:    h.bs.List(),\n }\n writeResponse(w, http.StatusOK, resp)\n}\n```", "```go\nfunc TestIndexIntegration(t *testing.T) {\n // Arrange\n book := db.Book{\n  ID: uuid.New().String(),\n  Name: \"My first integration test\",\n  Status: db.Available.String(),\n }\n bs := db.NewBookService([]db.Book{book}, nil)\n h := handlers.NewHandler(bs, nil)\n svr := httptest.NewServer(http.HandlerFunc(h.Index))\n defer svr.Close()\n // Act\n r, err := http.Get(svr.URL)\n // Assert\n require.Nil(t, err)\n assert.Equal(t, http.StatusOK, r.StatusCode)\n body, err := io.ReadAll(r.Body)\n r.Body.Close()\n require.Nil(t, err)\n var resp handlers.Response\n err = json.Unmarshal(body, &resp)\n require.Nil(t, err)\n assert.Equal(t, 1, len(resp.Books))\n assert.Contains(t, resp.Books, book)\n}\n```", "```go\n$ go test -run TestIndexIntegration ./chapter05/handlers -v\n=== RUN   TestIndexIntegration\n--- PASS: TestIndexIntegration (1.712s)\nPASS\nok      github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter05/handlers     1.712s\n```", "```go\nfunc TestIndexIntegration(t *testing.T) {\n if testing.Short() {\n  t.Skip(\"Skipping TestIndexIntegration in short mode.\")\n }\n // testing code continues\n} \n```", "```go\n$ go test -run TestIndexIntegration ./chapter05/handlers -v -short\n=== RUN   TestIndexIntegration\n    handlers_test.go:19: Skipping TestIndexIntegration in short mode.\n--- SKIP: TestIndexIntegration (0.00s)\nPASS\n```", "```go\nfunc TestIndexIntegration(t *testing.T) {\n if os.Getenv(\"LONG\") == \"\" {\n  t.Skip(\"Skipping TestIndexIntegration in short mode.\")\n }\n // testing code continues\n}\n```", "```go\n$ LONG=true go test -run TestIndexIntegration ./chapter05/handlers -v\n=== RUN   TestIndexIntegration\n--- PASS: TestIndexIntegration (0.00s)\nPASS\nok      github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter05/handlers     0.779s\n```", "```go\n$ go install github.com/onsi/ginkgo/v2/ginkgo\n```", "```go\n$ go get github.com/onsi/gomega/...\n```", "```go\n$ cd chapter05/handlers && ginkgo bootstrap        \nGenerating ginkgo test suite bootstrap for handlers in:\n        handlers_suite_test.go \n```", "```go\npackage handlers_test\nimport (\n \"testing\"\n . \"github.com/onsi/ginkgo/v2\"\n . \"github.com/onsi/gomega\"\n)\nfunc TestHandlers(t *testing.T) {\n RegisterFailHandler(Fail)\n RunSpecs(t, \"Handlers Suite\")\n}\n```", "```go\nvar _ = Describe(\"Handlers integration\", func() {\n var svr *httptest.Server\n var book db.Book\n BeforeEach(func() {\n  book = db.Book{\n   ID: uuid.New().String(),\n   Name: \"My first integration test\",\n   Status: db.Available.String(),\n  }\n  bs := db.NewBookService([]db.Book{book}, nil)\n  ha := handlers.NewHandler(bs, nil)\n  svr = httptest.NewServer(http.HandlerFunc(ha.Index))\n })\n AfterEach(func() {\n  svr.Close()\n })\n Describe(\"Index endpoint\", func() {\n  Context(\"with one existing book\", func() {\n   It(\"should return book\", func() {\n    r, err := http.Get(svr.URL)\nExpect(err).To(BeNil())\n    Expect(r.StatusCode).To(Equal(http.StatusOK))\n    // … assertions continue\n   })\n  })\n })\n})\n```", "```go\n$ ginkgo -v ./chapter05/handlers\nRunning Suite: Handlers Suite\n===================================================================\nHandlers integration Index endpoint with one existing book\n  should return book\n SUCCESS! -- 1 Passed | 0 Failed | 0 Pending | 0 Skipped\nPASS\n```"]