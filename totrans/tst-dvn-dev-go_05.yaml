- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Performing Integration Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行集成测试
- en: In the previous chapters, we discussed the broader topic of writing and testing
    code with **test-driven development** (**TDD**), but have kept our implementation
    focus on unit tests. As we’ve discussed at length so far, unit tests are at the
    bottom of the test pyramid, being the most numerous, as they are testing all the
    different independent parts or units of the application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了更广泛的话题，即使用**测试驱动开发**（**TDD**）编写和测试代码，但我们的实现重点一直放在单元测试上。正如我们之前详细讨论的那样，单元测试位于测试金字塔的底部，因为它们数量最多，因为它们测试应用程序的所有不同独立部分或单元。
- en: The concepts we have discussed so far have allowed us to write unit tests that
    test these units in isolation, across a variety of scenarios. In [*Chapter 3*](B18371_03.xhtml#_idTextAnchor061),
    *Mocking and Assertion Frameworks*, we learned how to make use of frameworks to
    easily create mocks, which allow us to instantiate units whose dependencies we
    have full control over. As discussed in [*Chapter 4*](B18371_04.xhtml#_idTextAnchor085),
    *Building Efficient Test Suites*, we learned how to make use of the popular technique
    of table-driven testing to easily write tests across a variety of cases, including
    edge and corner cases.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论的概念使我们能够编写单元测试，以隔离测试这些单元，并在各种场景中进行测试。在[*第3章*](B18371_03.xhtml#_idTextAnchor061)，*模拟和断言框架*中，我们学习了如何利用框架轻松创建模拟，这使我们能够实例化对其依赖项有完全控制的单元。正如[*第4章*](B18371_04.xhtml#_idTextAnchor085)，*构建高效的测试套件*中讨论的那样，我们学习了如何利用流行的表格驱动测试技术轻松编写各种情况的测试，包括边缘和角落情况。
- en: No matter how well we write our unit tests, they have the limitation that they
    only verify their limited scope. In other words, unit tests verify that each unit
    is working correctly, but not that they integrate and function correctly together.
    The integrations between units, which may be developed by different teams, can
    often be the cause of errors and outages, so it is important to verify that they
    behave as expected, independently and together.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们编写单元测试多么出色，它们都有局限性，即它们只能验证其有限的范围。换句话说，单元测试验证每个单元是否正常工作，但并不能验证它们是否能够正确集成并协同工作。不同团队开发的单元之间的集成往往可能是错误和故障的原因，因此验证它们是否按预期独立和协同工作非常重要。
- en: We will now turn our attention to implementing integration testing suites, which
    will give us the confidence that the functionality that matters will work as intended
    when multiple units work together. We will explore how to containerize our applications,
    ensuring that our tests mimic our production environments and perform as expected.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将把注意力转向实现集成测试套件，这将使我们确信，当多个单元协同工作时，重要的功能将按预期工作。我们将探讨如何容器化我们的应用程序，确保我们的测试模拟我们的生产环境并按预期执行。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The limitations of unit testing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试的局限性
- en: The implementation of integration tests in Go
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go中集成测试的实现
- en: Introduction to behavior-driven test writing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为驱动测试编写简介
- en: The importance of database testing
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库测试的重要性
- en: Containerization with Docker
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker进行容器化
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need to have **Go version 1.19** or later installed to run the code
    samples in this chapter. The installation process is described in the official
    Go documentation at [https://go.dev/doc/install](https://go.dev/doc/install).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装**Go版本1.19**或更高版本才能运行本章中的代码示例。安装过程在官方Go文档中有描述，请参阅[https://go.dev/doc/install](https://go.dev/doc/install)。
- en: The code examples included in this book are publicly available at [https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter05](https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter05).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本书包含的代码示例在[https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter05](https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter05)上公开提供。
- en: Supplementing unit tests with integration tests
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用集成测试补充单元测试
- en: Unit tests are small, fast tests that verify the behavior of a single component.
    In Go, the UUT is typically the package, which exposes an API that these fast
    tests can verify against. These independent units combine to make up **components**,
    which are identifiable parts of a system. Usually, components have well-defined
    responsibilities and provide a group of related functions. A component’s units
    work together to deliver the component’s functionality.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是小型、快速的测试，用于验证单个组件的行为。在 Go 中，UUT 通常是指包，它暴露了一个 API，这些快速测试可以对其进行验证。这些独立的单元组合起来形成**组件**，它们是系统的可识别部分。通常，组件具有明确定义的责任并提供一组相关功能。组件的单元协同工作以提供组件的功能。
- en: Engineers rely heavily on unit tests in the development phase, and they are
    an important pillar of TDD, where the testing practice requires the testing code
    to be written together with the implementation code. However, they have some limitations
    that make the remaining tests of the testing pyramid essential. Therefore, as
    TDD practitioners, we cannot simply focus on unit tests.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 工程师在开发阶段高度依赖单元测试，它们是 TDD（测试驱动开发）的重要支柱，其中测试实践要求测试代码与实现代码一起编写。然而，它们有一些局限性，使得测试金字塔的剩余测试变得至关重要。因此，作为
    TDD 实践者，我们不能仅仅关注单元测试。
- en: Limitations of unit testing
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试的限制
- en: 'The practice of verifying functionality with unit tests has been the subject
    of debate in the engineering community because of its limitations. *Figure 5**.1*
    presents a summary of their advantages and disadvantages:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其局限性，使用单元测试验证功能在工程社区中一直是争论的主题。*图 5.1* 展示了它们的优缺点总结：
- en: '![Figure 5.1 – Advantages and disadvantages of unit testing ](img/Figure_5.01_B18371.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 单元测试的优点和缺点](img/Figure_5.01_B18371.jpg)'
- en: Figure 5.1 – Advantages and disadvantages of unit testing
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 单元测试的优点和缺点
- en: 'Here are the advantages of unit tests:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是单元测试的优点：
- en: '**Support refactoring**: Unit tests make it easier to refactor code because
    they provide fast verification of existing functionality. They decrease the risk
    associated with changing code, which can lead to breaking existing functionality.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持重构**：单元测试使得重构代码变得更加容易，因为它们可以快速验证现有功能。它们降低了与代码更改相关的风险，这可能导致现有功能被破坏。'
- en: '**Early bug detection**: Unit tests verify the implementation at the development
    phase before it has been integrated with the existing product and can be tested
    end-to-end. This also ensures that bugs don’t propagate to other teams or are
    accidentally released. Early bug detection can also lead to shorter development
    times and reduced project costs.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**早期错误检测**：单元测试在集成到现有产品并进行全面测试之前，在开发阶段验证实现。这也确保了错误不会传播到其他团队或意外发布。早期错误检测还可以缩短开发时间并降低项目成本。'
- en: '**Easier debugging**: Detecting and fixing errors is easier when the tests
    have a limited scope. As the **UUT** is tested in isolation from its dependencies,
    we know that any failing tests are caused either by the test setup or the implementation
    of the UUT.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更容易调试**：当测试范围有限时，检测和修复错误变得更加容易。由于 UUT 是与其依赖项隔离测试的，我们知道任何失败的测试都是由测试设置或 UUT
    的实现引起的。'
- en: '**Better code design**: Poorly designed code is hard to test code and can highlight
    to developers where their code must be rewritten or refactored. In practice, unit
    tests promote better code design because they bring the testing concerns to the
    development phase.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的代码设计**：设计不良的代码难以测试，并且可以指出开发者代码必须重写或重构的地方。在实践中，单元测试通过将测试关注点带到开发阶段来促进更好的代码设计。'
- en: '**Documentation alongside implementation**: Unit tests serve as detailed documentation
    for the functionality and behavior of a component. As tests live alongside the
    code in Go, they give developers access to it without the use of another documentation
    system.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现旁边的文档**：单元测试充当组件功能和行为的详细文档。由于测试与 Go 中的代码一起存在，它们为开发者提供了访问权限，而无需使用另一个文档系统。'
- en: 'And these are the disadvantages:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 而这些是它们的缺点：
- en: '**Increase the amount of code**: Unit tests increase the code that developers
    must write early on. This is problematic for tasks that require prototyping or
    don’t have well-established requirements. Developers don’t want to write large
    amounts of code that then need to be changed alongside the implementation.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加代码量**：单元测试增加了开发者必须早期编写的代码量。这对于需要原型设计或没有明确要求的任务来说是个问题。开发者不希望编写大量随后需要与实现一起更改的代码。'
- en: '**Increased refactor effort**: While unit tests ensure that refactoring has
    not broken any existing functionality, causing regressions, the tests themselves
    must be refactored in the case of changes in requirements. This can increase the
    cost of refactoring efforts.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加重构工作量**：虽然单元测试确保重构没有破坏任何现有功能，导致回归，但在需求变化的情况下，测试本身必须进行重构。这可能会增加重构工作的成本。'
- en: '**Difficult to identify realistic scenarios**: As the codebase grows and functionality
    becomes more complex, it will be difficult, if not impossible, to test all the
    execution paths of a component. However, as unit tests are written based on code
    and not user requirements, it can be difficult for developers to identify which
    scenarios are realistic and should be covered.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**难以识别现实场景**：随着代码库的增长和功能的复杂化，测试组件的所有执行路径将变得困难，甚至不可能。然而，由于单元测试是基于代码而不是用户需求编写的，开发者可能难以识别哪些场景是现实的，应该被覆盖。'
- en: '**Difficulties testing user interfaces (UIs)**: It is difficult to test UIs
    with unit tests. Usually, they verify business logic, as they traditionally do
    not have libraries available for UI verification.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试用户界面（UI）的困难**：使用单元测试来测试UI是困难的。通常，它们验证业务逻辑，因为它们传统上没有可用于UI验证的库。'
- en: Integration tests are a good way to supplement unit tests, as they address some
    of the disadvantages and limitations of unit tests highlighted previously. Next,
    we will learn how to implement and run them for our Go packages.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试是补充单元测试的好方法，因为它们解决了之前提到的单元测试的一些缺点和局限性。接下来，我们将学习如何为我们的Go包实现和运行它们。
- en: Unit tests are considered good practice
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试被认为是良好的实践
- en: While they do pose some disadvantages, the consensus in the community is that
    they should be used as part of development practice. Understanding their limitations
    highlights what other testing needs we need to cover for the full verification
    of our system.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们确实存在一些缺点，但社区共识是它们应该作为开发实践的一部分来使用。了解它们的局限性突出了我们需要覆盖的其他测试需求，以实现系统的全面验证。
- en: Implementing integration tests
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现集成测试
- en: 'Integration tests and end-to-end tests are often used interchangeably, but
    they each have a scope and purpose in the testing pyramid. *Figure 5**.2* depicts
    the testing pyramid and highlights the difference in scope and speed between integration
    and end-to-end tests:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试和端到端测试经常被互换使用，但它们在测试金字塔中各自都有范围和目的。*图5.2* 展示了测试金字塔，并突出了集成测试和端到端测试在范围和速度上的差异：
- en: '![Figure 5.2 – The distinction between integration and end-to-end tests ](img/Figure_5.02_B18371.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – 集成测试和端到端测试的区别](img/Figure_5.02_B18371.jpg)'
- en: Figure 5.2 – The distinction between integration and end-to-end tests
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 集成测试和端到端测试的区别
- en: 'The difference in speed between integration and end-to-end tests is due to
    the functionality that they cover:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试和端到端测试之间的速度差异是由于它们覆盖的功能：
- en: '**Integration tests** cover one or multiple components, ensuring that the individual
    components work well as a combined entity. While the logic of the particular component
    is verified by its unit tests, the purpose of the integration test is to exercise
    the conditions at the seams between the components.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**涵盖一个或多个组件，确保各个组件作为一个整体运行良好。虽然特定组件的逻辑通过其单元测试得到验证，但集成测试的目的是测试组件之间的接缝处的条件。'
- en: '**End-to-end tests** replicate the usage of the system by the user. They require
    starting up all services and dependencies of the system under test. Then, tests
    that mimic user behavior are written using helper frameworks. These tests verify
    that the system is performing correctly under real-world conditions.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端测试**复制了用户对系统的使用。它们需要启动测试系统下的所有服务和依赖项。然后，使用辅助框架编写模拟用户行为的测试。这些测试验证系统在真实世界条件下的正确运行。'
- en: 'So, if end-to-end tests cover more functionality than integration tests and
    can be automated, why should we bother to implement integration tests? *Figure
    5**.3* depicts some of the drawbacks of end-to-end tests and how integration tests
    address them:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果端到端测试覆盖的功能比集成测试更多，并且可以自动化，为什么我们还要费心实现集成测试？*图5.3* 展示了端到端测试的一些缺点以及集成测试如何解决这些问题：
- en: '![Figure 5.3 – Challenges of end-to-end tests ](img/Figure_5.03_B18371.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 – 端到端测试的挑战](img/Figure_5.03_B18371.jpg)'
- en: Figure 5.3 – Challenges of end-to-end tests
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 端到端测试的挑战
- en: 'All of the tests in the testing pyramid work together to address each other’s
    shortcomings. In particular, integration tests and end-to-end tests work together
    in unison:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 测试金字塔中的所有测试共同工作，以解决彼此的不足。特别是，集成测试和端到端测试协同工作：
- en: Typically, end-to-end tests are performed at **the end of the development process**,
    once the system is relatively stable and can be called end to end. On the other
    hand, integration tests can be performed as soon as the individual components
    are ready, earlier in the development cycle, thereby **shortening the feedback
    loop** and allowing developers to detect bugs earlier on in the project.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，端到端测试是在**开发过程的末尾**进行的，一旦系统相对稳定，可以称为端到端。另一方面，集成测试可以在单个组件准备好后立即进行，在开发周期的早期，从而**缩短反馈循环**，使开发者能够更早地检测到项目中的错误。
- en: As they require more setup and resources, end-to-end tests are **slow and possibly
    expensive** to run. Therefore, engineers might run them as releases and not individual
    code commits. On the other hand, integration tests require much less setup, so
    they are **faster and cheaper to run**. They are often included in the code commit
    checks.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它们需要更多的设置和资源，端到端测试运行起来可能**慢且可能昂贵**。因此，工程师可能会在发布时运行它们，而不是针对单个代码提交。另一方面，集成测试需要的设置要少得多，因此它们**更快且更便宜**。它们通常包含在代码提交检查中。
- en: As previously mentioned, the focus of end-to-end tests is to verify the **test
    user flow and experience** in real-world scenarios. On the other hand, integration
    tests focus on **integration with external and internal modules** in a variety
    of scenarios, such as negative testing and partial outages. These can be difficult
    to set up in end-to-end tests, which require the entire system to be configured.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，端到端测试的焦点是在真实场景中验证**测试用户流程和体验**。另一方面，集成测试侧重于在多种场景下与外部和内部模块的**集成**，例如负面测试和部分中断。这些在端到端测试中可能难以设置，需要配置整个系统。
- en: Integration tests are implemented just as unit tests
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试的实现方式与单元测试相同
- en: We use the same mechanisms for integration tests. We make use of setup functions
    and mocks and table tests to write tests that simply have a larger scope. Furthermore,
    integration tests have the same test signature as unit tests.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的机制进行集成测试。我们利用设置函数和模拟以及表格测试来编写具有更大范围的测试。此外，集成测试具有与单元测试相同的测试签名。
- en: 'The setup for integration tests is slightly more complex than unit tests, as
    multiple components, some of which are external, must be configured and started.
    *Figure 5**.4* shows a typical example of the technologies and configurations
    we might use:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试的设置比单元测试稍微复杂一些，因为必须配置和启动多个组件，其中一些是外部的。*图5**.4*显示了我们可能使用的典型技术和配置示例：
- en: '![Figure 5.4 – Example configuration of integration tests ](img/Figure_5.04_B18371.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 – 集成测试的示例配置](img/Figure_5.04_B18371.jpg)'
- en: Figure 5.4 – Example configuration of integration tests
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 集成测试的示例配置
- en: 'The various parts of the integration tests that need to be configured are as
    follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 需要配置的集成测试的各个部分如下：
- en: The **Component under test** part is initialized. The component under test is
    larger than the UUT, but it is still self-contained and defined within a single
    module. The scope of the integration test is to ensure multiple units work as
    expected, but they are always contained within the single module under test.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**被测试组件**部分被初始化。被测试组件比UUT大，但仍然是一个独立的组件，定义在单个模块内。集成测试的范围是确保多个单元按预期工作，但它们始终包含在单个被测试模块内。'
- en: If required, we initialize the **Database** component with a given seed/start
    position of test data contained inside it. As they are complex, databases are
    rarely mocked and will most often be started and populated before the component
    under test is started. Database start positions are often specified as **SQL files**
    or **JSON files**.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，我们将使用给定的种子/起始位置初始化**数据库**组件，其中包含测试数据。由于数据库复杂，很少进行模拟，通常在启动被测试组件之前启动并填充。数据库的起始位置通常指定为**SQL文件**或**JSON文件**。
- en: Docker makes it easier to configure **Real components** together and is often
    used for system configuration. We will look at how to leverage the power of Docker
    later in this chapter in the *Spinning up and tearing down environments with Docker*
    section.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker使得配置**真实组件**更加容易，常用于系统配置。我们将在本章的“使用Docker启动和关闭环境”部分稍后探讨如何利用Docker的强大功能。
- en: Most often, the component under test will require dependencies for it to start
    and function correctly. These dependencies could be internal to the project or
    external dependencies to the organization, such as a third-party service. These
    external dependencies will be mocked, allowing us to test our component with a
    variety of inputs and conditions.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，被测试的组件将需要依赖项才能启动和正确运行。这些依赖项可能是项目内部的，也可能是组织的外部依赖项，例如第三方服务。这些外部依赖项将被模拟，使我们能够使用各种输入和条件测试我们的组件。
- en: Let’s have a look at an example integration test for our `BookSwap` application,
    which we introduced in [*Chapter 4*](B18371_04.xhtml#_idTextAnchor085), *Building
    Efficient Test Suites*. We will write an integration test for the `GET /` endpoint
    that will return a welcome message and a list of available books. It will also
    allow us to explore testing web applications.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们`BookSwap`应用程序的一个示例集成测试，该应用程序在[*第4章*](B18371_04.xhtml#_idTextAnchor085)中介绍，*构建高效的测试套件*。我们将编写一个针对`GET
    /`端点的集成测试，该端点将返回欢迎信息和可用书籍列表。它还将使我们能够探索测试Web应用程序。
- en: 'The HTTP handler that’s registered to respond to this request is relatively
    simple:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注册以响应此请求的HTTP处理器相对简单：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The implementation of `Handler` highlights the following implementation details:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Handler`的实现突出了以下实现细节：'
- en: We create a custom `Handler` type with all its required dependencies. In the
    case of the `BookSwap` application, we save an instance of `BookService` and an
    instance of `UserService`.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个包含所有必需依赖项的自定义`Handler`类型。在`BookSwap`应用程序的情况下，我们保存了`BookService`的一个实例和`UserService`的一个实例。
- en: The handler has a method for each endpoint that it serves. We create a handler
    method that takes in a `ResponseWriter` and a `Request`. This signature is typical
    of `http.HandlerFunc`, which is an adapter to allow the use of Go functions as
    HTTP handlers.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器为它所服务的每个端点都有一个方法。我们创建了一个接受`ResponseWriter`和`Request`的处理方法。这个签名是`http.HandlerFunc`的典型特征，它是一个适配器，允许将Go函数用作HTTP处理器。
- en: We invoke the `List` function of `BookService` to fetch the list of books and
    construct a response. This custom response is then written to `ResponseWriter`,
    which allows us to easily unmarshal Go structs to HTTP responses.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们调用`BookService`的`List`函数来获取书籍列表并构建响应。然后将这个自定义响应写入`ResponseWriter`，这使得我们能够轻松地将Go结构体反序列化为HTTP响应。
- en: The setup of our handler code is pretty straightforward and will be similar
    to any code you will write for HTTP responses. But how would we test it? We could
    unit test `BookService` and ensure that it functions correctly, but we also need
    to test that the responses the handlers construct are as expected. It’s time to
    write our very first integration test.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们处理器的设置代码相当简单，将类似于您为HTTP响应编写的任何代码。但我们应该如何测试它呢？我们可以对`BookService`进行单元测试，确保它正常工作，但我们还需要测试处理器构建的响应是否符合预期。是时候编写我们的第一个集成测试了。
- en: 'The Go standard library has the `httptest` package ([https://pkg.go.dev/net/http/httptest](https://pkg.go.dev/net/http/httptest)),
    which allows us to easily test HTTP handlers and clients. This package contains
    the functionality for the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准库中的`httptest`包([https://pkg.go.dev/net/http/httptest](https://pkg.go.dev/net/http/httptest))允许我们轻松测试HTTP处理器和客户端。此包包含以下功能：
- en: Starting servers with a specific `http.HandlerFunc` with the `httptest.Server`
    type.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`httptest.Server`类型启动具有特定`http.HandlerFunc`的服务器。
- en: Creating incoming requests to pass to handlers with the `httptest.NewRequest`
    function.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`httptest.NewRequest`函数创建传入的请求以传递给处理器。
- en: Recording responses with the `httptest.ResponseRecorder` type for assertions
    in testing code. The recorder conforms to the `http.ResponseWriter` type and can
    be used in its place in handler code.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`httptest.ResponseRecorder`类型记录响应，以便在测试代码中进行断言。该记录器符合`http.ResponseWriter`类型，可以在处理代码中替代使用。
- en: 'A simple integration test for our `GET /` HTTP handler is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`GET /` HTTP处理器的简单集成测试如下：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `TestIndexIntegration` test is relatively straightforward since it does
    not require any complex request construction or response verification:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestIndexIntegration`测试相对简单，因为它不需要任何复杂的请求构建或响应验证：'
- en: The signature of the test is just like any other unit test. It starts with the
    `Test` prefix and takes in a single parameter of the `*``testing.T` type.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试的签名就像任何其他单元测试一样。它以`Test`前缀开始，并接受一个`*testing.T`类型的单个参数。
- en: Next, we create an instance of `BookService` with a single book as the starting
    position. The purpose of the test is to ensure that `BookService` integrates with
    its handler and returns responses as expected.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用单个书籍作为起始位置创建一个`BookService`实例。测试的目的在于确保`BookService`能够与处理器集成并按预期返回响应。
- en: We create a new handler with the instantiated `BookService`. Then, we pass the
    handler to the `httptest.NewServer` function, which creates and starts a server
    instance to serve our handler. We defer the call to the `Close` function, as this
    server should be shut down at the end of the test execution. This concludes the
    `Arrange` section of our test.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用实例化的`BookService`创建一个新的处理器。然后，我们将处理器传递给`httptest.NewServer`函数，该函数创建并启动一个服务器实例以服务我们的处理器。我们延迟调用`Close`函数，因为这个服务器应该在测试执行结束时关闭。这完成了我们的测试的`Arrange`部分。
- en: The `Act` section of our test is very simple. We invoke the server at its URL
    using the `http.Get` method. This is the same method that our clients will be
    using, and the test is not aware that it is calling a special, mocked server.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的测试中的`Act`部分非常简单。我们使用`http.Get`方法调用服务器的URL。这与我们的客户端将使用的方法相同，测试并不知晓它正在调用一个特殊、模拟的服务器。
- en: Finally, we can run assertions on our response and possible error in the `Assert`
    section of our test. We verify that no error is returned and that the response
    has the `200 OK` HTTP status code.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以在测试的`Assert`部分对响应和可能的错误进行断言。我们验证没有错误返回，并且响应具有`200 OK` HTTP状态码。
- en: Then, we read the body of the response and unmarshal it into our custom response
    type. This makes it easier for us to verify the response, but we could have also
    verified the contents of the response body as a string.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们读取响应体并将其反序列化到我们的自定义响应类型中。这使得我们更容易验证响应，但我们也可以将响应体的内容作为字符串进行验证。
- en: The last assertion verifies that the book instance created in the `Arrange`
    section is contained in the custom response. The test then concludes and the deferred
    call to the server `Close` function is run, cleaning up the server resources set
    up by the test.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个断言验证在`Arrange`部分创建的书籍实例包含在自定义响应中。然后测试结束，并运行对服务器`Close`函数的延迟调用，清理测试设置的服务器资源。
- en: The `httptest` package allows us to seamlessly verify the behavior of HTTP handlers
    and integration tests using the same libraries and functions that clients will
    use. This allows us to write powerful integration tests.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`httptest`包允许我们无缝地使用客户端将使用的相同库和函数来验证HTTP处理器和集成测试的行为。这使我们能够编写强大的集成测试。'
- en: Running integration tests
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行集成测试
- en: 'Integration tests can be run just like any other unit test that we have been
    running so far – by using the `go test` command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试可以像我们迄今为止运行的其他任何单元测试一样运行——通过使用`go test`命令：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The test runs successfully since it has the typical signature of a unit test.
    However, notice that this integration test takes nearly 2 seconds to run on my
    machine. This is the measurement for a particular test run, but I have registered
    runtimes as high as 4 seconds for just this simple `GET` request. As the number
    of integration tests for a particular application grows, they have the potential
    to severely slow down our test suites, even if we run them using `t.Parallel()`,
    as we learned in [*Chapter 4*](B18371_04.xhtml#_idTextAnchor085), *Building Efficient
    Test Suites*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行成功，因为它具有典型单元测试的签名。然而，请注意，这个集成测试在我的机器上运行了近2秒。这是特定测试运行的测量值，但我已经记录了高达4秒的运行时间，仅针对这个简单的`GET`请求。随着特定应用程序集成测试数量的增加，它们有可能严重减慢我们的测试套件，即使我们使用`t.Parallel()`运行它们，正如我们在[*第4章*](B18371_04.xhtml#_idTextAnchor085)，“构建高效的测试套件”中学到的。
- en: It would be great to separate our unit tests and much slower integration tests.
    We could then run unit tests for all commits and integration tests for code releases.
    There is no perfect, built-in way to signal to the test runner which tests are
    integration tests, but we can explore a few options.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 很好地，我们可以将单元测试和较慢的集成测试分开。这样，我们可以为所有提交运行单元测试，为代码发布运行集成测试。没有完美的、内置的方式来向测试运行器指示哪些是集成测试，但我们可以探索一些选项。
- en: Short mode
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简短模式
- en: 'The `go test` command has a built-in flag called `-short` that we can access
    using the `testing.Short()` function. This flag allows us to mark long-running
    tests for skipping by adding a short snippet to their test code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`go test`命令有一个内置的标志`-short`，我们可以通过使用`testing.Short()`函数来访问它。此标志允许我们通过在测试代码中添加一个简短的片段来标记长时间运行的测试以跳过：'
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `t.Skip` method will ensure that this long-running test will be skipped.
    We can then run the tests in short mode by adding the `–short` flag to our test
    command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`t.Skip`方法将确保这个长时间运行的测试将被跳过。然后我们可以通过在测试命令中添加`–short`标志来以简短模式运行测试：'
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As expected, the long-running test is skipped.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，长时间运行的测试被跳过了。
- en: The major downside of this approach is that it requires the user to have special
    knowledge to achieve a fast-running test suite, which should be the default behavior.
    There is no built-in `–long` flag that we can use to execute all (including long-running)
    tests.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的重大缺点是它要求用户具有特殊知识才能实现快速运行的测试套件，而这应该是默认行为。没有内置的`–long`标志可以用来执行所有（包括长时间运行的）测试。
- en: Naming conventions
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名约定
- en: Another option is to use naming conventions, which would not require any special
    code functions to be added to any tests. For example, you could agree with in
    your team that unit tests will end with the `Unit` suffix and integration tests
    with the `Integration` suffix. Depending on the length and contents of the file,
    we could create separate integration and unit test files. Both unit and integration
    tests can use the dedicated test package, named with the `_test` suffix, keeping
    the source and test code dependencies separated.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用命名约定，这不需要在测试中添加任何特殊的代码函数。例如，你可以在团队中达成一致，单元测试将以`Unit`后缀结尾，集成测试以`Integration`后缀结尾。根据文件长度和内容，我们可以创建单独的集成和单元测试文件。单元和集成测试都可以使用专用的测试包，以`_test`后缀命名，以保持源代码和测试代码依赖的分离。
- en: Then, we can make use of the `–run` flag, which we explored in [*Chapter 2*](B18371_02.xhtml#_idTextAnchor035),
    *Unit Testing Essentials*, to instruct the test runner to run a subset of tests
    based on their name. We run all unit tests using the `go test -run Unit ./...`
    command, which will recursively traverse folders to search for any test that contains
    the word `Unit`. Analogously, integration tests will be run using the `go test
    -v -run Integration ./...` command.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`–run`标志，这在[*第2章*](B18371_02.xhtml#_idTextAnchor035)中进行了探讨，即*单元测试基础*，来指示测试运行器根据测试名称运行测试子集。我们使用`go
    test -run Unit ./...`命令运行所有单元测试，该命令将递归遍历文件夹以搜索包含单词`Unit`的任何测试。类似地，集成测试将使用`go test
    -v -run Integration ./...`命令运行。
- en: Unfortunately, this method suffers from the same major downside as short mode,
    as running the default `go test` command without the `–run` flag will cause all
    tests to run, including the slower integration tests.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种方法与简短模式有相同的重大缺点，因为在不添加`–run`标志的情况下运行默认的`go test`命令将导致运行所有测试，包括较慢的集成测试。
- en: Environment variables
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境变量
- en: 'The last option is to create an environment variable to make up for the lack
    of a corresponding flag. Again, we will have to add a short code snippet to our
    test to verify this environment variable:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选项是创建一个环境变量来弥补缺少相应标志的不足。同样，我们不得不在我们的测试中添加一个简短的代码片段来验证这个环境变量：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We make use of the `os.Getenv` method to read environment variables, which will
    return empty if the variable has not been defined. If this variable is empty,
    we skip the integration test, allowing the default behavior of our test suite
    to only run fast tests, skipping integration tests.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`os.Getenv`方法读取环境变量，如果变量未定义，则返回空。如果这个变量为空，我们将跳过集成测试，允许测试套件的默认行为只运行快速测试，跳过集成测试。
- en: 'Running integration tests is easy:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 运行集成测试很简单：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that this version of the command will only run on `CMD` terminals. Alternatively,
    you can set the `LONG` environment variable to '`true`' in your terminal and then
    run the preceding `go test` command on its own after setting this.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个命令版本只能在`CMD`终端上运行。或者，你可以在你的终端中将`LONG`环境变量设置为"`true`"，然后设置此变量后单独运行前面的`go
    test`命令。
- en: We will make use of the environment variables solution going forward. The expected
    default behavior of the test suite is to run fast-running unit tests. This solution
    allows us to keep specialized knowledge out of the expected default behavior and
    makes it easy to run integration tests when required. It also integrates well
    with containerization technologies such as Docker, which we will explore later
    in this chapter.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用环境变量解决方案继续前进。测试套件的预期默认行为是运行快速运行的单元测试。此解决方案允许我们将专用知识排除在预期默认行为之外，并使得在需要时运行集成测试变得容易。它还很好地与Docker等容器化技术集成，我们将在本章后面探讨。
- en: Behavior-driven testing
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为驱动测试
- en: We have now learned how to supplement unit tests with integration tests, increasing
    the scope of our component under test. End-to-end tests have the most scope as
    they test the entirety of our system. They are often discussed together with **behavior-driven
    design** (**BDD**), which is a branch of TDD that focuses on writing human-readable
    tests based on user requirements.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了如何通过集成测试来补充单元测试，从而扩大我们正在测试的组件的范围。端到端测试具有最大的范围，因为它们测试了我们的整个系统。它们通常与**行为驱动设计**（**BDD**）一起讨论，BDD是TDD的一个分支，它侧重于根据用户需求编写人类可读的测试。
- en: Fundamentals of BDD
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BDD的基础
- en: 'The first step of BDD practitioners is to establish a shared vocabulary between
    the different interested parties: business stakeholders, domain experts, and various
    other engineering functions.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: BDD实践者的第一步是在不同的利益相关者之间建立共享的词汇：业务利益相关者、领域专家以及各种其他工程职能。
- en: Based on this shared and well-understood vocabulary, the user requirements are
    then converted into **user acceptance tests** (**UATs**). These tests are end-to-end
    tests that ensure that system requirements are covered by all new releases.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个共享且易于理解的词汇表，用户需求随后被转换为**用户验收测试**（**UATs**）。这些测试是端到端测试，确保所有新版本都涵盖了系统需求。
- en: 'Tests are usually written in the `GET /` endpoint we have previously implemented
    looks like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通常编写在之前实现的`GET /`端点上，看起来像这样：
- en: '**Story: View the list** **of books**'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**故事：查看书籍列表** ****'
- en: '**Given** a user'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Given** 一个用户'
- en: '`GET /` root endpoint'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /` 根端点'
- en: '**Then** the list of available books is returned to the user'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Then** 将可用的书籍列表返回给用户'
- en: 'The test specification reads like plain English and establishes the main aspects
    of the test case:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 测试规范读起来像普通的英语，并确立了测试用例的主要方面：
- en: Who the main actor of the test case is
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试用例的主要行为者是谁
- en: What their expected behavior is
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们的预期行为是什么
- en: What the user will get from the performed action
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户将从执行的操作中获得什么
- en: Note that the test case does not specify any implementation details of the application
    and instead focuses on *the behavior* of the application. Test cases treat the
    application as a **black box**. This simplicity is the power of BDD, where test
    specifications are not something that only engineers and testing professionals
    can write.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，测试用例没有指定应用程序的任何实现细节，而是专注于*应用程序的行为*。测试用例将应用程序视为一个**黑盒**。这种简单性是行为驱动开发（BDD）的力量所在，因为测试规范不是只有工程师和测试专业人员才能编写的东西。
- en: BDD is about bridging gaps
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: BDD是关于弥合差距
- en: The emphasis on shared language and easily readable tests ensures that the gaps
    between technical and non-technical stakeholders are bridged. This avoids misunderstandings
    and delays in the implementation of the system’s intended behavior.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对共享语言和易于阅读的测试的强调确保了技术利益相关者和非技术利益相关者之间的差距得到弥合。这避免了在实施系统预期行为时的误解和延迟。
- en: '*Figure 5**.5* highlights some of the advantages and disadvantages of writing
    tests using BDD:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5**.5*突出了使用BDD编写测试的一些优点和缺点：'
- en: '![Figure 5.5 – Advantages and disadvantages of writing BDD tests ](img/Figure_5.05_B18371.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5 – 编写BDD测试的优点和缺点](img/Figure_5.05_B18371.jpg)'
- en: Figure 5.5 – Advantages and disadvantages of writing BDD tests
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 编写BDD测试的优点和缺点
- en: 'The following are the advantages of BDD:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下BDD的优点：
- en: '**Single source of truth**: The biggest advantage of BDD is that it allows
    teams to have a single source of truth for the intended behavior of the application.
    Furthermore, we have a unified vocabulary to express this behavior across the
    business.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一事实来源**：BDD最大的优点是它允许团队有一个单一的事实来源，用于应用程序的预期行为。此外，我们有一个统一的词汇来表达业务中的这一行为。'
- en: '**Tests as documentation**: While unit tests can also serve as documentation
    for the application, BDD tests are easier to read and understand, since they focus
    on readability.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试作为文档**：虽然单元测试也可以作为应用程序的文档，但BDD测试更容易阅读和理解，因为它们侧重于可读性。'
- en: '**Specific behaviors**: With their Given-When-Then structure, BDD tests encourage
    writing test cases for specific behavior. This often helps narrow down larger
    and potentially vague user requirements that have been established at the beginning
    of the project.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体行为**：通过它们的Given-When-Then结构，BDD测试鼓励编写针对特定行为的测试用例。这通常有助于缩小在项目初期建立的大型和可能模糊的用户需求。'
- en: '**Wider involvement**: Anyone in the team or the business can contribute to
    the specification of these tests, making it easier to detect any bugs or functional
    oversights early on.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更广泛的参与度**：团队或业务中的任何人都可参与到这些测试规范的制定中，这使得早期发现任何错误或功能疏忽变得更加容易。'
- en: 'And here are the disadvantages:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是它的缺点：
- en: '**Time-consuming**: It can be time-consuming to get multiple stakeholders together
    to establish test cases at the beginning of the project. Furthermore, it can also
    be time-consuming to maintain these tests during the lifetime of the project.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**耗时**：在项目开始时将多个利益相关者聚集在一起建立测试用例可能会很耗时。此外，在项目生命周期内维护这些测试也可能很耗时。'
- en: '**Requires commitment**: The different stakeholders need to commit to taking
    on the work of specifying and discussing these test cases upfront.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**需要承诺**：不同的利益相关者需要承诺在项目开始时承担指定和讨论这些测试用例的工作。'
- en: '**Dependent on good BDD practices**: Unless correctly specified together with
    the correct stakeholders, BDD tests can become ambiguous and difficult to implement.
    The successful specification of tests is therefore dependent on good BDD practices
    in the business.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖于良好的 BDD 实践**：除非与正确的利益相关者正确地一起指定，否则 BDD 测试可能会变得模糊且难以实施。因此，测试的成功指定依赖于业务中良好的
    BDD 实践。'
- en: Now that we understand some of the advantages of BDD tests and how to write
    them, we can turn our attention to implementing them in Go.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了一些 BDD 测试的优势以及如何编写它们，我们可以将注意力转向在 Go 中实现它们。
- en: Implementing BDD tests with Ginkgo
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Ginkgo 实现 BDD 测试
- en: In [*Chapter 3*](B18371_03.xhtml#_idTextAnchor061), *Mocking and Assertion Frameworks*,
    we learned how to create mocks and write assertions with the `testify` open source
    testing library. This allows us to create streamlined unit tests and easily create
    mocks. However, a more expressive testing library was required to easily produce
    BDD-style tests.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 3 章*](B18371_03.xhtml#_idTextAnchor061)，*模拟和断言框架* 中，我们学习了如何使用 `testify`
    开源测试库创建模拟和编写断言。这使我们能够创建简化的单元测试并轻松创建模拟。然而，需要一个更具表达力的测试库来轻松生成 BDD 风格的测试。
- en: The `ginkgo` ([https://github.com/onsi/ginkgo](https://github.com/onsi/ginkgo))
    project was started in 2013 to fill this need. It is a testing framework built
    on top of Go’s `testing` package and it is designed to help us write expressive
    BDD tests. It is used together with the `gomega` ([https://github.com/onsi/gomega](https://github.com/onsi/gomega))
    matcher library, which exposes assertion matchers that we can use in our tests.
    This framework received mixed support from the community, as it brought the Ruby
    way of writing tests to Go. However, it is currently the default way to write
    BDD-style tests and it is an important part of our TDD journey.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`ginkgo` ([https://github.com/onsi/ginkgo](https://github.com/onsi/ginkgo))
    项目始于 2013 年，旨在满足这一需求。它是一个建立在 Go 的 `testing` 包之上的测试框架，旨在帮助我们编写表达式的 BDD 测试。它与 `gomega`
    ([https://github.com/onsi/gomega](https://github.com/onsi/gomega)) 匹配器库一起使用，该库暴露了我们可以用于测试的断言匹配器。这个框架得到了社区的混合支持，因为它将
    Ruby 风格的测试方式引入了 Go。然而，它目前是编写 BDD 风格测试的默认方式，并且是我们 TDD 旅程的一个重要部分。'
- en: 'The `Ginkgo` library supports Go modules and can easily be installed with the
    `go install` command, just like `testify`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ginkgo` 库支持 Go 模块，并且可以使用 `go install` 命令轻松安装，就像 `testify` 一样：'
- en: '[PRE7]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Ginkgo installation location
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Ginkgo 安装位置
- en: The `install` command will install the `ginkgo` CLI in your `$GOBIN` path, so
    ensure that it is set accordingly before you install it. By default, the `$GOBIN`
    path is `$GOPATH/bin`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`install` 命令将在您的 `$GOBIN` 路径中安装 `ginkgo` CLI，因此请在安装之前确保它已正确设置。默认情况下，`$GOBIN`
    路径是 `$GOPATH/bin`。'
- en: 'The `go get` command then fetches the `gomega` assertion library:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`go get` 命令随后会获取 `gomega` 断言库：'
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Ginkgo tests live in `_test.go` files, just like regular unit tests, but they
    are organized in test suites. Suites can be compared to the table tests that we
    previously implemented, where we grouped tests by similar functionality and scenarios.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Ginkgo 测试位于 `_test.go` 文件中，就像常规单元测试一样，但它们被组织在测试套件中。套件可以比作我们之前实现的表格测试，其中我们将测试按相似的功能和场景分组。
- en: 'Suites are generated in the current directory using the `ginkgo` `bootstrap`
    command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ginkgo` `bootstrap` 命令在当前目录下生成测试套件：
- en: '[PRE9]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The file is named according to the package declared in the current directory.
    The generated file contains the package declaration and some essential code for
    the suite’s declaration. Note that this command will fail if a suite already exists.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 文件命名根据当前目录中声明的包命名。生成的文件包含包声明和套件声明的某些基本代码。请注意，如果套件已存在，此命令将失败。
- en: The `bootstrap` command is a convenient way to generate this boilerplate for
    us and ensure that all test files have the same basic structure, across our all
    projects. It also ensures that our suites’ naming is consistent, so it is a powerful
    standardization tool.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`bootstrap`命令是生成此样板代码的便捷方式，并确保所有测试文件都具有相同的基本结构，跨所有项目。它还确保我们的套件命名一致，因此是一个强大的标准化工具。'
- en: Testing terminology
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 测试术语
- en: '`ginkgo` uses the same terminology as the `ginkgo` tests going forward.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`ginkgo`将使用与`ginkgo`测试相同的术语。'
- en: 'The generated `chapter05/handlers/handlers_suite_test.go`, contains the following
    code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的`chapter05/handlers/handlers_suite_test.go`包含以下代码：
- en: '[PRE10]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This file contains the necessary information for interacting with the `ginkgo`
    runner:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件包含与`ginkgo`运行器交互所需的必要信息：
- en: The suite test file is declared inside the `handlers_test` package corresponding
    to this directory. The separate `_test` package ensures that we only test the
    exported functionality of the source package. This is essential to writing integration
    tests that only assert the external behavior of the API.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 套件测试文件声明在对应此目录的`handlers_test`包内部。单独的`_test`包确保我们只测试源包导出的功能。这对于编写只断言API外部行为的集成测试至关重要。
- en: The `ginkgo` and `gomega` libraries are imported using the dot (`.`) operator.
    This allows us to have access to test and assertion functionality without having
    to qualify each function with the package name. This can be disabled, but it is
    discouraged by the BDD community, as tests should read as naturally as possible.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用点(`.`)运算符导入`ginkgo`和`gomega`库。这允许我们访问测试和断言功能，而无需在每个函数前加上包名。这可以被禁用，但BDD社区不鼓励这样做，因为测试应该尽可能自然地阅读。
- en: The signature of the test is as expected. The test signature takes in a single
    parameter of the `*testing.T` type. This is the entry point of our generated suite.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试的签名与预期相符。测试签名接受一个`*testing.T`类型的单个参数。这是我们的生成套件的入口点。
- en: The test contains two calls to the `Ginkgo` test runner. We will not spend too
    much time discussing the internals of these functions, but, as all the testing
    library is open source, you can look up what they do yourself. The call to `RunSpecs`
    instructs the test runner to begin running the suite and execute all existing
    specs.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试包含对`Ginkgo`测试运行器的两次调用。我们不会过多地讨论这些函数的内部结构，但，由于所有测试库都是开源的，您可以自己查找它们的功能。对`RunSpecs`的调用指示测试运行器开始运行套件并执行所有现有规格。
- en: The suite only serves as an entry point for the specs to begin executing, which
    are usually defined in separate test files.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 套件仅作为规格开始执行的人口点，这些规格通常定义在单独的测试文件中。
- en: 'We define `ginkgo` equivalent to the `Index` endpoint integration test that
    we previously saw in the *Implementing integration tests* section in the `chapter05/handlers/handlers_index_test.go`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`ginkgo`定义为与我们在`第五章/handlers/handlers_index_test.go`中的`Implementing integration
    tests`部分之前看到的`Index`端点集成测试等效：
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The Ginkgo equivalent of our `Index` integration test seems quite different
    from the code we are used to seeing. Its focus is on setting up the various aspects
    of the test in an easy-to-read **spec tree**:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`Index`集成测试的Ginkgo等效似乎与我们习惯看到的代码有很大不同。它的重点是轻松阅读的**spec树**中设置测试的各个方面：
- en: We make use of closures to set up our spec hierarchy. The `Describe` function
    allows us to create `Describe` node.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用闭包来设置我们的规格层次结构。`Describe`函数允许我们创建`Describe`节点。
- en: The `BeforeEach` function creates **setup nodes** that run before tests. They
    are used for extracting common setups, allowing us to streamline our tests.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BeforeEach`函数创建在测试之前运行的**设置节点**。它们用于提取公共设置，使我们能够简化测试。'
- en: The `AfterEach` function creates setup nodes that run after tests. They allow
    us to clean up after our specs have run, ensuring that critical resources are
    cleaned up correctly.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AfterEach`函数创建在测试之后运行的设置节点。它们允许我们在规格运行后进行清理，确保关键资源被正确清理。'
- en: We can further define container nodes inside the top-level nodes as required
    to organize our specs and their scenarios.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以根据需要在内层节点中进一步定义容器节点，以组织我们的规格及其场景。
- en: The `Context` function is an alias for `Describe` that allows us to add extra
    information to our specs to help people understand them. It also creates container
    nodes but can be used to organize information.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Context` 函数是 `Describe` 的别名，它允许我们向我们的 spec 添加额外信息以帮助人们理解它们。它还创建容器节点，但可以用来组织信息。'
- en: The `It` function allows us to define **subject nodes**. These nodes contain
    the assertions of the subject under test and cannot contain any other nested nodes.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`It` 函数允许我们定义**主题节点**。这些节点包含被测试主题的断言，并且不能包含任何其他嵌套节点。'
- en: The assertions inside the subject nodes are written with the `gomega` assertion
    library. These can be nested just like the assertions of `testify` but take a
    human-readable form. All assertions must begin with the `Expect` function, which
    wraps an actual value.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题节点内的断言是用 `gomega` 断言库编写的。这些可以像 `testify` 的断言一样嵌套，但采用人类可读的形式。所有断言都必须以 `Expect`
    函数开始，它包装了一个实际值。
- en: '*Figure 5**.6* shows a visual representation of the structure of the spec tree:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5**.6* 展示了 spec 树结构的视觉表示：'
- en: '![Figure 5.6 – The structure of the spec tree ](img/Figure_5.06_B18371.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – spec 树的结构](img/Figure_5.06_B18371.jpg)'
- en: Figure 5.6 – The structure of the spec tree
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – spec 树的结构
- en: All tests begin with a `Describe` container node. This top-level node can then
    contain multiple `BeforeEach` setup nodes, multiple `AfterEach` nodes, other `Context`
    container nodes, and multiple `It` subject nodes. As we saw in the handlers integration
    test, these nodes are arranged to build a hierarchy that reflects our test scenario.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试都以一个 `Describe` 容器节点开始。然后，这个顶级节点可以包含多个 `BeforeEach` 设置节点、多个 `AfterEach`
    节点、其他 `Context` 容器节点和多个 `It` 主题节点。正如我们在处理程序集成测试中看到的那样，这些节点被安排来构建一个反映我们的测试场景的层次结构。
- en: Nesting rules
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套规则
- en: The spec tree consists of nested container nodes. Setup nodes can be nested
    inside them. Like the behavior of deferred functions, the innermost function will
    run first. Then, the others will continue in the same fashion going outward.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: spec 树由嵌套的容器节点组成。设置节点可以嵌套在其中。就像延迟函数的行为一样，最内层的函数将首先运行。然后，其他函数将按相同的方式向外继续运行。
- en: 'Once we have generated our suite and populated it with specs, we can run it
    by using the `ginkgo` command:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们生成了套件并用 spec 填充了它，我们就可以通过使用 `ginkgo` 命令来运行它：
- en: '[PRE12]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Just like the `go test` command we have used so far, `ginkgo` also supports
    the `./...` operator, which will traverse subdirectories and look for suites to
    run.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前使用的 `go test` 命令一样，`ginkgo` 也支持 `./...` 操作符，它将遍历子目录并查找要运行的套件。
- en: As we can see from the output, the container nodes and subject nodes are used
    to construct meaningful names for the spec suite. Ginkgo allows us to construct
    test collections with meaningful test outputs. We will continue to explore it
    in future chapters.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中我们可以看到，容器节点和主题节点用于为 spec 套件构建有意义的名称。Ginkgo 允许我们构建具有有意义的测试输出的测试集合。我们将在未来的章节中继续探讨它。
- en: Understanding database testing
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解数据库测试
- en: In the world of testing, databases are often overlooked in literature. Most
    applications often assume in-memory data storage, just as we have done with the
    `BookSwap` application so far. However, it is important to understand the difficulties
    and techniques that we have available when it comes to verifying our databases.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试的世界里，数据库在文献中经常被忽视。大多数应用程序通常假设内存数据存储，就像我们到目前为止在 `BookSwap` 应用程序中所做的那样。然而，了解我们在验证数据库时面临的困难和可用技术是很重要的。
- en: 'Databases are often seen as external systems or black boxes in our system.
    They provide specialized behavior and are often complex systems, which most often
    cannot fail. *Figure 5**.6* depicts the typical data translation between different
    formats:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库通常被视为我们的系统中的外部系统或黑盒。它们提供特定的行为，通常是复杂的系统，通常不能失败。*图 5**.6* 描述了不同格式之间的典型数据转换：
- en: '![Figure 5.7 – The data formats of a typical system ](img/Figure_5.07_B18371.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – 典型系统的数据格式](img/Figure_5.07_B18371.jpg)'
- en: Figure 5.7 – The data formats of a typical system
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 典型系统的数据格式
- en: Data changes formats multiple times in a typical application. User requests
    usually enter our system in **JSON** format. The **API layer** area then translates
    these requests to the internal application models and sends them further down
    the stack to the **Service layer** area. Finally, the **Service layer** area persists
    these in the database using **SQL** or whatever the expected format of the database
    is. Often, **NoSQL databases** will save their data back in **JSON** format and
    persist it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的应用程序中，数据格式会多次改变。用户请求通常以**JSON**格式进入我们的系统。然后**API层**将这些请求转换为内部应用程序模型，并将它们发送到堆栈的下一层，即**服务层**区域。最后，**服务层**使用**SQL**或数据库预期的任何格式将这些数据持久化到数据库中。通常，**NoSQL数据库**会将数据以**JSON**格式保存并持久化。
- en: 'We should write tests that cover the following aspects of our database systems:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该编写测试来覆盖我们数据库系统的以下方面：
- en: '**Startup and availability**: The application should wait for the database
    to become available and should do so in an efficient manner.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动和可用性**：应用程序应该等待数据库变得可用，并且应该以高效的方式进行。'
- en: '**Persistence and querying**: Once data is stored in the database, it should
    be correctly stored and fetched. This is done by the business logic and should
    be verified to be implemented correctly.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久化和查询**：一旦数据存储在数据库中，它应该被正确存储和检索。这是通过业务逻辑完成的，并且应该验证其正确实现。'
- en: '**Performance testing**: This type of non-functional testing is important for
    the database, which typically powers all the requests in the application. Typical
    verifications include load testing using large files or results counts, running
    tests using multiple remote users, and any edge cases regarding the values of
    the column/field values of the database payloads.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能测试**：这种非功能性测试对于数据库非常重要，因为数据库通常为应用程序中的所有请求提供动力。典型的验证包括使用大文件或结果计数进行负载测试，使用多个远程用户运行测试，以及任何关于数据库有效载荷列/字段值的边缘情况。'
- en: These crucial aspects of our systems should be covered by testing, especially
    around the points where data formats vary and translations occur. These format
    translations can be the cause of bugs and outages. For example, one field might
    be a mandatory non-nullable value at the database level, but be missing further
    up the stack.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们系统的这些关键方面应该通过测试得到覆盖，特别是在数据格式变化和转换发生的地方。这些格式转换可能是错误和中断的原因。例如，一个字段可能在数据库级别是一个强制性的非空值，但在更高的堆栈级别可能缺失。
- en: Mocks as databases
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟数据库
- en: It might be tempting to assume that a mock would be fitting to wrap around complex
    external behavior, but the community generally discourages this as an engineering
    anti-pattern. End-to-end and integration tests should verify and run against the
    databases that they use in production to avoid differences in functionality and
    performance.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会诱使人们认为模拟适合围绕复杂的外部行为进行包装，但社区普遍不鼓励这种作为工程反模式的做法。端到端和集成测试应该验证并针对它们在生产中使用的数据库运行，以避免功能性和性能上的差异。
- en: Useful libraries
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有用的库
- en: 'Fortunately, the Go ecosystem provides some great libraries to allow us to
    easily integrate databases into our applications. Here are some Go libraries that
    you will find useful when integrating databases into your Go applications:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Go生态系统提供了一些优秀的库，使我们能够轻松地将数据库集成到我们的应用程序中。以下是一些在将数据库集成到Go应用程序时你会发现有用的Go库：
- en: '`go-testfixtures` ([https://github.com/go-testfixtures/testfixtures](https://github.com/go-testfixtures/testfixtures)):
    An open source library that makes it easy to write functional database tests.
    It uses the **Ruby on Rails** way of setting up data samples using fixtures files.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go-testfixtures` ([https://github.com/go-testfixtures/testfixtures](https://github.com/go-testfixtures/testfixtures))：一个开源库，它使得编写功能数据库测试变得容易。它使用**Ruby
    on Rails**的方式通过固定文件设置数据样本。'
- en: '`golang-migrate` ([https://github.com/golang-migrate/migrate](https://github.com/golang-migrate/migrate)):
    An open source library that makes setting up database startup positions easy,
    without us having to write our own data formats and files. It supports a variety
    of SQL and NoSQL databases.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`golang-migrate` ([https://github.com/golang-migrate/migrate](https://github.com/golang-migrate/migrate))：一个开源库，它使得设置数据库启动位置变得容易，而无需我们编写自己的数据格式和文件。它支持多种SQL和NoSQL数据库。'
- en: '`go-txdb` ([https://github.com/DATA-DOG/go-txdb](https://github.com/DATA-DOG/go-txdb)):
    An open source library that runs database queries in transactions. Once the tests
    are complete, transactions are rolled back and data is not persisted. This allows
    us to run our tests in isolation on top of a real database.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go-txdb` ([https://github.com/DATA-DOG/go-txdb](https://github.com/DATA-DOG/go-txdb)):
    这是一个开源库，可以在事务中运行数据库查询。一旦测试完成，事务就会回滚，数据不会持久化。这允许我们在真实数据库之上独立运行我们的测试。'
- en: '`gorm` ([https://github.com/go-gorm/gorm](https://github.com/go-gorm/gorm)):
    A popular open source library that provides **object-relational mapping** (**ORM**).
    This developer-friendly library makes it easier to convert database types into
    useful custom structs.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gorm` ([https://github.com/go-gorm/gorm](https://github.com/go-gorm/gorm)):
    这是一个流行的开源库，提供了**对象关系映射**（ORM）。这个面向开发者的库使得将数据库类型转换为有用的自定义结构体变得更加容易。'
- en: '`bun` ([https://github.com/uptrace/bun](https://github.com/uptrace/bun)): This
    is the new, rewritten version of the `go-pg` ([https://github.com/go-pg/pg](https://github.com/go-pg/pg))
    project. This project provides ORM functionality for multiple SQL databases.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bun` ([https://github.com/uptrace/bun](https://github.com/uptrace/bun)): 这是
    `go-pg` ([https://github.com/go-pg/pg](https://github.com/go-pg/pg)) 项目的全新重写版本。该项目为多个
    SQL 数据库提供 ORM 功能。'
- en: The literature on whether to use SQL or NoSQL databases is vast and involves
    a wide set of recommendations. We will not start this discussion here, but SQL
    databases remain the most popular database solutions. We will focus on how to
    implement and test SQL databases in our discussions going forward. We will also
    see some of the libraries we mentioned in this section in action going forward.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 关于是否使用 SQL 或 NoSQL 数据库的文献非常丰富，涉及广泛的建议。我们在这里不会开始这个讨论，但 SQL 数据库仍然是最受欢迎的数据库解决方案。我们将专注于在未来的讨论中如何实现和测试
    SQL 数据库。我们还将看到一些在本节中提到的库的实际应用。
- en: Spinning up and tearing down environments with Docker
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 启动和关闭环境
- en: The final topic we will cover in our exploration of integration and end-to-end
    testing is **containerization** using the popular technology known as Docker.
    It provides us with the ability to start up applications in our local and remote
    environments in the same way.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索集成和端到端测试的过程中，我们将讨论的最后一个主题是使用称为 Docker 的流行技术进行的**容器化**。它使我们能够在本地和远程环境中以相同的方式启动应用程序。
- en: Docker gives developers the confidence that their applications will behave in
    the same way across environments, which is particularly useful for managing and
    deploying test environments.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 给开发者信心，他们的应用程序将在不同的环境中以相同的方式运行，这对于管理和部署测试环境尤其有用。
- en: Fundamentals of Docker
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 基础
- en: A **container** is a unit of software that bundles up code and all its dependencies,
    enabling us to run it in multiple environments. The specification of the container
    is known as a **container image**. Docker Engine interprets the specification
    of container images and turns them into containers.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器**是一个软件单元，它将代码及其所有依赖项捆绑在一起，使我们能够在多个环境中运行它。容器的规范称为**容器镜像**。Docker 引擎解释容器镜像的规范，并将它们转换为容器。'
- en: Containerization versus virtualization
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化与虚拟化
- en: '**Virtualization** refers to running multiple operating systems on a single
    machine. Containerization refers to running multiple applications developed in
    the environment of one operating system on a single machine.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**虚拟化**指的是在单台机器上运行多个操作系统。容器化指的是在单台机器上运行在一个操作系统环境中开发的多个应用程序。'
- en: '*Figure 5**.7* depicts containers running on the host environment:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.7* 展示了在宿主环境中运行的容器：'
- en: '![Figure 5.8 – Running containers with Docker ](img/Figure_5.08_B18371.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8 – 使用 Docker 运行容器](img/Figure_5.08_B18371.jpg)'
- en: Figure 5.8 – Running containers with Docker
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 使用 Docker 运行容器
- en: Containers are lightweight, allowing multiple containers to run on the same
    physical hardware. **Docker Engine** oversees managing them and enforcing isolation
    levels, ensuring that malicious code cannot escape outside of its current namespace,
    but also importantly ensuring that tests have a realistic level of isolation.
    In practice, this means that we can download and run a set of images for complex
    systems to run on shared hardware.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 容器轻量级，允许在相同的物理硬件上运行多个容器。**Docker 引擎**负责管理它们并强制执行隔离级别，确保恶意代码不能逃出其当前命名空间之外，同时也重要的是确保测试具有现实级别的隔离。在实践中，这意味着我们可以下载并运行一组图像，以便在共享硬件上运行复杂的系统。
- en: 'For example, we could run multiple containers on shared infrastructure: a Go
    web application, a database, event buses and queues, monitoring, and so on. All
    these different technologies and images can be managed by a single **standardized
    technology** with Docker Engine.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在共享基础设施上运行多个容器：一个 Go 网络应用程序、数据库、事件总线、队列、监控等。所有这些不同的技术和镜像都可以通过 Docker
    引擎的单个 **标准化技术** 进行管理。
- en: Using Docker
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Docker
- en: The concept of containerization does not belong to Docker exclusively, but we
    will refer only to the usage of Docker going forward. Docker Engine can easily
    be installed by following the official documentation available at [https://www.docker.com/get-started/](https://www.docker.com/get-started/).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化的概念并不专属于 Docker，但我们将只从 Docker 的使用角度进行讨论。Docker 引擎可以通过遵循官方文档轻松安装，官方文档可在 [https://www.docker.com/get-started/](https://www.docker.com/get-started/)
    获取。
- en: 'Docker Engine ships with a powerful CLI that contains two main commands:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 引擎附带了一个强大的命令行界面（CLI），其中包含两个主要命令：
- en: '`docker` deploys and manages a single application or container. The Docker
    CLI offers an extensive list of commands and options, some of the most common
    being these:'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker` 部署和管理单个应用程序或容器。Docker CLI 提供了广泛的命令和选项，其中一些最常见的是以下这些：'
- en: '`docker pull` downloads an image from the image repository, named `docker run`
    creates a container from an image. If the image is not available locally, it will
    be downloaded from the image repository, prolonging the container startup time.'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker pull` 从镜像仓库下载镜像，`docker run` 从镜像创建容器。如果镜像不在本地，它将从镜像仓库下载，从而延长容器启动时间。'
- en: '`docker ps` lists all the locally running containers. This command is commonly
    used to get the unique container ID for each container. These unique IDs can then
    be used to reference specific containers in other commands.'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker ps` 列出所有本地正在运行的容器。此命令通常用于获取每个容器的唯一容器 ID。然后可以使用这些唯一 ID 在其他命令中引用特定的容器。'
- en: '`docker stop` instructs the container to shut down, giving it time to gracefully
    shut down and clean up its resources. Docker Engine makes use of operating system
    signals to communicate shutdown to containers. Containers can then be restarted
    using the `docker start` command.'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker stop` 指示容器关闭，给它时间优雅地关闭并清理其资源。Docker 引擎使用操作系统信号与容器通信关闭。然后可以使用 `docker
    start` 命令重新启动容器。'
- en: '`docker kill` instructs the container to stop its execution immediately, without
    allowing time for graceful shutdown.'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker kill` 指示容器立即停止其执行，不允许进行优雅的关闭。'
- en: '`docker exec` allows us to access a running container. Since containers are
    isolated from the rest of the operating system, the only way to have access to
    its resources and setup is to request access from Docker Engine.'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker exec` 允许我们访问正在运行的容器。由于容器与操作系统的其余部分隔离，访问其资源和设置的唯一方式是请求 Docker 引擎的访问。'
- en: '`docker compose` deploys and manages multiple containers within the same single
    host. This allows us to configure and start multiple containers with a single
    command, as opposed to starting them each individually with the `docker` command.
    Another key advantage is that the containers will be running and networking as
    a single group, making it easy to deploy complex systems across environments.
    Some of the most common `docker compose` commands are as follows:'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker compose` 在同一主机上部署和管理多个容器。这使得我们可以使用单个命令配置和启动多个容器，而不是使用 `docker` 命令逐个启动它们。另一个关键优势是容器将作为一个单一组运行和联网，这使得跨环境部署复杂系统变得容易。以下是一些最常见的
    `docker compose` 命令：'
- en: '`docker compose up` starts the specified containers of a given `.yml` file.'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker compose up` 启动给定 `.yml` 文件中指定的容器。'
- en: '`docker compose ps` lists the containers of a Compose project, including their
    statuses and registered ports. These containers will also be visible when running
    the `docker ps` command, but this command will output more container information.'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker compose ps` 列出 Compose 项目的容器，包括其状态和注册的端口。当运行 `docker ps` 命令时，这些容器也将可见，但此命令将输出更多容器信息。'
- en: '`docker compose stop` instructs running containers to stop, without removing
    them. They can then be restarted again using the `docker compose` `start` command.'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker compose stop` 指示正在运行的容器停止，但不删除它们。然后可以使用 `docker compose` 的 `start`
    命令重新启动它们。'
- en: '`docker compose kill` forces containers to immediately stop using the `SIGKILL`
    system signal.'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker compose kill` 强制容器立即停止，使用 `SIGKILL` 系统信号。'
- en: That’s all the basics we need to know to install Docker Engine and perform some
    basic tasks with Docker. In [*Chapter 6*](B18371_06.xhtml#_idTextAnchor142), *End-To-End
    Testing the BookSwap Web Application*, we will look at the configuration of the
    custom Dockerfile for our application, the changes we need to make to our existing
    implementation to make use of a database, and how to run end-to-end tests based
    on these easy to spin up and tear down containers.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们安装Docker Engine和执行一些基本Docker任务所需了解的所有基础知识。在[*第6章*](B18371_06.xhtml#_idTextAnchor142)，“对BookSwap
    Web应用程序进行端到端测试”，我们将查看我们应用程序的自定义Dockerfile的配置，我们需要对我们现有的实现进行哪些更改以使用数据库，以及如何基于这些易于启动和关闭的容器运行端到端测试。
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we moved on from focusing on unit tests, which verify the functionality
    of code in small isolated units. We began with an introduction to the importance
    of integration testing and learned how to write and run integration tests for
    HTTP handlers using the `httptest` library. Then, we learned what the practice
    of writing BDD-style tests entails and how to implement them using the `ginkgo`
    testing library. Then, we discussed the importance of testing databases and what
    useful libraries there are available to us to be able to write these. Finally,
    we covered the advantages of containerization and learned how to use Docker and
    configure services with `docker compose`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从关注单元测试，即验证代码在小型隔离单元中的功能，转向了。我们首先介绍了集成测试的重要性，并学习了如何使用`httptest`库编写和运行HTTP处理器的集成测试。然后，我们学习了编写BDD风格测试的实践，以及如何使用`ginkgo`测试库实现它们。然后，我们讨论了测试数据库的重要性，以及有哪些有用的库可供我们编写这些测试。最后，我们介绍了容器化的优势，并学习了如何使用Docker以及如何使用`docker
    compose`配置服务。
- en: In [*Chapter 6*](B18371_06.xhtml#_idTextAnchor142), *End-To-End Testing the
    BookSwap Web Application*, we will expand on all the fundamentals of the technologies
    we have learned so far and apply them to test the `BookSwap` web application.
    This will give us good hands-on practice to configure a typical web application
    that has a simple database dependency.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B18371_06.xhtml#_idTextAnchor142)，“对BookSwap Web应用程序进行端到端测试”，我们将深入探讨我们迄今为止所学的所有技术基础，并将它们应用于测试`BookSwap`
    Web应用程序。这将为我们提供良好的实践机会，以配置一个具有简单数据库依赖的典型Web应用程序。
- en: Questions
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章知识的掌握：
- en: What is the difference between integration tests and end-to-end tests?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集成测试和端到端测试之间的区别是什么？
- en: What is **behavior-driven** **design** (**BDD**)?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是**行为驱动**的**设计**（**BDD**）？
- en: Should we mock databases? Why/why not?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该模拟数据库吗？为什么/为什么不？
- en: What is a container?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器是什么？
- en: Further reading
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章所涉及主题的信息，请查看以下资源：
- en: '*BDD in Action: Behavior-driven development for the whole software lifecycle*,
    by John Ferguson Smart, published by Manning Publications'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '《*BDD in Action: 整个软件生命周期的行为驱动开发*》，由John Ferguson Smart著，由Manning Publications出版'
- en: '*Docker: Up & Running: Shipping Reliable Containers in Production*, by Sean
    Kane and Karl Matthias, published by O’Reilly'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '《*Docker: Up & Running: 在生产中部署可靠的容器*》，由Sean Kane和Karl Matthias著，由O’Reilly出版'
- en: '*Designing Data-Intensive Applications: The Big Ideas Behind Reliable, Scalable,
    and Maintainable Systems*, by Martin Kleppmann, published by O’Reilly'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*设计数据密集型应用程序：可靠、可扩展和可维护系统的核心思想*》，由Martin Kleppmann著，由O’Reilly出版
