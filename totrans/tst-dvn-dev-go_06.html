<html><head></head><body>
<div id="_idContainer058">
<h1 class="chapter-number" id="_idParaDest-122"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-123"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.2.1">End-to-End Testing the BookSwap Web Application</span></h1>
<p><span class="koboSpan" id="kobo.3.1">We have made a lot of progress toward our goal of learning how to use TDD for implementing and testing Go code. </span><span class="koboSpan" id="kobo.3.2">So far, we have covered a wide variety of techniques for implementing unit and integration tests. </span><span class="koboSpan" id="kobo.3.3">Unit tests verify that each component works as intended, while integration tests extend their scope to cover the seams and interactions between different units. </span><span class="koboSpan" id="kobo.3.4">Moreover, we have learned how to apply these techniques to a wide variety of examples, including the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4.1">BookSwap</span></strong><span class="koboSpan" id="kobo.5.1"> web application introduced in </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">previous chapters.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">These tests give us a fast feedback loop for code changes, as they don’t require the entirety of the application to be started up and made available before the test suite is run. </span><span class="koboSpan" id="kobo.7.2">As discussed in </span><a href="B18371_05.xhtml#_idTextAnchor124"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.8.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.9.1">, </span><em class="italic"><span class="koboSpan" id="kobo.10.1">Performing Integration Testing</span></em><span class="koboSpan" id="kobo.11.1">, we learned how to make use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.12.1">httptest</span></strong><span class="koboSpan" id="kobo.13.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.14.1">ginkgo</span></strong><span class="koboSpan" id="kobo.15.1"> libraries to easily write and run integration tests for web applications. </span><span class="koboSpan" id="kobo.15.2">We also</span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.16.1"> learned how to make use of </span><strong class="bold"><span class="koboSpan" id="kobo.17.1">behavior-driven development</span></strong><span class="koboSpan" id="kobo.18.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.19.1">BDD</span></strong><span class="koboSpan" id="kobo.20.1">) for writing tests, which is a popular technique for writing</span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.21.1"> integration</span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.22.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.23.1">end-to-end</span></strong><span class="koboSpan" id="kobo.24.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.25.1">E2E</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">) tests.</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">However, while we can rely on unit and integration testing to ensure that the application is functioning correctly in a wide variety of scenarios, we should not neglect the benefits that E2E tests bring to our testing strategy. </span><span class="koboSpan" id="kobo.27.2">Only E2E tests allow us to verify the behavior of the entire application and replicate the user flows and experience. </span><span class="koboSpan" id="kobo.27.3">Simply put, these tests give us an insight into the user experience in production, which is the final verification that we should be making to our application before it </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">is released.</span></span></p>
<p><span class="koboSpan" id="kobo.29.1">This chapter is dedicated to discussing the implementation of E2E testing suites for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.30.1">BookSwap</span></strong><span class="koboSpan" id="kobo.31.1"> web application introduced in previous chapters. </span><span class="koboSpan" id="kobo.31.2">We will make use of Docker to streamline the creation and teardown of identical applications, as well as discuss the changes we need to make to the application in order to make use of a database. </span><span class="koboSpan" id="kobo.31.3">Then, we will learn how to make use of Godog to write and run E2E tests. </span><span class="koboSpan" id="kobo.31.4">Finally, we will discuss which database assertions we should include in </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">our tests.</span></span></p>
<p><span class="koboSpan" id="kobo.33.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.35.1">The requirements of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">BookSwap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.37.1"> application</span></span></li>
<li><span class="koboSpan" id="kobo.38.1">The implementation of database storage in </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">web applications</span></span></li>
<li><span class="koboSpan" id="kobo.40.1">Getting started with Cucumber </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">and Godog</span></span></li>
<li><span class="koboSpan" id="kobo.42.1">The implementation of E2E tests </span></li>
<li><span class="koboSpan" id="kobo.43.1">Database start positions </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">and assertions</span></span></li>
</ul>
<h1 id="_idParaDest-124"><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.45.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.46.1">You will need to have </span><strong class="bold"><span class="koboSpan" id="kobo.47.1">Go version 1.19</span></strong><span class="koboSpan" id="kobo.48.1"> or later installed to run the code samples in this chapter. </span><span class="koboSpan" id="kobo.48.2">The installation process is described in the official Go documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">at </span></span><a href="https://go.dev/doc/install"><span class="No-Break"><span class="koboSpan" id="kobo.50.1">https://go.dev/doc/install</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.51.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">The code examples included in this book are publicly available </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">at </span></span><a href="https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter06"><span class="No-Break"><span class="koboSpan" id="kobo.54.1">https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter06</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.55.1">.</span></span></p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.56.1">Use case – extending the BookSwap application</span></h1>
<p><span class="koboSpan" id="kobo.57.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">BookSwap</span></strong><span class="koboSpan" id="kobo.59.1"> web</span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.60.1"> application was introduced in </span><a href="B18371_04.xhtml#_idTextAnchor085"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.61.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.62.1">, </span><em class="italic"><span class="koboSpan" id="kobo.63.1">Building Efficient Test Suites</span></em><span class="koboSpan" id="kobo.64.1">. </span><span class="koboSpan" id="kobo.64.2">Its main functionality allows users to list their books and swap them with other users. </span><span class="koboSpan" id="kobo.64.3">We learned what its main components and endpoints are, as well as how to apply table testing to its </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">BookService</span></strong><span class="koboSpan" id="kobo.66.1">. </span><span class="koboSpan" id="kobo.66.2">Then, in </span><a href="B18371_05.xhtml#_idTextAnchor124"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.67.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.68.1">, </span><em class="italic"><span class="koboSpan" id="kobo.69.1">Performing Integration Testing</span></em><span class="koboSpan" id="kobo.70.1">, we learned how to write integration tests for its </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">Index</span></strong><span class="koboSpan" id="kobo.72.1"> request handler. </span><span class="koboSpan" id="kobo.72.2">We will continue to build out the functionality of this application in this chapter, taking a closer look at the user flows and intended functionality for </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">each endpoint.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.74.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.75.1">.1</span></em><span class="koboSpan" id="kobo.76.1"> depicts a summary of the responsibilities of the three main services of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">BookSwap</span></strong><span class="koboSpan" id="kobo.78.1"> application—</span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">BookService</span></strong><span class="koboSpan" id="kobo.80.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">UserService</span></strong><span class="koboSpan" id="kobo.82.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">PostingService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer054">
<span class="koboSpan" id="kobo.86.1"><img alt="Figure 6.1 – The responsibilities of the main components of the BookSwap application  " src="image/Figure_6.1_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.87.1">Figure 6.1 – The responsibilities of the main components of the BookSwap application </span></p>
<p><span class="koboSpan" id="kobo.88.1">Each of the</span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.89.1"> services has its own specialization and separate</span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.90.1"> responsibilities: </span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">BookService</span></strong><span class="koboSpan" id="kobo.92.1"> is in charge of all book management aspects. </span><span class="koboSpan" id="kobo.92.2">This service implements the functionality of creating, updating, listing, and filtering books. </span><span class="koboSpan" id="kobo.92.3">As this application is quite limited in functionality, books are only filtered by the owner’s user ID, and we will not implement any searching for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">books</span></strong><span class="koboSpan" id="kobo.94.1"> inventory. </span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">UserService</span></strong><span class="koboSpan" id="kobo.96.1"> is in charge of all user management aspects. </span><span class="koboSpan" id="kobo.96.2">This service implements functionality for creating and updating user profiles. </span><span class="koboSpan" id="kobo.96.3">It can also fetch a given user by ID and relies on </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">BookService</span></strong><span class="koboSpan" id="kobo.98.1"> to receive a list of all books whose owner ID corresponds to the supplied user ID. </span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">PostingService</span></strong><span class="koboSpan" id="kobo.100.1"> is an external service to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">BookSwap</span></strong><span class="koboSpan" id="kobo.102.1"> application, which is in charge of the details of posting and swapping books. </span><span class="koboSpan" id="kobo.102.2">For implementation purposes, we will </span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.103.1">use a </span><strong class="bold"><span class="koboSpan" id="kobo.104.1">stubbed implementation</span></strong><span class="koboSpan" id="kobo.105.1"> of this service inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">BookSwap</span></strong><span class="koboSpan" id="kobo.107.1"> application. </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">PostingService</span></strong><span class="koboSpan" id="kobo.109.1"> is not a service that actually exists, but we will use an internal stub to simulate </span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.110.1">calling out to an </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">external service.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.112.1">What is a stub?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.113.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.114.1">stub</span></strong><span class="koboSpan" id="kobo.115.1"> is a </span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.116.1">concrete implementation of another component. </span><span class="koboSpan" id="kobo.116.2">Stubs don’t make use of mocking frameworks, as they are used by implementation code. </span><span class="koboSpan" id="kobo.116.3">They make testing easier and allow us to build code as if the external component were built and implemented. </span><span class="koboSpan" id="kobo.116.4">Due to the flexibility of interfaces in Go, stubbed implementations can be easily swapped out for </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">real implementations.</span></span></p>
<p><span class="koboSpan" id="kobo.118.1">As </span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.119.1">mentioned in </span><a href="B18371_04.xhtml#_idTextAnchor085"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.120.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.121.1">, </span><em class="italic"><span class="koboSpan" id="kobo.122.1">Building Efficient Test Suites</span></em><span class="koboSpan" id="kobo.123.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">BookSwap</span></strong><span class="koboSpan" id="kobo.125.1"> saves its data in maps and does not currently have any database or persistent storage. </span><span class="koboSpan" id="kobo.125.2">We will change its implementation to use a </span><strong class="bold"><span class="koboSpan" id="kobo.126.1">PostgreSQL</span></strong><span class="koboSpan" id="kobo.127.1"> database in </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">this chapter.</span></span></p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.129.1">User journeys</span></h2>
<p><span class="koboSpan" id="kobo.130.1">In this</span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.131.1"> chapter, we will focus on the implementation of E2E tests. </span><span class="koboSpan" id="kobo.131.2">The focus of these tests is to verify the behavior of the application under typical </span><strong class="bold"><span class="koboSpan" id="kobo.132.1">user journeys</span></strong><span class="koboSpan" id="kobo.133.1">. </span><span class="koboSpan" id="kobo.133.2">Therefore, it is important to establish typical user journeys or request flows before writing any E2E test cases. </span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.134.1">What is a user journey?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.135.1">A user journey</span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.136.1"> is the path or sequence of requests that the user of an application will take in order to achieve their goal. </span><span class="koboSpan" id="kobo.136.2">Often, these journeys are tracked in production environments to get insights into how users are using services. </span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.137.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.138.1">.2</span></em><span class="koboSpan" id="kobo.139.1"> depicts the expected request flow for a new user for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">BookSwap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.141.1"> application:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer055">
<span class="koboSpan" id="kobo.142.1"><img alt="Figure 6.2 – The request flow of a new BookSwap application user " src="image/Figure_6.2_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.143.1">Figure 6.2 – The request flow of a new BookSwap application user</span></p>
<p><span class="koboSpan" id="kobo.144.1">The request</span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.145.1"> flow diagram gives us an insight into which parts of the </span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.146.1">application are required for the user journey to be successfully completed. </span><span class="koboSpan" id="kobo.146.2">The expected usage of the application for a new user is outlined here: </span></p>
<ol>
<li value="1"><strong class="bold"><span class="koboSpan" id="kobo.147.1">Create a new user</span></strong><span class="koboSpan" id="kobo.148.1">: The user will need to create a new user profile and retrieve their user ID. </span><span class="koboSpan" id="kobo.148.2">In a real application, this is where the authentication part of the application will take place. </span><span class="koboSpan" id="kobo.148.3">As previously mentioned, we will disregard all the password and authentication aspects of our application. </span><span class="koboSpan" id="kobo.148.4">Instead, we will treat the user ID as a secret number that the user will be issued. </span><span class="koboSpan" id="kobo.148.5">A new user is created by sending a request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">POST /users</span></strong><span class="koboSpan" id="kobo.150.1"> endpoint, passing the details of the user profile as a JSON request body. </span><span class="koboSpan" id="kobo.150.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">UserService</span></strong><span class="koboSpan" id="kobo.152.1"> service will then create the user and return it to </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">the client.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.154.1">List the available books</span></strong><span class="koboSpan" id="kobo.155.1">: The user can then fetch a list of books. </span><span class="koboSpan" id="kobo.155.2">This corresponds to navigating the home page of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">BookSwap</span></strong><span class="koboSpan" id="kobo.157.1"> application and viewing which books are available for swapping. </span><span class="koboSpan" id="kobo.157.2">The client issues a </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">GET /books</span></strong><span class="koboSpan" id="kobo.159.1"> request. </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">BookService</span></strong><span class="koboSpan" id="kobo.161.1"> will fetch a list of books, filtering them by available status. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.162.1">Swap a book</span></strong><span class="koboSpan" id="kobo.163.1">: Once the user has set up their profile and identified a book that they’d like to have, they can decide to swap a book. </span><span class="koboSpan" id="kobo.163.2">The client issues a </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">POST /books/{id}</span></strong><span class="koboSpan" id="kobo.165.1"> request, passing the ID of the book that they want to book. </span><span class="koboSpan" id="kobo.165.2">Then, they pass their own user ID as a URL parameter, completing the URL of the request as </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">POST /books/id?user={userId}</span></strong><span class="koboSpan" id="kobo.167.1">. </span><span class="koboSpan" id="kobo.167.2">This could also have been implemented</span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.168.1"> with a request body. </span></li>
</ol>
<p><span class="koboSpan" id="kobo.169.1">Looking at the main </span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.170.1">components in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.171.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.172.1">.2</span></em><span class="koboSpan" id="kobo.173.1">, we notice that there is an extra component named </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">HTTP Server</span></strong><span class="koboSpan" id="kobo.175.1">. </span><span class="koboSpan" id="kobo.175.2">The implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">HTTP Server</span></strong><span class="koboSpan" id="kobo.177.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">BookSwap</span></strong><span class="koboSpan" id="kobo.179.1"> application consists of a few different parts: </span></p>
<ul>
<li><span class="koboSpan" id="kobo.180.1">A handler custom type with </span><strong class="bold"><span class="koboSpan" id="kobo.181.1">handler functions</span></strong><span class="koboSpan" id="kobo.182.1"> that take in an HTTP request and response writer. </span><span class="koboSpan" id="kobo.182.2">We saw an example of a handler function with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">Index</span></strong><span class="koboSpan" id="kobo.184.1"> example in </span><a href="B18371_05.xhtml#_idTextAnchor124"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.185.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.186.1">, </span><em class="italic"><span class="koboSpan" id="kobo.187.1">Performing Integration Testing</span></em><span class="koboSpan" id="kobo.188.1">. </span><span class="koboSpan" id="kobo.188.2">Typically, the handler custom type has access to all the dependencies it requires to fulfill its exposed operations. </span></li>
<li><span class="koboSpan" id="kobo.189.1">Each handler function is </span><strong class="bold"><span class="koboSpan" id="kobo.190.1">configured to serve an endpoint</span></strong><span class="koboSpan" id="kobo.191.1"> of the HTTP server. </span><span class="koboSpan" id="kobo.191.2">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">gorilla/mux</span></strong><span class="koboSpan" id="kobo.193.1"> library to take care of the configuration and routing of requests to their respective handler functions. </span><span class="koboSpan" id="kobo.193.2">You can read more about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">gorilla/mux</span></strong><span class="koboSpan" id="kobo.195.1"> library at </span><a href="https://github.com/gorilla/mux"><span class="koboSpan" id="kobo.196.1">https://github.com/gorilla/mux</span></a><span class="koboSpan" id="kobo.197.1">. </span></li>
<li><span class="koboSpan" id="kobo.198.1">Finally, once routes and handlers are set up, we start the server and configure it to listen on a given port. </span><span class="koboSpan" id="kobo.198.2">This is done using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">net/http</span></strong><span class="koboSpan" id="kobo.200.1"> library in the Go </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">standard library.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.202.1">What is a mux?</span></p>
<p class="callout"><strong class="bold"><span class="koboSpan" id="kobo.203.1">Mux</span></strong><span class="koboSpan" id="kobo.204.1"> stands </span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.205.1">for </span><strong class="bold"><span class="koboSpan" id="kobo.206.1">HTTP request multiplexer</span></strong><span class="koboSpan" id="kobo.207.1">. </span><span class="koboSpan" id="kobo.207.2">It provides functionality for receiving a variety of requests and routing </span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.208.1">them to the correct handler function based on the HTTP method, path, and query values. </span><span class="koboSpan" id="kobo.208.2">While there are other options, </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">gorilla/mux</span></strong><span class="koboSpan" id="kobo.210.1"> is a popular solution among </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">Go developers.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.212.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.213.1">.2</span></em><span class="koboSpan" id="kobo.214.1"> covers a successful journey for a new user. </span><span class="koboSpan" id="kobo.214.2">E2E tests </span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.215.1">should cover a variety of scenarios, so we map out multiple request flows. </span><span class="koboSpan" id="kobo.215.2">However, due to their higher cost and running time, they typically only cover </span><strong class="bold"><span class="koboSpan" id="kobo.216.1">base cases</span></strong><span class="koboSpan" id="kobo.217.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.218.1">happy paths</span></strong><span class="koboSpan" id="kobo.219.1">. </span></p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.220.1">Using Docker</span></h2>
<p><span class="koboSpan" id="kobo.221.1">Up until now, we have</span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.222.1"> run appli</span><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.223.1">cations using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">go run</span></strong><span class="koboSpan" id="kobo.225.1"> command and tested them using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">go test</span></strong><span class="koboSpan" id="kobo.227.1"> command. </span><span class="koboSpan" id="kobo.227.2">The downside of this approach is that we must set up the Go environment and any dependencies locally before we can build and run the code locally. </span><span class="koboSpan" id="kobo.227.3">In </span><a href="B18371_05.xhtml#_idTextAnchor124"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.228.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.229.1">, </span><em class="italic"><span class="koboSpan" id="kobo.230.1">Performing Integration Testing</span></em><span class="koboSpan" id="kobo.231.1">, we introduced Docker as a solution that addresses </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">these issues.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.233.1">What is a Dockerfile?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.234.1">A Dockerfile</span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.235.1"> is a file that contains all the commands required for assembling an image. </span><span class="koboSpan" id="kobo.235.2">It is then used by Docker Engine to automatically create and start a container. </span><span class="koboSpan" id="kobo.235.3">We can view it as the specification of the setup for a </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">Docker container.</span></span></p>
<p><span class="koboSpan" id="kobo.237.1">We need to create a custom Dockerfile for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">BookSwap</span></strong><span class="koboSpan" id="kobo.239.1"> application, as it does not have a pre-defined image in the Docker Hub image library. </span><span class="koboSpan" id="kobo.239.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">Dockerfile.book-swap.chapter06</span></strong><span class="koboSpan" id="kobo.241.1"> file contains the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">BookSwap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.243.1"> specification:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.244.1">FROM golang:1.19-alpine</span></strong><span class="koboSpan" id="kobo.245.1">
WORKDIR /app
COPY go.mod ./
COPY go.sum ./
COPY . </span><span class="koboSpan" id="kobo.245.2">.
</span><strong class="bold"><span class="koboSpan" id="kobo.246.1">RUN go mod download</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.247.1">RUN go build ./chapter06/cmd</span></strong><span class="koboSpan" id="kobo.248.1">
EXPOSE ${BOOKSWAP_PORT}
</span><strong class="bold"><span class="koboSpan" id="kobo.249.1">CMD [ "./cmd" ]</span></strong></pre>
<p><span class="koboSpan" id="kobo.250.1">This relatively simple file demonstrates all the essential knowledge that we need to effectively use Docker with</span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.251.1"> our Go applications: </span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.252.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">FROM</span></strong><span class="koboSpan" id="kobo.254.1"> statement indicates the base image of this build stage. </span><span class="koboSpan" id="kobo.254.2">We choose an image from Docker Hub that has the </span><strong class="bold"><span class="koboSpan" id="kobo.255.1">1.19 Go version</span></strong><span class="koboSpan" id="kobo.256.1"> that we require to run our application. </span><span class="koboSpan" id="kobo.256.2">In Docker</span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.257.1"> terminology, </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">alpine</span></strong><span class="koboSpan" id="kobo.259.1"> images are lightweight and run on the </span><strong class="bold"><span class="koboSpan" id="kobo.260.1">Linux </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.261.1">BusyBox distribution</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.263.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">WORKDIR</span></strong><span class="koboSpan" id="kobo.265.1"> statement creates and sets the working directory of the Docker container. </span><span class="koboSpan" id="kobo.265.2">All further commands in our file execute in this directory. </span></li>
<li><span class="koboSpan" id="kobo.266.1">Next, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">COPY</span></strong><span class="koboSpan" id="kobo.268.1"> statement copies all the source files from our local directory to the container’s working directory. </span><span class="koboSpan" id="kobo.268.2">Remember that containers are isolated from the underlying local directories, so these files must be copied to the container. </span></li>
<li><span class="koboSpan" id="kobo.269.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">RUN</span></strong><span class="koboSpan" id="kobo.271.1"> statement executes the commands needed to build our Go executable by first downloading its dependencies and then specifying the directory that contains our application entry point. </span><span class="koboSpan" id="kobo.271.2">The Dockerfile is placed alongside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">go.mod</span></strong><span class="koboSpan" id="kobo.273.1"> file in the root directory, so we need to explicitly state which of our chapter entry points to build from. </span></li>
<li><span class="koboSpan" id="kobo.274.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">EXPOSE</span></strong><span class="koboSpan" id="kobo.276.1"> statement instructs the Docker container to listen to network requests on the given port, as indicated by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">BOOKSWAP_PORT</span></strong><span class="koboSpan" id="kobo.278.1"> environment variable. </span><span class="koboSpan" id="kobo.278.2">This variable is needed for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">BookSwap</span></strong><span class="koboSpan" id="kobo.280.1"> application, so ensure that it is set in your terminal session before you run the application. </span><span class="koboSpan" id="kobo.280.2">The instructions of how to set environment variables will be different according to your operating system. </span><span class="koboSpan" id="kobo.280.3">If you want to run with the default setup, set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">BOOKSWAP_PORT</span></strong><span class="koboSpan" id="kobo.282.1"> environment variable </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">3000</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.286.1">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">CMD</span></strong><span class="koboSpan" id="kobo.288.1"> statement specifies the command that should be run once the container starts. </span><span class="koboSpan" id="kobo.288.2">We</span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.289.1"> run the executable from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">go </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">build</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.292.1"> step.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.293.1">That’s all we need to specify to run our application on any environment that is running Docker and has an internet connection! </span><span class="koboSpan" id="kobo.293.2">Most Docker specifications will be using this simple recipe for writing and running their custom images. </span><span class="koboSpan" id="kobo.293.3">We will see this specification in action later in </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">this chapter.</span></span></p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.295.1">Persistent storage</span></h2>
<p><span class="koboSpan" id="kobo.296.1">The next change we will make is to </span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.297.1">add </span><strong class="bold"><span class="koboSpan" id="kobo.298.1">persistent storage</span></strong><span class="koboSpan" id="kobo.299.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">BookSwap</span></strong><span class="koboSpan" id="kobo.301.1"> application, allowing us to save the state once the application shuts down. </span><span class="koboSpan" id="kobo.301.2">As SQL databases are still the most popular persistent storage solutions, we will use a SQL database in the demo application. </span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.302.1">SQL database management solutions</span></p>
<p class="callout"><span class="koboSpan" id="kobo.303.1">There are a few popular SQL database solutions that you may </span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.304.1">already be familiar with. </span><span class="koboSpan" id="kobo.304.2">Some of</span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.305.1"> these are </span><strong class="bold"><span class="koboSpan" id="kobo.306.1">Oracle MySQL</span></strong><span class="koboSpan" id="kobo.307.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.308.1">Microsoft SQL Server</span></strong><span class="koboSpan" id="kobo.309.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.310.1">PostgreSQL</span></strong><span class="koboSpan" id="kobo.311.1">. </span><span class="koboSpan" id="kobo.311.2">They all allow us to manage and interact with underlying SQL databases</span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.312.1"> but may have differences in terms of the way we interact with them. </span><span class="koboSpan" id="kobo.312.2">Therefore, it’s important to use the same SQL solution in test environments as we have </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">in production.</span></span></p>
<p><span class="koboSpan" id="kobo.314.1">We will use a </span><strong class="bold"><span class="koboSpan" id="kobo.315.1">PostgreSQL database</span></strong><span class="koboSpan" id="kobo.316.1">, an open source relational database widely used in production. </span><span class="koboSpan" id="kobo.316.2">It also has excellent cloud support across the public cloud providers, so it is a natural choice for our technology stack. </span></p>
<p><span class="koboSpan" id="kobo.317.1">You can easily download and </span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.318.1">install it locally using the steps in the official documentation, available at </span><a href="https://www.postgresql.org/download/"><span class="koboSpan" id="kobo.319.1">https://www.postgresql.org/download/</span></a><span class="koboSpan" id="kobo.320.1">, following the instructions for your operating system. </span><span class="koboSpan" id="kobo.320.2">Once you install it locally, make a note of your host, port, username, and password. </span><span class="koboSpan" id="kobo.320.3">You will need these to connect to your database and run instructions on </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">it later.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.322.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.323.1">.3</span></em><span class="koboSpan" id="kobo.324.1"> depicts the two main tables required for our application: </span></p>
<div>
<div class="IMG---Figure" id="_idContainer056">
<span class="koboSpan" id="kobo.325.1"><img alt="Figure 6.3 – The SQL tables of the BookSwap application " src="image/Figure_6.3_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.326.1">Figure 6.3 – The SQL tables of the BookSwap application</span></p>
<p><span class="koboSpan" id="kobo.327.1">There are two tables: </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">books</span></strong><span class="koboSpan" id="kobo.329.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">users</span></strong><span class="koboSpan" id="kobo.331.1">. </span><span class="koboSpan" id="kobo.331.2">Each table has a column for the data fields of each type. </span><span class="koboSpan" id="kobo.331.3">As</span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.332.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">owner_id</span></strong><span class="koboSpan" id="kobo.334.1"> value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">books</span></strong><span class="koboSpan" id="kobo.336.1"> should belong to an existing user, there</span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.337.1"> is a </span><strong class="bold"><span class="koboSpan" id="kobo.338.1">foreign key constraint</span></strong><span class="koboSpan" id="kobo.339.1"> between the two tables on the user </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">id</span></strong><span class="koboSpan" id="kobo.341.1"> field. </span><span class="koboSpan" id="kobo.341.2">All the columns are of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">varchar</span></strong><span class="koboSpan" id="kobo.343.1">, which corresponds to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">string</span></strong><span class="koboSpan" id="kobo.345.1"> type. </span></p>
<p><span class="koboSpan" id="kobo.346.1">Before we start up the application, we need to create the tables required for the application to function. </span><span class="koboSpan" id="kobo.346.2">However, we don’t want to execute SQL instructions outside of our source code, instead allowing us to version and review it. </span></p>
<p><span class="koboSpan" id="kobo.347.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">golang-migrate</span></strong><span class="koboSpan" id="kobo.349.1"> project (</span><a href="https://github.com/golang-migrate/migrate"><span class="koboSpan" id="kobo.350.1">https://github.com/golang-migrate/migrate</span></a><span class="koboSpan" id="kobo.351.1">) allows us to write migrations and run them as part of our application startup. </span><span class="koboSpan" id="kobo.351.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">migrate</span></strong><span class="koboSpan" id="kobo.353.1"> CLI tool can easily be installed on your environment by following the installation steps in the </span><em class="italic"><span class="koboSpan" id="kobo.354.1">Getting started</span></em><span class="koboSpan" id="kobo.355.1"> tutorials available in the </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">project documentation.</span></span></p>
<p><span class="koboSpan" id="kobo.357.1">Once installed, we can generate migrations for our two required tables: </span></p>
<pre class="console"><span class="koboSpan" id="kobo.358.1">
$ migrate create -ext sql -dir chapter06/db/migrations -seq create_users_table
$ migrate create -ext sql -dir chapter06/db/migrations -seq create_books_table</span></pre>
<p><span class="koboSpan" id="kobo.359.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">migrate</span></strong><span class="koboSpan" id="kobo.361.1"> CLI tool creates two files for each table, named </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">*.up.sql</span></strong><span class="koboSpan" id="kobo.363.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">*.down.sql</span></strong><span class="koboSpan" id="kobo.365.1">. </span><span class="koboSpan" id="kobo.365.2">The intended usage of these files is that the up migration creates the table at startup, and the down migration deletes the table once the application shuts down. </span><span class="koboSpan" id="kobo.365.3">This ensures that tables are removed after each run of the application and that they are always created at startup. </span><span class="koboSpan" id="kobo.365.4">Then, we add the columns required for each table. </span><span class="koboSpan" id="kobo.365.5">The configuration of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">users</span></strong><span class="koboSpan" id="kobo.367.1"> table is shown here: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.368.1">
BEGIN;
</span><strong class="bold"><span class="koboSpan" id="kobo.369.1">CREATE TABLE IF NOT EXISTS users</span></strong><span class="koboSpan" id="kobo.370.1">
(
</span><strong class="bold"><span class="koboSpan" id="kobo.371.1">   id VARCHAR (50) PRIMARY KEY,</span></strong><span class="koboSpan" id="kobo.372.1">
   name VARCHAR (50) NOT NULL,
   // other column definitions
);
COMMIT;</span></pre>
<p><span class="koboSpan" id="kobo.373.1">The</span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.374.1"> migration creates a table if one does not exist and marks the </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">id</span></strong><span class="koboSpan" id="kobo.376.1"> column as the primary key. </span><span class="koboSpan" id="kobo.376.2">The specification matches the columns defined in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.377.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.378.1">.3</span></em><span class="koboSpan" id="kobo.379.1">. </span><span class="koboSpan" id="kobo.379.2">The down migration is one single line, which drops the table: </span></p>
<pre class="console"><span class="koboSpan" id="kobo.380.1">
DROP TABLE IF EXISTS users;</span></pre>
<p><span class="koboSpan" id="kobo.381.1">The configuration of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">books</span></strong><span class="koboSpan" id="kobo.383.1"> table is done in the same way. </span><span class="koboSpan" id="kobo.383.2">Finally, we add the migrations to the entry point of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">BookSwap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.385.1"> application:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.386.1">
func main() {
// other initialisation code
  postgresURL, ok := os.LookupEnv("BOOKSWAP_DB_URL")
  if !ok {
    log.Fatal("env variable BOOKSWAP_DB_URL not found")
  }
  </span><strong class="bold"><span class="koboSpan" id="kobo.387.1">m, err := migrate.New("file://chapter06/db/migrations", postgresURL)</span></strong><span class="koboSpan" id="kobo.388.1">
  if err != nil {
    log.Fatal(err)
  }
  if err := </span><strong class="bold"><span class="koboSpan" id="kobo.389.1">m.Up()</span></strong><span class="koboSpan" id="kobo.390.1">; err != nil {
    log.Fatal(err)
  }
   defer func() {
      </span><strong class="bold"><span class="koboSpan" id="kobo.391.1">m.Down()</span></strong><span class="koboSpan" id="kobo.392.1">
  }()
  // other initialisation code
}</span></pre>
<p><span class="koboSpan" id="kobo.393.1">Interacting with</span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.394.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">migrate</span></strong><span class="koboSpan" id="kobo.396.1"> library requires three extra steps to be added to the startup of </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">the application:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.398.1">Creating a </span><strong class="bold"><span class="koboSpan" id="kobo.399.1">new migrate instance</span></strong><span class="koboSpan" id="kobo.400.1"> with a source URL and database URL. </span><span class="koboSpan" id="kobo.400.2">As previously mentioned, the connection string for your database instance will depend on your SQL configuration. </span><span class="koboSpan" id="kobo.400.3">The format for your database will have a format similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">postgres://user:password@host:port/database</span></strong><span class="koboSpan" id="kobo.402.1">.  </span><span class="koboSpan" id="kobo.402.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">BookSwap</span></strong><span class="koboSpan" id="kobo.404.1"> application requires an environment variable named </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">BOOKSWAP_DB_URL</span></strong><span class="koboSpan" id="kobo.406.1">, which contains this value. </span><span class="koboSpan" id="kobo.406.2">Make sure that this environment variable is set before starting </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">the application.</span></span></li>
<li><span class="koboSpan" id="kobo.408.1">Once the migrate instance is created, we invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">Up()</span></strong><span class="koboSpan" id="kobo.410.1"> method. </span><span class="koboSpan" id="kobo.410.2">This method looks at the current migration version and applies all the migrations defined in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">*.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">up.sql</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.413.1"> files.</span></span></li>
<li><span class="koboSpan" id="kobo.414.1">If we want to clean up after the application shuts down or in the case of an error, we defer a call to the migration </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">Down()</span></strong><span class="koboSpan" id="kobo.416.1"> method. </span><span class="koboSpan" id="kobo.416.2">This method uses the same version management and runs the contents of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">*.down.sql</span></strong><span class="koboSpan" id="kobo.418.1"> files. </span></li>
</ol>
<p><span class="koboSpan" id="kobo.419.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">golang-migrate</span></strong><span class="koboSpan" id="kobo.421.1"> library and CLI have made it easy for us to save database configuration alongside source code, allowing for easy versioning as well as </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">version management.</span></span></p>
<p><span class="koboSpan" id="kobo.423.1">Once our database and tables are created, we need to refactor our </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">UserService</span></strong><span class="koboSpan" id="kobo.425.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">BookService</span></strong><span class="koboSpan" id="kobo.427.1"> implementations to make use of SQL tables and not the built-in maps we have been using so far. </span><span class="koboSpan" id="kobo.427.2">Typically, engineers make use of an </span><strong class="bold"><span class="koboSpan" id="kobo.428.1">object-relational mapping</span></strong><span class="koboSpan" id="kobo.429.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.430.1">ORM</span></strong><span class="koboSpan" id="kobo.431.1">) library, which</span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.432.1"> allows us to create a bridge between our Go custom types and our PostgreSQL database. </span></p>
<p><span class="koboSpan" id="kobo.433.1">There are a few ORM solutions in the Go ecosystem. </span><span class="koboSpan" id="kobo.433.2">One </span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.434.1">of the most popular ones is </span><strong class="bold"><span class="koboSpan" id="kobo.435.1">GORM</span></strong><span class="koboSpan" id="kobo.436.1"> (</span><a href="https://github.com/go-gorm/gorm"><span class="koboSpan" id="kobo.437.1">https://github.com/go-gorm/gorm</span></a><span class="koboSpan" id="kobo.438.1">), which is an open source easy-to-use Go library. </span><span class="koboSpan" id="kobo.438.2">This library will make it easy for us to interact with our database solution, removing the need to manage SQL as raw strings in our </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">source code.</span></span></p>
<p><span class="koboSpan" id="kobo.440.1">The setup for using GORM is very similar to what we have done using </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">golang-migrate</span></strong><span class="koboSpan" id="kobo.442.1">: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.443.1">
func main() {
  // other initialisation code
  postgresURL, ok := os.LookupEnv("BOOKSWAP_DB_URL")
  if !ok {
    log.Fatal("$BOOKSWAP_DB_URL not found")
  }
  </span><strong class="bold"><span class="koboSpan" id="kobo.444.1">dbConn, err := gorm.Open(postgres.Open(postgresURL), &amp;gorm.Config{})</span></strong><span class="koboSpan" id="kobo.445.1">
  if err != nil {
    log.Fatal(err)
  } 
  ps := db.NewPostingService()
</span><strong class="bold"><span class="koboSpan" id="kobo.446.1">  b := db.NewBookService(dbConn, ps)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.447.1">  u := db.NewUserService(dbConn, b)</span></strong><span class="koboSpan" id="kobo.448.1">
  // initialisation code continues
 }</span></pre>
<p><span class="koboSpan" id="kobo.449.1">First, we connect to the database using the database URL that we used previously to connect with </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">golang-migrate</span></strong><span class="koboSpan" id="kobo.451.1">. </span><span class="koboSpan" id="kobo.451.2">Once successfully connected, it returns the GORM database wrapper of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">*gorm.DB</span></strong><span class="koboSpan" id="kobo.453.1">. </span></p>
<p><span class="koboSpan" id="kobo.454.1">If we cannot </span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.455.1">connect to the database, then we will kill the application. </span><span class="koboSpan" id="kobo.455.2">We have also changed the signatures of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">NewBookService</span></strong><span class="koboSpan" id="kobo.457.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">NewUserService</span></strong><span class="koboSpan" id="kobo.459.1"> initialization functions to take in the initialized database session. </span></p>
<p><span class="koboSpan" id="kobo.460.1">All of the operations of </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">BookService</span></strong><span class="koboSpan" id="kobo.462.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">UserService</span></strong><span class="koboSpan" id="kobo.464.1"> that previously saved models to the built-in map type will now have to leverage the operations of the GORM database wrapper. </span><span class="koboSpan" id="kobo.464.2">One example is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">BookService</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.466.1">ListByUser</span></strong><span class="koboSpan" id="kobo.467.1"> method: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.468.1">
// ListByUser returns the list of books for a given user.
</span><span class="koboSpan" id="kobo.468.2">func (bs *BookService) ListByUser(userID string) ([]Book, error) {
  var items []Book
  if result := </span><strong class="bold"><span class="koboSpan" id="kobo.469.1">bs.DB.Where("owner_id = ?", userID).Find(&amp;items)</span></strong><span class="koboSpan" id="kobo.470.1">;
    result.Error != nil {
      return nil, result.Error
  }
return items, nil
}</span></pre>
<p><span class="koboSpan" id="kobo.471.1">This method lists</span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.472.1"> all books whose owner ID matches the given user ID. </span><span class="koboSpan" id="kobo.472.2">The usage of an ORM solution allows us to invoke operations on the database using a service that is able to use the invocations of methods to construct the correct SQL query. </span><span class="koboSpan" id="kobo.472.3">This allows us to reduce errors and remove the need to manage and interact with raw SQL strings. </span></p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.473.1">Running the BookSwap application</span></h2>
<p><span class="koboSpan" id="kobo.474.1">The final piece of the puzzle for </span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.475.1">extensions we need to make to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">BookSwap</span></strong><span class="koboSpan" id="kobo.477.1"> application is how to run it together with its database. </span><span class="koboSpan" id="kobo.477.2">As mentioned in </span><a href="B18371_05.xhtml#_idTextAnchor124"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.478.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.479.1">, </span><em class="italic"><span class="koboSpan" id="kobo.480.1">Performing Integration Testing</span></em><span class="koboSpan" id="kobo.481.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">docker-compose</span></strong><span class="koboSpan" id="kobo.483.1"> tool is what we use to manage multiple Docker containers together. </span><span class="koboSpan" id="kobo.483.2">We now have two services, or parts, to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">BookSwap</span></strong><span class="koboSpan" id="kobo.485.1"> application—the server-side application and its database. </span><span class="koboSpan" id="kobo.485.2">The database setup needs to be run in a Docker container as well, to avoid having to set up databases in every single environment. </span></p>
<p><span class="koboSpan" id="kobo.486.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">docker-compose</span></strong><span class="koboSpan" id="kobo.488.1"> command takes its input from a </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">.yml</span></strong><span class="koboSpan" id="kobo.490.1"> file, which makes it easy to specify the different services and their requirements. </span><span class="koboSpan" id="kobo.490.2">This simple specification in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">docker-compose.book-swap.chapter06.yml</span></strong><span class="koboSpan" id="kobo.492.1"> file defines our </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">BookSwap</span></strong><span class="koboSpan" id="kobo.494.1"> application and a PostgreSQL database that it can use: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.495.1">
version: '3'
services:
</span><strong class="bold"><span class="koboSpan" id="kobo.496.1"> books:</span></strong><span class="koboSpan" id="kobo.497.1">
  build:
   context: .
</span><strong class="bold"><span class="koboSpan" id="kobo.498.1">   dockerfile: Dockerfile.book-swap.chapter06</span></strong><span class="koboSpan" id="kobo.499.1">
  ports:
   - "${BOOKSWAP_PORT}:${BOOKSWAP_PORT}"
</span><strong class="bold"><span class="koboSpan" id="kobo.500.1">  depends_on:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.501.1">   db:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.502.1">     </span></strong><strong class="bold"><span class="koboSpan" id="kobo.503.1">condition: service_healthy</span></strong><span class="koboSpan" id="kobo.504.1">
  restart: on-failure
  env_file:
   - </span><strong class="bold"><span class="koboSpan" id="kobo.505.1">docker.env db:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.506.1">  image: postgres:15.0-alpine</span></strong><span class="koboSpan" id="kobo.507.1">
  ports:
   - "5432:5432"
  expose:
   - "5432"
</span><strong class="bold"><span class="koboSpan" id="kobo.508.1">  env_file:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.509.1">   - docker.env</span></strong><span class="koboSpan" id="kobo.510.1">
  restart: on-failure</span></pre>
<p><span class="koboSpan" id="kobo.511.1">The configuration in this relatively simple file specifies everything </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">we need:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.513.1">We </span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.514.1">define a services block for all the services that we start up. </span><span class="koboSpan" id="kobo.514.2">In our case, we will define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">books</span></strong><span class="koboSpan" id="kobo.516.1"> service and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">db</span></strong><span class="koboSpan" id="kobo.518.1"> service, each configured in its own sub-block. </span></li>
<li><span class="koboSpan" id="kobo.519.1">The configuration of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">books</span></strong><span class="koboSpan" id="kobo.521.1"> service specifies the following: </span><ol><li><span class="koboSpan" id="kobo.522.1">The service is built from its own Dockerfile located in the current directory. </span><span class="koboSpan" id="kobo.522.2">This is the Dockerfile that we previously discussed in the </span><em class="italic"><span class="koboSpan" id="kobo.523.1">Using Docker</span></em><span class="koboSpan" id="kobo.524.1"> section of </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">this chapter.</span></span></li><li><span class="koboSpan" id="kobo.526.1">The service exposes the port specified by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">BOOKSWAP_PORT</span></strong><span class="koboSpan" id="kobo.528.1"> environment variable on its network. </span><span class="koboSpan" id="kobo.528.2">This will allow us to run tests that need access to the </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">port locally.</span></span></li><li><span class="koboSpan" id="kobo.530.1">The service depends on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">db</span></strong><span class="koboSpan" id="kobo.532.1"> service being started successfully. </span><span class="koboSpan" id="kobo.532.2">Docker Engine will take this into account when starting our service and instruct that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">db</span></strong><span class="koboSpan" id="kobo.534.1"> service be started first. </span></li><li><span class="koboSpan" id="kobo.535.1">The service uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">docker.env</span></strong><span class="koboSpan" id="kobo.537.1"> file for its environment variable configuration. </span><span class="koboSpan" id="kobo.537.2">This will specify other environment variables that we require, like </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">BOOKSWAP_DB_URL</span></strong><span class="koboSpan" id="kobo.539.1"> that we have </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">previously seen.</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.541.1">The configuration of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">db</span></strong><span class="koboSpan" id="kobo.543.1"> service specifies the following: </span><ol><li><span class="koboSpan" id="kobo.544.1">The container should use an existing image from the Docker repository. </span><span class="koboSpan" id="kobo.544.2">At the time of writing, this was the latest image of the </span><strong class="bold"><span class="koboSpan" id="kobo.545.1">PostgreSQL</span></strong><span class="koboSpan" id="kobo.546.1"> image, available at </span><a href="https://hub.docker.com/_/postgres"><span class="koboSpan" id="kobo.547.1">https://hub.docker.com/_/postgres</span></a><span class="koboSpan" id="kobo.548.1">. </span></li><li><span class="koboSpan" id="kobo.549.1">The service exposes port </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">5432</span></strong><span class="koboSpan" id="kobo.551.1">, as is customary </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">for PostgreSQL.</span></span></li><li><span class="koboSpan" id="kobo.553.1">As can be seen from the documentation for this image, it requires the specification of a number of environment variables for the database username, password, and name. </span><span class="koboSpan" id="kobo.553.2">All of these variables will be defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">docker.env</span></strong><span class="koboSpan" id="kobo.555.1"> file that we supply to this service. </span></li></ol></li>
<li><span class="koboSpan" id="kobo.556.1">Both </span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.557.1">services have a restart policy defined as well. </span><span class="koboSpan" id="kobo.557.2">This means that Docker will automatically restart containers if </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">they fail.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.559.1">We can provide the following sample configuration for </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">docker.env</span></strong><span class="koboSpan" id="kobo.561.1">, but you can easily change it according to your own preferences by editing </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">the file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.563.1">
POSTGRES_USER=root
POSTGRES_PASSWORD=root
POSTGRES_DB=books
BOOKSWAP_DB_URL=postgres://root:root@db:5432/books?sslmode=disable
BOOKSWAP_PORT=3000</span></pre>
<p><span class="koboSpan" id="kobo.564.1">That’s all the configuration required for running two services together with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">docker compose -f docker-compose.book-swap.chapter06.yml up --build</span></strong><span class="koboSpan" id="kobo.566.1"> command from the project root directory. </span><span class="koboSpan" id="kobo.566.2">This file contains a typical configuration that you will be able to reuse in your own projects. </span><span class="koboSpan" id="kobo.566.3">Furthermore, it allows</span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.567.1"> us to identically start and run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">BookSwap</span></strong><span class="koboSpan" id="kobo.569.1"> application across different environments. </span><span class="koboSpan" id="kobo.569.2">This provides us with the key advantage of being able to easily spin up test environments for the application as a whole. </span><span class="koboSpan" id="kobo.569.3">With these building blocks in place, let us have a look at how we can make use of this key advantage to increase the test coverage of </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">our application.</span></span></p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.571.1">Exploring Godog</span></h1>
<p><span class="koboSpan" id="kobo.572.1">In this chapter, we have made quite a few changes that have extended the scope and complexity of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">BookSwap</span></strong><span class="koboSpan" id="kobo.574.1"> application. </span><span class="koboSpan" id="kobo.574.2">Now that we can easily start and tear down the application using Docker containers, it is time to turn our attention to writing E2E tests for </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">our application.</span></span></p>
<p><span class="koboSpan" id="kobo.576.1">In </span><a href="B18371_05.xhtml#_idTextAnchor124"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.577.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.578.1">, </span><em class="italic"><span class="koboSpan" id="kobo.579.1">Performing Integration Testing</span></em><span class="koboSpan" id="kobo.580.1">, we looked at how to write BDD-style tests. </span><span class="koboSpan" id="kobo.580.2">This style of testing allows us to write </span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.581.1">human-readable test scenarios and use a </span><strong class="bold"><span class="koboSpan" id="kobo.582.1">Given-When-Then</span></strong><span class="koboSpan" id="kobo.583.1"> structure. </span><span class="koboSpan" id="kobo.583.2">These readable tests can serve as documentation for our projects, allowing us to involve multiple stakeholders and write tests that truly cover the functionality of </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">our applications.</span></span></p>
<p><span class="koboSpan" id="kobo.585.1">We also explored the </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">ginkgo</span></strong><span class="koboSpan" id="kobo.587.1"> testing library, which allowed us to write tests using this style. </span><span class="koboSpan" id="kobo.587.2">Godog (</span><a href="https://github.com/cucumber/godog"><span class="koboSpan" id="kobo.588.1">https://github.com/cucumber/godog</span></a><span class="koboSpan" id="kobo.589.1">) is another testing library that we will be exploring</span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.590.1"> to write </span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.591.1">BDD-style tests. </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">ginkgo</span></strong><span class="koboSpan" id="kobo.593.1"> allows us to add BDD-style assertions to our unit tests, but Godog provides extra code generation capabilities that make it a great fit for writing functional tests. </span><span class="koboSpan" id="kobo.593.2">We will learn how to use this great library for integration and </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">E2E testing.</span></span></p>
<p><span class="koboSpan" id="kobo.595.1">Here are some of the</span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.596.1"> highlights </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">of Godog:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.598.1">Unlike the libraries we have used so far, Godog does not run its tests using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">go test</span></strong><span class="koboSpan" id="kobo.600.1"> command, but with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">godog run</span></strong><span class="koboSpan" id="kobo.602.1"> command. </span><span class="koboSpan" id="kobo.602.2">This command serves the dual purpose of generating test files as well as running the test that has </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">been implemented.</span></span></li>
<li><span class="koboSpan" id="kobo.604.1">Tests are organized </span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.605.1">in </span><strong class="bold"><span class="koboSpan" id="kobo.606.1">feature files</span></strong><span class="koboSpan" id="kobo.607.1">, which describe the expected behavior of a particular piece of functionality in a particular scenario. </span><span class="koboSpan" id="kobo.607.2">Godog uses a domain-specific language </span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.608.1">called </span><strong class="bold"><span class="koboSpan" id="kobo.609.1">Gherkin</span></strong><span class="koboSpan" id="kobo.610.1"> (</span><a href="https://cucumber.io/docs/gherkin/reference/"><span class="koboSpan" id="kobo.611.1">https://cucumber.io/docs/gherkin/reference/</span></a><span class="koboSpan" id="kobo.612.1">). </span><span class="koboSpan" id="kobo.612.2">We will explore how to write tests in this format for the remainder of this chapter. </span></li>
<li><span class="koboSpan" id="kobo.613.1">Godog is an </span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.614.1">open source library, maintained by the community and the Cucumber organization. </span><span class="koboSpan" id="kobo.614.2">You can freely explore the source code and even contribute. </span></li>
</ul>
<p><span class="koboSpan" id="kobo.615.1">Just as with the other dependencies we have used so far, Godog is installed by running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">go install</span></strong><span class="koboSpan" id="kobo.617.1"> command in </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">the terminal:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.619.1">
$ go install github.com/cucumber/godog/cmd/godog@latest</span></pre>
<p><span class="koboSpan" id="kobo.620.1">Now that we understand the basic usage of Godog and have installed it successfully, we start by writing our first </span><strong class="bold"><span class="koboSpan" id="kobo.621.1">feature file</span></strong><span class="koboSpan" id="kobo.622.1">. </span><span class="koboSpan" id="kobo.622.2">We start out with a simple feature file for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">BookSwap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.624.1"> application:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.625.1">Feature: New user signs up</span></strong><span class="koboSpan" id="kobo.626.1">
 In order to use the BookSwap application
 As a new user
 I need to be able to sign up.
</span><strong class="bold"><span class="koboSpan" id="kobo.627.1">Background: Verify configuration</span></strong><span class="koboSpan" id="kobo.628.1">
 Given the BookSwap app is up
</span><strong class="bold"><span class="koboSpan" id="kobo.629.1">Scenario: Sign up</span></strong><span class="koboSpan" id="kobo.630.1">
 Given user details
 When sent to the users endpoint
 Then a new user profile is created</span></pre>
<p><span class="koboSpan" id="kobo.631.1">The feature file </span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.632.1">describes a part of the</span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.633.1"> functionality required for new users of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">BookSwap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.635.1"> application:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.636.1">The feature describes the scenario of signing up as a new user of </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">an application.</span></span></li>
<li><span class="koboSpan" id="kobo.638.1">As a background step, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">BookSwap</span></strong><span class="koboSpan" id="kobo.640.1"> application should be up and running. </span><span class="koboSpan" id="kobo.640.2">This allows us to write an E2E test as we run the entire application and run the test on the side. </span></li>
<li><span class="koboSpan" id="kobo.641.1">When the feature is completed, the following functionality will be available: </span><ul><li><span class="koboSpan" id="kobo.642.1">New customers will be able to create </span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">user profiles.</span></span></li><li><span class="koboSpan" id="kobo.644.1">When their profile is created, the user will see their user summary and receive their user ID, which will allow them to further interact with the application. </span></li><li><span class="koboSpan" id="kobo.645.1">Once signed up, customers will be able to view their profile by using their user ID. </span></li><li><span class="koboSpan" id="kobo.646.1">Any further interactions with the application are outside the scope of </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">this feature.</span></span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.648.1">As discussed, the feature file is based on the expected user journeys and request flows of the application. </span><span class="koboSpan" id="kobo.648.2">Feature files should be easy to read and understand, so we should create separate files for covering other features and scenarios and use </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">non-technical language.</span></span></p>
<p><span class="koboSpan" id="kobo.650.1">In the next section, we will learn how to implement and run this feature file </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">with Godog.</span></span></p>
<h1 id="_idParaDest-131"><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.652.1">Implementing tests with Godog</span></h1>
<p><span class="koboSpan" id="kobo.653.1">With </span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.654.1">Godog installed and our first feature outlined, let us turn </span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.655.1">our attention to the implementation of </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">this test.</span></span></p>
<p><span class="koboSpan" id="kobo.657.1">The main steps we will be taking for implementing our outlined feature are </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">as follows:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.659.1">Creating feature and test files. </span></li>
<li><span class="koboSpan" id="kobo.660.1">Implementing the test steps for the functionality of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">BookSwap</span></strong><span class="koboSpan" id="kobo.662.1"> application. </span></li>
<li><span class="koboSpan" id="kobo.663.1">Running the application as well as the test. </span></li>
</ol>
<p><span class="koboSpan" id="kobo.664.1">As we previously </span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.665.1">mentioned, we will use Godog to implement BDD-style</span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.666.1"> E2E tests, so we require the application to be up and running before we run our tests. </span><span class="koboSpan" id="kobo.666.2">However, this is not a Godog requirement, so we can write tests at any level with this </span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">easy-to-use library.</span></span></p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.668.1">Creating test files</span></h2>
<p><span class="koboSpan" id="kobo.669.1">As previously mentioned, Godog relies </span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.670.1">on code generation to make developers’ lives easier. </span><span class="koboSpan" id="kobo.670.2">The process consists of copying code from the terminal and creating files ourselves. </span><span class="koboSpan" id="kobo.670.3">Let us look at the steps involved. </span></p>
<h3><span class="koboSpan" id="kobo.671.1">Step 1 – creating a feature file</span></h3>
<p><span class="koboSpan" id="kobo.672.1">Feature files are</span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.673.1"> stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">/features</span></strong><span class="koboSpan" id="kobo.675.1"> directory located at the root of the Go project. </span><span class="koboSpan" id="kobo.675.2">As we use project folders in our repository, we need to create a file under </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">/chapter06/features</span></strong><span class="koboSpan" id="kobo.677.1">. </span><span class="koboSpan" id="kobo.677.2">We will create a file in this directory and add the feature text inside it: </span></p>
<pre class="console"><span class="koboSpan" id="kobo.678.1">
$ mkdir chapter06/features
</span><strong class="bold"><span class="koboSpan" id="kobo.679.1">$ vim chapter06/features/newUserSignsUp.feature</span></strong></pre>
<p><span class="koboSpan" id="kobo.680.1">Note that the file is named according to the feature name, making it easy to understand which functionality the file relates to. </span></p>
<h3><span class="koboSpan" id="kobo.681.1">Step 2 – generating step definitions</span></h3>
<p><span class="koboSpan" id="kobo.682.1">Once the feature file </span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.683.1">contains our text, we can use Godog to generate the steps required for our feature. </span><span class="koboSpan" id="kobo.683.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">godog run</span></strong><span class="koboSpan" id="kobo.685.1"> command prints the following generated code to the terminal: </span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.686.1">func aNewUserProfileIsCreated() error {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.687.1">  return godog.ErrPending</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.688.1">}</span></strong><span class="koboSpan" id="kobo.689.1">
func </span><strong class="bold"><span class="koboSpan" id="kobo.690.1">sentToTheUsersEndpoint</span></strong><span class="koboSpan" id="kobo.691.1">() error {
  return godog.ErrPending
}
func </span><strong class="bold"><span class="koboSpan" id="kobo.692.1">theBookSwapAppIsUp</span></strong><span class="koboSpan" id="kobo.693.1">() error {
  return godog.ErrPending
}
func </span><strong class="bold"><span class="koboSpan" id="kobo.694.1">userDetails</span></strong><span class="koboSpan" id="kobo.695.1">() error {
  return godog.ErrPending
}
 
</span><strong class="bold"><span class="koboSpan" id="kobo.696.1">func InitializeScenario(ctx *godog.ScenarioContext) {</span></strong><span class="koboSpan" id="kobo.697.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.698.1">ctx.Step(`^a new user profile is create, </span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.699.1">    aNewUserProfileIsCreated)</span></strong><span class="koboSpan" id="kobo.700.1">
  ctx.Step(`^sent to the users endpoint$`, 
    sentToTheUsersEndpoint)
  ctx.Step(`^the BookSwap app is up$`, theBookSwapAppIsUp)
  ctx.Step(`^user details$`, userDetails)
}</span></pre>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.701.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.702.1">.4</span></em><span class="koboSpan" id="kobo.703.1"> presents the </span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.704.1">sequence of steps in our scenario, along with any HTTP requests that </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">they make:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer057">
<span class="koboSpan" id="kobo.706.1"><img alt="Figure 6.4 – Steps and HTTP requests made in our scenario " src="image/Figure_6.4_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.707.1">Figure 6.4 – Steps and HTTP requests made in our scenario</span></p>
<p><span class="koboSpan" id="kobo.708.1">The generated code </span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.709.1">contains a function for each step of our scenario: </span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.710.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">aNewUserProfileIsCreated</span></strong><span class="koboSpan" id="kobo.712.1"> function sends a request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">GET /users/{id}</span></strong><span class="koboSpan" id="kobo.714.1"> endpoint and verifies that the user profile is successfully created. </span><span class="koboSpan" id="kobo.714.2">It will also verify that the user profile can be successfully retrieved by using the assigned user ID. </span></li>
<li><span class="koboSpan" id="kobo.715.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">sentToTheUsersEndpoint</span></strong><span class="koboSpan" id="kobo.717.1"> function sends a JSON payload to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">POST /users</span></strong><span class="koboSpan" id="kobo.719.1"> endpoint and verifies that the endpoint responds with the correct user details. </span><span class="koboSpan" id="kobo.719.2">It will also get access to the user ID that the application generates for the new </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">user profile.</span></span></li>
<li><span class="koboSpan" id="kobo.721.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">theBookSwapAppIsUp</span></strong><span class="koboSpan" id="kobo.723.1"> function sends a request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">GET /</span></strong><span class="koboSpan" id="kobo.725.1"> endpoint and verifies that the application responds with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">200 OK</span></strong><span class="koboSpan" id="kobo.727.1"> status code. </span><span class="koboSpan" id="kobo.727.2">In production, we often expose a separate </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">/health</span></strong><span class="koboSpan" id="kobo.729.1"> endpoint, but we will make use of the root endpoint for the purposes of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">BookSwap</span></strong><span class="koboSpan" id="kobo.731.1"> demo application. </span></li>
<li><span class="koboSpan" id="kobo.732.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">userDetails</span></strong><span class="koboSpan" id="kobo.734.1"> function will create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">db.User</span></strong><span class="koboSpan" id="kobo.736.1"> instance that we will marshal to the JSON payload and send to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">sentToTheUsersEndpoint</span></strong><span class="koboSpan" id="kobo.738.1"> step. </span><span class="koboSpan" id="kobo.738.2">It will also serve as the expected value, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">want</span></strong><span class="koboSpan" id="kobo.740.1"> variable,  in our test assertions. </span></li>
</ol>
<p><span class="koboSpan" id="kobo.741.1">We will need to implement these functions to invoke the functionality of our application. </span></p>
<p><span class="koboSpan" id="kobo.742.1">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">InitializeScenario</span></strong><span class="koboSpan" id="kobo.744.1"> function ties together all these functions into steps and orders them alphabetically. </span><span class="koboSpan" id="kobo.744.2">We will have to correctly order them according to our feature definition when we implement our test file. </span></p>
<p><span class="koboSpan" id="kobo.745.1">While the </span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.746.1">generated code is simple, it provides a scaffold for our test code and takes care of the interaction required with the Godog test runner. </span></p>
<h3><span class="koboSpan" id="kobo.747.1">Step 3 – creating a test file</span></h3>
<p><span class="koboSpan" id="kobo.748.1">Just as with regular </span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.749.1">unit tests, Godog tests also live in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">*_test.go</span></strong><span class="koboSpan" id="kobo.751.1"> files </span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.752.1">and live alongside the packages that they test. </span><span class="koboSpan" id="kobo.752.2">As we will test the entire application, we create a test file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">root</span></strong><span class="koboSpan" id="kobo.754.1"> directory, at the same level as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">/features</span></strong><span class="koboSpan" id="kobo.756.1"> directory. </span><span class="koboSpan" id="kobo.756.2">We create a test file matching the name of the feature and paste the generated file inside it: </span></p>
<pre class="console"><span class="koboSpan" id="kobo.757.1">
$ vi /cmd/newUserAddsBook_test.go</span></pre>
<p><span class="koboSpan" id="kobo.758.1">While the name of the test does not need to match, using a matching test will allow Godog to match the test with the feature. </span></p>
<p><span class="koboSpan" id="kobo.759.1">With the test file and code created, we execute </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">godog run</span></strong><span class="koboSpan" id="kobo.761.1"> again. </span><span class="koboSpan" id="kobo.761.2">The test runner will mark the scenario as </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">pending</span></strong><span class="koboSpan" id="kobo.763.1">: </span></p>
<pre class="console"><span class="koboSpan" id="kobo.764.1">
Background: Verify configuration
  Given the BookSwap app is up # newUserSignsUp_test.go:148 -&gt; theBookSwapAppIsUp
</span><strong class="bold"><span class="koboSpan" id="kobo.765.1">      TODO: write pending definition</span></strong><span class="koboSpan" id="kobo.766.1">
 
Scenario: Sign up       # </span><strong class="bold"><span class="koboSpan" id="kobo.767.1">features/newUserSignsUp.feature:9</span></strong><span class="koboSpan" id="kobo.768.1">
  Given user details    # </span><strong class="bold"><span class="koboSpan" id="kobo.769.1">newUserSignsUp_test.go:152</span></strong><span class="koboSpan" id="kobo.770.1"> -&gt; userDetails
  When sent to the users endpoint # </span><strong class="bold"><span class="koboSpan" id="kobo.771.1">newUserSignsUp_test.go:144</span></strong><span class="koboSpan" id="kobo.772.1"> -&gt; sentToTheUsersEndpoint
  Then a new user profile is created # </span><strong class="bold"><span class="koboSpan" id="kobo.773.1">newUserSignsUp_test.go:140</span></strong><span class="koboSpan" id="kobo.774.1"> -&gt; aNewUserProfileIsCreate</span></pre>
<p><span class="koboSpan" id="kobo.775.1">Conveniently, the </span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.776.1">output prints out the line numbers for each step as well, showing</span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.777.1"> us where we are missing the implementation required for </span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">our tests.</span></span></p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.779.1">Implementing test steps</span></h2>
<p><span class="koboSpan" id="kobo.780.1">Now that Godog has </span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.781.1">conveniently generated a scaffold for our test steps, we begin writing test code according to the functionality of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">BookSwap</span></strong><span class="koboSpan" id="kobo.783.1"> application. </span><span class="koboSpan" id="kobo.783.2">However, as described in the previous section, we will need to pass information between </span><span class="No-Break"><span class="koboSpan" id="kobo.784.1">test steps.</span></span></p>
<p><span class="koboSpan" id="kobo.785.1">The way to do this in Godog is by passing information through chained contexts. </span><span class="koboSpan" id="kobo.785.2">Godog will pass the contexts between the test steps, allowing us to pass information between steps in a safe way. </span><span class="koboSpan" id="kobo.785.3">In order to do this, we will need to change the signature of the test steps to take in a context and return a context and an error: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.786.1">
func theBookSwapAppIsUp(</span><strong class="bold"><span class="koboSpan" id="kobo.787.1">ctx context.Context</span></strong><span class="koboSpan" id="kobo.788.1">)(</span><strong class="bold"><span class="koboSpan" id="kobo.789.1">context.Context, error</span></strong><span class="koboSpan" id="kobo.790.1">) { 
  // test step implementation 
}</span></pre>
<p><span class="koboSpan" id="kobo.791.1">The test steps take in a context and return a context and error. </span><span class="koboSpan" id="kobo.791.2">Under the hood, Godog will handle each of these return values correctly: chaining the returned context to subsequent test steps and failing the test in the case of a non-nil error. </span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.792.1">Context refresher</span></p>
<p class="callout"><span class="koboSpan" id="kobo.793.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">context</span></strong><span class="koboSpan" id="kobo.795.1"> type is part of Go’s standard library and its purpose is to carry deadlines, cancellations, and request-scoped variables. </span><span class="koboSpan" id="kobo.795.2">Contexts should be propagated across functions, allowing us to tie together function calls to requests across the layers of our application. </span><span class="koboSpan" id="kobo.795.3">Creating a new context requires a parent context. </span><span class="koboSpan" id="kobo.795.4">Cancellations then propagate across the chain of </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">children contexts.</span></span></p>
<p><span class="koboSpan" id="kobo.797.1">For our purposes, we will use contexts to carry request-scoped variables. </span><span class="koboSpan" id="kobo.797.2">We will create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">contextKey</span></strong><span class="koboSpan" id="kobo.799.1"> custom type that will carry all the variables that we need to pass between </span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">test steps:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.801.1">
// contextKey is used to pass information between test 
// steps.
</span><span class="koboSpan" id="kobo.801.2">type contextKey struct {
  UsersURL string
  User     db.User
}</span></pre>
<p><span class="koboSpan" id="kobo.802.1">In our case, we will </span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.803.1">propagate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.804.1">BookSwap</span></strong><span class="koboSpan" id="kobo.805.1"> application’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">UsersURL</span></strong><span class="koboSpan" id="kobo.807.1"> and the wanted value of the created user. </span><span class="koboSpan" id="kobo.807.2">In our background step, </span><strong class="source-inline"><span class="koboSpan" id="kobo.808.1">theBookSwapAppIsUp</span></strong><span class="koboSpan" id="kobo.809.1">, we see a demonstration of the usage of the context to pass information to </span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">subsequent steps:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.811.1">
func theBookSwapAppIsUp(ctx context.Context) (context.Context, error) {
</span><strong class="bold"><span class="koboSpan" id="kobo.812.1">  url, err := getTestURL()</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.813.1">  if err != nil {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.814.1">    return ctx, fmt.Errorf("incorrect config:%v", err)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.815.1">  }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.816.1">  </span></strong><strong class="bold"><span class="koboSpan" id="kobo.817.1">resp, err := http.Get(url)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.818.1">  if err != nil || resp.StatusCode != http.StatusOK {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.819.1">    return ctx, fmt.Errorf("bookswap not up:%v", err)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.820.1">  }</span></strong><span class="koboSpan" id="kobo.821.1">
  return </span><strong class="bold"><span class="koboSpan" id="kobo.822.1">context.WithValue</span></strong><span class="koboSpan" id="kobo.823.1">(ctx, contextKey{}, </span><strong class="bold"><span class="koboSpan" id="kobo.824.1">contextKey{</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.825.1">    UsersURL: url + "/users",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.826.1">  })</span></strong><span class="koboSpan" id="kobo.827.1">, nil
}</span></pre>
<p><span class="koboSpan" id="kobo.828.1">This code snippet </span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.829.1">demonstrates the implementation of a step that interacts with a REST endpoint: </span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.830.1">We set the URL value for the environment that we will be testing by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">getTestURL</span></strong><span class="koboSpan" id="kobo.832.1"> helper function. </span><span class="koboSpan" id="kobo.832.2">This function constructs the URL based on the environment variables specified for the application. </span><span class="koboSpan" id="kobo.832.3">This makes it easy for us to configure our test to run in different test environments, local or remote. </span><span class="koboSpan" id="kobo.832.4">If you want to run with the default values, set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">BOOKSWAP_BASE_URL</span></strong><span class="koboSpan" id="kobo.834.1"> environment variable to </span><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">http://localhost</span></strong><span class="koboSpan" id="kobo.836.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">BOOKSWAP_PORT</span></strong><span class="koboSpan" id="kobo.838.1"> environment variable to </span><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">3000</span></strong><span class="koboSpan" id="kobo.840.1"> to your </span><span class="No-Break"><span class="koboSpan" id="kobo.841.1">terminal session.</span></span></li>
<li><span class="koboSpan" id="kobo.842.1">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">http.Get</span></strong><span class="koboSpan" id="kobo.844.1"> method to interact with the defined URL, saving the error and the response. </span><span class="koboSpan" id="kobo.844.2">We are familiar with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.845.1">net/http</span></strong><span class="koboSpan" id="kobo.846.1"> library from previous chapters. </span><span class="koboSpan" id="kobo.846.2">Its usage is no different in this test. </span></li>
<li><span class="koboSpan" id="kobo.847.1">In the case of an error or a status code other than </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">200 OK</span></strong><span class="koboSpan" id="kobo.849.1">, we return an error. </span><span class="koboSpan" id="kobo.849.2">This will fail this step and end the test. </span></li>
<li><span class="koboSpan" id="kobo.850.1">Finally, in the case of success, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">context.WithValue</span></strong><span class="koboSpan" id="kobo.852.1"> function to create a child context from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">ctx</span></strong><span class="koboSpan" id="kobo.854.1"> parameter value, passing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.855.1">contextKey</span></strong><span class="koboSpan" id="kobo.856.1"> value with the populated </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">UsersURL</span></strong><span class="koboSpan" id="kobo.858.1">. </span><span class="koboSpan" id="kobo.858.2">In later steps, we will be able to use this URL for our requests. </span></li>
</ol>
<p><span class="koboSpan" id="kobo.859.1">One other change we </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.860.1">need to make to the generated test steps is to reorder them according to the order in which they should run. </span><span class="koboSpan" id="kobo.860.2">This step is not intuitive if you have never used Godog, but will be easy to track down if forgotten as your test will fail. </span></p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.861.1">Running the test suite</span></h2>
<p><span class="koboSpan" id="kobo.862.1">With everything </span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.863.1">implemented, it’s time to take our test out for a spin. </span><span class="koboSpan" id="kobo.863.2">First, we remember to run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">BookSwap</span></strong><span class="koboSpan" id="kobo.865.1"> application, either using </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1"> docker compose -f docker-compose.book-swap.chapter06.yml up --build</span></strong><span class="koboSpan" id="kobo.867.1"> command. </span><span class="koboSpan" id="kobo.867.2">Unless you have changed your configuration, this will expose the application at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">http://localhost:3000</span></strong><span class="koboSpan" id="kobo.869.1"> URL. </span><span class="koboSpan" id="kobo.869.2">You can easily verify that the application is running by performing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">curl</span></strong><span class="koboSpan" id="kobo.871.1"> command against </span><span class="No-Break"><span class="koboSpan" id="kobo.872.1">this endpoint:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.873.1">
$ curl --location --request GET 'http://localhost:3000'
</span><strong class="bold"><span class="koboSpan" id="kobo.874.1">{"message":"Welcome to the BookSwap service!"}</span></strong></pre>
<p><span class="koboSpan" id="kobo.875.1">If you see a welcome response, then the application is up and correctly connected to its database. </span></p>
<p><span class="koboSpan" id="kobo.876.1">With the application running, we execute our test using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">godog </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.878.1">run</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.879.1"> command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.880.1">
$ cd chapter06 &amp;&amp; godog run 
Feature: New user signs up
  In order to use the BookSwap application
  As a new user
  I need to be able to sign up.
</span><span class="koboSpan" id="kobo.880.2">Background: Verify configuration
  Given the BookSwap app is up  # newUserSignsUp_test.go:23 -&gt; theBookSwapAppIsUp
Scenario: Sign up             # features/newUserSignsUp.feature:9
  Given user details     # newUserSignsUp_test.go:35 -&gt; userDetails
  When sent to the users endpoint # newUserSignsUp_test.go:50 -&gt; sentToTheUsersEndpoint
  Then a new user profile is created # newUserSignsUp_test.go:84 -&gt; aNewUserProfileIsCreated
</span><strong class="bold"><span class="koboSpan" id="kobo.881.1">1 scenarios (1 passed)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.882.1">4 steps (4 passed)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.883.1">11.876996ms</span></strong></pre>
<p><span class="koboSpan" id="kobo.884.1">As we can see </span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.885.1">from the terminal output, Godog runs one scenario and all four steps passed. </span><span class="koboSpan" id="kobo.885.2">Alternatively, you can run the tests using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">go test</span></strong><span class="koboSpan" id="kobo.887.1"> command if you don’t want to install the Godog CLI, but that will not format the test results, as you see</span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.888.1"> in the preceding output. </span></p>
<p><span class="koboSpan" id="kobo.889.1">We have successfully written and run our first E2E test for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.890.1">BookSwap</span></strong><span class="koboSpan" id="kobo.891.1"> application, which has been extended with persistent storage. </span><span class="koboSpan" id="kobo.891.2">The test was written using the Godog open source testing library, which allowed us to write easy-to-read BDD-style tests. </span><span class="koboSpan" id="kobo.891.3">We are well on our way to becoming Go testing experts. </span></p>
<h1 id="_idParaDest-135"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.892.1">Using database assertions</span></h1>
<p><span class="koboSpan" id="kobo.893.1">We have learned how to start up our </span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.894.1">application in a test environment, as well as how to write and run E2E tests for our application. </span><span class="koboSpan" id="kobo.894.2">This has taken us far toward verifying the behavior of our application, but how can we be sure that the stored data and database components are correct? </span><span class="koboSpan" id="kobo.894.3">The final aspect of E2E testing that will help us answer this question is database testing. </span><span class="koboSpan" id="kobo.894.4">Looking at the tests we have written so far, we notice two things: </span></p>
<ul>
<li><span class="koboSpan" id="kobo.895.1">The database is typically initialized as empty, then the tables are torn down once the application shuts down. </span><span class="koboSpan" id="kobo.895.2">This has the advantage that we know there will be no persistent data that interferes with our tests, but it has the disadvantage of having to set up any required data as part of the test. </span><span class="koboSpan" id="kobo.895.3">For example, in our case, registering an available book requires a user ID, so we will have to create a user first before we do any book-related tasks. </span><span class="koboSpan" id="kobo.895.4">This can make our test suite running time longer. </span></li>
<li><span class="koboSpan" id="kobo.896.1">The items from the database are asserted through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">BookSwap</span></strong><span class="koboSpan" id="kobo.898.1"> endpoints. </span><span class="koboSpan" id="kobo.898.2">For example, we check that a user was correctly stored in the database by making a request to </span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">GET /users/{id}</span></strong><span class="koboSpan" id="kobo.900.1"> with its corresponding user ID. </span><span class="koboSpan" id="kobo.900.2">However, as requests travel down the entire application stack, it can become difficult to pinpoint the source of the error. </span></li>
</ul>
<p><span class="koboSpan" id="kobo.901.1">Let us explore these two pain points further to get a better understanding of how to address them. </span></p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.902.1">Seed data</span></h2>
<p><span class="koboSpan" id="kobo.903.1">As discussed in the previous </span><em class="italic"><span class="koboSpan" id="kobo.904.1">Persistent storage</span></em><span class="koboSpan" id="kobo.905.1"> section, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">golang-migrate</span></strong><span class="koboSpan" id="kobo.907.1"> to write database migrations, which allows us to create and set up our database for usage before the application starts up. </span><span class="koboSpan" id="kobo.907.2">Then, we use the </span><strong class="bold"><span class="koboSpan" id="kobo.908.1">GORM</span></strong><span class="koboSpan" id="kobo.909.1"> library</span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.910.1"> as our ORM, which allows us to easily interact with our database using custom types. </span></p>
<p><span class="koboSpan" id="kobo.911.1">The next step would be to insert</span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.912.1"> some data into our newly created tables. </span><span class="koboSpan" id="kobo.912.2">This type of initial data is known as </span><strong class="bold"><span class="koboSpan" id="kobo.913.1">seed data</span></strong><span class="koboSpan" id="kobo.914.1">. </span><span class="koboSpan" id="kobo.914.2">We can add seed data to our databases by simply adding the corresponding SQL statements to the migration file. </span><span class="koboSpan" id="kobo.914.3">For example, we can create an initial user after the table is created in the up migration by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.915.1">INSERT</span></strong><span class="koboSpan" id="kobo.916.1"> command: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.917.1">
INSERT INTO users VALUES ('ABC-123','Initial user', '1 London Road', 'N1', 'UK');</span></pre>
<p><span class="koboSpan" id="kobo.918.1">However, none of the tools we have explored have the capability of creating and adding random seeds for our application. </span><span class="koboSpan" id="kobo.918.2">We could add another library dependency for generating random data, but instead, we can make use of GORM’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.919.1">DB</span></strong><span class="koboSpan" id="kobo.920.1"> type to insert random data into our database before our tests run: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.921.1">
func addUser() error {
  </span><strong class="bold"><span class="koboSpan" id="kobo.922.1">dbConn, err := gorm.Open(postgres.Open(postgresURL), &amp;gorm.Config{})</span></strong><span class="koboSpan" id="kobo.923.1">
  if err != nil {
    return err
  }
  </span><strong class="bold"><span class="koboSpan" id="kobo.924.1">dbConn.Save(&amp;db.User{</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.925.1">     ID:       uuid.New().String(),</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.926.1">     Name:     "Generated User",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.927.1">  })</span></strong><span class="koboSpan" id="kobo.928.1">
  return nil
}</span></pre>
<p><span class="koboSpan" id="kobo.929.1">The previous code snippet demonstrates how to insert data into the database alongside running our Godog test steps, as detailed here: </span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.930.1">Just as at the application start, we open a new connection to our PostgreSQL database. </span><span class="koboSpan" id="kobo.930.2">Database connections should be shared between tests as much as possible, and you should not open them for many test iterations. </span><span class="koboSpan" id="kobo.930.3">However, as database start positions are usually required for E2E tests, it’s feasible to set up our database in this way. </span></li>
<li><span class="koboSpan" id="kobo.931.1">Once the database connection </span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.932.1">is opened successfully, we save a generated user using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.933.1">Save</span></strong><span class="koboSpan" id="kobo.934.1"> method of the GORM database. </span><span class="koboSpan" id="kobo.934.2">After this, the database will contain the generated data and can be used across our tests. </span></li>
</ol>
<h2 id="_idParaDest-137"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.935.1">Test cases and assertions</span></h2>
<p><span class="koboSpan" id="kobo.936.1">When it comes to </span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.937.1">assertions on the contents of our database, we can take the same approach as we’ve seen with adding generated data: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.938.1">
func verifyUser(want db.User) error {
  </span><strong class="bold"><span class="koboSpan" id="kobo.939.1">dbConn, err := gorm.Open(postgres.Open(postgresURL), &amp;gorm.Config{})</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.940.1">  if err != nil {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.941.1">    log.Fatal(err)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.942.1">  }</span></strong><span class="koboSpan" id="kobo.943.1">
  var got db.User
  </span><strong class="bold"><span class="koboSpan" id="kobo.944.1">if err := dbConn.Where("id = ?", want.ID).First(&amp;got); </span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.945.1">  err != nil {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.946.1">    return err.Error</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.947.1">  }</span></strong><span class="koboSpan" id="kobo.948.1">
  if want != got {
    return fmt.Errorf("user does not match:got %v, want %v",got, want)
  }
  return nil
}</span></pre>
<p><span class="koboSpan" id="kobo.949.1">Looking at the verification code, we see the </span><span class="No-Break"><span class="koboSpan" id="kobo.950.1">same approach:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.951.1">We connect to the database using the connection string. </span><span class="koboSpan" id="kobo.951.2">GORM will optimize the use of your database connection when being used by multiple goroutines. </span></li>
<li><span class="koboSpan" id="kobo.952.1">Then, we use the database methods to query the database for the user ID that is supplied to the method. </span><span class="koboSpan" id="kobo.952.2">Note that we rely on the GORM database directly, and not our own methods of </span><strong class="source-inline"><span class="koboSpan" id="kobo.953.1">UserService</span></strong><span class="koboSpan" id="kobo.954.1">, removing any possible bugs that we may have introduced. </span></li>
</ol>
<p><span class="koboSpan" id="kobo.955.1">While GORM is easy to use, it </span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.956.1">might feel quite verbose to write full database queries to assert on returned values. </span><span class="koboSpan" id="kobo.956.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.957.1">dbassert</span></strong><span class="koboSpan" id="kobo.958.1"> open source library (</span><a href="https://github.com/hashicorp/dbassert"><span class="koboSpan" id="kobo.959.1">https://github.com/hashicorp/dbassert</span></a><span class="koboSpan" id="kobo.960.1">) provides </span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.961.1">wrappers and helper functions that can make this easier for you. </span><span class="koboSpan" id="kobo.961.2">You can explore this library by yourself and see how it can help streamline your test code. </span></p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.962.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.963.1">In this chapter, we spent our efforts extending the </span><strong class="source-inline"><span class="koboSpan" id="kobo.964.1">BookSwap</span></strong><span class="koboSpan" id="kobo.965.1"> application. </span><span class="koboSpan" id="kobo.965.2">We began by discussing what a typical user journey for a user will be, added a PostgreSQL database to it, and configured it to run with Docker. </span><span class="koboSpan" id="kobo.965.3">Then, we explored the Godog testing library, which makes it easy to write BDD-style tests, as well as E2E tests. </span><span class="koboSpan" id="kobo.965.4">We made use of Godog to verify that users are able to sign up on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">BookSwap</span></strong><span class="koboSpan" id="kobo.967.1"> application, making use of the code generation abilities of Godog. </span><span class="koboSpan" id="kobo.967.2">Finally, we briefly discussed the challenges of creating database start positions and assertions directly at the database level. </span></p>
<p><span class="koboSpan" id="kobo.968.1">In </span><a href="B18371_07.xhtml#_idTextAnchor162"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.969.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.970.1">, </span><em class="italic"><span class="koboSpan" id="kobo.971.1">Refactoring in Go</span></em><span class="koboSpan" id="kobo.972.1">, we will discuss tools and techniques for code refactoring and how to break up monoliths into multiple services. </span><span class="koboSpan" id="kobo.972.2">This will give us a realistic understanding of how to rely on our tests to verify that refactoring does not cause errors or break </span><span class="No-Break"><span class="koboSpan" id="kobo.973.1">existing functionality.</span></span></p>
<h1 id="_idParaDest-139"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.974.1">Questions</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.975.1">What is the purpose of a </span><span class="No-Break"><span class="koboSpan" id="kobo.976.1">user journey?</span></span></li>
<li><span class="koboSpan" id="kobo.977.1">What is ORM? </span></li>
<li><span class="koboSpan" id="kobo.978.1">What is the advantage of using </span><span class="No-Break"><span class="koboSpan" id="kobo.979.1">Docker Compose?</span></span></li>
<li><span class="koboSpan" id="kobo.980.1">What is database seeding? </span></li>
</ol>
<h1 id="_idParaDest-140"><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.981.1">Further reading</span></h1>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.982.1">User Story Mapping: Discover the Whole Story, Build the Right Product</span></em><span class="koboSpan" id="kobo.983.1">, </span><em class="italic"><span class="koboSpan" id="kobo.984.1">Jeff Patton</span></em><span class="koboSpan" id="kobo.985.1">, </span><em class="italic"><span class="koboSpan" id="kobo.986.1">Peter Economy</span></em><span class="koboSpan" id="kobo.987.1">. </span><span class="koboSpan" id="kobo.987.2">Published </span><span class="No-Break"><span class="koboSpan" id="kobo.988.1">by </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.989.1">O’Reilly</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.990.1">.</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.991.1">The Book Of Kubernetes: A Hands-on Deep Dive into Container Technology</span></em><span class="koboSpan" id="kobo.992.1">, </span><em class="italic"><span class="koboSpan" id="kobo.993.1">Alan Hohn</span></em><span class="koboSpan" id="kobo.994.1">. </span><span class="koboSpan" id="kobo.994.2">Published by </span><em class="italic"><span class="koboSpan" id="kobo.995.1">No </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.996.1">Starch Press</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.997.1">.</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.998.1">SQL &amp; NoSQL Databases: Models, Languages, Consistency Options and Architectures for Big Data Management</span></em><span class="koboSpan" id="kobo.999.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1000.1">Andreas Meier</span></em><span class="koboSpan" id="kobo.1001.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1002.1">Michael Kaufmann</span></em><span class="koboSpan" id="kobo.1003.1">. </span><span class="koboSpan" id="kobo.1003.2">Published by </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1004.1">Springer Vieweg</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1005.1">.</span></span></li>
</ul>
</div>
</body></html>