["```go\nFROM golang:1.19-alpine\nWORKDIR /app\nCOPY go.mod ./\nCOPY go.sum ./\nCOPY . .\nRUN go mod download\nRUN go build ./chapter06/cmd\nEXPOSE ${BOOKSWAP_PORT}\nCMD [ \"./cmd\" ]\n```", "```go\n$ migrate create -ext sql -dir chapter06/db/migrations -seq create_users_table\n$ migrate create -ext sql -dir chapter06/db/migrations -seq create_books_table\n```", "```go\nBEGIN;\nCREATE TABLE IF NOT EXISTS users\n(\n   id VARCHAR (50) PRIMARY KEY,\n   name VARCHAR (50) NOT NULL,\n   // other column definitions\n);\nCOMMIT;\n```", "```go\nDROP TABLE IF EXISTS users;\n```", "```go\nfunc main() {\n// other initialisation code\n  postgresURL, ok := os.LookupEnv(\"BOOKSWAP_DB_URL\")\n  if !ok {\n    log.Fatal(\"env variable BOOKSWAP_DB_URL not found\")\n  }\n  m, err := migrate.New(\"file://chapter06/db/migrations\", postgresURL)\n  if err != nil {\n    log.Fatal(err)\n  }\n  if err := m.Up(); err != nil {\n    log.Fatal(err)\n  }\n   defer func() {\n      m.Down()\n  }()\n  // other initialisation code\n}\n```", "```go\nfunc main() {\n  // other initialisation code\n  postgresURL, ok := os.LookupEnv(\"BOOKSWAP_DB_URL\")\n  if !ok {\n    log.Fatal(\"$BOOKSWAP_DB_URL not found\")\n  }\n  dbConn, err := gorm.Open(postgres.Open(postgresURL), &gorm.Config{})\n  if err != nil {\n    log.Fatal(err)\n  } \n  ps := db.NewPostingService()\n  b := db.NewBookService(dbConn, ps)\n  u := db.NewUserService(dbConn, b)\n  // initialisation code continues\n }\n```", "```go\n// ListByUser returns the list of books for a given user.\nfunc (bs *BookService) ListByUser(userID string) ([]Book, error) {\n  var items []Book\n  if result := bs.DB.Where(\"owner_id = ?\", userID).Find(&items);\n    result.Error != nil {\n      return nil, result.Error\n  }\nreturn items, nil\n}\n```", "```go\nversion: '3'\nservices:\n books:\n  build:\n   context: .\n   dockerfile: Dockerfile.book-swap.chapter06\n  ports:\n   - \"${BOOKSWAP_PORT}:${BOOKSWAP_PORT}\"\n  depends_on:\n   db:\ncondition: service_healthy\n  restart: on-failure\n  env_file:\n   - docker.env db:\n  image: postgres:15.0-alpine\n  ports:\n   - \"5432:5432\"\n  expose:\n   - \"5432\"\n  env_file:\n   - docker.env\n  restart: on-failure\n```", "```go\nPOSTGRES_USER=root\nPOSTGRES_PASSWORD=root\nPOSTGRES_DB=books\nBOOKSWAP_DB_URL=postgres://root:root@db:5432/books?sslmode=disable\nBOOKSWAP_PORT=3000\n```", "```go\n$ go install github.com/cucumber/godog/cmd/godog@latest\n```", "```go\nFeature: New user signs up\n In order to use the BookSwap application\n As a new user\n I need to be able to sign up.\nBackground: Verify configuration\n Given the BookSwap app is up\nScenario: Sign up\n Given user details\n When sent to the users endpoint\n Then a new user profile is created\n```", "```go\n$ mkdir chapter06/features\n$ vim chapter06/features/newUserSignsUp.feature\n```", "```go\nfunc aNewUserProfileIsCreated() error {\n  return godog.ErrPending\n}\nfunc sentToTheUsersEndpoint() error {\n  return godog.ErrPending\n}\nfunc theBookSwapAppIsUp() error {\n  return godog.ErrPending\n}\nfunc userDetails() error {\n  return godog.ErrPending\n}\n\nfunc InitializeScenario(ctx *godog.ScenarioContext) {\n  ctx.Step(`^a new user profile is create, \n    aNewUserProfileIsCreated)\n  ctx.Step(`^sent to the users endpoint$`, \n    sentToTheUsersEndpoint)\n  ctx.Step(`^the BookSwap app is up$`, theBookSwapAppIsUp)\n  ctx.Step(`^user details$`, userDetails)\n}\n```", "```go\n$ vi /cmd/newUserAddsBook_test.go\n```", "```go\nBackground: Verify configuration\n  Given the BookSwap app is up # newUserSignsUp_test.go:148 -> theBookSwapAppIsUp\n      TODO: write pending definition\n\nScenario: Sign up       # features/newUserSignsUp.feature:9\n  Given user details    # newUserSignsUp_test.go:152 -> userDetails\n  When sent to the users endpoint # newUserSignsUp_test.go:144 -> sentToTheUsersEndpoint\n  Then a new user profile is created # newUserSignsUp_test.go:140 -> aNewUserProfileIsCreate\n```", "```go\nfunc theBookSwapAppIsUp(ctx context.Context)(context.Context, error) { \n  // test step implementation \n}\n```", "```go\n// contextKey is used to pass information between test \n// steps.\ntype contextKey struct {\n  UsersURL string\n  User     db.User\n}\n```", "```go\nfunc theBookSwapAppIsUp(ctx context.Context) (context.Context, error) {\n  url, err := getTestURL()\n  if err != nil {\n    return ctx, fmt.Errorf(\"incorrect config:%v\", err)\n  }\nresp, err := http.Get(url)\n  if err != nil || resp.StatusCode != http.StatusOK {\n    return ctx, fmt.Errorf(\"bookswap not up:%v\", err)\n  }\n  return context.WithValue(ctx, contextKey{}, contextKey{\n    UsersURL: url + \"/users\",\n  }), nil\n}\n```", "```go\n$ curl --location --request GET 'http://localhost:3000'\n{\"message\":\"Welcome to the BookSwap service!\"}\n```", "```go\n$ cd chapter06 && godog run \nFeature: New user signs up\n  In order to use the BookSwap application\n  As a new user\n  I need to be able to sign up.\nBackground: Verify configuration\n  Given the BookSwap app is up  # newUserSignsUp_test.go:23 -> theBookSwapAppIsUp\nScenario: Sign up             # features/newUserSignsUp.feature:9\n  Given user details     # newUserSignsUp_test.go:35 -> userDetails\n  When sent to the users endpoint # newUserSignsUp_test.go:50 -> sentToTheUsersEndpoint\n  Then a new user profile is created # newUserSignsUp_test.go:84 -> aNewUserProfileIsCreated\n1 scenarios (1 passed)\n4 steps (4 passed)\n11.876996ms\n```", "```go\nINSERT INTO users VALUES ('ABC-123','Initial user', '1 London Road', 'N1', 'UK');\n```", "```go\nfunc addUser() error {\n  dbConn, err := gorm.Open(postgres.Open(postgresURL), &gorm.Config{})\n  if err != nil {\n    return err\n  }\n  dbConn.Save(&db.User{\n     ID:       uuid.New().String(),\n     Name:     \"Generated User\",\n  })\n  return nil\n}\n```", "```go\nfunc verifyUser(want db.User) error {\n  dbConn, err := gorm.Open(postgres.Open(postgresURL), &gorm.Config{})\n  if err != nil {\n    log.Fatal(err)\n  }\n  var got db.User\n  if err := dbConn.Where(\"id = ?\", want.ID).First(&got); \n  err != nil {\n    return err.Error\n  }\n  if want != got {\n    return fmt.Errorf(\"user does not match:got %v, want %v\",got, want)\n  }\n  return nil\n}\n```"]