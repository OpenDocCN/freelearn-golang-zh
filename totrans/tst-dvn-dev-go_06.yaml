- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: End-to-End Testing the BookSwap Web Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have made a lot of progress toward our goal of learning how to use TDD for
    implementing and testing Go code. So far, we have covered a wide variety of techniques
    for implementing unit and integration tests. Unit tests verify that each component
    works as intended, while integration tests extend their scope to cover the seams
    and interactions between different units. Moreover, we have learned how to apply
    these techniques to a wide variety of examples, including the `BookSwap` web application
    introduced in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: These tests give us a fast feedback loop for code changes, as they don’t require
    the entirety of the application to be started up and made available before the
    test suite is run. As discussed in [*Chapter 5*](B18371_05.xhtml#_idTextAnchor124),
    *Performing Integration Testing*, we learned how to make use of the `httptest`
    and `ginkgo` libraries to easily write and run integration tests for web applications.
    We also learned how to make use of **behavior-driven development** (**BDD**) for
    writing tests, which is a popular technique for writing integration and **end-to-end**
    (**E2E**) tests.
  prefs: []
  type: TYPE_NORMAL
- en: However, while we can rely on unit and integration testing to ensure that the
    application is functioning correctly in a wide variety of scenarios, we should
    not neglect the benefits that E2E tests bring to our testing strategy. Only E2E
    tests allow us to verify the behavior of the entire application and replicate
    the user flows and experience. Simply put, these tests give us an insight into
    the user experience in production, which is the final verification that we should
    be making to our application before it is released.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is dedicated to discussing the implementation of E2E testing suites
    for the `BookSwap` web application introduced in previous chapters. We will make
    use of Docker to streamline the creation and teardown of identical applications,
    as well as discuss the changes we need to make to the application in order to
    make use of a database. Then, we will learn how to make use of Godog to write
    and run E2E tests. Finally, we will discuss which database assertions we should
    include in our tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The requirements of the `BookSwap` application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation of database storage in web applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with Cucumber and Godog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation of E2E tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database start positions and assertions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need to have **Go version 1.19** or later installed to run the code
    samples in this chapter. The installation process is described in the official
    Go documentation at [https://go.dev/doc/install](https://go.dev/doc/install).
  prefs: []
  type: TYPE_NORMAL
- en: The code examples included in this book are publicly available at [https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter06](https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: Use case – extending the BookSwap application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `BookSwap` web application was introduced in [*Chapter 4*](B18371_04.xhtml#_idTextAnchor085),
    *Building Efficient Test Suites*. Its main functionality allows users to list
    their books and swap them with other users. We learned what its main components
    and endpoints are, as well as how to apply table testing to its `BookService`.
    Then, in [*Chapter 5*](B18371_05.xhtml#_idTextAnchor124), *Performing Integration
    Testing*, we learned how to write integration tests for its `Index` request handler.
    We will continue to build out the functionality of this application in this chapter,
    taking a closer look at the user flows and intended functionality for each endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6**.1* depicts a summary of the responsibilities of the three main
    services of the `BookSwap` application—`BookService`, `UserService`, and `PostingService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – The responsibilities of the main components of the BookSwap
    application  ](img/Figure_6.1_B18371.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – The responsibilities of the main components of the BookSwap application
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the services has its own specialization and separate responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BookService` is in charge of all book management aspects. This service implements
    the functionality of creating, updating, listing, and filtering books. As this
    application is quite limited in functionality, books are only filtered by the
    owner’s user ID, and we will not implement any searching for the `books` inventory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UserService` is in charge of all user management aspects. This service implements
    functionality for creating and updating user profiles. It can also fetch a given
    user by ID and relies on `BookService` to receive a list of all books whose owner
    ID corresponds to the supplied user ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PostingService` is an external service to the `BookSwap` application, which
    is in charge of the details of posting and swapping books. For implementation
    purposes, we will use a `BookSwap` application. `PostingService` is not a service
    that actually exists, but we will use an internal stub to simulate calling out
    to an external service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a stub?
  prefs: []
  type: TYPE_NORMAL
- en: A **stub** is a concrete implementation of another component. Stubs don’t make
    use of mocking frameworks, as they are used by implementation code. They make
    testing easier and allow us to build code as if the external component were built
    and implemented. Due to the flexibility of interfaces in Go, stubbed implementations
    can be easily swapped out for real implementations.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in [*Chapter 4*](B18371_04.xhtml#_idTextAnchor085), *Building Efficient
    Test Suites*, `BookSwap` saves its data in maps and does not currently have any
    database or persistent storage. We will change its implementation to use a **PostgreSQL**
    database in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: User journeys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we will focus on the implementation of E2E tests. The focus
    of these tests is to verify the behavior of the application under typical **user
    journeys**. Therefore, it is important to establish typical user journeys or request
    flows before writing any E2E test cases.
  prefs: []
  type: TYPE_NORMAL
- en: What is a user journey?
  prefs: []
  type: TYPE_NORMAL
- en: A user journey is the path or sequence of requests that the user of an application
    will take in order to achieve their goal. Often, these journeys are tracked in
    production environments to get insights into how users are using services.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6**.2* depicts the expected request flow for a new user for the `BookSwap`
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – The request flow of a new BookSwap application user ](img/Figure_6.2_B18371.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – The request flow of a new BookSwap application user
  prefs: []
  type: TYPE_NORMAL
- en: 'The request flow diagram gives us an insight into which parts of the application
    are required for the user journey to be successfully completed. The expected usage
    of the application for a new user is outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`POST /users` endpoint, passing the details of the user profile as a JSON request
    body. The `UserService` service will then create the user and return it to the
    client.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`BookSwap` application and viewing which books are available for swapping.
    The client issues a `GET /books` request. `BookService` will fetch a list of books,
    filtering them by available status.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`POST /books/{id}` request, passing the ID of the book that they want to book.
    Then, they pass their own user ID as a URL parameter, completing the URL of the
    request as `POST /books/id?user={userId}`. This could also have been implemented
    with a request body.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Looking at the main components in *Figure 6**.2*, we notice that there is an
    extra component named `HTTP Server`. The implementation of `HTTP Server` in the
    `BookSwap` application consists of a few different parts:'
  prefs: []
  type: TYPE_NORMAL
- en: A handler custom type with `Index` example in [*Chapter 5*](B18371_05.xhtml#_idTextAnchor124),
    *Performing Integration Testing*. Typically, the handler custom type has access
    to all the dependencies it requires to fulfill its exposed operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each handler function is `gorilla/mux` library to take care of the configuration
    and routing of requests to their respective handler functions. You can read more
    about the `gorilla/mux` library at [https://github.com/gorilla/mux](https://github.com/gorilla/mux).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, once routes and handlers are set up, we start the server and configure
    it to listen on a given port. This is done using the `net/http` library in the
    Go standard library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a mux?
  prefs: []
  type: TYPE_NORMAL
- en: '`gorilla/mux` is a popular solution among Go developers.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6**.2* covers a successful journey for a new user. E2E tests should
    cover a variety of scenarios, so we map out multiple request flows. However, due
    to their higher cost and running time, they typically only cover **base cases**
    or **happy paths**.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up until now, we have run applications using the `go run` command and tested
    them using the `go test` command. The downside of this approach is that we must
    set up the Go environment and any dependencies locally before we can build and
    run the code locally. In [*Chapter 5*](B18371_05.xhtml#_idTextAnchor124), *Performing
    Integration Testing*, we introduced Docker as a solution that addresses these
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: What is a Dockerfile?
  prefs: []
  type: TYPE_NORMAL
- en: A Dockerfile is a file that contains all the commands required for assembling
    an image. It is then used by Docker Engine to automatically create and start a
    container. We can view it as the specification of the setup for a Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a custom Dockerfile for our `BookSwap` application, as it
    does not have a pre-defined image in the Docker Hub image library. The `Dockerfile.book-swap.chapter06`
    file contains the `BookSwap` specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This relatively simple file demonstrates all the essential knowledge that we
    need to effectively use Docker with our Go applications:'
  prefs: []
  type: TYPE_NORMAL
- en: The `FROM` statement indicates the base image of this build stage. We choose
    an image from Docker Hub that has the `alpine` images are lightweight and run
    on the **Linux** **BusyBox distribution**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `WORKDIR` statement creates and sets the working directory of the Docker
    container. All further commands in our file execute in this directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, the `COPY` statement copies all the source files from our local directory
    to the container’s working directory. Remember that containers are isolated from
    the underlying local directories, so these files must be copied to the container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `RUN` statement executes the commands needed to build our Go executable
    by first downloading its dependencies and then specifying the directory that contains
    our application entry point. The Dockerfile is placed alongside the `go.mod` file
    in the root directory, so we need to explicitly state which of our chapter entry
    points to build from.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `EXPOSE` statement instructs the Docker container to listen to network requests
    on the given port, as indicated by the `BOOKSWAP_PORT` environment variable. This
    variable is needed for the `BookSwap` application, so ensure that it is set in
    your terminal session before you run the application. The instructions of how
    to set environment variables will be different according to your operating system.
    If you want to run with the default setup, set the `BOOKSWAP_PORT` environment
    variable to `3000`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the `CMD` statement specifies the command that should be run once the
    container starts. We run the executable from the `go` `build` step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That’s all we need to specify to run our application on any environment that
    is running Docker and has an internet connection! Most Docker specifications will
    be using this simple recipe for writing and running their custom images. We will
    see this specification in action later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Persistent storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next change we will make is to add `BookSwap` application, allowing us to
    save the state once the application shuts down. As SQL databases are still the
    most popular persistent storage solutions, we will use a SQL database in the demo
    application.
  prefs: []
  type: TYPE_NORMAL
- en: SQL database management solutions
  prefs: []
  type: TYPE_NORMAL
- en: There are a few popular SQL database solutions that you may already be familiar
    with. Some of these are **Oracle MySQL**, **Microsoft SQL Server**, and **PostgreSQL**.
    They all allow us to manage and interact with underlying SQL databases but may
    have differences in terms of the way we interact with them. Therefore, it’s important
    to use the same SQL solution in test environments as we have in production.
  prefs: []
  type: TYPE_NORMAL
- en: We will use a **PostgreSQL database**, an open source relational database widely
    used in production. It also has excellent cloud support across the public cloud
    providers, so it is a natural choice for our technology stack.
  prefs: []
  type: TYPE_NORMAL
- en: You can easily download and install it locally using the steps in the official
    documentation, available at [https://www.postgresql.org/download/](https://www.postgresql.org/download/),
    following the instructions for your operating system. Once you install it locally,
    make a note of your host, port, username, and password. You will need these to
    connect to your database and run instructions on it later.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6**.3* depicts the two main tables required for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – The SQL tables of the BookSwap application ](img/Figure_6.3_B18371.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – The SQL tables of the BookSwap application
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two tables: `books` and `users`. Each table has a column for the
    data fields of each type. As the `owner_id` value of `books` should belong to
    an existing user, there is a `id` field. All the columns are of type `varchar`,
    which corresponds to a `string` type.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we start up the application, we need to create the tables required for
    the application to function. However, we don’t want to execute SQL instructions
    outside of our source code, instead allowing us to version and review it.
  prefs: []
  type: TYPE_NORMAL
- en: The `golang-migrate` project ([https://github.com/golang-migrate/migrate](https://github.com/golang-migrate/migrate))
    allows us to write migrations and run them as part of our application startup.
    The `migrate` CLI tool can easily be installed on your environment by following
    the installation steps in the *Getting started* tutorials available in the project
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, we can generate migrations for our two required tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `migrate` CLI tool creates two files for each table, named `*.up.sql` and
    `*.down.sql`. The intended usage of these files is that the up migration creates
    the table at startup, and the down migration deletes the table once the application
    shuts down. This ensures that tables are removed after each run of the application
    and that they are always created at startup. Then, we add the columns required
    for each table. The configuration of the `users` table is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The migration creates a table if one does not exist and marks the `id` column
    as the primary key. The specification matches the columns defined in *Figure 6**.3*.
    The down migration is one single line, which drops the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration of the `books` table is done in the same way. Finally, we
    add the migrations to the entry point of the `BookSwap` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Interacting with the `migrate` library requires three extra steps to be added
    to the startup of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a `postgres://user:password@host:port/database`. The `BookSwap` application
    requires an environment variable named `BOOKSWAP_DB_URL`, which contains this
    value. Make sure that this environment variable is set before starting the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the migrate instance is created, we invoke the `Up()` method. This method
    looks at the current migration version and applies all the migrations defined
    in our `*.``up.sql` files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we want to clean up after the application shuts down or in the case of an
    error, we defer a call to the migration `Down()` method. This method uses the
    same version management and runs the contents of the `*.down.sql` files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `golang-migrate` library and CLI have made it easy for us to save database
    configuration alongside source code, allowing for easy versioning as well as version
    management.
  prefs: []
  type: TYPE_NORMAL
- en: Once our database and tables are created, we need to refactor our `UserService`
    and `BookService` implementations to make use of SQL tables and not the built-in
    maps we have been using so far. Typically, engineers make use of an **object-relational
    mapping** (**ORM**) library, which allows us to create a bridge between our Go
    custom types and our PostgreSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few ORM solutions in the Go ecosystem. One of the most popular ones
    is **GORM** ([https://github.com/go-gorm/gorm](https://github.com/go-gorm/gorm)),
    which is an open source easy-to-use Go library. This library will make it easy
    for us to interact with our database solution, removing the need to manage SQL
    as raw strings in our source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The setup for using GORM is very similar to what we have done using `golang-migrate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First, we connect to the database using the database URL that we used previously
    to connect with `golang-migrate`. Once successfully connected, it returns the
    GORM database wrapper of type `*gorm.DB`.
  prefs: []
  type: TYPE_NORMAL
- en: If we cannot connect to the database, then we will kill the application. We
    have also changed the signatures of the `NewBookService` and `NewUserService`
    initialization functions to take in the initialized database session.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the operations of `BookService` and `UserService` that previously saved
    models to the built-in map type will now have to leverage the operations of the
    GORM database wrapper. One example is the `BookService` `ListByUser` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This method lists all books whose owner ID matches the given user ID. The usage
    of an ORM solution allows us to invoke operations on the database using a service
    that is able to use the invocations of methods to construct the correct SQL query.
    This allows us to reduce errors and remove the need to manage and interact with
    raw SQL strings.
  prefs: []
  type: TYPE_NORMAL
- en: Running the BookSwap application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final piece of the puzzle for extensions we need to make to the `BookSwap`
    application is how to run it together with its database. As mentioned in [*Chapter
    5*](B18371_05.xhtml#_idTextAnchor124), *Performing Integration Testing*, the `docker-compose`
    tool is what we use to manage multiple Docker containers together. We now have
    two services, or parts, to the `BookSwap` application—the server-side application
    and its database. The database setup needs to be run in a Docker container as
    well, to avoid having to set up databases in every single environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `docker-compose` command takes its input from a `.yml` file, which makes
    it easy to specify the different services and their requirements. This simple
    specification in our `docker-compose.book-swap.chapter06.yml` file defines our
    `BookSwap` application and a PostgreSQL database that it can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration in this relatively simple file specifies everything we need:'
  prefs: []
  type: TYPE_NORMAL
- en: We define a services block for all the services that we start up. In our case,
    we will define the `books` service and the `db` service, each configured in its
    own sub-block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The configuration of the `books` service specifies the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The service is built from its own Dockerfile located in the current directory.
    This is the Dockerfile that we previously discussed in the *Using Docker* section
    of this chapter.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The service exposes the port specified by the `BOOKSWAP_PORT` environment variable
    on its network. This will allow us to run tests that need access to the port locally.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The service depends on the `db` service being started successfully. Docker Engine
    will take this into account when starting our service and instruct that the `db`
    service be started first.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The service uses the `docker.env` file for its environment variable configuration.
    This will specify other environment variables that we require, like `BOOKSWAP_DB_URL`
    that we have previously seen.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The configuration of the `db` service specifies the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The container should use an existing image from the Docker repository. At the
    time of writing, this was the latest image of the `5432`, as is customary for
    PostgreSQL.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: As can be seen from the documentation for this image, it requires the specification
    of a number of environment variables for the database username, password, and
    name. All of these variables will be defined in the `docker.env` file that we
    supply to this service.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Both services have a restart policy defined as well. This means that Docker
    will automatically restart containers if they fail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can provide the following sample configuration for `docker.env`, but you
    can easily change it according to your own preferences by editing the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: That’s all the configuration required for running two services together with
    the `docker compose -f docker-compose.book-swap.chapter06.yml up --build` command
    from the project root directory. This file contains a typical configuration that
    you will be able to reuse in your own projects. Furthermore, it allows us to identically
    start and run the `BookSwap` application across different environments. This provides
    us with the key advantage of being able to easily spin up test environments for
    the application as a whole. With these building blocks in place, let us have a
    look at how we can make use of this key advantage to increase the test coverage
    of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Godog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have made quite a few changes that have extended the scope
    and complexity of the `BookSwap` application. Now that we can easily start and
    tear down the application using Docker containers, it is time to turn our attention
    to writing E2E tests for our application.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B18371_05.xhtml#_idTextAnchor124), *Performing Integration
    Testing*, we looked at how to write BDD-style tests. This style of testing allows
    us to write human-readable test scenarios and use a **Given-When-Then** structure.
    These readable tests can serve as documentation for our projects, allowing us
    to involve multiple stakeholders and write tests that truly cover the functionality
    of our applications.
  prefs: []
  type: TYPE_NORMAL
- en: We also explored the `ginkgo` testing library, which allowed us to write tests
    using this style. Godog ([https://github.com/cucumber/godog](https://github.com/cucumber/godog))
    is another testing library that we will be exploring to write BDD-style tests.
    `ginkgo` allows us to add BDD-style assertions to our unit tests, but Godog provides
    extra code generation capabilities that make it a great fit for writing functional
    tests. We will learn how to use this great library for integration and E2E testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the highlights of Godog:'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the libraries we have used so far, Godog does not run its tests using
    the `go test` command, but with the `godog run` command. This command serves the
    dual purpose of generating test files as well as running the test that has been
    implemented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests are organized in **feature files**, which describe the expected behavior
    of a particular piece of functionality in a particular scenario. Godog uses a
    domain-specific language called **Gherkin** ([https://cucumber.io/docs/gherkin/reference/](https://cucumber.io/docs/gherkin/reference/)).
    We will explore how to write tests in this format for the remainder of this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Godog is an open source library, maintained by the community and the Cucumber
    organization. You can freely explore the source code and even contribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Just as with the other dependencies we have used so far, Godog is installed
    by running the `go install` command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we understand the basic usage of Godog and have installed it successfully,
    we start by writing our first `BookSwap` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The feature file describes a part of the functionality required for new users
    of the `BookSwap` application:'
  prefs: []
  type: TYPE_NORMAL
- en: The feature describes the scenario of signing up as a new user of an application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a background step, the `BookSwap` application should be up and running. This
    allows us to write an E2E test as we run the entire application and run the test
    on the side.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the feature is completed, the following functionality will be available:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New customers will be able to create user profiles.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When their profile is created, the user will see their user summary and receive
    their user ID, which will allow them to further interact with the application.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Once signed up, customers will be able to view their profile by using their
    user ID.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Any further interactions with the application are outside the scope of this
    feature.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As discussed, the feature file is based on the expected user journeys and request
    flows of the application. Feature files should be easy to read and understand,
    so we should create separate files for covering other features and scenarios and
    use non-technical language.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to implement and run this feature file
    with Godog.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing tests with Godog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Godog installed and our first feature outlined, let us turn our attention
    to the implementation of this test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main steps we will be taking for implementing our outlined feature are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating feature and test files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing the test steps for the functionality of our `BookSwap` application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running the application as well as the test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we previously mentioned, we will use Godog to implement BDD-style E2E tests,
    so we require the application to be up and running before we run our tests. However,
    this is not a Godog requirement, so we can write tests at any level with this
    easy-to-use library.
  prefs: []
  type: TYPE_NORMAL
- en: Creating test files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As previously mentioned, Godog relies on code generation to make developers’
    lives easier. The process consists of copying code from the terminal and creating
    files ourselves. Let us look at the steps involved.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – creating a feature file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Feature files are stored in the `/features` directory located at the root of
    the Go project. As we use project folders in our repository, we need to create
    a file under `/chapter06/features`. We will create a file in this directory and
    add the feature text inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that the file is named according to the feature name, making it easy to
    understand which functionality the file relates to.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – generating step definitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once the feature file contains our text, we can use Godog to generate the steps
    required for our feature. The `godog run` command prints the following generated
    code to the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 6**.4* presents the sequence of steps in our scenario, along with any
    HTTP requests that they make:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Steps and HTTP requests made in our scenario ](img/Figure_6.4_B18371.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Steps and HTTP requests made in our scenario
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated code contains a function for each step of our scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: The `aNewUserProfileIsCreated` function sends a request to the `GET /users/{id}`
    endpoint and verifies that the user profile is successfully created. It will also
    verify that the user profile can be successfully retrieved by using the assigned
    user ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `sentToTheUsersEndpoint` function sends a JSON payload to the `POST /users`
    endpoint and verifies that the endpoint responds with the correct user details.
    It will also get access to the user ID that the application generates for the
    new user profile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `theBookSwapAppIsUp` function sends a request to the `GET /` endpoint and
    verifies that the application responds with a `200 OK` status code. In production,
    we often expose a separate `/health` endpoint, but we will make use of the root
    endpoint for the purposes of our `BookSwap` demo application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `userDetails` function will create a `db.User` instance that we will marshal
    to the JSON payload and send to the `sentToTheUsersEndpoint` step. It will also
    serve as the expected value, or `want` variable, in our test assertions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will need to implement these functions to invoke the functionality of our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `InitializeScenario` function ties together all these functions
    into steps and orders them alphabetically. We will have to correctly order them
    according to our feature definition when we implement our test file.
  prefs: []
  type: TYPE_NORMAL
- en: While the generated code is simple, it provides a scaffold for our test code
    and takes care of the interaction required with the Godog test runner.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – creating a test file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just as with regular unit tests, Godog tests also live in the `*_test.go` files
    and live alongside the packages that they test. As we will test the entire application,
    we create a test file in the `root` directory, at the same level as the `/features`
    directory. We create a test file matching the name of the feature and paste the
    generated file inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: While the name of the test does not need to match, using a matching test will
    allow Godog to match the test with the feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the test file and code created, we execute `godog run` again. The test
    runner will mark the scenario as `pending`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Conveniently, the output prints out the line numbers for each step as well,
    showing us where we are missing the implementation required for our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing test steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that Godog has conveniently generated a scaffold for our test steps, we
    begin writing test code according to the functionality of the `BookSwap` application.
    However, as described in the previous section, we will need to pass information
    between test steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to do this in Godog is by passing information through chained contexts.
    Godog will pass the contexts between the test steps, allowing us to pass information
    between steps in a safe way. In order to do this, we will need to change the signature
    of the test steps to take in a context and return a context and an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The test steps take in a context and return a context and error. Under the
    hood, Godog will handle each of these return values correctly: chaining the returned
    context to subsequent test steps and failing the test in the case of a non-nil
    error.'
  prefs: []
  type: TYPE_NORMAL
- en: Context refresher
  prefs: []
  type: TYPE_NORMAL
- en: The `context` type is part of Go’s standard library and its purpose is to carry
    deadlines, cancellations, and request-scoped variables. Contexts should be propagated
    across functions, allowing us to tie together function calls to requests across
    the layers of our application. Creating a new context requires a parent context.
    Cancellations then propagate across the chain of children contexts.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our purposes, we will use contexts to carry request-scoped variables. We
    will create a new `contextKey` custom type that will carry all the variables that
    we need to pass between test steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, we will propagate the `BookSwap` application’s `UsersURL` and
    the wanted value of the created user. In our background step, `theBookSwapAppIsUp`,
    we see a demonstration of the usage of the context to pass information to subsequent
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This code snippet demonstrates the implementation of a step that interacts
    with a REST endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: We set the URL value for the environment that we will be testing by calling
    the `getTestURL` helper function. This function constructs the URL based on the
    environment variables specified for the application. This makes it easy for us
    to configure our test to run in different test environments, local or remote.
    If you want to run with the default values, set the `BOOKSWAP_BASE_URL` environment
    variable to `http://localhost` and the `BOOKSWAP_PORT` environment variable to
    `3000` to your terminal session.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `http.Get` method to interact with the defined URL, saving the error
    and the response. We are familiar with the `net/http` library from previous chapters.
    Its usage is no different in this test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the case of an error or a status code other than `200 OK`, we return an error.
    This will fail this step and end the test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, in the case of success, we use the `context.WithValue` function to
    create a child context from the `ctx` parameter value, passing a `contextKey`
    value with the populated `UsersURL`. In later steps, we will be able to use this
    URL for our requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One other change we need to make to the generated test steps is to reorder them
    according to the order in which they should run. This step is not intuitive if
    you have never used Godog, but will be easy to track down if forgotten as your
    test will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Running the test suite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With everything implemented, it’s time to take our test out for a spin. First,
    we remember to run the `BookSwap` application, either using `docker compose -f
    docker-compose.book-swap.chapter06.yml up --build` command. Unless you have changed
    your configuration, this will expose the application at the `http://localhost:3000`
    URL. You can easily verify that the application is running by performing a `curl`
    command against this endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If you see a welcome response, then the application is up and correctly connected
    to its database.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the application running, we execute our test using the `godog` `run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the terminal output, Godog runs one scenario and all four
    steps passed. Alternatively, you can run the tests using the `go test` command
    if you don’t want to install the Godog CLI, but that will not format the test
    results, as you see in the preceding output.
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully written and run our first E2E test for the `BookSwap` application,
    which has been extended with persistent storage. The test was written using the
    Godog open source testing library, which allowed us to write easy-to-read BDD-style
    tests. We are well on our way to becoming Go testing experts.
  prefs: []
  type: TYPE_NORMAL
- en: Using database assertions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have learned how to start up our application in a test environment, as well
    as how to write and run E2E tests for our application. This has taken us far toward
    verifying the behavior of our application, but how can we be sure that the stored
    data and database components are correct? The final aspect of E2E testing that
    will help us answer this question is database testing. Looking at the tests we
    have written so far, we notice two things:'
  prefs: []
  type: TYPE_NORMAL
- en: The database is typically initialized as empty, then the tables are torn down
    once the application shuts down. This has the advantage that we know there will
    be no persistent data that interferes with our tests, but it has the disadvantage
    of having to set up any required data as part of the test. For example, in our
    case, registering an available book requires a user ID, so we will have to create
    a user first before we do any book-related tasks. This can make our test suite
    running time longer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The items from the database are asserted through the `BookSwap` endpoints. For
    example, we check that a user was correctly stored in the database by making a
    request to `GET /users/{id}` with its corresponding user ID. However, as requests
    travel down the entire application stack, it can become difficult to pinpoint
    the source of the error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us explore these two pain points further to get a better understanding of
    how to address them.
  prefs: []
  type: TYPE_NORMAL
- en: Seed data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in the previous *Persistent storage* section, we use `golang-migrate`
    to write database migrations, which allows us to create and set up our database
    for usage before the application starts up. Then, we use the **GORM** library
    as our ORM, which allows us to easily interact with our database using custom
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step would be to insert some data into our newly created tables. This
    type of initial data is known as `INSERT` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'However, none of the tools we have explored have the capability of creating
    and adding random seeds for our application. We could add another library dependency
    for generating random data, but instead, we can make use of GORM’s `DB` type to
    insert random data into our database before our tests run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code snippet demonstrates how to insert data into the database
    alongside running our Godog test steps, as detailed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Just as at the application start, we open a new connection to our PostgreSQL
    database. Database connections should be shared between tests as much as possible,
    and you should not open them for many test iterations. However, as database start
    positions are usually required for E2E tests, it’s feasible to set up our database
    in this way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the database connection is opened successfully, we save a generated user
    using the `Save` method of the GORM database. After this, the database will contain
    the generated data and can be used across our tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test cases and assertions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to assertions on the contents of our database, we can take the
    same approach as we’ve seen with adding generated data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the verification code, we see the same approach:'
  prefs: []
  type: TYPE_NORMAL
- en: We connect to the database using the connection string. GORM will optimize the
    use of your database connection when being used by multiple goroutines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we use the database methods to query the database for the user ID that
    is supplied to the method. Note that we rely on the GORM database directly, and
    not our own methods of `UserService`, removing any possible bugs that we may have
    introduced.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While GORM is easy to use, it might feel quite verbose to write full database
    queries to assert on returned values. The `dbassert` open source library ([https://github.com/hashicorp/dbassert](https://github.com/hashicorp/dbassert))
    provides wrappers and helper functions that can make this easier for you. You
    can explore this library by yourself and see how it can help streamline your test
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we spent our efforts extending the `BookSwap` application.
    We began by discussing what a typical user journey for a user will be, added a
    PostgreSQL database to it, and configured it to run with Docker. Then, we explored
    the Godog testing library, which makes it easy to write BDD-style tests, as well
    as E2E tests. We made use of Godog to verify that users are able to sign up on
    the `BookSwap` application, making use of the code generation abilities of Godog.
    Finally, we briefly discussed the challenges of creating database start positions
    and assertions directly at the database level.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B18371_07.xhtml#_idTextAnchor162), *Refactoring in Go*, we
    will discuss tools and techniques for code refactoring and how to break up monoliths
    into multiple services. This will give us a realistic understanding of how to
    rely on our tests to verify that refactoring does not cause errors or break existing
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the purpose of a user journey?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is ORM?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the advantage of using Docker Compose?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is database seeding?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*User Story Mapping: Discover the Whole Story, Build the Right Product*, *Jeff
    Patton*, *Peter Economy*. Published by *O’Reilly*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Book Of Kubernetes: A Hands-on Deep Dive into Container Technology*, *Alan
    Hohn*. Published by *No* *Starch Press*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*SQL & NoSQL Databases: Models, Languages, Consistency Options and Architectures
    for Big Data Management*, *Andreas Meier*, *Michael Kaufmann*. Published by *Springer
    Vieweg*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
