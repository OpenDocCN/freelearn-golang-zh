<html><head></head><body>
<div id="_idContainer066">
<h1 class="chapter-number" id="_idParaDest-141"><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-142"><a id="_idTextAnchor163"/><span class="koboSpan" id="kobo.2.1">Refactoring in Go</span></h1>
<p><span class="koboSpan" id="kobo.3.1">We have explored concepts and techniques for tests across the entire testing pyramid. </span><span class="koboSpan" id="kobo.3.2">We have applied these concepts while building our main project of study, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4.1">BookSwap</span></strong><span class="koboSpan" id="kobo.5.1"> application. </span><span class="koboSpan" id="kobo.5.2">This web application is currently verified by </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Unit tests implemented using the Go </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">standard library</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Integration tests implemented </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.11.1">httptest</span></strong></span></li>
<li><span class="koboSpan" id="kobo.12.1">End-to-end tests implemented </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.14.1">godog</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.15.1">To demonstrate these techniques in a realistic example, we have extended the functionality of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.16.1">BookSwap</span></strong><span class="koboSpan" id="kobo.17.1"> application with a variety of components. </span><span class="koboSpan" id="kobo.17.2">In </span><a href="B18371_06.xhtml#_idTextAnchor142"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.18.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.19.1">, </span><em class="italic"><span class="koboSpan" id="kobo.20.1">End-To-End Testing the BookSwap Web Application</span></em><span class="koboSpan" id="kobo.21.1">, we extended the project by adding the ability to run it in Docker and use a PostgreSQL database to save </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">its data.</span></span></p>
<p><span class="koboSpan" id="kobo.23.1">All of these changes have added complexity to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.24.1">BookSwap</span></strong><span class="koboSpan" id="kobo.25.1"> application, which now relies on </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.27.1">Two libraries for database migration and operations – </span><strong class="source-inline"><span class="koboSpan" id="kobo.28.1">golang-migrate</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.29.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.30.1">gorm</span></strong></span></li>
<li><span class="koboSpan" id="kobo.31.1">Three different types of files – source files, implementation files, and </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">Docker files</span></span></li>
<li><span class="koboSpan" id="kobo.33.1">A complex code structure with multiple layers – </span><strong class="source-inline"><span class="koboSpan" id="kobo.34.1">db</span></strong><span class="koboSpan" id="kobo.35.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">handlers</span></strong><span class="koboSpan" id="kobo.37.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.39.1">cmd</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.40.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">BookSwap</span></strong><span class="koboSpan" id="kobo.42.1"> application started as a simple REST API with a small scope of functionality. </span><span class="koboSpan" id="kobo.42.2">However, as we kept refining it and adding more code, it became more difficult to install and start up. </span><span class="koboSpan" id="kobo.42.3">This is part of the natural life cycle of software projects. </span><span class="koboSpan" id="kobo.42.4">As an engineer, you </span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.43.1">will more often have to modify and extend existing code, performing </span><strong class="bold"><span class="koboSpan" id="kobo.44.1">brownfield development</span></strong><span class="koboSpan" id="kobo.45.1">, than start and implement brand-new </span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.46.1">projects with no existing dependencies, also known as </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.47.1">greenfield development</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">This chapter is </span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.50.1">dedicated to </span><strong class="bold"><span class="koboSpan" id="kobo.51.1">code refactoring</span></strong><span class="koboSpan" id="kobo.52.1">, which is modifying and restructuring existing code. </span><span class="koboSpan" id="kobo.52.2">Based on our experiences of implementing and testing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">BookSwap</span></strong><span class="koboSpan" id="kobo.54.1"> application, we will learn about good practices for code refactoring. </span><span class="koboSpan" id="kobo.54.2">Then, we will learn how to validate the behavior of the restructured code, which should perform and behave identically to its legacy equivalent. </span><span class="koboSpan" id="kobo.54.3">Finally, we will discuss best practices for splitting up monolithic applications </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">into microservices.</span></span></p>
<p><span class="koboSpan" id="kobo.56.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.58.1">What code refactoring is and why it is an essential part of the </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">development process</span></span></li>
<li><span class="koboSpan" id="kobo.60.1">How to effectively change implementation and </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">test code</span></span></li>
<li><span class="koboSpan" id="kobo.62.1">Error verification </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">in Go</span></span></li>
<li><span class="koboSpan" id="kobo.64.1">How to validate refactoring </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">success criteria</span></span></li>
<li><span class="koboSpan" id="kobo.66.1">Good practices for splitting up </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">monolithic applications</span></span></li>
</ul>
<h1 id="_idParaDest-143"><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.68.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.69.1">You will need to have </span><strong class="bold"><span class="koboSpan" id="kobo.70.1">Go version 1.19</span></strong><span class="koboSpan" id="kobo.71.1"> or later installed to run the code samples in this chapter. </span><span class="koboSpan" id="kobo.71.2">The installation process is described on the official Go documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">at </span></span><a href="https://go.dev/doc/install"><span class="No-Break"><span class="koboSpan" id="kobo.73.1">https://go.dev/doc/install</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.74.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">The code examples included in this book are publicly available </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">at </span></span><a href="https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter07"><span class="No-Break"><span class="koboSpan" id="kobo.77.1">https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter07</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.78.1">.</span></span></p>
<h1 id="_idParaDest-144"><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.79.1">Understanding changing dependencies</span></h1>
<p><span class="koboSpan" id="kobo.80.1">In </span><a href="B18371_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.81.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.82.1">, </span><em class="italic"><span class="koboSpan" id="kobo.83.1">Getting to Grips with Test-Driven Development</span></em><span class="koboSpan" id="kobo.84.1">, we discussed refactoring the code we are writing as part of the </span><strong class="bold"><span class="koboSpan" id="kobo.85.1">Red-Green-Refactor</span></strong><span class="koboSpan" id="kobo.86.1"> TDD technique. </span><span class="koboSpan" id="kobo.86.2">This </span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.87.1">involved limiting the cleaning up of code as we write it. </span><span class="koboSpan" id="kobo.87.2">However, as we continue our journey with TDD, it is essential that we consider how our code will evolve through time and consider larger-scale code refactoring </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">or rewrites.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.89.1">Code refactoring</span></strong><span class="koboSpan" id="kobo.90.1"> is often used interchangeably with </span><strong class="bold"><span class="koboSpan" id="kobo.91.1">code redesigning</span></strong><span class="koboSpan" id="kobo.92.1">, but they represent different </span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.93.1">levels of code modification. </span><span class="koboSpan" id="kobo.93.2">Code redesigning involves </span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.94.1">changing the functionality of a code base/service, while code refactoring involves changing the way the service delivers its existing functionality. </span><span class="koboSpan" id="kobo.94.2">In fact, if done correctly, code refactoring will be invisible to any internal and external users of the </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">service functionality.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.96.1">The purpose of code refactoring</span></p>
<p class="callout"><span class="koboSpan" id="kobo.97.1">Developers refactor </span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.98.1">their code to make it more efficient, maintainable, and extendable. </span><span class="koboSpan" id="kobo.98.2">There are many benefits to code refactoring: better readability, improved </span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.99.1">performance, and enabling developers to change the code more efficiently. </span><span class="koboSpan" id="kobo.99.2">Together, these are known as </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.100.1">non-functional requirements</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.102.1">A project’s testing strategy is an essential aid for verifying and supporting efficient code changes and will help developers avoid </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.104.1">Functionality regressions</span></strong><span class="koboSpan" id="kobo.105.1">: The refactored code should not break any existing functionality, causing a regression. </span><span class="koboSpan" id="kobo.105.2">Integration tests will identify components that </span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.106.1">might no longer work together correctly, while end-to-end tests will pinpoint which breakages affect </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">user-facing functionality.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.108.1">Performance degradation</span></strong><span class="koboSpan" id="kobo.109.1">: The refactored code should not perform any slower than the existing functionality. </span><span class="koboSpan" id="kobo.109.2">Integration tests will identify which components have slowed down for a particular scenario or operation, signaling to developers which components should be investigated further. </span><span class="koboSpan" id="kobo.109.3">End-to-end tests will identify which performance issues are affecting users but might make it more difficult to isolate the problem, as they don’t provide the granularity of system components. </span><span class="koboSpan" id="kobo.109.4">However, they will give an important indication of the severity of a particular performance issue, allowing developers to correctly prioritize issues. </span><span class="koboSpan" id="kobo.109.5">We will cover performance testing in more detail in </span><a href="B18371_08.xhtml#_idTextAnchor179"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.110.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.111.1">, </span><em class="italic"><span class="koboSpan" id="kobo.112.1">Testing </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.113.1">Microservice Architectures</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.115.1">Changes outside the intended scope</span></strong><span class="koboSpan" id="kobo.116.1">: The refactored code should not affect components outside the intended scope of the changes. </span><span class="koboSpan" id="kobo.116.2">This indication is particularly important for legacy code bases, where developers might not have a clear picture of the dependency graph of the different components. </span><span class="koboSpan" id="kobo.116.3">Unit tests will pinpoint which packages within the current codebase/service might be affected by the refactor, while integration tests will highlight whether the APIs between different services might </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">be broken.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.118.1">The potential costs of these issues come in </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">multiple forms:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.120.1">Losing business/transaction volume during a </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">potential outage</span></span></li>
<li><span class="koboSpan" id="kobo.122.1">Increased infrastructure/cloud costs in the case of </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">slower performance</span></span></li>
<li><span class="koboSpan" id="kobo.124.1">Increased </span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.125.1">development costs if developers take a longer time to deliver a </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">code change</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.127.1">Therefore, it is essential that code refactoring is easy to take on </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">and verify.</span></span></p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.129.1">Code refactoring steps and techniques</span></h2>
<p><span class="koboSpan" id="kobo.130.1">Now that we understand </span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.131.1">the fundamental need for code refactoring, let us </span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.132.1">explore some code refactoring techniques. </span><span class="koboSpan" id="kobo.132.2">These are not limited to Go development itself, but it is important to understand the process by which we change the code so that we can then understand how to effectively validate its output. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.133.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.134.1">.1</span></em><span class="koboSpan" id="kobo.135.1"> depicts the basic working process of </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">code refactoring:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer059">
<span class="koboSpan" id="kobo.137.1"><img alt="Figure 7.1 – The working process of code refactoring " src="image/Figure_7.01_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.138.1">Figure 7.1 – The working process of code refactoring</span></p>
<p><span class="koboSpan" id="kobo.139.1">The code refactoring steps rely on tests </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">for verification:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.141.1">The developer identifies the change that they want to make to the </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">existing implementation.</span></span></li>
<li><span class="koboSpan" id="kobo.143.1">Then, they make the required change, ensuring that the code continues to compile. </span><span class="koboSpan" id="kobo.143.2">This might require making changes to both the implementation and </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">testing code.</span></span></li>
<li><span class="koboSpan" id="kobo.145.1">Once their first </span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.146.1">change is done, the developer runs the test suite to verify their implementation </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">changes.</span></span></li>
<li><span class="koboSpan" id="kobo.148.1">If the tests are passing, then this refactor is successful and the developer has successfully implemented this change. </span><span class="koboSpan" id="kobo.148.2">They can proceed to commit it and </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">release it.</span></span></li>
<li><span class="koboSpan" id="kobo.150.1">If the tests are failing, then this refactor is not successful and the developer must revise their refactored change. </span><span class="koboSpan" id="kobo.150.2">This might mean making further changes to either the implementation or test code or simply adjusting their new </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">code changes.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.152.1">The working process is closely related to the red-green-refactor process that we have seen in earlier chapters. </span><span class="koboSpan" id="kobo.152.2">The developer should not share any changes that they make without the test suite successfully passing. </span><span class="koboSpan" id="kobo.152.3">This is most often enforced by commit checks and test run verifications as part of the </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">build/release pipeline.</span></span></p>
<p><span class="koboSpan" id="kobo.154.1">As depicted in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.155.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.156.1">.2</span></em><span class="koboSpan" id="kobo.157.1">, code refactoring should consist of a series of minor code changes or modifications, ensuring that the refactored code retains the same </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">major functionality:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer060">
<span class="koboSpan" id="kobo.159.1"><img alt="Figure 7.2 – Refactoring as a series of minor changes " src="image/Figure_7.02_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.160.1">Figure 7.2 – Refactoring as a series of minor changes</span></p>
<p><span class="koboSpan" id="kobo.161.1">As with many aspects of the code development process, releasing small, isolated changes is better than large code releases. </span><span class="koboSpan" id="kobo.161.2">This allows developers to verify each code change and release it in turn. </span><span class="koboSpan" id="kobo.161.3">Furthermore, in the case of issues, reverting a small code change will be easier than reverting larger code changes that have been committed over </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">multiple days.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.163.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.164.1">.3</span></em><span class="koboSpan" id="kobo.165.1"> depicts an </span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.166.1">overview of five popular code </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">refactoring techniques:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer061">
<span class="koboSpan" id="kobo.168.1"><img alt="Figure 7.3 – Five popular code refactoring techniques " src="image/Figure_7.03_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.169.1">Figure 7.3 – Five popular code refactoring techniques</span></p>
<p><span class="koboSpan" id="kobo.170.1">The five techniques can be used together to improve code complexity </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">and duplication:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.172.1">Red-green-refactor</span></strong><span class="koboSpan" id="kobo.173.1"> is the technique we are already familiar with. </span><span class="koboSpan" id="kobo.173.2">The implementation is written </span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.174.1">alongside its corresponding tests, starting with a failing test, making it pass, and then refactoring the written code as required. </span><span class="koboSpan" id="kobo.174.2">This approach ensures that all functionality is covered by tests and that the refactoring is undertaken as part of the initial implementation. </span><span class="koboSpan" id="kobo.174.3">As tests are written alongside the code, this technique will most likely require test changes as part of the code </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">refactoring process.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.176.1">Extract</span></strong><span class="koboSpan" id="kobo.177.1"> is the technique that involves extracting an existing code fragment from a potentially </span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.178.1">large function into its own function. </span><span class="koboSpan" id="kobo.178.2">This function name should describe the functionality that the extracted fragment implements, improving the readability of the previous large function containing multiple pieces of functionality. </span><span class="koboSpan" id="kobo.178.3">As code is only extracted, not rewritten, test changes will not likely </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">be required.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.180.1">Simplify</span></strong><span class="koboSpan" id="kobo.181.1"> is the </span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.182.1">technique that improves the complexity of large functions. </span><span class="koboSpan" id="kobo.182.2">This can be done by refactoring conditional expressions or adjusting method calls by refactoring function parameters or adjusting interface signatures. </span><span class="koboSpan" id="kobo.182.3">As this technique involves changing function signatures, test changes will most likely </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">be required.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.184.1">Inline</span></strong><span class="koboSpan" id="kobo.185.1"> is the opposite technique to </span><strong class="bold"><span class="koboSpan" id="kobo.186.1">Extract</span></strong><span class="koboSpan" id="kobo.187.1">. </span><span class="koboSpan" id="kobo.187.2">It involves removing redundant functions by taking </span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.188.1">their contents and putting them in place of the existing function call. </span><span class="koboSpan" id="kobo.188.2">This reduces the indirection of the code, reducing the cognitive burden of the developer reading the code. </span><span class="koboSpan" id="kobo.188.3">Unless the method being tested is removed, this technique will not likely require </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">test changes.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.190.1">Abstraction</span></strong><span class="koboSpan" id="kobo.191.1"> is the technique </span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.192.1">most likely suited for larger-scope code refactoring. </span><span class="koboSpan" id="kobo.192.2">This technique involves introducing new levels of abstraction, such as interfaces, to remove repetition and allow the reuse of behaviors across multiple packages. </span><span class="koboSpan" id="kobo.192.3">Since new interfaces will require the use of mocks and larger scope refactoring, this technique will most likely require </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">test changes.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.194.1">These popular techniques will help you refactor your code and ensure that it continues to adhere to the SOLID principles we have previously discussed in </span><a href="B18371_03.xhtml#_idTextAnchor061"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.195.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.196.1">, </span><em class="italic"><span class="koboSpan" id="kobo.197.1">Mocking and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.198.1">Assertion Frameworks</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">.</span></span></p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.200.1">Technical debt</span></h2>
<p><span class="koboSpan" id="kobo.201.1">Code refactoring is an </span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.202.1">extremely important and unavoidable part of the development life cycle. </span><span class="koboSpan" id="kobo.202.2">When code is not routinely refactored and maintained, it begins to accumulate </span><strong class="bold"><span class="koboSpan" id="kobo.203.1">technical debt</span></strong><span class="koboSpan" id="kobo.204.1">. </span><span class="koboSpan" id="kobo.204.2">The subject of how to effectively manage technical debt has been discussed often in the engineering community, as it is easy for engineering managers to prioritize delivering new features, which have a tangible monetary value, as opposed to addressing technical debt, which does not have immediate consequences or cost associated </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">with it.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.206.1">Technical debt in Agile</span></p>
<p class="callout"><span class="koboSpan" id="kobo.207.1">In Agile, technical debt is the term used to refer to the consequences of prioritizing speed over quality. </span><span class="koboSpan" id="kobo.207.2">While the </span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.208.1">code is tested for correct functionality, its internal structure might be the result of poor architectural choices that have been made </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">for speed.</span></span></p>
<p><span class="koboSpan" id="kobo.210.1">The consequences of technical debt can affect your project in a variety </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">of ways:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.212.1">Bugs</span></strong><span class="koboSpan" id="kobo.213.1">: As code </span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.214.1">accumulates technical debt, duplicated code and high cohesion can lead to bugs that are difficult to fix and detect. </span><span class="koboSpan" id="kobo.214.2">These can have financial consequences in the case that they cause outages or affect </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">user operations.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.216.1">Decreased productivity</span></strong><span class="koboSpan" id="kobo.217.1">: As technical debt does not follow SOLID principles and does not resemble the rest of the code base, it can be difficult for developers to change it with new features. </span><span class="koboSpan" id="kobo.217.2">Furthermore, technical debt is also typically not well documented, so it can be difficult to reason around </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">expected behavior.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.219.1">Limits new features</span></strong><span class="koboSpan" id="kobo.220.1">: As it accumulates, developers can spend their entire time fixing bugs and </span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.221.1">performance issues with technical debt, meaning that they do not have time to deliver new features. </span><span class="koboSpan" id="kobo.221.2">This “putting out fires” and chaotic way of working frustrates engineers and can even lead to higher </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">staff attrition.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.223.1">Technical debt is often compared to financial debt. </span><span class="koboSpan" id="kobo.223.2">If we don’t take care of the issues in our code for a prolonged period of time and continue extending code that has been poorly designed, the </span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.224.1">debt becomes larger and more difficult to handle, similar to how financial debt accumulates interest. </span><span class="koboSpan" id="kobo.224.2">To avoid these consequences, technical debt should be handled alongside other work in the Agile way </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">of working.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.226.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.227.1">.4</span></em><span class="koboSpan" id="kobo.228.1"> depicts how Agile teams typically structure their work to address technical debt with a prioritized </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">work </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.230.1">backlog</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer062">
<span class="koboSpan" id="kobo.232.1"><img alt="Figure 7.4 – Sprint planning with technical debt " src="image/Figure_7.04_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.233.1">Figure 7.4 – Sprint planning with technical debt</span></p>
<p><span class="koboSpan" id="kobo.234.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.235.1">sprint backlog</span></strong><span class="koboSpan" id="kobo.236.1"> is a combination of feature work and </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">technical debt:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.238.1">The development </span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.239.1">team and product team each maintain their own backlogs. </span><span class="koboSpan" id="kobo.239.2">Typically, these are represented by Jira tickets or GitHub issues with details of the work to be done. </span><span class="koboSpan" id="kobo.239.3">The technical debt work will typically involve refactoring existing code, while the feature work will consist of adding new functionality. </span><span class="koboSpan" id="kobo.239.4">The sprint backlog attempts to find a balance between these two types </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">of work.</span></span></li>
<li><span class="koboSpan" id="kobo.241.1">During sprint planning, representative stakeholders prioritize the work. </span><span class="koboSpan" id="kobo.241.2">It is considered good practice to involve the development team during planning to ensure that the entire team has a good understanding of the goals of the upcoming sprint. </span><span class="koboSpan" id="kobo.241.3">The engineering team consists of experts who can scope what refactoring work should be taken on. </span><span class="koboSpan" id="kobo.241.4">They often have an understanding of which parts of the system </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">require attention.</span></span></li>
<li><span class="koboSpan" id="kobo.243.1">The outcome of the sprint planning meeting is a prioritized list of work that makes up the sprint backlog. </span><span class="koboSpan" id="kobo.243.2">Based on their expertise, the technical team typically provides time estimates for the work to be done. </span><span class="koboSpan" id="kobo.243.3">These estimates are then used to determine what work can be undertaken to match the capacity of the team. </span><span class="koboSpan" id="kobo.243.4">Refactoring </span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.244.1">and feature work are treated as equal, with time being given to each piece of work based on </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">provided estimates.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.246.1">While technical debt seems like it does not have any immediate cost, it’s important that teams are allowed to take time to refactor and maintain </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">their code.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.248.1">Planning for technical debt</span></p>
<p class="callout"><span class="koboSpan" id="kobo.249.1">A “little and often” approach works best, where technical debt is planned alongside feature work, as </span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.250.1">opposed to a “Big Bang” approach, where a whole sprint is dedicated to fixing issues and doing extensive </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">code refactors.</span></span></p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.252.1">Changing dependencies</span></h2>
<p><span class="koboSpan" id="kobo.253.1">Now that we have a good understanding of how to plan and undertake code refactoring, it is time to turn </span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.254.1">our attention to a special case of code refactoring, which is changing dependencies. </span><span class="koboSpan" id="kobo.254.2">As discussed in </span><a href="B18371_03.xhtml#_idTextAnchor061"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.255.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.256.1">, </span><em class="italic"><span class="koboSpan" id="kobo.257.1">Mocking and Assertion Frameworks</span></em><span class="koboSpan" id="kobo.258.1">, dependencies are typically wrapped in our own interfaces. </span><span class="koboSpan" id="kobo.258.2">Go’s powerful interface also helps us refactor our code when </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">dependencies change.</span></span></p>
<p><span class="koboSpan" id="kobo.260.1">Interfaces make our code easier to refactor, as well as less coupled, by providing </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.262.1">Clear expected behavior</span></strong><span class="koboSpan" id="kobo.263.1">: Interfaces are defined on the calling side, establishing what the expected behavior of the external dependency will be inside the package. </span><span class="koboSpan" id="kobo.263.2">Developers have a clear way to indicate what functionality and method signatures they expect the external dependency </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">to provide.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.265.1">Compiler-enforced method signatures</span></strong><span class="koboSpan" id="kobo.266.1">: Once the expected behavior is defined, the compiler will verify that any struct that is passed as the interface will satisfy these signatures. </span><span class="koboSpan" id="kobo.266.2">Therefore, the code can never get into a state where a certain method is not defined, and cause runtime errors </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">once called.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.268.1">Separation between packages</span></strong><span class="koboSpan" id="kobo.269.1">: As the interface lives inside the calling package, it provides a barrier between the package and the external dependency. </span><span class="koboSpan" id="kobo.269.2">The dependency can then be refactored or have new functionality implemented without the need to handle these changes in the </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">calling packages.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.271.1">Implementation opacity</span></strong><span class="koboSpan" id="kobo.272.1">: The calling package does not have any knowledge of the external dependency. </span><span class="koboSpan" id="kobo.272.2">This makes it easy for us to replace one concrete implementation with </span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.273.1">another, which makes changing dependencies during refactoring easy. </span><span class="koboSpan" id="kobo.273.2">We have already seen an example of this in </span><a href="B18371_03.xhtml#_idTextAnchor061"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.274.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.275.1">, </span><em class="italic"><span class="koboSpan" id="kobo.276.1">Mocking and Assertion Frameworks</span></em><span class="koboSpan" id="kobo.277.1">, where we saw how to provide mocks for dependencies of the UUT, allowing us to test its behavior in isolation from all its other </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">concrete dependencies.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.279.1">A good example to analyze this is </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">PostingService</span></strong><span class="koboSpan" id="kobo.281.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">BookSwap</span></strong><span class="koboSpan" id="kobo.283.1"> application. </span><span class="koboSpan" id="kobo.283.2">The purpose of the service is to take on the order and provide all the book </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">shipping functionality:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.285.1">
// PostingService interface wraps around external posting
// functionality.
</span><span class="koboSpan" id="kobo.285.2">type </span><strong class="bold"><span class="koboSpan" id="kobo.286.1">PostingService interface</span></strong><span class="koboSpan" id="kobo.287.1"> {
  NewOrder(b Book) error
}</span></pre>
<p><span class="koboSpan" id="kobo.288.1">As expected, we have defined </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">PostingService</span></strong><span class="koboSpan" id="kobo.290.1"> as an interface that we have defined inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">BookSwap</span></strong><span class="koboSpan" id="kobo.292.1"> application. </span><span class="koboSpan" id="kobo.292.2">This service has not been implemented, as we have considered the implementation of this service as fully external. </span><span class="koboSpan" id="kobo.292.3">Please note that this is a purely fictional service that we have used to demonstrate the process of providing and consuming </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">external dependencies.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">BookService</span></strong><span class="koboSpan" id="kobo.295.1"> takes </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">PostingService</span></strong><span class="koboSpan" id="kobo.297.1"> using this defined interface as </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">a dependency:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.299.1">
// NewBookService initialises a BookService given its
// dependencies.
</span><span class="koboSpan" id="kobo.299.2">func NewBookService(db *gorm.DB, </span><strong class="bold"><span class="koboSpan" id="kobo.300.1">ps PostingService</span></strong><span class="koboSpan" id="kobo.301.1">) *BookService {
  return &amp;BookService{
    DB: db,
</span><strong class="bold"><span class="koboSpan" id="kobo.302.1">    ps: ps,</span></strong><span class="koboSpan" id="kobo.303.1">
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.304.1">We can provide any implementation of this function as long as it provides the method defined by the interface. </span><span class="koboSpan" id="kobo.304.2">This makes it easy for us to provide any implementation of this service to the </span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.305.1">method, without making any further code changes inside this package, which means we can keep the scope of the refactoring small to the </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">implementing package.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.307.1">Nil values as dependencies</span></p>
<p class="callout"><span class="koboSpan" id="kobo.308.1">The zero value of an interface is nil, so it will satisfy the method signature when passed in as well. </span><span class="koboSpan" id="kobo.308.2">While a nil value dependency can cause errors if a function is called on it, using nil for dependencies we are not interested in is particularly useful when </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">writing tests.</span></span></p>
<p><span class="koboSpan" id="kobo.310.1">While implementation is easy to swap when the signature of the dependency stays as expected, changing the interface method signature is not so easy and will require us to make changes to the calling packages, which have defined their own </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">wrapping interfaces.</span></span></p>
<p><span class="koboSpan" id="kobo.312.1">When changing the signature of an interface, you will typically need to make the </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">following changes:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.314.1">Make the changes to the implementation of the interface, if it is part of </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">your project.</span></span></li>
<li><span class="koboSpan" id="kobo.316.1">Update the test code to ensure that the refactored changes are working correctly. </span><span class="koboSpan" id="kobo.316.2">This will ensure that you have not introduced any bugs or </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">caused regressions.</span></span></li>
<li><span class="koboSpan" id="kobo.318.1">Based on the compiler errors, you can easily identify which packages use the implementation type as a dependency, as they will no longer satisfy these old method signatures. </span><span class="koboSpan" id="kobo.318.2">Then, you can make the corresponding changes to any interfaces that wrap around </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">the implementation.</span></span></li>
<li><span class="koboSpan" id="kobo.320.1">If you are using a mock generation tool, you can regenerate your mocks according to the newly updated </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">interface definitions.</span></span></li>
<li><span class="koboSpan" id="kobo.322.1">As identified by compilation errors, you can make any changes to the test code. </span><span class="koboSpan" id="kobo.322.2">These changes might be required after regenerating the mocks or to test the new behavior of </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">the refactoring.</span></span></li>
</ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.324.1">The compiler is your guide</span></p>
<p class="callout"><span class="koboSpan" id="kobo.325.1">The enforcement of interface signatures will help you identify which packages must be modified and ensure that the code does not end up in an unstable state. </span><span class="koboSpan" id="kobo.325.2">The compiler will highlight any code that needs to be modified and guide you in your </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">refactoring efforts.</span></span></p>
<p><span class="koboSpan" id="kobo.327.1">As changing interfaces </span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.328.1">requires a lot of rework, developers will try to avoid making these changes. </span><span class="koboSpan" id="kobo.328.2">However, taking the time to design your code according to good architectural principles should help you avoid needing to make such sweeping code </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">changes often.</span></span></p>
<h1 id="_idParaDest-148"><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.330.1">Relying on your tests</span></h1>
<p><span class="koboSpan" id="kobo.331.1">We now have a good understanding of how to refactor our code and have learned how to take advantage of some of Go’s best features: the compiler and interfaces. </span><span class="koboSpan" id="kobo.331.2">This should make your refactoring much easier and help you fit it into your sprint planning. </span><span class="koboSpan" id="kobo.331.3">In this section, we will have a look at a couple of examples of code refactors in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">BookSwap</span></strong><span class="koboSpan" id="kobo.333.1"> application that will allow us to use all the techniques we have explored in </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">this chapter.</span></span></p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.335.1">Automated refactoring</span></h2>
<p><span class="koboSpan" id="kobo.336.1">One of the biggest strengths </span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.337.1">of Go is its tooling, and IDE support is no exception </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">to this:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.339.1">The Google Go team maintains an extension for Go development in Visual Studio </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">Code (</span></span><a href="https://code.visualstudio.com/docs/languages/go"><span class="No-Break"><span class="koboSpan" id="kobo.341.1">https://code.visualstudio.com/docs/languages/go</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.342.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.343.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">vim-go</span></strong><span class="koboSpan" id="kobo.345.1"> plugin (</span><a href="https://github.com/fatih/vim-go"><span class="koboSpan" id="kobo.346.1">https://github.com/fatih/vim-go</span></a><span class="koboSpan" id="kobo.347.1">) is a popular open source plugin maintained </span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.348.1">by the </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">Go community</span></span></li>
<li><span class="koboSpan" id="kobo.350.1">The team at JetBrains has created GoLand (</span><a href="https://www.jetbrains.com/go/"><span class="koboSpan" id="kobo.351.1">https://www.jetbrains.com/go/</span></a><span class="koboSpan" id="kobo.352.1">), which is a dedicated product for </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">Go development</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.354.1">All of these IDEs provide us with support for looking up references and usages of a given type and for renaming symbols across the entire call stack. </span><span class="koboSpan" id="kobo.354.2">This can take a lot of the boring grunt work of simple refactoring, but you will still have to make quite a few </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">changes yourself.</span></span></p>
<p><span class="koboSpan" id="kobo.356.1">Let’s consider the refactoring involved in renaming </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">BookService</span></strong><span class="koboSpan" id="kobo.358.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">BookRepository</span></strong><span class="koboSpan" id="kobo.360.1">. </span><span class="koboSpan" id="kobo.360.2">We might want to change this name, as we added functionality related to the database of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">BookSwap</span></strong><span class="koboSpan" id="kobo.362.1"> application in </span><a href="B18371_06.xhtml#_idTextAnchor142"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.363.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.364.1">, </span><em class="italic"><span class="koboSpan" id="kobo.365.1">End-to-End Testing the BookSwap </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.366.1">Web Application</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.368.1">First, we will rename the struct with our IDE’s rename </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">symbol functionality:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.370.1">
// </span><strong class="bold"><span class="koboSpan" id="kobo.371.1">BookRepository</span></strong><span class="koboSpan" id="kobo.372.1"> contains all the functionality and
// dependencies for managing books.
</span><strong class="bold"><span class="koboSpan" id="kobo.373.1">type BookRepository struct</span></strong><span class="koboSpan" id="kobo.374.1"> {
  DB *gorm.DB
  ps PostingService
}</span></pre>
<p><span class="koboSpan" id="kobo.375.1">This will update all the direct references to the old </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">BookService</span></strong><span class="koboSpan" id="kobo.377.1"> in all implementation and test code across the entire application. </span><span class="koboSpan" id="kobo.377.2">This saves us from fixing a lot of compilation </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">errors manually.</span></span></p>
<p><span class="koboSpan" id="kobo.379.1">Next, we need to </span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.380.1">ensure all methods relating to this struct are correctly named. </span><span class="koboSpan" id="kobo.380.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">NewBookService</span></strong><span class="koboSpan" id="kobo.382.1"> initialization function will need to be renamed </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">as well:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.384.1">
// NewBookRepository initialises a BookService given its
// dependencies.
</span><span class="koboSpan" id="kobo.384.2">func </span><strong class="bold"><span class="koboSpan" id="kobo.385.1">NewBookRepository</span></strong><span class="koboSpan" id="kobo.386.1">(db *gorm.DB, ps PostingService) *</span><strong class="bold"><span class="koboSpan" id="kobo.387.1">BookRepository</span></strong><span class="koboSpan" id="kobo.388.1"> {
  return &amp;</span><strong class="bold"><span class="koboSpan" id="kobo.389.1">BookRepository</span></strong><span class="koboSpan" id="kobo.390.1">{
    DB: db,
    ps: ps,
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.391.1">The renamed function makes it clear that it is responsible for creating </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">BookRepository</span></strong><span class="koboSpan" id="kobo.393.1"> given </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">its dependencies.</span></span></p>
<p><span class="koboSpan" id="kobo.395.1">We will need to review any test code for test signatures that relate to the old name as well. </span><span class="koboSpan" id="kobo.395.2">As we want to name tests after the functionality they verify and not the types they verify, we will not need to change any test names for </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">this rename.</span></span></p>
<p><span class="koboSpan" id="kobo.397.1">Finally, the filenames that contain and test these definitions will need to be changed </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">to match:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.399.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">book_service.go</span></strong><span class="koboSpan" id="kobo.401.1"> file becomes </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">book_repository.go</span></strong><span class="koboSpan" id="kobo.403.1">, making the naming of the file and the code it </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">contains consistent</span></span></li>
<li><span class="koboSpan" id="kobo.405.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">book_service_test.go</span></strong><span class="koboSpan" id="kobo.407.1"> file becomes </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">book_repository_test.go</span></strong><span class="koboSpan" id="kobo.409.1">, ensuring that the test code and implementation stay </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">grouped together</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.411.1">That’s all the work we need to do for renaming a service in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">BookSwap</span></strong><span class="koboSpan" id="kobo.413.1"> application. </span><span class="koboSpan" id="kobo.413.2">This simple code refactor </span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.414.1">did not require any test changes, but it did demonstrate the process that you will have to undertake in refactoring Go code and how you can rely on your IDE to take care of some of the more </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">laborious parts.</span></span></p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.416.1">Validating refactored code</span></h2>
<p><span class="koboSpan" id="kobo.417.1">While renaming </span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.418.1">symbols is straightforward, a far more common change that you will find yourself having to make will be to change a method’s signature. </span><span class="koboSpan" id="kobo.418.2">Let us see refactoring for a method signature change of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">Get</span></strong><span class="koboSpan" id="kobo.420.1"> method of </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">BookRepository</span></strong><span class="koboSpan" id="kobo.422.1">, which currently has </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">this signature:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.424.1">
// Get returns a given book or error if none exists.
</span><span class="koboSpan" id="kobo.424.2">func (bs *BookRepository) </span><strong class="bold"><span class="koboSpan" id="kobo.425.1">Get(id string)</span></strong><span class="koboSpan" id="kobo.426.1"> (*Book, error)</span></pre>
<p><span class="koboSpan" id="kobo.427.1">This method takes in an ID, fetches </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">Book</span></strong><span class="koboSpan" id="kobo.429.1"> from the database, or returns an error in the case that the book is not found. </span><span class="koboSpan" id="kobo.429.2">This is a common signature for </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">this functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.431.1">We will change this method to take in </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">*Book</span></strong><span class="koboSpan" id="kobo.433.1"> and return only an error. </span><span class="koboSpan" id="kobo.433.2">This will mean that the book fetched from the database will be populated on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">book</span></strong><span class="koboSpan" id="kobo.435.1"> parameter and return an error if is not found. </span><span class="koboSpan" id="kobo.435.2">The new signature of this method will be </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.437.1">
// Get populates a given book or returns error if none
// exists.
</span><span class="koboSpan" id="kobo.437.2">func (bs *BookRepository) </span><strong class="bold"><span class="koboSpan" id="kobo.438.1">Get(b *Book) error</span></strong></pre>
<p><span class="koboSpan" id="kobo.439.1">With the new signature in place, it’s time to change our test code accordingly. </span><span class="koboSpan" id="kobo.439.2">The assertions in </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">TestGet</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.441.1">Book</span></strong><span class="koboSpan" id="kobo.442.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">book_repository_test.go</span></strong><span class="koboSpan" id="kobo.444.1"> file get changed to make use of the </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">new signature:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.446.1">
for name, tc := range tests {
  t.Run(name, func(t *testing.T) {
</span><strong class="bold"><span class="koboSpan" id="kobo.447.1">    var b db.Book</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.448.1">    b.ID = tc.id</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.449.1">    </span></strong><strong class="bold"><span class="koboSpan" id="kobo.450.1">err := bs.Get(&amp;b)</span></strong><span class="koboSpan" id="kobo.451.1">
    if tc.wantErr != nil {
      assert.Equal(t, tc.wantErr, err)
      assert.Nil(t, b)
      return
    }
    assert.Nil(t, err)
    assert.Equal(t, tc.want, b)
  })
}</span></pre>
<p><span class="koboSpan" id="kobo.452.1">We change the test code to make it compile and adjust to the new signature of the function. </span><span class="koboSpan" id="kobo.452.2">During refactoring, tests should be changed as little as possible to ensure that the refactored code has not caused </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">any regressions.</span></span></p>
<p><span class="koboSpan" id="kobo.454.1">At this point, the test will </span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.455.1">be compiling, but we have not completely implemented the code for the new signature. </span><span class="koboSpan" id="kobo.455.2">It’s time to turn our attention to the implementation of this </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">new method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.457.1">
func (bs *BookRepository) </span><strong class="bold"><span class="koboSpan" id="kobo.458.1">Get(b *Book) error</span></strong><span class="koboSpan" id="kobo.459.1"> {
  if r := bs.DB.Where("id = ?",
    </span><strong class="bold"><span class="koboSpan" id="kobo.460.1">b.ID</span></strong><span class="koboSpan" id="kobo.461.1">).First(</span><strong class="bold"><span class="koboSpan" id="kobo.462.1">&amp;b</span></strong><span class="koboSpan" id="kobo.463.1">); r.Error != nil {
      return </span><strong class="bold"><span class="koboSpan" id="kobo.464.1">r.Error</span></strong><span class="koboSpan" id="kobo.465.1">
  }
  </span><strong class="bold"><span class="koboSpan" id="kobo.466.1">return nil</span></strong><span class="koboSpan" id="kobo.467.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.468.1">The code is adjusted to read the ID of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">b *Book</span></strong><span class="koboSpan" id="kobo.470.1"> parameter, and the database populates its results to the same passed-in parameter. </span><span class="koboSpan" id="kobo.470.2">Then, we return an error or </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">nil</span></strong><span class="koboSpan" id="kobo.472.1"> according to whether the item is found </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">or not.</span></span></p>
<p><span class="koboSpan" id="kobo.474.1">Any other calling code will need to be adjusted in the same way as we have adjusted our test code. </span><span class="koboSpan" id="kobo.474.2">The compiler will let you know if you have missed any code that needs to be refactored. </span><span class="koboSpan" id="kobo.474.3">For example, if we add a second parameter to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">Get</span></strong><span class="koboSpan" id="kobo.476.1"> method of </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">BookRepository</span></strong><span class="koboSpan" id="kobo.478.1"> and forget to change it in its test, the compiler will let us know that the expected method signature is not defined when the test </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">is run:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.480.1">
$ go test -run TestGetBook ./chapter07/db
</span><strong class="bold"><span class="koboSpan" id="kobo.481.1">./book_repository_test.go:34:19: not enough arguments in call to bs.Get</span></strong><span class="koboSpan" id="kobo.482.1">
  have (*db.Book)
  want (*db.Book, string)
FAIL    github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter07/db [build failed]</span></pre>
<p><span class="koboSpan" id="kobo.483.1">Remember, your test </span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.484.1">code is the first external consumer of your package’s API, so any changes to the implementation code will affect your tests first. </span><span class="koboSpan" id="kobo.484.2">Note that this non-compiling state of the code has not been committed on our repository, so your test output will not match the </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">preceding snippet.</span></span></p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.486.1">Error verification</span></h1>
<p><span class="koboSpan" id="kobo.487.1">In </span><a href="B18371_04.xhtml#_idTextAnchor085"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.488.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.489.1">, </span><em class="italic"><span class="koboSpan" id="kobo.490.1">Building Efficient Test Suites</span></em><span class="koboSpan" id="kobo.491.1">, we briefly discussed Go’s approach of explicit error handling. </span><span class="koboSpan" id="kobo.491.2">We learned that errors are typically returned last in a list of multiple return </span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.492.1">values. </span><span class="koboSpan" id="kobo.492.2">So far, we have been using Go’s inbuilt </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">error</span></strong><span class="koboSpan" id="kobo.494.1"> type and representative error messages to indicate to the user when something has gone wrong. </span><span class="koboSpan" id="kobo.494.2">Let us now take a closer look at how error verification works </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">in Go.</span></span></p>
<p><span class="koboSpan" id="kobo.496.1">We have created errors in two ways so far. </span><span class="koboSpan" id="kobo.496.2">The simplest way is using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">errors.New</span></strong><span class="koboSpan" id="kobo.498.1"> function. </span><span class="koboSpan" id="kobo.498.2">It creates an error with a </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">given message:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.500.1">
err := errors.New(</span><strong class="bold"><span class="koboSpan" id="kobo.501.1">"Something is wrong!"</span></strong><span class="koboSpan" id="kobo.502.1">)</span></pre>
<p><span class="koboSpan" id="kobo.503.1">This function takes in an error message as a parameter and returns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">error</span></strong><span class="koboSpan" id="kobo.505.1"> interface type. </span><span class="koboSpan" id="kobo.505.2">In order to get our error message back, we invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">Error</span></strong><span class="koboSpan" id="kobo.507.1"> method on </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">the function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.509.1">
msg := err.Error()</span></pre>
<p><span class="koboSpan" id="kobo.510.1">This method returns the message as a </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">string type.</span></span></p>
<p><span class="koboSpan" id="kobo.512.1">Writing a test to compare the incoming and outgoing error messages is trivial for </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">this example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.514.1">
func TestErrorsVerification(t *testing.T){
  t.Run("simple custom error", func(t *testing.T) {
    wantMsg := "Something went wrong!"
</span><span class="koboSpan" id="kobo.514.2">    err := errors.New(wantMsg)
    gotMsg := err.Error()
</span><strong class="bold"><span class="koboSpan" id="kobo.515.1">    assert.Equal(t, wantMsg, gotMsg)</span></strong><span class="koboSpan" id="kobo.516.1">
  })
}</span></pre>
<p><span class="koboSpan" id="kobo.517.1">As we have full control of the entire error message, we can easily assert that the values are equal. </span><span class="koboSpan" id="kobo.517.2">However, what if the error message construction is part of the function? </span><span class="koboSpan" id="kobo.517.3">It is common practice in Go to construct representative error messages that include inputs and other call parameters. </span><span class="koboSpan" id="kobo.517.4">These kinds of errors are typically constructed using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">fmt.Errorf</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.519.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.520.1">
func checkOdd(input int) error {
  if input%2 == 0 {
</span><strong class="bold"><span class="koboSpan" id="kobo.521.1">    return fmt.Errorf("Input %d cannot be even.", input)</span></strong><span class="koboSpan" id="kobo.522.1">
  }
  return nil
}</span></pre>
<p><span class="koboSpan" id="kobo.523.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">fmt.Errorf</span></strong><span class="koboSpan" id="kobo.525.1"> function formats </span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.526.1">the error the same as the rest of the formatting functions in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">fmt</span></strong><span class="koboSpan" id="kobo.528.1"> package, but returns an </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">error</span></strong><span class="koboSpan" id="kobo.530.1"> type with a well-formatted message. </span><span class="koboSpan" id="kobo.530.2">Asserting on this error message is slightly </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">more complicated.</span></span></p>
<p><span class="koboSpan" id="kobo.532.1">The first option is to reconstruct the error message in the </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">test code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.534.1">
func TestErrorsVerification(t *testing.T) {
  t.Run("formatted custom error", func(t *testing.T) {
   input := 4
   </span><strong class="bold"><span class="koboSpan" id="kobo.535.1">wantMsg := fmt.Sprintf("Input %d cannot be even.",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.536.1">      input)</span></strong><span class="koboSpan" id="kobo.537.1">
   err := checkOdd(input)
   gotMsg := err.Error()
   </span><strong class="bold"><span class="koboSpan" id="kobo.538.1">assert.Equal(t, wantMsg, gotMsg)</span></strong><span class="koboSpan" id="kobo.539.1">
  })
}</span></pre>
<p><span class="koboSpan" id="kobo.540.1">The test code makes use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">fmt.Sprintf</span></strong><span class="koboSpan" id="kobo.542.1"> function to format the expected error message using the same format from the call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">fmt.Errorf</span></strong><span class="koboSpan" id="kobo.544.1"> function in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">checkOdd</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.546.1">implementation function.</span></span></p>
<p><span class="koboSpan" id="kobo.547.1">This first option has </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">three disadvantages:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.549.1">The test code </span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.550.1">has to repeat the implementation code simply for the purposes of verification. </span><span class="koboSpan" id="kobo.550.2">This can get complex if the error message requires </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">significant setup.</span></span></li>
<li><span class="koboSpan" id="kobo.552.1">The test code is now tightly coupled to the implementation code. </span><span class="koboSpan" id="kobo.552.2">Changing the error formatting logic in the implementation code now requires the same change in the </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">test code.</span></span></li>
<li><span class="koboSpan" id="kobo.554.1">There is no way to ensure that the formatting is replicated in the exact same way across test scenarios. </span><span class="koboSpan" id="kobo.554.2">This is likely to be a problem in large code bases that are maintained by large </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">engineering teams.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.556.1">The second option is to relax our error verification so that we no longer need to completely recreate the </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">error message:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.558.1">
func TestErrorsVerification(t *testing.T) {
  t.Run("formatted custom error", func(t *testing.T) {
    input := 4
    err := checkOdd(input)
    gotMsg := err.Error()
</span><strong class="bold"><span class="koboSpan" id="kobo.559.1">    assert.Contains(t, gotMsg, fmt.Sprint(input))</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.560.1">    assert.Contains(t, gotMsg, "even")</span></strong><span class="koboSpan" id="kobo.561.1">
  })
}</span></pre>
<p><span class="koboSpan" id="kobo.562.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">assert.Contains</span></strong><span class="koboSpan" id="kobo.564.1"> function is used to verify that the error message contains some substrings, which we can be relatively sure will not change in the implementation code. </span><span class="koboSpan" id="kobo.564.2">This option has removed the need for full implementation of the error message formatting, simplifying our </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">test code.</span></span></p>
<p><span class="koboSpan" id="kobo.566.1">However, this second option also has quite a </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">few disadvantages:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.568.1">The error message </span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.569.1">assertion is not fully verified. </span><span class="koboSpan" id="kobo.569.2">For example, the implementation could be producing completely nonsense messages and our test will pass as long as the strings verified are contained within it. </span><span class="koboSpan" id="kobo.569.3">The test would no longer be able to assert on the full functionality of the implementation code. </span><span class="koboSpan" id="kobo.569.4">Other types of testing, such as integration or end-to-end tests, may verify this. </span><span class="koboSpan" id="kobo.569.5">However, we will explore how to include error assertions in </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">unit tests.</span></span></li>
<li><span class="koboSpan" id="kobo.571.1">Even though it has been reduced, the test code still has some leaked implementation knowledge and a hardcoded part of the error message. </span><span class="koboSpan" id="kobo.571.2">Therefore, the test is still brittle and tightly coupled to its </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">implementation counterpart.</span></span></li>
<li><span class="koboSpan" id="kobo.573.1">There is still no way to ensure that the assertions are performed in the same way across tests. </span><span class="koboSpan" id="kobo.573.2">In fact, because the expected string is no longer constructed during the Arrange part of the test, it can be even more difficult to find the hardcoded strings until the test suite points out </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">the failures.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.575.1">As discussed, both of our two immediate options have significant disadvantages. </span><span class="koboSpan" id="kobo.575.2">However, as we </span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.576.1">remember from </span><a href="B18371_04.xhtml#_idTextAnchor085"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.577.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.578.1">, </span><em class="italic"><span class="koboSpan" id="kobo.579.1">Building Efficient Test Suites</span></em><span class="koboSpan" id="kobo.580.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">error</span></strong><span class="koboSpan" id="kobo.582.1"> type is a simple interface with only a </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">single method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.584.1">
type error interface {
</span><strong class="bold"><span class="koboSpan" id="kobo.585.1">  </span></strong><strong class="bold"><span class="koboSpan" id="kobo.586.1">Error() string</span></strong><span class="koboSpan" id="kobo.587.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.588.1">We can easily implement our own custom error types by implementing this simple function. </span><span class="koboSpan" id="kobo.588.2">As we have seen on multiple occasions, the power of interfaces shines in many aspects of the Go programming language, and error handling is one of them </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">as well.</span></span></p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.590.1">Custom error types</span></h2>
<p><span class="koboSpan" id="kobo.591.1">The third option for </span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.592.1">error handling is to create our </span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.593.1">own custom error types, which will allow us to add more information to the error type than simply formatting a string multiple times. </span><span class="koboSpan" id="kobo.593.2">This will give us flexibility in both implementation and </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">test code.</span></span></p>
<p><span class="koboSpan" id="kobo.595.1">First, we will define a simple </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">evenNumberError</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.597.1"> type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.598.1">
type evenNumberError struct {
</span><strong class="bold"><span class="koboSpan" id="kobo.599.1">  input int</span></strong><span class="koboSpan" id="kobo.600.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.601.1">This type has a field for the input of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">checkOdd</span></strong><span class="koboSpan" id="kobo.603.1"> function. </span><span class="koboSpan" id="kobo.603.2">This will allow the test to have access to the input value without having to check the returned error message, which was necessary for the first and second options </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">presented previously.</span></span></p>
<p><span class="koboSpan" id="kobo.605.1">Next, we need to add a method to this new type to ensure that it satisfies the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">error</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.607.1"> interface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.608.1">
func (</span><strong class="bold"><span class="koboSpan" id="kobo.609.1">e *evenNumberError</span></strong><span class="koboSpan" id="kobo.610.1">) Error() string {
</span><strong class="bold"><span class="koboSpan" id="kobo.611.1">    return fmt.Sprintf("Input %d cannot be even.", e.input)</span></strong><span class="koboSpan" id="kobo.612.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.613.1">This method has </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">evenNumberError</span></strong><span class="koboSpan" id="kobo.615.1"> as a receiver and the same signature as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">error</span></strong><span class="koboSpan" id="kobo.617.1"> interface. </span><span class="koboSpan" id="kobo.617.2">Inside </span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.618.1">the method, we use the same </span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.619.1">format and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">fmt.Sprintf</span></strong><span class="koboSpan" id="kobo.621.1"> function, together with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">input</span></strong><span class="koboSpan" id="kobo.623.1"> field of </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">the receiver.</span></span></p>
<p><span class="koboSpan" id="kobo.625.1">The implementation function can be changed to use this new </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">error</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.627.1"> type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.628.1">
func checkOdd(input int) </span><strong class="bold"><span class="koboSpan" id="kobo.629.1">error</span></strong><span class="koboSpan" id="kobo.630.1"> {
  if input%2 == 0 {
</span><strong class="bold"><span class="koboSpan" id="kobo.631.1">   return &amp;evenNumberError{</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.632.1">     input: input,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.633.1">   </span></strong><strong class="bold"><span class="koboSpan" id="kobo.634.1">}</span></strong><span class="koboSpan" id="kobo.635.1">
  }
  return nil
}</span></pre>
<p><span class="koboSpan" id="kobo.636.1">With the error formatting wrapped inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">evenNumberError</span></strong><span class="koboSpan" id="kobo.638.1"> type, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">return</span></strong><span class="koboSpan" id="kobo.640.1"> statement of this function simply consists of creating a new instance of this type and returning a pointer to it. </span><span class="koboSpan" id="kobo.640.2">We pass the parameter from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">checkOdd</span></strong><span class="koboSpan" id="kobo.642.1"> function to </span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">its initialization.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.644.1">Always return the error interface</span></p>
<p class="callout"><span class="koboSpan" id="kobo.645.1">One last thing to note is that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">checkOdd</span></strong><span class="koboSpan" id="kobo.647.1"> function still returns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">error</span></strong><span class="koboSpan" id="kobo.649.1"> interface. </span><span class="koboSpan" id="kobo.649.2">Therefore, the calling code does not need to have any knowledge of the custom error types created in this package. </span><span class="koboSpan" id="kobo.649.3">When working with custom error types, you should always follow this pattern </span><span class="No-Break"><span class="koboSpan" id="kobo.650.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.651.1">The test </span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.652.1">code is much simplified with this new </span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.653.1">custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">error</span></strong><span class="koboSpan" id="kobo.655.1"> type </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">in place:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.657.1">
func TestErrorsVerification(t *testing.T) {
  t.Run("custom error type", func(t *testing.T) {
    input := 4
</span><strong class="bold"><span class="koboSpan" id="kobo.658.1">    </span></strong><strong class="bold"><span class="koboSpan" id="kobo.659.1">wantErr := &amp;evenNumberError{</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.660.1">      input: input,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.661.1">    }</span></strong><span class="koboSpan" id="kobo.662.1">
    err := checkOdd(input)
</span><strong class="bold"><span class="koboSpan" id="kobo.663.1">    var gotErr *evenNumberError</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.664.1">    require.True(t, errors.As(err, &amp;gotErr))</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.665.1">    assert.Equal(t, wantErr, gotErr)</span></strong><span class="koboSpan" id="kobo.666.1">
  })
}</span></pre>
<p><span class="koboSpan" id="kobo.667.1">The implementation of the error verification in this example demonstrates how to run verifications on custom </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">error</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.669.1"> types:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.670.1">We create an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">evenNumberError</span></strong><span class="koboSpan" id="kobo.672.1"> type with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">input</span></strong><span class="koboSpan" id="kobo.674.1"> field. </span><span class="koboSpan" id="kobo.674.2">This is much simpler than having to create an expected </span><span class="No-Break"><span class="koboSpan" id="kobo.675.1">error message.</span></span></li>
<li><span class="koboSpan" id="kobo.676.1">After calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">checkOdd</span></strong><span class="koboSpan" id="kobo.678.1"> function, we need to convert the built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">error</span></strong><span class="koboSpan" id="kobo.680.1"> value to the custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">error</span></strong><span class="koboSpan" id="kobo.682.1"> type. </span><span class="koboSpan" id="kobo.682.2">This is done by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">errors.As</span></strong><span class="koboSpan" id="kobo.684.1"> function, which returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">true</span></strong><span class="koboSpan" id="kobo.686.1"> if the conversion has </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">been successful.</span></span></li>
<li><span class="koboSpan" id="kobo.688.1">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">require.True</span></strong><span class="koboSpan" id="kobo.690.1"> function to ensure that the test fails if the </span><span class="No-Break"><span class="koboSpan" id="kobo.691.1">conversion fails.</span></span></li>
<li><span class="koboSpan" id="kobo.692.1">Finally, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">assert.Equal</span></strong><span class="koboSpan" id="kobo.694.1"> function to ensure that the actual error is </span><span class="No-Break"><span class="koboSpan" id="kobo.695.1">as expected.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.696.1">The implementation of the test is much simpler, and it is no longer tightly coupled to error formatting </span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.697.1">inside the function under test. </span><span class="koboSpan" id="kobo.697.2">This approach </span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.698.1">does have a slight disadvantage in that it creates a new custom type, but working with custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">error</span></strong><span class="koboSpan" id="kobo.700.1"> types streamlines the implementation code by providing a single, unified, way to </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">format errors.</span></span></p>
<p><span class="koboSpan" id="kobo.702.1">We run the test as usual to see our error verification </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">in action:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.704.1">
$ go test -run TestErrorsVerification ./chapter07/errors -v
=== RUN   TestErrorsVerification
=== RUN   TestErrorsVerification/simple_custom_error
=== RUN   TestErrorsVerification/formatted_custom_error
=== RUN   TestErrorsVerification/contains_custom_error
=== RUN   TestErrorsVerification/custom_error_type
--- PASS: TestErrorsVerification (0.00s)
  --- PASS: TestErrorsVerification/simple_custom_error (0.00s)
  --- PASS: TestErrorsVerification/formatted_custom_error (0.00s)
  --- PASS: TestErrorsVerification/contains_custom_error (0.00s)
  --- PASS: TestErrorsVerification/custom_error_type (0.00s)
PASS
ok      github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter07/errors       0.122s</span></pre>
<p><span class="koboSpan" id="kobo.705.1">Each test case runs in its subtest, as can be seen from the </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">organized output.</span></span></p>
<p><span class="koboSpan" id="kobo.707.1">Another </span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.708.1">advantage of using custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">error</span></strong><span class="koboSpan" id="kobo.710.1"> types is that they </span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.711.1">allow a function to return multiple types of errors, which can provide context to callers of a given package or service. </span><span class="koboSpan" id="kobo.711.2">For now, we should remember that they have the advantage of streamlining our test code while providing precise error </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">verification possibilities.</span></span></p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.713.1">Splitting up the monolith</span></h1>
<p><span class="koboSpan" id="kobo.714.1">The final aspect of refactoring that we will discuss is moving from a monolith to a microservice architecture. </span><span class="koboSpan" id="kobo.714.2">While there are examples of large companies that successfully operate using a monolithic architecture, the consensus in the technical community is that a microservice architecture is easier to scale and maintain, particularly when working across multiple teams. </span><span class="koboSpan" id="kobo.714.3">It is therefore important to discuss some of the basics of how and when to split up a service </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">during refactoring.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.716.1">What is a monolithic application?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.717.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.718.1">monolithic application</span></strong><span class="koboSpan" id="kobo.719.1"> is a single application that is built and released in one unit. </span><span class="koboSpan" id="kobo.719.2">The term is typically used </span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.720.1">to refer to a large application, with many different responsibilities that serve many different </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">user journeys.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.722.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.723.1">.5</span></em><span class="koboSpan" id="kobo.724.1"> depicts </span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.725.1">some of the advantages and disadvantages of </span><a id="_idIndexMarker583"/><span class="No-Break"><span class="koboSpan" id="kobo.726.1">monolithic applications:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer063">
<span class="koboSpan" id="kobo.727.1"><img alt="Figure 7.5 – Pros and cons of monolithic applications " src="image/Figure_7.05_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.728.1">Figure 7.5 – Pros and cons of monolithic applications</span></p>
<p><span class="koboSpan" id="kobo.729.1">The list of pros and </span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.730.1">cons of monolithic applications spans </span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.731.1">from deployment </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">to resilience:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.733.1">As monoliths are built and deployed in one running application, developers will find them </span><strong class="bold"><span class="koboSpan" id="kobo.734.1">easy to deploy</span></strong><span class="koboSpan" id="kobo.735.1">. </span><span class="koboSpan" id="kobo.735.2">However, as all the components are deployed together, they also cannot be scaled individually, making the application </span><strong class="bold"><span class="koboSpan" id="kobo.736.1">harder to scale</span></strong><span class="koboSpan" id="kobo.737.1">. </span><span class="koboSpan" id="kobo.737.2">This can be a significant bottleneck to how many requests the application can handle, affecting a business’s revenue. </span><span class="koboSpan" id="kobo.737.3">Scaling the monolith as a whole can also be unduly expensive, as all resources are </span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">scaled together.</span></span></li>
<li><span class="koboSpan" id="kobo.739.1">Monolithic applications have a lower cognitive burden because all of their code lives in one single, searchable code base. </span><span class="koboSpan" id="kobo.739.2">At the beginning of the project, developers have an easier time developing in one single code base. </span><span class="koboSpan" id="kobo.739.3">However, as the project progresses and the team grows, the code base becomes constrained by its initial architecture, design, and technology choices. </span><span class="koboSpan" id="kobo.739.4">Often, this leads to </span><strong class="bold"><span class="koboSpan" id="kobo.740.1">slower </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.741.1">development speed</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.742.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.743.1">As they only have to start up one application, engineers find monolithic applications </span><strong class="bold"><span class="koboSpan" id="kobo.744.1">simple to test and debug</span></strong><span class="koboSpan" id="kobo.745.1">. </span><span class="koboSpan" id="kobo.745.2">However, as all modules are hosted together, </span><strong class="bold"><span class="koboSpan" id="kobo.746.1">errors can cause full outages</span></strong><span class="koboSpan" id="kobo.747.1"> of the application. </span><span class="koboSpan" id="kobo.747.2">This can again significantly affect a </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">business’s revenue.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.749.1">Many organizations start out with a monolithic application when they have a small code base and engineering team. </span><span class="koboSpan" id="kobo.749.2">Then, as their team and application functionality grow, they struggle to scale and maintain their monoliths. </span><span class="koboSpan" id="kobo.749.3">A new approach to building applications was required to mitigate the disadvantages that come with developing code in </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">a monolith.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.751.1">What is a microservice architecture?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.752.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.753.1">microservice architecture</span></strong><span class="koboSpan" id="kobo.754.1"> is a system </span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.755.1">design method that relies on independently </span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.756.1">built and released services, known as </span><strong class="bold"><span class="koboSpan" id="kobo.757.1">microservices</span></strong><span class="koboSpan" id="kobo.758.1">. </span><span class="koboSpan" id="kobo.758.2">These independent units have their own responsibilities and self-contained resources for accomplishing </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">their goals.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.760.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.761.1">.6</span></em><span class="koboSpan" id="kobo.762.1"> depicts some of the advantages and disadvantages of </span><span class="No-Break"><span class="koboSpan" id="kobo.763.1">microservice architectures:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer064">
<span class="koboSpan" id="kobo.764.1"><img alt="Figure 7.6 – Pros and cons of microservice architectures " src="image/Figure_7.06_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.765.1">Figure 7.6 – Pros and cons of microservice architectures</span></p>
<p><span class="koboSpan" id="kobo.766.1">The pros of </span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.767.1">microservice architectures have addressed </span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.768.1">many of the cons of </span><span class="No-Break"><span class="koboSpan" id="kobo.769.1">monolithic applications:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.770.1">As each microservice is independently deployed, this type of architecture offers </span><strong class="bold"><span class="koboSpan" id="kobo.771.1">flexible scaling</span></strong><span class="koboSpan" id="kobo.772.1">. </span><span class="koboSpan" id="kobo.772.2">This allows </span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.773.1">us to scale one part of the application, according to which user journeys are most popular. </span><span class="koboSpan" id="kobo.773.2">However, as each service </span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.774.1">has its own dedicated set of resources, microservice architectures can incur </span><strong class="bold"><span class="koboSpan" id="kobo.775.1">higher </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.776.1">infrastructure costs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.778.1">The smaller code bases of the microservices are </span><strong class="bold"><span class="koboSpan" id="kobo.779.1">easier to maintain</span></strong><span class="koboSpan" id="kobo.780.1">, especially when it comes to refactoring. </span><span class="koboSpan" id="kobo.780.2">They can also make their own technical choices, offering engineers the opportunity to choose the best tool for the goals of each microservice. </span><span class="koboSpan" id="kobo.780.3">However, the separation between the different code bases does require </span><strong class="bold"><span class="koboSpan" id="kobo.781.1">higher organizational overhead</span></strong><span class="koboSpan" id="kobo.782.1"> in order to ensure that the individual units function together correctly and follow a unified set of </span><span class="No-Break"><span class="koboSpan" id="kobo.783.1">engineering standards.</span></span></li>
<li><span class="koboSpan" id="kobo.784.1">As each microservice has its own well-defined functionality and responsibilities, they require a </span><strong class="bold"><span class="koboSpan" id="kobo.785.1">smaller scope of tests</span></strong><span class="koboSpan" id="kobo.786.1"> to ensure that they are working correctly. </span><span class="koboSpan" id="kobo.786.2">However, the integration points become the focal point of tests, making integration tests more important than ever. </span><span class="koboSpan" id="kobo.786.3">When a systemic error happens, each service also has its own set of logs, making this type of architecture </span><strong class="bold"><span class="koboSpan" id="kobo.787.1">more difficult </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.788.1">to debug</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">.</span></span></li>
</ul>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.790.1">Figure 7</span></em></span><em class="italic"><span class="koboSpan" id="kobo.791.1">.7</span></em><span class="koboSpan" id="kobo.792.1"> depicts the two </span><span class="No-Break"><span class="koboSpan" id="kobo.793.1">system types:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer065">
<span class="koboSpan" id="kobo.794.1"><img alt="Figure 7.7 – Monolithic application versus microservice architecture " src="image/Figure_7.07_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.795.1">Figure 7.7 – Monolithic application versus microservice architecture</span></p>
<p><span class="koboSpan" id="kobo.796.1">The monolithic application contains all of the components required in one single unit and relies on </span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.797.1">one database. </span><span class="koboSpan" id="kobo.797.2">The microservice architecture splits the monolithic application according to the functionality that they provide and these functionalities depend on each other to deliver the same user journeys as the </span><span class="No-Break"><span class="koboSpan" id="kobo.798.1">monolithic application.</span></span></p>
<p><span class="koboSpan" id="kobo.799.1">As we have seen, neither development approach is perfect. </span><span class="koboSpan" id="kobo.799.2">A monolithic application may work perfectly well when application traffic is predictable or the team has strict architecture design guidelines, but most organizations grow their teams and evolve their products. </span><span class="koboSpan" id="kobo.799.3">In these circumstances, organizations will usually opt for a microservice architecture. </span><span class="koboSpan" id="kobo.799.4">Therefore, it is absolutely essential for engineers to know how to develop and test </span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">microservice architectures.</span></span></p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.801.1">Key refactoring considerations</span></h2>
<p><span class="koboSpan" id="kobo.802.1">Many organizations have undertaken the work to split up their monolithic applications into microservice </span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.803.1">architectures. </span><span class="koboSpan" id="kobo.803.2">The engineering community has discussed how to undertake this journey as painlessly and successfully as possible. </span><span class="koboSpan" id="kobo.803.3">We can highlight some key considerations for this type </span><span class="No-Break"><span class="koboSpan" id="kobo.804.1">of refactoring.</span></span></p>
<h3><span class="koboSpan" id="kobo.805.1">Define boundaries</span></h3>
<p><span class="koboSpan" id="kobo.806.1">In order to be successful, microservices need to have their own domain and have well-defined application boundaries. </span><span class="koboSpan" id="kobo.806.2">Engineering teams can identify which parts of the monolith they should extract, either through analysis or generated </span><span class="No-Break"><span class="koboSpan" id="kobo.807.1">dependency graphs.</span></span></p>
<p><span class="koboSpan" id="kobo.808.1">Based on these, they can scope </span><span class="No-Break"><span class="koboSpan" id="kobo.809.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.810.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.811.1">functionality and models of the domain</span></strong><span class="koboSpan" id="kobo.812.1"> that the microservice will be responsible for. </span><span class="koboSpan" id="kobo.812.2">For example, in an e-commerce application, we might identify a service that is responsible for placing and managing items in the </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">shopping cart.</span></span></li>
<li><span class="koboSpan" id="kobo.814.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.815.1">upstream dependencies</span></strong><span class="koboSpan" id="kobo.816.1"> that the microservice will require. </span><span class="koboSpan" id="kobo.816.2">For example, the previously identified shopping cart service will have a dependency on the inventory service, which will tell it how much items cost and whether they are </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">in stock.</span></span></li>
<li><span class="koboSpan" id="kobo.818.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.819.1">downstream dependencies</span></strong><span class="koboSpan" id="kobo.820.1"> and data storage solution that the microservice will require. </span><span class="koboSpan" id="kobo.820.2">For example, the shopping cart service will save its data to an in-memory data structure store, such as Redis, and have a downstream dependency to a checkout service once the user decides to purchase </span><span class="No-Break"><span class="koboSpan" id="kobo.821.1">their cart.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.822.1">The result of the boundary identification exercise could be a high-level design of the infrastructure requirements of the microservice, as well as an overview of the API that the microservice will expose to other parts of </span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">the system.</span></span></p>
<h3><span class="koboSpan" id="kobo.824.1">Loose coupling</span></h3>
<p><span class="koboSpan" id="kobo.825.1">One of the advantages of a microservice architecture is that it allows us to build services that are </span><strong class="bold"><span class="koboSpan" id="kobo.826.1">loosely coupled</span></strong><span class="koboSpan" id="kobo.827.1">, from </span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.828.1">both a development and deployment perspective. </span><span class="koboSpan" id="kobo.828.2">However, this advantage can be easily lost if the teams don’t isolate </span><span class="No-Break"><span class="koboSpan" id="kobo.829.1">inter-service dependencies.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.830.1">What is a loose coupling for microservices?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.831.1">In microservice architectures, services are loosely coupled if changes to one service’s design or </span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.832.1">implementation will not cause changes in other services that it depends on or that depend </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">on it.</span></span></p>
<p><span class="koboSpan" id="kobo.834.1">Loosely coupled microservices should follow the following rules </span><span class="No-Break"><span class="koboSpan" id="kobo.835.1">of thumb:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.836.1">Have separate data stores</span></strong><span class="koboSpan" id="kobo.837.1">: When microservices share a single database, they also </span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.838.1">share a </span><strong class="bold"><span class="koboSpan" id="kobo.839.1">single point of failure</span></strong><span class="koboSpan" id="kobo.840.1">. </span><span class="koboSpan" id="kobo.840.2">An outage on the shared database will cause all of the services that depend on it to fail </span><span class="No-Break"><span class="koboSpan" id="kobo.841.1">as well.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.842.1">Use asynchronous communication</span></strong><span class="koboSpan" id="kobo.843.1">: Use asynchronous communication patterns such as queues and event buses to pass data to other services. </span><span class="koboSpan" id="kobo.843.2">This allows us to scale services independently and even batch messages </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">when appropriate.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.845.1">Implement fault tolerance</span></strong><span class="koboSpan" id="kobo.846.1">: Design your service with the assumption that its internal and external dependencies will fail or be slow to respond. </span><span class="koboSpan" id="kobo.846.2">A common way this is implemented in REST APIs is with the circuit breaker pattern, which will time out external calls when patterns of failure are detected in order to ensure that your microservice can continue to function, using default values if one of its dependencies is no </span><span class="No-Break"><span class="koboSpan" id="kobo.847.1">longer available.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.848.1">Make backward-compatible changes</span></strong><span class="koboSpan" id="kobo.849.1">: Whenever possible, microservice APIs should make backward-compatible changes that will not force other services to implement changes to their payloads at the </span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">same time.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.851.1">Implement request tracing and service monitoring</span></strong><span class="koboSpan" id="kobo.852.1">: In the microservice world, it is important to understand how requests flow through your system. </span><span class="koboSpan" id="kobo.852.2">This is important </span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.853.1">for detecting errors in your system and identifying services with insufficient </span><span class="No-Break"><span class="koboSpan" id="kobo.854.1">infrastructure resources.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.855.1">Following these rules during microservice design and implementation will help you take advantage of the </span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.856.1">true power of microservices. </span><span class="koboSpan" id="kobo.856.2">In </span><a href="B18371_08.xhtml#_idTextAnchor179"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.857.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.858.1">, </span><em class="italic"><span class="koboSpan" id="kobo.859.1">Testing Microservice Architectures</span></em><span class="koboSpan" id="kobo.860.1">, we will discuss these principles further and discuss the challenges of testing microservices and how we need to adjust our testing strategy to fit the </span><span class="No-Break"><span class="koboSpan" id="kobo.861.1">microservice world.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.862.1">How will the microservice behave without its dependencies?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.863.1">Once we have identified the dependencies of a microservice, we should remember to design and test for the behavior of the microservice in the case that its dependencies encounter an outage. </span><span class="koboSpan" id="kobo.863.2">This important </span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.864.1">part of microservice design, known as </span><strong class="bold"><span class="koboSpan" id="kobo.865.1">graceful degradation</span></strong><span class="koboSpan" id="kobo.866.1">, should not </span><span class="No-Break"><span class="koboSpan" id="kobo.867.1">be overlooked.</span></span></p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.868.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.869.1">In this chapter, we tackled the important topic of code refactoring, which is a crucial and unavoidable part of extending and maintaining healthy code bases. </span><span class="koboSpan" id="kobo.869.2">We started by learning some common code refactoring techniques and discussed the true cost of technical debt. </span><span class="koboSpan" id="kobo.869.3">Then, we revisited the power of interfaces, which make it easy to change dependencies and allow us to use the compiler as a guide </span><span class="No-Break"><span class="koboSpan" id="kobo.870.1">during refactoring.</span></span></p>
<p><span class="koboSpan" id="kobo.871.1">Then, we considered the test changes that we have to make to our tests to ensure that they continue to verify behaviors during two common refactorings: renaming structs and changing method signatures. </span><span class="koboSpan" id="kobo.871.2">Expanding upon our previous knowledge of error handling and verification, we learned how to create custom error types and more easily verify </span><span class="No-Break"><span class="koboSpan" id="kobo.872.1">error messages.</span></span></p>
<p><span class="koboSpan" id="kobo.873.1">Finally, we learned some of the reasons why organizations move from monolithic applications to microservice architectures, and explored some rules of thumb that allow us to create loosely </span><span class="No-Break"><span class="koboSpan" id="kobo.874.1">coupled microservices.</span></span></p>
<p><span class="koboSpan" id="kobo.875.1">In </span><a href="B18371_08.xhtml#_idTextAnchor179"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.876.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.877.1">, </span><em class="italic"><span class="koboSpan" id="kobo.878.1">Testing Microservice Architectures</span></em><span class="koboSpan" id="kobo.879.1">, we will expand on all the concepts we have learned so far and learn what considerations should be made when testing microservice architectures. </span><span class="koboSpan" id="kobo.879.2">We will apply and demonstrate these concepts on our demo application, the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">BookSwap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.881.1"> application.</span></span></p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.882.1">Questions</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.883.1">What is the difference between code redesign and </span><span class="No-Break"><span class="koboSpan" id="kobo.884.1">code refactoring?</span></span></li>
<li><span class="koboSpan" id="kobo.885.1">Describe the working process of </span><span class="No-Break"><span class="koboSpan" id="kobo.886.1">code refactoring.</span></span></li>
<li><span class="koboSpan" id="kobo.887.1">What is </span><span class="No-Break"><span class="koboSpan" id="kobo.888.1">technical debt?</span></span></li>
<li><span class="koboSpan" id="kobo.889.1">What is a monolithic application? </span><span class="koboSpan" id="kobo.889.2">What is a </span><span class="No-Break"><span class="koboSpan" id="kobo.890.1">microservice architecture?</span></span></li>
</ol>
<h1 id="_idParaDest-157"><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.891.1">Further reading</span></h1>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.892.1">Clean Architecture: A Craftsman’s Guide to Software Structure and Design</span></em><span class="koboSpan" id="kobo.893.1">, Robert C. </span><span class="koboSpan" id="kobo.893.2">Martin, published </span><span class="No-Break"><span class="koboSpan" id="kobo.894.1">by Addison-Wesley</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.895.1">Refactoring: Improving the Design of Existing Code</span></em><span class="koboSpan" id="kobo.896.1">, Martin Fowler, published by </span><span class="No-Break"><span class="koboSpan" id="kobo.897.1">Addison-Wesley Professional</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.898.1">Building Microservices Second Edition: Designing Fine-Grained Systems</span></em><span class="koboSpan" id="kobo.899.1">, Sam Newman, published </span><span class="No-Break"><span class="koboSpan" id="kobo.900.1">by O’Reilly</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.901.1">Monolith to Microservices: Evolutionary Patterns to Transform Your Monolith</span></em><span class="koboSpan" id="kobo.902.1">, Sam Newman, published </span><span class="No-Break"><span class="koboSpan" id="kobo.903.1">by O’Reilly</span></span></li>
</ul>
</div>
<div>
<div class="IMG---Figure" id="_idContainer067">
</div>
</div>
</body></html>