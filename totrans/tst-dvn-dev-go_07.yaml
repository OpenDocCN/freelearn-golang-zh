- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Refactoring in Go
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go中的重构
- en: 'We have explored concepts and techniques for tests across the entire testing
    pyramid. We have applied these concepts while building our main project of study,
    the `BookSwap` application. This web application is currently verified by the
    following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了整个测试金字塔中测试的概念和技术。我们在构建我们的主要研究项目，即`BookSwap`应用程序时应用了这些概念。这个网络应用程序目前由以下内容验证：
- en: Unit tests implemented using the Go standard library
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Go标准库实现的单元测试
- en: Integration tests implemented using `httptest`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`httptest`实现的集成测试
- en: End-to-end tests implemented using `godog`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`godog`实现的端到端测试
- en: To demonstrate these techniques in a realistic example, we have extended the
    functionality of the `BookSwap` application with a variety of components. In [*Chapter
    6*](B18371_06.xhtml#_idTextAnchor142), *End-To-End Testing the BookSwap Web Application*,
    we extended the project by adding the ability to run it in Docker and use a PostgreSQL
    database to save its data.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在一个现实示例中演示这些技术，我们通过添加各种组件扩展了`BookSwap`应用程序的功能。在[*第6章*](B18371_06.xhtml#_idTextAnchor142)，“BookSwap网络应用程序的端到端测试”，我们通过添加在Docker中运行和使用PostgreSQL数据库保存其数据的能力来扩展了项目。
- en: 'All of these changes have added complexity to our `BookSwap` application, which
    now relies on the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些更改都增加了我们的`BookSwap`应用程序的复杂性，现在它依赖于以下内容：
- en: Two libraries for database migration and operations – `golang-migrate` and `gorm`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个用于数据库迁移和操作的库 – `golang-migrate`和`gorm`
- en: Three different types of files – source files, implementation files, and Docker
    files
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三种不同类型的文件 – 源文件、实现文件和Docker文件
- en: A complex code structure with multiple layers – `db`, `handlers`, and `cmd`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有多个层级的复杂代码结构 – `db`、`handlers`和`cmd`
- en: The `BookSwap` application started as a simple REST API with a small scope of
    functionality. However, as we kept refining it and adding more code, it became
    more difficult to install and start up. This is part of the natural life cycle
    of software projects. As an engineer, you will more often have to modify and extend
    existing code, performing **brownfield development**, than start and implement
    brand-new projects with no existing dependencies, also known as **greenfield development**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookSwap`应用程序最初是一个简单的REST API，功能范围较小。然而，随着我们不断改进它并添加更多代码，安装和启动变得更加困难。这是软件项目自然生命周期的一部分。作为一名工程师，您将更经常地需要修改和扩展现有代码，执行**棕色地带开发**，而不是启动和实施没有现有依赖的新项目，也称为**绿色地带开发**。'
- en: This chapter is dedicated to `BookSwap` application, we will learn about good
    practices for code refactoring. Then, we will learn how to validate the behavior
    of the restructured code, which should perform and behave identically to its legacy
    equivalent. Finally, we will discuss best practices for splitting up monolithic
    applications into microservices.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门介绍`BookSwap`应用程序，我们将学习代码重构的良好实践。然后，我们将学习如何验证重构代码的行为，它应该与它的遗留等效物执行和表现相同。最后，我们将讨论将单体应用程序拆分为微服务的最佳实践。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What code refactoring is and why it is an essential part of the development
    process
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码重构是什么以及为什么它是开发过程中的一个重要部分
- en: How to effectively change implementation and test code
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何有效地更改实现和测试代码
- en: Error verification in Go
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go中的错误验证
- en: How to validate refactoring success criteria
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何验证重构的成功标准
- en: Good practices for splitting up monolithic applications
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分割单体应用程序的良好实践
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need to have **Go version 1.19** or later installed to run the code
    samples in this chapter. The installation process is described on the official
    Go documentation at [https://go.dev/doc/install](https://go.dev/doc/install).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装**Go版本1.19**或更高版本才能运行本章中的代码示例。安装过程在官方Go文档[https://go.dev/doc/install](https://go.dev/doc/install)中描述。
- en: The code examples included in this book are publicly available at [https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter07](https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter07).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本书包含的代码示例在[https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter07](https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter07)上公开可用。
- en: Understanding changing dependencies
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解依赖关系的变化
- en: In [*Chapter 1*](B18371_01.xhtml#_idTextAnchor015), *Getting to Grips with Test-Driven
    Development*, we discussed refactoring the code we are writing as part of the
    **Red-Green-Refactor** TDD technique. This involved limiting the cleaning up of
    code as we write it. However, as we continue our journey with TDD, it is essential
    that we consider how our code will evolve through time and consider larger-scale
    code refactoring or rewrites.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第1章*](B18371_01.xhtml#_idTextAnchor015)，“掌握测试驱动开发”，我们讨论了作为**红-绿-重构** TDD技术一部分的重构我们正在编写的代码。这涉及到限制我们在编写代码时的清理工作。然而，随着我们继续TDD之旅，考虑我们的代码如何随时间演变以及考虑更大规模的代码重构或重写是至关重要的。
- en: '**Code refactoring** is often used interchangeably with **code redesigning**,
    but they represent different levels of code modification. Code redesigning involves
    changing the functionality of a code base/service, while code refactoring involves
    changing the way the service delivers its existing functionality. In fact, if
    done correctly, code refactoring will be invisible to any internal and external
    users of the service functionality.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码重构**通常与**代码重设计**互换使用，但它们代表了不同层次的代码修改。代码重设计涉及更改代码库/服务的功能，而代码重构涉及更改服务提供现有功能的方式。实际上，如果做得正确，代码重构对服务功能的任何内部和外部用户都是不可见的。'
- en: The purpose of code refactoring
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重构的目的
- en: 'Developers refactor their code to make it more efficient, maintainable, and
    extendable. There are many benefits to code refactoring: better readability, improved
    performance, and enabling developers to change the code more efficiently. Together,
    these are known as **non-functional requirements**.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者重构代码是为了使其更高效、可维护和可扩展。代码重构有许多好处：更好的可读性、改进的性能以及使开发者能够更高效地更改代码。这些共同被称为**非功能性需求**。
- en: 'A project’s testing strategy is an essential aid for verifying and supporting
    efficient code changes and will help developers avoid the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个项目的测试策略是验证和支持高效代码更改的重要辅助工具，并将帮助开发者避免以下情况：
- en: '**Functionality regressions**: The refactored code should not break any existing
    functionality, causing a regression. Integration tests will identify components
    that might no longer work together correctly, while end-to-end tests will pinpoint
    which breakages affect user-facing functionality.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能退化**：重构后的代码不应破坏任何现有功能，导致退化。集成测试将识别可能不再正确协同工作的组件，而端到端测试将确定哪些破坏影响了用户界面功能。'
- en: '**Performance degradation**: The refactored code should not perform any slower
    than the existing functionality. Integration tests will identify which components
    have slowed down for a particular scenario or operation, signaling to developers
    which components should be investigated further. End-to-end tests will identify
    which performance issues are affecting users but might make it more difficult
    to isolate the problem, as they don’t provide the granularity of system components.
    However, they will give an important indication of the severity of a particular
    performance issue, allowing developers to correctly prioritize issues. We will
    cover performance testing in more detail in [*Chapter 8*](B18371_08.xhtml#_idTextAnchor179),
    *Testing* *Microservice Architectures*.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能下降**：重构后的代码不应比现有功能运行得更慢。集成测试将确定哪些组件在特定场景或操作中变慢，向开发者发出信号，指出哪些组件应进一步调查。端到端测试将确定哪些性能问题影响用户，但可能使隔离问题变得更加困难，因为它们不提供系统组件的粒度。然而，它们将给出一个关于特定性能问题严重性的重要指示，使开发者能够正确地优先处理问题。我们将在[*第8章*](B18371_08.xhtml#_idTextAnchor179)，“测试*微服务架构*”中更详细地介绍性能测试。'
- en: '**Changes outside the intended scope**: The refactored code should not affect
    components outside the intended scope of the changes. This indication is particularly
    important for legacy code bases, where developers might not have a clear picture
    of the dependency graph of the different components. Unit tests will pinpoint
    which packages within the current codebase/service might be affected by the refactor,
    while integration tests will highlight whether the APIs between different services
    might be broken.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超出预期范围的变化**：重构后的代码不应影响预期范围之外的其他组件。这种指示对于遗留代码库尤为重要，因为开发者可能对不同组件的依赖关系图没有清晰的了解。单元测试将确定当前代码库/服务中哪些包可能受到重构的影响，而集成测试将突出显示不同服务之间的API是否可能被破坏。'
- en: 'The potential costs of these issues come in multiple forms:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的潜在成本以多种形式出现：
- en: Losing business/transaction volume during a potential outage
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在潜在的故障期间，失去业务/交易量
- en: Increased infrastructure/cloud costs in the case of slower performance
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在性能较慢的情况下，增加基础设施/云成本
- en: Increased development costs if developers take a longer time to deliver a code
    change
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果开发者花费更长的时间交付代码更改，则增加开发成本
- en: Therefore, it is essential that code refactoring is easy to take on and verify.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，代码重构易于接受和验证至关重要。
- en: Code refactoring steps and techniques
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码重构步骤和技术
- en: 'Now that we understand the fundamental need for code refactoring, let us explore
    some code refactoring techniques. These are not limited to Go development itself,
    but it is important to understand the process by which we change the code so that
    we can then understand how to effectively validate its output. *Figure 7**.1*
    depicts the basic working process of code refactoring:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了代码重构的基本需求，让我们来探讨一些代码重构技术。这些技术不仅限于 Go 开发本身，但了解我们更改代码的过程很重要，这样我们才能了解如何有效地验证其输出。*图
    7.1* 展示了代码重构的基本工作流程：
- en: '![Figure 7.1 – The working process of code refactoring ](img/Figure_7.01_B18371.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – 代码重构的工作流程](img/Figure_7.01_B18371.jpg)'
- en: Figure 7.1 – The working process of code refactoring
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 代码重构的工作流程
- en: 'The code refactoring steps rely on tests for verification:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重构步骤依赖于测试进行验证：
- en: The developer identifies the change that they want to make to the existing implementation.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发者确定他们想要对现有实现进行的更改。
- en: Then, they make the required change, ensuring that the code continues to compile.
    This might require making changes to both the implementation and testing code.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，他们进行必要的更改，确保代码能够继续编译。这可能需要修改实现代码和测试代码。
- en: Once their first change is done, the developer runs the test suite to verify
    their implementation changes.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成第一次更改，开发者就会运行测试套件以验证他们的实现更改。
- en: If the tests are passing, then this refactor is successful and the developer
    has successfully implemented this change. They can proceed to commit it and release
    it.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果测试通过，则此重构成功，开发者已成功实施此更改。他们可以继续提交并发布。
- en: If the tests are failing, then this refactor is not successful and the developer
    must revise their refactored change. This might mean making further changes to
    either the implementation or test code or simply adjusting their new code changes.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果测试失败，则此重构不成功，开发者必须修改他们的重构更改。这可能意味着对实现代码或测试代码进行进一步更改，或者简单地调整他们的新代码更改。
- en: The working process is closely related to the red-green-refactor process that
    we have seen in earlier chapters. The developer should not share any changes that
    they make without the test suite successfully passing. This is most often enforced
    by commit checks and test run verifications as part of the build/release pipeline.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程与我们在早期章节中看到的红绿重构过程密切相关。开发者不应在没有测试套件成功通过的情况下共享任何更改。这通常通过提交检查和构建/发布管道中的测试运行验证来强制执行。
- en: 'As depicted in *Figure 7**.2*, code refactoring should consist of a series
    of minor code changes or modifications, ensuring that the refactored code retains
    the same major functionality:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 7.2* 所示，代码重构应包括一系列小的代码更改或修改，确保重构后的代码保留相同的主要功能：
- en: '![Figure 7.2 – Refactoring as a series of minor changes ](img/Figure_7.02_B18371.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 作为一系列小更改的重构](img/Figure_7.02_B18371.jpg)'
- en: Figure 7.2 – Refactoring as a series of minor changes
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 作为一系列小更改的重构
- en: As with many aspects of the code development process, releasing small, isolated
    changes is better than large code releases. This allows developers to verify each
    code change and release it in turn. Furthermore, in the case of issues, reverting
    a small code change will be easier than reverting larger code changes that have
    been committed over multiple days.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 就像代码开发过程的许多方面一样，发布小的、独立的更改比发布大的代码版本更好。这允许开发者验证每个代码更改，并依次发布。此外，在出现问题时，撤销小的代码更改将比撤销多日提交的大代码更改更容易。
- en: '*Figure 7**.3* depicts an overview of five popular code refactoring techniques:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7.3* 展示了五种流行代码重构技术的概述：'
- en: '![Figure 7.3 – Five popular code refactoring techniques ](img/Figure_7.03_B18371.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 五种流行的代码重构技术](img/Figure_7.03_B18371.jpg)'
- en: Figure 7.3 – Five popular code refactoring techniques
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 五种流行的代码重构技术
- en: 'The five techniques can be used together to improve code complexity and duplication:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 五种技术可以结合使用，以改善代码复杂性和重复：
- en: '**Red-green-refactor** is the technique we are already familiar with. The implementation
    is written alongside its corresponding tests, starting with a failing test, making
    it pass, and then refactoring the written code as required. This approach ensures
    that all functionality is covered by tests and that the refactoring is undertaken
    as part of the initial implementation. As tests are written alongside the code,
    this technique will most likely require test changes as part of the code refactoring
    process.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**红-绿-重构**是我们已经熟悉的技术。实现与相应的测试一起编写，从失败的测试开始，使其通过，然后根据需要重构编写的代码。这种方法确保所有功能都由测试覆盖，并且重构是作为初始实现的一部分进行的。由于测试与代码一起编写，因此这种技术可能需要在代码重构过程中进行测试更改。'
- en: '**Extract** is the technique that involves extracting an existing code fragment
    from a potentially large function into its own function. This function name should
    describe the functionality that the extracted fragment implements, improving the
    readability of the previous large function containing multiple pieces of functionality.
    As code is only extracted, not rewritten, test changes will not likely be required.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提取**是一种涉及将现有代码片段从可能很大的函数中提取出来形成其自身函数的技术。这个函数名应该描述提取片段实现的功能，从而提高包含多个功能片段的先前大函数的可读性。由于代码只是被提取，而不是重写，因此不太可能需要测试更改。'
- en: '**Simplify** is the technique that improves the complexity of large functions.
    This can be done by refactoring conditional expressions or adjusting method calls
    by refactoring function parameters or adjusting interface signatures. As this
    technique involves changing function signatures, test changes will most likely
    be required.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化**是一种提高大型函数复杂性的技术。这可以通过重构条件表达式或通过重构函数参数或调整接口签名来调整方法调用来实现。由于这种技术涉及更改函数签名，因此可能需要测试更改。'
- en: '**Inline** is the opposite technique to **Extract**. It involves removing redundant
    functions by taking their contents and putting them in place of the existing function
    call. This reduces the indirection of the code, reducing the cognitive burden
    of the developer reading the code. Unless the method being tested is removed,
    this technique will not likely require test changes.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内联**是与**提取**相反的技术。它涉及通过将内容移除并替换为现有函数调用的位置来删除冗余功能。这减少了代码的间接性，减轻了阅读代码的开发者的认知负担。除非被测试的方法被移除，否则这种技术不太可能需要测试更改。'
- en: '**Abstraction** is the technique most likely suited for larger-scope code refactoring.
    This technique involves introducing new levels of abstraction, such as interfaces,
    to remove repetition and allow the reuse of behaviors across multiple packages.
    Since new interfaces will require the use of mocks and larger scope refactoring,
    this technique will most likely require test changes.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象**是最适合较大范围代码重构的技术。这种技术涉及引入新的抽象级别，如接口，以消除重复并允许在多个包之间重用行为。由于新接口将需要使用模拟和较大范围的重构，因此这种技术可能需要测试更改。'
- en: These popular techniques will help you refactor your code and ensure that it
    continues to adhere to the SOLID principles we have previously discussed in [*Chapter
    3*](B18371_03.xhtml#_idTextAnchor061), *Mocking and* *Assertion Frameworks*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些流行的技术将帮助您重构代码，并确保它继续遵循我们之前在[*第3章*](B18371_03.xhtml#_idTextAnchor061)、“模拟”和“断言框架”中讨论的SOLID原则。
- en: Technical debt
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术债务
- en: Code refactoring is an extremely important and unavoidable part of the development
    life cycle. When code is not routinely refactored and maintained, it begins to
    accumulate **technical debt**. The subject of how to effectively manage technical
    debt has been discussed often in the engineering community, as it is easy for
    engineering managers to prioritize delivering new features, which have a tangible
    monetary value, as opposed to addressing technical debt, which does not have immediate
    consequences or cost associated with it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重构是开发生命周期中极其重要且不可避免的一部分。当代码没有定期重构和维护时，它开始积累**技术债务**。如何有效管理技术债务的问题在工程社区中经常被讨论，因为工程经理很容易将交付具有实际货币价值的新功能（相对于没有立即后果或与之相关的成本的技术债务）作为优先事项。
- en: Technical debt in Agile
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷开发中的技术债务
- en: In Agile, technical debt is the term used to refer to the consequences of prioritizing
    speed over quality. While the code is tested for correct functionality, its internal
    structure might be the result of poor architectural choices that have been made
    for speed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在敏捷中，技术债务是指优先考虑速度而非质量的后果。虽然代码经过测试以确保正确功能，但其内部结构可能是为了速度而做出的不良架构选择的结果。
- en: 'The consequences of technical debt can affect your project in a variety of
    ways:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 技术债务的后果可能会以多种方式影响你的项目：
- en: '**Bugs**: As code accumulates technical debt, duplicated code and high cohesion
    can lead to bugs that are difficult to fix and detect. These can have financial
    consequences in the case that they cause outages or affect user operations.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺陷**：随着技术债务的累积，重复代码和高内聚性可能导致难以修复和检测的缺陷。如果它们导致故障或影响用户操作，可能会产生财务后果。'
- en: '**Decreased productivity**: As technical debt does not follow SOLID principles
    and does not resemble the rest of the code base, it can be difficult for developers
    to change it with new features. Furthermore, technical debt is also typically
    not well documented, so it can be difficult to reason around expected behavior.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**降低生产力**：由于技术债务不遵循SOLID原则，并且与代码库的其他部分不相似，开发者可能难以在添加新功能时对其进行更改。此外，技术债务通常也没有很好地记录，因此难以推断预期的行为。'
- en: '**Limits new features**: As it accumulates, developers can spend their entire
    time fixing bugs and performance issues with technical debt, meaning that they
    do not have time to deliver new features. This “putting out fires” and chaotic
    way of working frustrates engineers and can even lead to higher staff attrition.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制新功能**：随着债务的累积，开发者可能需要花费全部时间修复技术债务带来的缺陷和性能问题，这意味着他们没有时间交付新功能。这种“救火”和混乱的工作方式会让工程师感到沮丧，甚至可能导致更高的员工流失率。'
- en: Technical debt is often compared to financial debt. If we don’t take care of
    the issues in our code for a prolonged period of time and continue extending code
    that has been poorly designed, the debt becomes larger and more difficult to handle,
    similar to how financial debt accumulates interest. To avoid these consequences,
    technical debt should be handled alongside other work in the Agile way of working.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 技术债务常被比作财务债务。如果我们长时间不处理代码中的问题，并继续扩展设计不良的代码，债务会越来越大，处理起来也更加困难，就像财务债务会累积利息一样。为了避免这些后果，技术债务应该以敏捷工作方式与其他工作一起处理。
- en: '*Figure 7**.4* depicts how Agile teams typically structure their work to address
    technical debt with a prioritized work **backlog**:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7**.4* 展示了敏捷团队通常如何以优先级排序的工作 **待办事项** 来处理技术债务：'
- en: '![Figure 7.4 – Sprint planning with technical debt ](img/Figure_7.04_B18371.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 带有技术债务的冲刺计划](img/Figure_7.04_B18371.jpg)'
- en: Figure 7.4 – Sprint planning with technical debt
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 带有技术债务的冲刺计划
- en: 'The **sprint backlog** is a combination of feature work and technical debt:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**冲刺待办事项** 是功能工作和技术债务的结合：'
- en: The development team and product team each maintain their own backlogs. Typically,
    these are represented by Jira tickets or GitHub issues with details of the work
    to be done. The technical debt work will typically involve refactoring existing
    code, while the feature work will consist of adding new functionality. The sprint
    backlog attempts to find a balance between these two types of work.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发团队和产品团队各自维护自己的待办事项。通常，这些由Jira工单或GitHub问题表示，其中包含要完成的工作的详细信息。技术债务工作通常涉及重构现有代码，而功能工作则包括添加新功能。冲刺待办事项试图在这两种类型的工作之间找到平衡。
- en: During sprint planning, representative stakeholders prioritize the work. It
    is considered good practice to involve the development team during planning to
    ensure that the entire team has a good understanding of the goals of the upcoming
    sprint. The engineering team consists of experts who can scope what refactoring
    work should be taken on. They often have an understanding of which parts of the
    system require attention.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在冲刺计划阶段，代表利益相关者会优先考虑工作。在规划过程中涉及开发团队被视为良好实践，以确保整个团队对即将到来的冲刺目标有良好的理解。工程团队由专家组成，他们可以确定应该进行哪些重构工作。他们通常了解系统哪些部分需要关注。
- en: The outcome of the sprint planning meeting is a prioritized list of work that
    makes up the sprint backlog. Based on their expertise, the technical team typically
    provides time estimates for the work to be done. These estimates are then used
    to determine what work can be undertaken to match the capacity of the team. Refactoring
    and feature work are treated as equal, with time being given to each piece of
    work based on provided estimates.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冲刺规划会议的结果是一个优先级列表的工作，这些工作构成了冲刺待办事项。根据他们的专业知识，技术团队通常会为要完成的工作提供时间估计。然后，这些估计被用来确定可以完成哪些工作以匹配团队的能力。重构和功能工作被视为同等重要，每项工作的时间都是根据提供的估计来分配的。
- en: While technical debt seems like it does not have any immediate cost, it’s important
    that teams are allowed to take time to refactor and maintain their code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然技术债务似乎没有立即的成本，但重要的是团队应该被允许花时间重构和维护他们的代码。
- en: Planning for technical debt
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 规划技术债务
- en: A “little and often” approach works best, where technical debt is planned alongside
    feature work, as opposed to a “Big Bang” approach, where a whole sprint is dedicated
    to fixing issues and doing extensive code refactors.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: “少量多次”的方法效果最好，即在规划功能工作的同时规划技术债务，而不是“大爆炸”方法，即整个冲刺都致力于修复问题和进行广泛的代码重构。
- en: Changing dependencies
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变依赖项
- en: Now that we have a good understanding of how to plan and undertake code refactoring,
    it is time to turn our attention to a special case of code refactoring, which
    is changing dependencies. As discussed in [*Chapter 3*](B18371_03.xhtml#_idTextAnchor061),
    *Mocking and Assertion Frameworks*, dependencies are typically wrapped in our
    own interfaces. Go’s powerful interface also helps us refactor our code when dependencies
    change.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经很好地理解了如何规划和执行代码重构，是时候将我们的注意力转向代码重构的一个特殊情况，即更改依赖项。正如在[*第三章*](B18371_03.xhtml#_idTextAnchor061)中讨论的，*模拟和断言框架*，依赖项通常被封装在我们的接口中。Go强大的接口也有助于我们在依赖项更改时重构我们的代码。
- en: 'Interfaces make our code easier to refactor, as well as less coupled, by providing
    the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接口通过以下方式使我们的代码更容易重构，以及更少耦合：
- en: '**Clear expected behavior**: Interfaces are defined on the calling side, establishing
    what the expected behavior of the external dependency will be inside the package.
    Developers have a clear way to indicate what functionality and method signatures
    they expect the external dependency to provide.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**明确的预期行为**：接口在调用端定义，确立了外部依赖在包内的预期行为。开发者有明确的方式来表明他们期望外部依赖提供哪些功能和方法签名。'
- en: '**Compiler-enforced method signatures**: Once the expected behavior is defined,
    the compiler will verify that any struct that is passed as the interface will
    satisfy these signatures. Therefore, the code can never get into a state where
    a certain method is not defined, and cause runtime errors once called.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译器强制的方法签名**：一旦定义了预期的行为，编译器将验证任何作为接口传递的结构是否满足这些签名。因此，代码永远不会进入一个状态，其中某个方法未定义，一旦调用就会导致运行时错误。'
- en: '**Separation between packages**: As the interface lives inside the calling
    package, it provides a barrier between the package and the external dependency.
    The dependency can then be refactored or have new functionality implemented without
    the need to handle these changes in the calling packages.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包之间的分离**：由于接口位于调用包内部，它为包和外部依赖之间提供了一个屏障。然后，可以重构依赖项或实现新功能，而无需在调用包中处理这些更改。'
- en: '**Implementation opacity**: The calling package does not have any knowledge
    of the external dependency. This makes it easy for us to replace one concrete
    implementation with another, which makes changing dependencies during refactoring
    easy. We have already seen an example of this in [*Chapter 3*](B18371_03.xhtml#_idTextAnchor061),
    *Mocking and Assertion Frameworks*, where we saw how to provide mocks for dependencies
    of the UUT, allowing us to test its behavior in isolation from all its other concrete
    dependencies.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现透明度**：调用包对外部依赖没有任何了解。这使得我们能够轻松地用一个具体实现替换另一个，这使得在重构期间更改依赖项变得容易。我们已经在[*第三章*](B18371_03.xhtml#_idTextAnchor061)中看到了一个例子，*模拟和断言框架*，我们看到了如何为UUT的依赖项提供模拟，使我们能够独立于所有其他具体依赖项测试其行为。'
- en: 'A good example to analyze this is `PostingService` of the `BookSwap` application.
    The purpose of the service is to take on the order and provide all the book shipping
    functionality:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 分析这个的好例子是`BookSwap`应用程序的`PostingService`。该服务的作用是承担订单并提供所有书籍运输功能：
- en: '[PRE0]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As expected, we have defined `PostingService` as an interface that we have defined
    inside the `BookSwap` application. This service has not been implemented, as we
    have considered the implementation of this service as fully external. Please note
    that this is a purely fictional service that we have used to demonstrate the process
    of providing and consuming external dependencies.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们已将`PostingService`定义为`BookSwap`应用程序内部的一个接口。这个服务尚未实现，因为我们已将这个服务的实现视为完全外部。请注意，这是一个纯粹虚构的服务，我们已用它来演示提供和消费外部依赖的过程。
- en: '`BookService` takes `PostingService` using this defined interface as a dependency:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookService`使用此定义的接口作为依赖项：'
- en: '[PRE1]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can provide any implementation of this function as long as it provides the
    method defined by the interface. This makes it easy for us to provide any implementation
    of this service to the method, without making any further code changes inside
    this package, which means we can keep the scope of the refactoring small to the
    implementing package.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 只要它提供了接口定义中定义的方法，我们就可以提供这个函数的任何实现。这使得我们能够轻松地为方法提供任何服务的实现，而无需在此包内部进行任何进一步的代码更改，这意味着我们可以将重构的范围缩小到实现包。
- en: Nil values as dependencies
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 作为依赖项的空值
- en: The zero value of an interface is nil, so it will satisfy the method signature
    when passed in as well. While a nil value dependency can cause errors if a function
    is called on it, using nil for dependencies we are not interested in is particularly
    useful when writing tests.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接口的零值是nil，因此当它作为参数传递时也会满足方法签名。虽然nil值依赖项如果在它上面调用函数可能会引起错误，但在编写测试时，对于我们不感兴趣的依赖项使用nil特别有用。
- en: While implementation is easy to swap when the signature of the dependency stays
    as expected, changing the interface method signature is not so easy and will require
    us to make changes to the calling packages, which have defined their own wrapping
    interfaces.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当依赖项的签名保持预期不变时，实现交换很容易，但更改接口方法签名并不容易，这将要求我们对定义了自己的包装接口的调用包进行更改。
- en: 'When changing the signature of an interface, you will typically need to make
    the following changes:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当更改接口的签名时，您通常需要做出以下更改：
- en: Make the changes to the implementation of the interface, if it is part of your
    project.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果接口实现是您项目的一部分，请对其进行更改。
- en: Update the test code to ensure that the refactored changes are working correctly.
    This will ensure that you have not introduced any bugs or caused regressions.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新测试代码以确保重构更改正常工作。这将确保您没有引入任何错误或造成回归。
- en: Based on the compiler errors, you can easily identify which packages use the
    implementation type as a dependency, as they will no longer satisfy these old
    method signatures. Then, you can make the corresponding changes to any interfaces
    that wrap around the implementation.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据编译器错误，您可以轻松地识别哪些包使用实现类型作为依赖项，因为它们将不再满足这些旧的方法签名。然后，您可以对任何围绕实现包装的接口进行相应的更改。
- en: If you are using a mock generation tool, you can regenerate your mocks according
    to the newly updated interface definitions.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您正在使用模拟生成工具，您可以根据新更新的接口定义重新生成您的模拟。
- en: As identified by compilation errors, you can make any changes to the test code.
    These changes might be required after regenerating the mocks or to test the new
    behavior of the refactoring.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如编译器错误所识别的，您可以更改测试代码。这些更改可能是在重新生成模拟或测试重构的新行为之后所需的。
- en: The compiler is your guide
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器是您的指南
- en: The enforcement of interface signatures will help you identify which packages
    must be modified and ensure that the code does not end up in an unstable state.
    The compiler will highlight any code that needs to be modified and guide you in
    your refactoring efforts.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接口签名的强制执行将帮助您确定哪些包需要修改，并确保代码不会最终处于不稳定状态。编译器将突出显示任何需要修改的代码，并在您的重构努力中为您提供指导。
- en: As changing interfaces requires a lot of rework, developers will try to avoid
    making these changes. However, taking the time to design your code according to
    good architectural principles should help you avoid needing to make such sweeping
    code changes often.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于更改接口需要大量的重写工作，开发者会尽量避免进行这些更改。然而，花时间根据良好的架构原则设计代码应该有助于您避免经常需要进行如此大规模的代码更改。
- en: Relying on your tests
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖您的测试
- en: 'We now have a good understanding of how to refactor our code and have learned
    how to take advantage of some of Go’s best features: the compiler and interfaces.
    This should make your refactoring much easier and help you fit it into your sprint
    planning. In this section, we will have a look at a couple of examples of code
    refactors in the `BookSwap` application that will allow us to use all the techniques
    we have explored in this chapter.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对如何重构我们的代码有了很好的理解，并学会了如何利用 Go 的一些最佳特性：编译器和接口。这应该会使您的重构更加容易，并帮助您将其纳入您的冲刺计划。在本节中，我们将查看
    `BookSwap` 应用程序中的一些代码重构示例，这将使我们能够使用本章中探索的所有技术。
- en: Automated refactoring
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动重构
- en: 'One of the biggest strengths of Go is its tooling, and IDE support is no exception
    to this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Go 最大的优势之一是其工具和 IDE 支持，这也不例外：
- en: The Google Go team maintains an extension for Go development in Visual Studio
    Code ([https://code.visualstudio.com/docs/languages/go](https://code.visualstudio.com/docs/languages/go))
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Go 团队维护了一个 Visual Studio Code 的 Go 开发扩展（[https://code.visualstudio.com/docs/languages/go](https://code.visualstudio.com/docs/languages/go)）
- en: The `vim-go` plugin ([https://github.com/fatih/vim-go](https://github.com/fatih/vim-go))
    is a popular open source plugin maintained by the Go community
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vim-go` 插件（[https://github.com/fatih/vim-go](https://github.com/fatih/vim-go)）是由
    Go 社区维护的一个流行的开源插件'
- en: The team at JetBrains has created GoLand ([https://www.jetbrains.com/go/](https://www.jetbrains.com/go/)),
    which is a dedicated product for Go development
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JetBrains 团队创建了 GoLand（[https://www.jetbrains.com/go/](https://www.jetbrains.com/go/)），这是一个针对
    Go 开发的专用产品
- en: All of these IDEs provide us with support for looking up references and usages
    of a given type and for renaming symbols across the entire call stack. This can
    take a lot of the boring grunt work of simple refactoring, but you will still
    have to make quite a few changes yourself.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些 IDE 都为我们提供了查找给定类型的引用和用法以及在整个调用堆栈中重命名符号的支持。这可以减少许多简单的重构中的枯燥工作，但您仍然需要自己进行相当多的更改。
- en: Let’s consider the refactoring involved in renaming `BookService` to `BookRepository`.
    We might want to change this name, as we added functionality related to the database
    of the `BookSwap` application in [*Chapter 6*](B18371_06.xhtml#_idTextAnchor142),
    *End-to-End Testing the BookSwap* *Web Application*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑将 `BookService` 重命名为 `BookRepository` 所涉及的重构。我们可能想要更改此名称，因为我们已经在 [*第 6
    章*](B18371_06.xhtml#_idTextAnchor142)，*End-to-End Testing the BookSwap* *Web Application*
    中添加了与 `BookSwap` 应用程序数据库相关的功能。
- en: 'First, we will rename the struct with our IDE’s rename symbol functionality:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用 IDE 的重命名符号功能重命名结构体：
- en: '[PRE2]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will update all the direct references to the old `BookService` in all implementation
    and test code across the entire application. This saves us from fixing a lot of
    compilation errors manually.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这将更新整个应用程序中所有实现和测试代码中对旧 `BookService` 的直接引用。这使我们免去了手动修复大量编译错误。
- en: 'Next, we need to ensure all methods relating to this struct are correctly named.
    The `NewBookService` initialization function will need to be renamed as well:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保所有与这个结构体相关的函数都被正确命名。`NewBookService` 初始化函数也需要重命名：
- en: '[PRE3]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The renamed function makes it clear that it is responsible for creating `BookRepository`
    given its dependencies.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 重命名的函数清楚地表明它负责根据其依赖关系创建 `BookRepository`。
- en: We will need to review any test code for test signatures that relate to the
    old name as well. As we want to name tests after the functionality they verify
    and not the types they verify, we will not need to change any test names for this
    rename.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要审查任何与旧名称相关的测试代码签名。由于我们希望测试名称反映它们验证的功能而不是它们验证的类型，因此我们不需要更改任何测试名称。
- en: 'Finally, the filenames that contain and test these definitions will need to
    be changed to match:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，包含并测试这些定义的文件名需要更改以匹配：
- en: The `book_service.go` file becomes `book_repository.go`, making the naming of
    the file and the code it contains consistent
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`book_service.go` 文件变为 `book_repository.go`，使文件名和其中包含的代码的命名保持一致'
- en: The `book_service_test.go` file becomes `book_repository_test.go`, ensuring
    that the test code and implementation stay grouped together
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`book_service_test.go`文件变为`book_repository_test.go`，确保测试代码和实现保持在一起'
- en: That’s all the work we need to do for renaming a service in our `BookSwap` application.
    This simple code refactor did not require any test changes, but it did demonstrate
    the process that you will have to undertake in refactoring Go code and how you
    can rely on your IDE to take care of some of the more laborious parts.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是我们在`BookSwap`应用程序中重命名服务所需做的所有工作。这个简单的代码重构不需要任何测试更改，但它展示了重构Go代码的过程以及你如何依赖IDE来处理一些更繁琐的部分。
- en: Validating refactored code
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证重构代码
- en: 'While renaming symbols is straightforward, a far more common change that you
    will find yourself having to make will be to change a method’s signature. Let
    us see refactoring for a method signature change of the `Get` method of `BookRepository`,
    which currently has this signature:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然重命名符号很简单，但你将发现自己需要做的更常见更改是更改方法签名。让我们看看对`BookRepository`的`Get`方法签名的重构，该方法目前具有以下签名：
- en: '[PRE4]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This method takes in an ID, fetches `Book` from the database, or returns an
    error in the case that the book is not found. This is a common signature for this
    functionality.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受一个ID，从数据库中检索`Book`，或者在书籍未找到的情况下返回错误。这是此功能的常见签名。
- en: 'We will change this method to take in `*Book` and return only an error. This
    will mean that the book fetched from the database will be populated on the `book`
    parameter and return an error if is not found. The new signature of this method
    will be as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更改此方法以接受`*Book`并仅返回错误。这意味着从数据库中检索到的书籍将被填充到`book`参数中，如果未找到则返回错误。此方法的新签名如下：
- en: '[PRE5]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With the new signature in place, it’s time to change our test code accordingly.
    The assertions in `TestGet` `Book` of the `book_repository_test.go` file get changed
    to make use of the new signature:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的签名就绪后，是时候相应地更改我们的测试代码了。`book_repository_test.go`文件中的`TestGet` `Book`断言被更改以利用新的签名：
- en: '[PRE6]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We change the test code to make it compile and adjust to the new signature of
    the function. During refactoring, tests should be changed as little as possible
    to ensure that the refactored code has not caused any regressions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更改测试代码以使其编译并调整到函数的新签名。在重构过程中，应尽可能少地更改测试，以确保重构的代码没有造成任何回归。
- en: 'At this point, the test will be compiling, but we have not completely implemented
    the code for the new signature. It’s time to turn our attention to the implementation
    of this new method:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，测试将开始编译，但我们还没有完全实现新签名的代码。现在是时候将注意力转向新方法的实现了：
- en: '[PRE7]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The code is adjusted to read the ID of the `b *Book` parameter, and the database
    populates its results to the same passed-in parameter. Then, we return an error
    or `nil` according to whether the item is found or not.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 代码被调整为读取`b *Book`参数的ID，数据库将结果填充到相同的传入参数中。然后，我们根据项目是否找到返回错误或`nil`。
- en: 'Any other calling code will need to be adjusted in the same way as we have
    adjusted our test code. The compiler will let you know if you have missed any
    code that needs to be refactored. For example, if we add a second parameter to
    the `Get` method of `BookRepository` and forget to change it in its test, the
    compiler will let us know that the expected method signature is not defined when
    the test is run:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 任何其他调用代码都需要像我们调整测试代码一样进行调整。编译器会通知你是否有任何需要重构的代码遗漏了。例如，如果我们向`BookRepository`的`Get`方法添加一个参数，却忘记在测试中更改它，编译器会在测试运行时通知我们预期的方法签名未定义：
- en: '[PRE8]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Remember, your test code is the first external consumer of your package’s API,
    so any changes to the implementation code will affect your tests first. Note that
    this non-compiling state of the code has not been committed on our repository,
    so your test output will not match the preceding snippet.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你的测试代码是包API的第一个外部消费者，因此实现代码的任何更改都会首先影响你的测试。请注意，这种无法编译的状态的代码尚未提交到我们的仓库，因此你的测试输出将不会与前面的片段匹配。
- en: Error verification
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误验证
- en: In [*Chapter 4*](B18371_04.xhtml#_idTextAnchor085), *Building Efficient Test
    Suites*, we briefly discussed Go’s approach of explicit error handling. We learned
    that errors are typically returned last in a list of multiple return values. So
    far, we have been using Go’s inbuilt `error` type and representative error messages
    to indicate to the user when something has gone wrong. Let us now take a closer
    look at how error verification works in Go.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B18371_04.xhtml#_idTextAnchor085) *构建高效的测试套件*中，我们简要讨论了Go的显式错误处理方法。我们了解到，错误通常在多个返回值列表中最后返回。到目前为止，我们一直在使用Go的内置`error`类型和代表性错误信息来向用户指示出错了。现在让我们更详细地看看Go中错误验证是如何工作的。
- en: 'We have created errors in two ways so far. The simplest way is using the `errors.New`
    function. It creates an error with a given message:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经以两种方式创建了错误。最简单的方法是使用`errors.New`函数。它创建了一个带有给定消息的错误：
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This function takes in an error message as a parameter and returns the `error`
    interface type. In order to get our error message back, we invoke the `Error`
    method on the function:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个错误信息作为参数，并返回`error`接口类型。为了获取我们的错误信息，我们在函数上调用`Error`方法：
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This method returns the message as a string type.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法返回一个字符串类型的消息。
- en: 'Writing a test to compare the incoming and outgoing error messages is trivial
    for this example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，编写一个比较输入和输出错误信息的测试非常简单：
- en: '[PRE11]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As we have full control of the entire error message, we can easily assert that
    the values are equal. However, what if the error message construction is part
    of the function? It is common practice in Go to construct representative error
    messages that include inputs and other call parameters. These kinds of errors
    are typically constructed using the `fmt.Errorf` function:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们完全控制整个错误信息，我们可以轻松断言值是相等的。然而，如果错误信息构建是函数的一部分怎么办？在Go中构建包含输入和其他调用参数的代表性错误信息是一种常见做法。这类错误通常使用`fmt.Errorf`函数构建：
- en: '[PRE12]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `fmt.Errorf` function formats the error the same as the rest of the formatting
    functions in the `fmt` package, but returns an `error` type with a well-formatted
    message. Asserting on this error message is slightly more complicated.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt.Errorf`函数以与`fmt`包中其他格式化函数相同的方式格式化错误，但返回一个格式良好的消息的`error`类型。对这个错误消息进行断言稍微复杂一些。'
- en: 'The first option is to reconstruct the error message in the test code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种选择是在测试代码中重建错误信息：
- en: '[PRE13]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The test code makes use of the `fmt.Sprintf` function to format the expected
    error message using the same format from the call to the `fmt.Errorf` function
    in the `checkOdd` implementation function.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码使用了`fmt.Sprintf`函数，使用与`checkOdd`实现函数中调用`fmt.Errorf`函数相同的格式来格式化预期的错误信息。
- en: 'This first option has three disadvantages:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种第一种选择有三个缺点：
- en: The test code has to repeat the implementation code simply for the purposes
    of verification. This can get complex if the error message requires significant
    setup.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试代码必须重复实现代码，仅仅是为了验证的目的。如果错误信息需要大量的设置，这可能会变得复杂。
- en: The test code is now tightly coupled to the implementation code. Changing the
    error formatting logic in the implementation code now requires the same change
    in the test code.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试代码现在与实现代码紧密耦合。现在，在实现代码中更改错误格式化逻辑需要相同的更改在测试代码中。
- en: There is no way to ensure that the formatting is replicated in the exact same
    way across test scenarios. This is likely to be a problem in large code bases
    that are maintained by large engineering teams.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有办法确保格式化在测试场景中完全相同地复制。这可能在由大型工程团队维护的大型代码库中成为一个问题。
- en: 'The second option is to relax our error verification so that we no longer need
    to completely recreate the error message:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是放宽我们的错误验证，这样我们就不需要完全重新创建错误信息：
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `assert.Contains` function is used to verify that the error message contains
    some substrings, which we can be relatively sure will not change in the implementation
    code. This option has removed the need for full implementation of the error message
    formatting, simplifying our test code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`assert.Contains`函数来验证错误信息包含一些子字符串，我们可以相对有把握地说这些子字符串在实现代码中不会改变。这个选项已经消除了对错误信息格式化完整实现的必要性，简化了我们的测试代码。
- en: 'However, this second option also has quite a few disadvantages:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个第二种选择也有不少缺点：
- en: The error message assertion is not fully verified. For example, the implementation
    could be producing completely nonsense messages and our test will pass as long
    as the strings verified are contained within it. The test would no longer be able
    to assert on the full functionality of the implementation code. Other types of
    testing, such as integration or end-to-end tests, may verify this. However, we
    will explore how to include error assertions in unit tests.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误消息断言并未得到完全验证。例如，实现可能会产生完全无意义的消息，只要验证的字符串包含在其中，测试就会通过。测试将无法再对实现代码的完整功能进行断言。其他类型的测试，如集成测试或端到端测试，可能会验证这一点。然而，我们将探讨如何在单元测试中包含错误断言。
- en: Even though it has been reduced, the test code still has some leaked implementation
    knowledge and a hardcoded part of the error message. Therefore, the test is still
    brittle and tightly coupled to its implementation counterpart.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管已经减少，测试代码仍然有一些泄露的实现知识和错误消息的硬编码部分。因此，测试仍然脆弱，并且与其实现对应物紧密耦合。
- en: There is still no way to ensure that the assertions are performed in the same
    way across tests. In fact, because the expected string is no longer constructed
    during the Arrange part of the test, it can be even more difficult to find the
    hardcoded strings until the test suite points out the failures.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仍然没有方法可以确保在测试中执行断言的方式是一致的。事实上，因为预期的字符串不再在测试的安排部分构建，所以在测试套件指出失败之前，甚至可能更难找到硬编码的字符串。
- en: 'As discussed, both of our two immediate options have significant disadvantages.
    However, as we remember from [*Chapter 4*](B18371_04.xhtml#_idTextAnchor085),
    *Building Efficient Test Suites*, the `error` type is a simple interface with
    only a single method:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所讨论的，我们两个直接的选择都有显著的缺点。然而，正如我们从[*第4章*](B18371_04.xhtml#_idTextAnchor085)中回忆起来的，*构建高效的测试套件*，`error`类型是一个简单的接口，只有一个方法：
- en: '[PRE15]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can easily implement our own custom error types by implementing this simple
    function. As we have seen on multiple occasions, the power of interfaces shines
    in many aspects of the Go programming language, and error handling is one of them
    as well.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地通过实现这个简单的函数来创建我们自己的自定义错误类型。正如我们在多个场合所看到的，接口的力量在Go编程语言的许多方面都得到了体现，错误处理也是其中之一。
- en: Custom error types
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义错误类型
- en: The third option for error handling is to create our own custom error types,
    which will allow us to add more information to the error type than simply formatting
    a string multiple times. This will give us flexibility in both implementation
    and test code.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理的第三种选择是创建我们自己的自定义错误类型，这将使我们能够向错误类型添加比简单地多次格式化字符串更多的信息。这将使我们能够在实现和测试代码中都具有灵活性。
- en: 'First, we will define a simple `evenNumberError` type:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个简单的`evenNumberError`类型：
- en: '[PRE16]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This type has a field for the input of our `checkOdd` function. This will allow
    the test to have access to the input value without having to check the returned
    error message, which was necessary for the first and second options presented
    previously.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类型有一个字段用于`checkOdd`函数的输入。这将允许测试访问输入值，而无需检查返回的错误消息，这在之前提出的第一个和第二个选项中是必要的。
- en: 'Next, we need to add a method to this new type to ensure that it satisfies
    the `error` interface:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要向这个新类型添加一个方法以确保它满足`error`接口：
- en: '[PRE17]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This method has `evenNumberError` as a receiver and the same signature as the
    `error` interface. Inside the method, we use the same format and the `fmt.Sprintf`
    function, together with the `input` field of the receiver.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法以`evenNumberError`作为接收者，与`error`接口具有相同的签名。在方法内部，我们使用相同的格式和`fmt.Sprintf`函数，以及接收者的`input`字段。
- en: 'The implementation function can be changed to use this new `error` type:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 实现函数可以被修改为使用这个新的`error`类型：
- en: '[PRE18]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With the error formatting wrapped inside the `evenNumberError` type, the `return`
    statement of this function simply consists of creating a new instance of this
    type and returning a pointer to it. We pass the parameter from the `checkOdd`
    function to its initialization.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在`evenNumberError`类型内部包装错误格式化后，这个函数的`return`语句简单地由创建这个类型的新实例并返回它的指针组成。我们将从`checkOdd`函数传递参数到其初始化中。
- en: Always return the error interface
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 总是返回错误接口
- en: One last thing to note is that the `checkOdd` function still returns the `error`
    interface. Therefore, the calling code does not need to have any knowledge of
    the custom error types created in this package. When working with custom error
    types, you should always follow this pattern as well.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的一点是，`checkOdd`函数仍然返回`error`接口。因此，调用代码不需要了解在此包中创建的任何自定义错误类型。在处理自定义错误类型时，你也应该始终遵循这个模式。
- en: 'The test code is much simplified with this new custom `error` type in place:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种新的自定义`error`类型，测试代码变得更加简化：
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The implementation of the error verification in this example demonstrates how
    to run verifications on custom `error` types:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中错误验证的实现展示了如何在自定义`error`类型上运行验证：
- en: We create an instance of the `evenNumberError` type with the `input` field.
    This is much simpler than having to create an expected error message.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`input`字段创建`evenNumberError`类型的实例。这比创建预期的错误消息要简单得多。
- en: After calling the `checkOdd` function, we need to convert the built-in `error`
    value to the custom `error` type. This is done by using the `errors.As` function,
    which returns `true` if the conversion has been successful.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用`checkOdd`函数之后，我们需要将内置的`error`值转换为自定义`error`类型。这是通过使用`errors.As`函数完成的，如果转换成功，它将返回`true`。
- en: We use the `require.True` function to ensure that the test fails if the conversion
    fails.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`require.True`函数来确保如果转换失败，测试将失败。
- en: Finally, we use the `assert.Equal` function to ensure that the actual error
    is as expected.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`assert.Equal`函数来确保实际错误与预期相符。
- en: The implementation of the test is much simpler, and it is no longer tightly
    coupled to error formatting inside the function under test. This approach does
    have a slight disadvantage in that it creates a new custom type, but working with
    custom `error` types streamlines the implementation code by providing a single,
    unified, way to format errors.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的实现变得更加简单，并且不再紧密耦合到被测试函数内部的错误格式化。这种方法确实有一个小小的缺点，就是它创建了一个新的自定义类型，但通过提供一种单一、统一的方式来格式化错误，与自定义`error`类型一起工作简化了实现代码。
- en: 'We run the test as usual to see our error verification in action:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像往常一样运行测试，以查看错误验证的实际效果：
- en: '[PRE20]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Each test case runs in its subtest, as can be seen from the organized output.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试用例都在其子测试中运行，正如有组织的输出所示。
- en: Another advantage of using custom `error` types is that they allow a function
    to return multiple types of errors, which can provide context to callers of a
    given package or service. For now, we should remember that they have the advantage
    of streamlining our test code while providing precise error verification possibilities.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义`error`类型的另一个优点是，它们允许函数返回多种类型的错误，这可以为给定包或服务的调用者提供上下文。目前，我们应该记住，它们的优势在于简化我们的测试代码，同时提供精确的错误验证可能性。
- en: Splitting up the monolith
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆分单体
- en: The final aspect of refactoring that we will discuss is moving from a monolith
    to a microservice architecture. While there are examples of large companies that
    successfully operate using a monolithic architecture, the consensus in the technical
    community is that a microservice architecture is easier to scale and maintain,
    particularly when working across multiple teams. It is therefore important to
    discuss some of the basics of how and when to split up a service during refactoring.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的最后一个重构方面是从单体架构迁移到微服务架构。虽然有一些大公司成功地使用单体架构运营，但在技术社区中，普遍认为微服务架构更容易扩展和维护，尤其是在跨多个团队工作时。因此，讨论一些关于如何在重构期间拆分服务的基本原则是很重要的。
- en: What is a monolithic application?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是单体应用？
- en: A **monolithic application** is a single application that is built and released
    in one unit. The term is typically used to refer to a large application, with
    many different responsibilities that serve many different user journeys.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**单体应用**是一个单一的应用程序，它作为一个单元构建和发布。这个术语通常用来指代一个大型应用程序，它具有许多不同的职责，服务于许多不同的用户旅程。'
- en: '*Figure 7**.5* depicts some of the advantages and disadvantages of monolithic
    applications:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.5* 展示了单体应用的某些优点和缺点：'
- en: '![Figure 7.5 – Pros and cons of monolithic applications ](img/Figure_7.05_B18371.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5 – 单体应用的优缺点](img/Figure_7.05_B18371.jpg)'
- en: Figure 7.5 – Pros and cons of monolithic applications
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 单体应用的优缺点
- en: 'The list of pros and cons of monolithic applications spans from deployment
    to resilience:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用的优缺点列表涵盖了从部署到弹性的各个方面：
- en: As monoliths are built and deployed in one running application, developers will
    find them **easy to deploy**. However, as all the components are deployed together,
    they also cannot be scaled individually, making the application **harder to scale**.
    This can be a significant bottleneck to how many requests the application can
    handle, affecting a business’s revenue. Scaling the monolith as a whole can also
    be unduly expensive, as all resources are scaled together.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于单体是在一个运行的应用程序中构建和部署的，开发者会发现它们**易于部署**。然而，由于所有组件都一起部署，它们也不能单独扩展，这使得应用程序**更难扩展**。这可能会成为应用程序处理请求数量的瓶颈，影响企业的收入。将整个单体进行扩展也可能是不必要的昂贵，因为所有资源都一起扩展。
- en: Monolithic applications have a lower cognitive burden because all of their code
    lives in one single, searchable code base. At the beginning of the project, developers
    have an easier time developing in one single code base. However, as the project
    progresses and the team grows, the code base becomes constrained by its initial
    architecture, design, and technology choices. Often, this leads to **slower**
    **development speed**.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单体应用由于所有代码都生活在单一可搜索的代码库中，因此认知负担较低。在项目初期，开发者在一个单一的代码库中开发更为容易。然而，随着项目的推进和团队的扩大，代码库会受到其初始架构、设计和技术选择的限制。通常，这会导致**更慢**的开发速度。
- en: As they only have to start up one application, engineers find monolithic applications
    **simple to test and debug**. However, as all modules are hosted together, **errors
    can cause full outages** of the application. This can again significantly affect
    a business’s revenue.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于他们只需要启动一个应用程序，工程师发现单体应用**简单易测试和调试**。然而，由于所有模块都一起托管，**错误可能导致应用程序完全中断**。这可能会再次显著影响企业的收入。
- en: Many organizations start out with a monolithic application when they have a
    small code base and engineering team. Then, as their team and application functionality
    grow, they struggle to scale and maintain their monoliths. A new approach to building
    applications was required to mitigate the disadvantages that come with developing
    code in a monolith.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 许多组织在拥有小型代码库和工程团队时开始使用单体应用。随着团队和应用程序功能的发展，他们发现难以扩展和维护单体。需要一种新的方法来构建应用程序，以减轻在单体中开发代码带来的不利影响。
- en: What is a microservice architecture?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是微服务架构？
- en: A **microservice architecture** is a system design method that relies on independently
    built and released services, known as **microservices**. These independent units
    have their own responsibilities and self-contained resources for accomplishing
    their goals.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**微服务架构**是一种系统设计方法，它依赖于独立构建和发布的称为**微服务**的服务。这些独立的单元有自己的责任和自包含的资源，以实现其目标。'
- en: '*Figure 7**.6* depicts some of the advantages and disadvantages of microservice
    architectures:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.6*展示了微服务架构的一些优缺点：'
- en: '![Figure 7.6 – Pros and cons of microservice architectures ](img/Figure_7.06_B18371.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6 – 微服务架构的优缺点](img/Figure_7.06_B18371.jpg)'
- en: Figure 7.6 – Pros and cons of microservice architectures
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 微服务架构的优缺点
- en: 'The pros of microservice architectures have addressed many of the cons of monolithic
    applications:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构的优点解决了许多单体应用的缺点：
- en: As each microservice is independently deployed, this type of architecture offers
    **flexible scaling**. This allows us to scale one part of the application, according
    to which user journeys are most popular. However, as each service has its own
    dedicated set of resources, microservice architectures can incur **higher** **infrastructure
    costs**.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于每个微服务都是独立部署的，这种架构提供了**灵活的扩展性**。这允许我们根据最受欢迎的用户旅程来扩展应用程序的一部分。然而，由于每个服务都有其专用的资源集，微服务架构可能会产生**更高的**基础设施成本。
- en: The smaller code bases of the microservices are **easier to maintain**, especially
    when it comes to refactoring. They can also make their own technical choices,
    offering engineers the opportunity to choose the best tool for the goals of each
    microservice. However, the separation between the different code bases does require
    **higher organizational overhead** in order to ensure that the individual units
    function together correctly and follow a unified set of engineering standards.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的较小代码库**更容易维护**，尤其是在重构方面。它们还可以做出自己的技术选择，为工程师提供选择每个微服务目标最佳工具的机会。然而，不同代码库之间的分离确实需要**更高的组织开销**，以确保各个单元能够正确协同工作并遵循统一的一套工程标准。
- en: As each microservice has its own well-defined functionality and responsibilities,
    they require a **smaller scope of tests** to ensure that they are working correctly.
    However, the integration points become the focal point of tests, making integration
    tests more important than ever. When a systemic error happens, each service also
    has its own set of logs, making this type of architecture **more difficult** **to
    debug**.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于每个微服务都有其自身明确的功能和责任，它们需要**更小的测试范围**来确保它们正确运行。然而，集成点成为测试的焦点，使得集成测试比以往任何时候都更加重要。当出现系统错误时，每个服务也有自己的日志集，这使得这种类型的架构**更难调试**。
- en: '*Figure 7**.7* depicts the two system types:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.7*展示了两种系统类型：'
- en: '![Figure 7.7 – Monolithic application versus microservice architecture ](img/Figure_7.07_B18371.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7 – 单体应用与微服务架构对比](img/Figure_7.07_B18371.jpg)'
- en: Figure 7.7 – Monolithic application versus microservice architecture
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – 单体应用与微服务架构对比
- en: The monolithic application contains all of the components required in one single
    unit and relies on one database. The microservice architecture splits the monolithic
    application according to the functionality that they provide and these functionalities
    depend on each other to deliver the same user journeys as the monolithic application.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用包含所有在一个单一单元中所需的组件，并依赖于一个数据库。微服务架构根据它们提供的功能来拆分单体应用，并且这些功能相互依赖，以提供与单体应用相同的用户旅程。
- en: As we have seen, neither development approach is perfect. A monolithic application
    may work perfectly well when application traffic is predictable or the team has
    strict architecture design guidelines, but most organizations grow their teams
    and evolve their products. In these circumstances, organizations will usually
    opt for a microservice architecture. Therefore, it is absolutely essential for
    engineers to know how to develop and test microservice architectures.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这两种开发方法都不是完美的。当应用流量可预测或团队有严格的架构设计指南时，单体应用可能运行得很好，但大多数组织都会扩大团队规模并演进他们的产品。在这些情况下，组织通常会选择微服务架构。因此，工程师了解如何开发和测试微服务架构是绝对必要的。
- en: Key refactoring considerations
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键重构考虑因素
- en: Many organizations have undertaken the work to split up their monolithic applications
    into microservice architectures. The engineering community has discussed how to
    undertake this journey as painlessly and successfully as possible. We can highlight
    some key considerations for this type of refactoring.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 许多组织已经着手将他们的单体应用拆分为微服务架构。工程界已经讨论了如何尽可能无痛且成功地完成这一旅程。我们可以强调一些此类重构的关键考虑因素。
- en: Define boundaries
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义边界
- en: In order to be successful, microservices need to have their own domain and have
    well-defined application boundaries. Engineering teams can identify which parts
    of the monolith they should extract, either through analysis or generated dependency
    graphs.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功，微服务需要有它们自己的领域和明确的应用边界。工程团队能够确定他们应该从单体中提取哪些部分，无论是通过分析还是生成的依赖图。
- en: 'Based on these, they can scope the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，他们可以确定以下内容：
- en: The **functionality and models of the domain** that the microservice will be
    responsible for. For example, in an e-commerce application, we might identify
    a service that is responsible for placing and managing items in the shopping cart.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务将负责的**领域功能性和模型**。例如，在一个电子商务应用中，我们可能会识别出一个负责在购物车中放置和管理商品的服务。
- en: The **upstream dependencies** that the microservice will require. For example,
    the previously identified shopping cart service will have a dependency on the
    inventory service, which will tell it how much items cost and whether they are
    in stock.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务将需要的**上游依赖**。例如，之前确定的购物车服务将依赖于库存服务，该服务会告诉它商品的成本以及它们是否有库存。
- en: The **downstream dependencies** and data storage solution that the microservice
    will require. For example, the shopping cart service will save its data to an
    in-memory data structure store, such as Redis, and have a downstream dependency
    to a checkout service once the user decides to purchase their cart.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务将需要的**下游依赖**和数据存储解决方案。例如，购物车服务将把其数据保存到内存数据结构存储中，如Redis，并在用户决定购买购物车中的商品后，有一个下游依赖到结账服务。
- en: The result of the boundary identification exercise could be a high-level design
    of the infrastructure requirements of the microservice, as well as an overview
    of the API that the microservice will expose to other parts of the system.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 边界识别练习的结果可能是微服务基础设施需求的高级设计，以及微服务将向系统其他部分公开的API概述。
- en: Loose coupling
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 松散耦合
- en: One of the advantages of a microservice architecture is that it allows us to
    build services that are **loosely coupled**, from both a development and deployment
    perspective. However, this advantage can be easily lost if the teams don’t isolate
    inter-service dependencies.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构的一个优点是它允许我们从开发和部署的角度构建松散耦合的服务。然而，如果团队没有隔离服务间的依赖关系，这种优势很容易就会丧失。
- en: What is a loose coupling for microservices?
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的松散耦合是什么意思？
- en: In microservice architectures, services are loosely coupled if changes to one
    service’s design or implementation will not cause changes in other services that
    it depends on or that depend on it.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，如果对某个服务的设计或实现进行更改不会导致其依赖的其他服务或依赖其服务的其他服务发生变化，则这些服务是松散耦合的。
- en: 'Loosely coupled microservices should follow the following rules of thumb:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 松散耦合的微服务应遵循以下经验法则：
- en: '**Have separate data stores**: When microservices share a single database,
    they also share a **single point of failure**. An outage on the shared database
    will cause all of the services that depend on it to fail as well.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拥有独立的数据存储**：当微服务共享单个数据库时，它们也共享一个**单点故障**。共享数据库的故障将导致所有依赖它的服务也失败。'
- en: '**Use asynchronous communication**: Use asynchronous communication patterns
    such as queues and event buses to pass data to other services. This allows us
    to scale services independently and even batch messages when appropriate.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用异步通信**：使用异步通信模式，如队列和事件总线，将数据传递给其他服务。这允许我们独立扩展服务，并在适当的情况下批量处理消息。'
- en: '**Implement fault tolerance**: Design your service with the assumption that
    its internal and external dependencies will fail or be slow to respond. A common
    way this is implemented in REST APIs is with the circuit breaker pattern, which
    will time out external calls when patterns of failure are detected in order to
    ensure that your microservice can continue to function, using default values if
    one of its dependencies is no longer available.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现容错性**：在设计服务时，假设其内部和外部依赖项可能会失败或响应缓慢。在REST API中，这通常是通过断路器模式实现的，当检测到故障模式时，它会超时外部调用，以确保您的微服务可以继续运行，如果其依赖项之一不再可用，则使用默认值。'
- en: '**Make backward-compatible changes**: Whenever possible, microservice APIs
    should make backward-compatible changes that will not force other services to
    implement changes to their payloads at the same time.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现向后兼容的更改**：在可能的情况下，微服务API应进行向后兼容的更改，这样不会强迫其他服务同时对其有效载荷进行更改。'
- en: '**Implement request tracing and service monitoring**: In the microservice world,
    it is important to understand how requests flow through your system. This is important
    for detecting errors in your system and identifying services with insufficient
    infrastructure resources.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现请求跟踪和服务监控**：在微服务世界中，了解请求如何流经您的系统非常重要。这对于检测系统中的错误和识别基础设施资源不足的服务至关重要。'
- en: Following these rules during microservice design and implementation will help
    you take advantage of the true power of microservices. In [*Chapter 8*](B18371_08.xhtml#_idTextAnchor179),
    *Testing Microservice Architectures*, we will discuss these principles further
    and discuss the challenges of testing microservices and how we need to adjust
    our testing strategy to fit the microservice world.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务设计和实现过程中遵循这些规则将帮助您充分利用微服务的真正力量。在[*第8章*](B18371_08.xhtml#_idTextAnchor179)《测试微服务架构》中，我们将进一步讨论这些原则，并讨论测试微服务的挑战以及我们需要如何调整我们的测试策略以适应微服务世界。
- en: How will the microservice behave without its dependencies?
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务在没有其依赖项的情况下会如何表现？
- en: Once we have identified the dependencies of a microservice, we should remember
    to design and test for the behavior of the microservice in the case that its dependencies
    encounter an outage. This important part of microservice design, known as **graceful
    degradation**, should not be overlooked.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了微服务的依赖项，我们应该记住设计并测试在依赖项遇到故障的情况下微服务的表现。这个被称为**优雅降级**的微服务设计的重要部分不应被忽视。
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we tackled the important topic of code refactoring, which is
    a crucial and unavoidable part of extending and maintaining healthy code bases.
    We started by learning some common code refactoring techniques and discussed the
    true cost of technical debt. Then, we revisited the power of interfaces, which
    make it easy to change dependencies and allow us to use the compiler as a guide
    during refactoring.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了代码重构这一重要主题，它是扩展和维护健康代码库的关键和不可避免的部分。我们首先学习了一些常见的代码重构技术，并讨论了技术债务的真实成本。然后，我们回顾了接口的力量，它使得改变依赖变得容易，并在重构期间允许我们使用编译器作为指南。
- en: 'Then, we considered the test changes that we have to make to our tests to ensure
    that they continue to verify behaviors during two common refactorings: renaming
    structs and changing method signatures. Expanding upon our previous knowledge
    of error handling and verification, we learned how to create custom error types
    and more easily verify error messages.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们考虑了为了确保测试在两种常见的重构操作（重命名结构体和更改方法签名）期间继续验证行为，我们必须对测试进行的测试更改。在扩展我们之前关于错误处理和验证的知识的基础上，我们学习了如何创建自定义错误类型，并更容易地验证错误消息。
- en: Finally, we learned some of the reasons why organizations move from monolithic
    applications to microservice architectures, and explored some rules of thumb that
    allow us to create loosely coupled microservices.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们了解了一些组织从单体应用程序迁移到微服务架构的原因，并探讨了允许我们创建松散耦合微服务的经验法则。
- en: In [*Chapter 8*](B18371_08.xhtml#_idTextAnchor179), *Testing Microservice Architectures*,
    we will expand on all the concepts we have learned so far and learn what considerations
    should be made when testing microservice architectures. We will apply and demonstrate
    these concepts on our demo application, the `BookSwap` application.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](B18371_08.xhtml#_idTextAnchor179) *测试微服务架构*中，我们将扩展到目前为止所学的所有概念，并学习在测试微服务架构时应考虑哪些因素。我们将在我们的演示应用程序`BookSwap`上应用并展示这些概念。
- en: Questions
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between code redesign and code refactoring?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码重构和代码重设计有什么区别？
- en: Describe the working process of code refactoring.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述代码重构的工作流程。
- en: What is technical debt?
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 技术债务是什么？
- en: What is a monolithic application? What is a microservice architecture?
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单体应用程序是什么？微服务架构是什么？
- en: Further reading
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Clean Architecture: A Craftsman’s Guide to Software Structure and Design*,
    Robert C. Martin, published by Addison-Wesley'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*整洁架构：软件结构和设计的工匠指南*，罗伯特·C·马丁著，由Addison-Wesley出版'
- en: '*Refactoring: Improving the Design of Existing Code*, Martin Fowler, published
    by Addison-Wesley Professional'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重构：现有代码的设计改进*，马丁·福勒著，由Addison-Wesley Professional出版'
- en: '*Building Microservices Second Edition: Designing Fine-Grained Systems*, Sam
    Newman, published by O’Reilly'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构建微服务第二版：设计细粒度系统*，山姆·纽曼著，由O’Reilly出版'
- en: '*Monolith to Microservices: Evolutionary Patterns to Transform Your Monolith*,
    Sam Newman, published by O’Reilly'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从单体到微服务：转型单体应用的演进模式*，山姆·纽曼著，由O’Reilly出版'
