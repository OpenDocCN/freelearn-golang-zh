<html><head></head><body>
<div id="_idContainer077">
<h1 class="chapter-number" id="_idParaDest-158"><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-159"><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.2.1">Testing Microservice Architectures</span></h1>
<p><span class="koboSpan" id="kobo.3.1">The topics we have covered so far have gone beyond the scope of how to write tests. </span><span class="koboSpan" id="kobo.3.2">We have looked at a wide range of software design and development concerns, including containerization with Docker and database integration with PostgreSQL. </span><span class="koboSpan" id="kobo.3.3">This highlights the fact that writing good tests requires a thorough understanding of the architecture and technical dependencies of the application </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">under test.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Alongside these software development concepts, we discussed the evolution of code in </span><a href="B18371_07.xhtml#_idTextAnchor162"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Refactoring in Go</span></em><span class="koboSpan" id="kobo.9.1">. </span><span class="koboSpan" id="kobo.9.2">We learned some common refactoring techniques, and we compared monolithic applications with microservice architectures, which is a common evolution of Go web applications as they grow and become </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">more mature.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">We will continue our exploration of microservice architectures and refactoring from the previous chapter. </span><span class="koboSpan" id="kobo.11.2">As microservices are often owned and developed by different software teams, they are often changed without any central oversight. </span><span class="koboSpan" id="kobo.11.3">In this fast-paced world of changing requirements and implementations, ensuring that the API integration points in our system are still functioning correctly is one of the biggest challenges to overcome. </span><span class="koboSpan" id="kobo.11.4">Another key concern to consider is error detection in the system – when something goes wrong, how do you isolate the malfunctioning service in a large map </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">of dependencies?</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">This chapter is dedicated to discussing the testing of microservice architectures, demonstrated on the monolithic </span><strong class="source-inline"><span class="koboSpan" id="kobo.14.1">BookSwap</span></strong><span class="koboSpan" id="kobo.15.1"> web application introduced in previous chapters. </span><span class="koboSpan" id="kobo.15.2">We will have a closer look at the implementation of non-functional tests, which was briefly discussed in previous chapters. </span><span class="koboSpan" id="kobo.15.3">Then, we will learn the new concepts of contract testing and how we can leverage Pact for the implementation of contracts on microservice architectures. </span><span class="koboSpan" id="kobo.15.4">Finally, we will discuss how we can split up the monolithic </span><strong class="source-inline"><span class="koboSpan" id="kobo.16.1">BookSwap</span></strong><span class="koboSpan" id="kobo.17.1"> web application that we have built so far. </span><span class="koboSpan" id="kobo.17.2">Using the concepts and challenges we will have learned, we will discuss some best practices for running microservices </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">in production.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.21.1">The implementation of non-functional testing </span></li>
<li><span class="koboSpan" id="kobo.22.1">Challenges of testing </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">microservice architectures</span></span></li>
<li><span class="koboSpan" id="kobo.24.1">Getting started with contract testing </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">with Pact</span></span></li>
<li><span class="koboSpan" id="kobo.26.1">Splitting up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.27.1">BookSwap</span></strong><span class="koboSpan" id="kobo.28.1"> monolith we have built so far </span></li>
<li><span class="koboSpan" id="kobo.29.1">Best practices for running microservice architectures </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">in production</span></span></li>
</ul>
<h1 id="_idParaDest-160"><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.31.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.32.1">You will need to have </span><strong class="bold"><span class="koboSpan" id="kobo.33.1">Go version 1.19</span></strong><span class="koboSpan" id="kobo.34.1"> or later installed to run the code samples in this chapter. </span><span class="koboSpan" id="kobo.34.2">The installation process is described in the official Go documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">at </span></span><a href="https://go.dev/doc/install"><span class="No-Break"><span class="koboSpan" id="kobo.36.1">https://go.dev/doc/install</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.37.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">The code examples included in this book are publicly available </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">at </span></span><a href="https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter08"><span class="No-Break"><span class="koboSpan" id="kobo.40.1">https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter08</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.41.1">.</span></span></p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.42.1">Functional and non-functional testing</span></h1>
<p><span class="koboSpan" id="kobo.43.1">We briefly touched </span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.44.1">upon the topic of non-functional testing in </span><a href="B18371_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.45.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.46.1">, </span><em class="italic"><span class="koboSpan" id="kobo.47.1">Getting to Grips with Test-Driven Development</span></em><span class="koboSpan" id="kobo.48.1">. </span><span class="koboSpan" id="kobo.48.2">Up until now, we have tabled this important type of testing </span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.49.1">and focused on verifying the various functional aspects, while exploring the popular testing libraries of </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">testify</span></strong><span class="koboSpan" id="kobo.51.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">ginkgo</span></strong><span class="koboSpan" id="kobo.53.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">GoDog</span></strong><span class="koboSpan" id="kobo.55.1">. </span><span class="koboSpan" id="kobo.55.2">Let’s now explore how to implement a few of the most important </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">non-functional tests.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.57.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.58.1">.1</span></em><span class="koboSpan" id="kobo.59.1"> depicts the </span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.60.1">main types of </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">non-functional tests:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer068">
<span class="koboSpan" id="kobo.62.1"><img alt="Figure 8.1 – Types of performance and correctness non-functional testing " src="image/Figure_8.01_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.63.1">Figure 8.1 – Types of performance and correctness non-functional testing</span></p>
<p><span class="koboSpan" id="kobo.64.1">The types of tests </span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.65.1">are divided between </span><strong class="bold"><span class="koboSpan" id="kobo.66.1">performance tests</span></strong><span class="koboSpan" id="kobo.67.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.68.1">usability tests</span></strong><span class="koboSpan" id="kobo.69.1">. </span><span class="koboSpan" id="kobo.69.2">They </span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.70.1">verify the </span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.71.1">following aspects </span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.72.1">of </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">our systems:</span></span></p>
<ol>
<li value="1"><strong class="bold"><span class="koboSpan" id="kobo.74.1">Load testing</span></strong><span class="koboSpan" id="kobo.75.1"> simulates </span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.76.1">user demand on our system. </span><span class="koboSpan" id="kobo.76.2">These tests </span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.77.1">simulate expected demand and overload conditions to identify bottlenecks or </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">performance issues.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.79.1">Stress testing</span></strong><span class="koboSpan" id="kobo.80.1"> simulates </span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.81.1">user demand under extreme conditions on </span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.82.1">our system. </span><span class="koboSpan" id="kobo.82.2">These tests are used to identify the scalability limit of our system and verify that it handles errors gracefully when components </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">become overloaded.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.84.1">Volume testing</span></strong><span class="koboSpan" id="kobo.85.1"> simulates </span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.86.1">large volumes of data coming into our system. </span><span class="koboSpan" id="kobo.86.2">This is </span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.87.1">similar to stress testing but with a few tests, each involving relatively large amounts of data, instead of many tests involving smaller amounts of data simulating user demand. </span><span class="koboSpan" id="kobo.87.2">These tests are used to identify the data limits that our system can process, which is particularly useful for services with a database/persistent </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">storage solution.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.89.1">Scalability testing</span></strong><span class="koboSpan" id="kobo.90.1"> verifies our system’s ability to scale its components when subjected </span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.91.1">to sudden load. </span><span class="koboSpan" id="kobo.91.2">The load can be applied gradually, or </span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.92.1">it can be applied suddenly, which </span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.93.1">is known as a </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.94.1">spike test</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.96.1">Failover testing</span></strong><span class="koboSpan" id="kobo.97.1"> verifies our system’s ability to recover after a failure. </span><span class="koboSpan" id="kobo.97.2">This type of negative </span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.98.1">testing is a useful simulation for how quickly the </span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.99.1">system can recover </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">following incidents.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.101.1">Configuration testing</span></strong><span class="koboSpan" id="kobo.102.1"> verifies our system’s behavior with different types of settings. </span><span class="koboSpan" id="kobo.102.2">They </span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.103.1">can be user-controlled settings or system settings. </span><span class="koboSpan" id="kobo.103.2">The </span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.104.1">system setup can change the expected behavior of the system, as well as </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">its performance.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.106.1">Usability testing</span></strong><span class="koboSpan" id="kobo.107.1"> verifies </span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.108.1">how intuitive the user-facing functionality is to use. </span><span class="koboSpan" id="kobo.108.2">The focus of this type of testing varies according to the functionality that the system exposes, but it typically covers </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">the following:</span></span><ol><li><span class="koboSpan" id="kobo.110.1">How intuitive the system is to use for </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">new users</span></span></li><li><span class="koboSpan" id="kobo.112.1">How easily users can perform </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">their tasks</span></span></li><li><span class="koboSpan" id="kobo.114.1">Whether error messages are well formulated and guide </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">the user</span></span></li></ol></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.116.1">Security testing</span></strong><span class="koboSpan" id="kobo.117.1"> verifies </span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.118.1">whether security practices have been followed </span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.119.1">during the development process. </span><span class="koboSpan" id="kobo.119.2">The system under test should have correct authentication, authorization, and data </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">integrity features.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.121.1">As we have seen, non-functional tests are extremely important for ensuring that our systems are functioning </span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.122.1">correctly under a wide variety of conditions. </span><span class="koboSpan" id="kobo.122.2">No testing strategy is complete without covering some of these important types of tests. </span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.123.1">Non-functional tests verify crucial aspects of our system</span></p>
<p class="callout"><span class="koboSpan" id="kobo.124.1">These tests verify the performance and usability of the system under test, including how well the system scales and recovers from outages. </span><span class="koboSpan" id="kobo.124.2">These types of tests might be performed by different development teams, as they might require skills from outside the engineering team to </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">implement them.</span></span></p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.126.1">Performance testing in Go</span></h2>
<p><span class="koboSpan" id="kobo.127.1">While we have </span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.128.1">already established that non-functional testing </span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.129.1">covers important aspects, performance testing becomes even more important when moving from monolithic applications to microservice architectures. </span><span class="koboSpan" id="kobo.129.2">In the microservice world, the user journey varies and is processed by independent system components, which can lead to a less cohesive view of </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">system behavior.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.131.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.132.1">.2</span></em><span class="koboSpan" id="kobo.133.1"> depicts the key questions that performance </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">testing answers:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer069">
<span class="koboSpan" id="kobo.135.1"><img alt="Figure 8.2 – Key questions that performance testing answers " src="image/Figure_8.02_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.136.1">Figure 8.2 – Key questions that performance testing answers</span></p>
<p><span class="koboSpan" id="kobo.137.1">The two important questions that performance testing answers relate to system usability and scalability. </span><span class="koboSpan" id="kobo.137.2">Let’s look at what each </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">question means.</span></span></p>
<h3><span class="koboSpan" id="kobo.139.1">Is the system usable?</span></h3>
<p><span class="koboSpan" id="kobo.140.1">Usability is more than achieving correct functionality, as a slow-functioning system will eventually impact </span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.141.1">user satisfaction negatively. </span><span class="koboSpan" id="kobo.141.2">Performance testing is useful for assessing </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.143.1">Stability</span></strong><span class="koboSpan" id="kobo.144.1">: No intermittent failures should occur, causing retries and negative user experiences. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.145.1">Speed</span></strong><span class="koboSpan" id="kobo.146.1">: User requests should be kept within acceptable levels set according to business requirements, or the system is </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">scaled appropriately.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.148.1">Error handling</span></strong><span class="koboSpan" id="kobo.149.1">: Errors should be handled gracefully, without sudden crashes, and well-formulated messages should be returned across a variety of scenarios. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.150.1">User load</span></strong><span class="koboSpan" id="kobo.151.1">: The system </span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.152.1">should be able to handle the expected user loads without causing unexpected CPU or user </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">memory spikes.</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.154.1">Is the system scalable?</span></h3>
<p><span class="koboSpan" id="kobo.155.1">Business and system requirements evolve with time. </span><span class="koboSpan" id="kobo.155.2">A scalable system should be able to grow according </span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.156.1">to the expected future needs of the business. </span><span class="koboSpan" id="kobo.156.2">Performance testing is useful for assessing </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.158.1">Bottlenecks</span></strong><span class="koboSpan" id="kobo.159.1">: Monitoring a variety of metrics allows us to identify which services in our system are not scalable, and should be refactored. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.160.1">Individual parts</span></strong><span class="koboSpan" id="kobo.161.1">: It is important </span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.162.1">to understand the expected response time for each microservice, as well as an estimate for the entire system. </span><span class="koboSpan" id="kobo.162.2">This can help us map costs for each user operation on </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">our system.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.164.1">Growth runway</span></strong><span class="koboSpan" id="kobo.165.1">: Performance testing allows us to establish how much more user and volume growth the system can sustain in its </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">current form.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.167.1">When used correctly, performance testing will ensure that each microservice is able to handle the current load of the system and that they are able to work together to serve user </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">journeys correctly.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.169.1">The “little and often” approach</span></p>
<p class="callout"><span class="koboSpan" id="kobo.170.1">Performance testing is often added as part of the code build pipelines so that development teams get </span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.171.1">immediate feedback on performance with each commit. </span><span class="koboSpan" id="kobo.171.2">Similarly to refactoring, performance improvements are best done little and often. </span><span class="koboSpan" id="kobo.171.3">Monitoring performance with each commit will make it easier to see any trends and quickly fix </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">new issues.</span></span></p>
<p><span class="koboSpan" id="kobo.173.1">Performance testing is all about quantifying and comparing the behavior of our system and its microservices. </span><span class="koboSpan" id="kobo.173.2">How do we go about achieving this quantification? </span><span class="koboSpan" id="kobo.173.3">This is commonly achieved by gathering a few </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">important metrics:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.175.1">Response time</span></strong><span class="koboSpan" id="kobo.176.1">: The time it </span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.177.1">takes between a user’s request and the response from the system to arrive back to the user. </span><span class="koboSpan" id="kobo.177.2">Often, the </span><strong class="bold"><span class="koboSpan" id="kobo.178.1">average</span></strong><span class="koboSpan" id="kobo.179.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.180.1">peak</span></strong><span class="koboSpan" id="kobo.181.1"> values of the response time are measured, giving an indication of the worst case alongside the average case. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.182.1">Error rate</span></strong><span class="koboSpan" id="kobo.183.1">: The percentage </span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.184.1">of error cases in the total number of requests processed by the system. </span><span class="koboSpan" id="kobo.184.2">In RESTful APIs, the error responses are easily identified by HTTP </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">status codes.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.186.1">CPU and memory usage</span></strong><span class="koboSpan" id="kobo.187.1">: The percentage of CPU and memory that the microservice is </span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.188.1">using on its host. </span><span class="koboSpan" id="kobo.188.2">These indicators will show whether the system is </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">correctly scaled.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.190.1">Concurrent users</span></strong><span class="koboSpan" id="kobo.191.1">: The number of users that are requesting a given resource at the same time. </span><span class="koboSpan" id="kobo.191.2">This </span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.192.1">can make it easy to identify any spikes for a particular endpoint of the user path.  </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.193.1">Data throughput</span></strong><span class="koboSpan" id="kobo.194.1">: The amount of data processed by the system. </span><span class="koboSpan" id="kobo.194.2">This can indicate whether user </span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.195.1">requests are increasing over time or whether any large files are flowing into the system and </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">affecting performance.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.197.1">The system under test should have monitoring and alerting for these metrics in place before we write any performance tests. </span><span class="koboSpan" id="kobo.197.2">Furthermore, we should establish what the failure criteria for </span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.198.1">our performance tests will be according to the needs of </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">our system.</span></span></p>
<p><span class="koboSpan" id="kobo.200.1">While you should always establish your threshold values together with key stakeholders, we can make some general recommendations based on experience and </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">industry practice:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.202.1">The average response time should generally be under 500 milliseconds, while the peak response time should be under </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">1 second</span></span></li>
<li><span class="koboSpan" id="kobo.204.1">Error rates should generally be </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">under 5%</span></span></li>
<li><span class="koboSpan" id="kobo.206.1">CPU and memory usage should generally stay under 70%, allowing the system to handle any spikes that may </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">come up</span></span></li>
<li><span class="koboSpan" id="kobo.208.1">Concurrent users and data throughput do not have any failure thresholds, but should be </span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.209.1">monitored for spikes </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">and anomalies</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.211.1">Now that we understand the importance of performance tests and how to quantify and compare their results, we can turn our attention to their implementation. </span><span class="koboSpan" id="kobo.211.2">We can implement them with Go’s standard </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">testing</span></strong><span class="koboSpan" id="kobo.213.1"> framework or with popular </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">third-party libraries.</span></span></p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.215.1">Implementing performance tests </span></h2>
<p><span class="koboSpan" id="kobo.216.1">In </span><a href="B18371_02.xhtml#_idTextAnchor035"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.217.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.218.1">, </span><em class="italic"><span class="koboSpan" id="kobo.219.1">Unit Testing Essentials</span></em><span class="koboSpan" id="kobo.220.1">, we learned how to write and execute benchmarks </span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.221.1">with Go’s standard testing library, which are special tests used to verify the performance of our code. </span><span class="koboSpan" id="kobo.221.2">We also learned how to export test coverage metrics from Go’s </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">test runner.</span></span></p>
<p><span class="koboSpan" id="kobo.223.1">We can use benchmarks to write performance tests for our endpoints. </span><span class="koboSpan" id="kobo.223.2">For example, we can easily write a benchmark for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">GET /</span></strong><span class="koboSpan" id="kobo.225.1"> root endpoint of our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">BookSwap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.227.1"> application:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.228.1">
func </span><strong class="bold"><span class="koboSpan" id="kobo.229.1">BenchmarkGetIndex(b *testing.B)</span></strong><span class="koboSpan" id="kobo.230.1"> {
  endpoint := getTestEndpoint(b)
  for x := 0; x &lt; b.N; x++ {
    </span><strong class="bold"><span class="koboSpan" id="kobo.231.1">bks, err := http.Get(*endpoint)</span></strong><span class="koboSpan" id="kobo.232.1">
    assert.Nil(b, err)
    assert.NotNil(b, bks)
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.233.1">We create a new benchmark according to the expected signature, taking in a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">*testing.B</span></strong><span class="koboSpan" id="kobo.235.1"> parameter and named with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">Benchmark</span></strong><span class="koboSpan" id="kobo.237.1"> prefix. </span><span class="koboSpan" id="kobo.237.2">Then, we make use of the standard </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">http</span></strong><span class="koboSpan" id="kobo.239.1"> library to invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">GET</span></strong><span class="koboSpan" id="kobo.241.1"> operation on the defined endpoint, which is returned by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">getTestEndpoint</span></strong><span class="koboSpan" id="kobo.243.1"> helper function. </span><span class="koboSpan" id="kobo.243.2">Just as in previous chapters, this function constructs the endpoint based on the provided environment variables. </span><span class="koboSpan" id="kobo.243.3">If you want to run with the default values, set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">BOOKSWAP_BASE_URL</span></strong><span class="koboSpan" id="kobo.245.1"> environment variable to </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">http://localhost</span></strong><span class="koboSpan" id="kobo.247.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">BOOKSWAP_PORT</span></strong><span class="koboSpan" id="kobo.249.1"> environment variable to </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">3000</span></strong><span class="koboSpan" id="kobo.251.1"> to your </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">terminal session.</span></span></p>
<p><span class="koboSpan" id="kobo.253.1">We save this test in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">chapter08/performance/books_index_test.go</span></strong><span class="koboSpan" id="kobo.255.1"> file. </span><span class="koboSpan" id="kobo.255.2">With our simple test written, we need to make sure that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">BookSwap</span></strong><span class="koboSpan" id="kobo.257.1"> application is up and running. </span><span class="koboSpan" id="kobo.257.2">We can easily run it using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">docker compose -f docker-compose.book-swap.chapter08.yml up --build</span></strong><span class="koboSpan" id="kobo.259.1"> command. </span><span class="koboSpan" id="kobo.259.2">As mentioned in previous chapters, remember to set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">BOOKSWAP_PORT</span></strong><span class="koboSpan" id="kobo.261.1"> environment variable before running. </span><span class="koboSpan" id="kobo.261.2">If you are running with default configuration, then you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">3000</span></strong><span class="koboSpan" id="kobo.263.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">its value.</span></span></p>
<p><span class="koboSpan" id="kobo.265.1">Next, we need to run the benchmark. </span><span class="koboSpan" id="kobo.265.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">go test</span></strong><span class="koboSpan" id="kobo.267.1"> command provides support for profiling benchmarks in a similar way to how we extracted code coverage details, in </span><a href="B18371_02.xhtml#_idTextAnchor035"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.268.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.269.1">, </span><em class="italic"><span class="koboSpan" id="kobo.270.1">Unit Testing Essentials</span></em><span class="koboSpan" id="kobo.271.1">. </span><span class="koboSpan" id="kobo.271.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">runtime/pprof</span></strong><span class="koboSpan" id="kobo.273.1"> package provides the following predefined </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">profiling options:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">cpu</span></strong><span class="koboSpan" id="kobo.276.1"> shows us </span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.277.1">where our program is using </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">CPU cycles</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">heap</span></strong><span class="koboSpan" id="kobo.280.1"> shows us where our program is making </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">memory allocations</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">threadcreate</span></strong><span class="koboSpan" id="kobo.283.1"> shows us where the program is requiring </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">new threads</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">goroutine</span></strong><span class="koboSpan" id="kobo.286.1"> shows us stack traces of all the </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">program’s goroutines</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">block</span></strong><span class="koboSpan" id="kobo.289.1"> shows us where goroutines are waiting on </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">locking primitives</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">mutex</span></strong><span class="koboSpan" id="kobo.292.1"> reports </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">lock contention</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.294.1">We will explore the concurrency aspects of threads, goroutines, and mutexes in </span><a href="B18371_09.xhtml#_idTextAnchor197"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.295.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.296.1">, </span><em class="italic"><span class="koboSpan" id="kobo.297.1">Challenges of Testing Concurrent Code</span></em><span class="koboSpan" id="kobo.298.1">. </span><span class="koboSpan" id="kobo.298.2">For now, we will focus on </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">CPU profiling.</span></span></p>
<p><span class="koboSpan" id="kobo.300.1">We run our newly written benchmark with two profiling options, which will allow us to extract the </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">CPU profile:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.302.1">
$ go test -bench BenchmarkGetIndex </span><strong class="bold"><span class="koboSpan" id="kobo.303.1">-cpuprofile </span></strong><span class="koboSpan" id="kobo.304.1">cpu-books.out ./chapter08/performance</span></pre>
<p><span class="koboSpan" id="kobo.305.1">The benchmark runner outputs the same results we saw in our introductory chapter: </span></p>
<pre class="console"><span class="koboSpan" id="kobo.306.1">
pkg: github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter08/performance
BenchmarkGetIndex-8         </span><strong class="bold"><span class="koboSpan" id="kobo.307.1">1556</span></strong><span class="koboSpan" id="kobo.308.1">            796124 ns/op
PASS
ok      github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter08/performance  </span><strong class="bold"><span class="koboSpan" id="kobo.309.1">2.600s</span></strong></pre>
<p><span class="koboSpan" id="kobo.310.1">As our index endpoint is quite simple, the benchmark is executed 1,556 times and the total running time is 2.6 seconds. </span><span class="koboSpan" id="kobo.310.2">This command runs the benchmark and instructs the test runner to save the CPU profile to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">cpu-books.out</span></strong><span class="koboSpan" id="kobo.312.1"> file, saved in the current running directory. </span><span class="koboSpan" id="kobo.312.2">The </span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.313.1">details of the test run are saved in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">performance.test</span></strong><span class="koboSpan" id="kobo.315.1"> file, which is named after the package that the test is </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">declared in.</span></span></p>
<p><span class="koboSpan" id="kobo.317.1">We can view the file using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">pprof</span></strong><span class="koboSpan" id="kobo.319.1"> command tool, which comes installed with the </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">Go toolchain:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.321.1">
$ go tool pprof performance.test cpu-books.out</span></pre>
<p><span class="koboSpan" id="kobo.322.1">This opens up an interactive command that will allow us to get some insights into the measured CPU time. </span><span class="koboSpan" id="kobo.322.2">The command will give a text output of the top profile results, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">web</span></strong><span class="koboSpan" id="kobo.324.1"> will create a visual representation of the same results. </span><span class="koboSpan" id="kobo.324.2">Running </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">top5</span></strong><span class="koboSpan" id="kobo.326.1"> on the CPU profile of our benchmark presents the following </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">five results:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.328.1">
(pprof) top5      
Showing nodes accounting for 550ms, </span><strong class="bold"><span class="koboSpan" id="kobo.329.1">80.88% of 680ms total</span></strong><span class="koboSpan" id="kobo.330.1">
Showing top 5 nodes out of 91
  flat  flat%   sum%   cum   cum%
  180ms 26.47% 26.47%  180ms 26.47% runtime.pthread_cond_signal
  120ms 17.65% 44.12%  120ms 17.65% runtime.kevent
  100ms 14.71% 58.82%  100ms 14.71% runtime.cgocall
  80ms  11.76% 70.59%  120ms 17.65% runtime.pthread_cond_wait
  70ms  10.29% 80.88%  80ms  11.76% syscall.syscall</span></pre>
<p><span class="koboSpan" id="kobo.331.1">These top results count for more than 80% of the running time, but they seem to be related only to the running and scheduling of the benchmark test itself. </span><span class="koboSpan" id="kobo.331.2">As the benchmark is scheduled and runs thousands of times, we can expect that the test runner will need to make use of quite a few goroutines and threads to execute the test. </span><span class="koboSpan" id="kobo.331.3">However, this is not very useful output for gaining an understanding of the operation of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">BookSwap</span></strong><span class="koboSpan" id="kobo.333.1"> web application. </span><span class="koboSpan" id="kobo.333.2">We cannot profile our web application from the benchmark test since the web application is running in a whole other process, separate from </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">the benchmark.</span></span></p>
<p><span class="koboSpan" id="kobo.335.1">In order to gain insights into the CPU usage of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">BookSwap</span></strong><span class="koboSpan" id="kobo.337.1"> application, we will need to integrate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">pprof</span></strong><span class="koboSpan" id="kobo.339.1"> tool into our web application. </span><span class="koboSpan" id="kobo.339.2">This is easy to do by allowing </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">pprof</span></strong><span class="koboSpan" id="kobo.341.1"> to register itself alongside our other handlers in </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">handlers/config.go</span></strong><span class="koboSpan" id="kobo.343.1">: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.344.1">
func ConfigureServer(handler *Handler) *mux.Router {
  router := mux.NewRouter().StrictSlash(true)
  // other handler functions
  if os.Getenv("DEBUG") != "" {
</span><strong class="bold"><span class="koboSpan" id="kobo.345.1">    router.PathPrefix("/debug/pprof/").</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.346.1">      Handler(http.DefaultServeMux)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.347.1">}</span></strong><span class="koboSpan" id="kobo.348.1">
  return router
}</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">pprof</span></strong><span class="koboSpan" id="kobo.350.1"> will now be able to </span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.351.1">serve all the paths configured with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">debug/pprof</span></strong><span class="koboSpan" id="kobo.353.1"> prefix if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">DEBUG</span></strong><span class="koboSpan" id="kobo.355.1"> environment variable is set when the application is started. </span><span class="koboSpan" id="kobo.355.2">We can easily set it by adding the line </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">DEBUG=true</span></strong><span class="koboSpan" id="kobo.357.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">docker.env</span></strong><span class="koboSpan" id="kobo.359.1">. </span><span class="koboSpan" id="kobo.359.2">We can then rerun the application in debug mode using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">docker compose -f docker-compose.book-swap.chapter08.yml up --build</span></strong><span class="koboSpan" id="kobo.361.1"> command. </span><span class="koboSpan" id="kobo.361.2">This allows us to selectively expose this endpoint in particular environments. </span><span class="koboSpan" id="kobo.361.3">We are now ready to profile our web application. </span><span class="koboSpan" id="kobo.361.4">We rerun our benchmark, which will take around 3 seconds to run. </span><span class="koboSpan" id="kobo.361.5">We can then download the results to a local file in the same way that we exported the results of the </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">benchmark profile:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.363.1">
$ curl </span><strong class="bold"><span class="koboSpan" id="kobo.364.1">--output book-swap-app</span></strong><span class="koboSpan" id="kobo.365.1"> "http://localhost$BOOKSWAP_PORT/debug/pprof/profile?seconds=10"</span></pre>
<p><span class="koboSpan" id="kobo.366.1">As the application is running locally in this example, the URL is </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">localhost:$BOOKSWAP_PORT</span></strong><span class="koboSpan" id="kobo.368.1">, but we would change it for other environments and configurations. </span><span class="koboSpan" id="kobo.368.2">This command downloads the profiling data from the past 10 seconds and saves it to a local file. </span><span class="koboSpan" id="kobo.368.3">We can then view the exported results in the same way </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">as before:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.370.1">
$ go tool pprof book-swap-app</span></pre>
<p><span class="koboSpan" id="kobo.371.1">This command opens up the same interactive screen as before, but we will now opt to see the visual representation of the CPU using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">web</span></strong><span class="koboSpan" id="kobo.373.1"> command. </span><span class="koboSpan" id="kobo.373.2">This will launch a window in your default </span><a id="_idIndexMarker642"/><span class="koboSpan" id="kobo.374.1">browser with a graph of the method calls that have </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">been profiled.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.376.1">Graph visualization</span></p>
<p class="callout"><span class="koboSpan" id="kobo.377.1">Go’s profiling tool, </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">pprof</span></strong><span class="koboSpan" id="kobo.379.1">, relies on an </span><a id="_idIndexMarker643"/><span class="koboSpan" id="kobo.380.1">external dependency for graph visualization. </span><span class="koboSpan" id="kobo.380.2">This dependency, named </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">graphviz</span></strong><span class="koboSpan" id="kobo.382.1">, is not written in Go and is therefore not automatically </span><a id="_idIndexMarker644"/><span class="koboSpan" id="kobo.383.1">installed with the Go toolchain. </span><span class="koboSpan" id="kobo.383.2">You should follow the official documentation (</span><a href="https://graphviz.org/download/"><span class="koboSpan" id="kobo.384.1">https://graphviz.org/download/</span></a><span class="koboSpan" id="kobo.385.1">) to install it for your operating system. </span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.386.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.387.1">.3</span></em><span class="koboSpan" id="kobo.388.1"> presents the CPU profile usage in a visual representation, as was measured during the benchmarking of the </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">index endpoint:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer070">
<span class="koboSpan" id="kobo.390.1"><img alt="Figure 8.3 – A visual representation of the BookSwap CPU profile " src="image/Figure_8.03_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.391.1">Figure 8.3 – A visual representation of the BookSwap CPU profile</span></p>
<p><span class="koboSpan" id="kobo.392.1">As we can from the CPU profile, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">BookSwap</span></strong><span class="koboSpan" id="kobo.394.1"> application spends most resources serving HTTP connections with </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">net/http</span></strong><span class="koboSpan" id="kobo.396.1"> and interacting with the database layer using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">GORM</span></strong><span class="koboSpan" id="kobo.398.1"> library. </span><span class="koboSpan" id="kobo.398.2">This is indicated by the percentages and size of the boxes corresponding to each operation. </span><span class="koboSpan" id="kobo.398.3">The visual representation of the call stack gives us a good indication of where we are spending our resources. </span><span class="koboSpan" id="kobo.398.4">We explored the database aspects of the BookSwap application in </span><a href="B18371_06.xhtml#_idTextAnchor142"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.399.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.400.1">, </span><em class="italic"><span class="koboSpan" id="kobo.401.1">End-to-End Testing the BookSwap Web Application</span></em><span class="koboSpan" id="kobo.402.1">. </span><span class="koboSpan" id="kobo.402.2">If we want to improve the performance of the application, we can use the information </span><a id="_idIndexMarker645"/><span class="koboSpan" id="kobo.403.1">presented in the profile to identify areas of the call stack that need to </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">be improved.</span></span></p>
<p><span class="koboSpan" id="kobo.405.1">While benchmarking allows us to create simple tests and simulate a variety of load-testing scenarios, it can be quite verbose to define testing scenarios across many different microservices. </span><span class="koboSpan" id="kobo.405.2">There are two popular open source libraries that are often used for </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">performance testing:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.407.1">JMeter</span></strong><span class="koboSpan" id="kobo.408.1"> (</span><a href="https://jmeter.apache.org/"><span class="koboSpan" id="kobo.409.1">https://jmeter.apache.org/</span></a><span class="koboSpan" id="kobo.410.1">) is an open source Java testing tool maintained </span><a id="_idIndexMarker646"/><span class="koboSpan" id="kobo.411.1">by Apache. </span><span class="koboSpan" id="kobo.411.2">Test plans </span><a id="_idIndexMarker647"/><span class="koboSpan" id="kobo.412.1">are recorded using a simple UI, removing the need to write boilerplate code with Go’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">testing</span></strong><span class="koboSpan" id="kobo.414.1"> package. </span><span class="koboSpan" id="kobo.414.2">Different types of load can be configured. </span><span class="koboSpan" id="kobo.414.3">JMeter also has the capability of generating result graphs and dashboards once the tests </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">are run.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.416.1">K6</span></strong><span class="koboSpan" id="kobo.417.1"> (</span><a href="https://k6.io/"><span class="koboSpan" id="kobo.418.1">https://k6.io/</span></a><span class="koboSpan" id="kobo.419.1">) is an open source Go project maintained by Grafana. </span><span class="koboSpan" id="kobo.419.2">Test plans are </span><a id="_idIndexMarker648"/><span class="koboSpan" id="kobo.420.1">written in a scripting </span><a id="_idIndexMarker649"/><span class="koboSpan" id="kobo.421.1">language similar to JavaScript, reducing a lot of the code needed to write test scenarios. </span><span class="koboSpan" id="kobo.421.2">K6 offers different types of load configurations and also has the capability of outputting test results </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">to dashboards.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.423.1">Gatling</span></strong><span class="koboSpan" id="kobo.424.1"> (</span><a href="https://gatling.io/open-source/"><span class="koboSpan" id="kobo.425.1">https://gatling.io/open-source/</span></a><span class="koboSpan" id="kobo.426.1">) is an open source Scala load testing tool maintained </span><a id="_idIndexMarker650"/><span class="koboSpan" id="kobo.427.1">by Gatling Corp. </span><span class="koboSpan" id="kobo.427.2">Similarly to K6, tests are written in a Domain-Specific Language, but it is </span><a id="_idIndexMarker651"/><span class="koboSpan" id="kobo.428.1">based on Scala. </span><span class="koboSpan" id="kobo.428.2">This library provides load testing and insights </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">on dashboards.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.430.1">Regardless of which performance testing implementation option you choose, you can profile your application and supplement the data and graphs that it supplies. </span><span class="koboSpan" id="kobo.430.2">We will not be exploring these third-party tools in this book, as we have used Go’s in-built benchmarking capabilities to write our performance tests. </span></p>
<p><span class="koboSpan" id="kobo.431.1">Go profiling is a very </span><a id="_idIndexMarker652"/><span class="koboSpan" id="kobo.432.1">powerful tool with many more capabilities than what we have explored here. </span><span class="koboSpan" id="kobo.432.2">You can </span><a id="_idIndexMarker653"/><span class="koboSpan" id="kobo.433.1">read more about Go’s diagnostics capabilities in the </span><a id="_idIndexMarker654"/><span class="koboSpan" id="kobo.434.1">official </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">documentation (</span></span><a href="https://go.dev/doc/diagnostics"><span class="No-Break"><span class="koboSpan" id="kobo.436.1">https://go.dev/doc/diagnostics</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.437.1">).</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.438.1">Profiling tests and applications</span></p>
<p class="callout"><span class="koboSpan" id="kobo.439.1">While we did not directly use the profiling information of the benchmark we ran, profiling tests can be a useful way to investigate costly or slow-running tests. </span><span class="koboSpan" id="kobo.439.2">Therefore, knowing how to export and read profiling information is useful for both development and </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">test writing.</span></span></p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.441.1">Contract testing</span></h1>
<p><span class="koboSpan" id="kobo.442.1">As discussed in </span><a href="B18371_07.xhtml#_idTextAnchor162"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.443.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.444.1">, </span><em class="italic"><span class="koboSpan" id="kobo.445.1">Refactoring in Go</span></em><span class="koboSpan" id="kobo.446.1">, microservice architectures have many advantages over monolithic applications: the ability to scale system components independently, smaller code bases that are easier to maintain, and a system that is less prone to outages. </span><span class="koboSpan" id="kobo.446.2">However, the development and testing of working processes change when organizations </span><a id="_idIndexMarker655"/><span class="koboSpan" id="kobo.447.1">adopt microservice architectures. </span><span class="koboSpan" id="kobo.447.2">This also brings challenges, alongside the vast benefits of </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">microservice architectures.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.449.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.450.1">.4</span></em><span class="koboSpan" id="kobo.451.1"> depicts the three </span><a id="_idIndexMarker656"/><span class="koboSpan" id="kobo.452.1">types of complexity that microservice </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">architectures bring:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer071">
<span class="koboSpan" id="kobo.454.1"><img alt="Figure 8.4 – The complexities of microservice architectures " src="image/Figure_8.04_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.455.1">Figure 8.4 – The complexities of microservice architectures</span></p>
<p><span class="koboSpan" id="kobo.456.1">Microservice architectures add complexity to every part of the </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">development process:</span></span></p>
<ol>
<li value="1"><strong class="bold"><span class="koboSpan" id="kobo.458.1">Development complexity</span></strong><span class="koboSpan" id="kobo.459.1">: The source code of each microservice is often contained in its own </span><a id="_idIndexMarker657"/><span class="koboSpan" id="kobo.460.1">separate code base or repository. </span><span class="koboSpan" id="kobo.460.2">This leads to complexity in the development process due to the </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">following components:</span></span><ol><li><strong class="bold"><span class="koboSpan" id="kobo.462.1">Service design</span></strong><span class="koboSpan" id="kobo.463.1"> must be consistent across multiple services. </span><span class="koboSpan" id="kobo.463.2">Each engineering </span><a id="_idIndexMarker658"/><span class="koboSpan" id="kobo.464.1">team must design multiple services, as opposed to creating one monolithic application and then </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">changing it.</span></span></li><li><span class="koboSpan" id="kobo.466.1">Related to service design, the </span><strong class="bold"><span class="koboSpan" id="kobo.467.1">data separation and structure</span></strong><span class="koboSpan" id="kobo.468.1"> must be designed as well. </span><span class="koboSpan" id="kobo.468.2">Each microservice is in charge of saving its own data to persistent storage and sending the information to other services when they require it. </span><span class="koboSpan" id="kobo.468.3">If this is done without any design, services will need to pass data back and forth, increasing </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">response times.</span></span></li><li><span class="koboSpan" id="kobo.470.1">Finally, the team will need to implement </span><strong class="bold"><span class="koboSpan" id="kobo.471.1">tests for each service</span></strong><span class="koboSpan" id="kobo.472.1">. </span><span class="koboSpan" id="kobo.472.2">If the service exposes user-facing functionality, it will need to be tested at every level of the testing pyramid. </span><span class="koboSpan" id="kobo.472.3">This will increase the number of tests required for the system, even </span><a id="_idIndexMarker659"/><span class="koboSpan" id="kobo.473.1">though they may be faster and test a smaller </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">functionality scope.</span></span></li></ol></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.475.1">Deployment complexity</span></strong><span class="koboSpan" id="kobo.476.1">: Each microservice is its own self-contained running application. </span><span class="koboSpan" id="kobo.476.2">This </span><a id="_idIndexMarker660"/><span class="koboSpan" id="kobo.477.1">leads to complexity in the deployment pipelines due to the </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">following components:</span></span><ol><li><span class="koboSpan" id="kobo.479.1">The development teams </span><a id="_idIndexMarker661"/><span class="koboSpan" id="kobo.480.1">have a higher burden of </span><strong class="bold"><span class="koboSpan" id="kobo.481.1">infrastructure maintenance</span></strong><span class="koboSpan" id="kobo.482.1"> due to the separation of each microservice and its dependencies. </span><span class="koboSpan" id="kobo.482.2">This can become even more complex when services require different kinds of dependencies or versions, as the system matures and the microservices are not updated at the same time. </span></li><li><strong class="bold"><span class="koboSpan" id="kobo.483.1">Release strategies</span></strong><span class="koboSpan" id="kobo.484.1"> become more complex when it comes to making changes, as dependencies inside the system become more complex. </span><span class="koboSpan" id="kobo.484.2">All updates to the data structure or API changes, including the services, are not directly user-facing, as they could cause outages elsewhere in </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">the system.</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.486.1">Deployment automation</span></strong><span class="koboSpan" id="kobo.487.1"> becomes a necessity in order to make it feasible for teams to easily build and release services. </span><span class="koboSpan" id="kobo.487.2">Testing must also be added to the release pipelines to minimize the risk </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">of outages.</span></span></li></ol></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.489.1">Organizational complexity</span></strong><span class="koboSpan" id="kobo.490.1">: Teams are unblocked to develop and release multiple </span><a id="_idIndexMarker662"/><span class="koboSpan" id="kobo.491.1">services at the same time. </span><span class="koboSpan" id="kobo.491.2">This leads to an increase in productivity, but also organizational challenges due to the </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">following components:</span></span><ol><li><span class="koboSpan" id="kobo.493.1">Often, the number </span><a id="_idIndexMarker663"/><span class="koboSpan" id="kobo.494.1">of microservices far outnumbers the number of engineering teams, and in some cases even engineers! </span><span class="koboSpan" id="kobo.494.2">Therefore, </span><strong class="bold"><span class="koboSpan" id="kobo.495.1">service ownership</span></strong><span class="koboSpan" id="kobo.496.1"> is extended to multiple services per team. </span><span class="koboSpan" id="kobo.496.2">This adds maintenance complexity to the teams, which they must manage alongside delivering </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">new features.</span></span></li><li><span class="koboSpan" id="kobo.498.1">Teams must agree on a common way to structure and implement their services so that engineers can work across teams, as well as investigate services across the entire system. </span><span class="koboSpan" id="kobo.498.2">As such, the engineering organization will have to undertake some kind of design and implementation standardization process. </span><span class="koboSpan" id="kobo.498.3">This can be quite a difficult undertaking, as teams will have different requirements </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">and/or preferences.</span></span></li><li><span class="koboSpan" id="kobo.500.1">Finally, </span><strong class="bold"><span class="koboSpan" id="kobo.501.1">communication between teams</span></strong><span class="koboSpan" id="kobo.502.1"> will need to effectively handle larger systemic </span><a id="_idIndexMarker664"/><span class="koboSpan" id="kobo.503.1">changes in order to avoid outages. </span><span class="koboSpan" id="kobo.503.2">This can be difficult for teams that are </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">growing rapidly.</span></span></li></ol></li>
</ol>
<p><span class="koboSpan" id="kobo.505.1">The complexities introduced by microservice architectures can be mitigated with a solid testing strategy, which will flag any errors or breakages before they cause outages across the entire system. </span><span class="koboSpan" id="kobo.505.2">As discussed, the integration points between microservices must be tested, as teams will release changes to the services they own without any </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">central oversight.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.507.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.508.1">.5</span></em><span class="koboSpan" id="kobo.509.1"> depicts how </span><a id="_idIndexMarker665"/><span class="koboSpan" id="kobo.510.1">we might go about testing the integration between two microservices using the knowledge we have gained </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">so far:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer072">
<span class="koboSpan" id="kobo.512.1"><img alt="Figure 8.5 – Testing the integration between two microservices " src="image/Figure_8.05_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.513.1">Figure 8.5 – Testing the integration between two microservices</span></p>
<p><span class="koboSpan" id="kobo.514.1">There are two options when it comes to testing the integration between two services: </span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.515.1">Option A: Integration test with real services</span></strong><span class="koboSpan" id="kobo.516.1"> involves writing an integration test between the real services in a testing environment. </span><span class="koboSpan" id="kobo.516.2">This approach allows us </span><a id="_idIndexMarker666"/><span class="koboSpan" id="kobo.517.1">to verify that both services are functioning as expected and that their integration is successful. </span><span class="koboSpan" id="kobo.517.2">However, as the system grows, setting up each service and its dependencies becomes more complicated. </span><span class="koboSpan" id="kobo.517.3">Individual test runs will also slow down, as data and requests need to travel across multiple microservices or </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">data stores.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.519.1">Option B: Integration test with mocks</span></strong><span class="koboSpan" id="kobo.520.1"> involves writing separate integration tests against mocks for the dependency. </span><span class="koboSpan" id="kobo.520.2">This approach allows us to reduce the scope of the test and ensure that each service is working as expected. </span><span class="koboSpan" id="kobo.520.3">However, as it tests each service in isolation, it does not actually verify that the services are working together as expected. </span><span class="koboSpan" id="kobo.520.4">If either service does not conform to its defined mock, then the test would pass even though we could be creating an outage. </span><span class="koboSpan" id="kobo.520.5">This is the same issue we identified with our mocks in </span><a href="B18371_03.xhtml#_idTextAnchor061"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.521.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.522.1">, </span><em class="italic"><span class="koboSpan" id="kobo.523.1">Mocking and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.524.1">Assertion Frameworks</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.526.1">Neither of these two options is ideal because we would need to write robust tests that verify that our microservices are integrated well together to have the confidence to change microservices without central oversight. </span><span class="koboSpan" id="kobo.526.2">We will explore a third way of testing that can alleviate some of the downsides of </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">each approach.</span></span></p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.528.1">Fundamentals of contract testing</span></h2>
<p><span class="koboSpan" id="kobo.529.1">Due to the downsides of the </span><a id="_idIndexMarker667"/><span class="koboSpan" id="kobo.530.1">existing solutions and the difficulties that come with testing microservice architectures, developers began using another type of testing practice. </span><strong class="bold"><span class="koboSpan" id="kobo.531.1">Contract testing</span></strong><span class="koboSpan" id="kobo.532.1"> offers a simpler way to ensure that microservices continue to integrate well. </span><span class="koboSpan" id="kobo.532.2">It is not a new concept, but it has gained traction because it is well suited for </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">distributed architectures.</span></span></p>
<p><span class="koboSpan" id="kobo.534.1">Developers write virtual contracts that define how two microservices should interact. </span><span class="koboSpan" id="kobo.534.2">This contract provides the source of truth and represents the expected values for test assertions. </span><span class="koboSpan" id="kobo.534.3">There are two sides to </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">every contract:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.536.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.537.1">consumer</span></strong><span class="koboSpan" id="kobo.538.1"> begins the interaction between the two microservices. </span><span class="koboSpan" id="kobo.538.2">The consumer issues the HTTP request or requests data from a message queue. </span><span class="koboSpan" id="kobo.538.3">In the example in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.539.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.540.1">.5</span></em><span class="koboSpan" id="kobo.541.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">BookService</span></strong><span class="koboSpan" id="kobo.543.1"> is the consumer as it sends </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">the request.</span></span></li>
<li><span class="koboSpan" id="kobo.545.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.546.1">provider</span></strong><span class="koboSpan" id="kobo.547.1"> completes the interaction between two microservices. </span><span class="koboSpan" id="kobo.547.2">The provider responds to the consumer’s HTTP request or creates the message for the consumer to </span><a id="_idIndexMarker668"/><span class="koboSpan" id="kobo.548.1">read. </span><span class="koboSpan" id="kobo.548.2">In the example in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.549.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.550.1">.5</span></em><span class="koboSpan" id="kobo.551.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">PostingService</span></strong><span class="koboSpan" id="kobo.553.1"> is the provider as it sends </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">the response.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.555.1">Based on this terminology, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.556.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.557.1">.6</span></em><span class="koboSpan" id="kobo.558.1"> demonstrates the procedure for writing and running </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">contract tests:</span></span></p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div>
<div class="IMG---Figure" id="_idContainer073">
<span class="koboSpan" id="kobo.560.1"><img alt="Figure 8.6 – Writing and running contract tests " src="image/Figure_8.06_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.561.1">Figure 8.6 – Writing and running contract tests</span></p>
<p><span class="koboSpan" id="kobo.562.1">The simple procedure consists of the </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">following steps:</span></span></p>
<ol>
<li value="1"><strong class="bold"><span class="koboSpan" id="kobo.564.1">Establish the consumer and provider</span></strong><span class="koboSpan" id="kobo.565.1">: We begin by identifying which services we want to test. </span><span class="koboSpan" id="kobo.565.2">In a microservice architecture, this isn’t always straightforward. </span><span class="koboSpan" id="kobo.565.3">After </span><a id="_idIndexMarker669"/><span class="koboSpan" id="kobo.566.1">all, there is no code coverage metric for distributed systems that we can rely on to see which microservice integrations haven’t </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">been tested.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.568.1">Identify the interaction(s) under test</span></strong><span class="koboSpan" id="kobo.569.1">: This step is equivalent to identifying which user journey we’d like to test or writing our feature test. </span><span class="koboSpan" id="kobo.569.2">This should include the HTTP method, the HTTP request body, and any URL parameters we might require. </span><span class="koboSpan" id="kobo.569.3">At this point, we should also establish what the expected response of the provider </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">should be.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.571.1">Consumer unit tests</span></strong><span class="koboSpan" id="kobo.572.1">: As part of the development process, the team will write unit tests for the consumer service. </span><span class="koboSpan" id="kobo.572.2">This will be done against a provider mock that is under the </span><strong class="bold"><span class="koboSpan" id="kobo.573.1">consumer team’s ownership</span></strong><span class="koboSpan" id="kobo.574.1">. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.575.1">Provider unit tests</span></strong><span class="koboSpan" id="kobo.576.1">: In the same way as on the consumer service side, the team will write unit tests for the provider during the development process, we use a consumer mock that is under the </span><strong class="bold"><span class="koboSpan" id="kobo.577.1">provider </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.578.1">team’s ownership</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.580.1">Record consumer interaction</span></strong><span class="koboSpan" id="kobo.581.1">: Based on the identified parameters and interactions of the unit test, we can begin to formulate the contract between the consumer and provider. </span><span class="koboSpan" id="kobo.581.2">The consumer team captures the required interaction between services, which is made up of the consumer request(s) and the expected </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">provider response.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.583.1">Contract</span></strong><span class="koboSpan" id="kobo.584.1">: The consumer request and provider response are recorded together in one file, known as the contract. </span><span class="koboSpan" id="kobo.584.2">It crosses team boundaries and is the source of truth for the two teams, </span><a id="_idIndexMarker670"/><span class="koboSpan" id="kobo.585.1">allowing them to easily collaborate using a common language. </span><span class="koboSpan" id="kobo.585.2">As we mentioned previously, microservice architectures add organizational complexity so the contract can help teams communicate more effectively.  </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.586.1">Verify contract against provider</span></strong><span class="koboSpan" id="kobo.587.1">: The consumer requests recorded in the contract are run against the provider microservice. </span><span class="koboSpan" id="kobo.587.2">The expected provider response is verified against the response received from the real </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">provider microservice.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.589.1">A contract test is considered passed only when the contract is verified by interacting with the real services on both sides of the contract. </span><span class="koboSpan" id="kobo.589.2">However, unlike integration tests, which require one </span><a id="_idIndexMarker671"/><span class="koboSpan" id="kobo.590.1">single team to have both the consumer and provider running for the test, contract testing allows this verification to be done in two steps, allowing the team ownership for each service to </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">be maintained.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.592.1">The consumer viewpoint</span></p>
<p class="callout"><span class="koboSpan" id="kobo.593.1">Contract testing is written starting with the consumer, which dictates the request and expectations. </span><span class="koboSpan" id="kobo.593.2">This helps </span><a id="_idIndexMarker672"/><span class="koboSpan" id="kobo.594.1">us to ensure that the API is stable for the services that are using its functionality, encouraging stable APIs that do not promote </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">breaking changes.</span></span></p>
<p><span class="koboSpan" id="kobo.596.1">The contents of the contract file are the most important part of the process, and it is important that they does </span><a id="_idIndexMarker673"/><span class="koboSpan" id="kobo.597.1">not contain any errors. </span><span class="koboSpan" id="kobo.597.2">The safest way to ensure that this does not happen is to use tools that help us generate them, as opposed to writing them manually. </span><span class="koboSpan" id="kobo.597.3">We will not attempt to implement contract testing manually, but instead, look at the process using one of the most </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">popular tools.</span></span></p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.599.1">Using Pact</span></h2>
<p><span class="koboSpan" id="kobo.600.1">Now that we understand the basic process of contract testing, we can have a look at some tools that facilitate </span><a id="_idIndexMarker674"/><span class="koboSpan" id="kobo.601.1">the process by helping us generate contracts </span><a id="_idIndexMarker675"/><span class="koboSpan" id="kobo.602.1">and run tests. </span><span class="koboSpan" id="kobo.602.2">Pact (</span><a href="https://github.com/pact-foundation"><span class="koboSpan" id="kobo.603.1">https://github.com/pact-foundation</span></a><span class="koboSpan" id="kobo.604.1">) is a popular open source contract testing tool that allows us to easily write contract tests. </span><span class="koboSpan" id="kobo.604.2">It has been </span><a id="_idIndexMarker676"/><span class="koboSpan" id="kobo.605.1">running since 2013, and it has quickly become the number-one choice for implementing </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">contract tests.</span></span></p>
<p><span class="koboSpan" id="kobo.607.1">Some of the main features of Pact are </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.609.1">Synchronous and asynchronous support</span></strong><span class="koboSpan" id="kobo.610.1">: Pact allows contract testing for HTTP endpoints, as </span><a id="_idIndexMarker677"/><span class="koboSpan" id="kobo.611.1">well as asynchronous non-HTTP messaging systems. </span><span class="koboSpan" id="kobo.611.2">It supports a variety of technologies, such as Kafka, GraphQL, and publish-subscribe </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">messaging patterns.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.613.1">Libraries in over ten languages</span></strong><span class="koboSpan" id="kobo.614.1">: Pact offers support for a wide variety of languages for both frontend and backend technologies. </span><span class="koboSpan" id="kobo.614.2">The Pact Go library (</span><a href="https://github.com/pact-foundation/pact-go"><span class="koboSpan" id="kobo.615.1">https://github.com/pact-foundation/pact-go</span></a><span class="koboSpan" id="kobo.616.1">) provides us with the functionality required for testing our </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">Go microservices.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.618.1">Unit testing integration</span></strong><span class="koboSpan" id="kobo.619.1">: The consumer code base imports the Pact Go library and uses it to write unit tests. </span><span class="koboSpan" id="kobo.619.2">This allows developers to use the same workflow and techniques for contract tests as was used for writing </span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">unit tests.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.621.1">Contract testing Domain-Specific Language (DSL)</span></strong><span class="koboSpan" id="kobo.622.1">: The Pact library gives projects a common DSL for writing contract tests. </span><span class="koboSpan" id="kobo.622.2">This allows developers to define interactions and expected responses in a </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">uniform way.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.624.1">Test playback and verification</span></strong><span class="koboSpan" id="kobo.625.1">: Based on the test specifications, Pact generates and records the test runs. </span><span class="koboSpan" id="kobo.625.2">Contract tests are called pacts, and they are replayed and verified against the </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">provider service.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.627.1">Broker service</span></strong><span class="koboSpan" id="kobo.628.1">: Pact provides a self-hosted broker solution that allows the easy sharing and verification </span><a id="_idIndexMarker678"/><span class="koboSpan" id="kobo.629.1">of contracts and test results. </span><span class="koboSpan" id="kobo.629.2">This solution is suitable for production systems and integrating contract testing into the </span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">release pipelines.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.631.1">This list of features </span><a id="_idIndexMarker679"/><span class="koboSpan" id="kobo.632.1">is the reason why Pact has quickly become the </span><a id="_idIndexMarker680"/><span class="koboSpan" id="kobo.633.1">contract testing tool of choice. </span><span class="koboSpan" id="kobo.633.2">We can easily implement the contract testing steps using the Pact </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">Go library.</span></span></p>
<p><span class="koboSpan" id="kobo.635.1">Pact provides a variety of command-line tools in an easy-to-install native binary that provides functionality </span><a id="_idIndexMarker681"/><span class="koboSpan" id="kobo.636.1">for testing both synchronous and asynchronous </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">message-based interactions:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.638.1">Find the newest version of the tools on the project release page (</span><a href="https://github.com/pact-foundation/pact-ruby-standalone/releases"><span class="koboSpan" id="kobo.639.1">https://github.com/pact-foundation/pact-ruby-standalone/releases</span></a><span class="koboSpan" id="kobo.640.1">). </span><span class="koboSpan" id="kobo.640.2">This page will also contain installation instructions for your operating system. </span></li>
<li><span class="koboSpan" id="kobo.641.1">The Pact Go library supports Go modules and can be easily added to your projects with the usual command: </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">go </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">get github.com/pact-foundation/pact-go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.645.1">Adding the Pact tools to your system path</span></p>
<p class="callout"><span class="koboSpan" id="kobo.646.1">As detailed in the Pact setup instructions, remember to add the path to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">pact/bin</span></strong><span class="koboSpan" id="kobo.648.1"> directory to your system path. </span><span class="koboSpan" id="kobo.648.2">The Go test runner will need to be able to call the Pact tools during the test running </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">and verification.</span></span></p>
<p><span class="koboSpan" id="kobo.650.1">The installation will install a few different tools that we can use during contract testing. </span><span class="koboSpan" id="kobo.650.2">You can explore them all on your own. </span><span class="koboSpan" id="kobo.650.3">Some of the most commonly used tools are </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">as follows:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">pact-mock-service</span></strong><span class="koboSpan" id="kobo.653.1"> provides mocking and stubbing functionality. </span><span class="koboSpan" id="kobo.653.2">It can help us easily create mocks for our providers during </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">contract testing.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">pact-broker</span></strong><span class="koboSpan" id="kobo.656.1"> provides functionality for starting up the previously mentioned broker service, which makes it easy to share contracts and verification results. </span><span class="koboSpan" id="kobo.656.2">It also allows you to </span><a id="_idIndexMarker682"/><span class="koboSpan" id="kobo.657.1">deploy it independently, including </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">using Docker.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">pact-provider-verifier</span></strong><span class="koboSpan" id="kobo.660.1"> provides verification of two versions of pacts, regardless of whether the values are coming from the Pact Broker or another source. </span><span class="koboSpan" id="kobo.660.2">The verifier is often added to the release pipelines, saving the development effort of implementing </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">their own.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.662.1">Once the tools are installed, we </span><a id="_idIndexMarker683"/><span class="koboSpan" id="kobo.663.1">can have a look at a simple test example for a </span><a id="_idIndexMarker684"/><span class="koboSpan" id="kobo.664.1">possible client of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">GET /</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.666.1">root endpoint:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.667.1">func TestConsumerIndex_Local(t *testing.T) {</span></strong><span class="koboSpan" id="kobo.668.1">
  // Initialize
  pact := dsl.Pact{
    Consumer: "Consumer",
    Provider: "BookSwap",
  }
</span><strong class="bold"><span class="koboSpan" id="kobo.669.1">  pact.Setup(true)</span></strong><span class="koboSpan" id="kobo.670.1">
  // Test case - makes the call to the provider
</span><strong class="bold"><span class="koboSpan" id="kobo.671.1">  </span></strong><strong class="bold"><span class="koboSpan" id="kobo.672.1">var test = func() (err error) {</span></strong><span class="koboSpan" id="kobo.673.1">
    baseURL, ok := os.LookupEnv("BOOKSWAP_BASE_URL")
    require.True(t, ok)
    url := fmt.Sprintf("%s:%d/", baseURL, pact.Server.Port)
    req, err := http.NewRequest("GET", url, nil)
    assert.Nil(t, err)
    req.Header.Set("Content-Type", "application/json")
    resp, err := http.DefaultClient.Do(req)
    assert.Nil(t, err)
    assert.NotNil(t, resp)
    return
   }
</span><strong class="bold"><span class="koboSpan" id="kobo.674.1">   t.Run("get index", func(t *testing.T) {</span></strong><span class="koboSpan" id="kobo.675.1">
     pact.</span><strong class="bold"><span class="koboSpan" id="kobo.676.1">AddInteraction()</span></strong><span class="koboSpan" id="kobo.677.1">.
</span><span class="koboSpan" id="kobo.677.2">     Given("BookSwap is up").
</span><span class="koboSpan" id="kobo.677.3">     UponReceiving("GET / request").
</span><span class="koboSpan" id="kobo.677.4">     WithRequest(dsl.Request{
       Method: "GET", Path: dsl.String("/"),
       Headers: dsl.MapMatcher{
         "Content-Type":  dsl.String("application/json"),
       }
     }).
</span><span class="koboSpan" id="kobo.677.5">     WillRespondWith(dsl.Response{
       Status: https.StatusOK,
       Body: dsl.Like(handlers.Response{
         Message: "Welcome to the BookSwap Service!",
       }),
      })
      require.Nil(t, </span><strong class="bold"><span class="koboSpan" id="kobo.678.1">pact.Verify(test)</span></strong><span class="koboSpan" id="kobo.679.1">)
    })
    // Clean up
    require.Nil(t, </span><strong class="bold"><span class="koboSpan" id="kobo.680.1">pact.WritePact()</span></strong><span class="koboSpan" id="kobo.681.1">)
    </span><strong class="bold"><span class="koboSpan" id="kobo.682.1">pact.Teardown()</span></strong><span class="koboSpan" id="kobo.683.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.684.1">Looking at the client test more closely, we can see that writing a contract test with Pact is not all that different from writing a unit test with Go’s standard </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">testing library:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.686.1">The signature of the </span><a id="_idIndexMarker685"/><span class="koboSpan" id="kobo.687.1">test is the same as a unit test, conforming to </span><a id="_idIndexMarker686"/><span class="koboSpan" id="kobo.688.1">the test name convention and taking in the single </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">*testing.T</span></strong><span class="koboSpan" id="kobo.690.1"> parameter. </span></li>
<li><span class="koboSpan" id="kobo.691.1">The Pact DSL is initialized, and we start up the Pact Mock Server using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">Setup()</span></strong><span class="koboSpan" id="kobo.693.1"> function. </span><span class="koboSpan" id="kobo.693.2">Pact will find a free port on the local machine and then start up </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">the server.</span></span></li>
<li><span class="koboSpan" id="kobo.695.1">We create a test case function that takes in no parameters and returns a single error: </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">func() error</span></strong><span class="koboSpan" id="kobo.697.1">. </span><span class="koboSpan" id="kobo.697.2">This function wraps around the consumer code that calls out to the provider, including setting up any requests required. </span><span class="koboSpan" id="kobo.697.3">As we don’t have a dedicated client service on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">BookSwap</span></strong><span class="koboSpan" id="kobo.699.1"> application, we simply call out to it using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">http</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.701.1"> library.</span></span></li>
<li><span class="koboSpan" id="kobo.702.1">With everything set up, we can run test cases in subtests. </span><span class="koboSpan" id="kobo.702.2">This allows us to use the same test techniques that we’ve seen so far, including the table-driven testing we explored in </span><a href="B18371_04.xhtml#_idTextAnchor085"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.703.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.704.1">, </span><em class="italic"><span class="koboSpan" id="kobo.705.1">Building Efficient </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.706.1">Test Suites</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.708.1">Inside each subtest, we define a new Pact interaction using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">AddInteraction()</span></strong><span class="koboSpan" id="kobo.710.1"> function, which sets up all the prerequisites for contract testing, including starting a Mock Server, if one </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">is running.</span></span></li>
<li><span class="koboSpan" id="kobo.712.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">dsl.Interaction</span></strong><span class="koboSpan" id="kobo.714.1"> type returned allows us to configure all of the attributes required to describe the contract between the consumer and provider: the request and response body, headers, query parameters, status code, and </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">so on.</span></span></li>
<li><span class="koboSpan" id="kobo.716.1">Once everything has been set up for the test case and expected behavior, we verify that the behavior is as written using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">Verify</span></strong><span class="koboSpan" id="kobo.718.1"> function, which takes in the test case that has defined the </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">consumer configuration.</span></span></li>
<li><span class="koboSpan" id="kobo.720.1">Finally, we record the </span><a id="_idIndexMarker687"/><span class="koboSpan" id="kobo.721.1">interaction in a file and invoke </span><a id="_idIndexMarker688"/><span class="koboSpan" id="kobo.722.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">Teardown</span></strong><span class="koboSpan" id="kobo.724.1"> function, which stops the Pact Mock Server. </span><span class="koboSpan" id="kobo.724.2">By default, Pact will save the contract inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">pacts</span></strong><span class="koboSpan" id="kobo.726.1"> folder in </span><span class="No-Break"><span class="koboSpan" id="kobo.727.1">the project.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.728.1">We can run this test in the same way as we might run any integration test. </span><span class="koboSpan" id="kobo.728.2">The output of this test run will be </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.730.1">
$ LONG=true go test chapter08/contract_test/consumer_test.go -v === RUN   TestConsumerIndex_Local
2023/01/08 16:19:36 [INFO] checking pact-mock-service within range &gt;= 3.5.0, &lt; 4.0.0
2023/01/08 16:19:36 [INFO] checking pact-provider-verifier within range &gt;= 1.36.1, &lt; 2.0.0
2023/01/08 16:19:37 [INFO] checking pact-broker within range &gt;= 1.22.3
2023/01/08 16:19:37 [INFO] INFO  WEBrick 1.3.1
2023/01/08 16:19:37 [INFO] INFO  ruby 2.4.10 (2020-03-31) [x86_64-darwin19]
2023/01/08 16:19:37 [INFO] INFO  WEBrick::HTTPServer#start: pid=83017 port=52412
=== RUN   TestConsumerIndex_Local/get_index
2023/01/08 16:19:37 [INFO] INFO  going to shutdown ...
</span><span class="koboSpan" id="kobo.730.2">2023/01/08 16:19:38 [INFO] INFO  WEBrick::HTTPServer#start done.
</span><span class="koboSpan" id="kobo.730.3">--- PASS: TestConsumerIndex_Local (1.67s)
    --- PASS: TestConsumerIndex_Local/get_index (0.01s)
PASS
ok      command-line-arguments  1.828s</span></pre>
<p><span class="koboSpan" id="kobo.731.1">The output of the command indicates that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">TestConsumerIndex_Local</span></strong><span class="koboSpan" id="kobo.733.1"> test was run  against the Pact Mock Server and that it passed. </span><span class="koboSpan" id="kobo.733.2">The pact is also written to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">pacts/consumer-bookswap.json</span></strong><span class="koboSpan" id="kobo.735.1"> file. </span><span class="koboSpan" id="kobo.735.2">This file contains the specified interactions between the consumer and provider, as described by </span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">the test.</span></span></p>
<p><span class="koboSpan" id="kobo.737.1">The consumer has </span><a id="_idIndexMarker689"/><span class="koboSpan" id="kobo.738.1">specified the behavior they expect from the </span><a id="_idIndexMarker690"/><span class="koboSpan" id="kobo.739.1">provider in the contract specification. </span><span class="koboSpan" id="kobo.739.2">Therefore, the provider verification is </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">much simpler:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.741.1">func TestProviderIndex_Local(t *testing.T)</span></strong><span class="koboSpan" id="kobo.742.1"> {
  // Initialise
  pact := dsl.Pact{
    Provider: "BookSwap",
  }
  url := getTestEndpoint(t)
  
  // Verify
  _, err := </span><strong class="bold"><span class="koboSpan" id="kobo.743.1">pact.VerifyProvider</span></strong><span class="koboSpan" id="kobo.744.1">(t, types.VerifyRequest{
    ProviderBaseURL: url,
    PactURLs:        []string{PACTS_PATH},
  })
  require.Nil(t, err)
}</span></pre>
<p><span class="koboSpan" id="kobo.745.1">This simple snippet contains everything required for verification on the provider side: </span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.746.1">We define the provider verification as a unit test, in the same way as we did on the </span><span class="No-Break"><span class="koboSpan" id="kobo.747.1">consumer side.</span></span></li>
<li><span class="koboSpan" id="kobo.748.1">As we run the provider </span><a id="_idIndexMarker691"/><span class="koboSpan" id="kobo.749.1">verification against the real service, we </span><a id="_idIndexMarker692"/><span class="koboSpan" id="kobo.750.1">do not start the Pact Mock Server, but initialize the Pact DSL. </span></li>
<li><span class="koboSpan" id="kobo.751.1">We call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">VerifyRequest</span></strong><span class="koboSpan" id="kobo.753.1"> function, passing in the URL to the provider and the path to the consumer-defined contract. </span><span class="koboSpan" id="kobo.753.2">This was generated by running the consumer test, as described </span><span class="No-Break"><span class="koboSpan" id="kobo.754.1">earlier on.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.755.1">The URL to the provider and the path to the contract definition have been defined outside the scope of this test, allowing us to run this test in different environments. </span><span class="koboSpan" id="kobo.755.2">Once the </span><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">BookSwap</span></strong><span class="koboSpan" id="kobo.757.1"> application is up and running with the Docker command we saw earlier, we can run the </span><span class="No-Break"><span class="koboSpan" id="kobo.758.1">provider verification:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.759.1">
$ LONG=true go test chapter08/contract_ test/provider_test.go -v 
=== RUN   TestProviderIndex_Local
2023/01/08 17:46:09 [INFO] checking pact-mock-service within range &gt;= 3.5.0, &lt; 4.0.0
2023/01/08 17:46:09 [INFO] checking pact-provider-verifier within range &gt;= 1.36.1, &lt; 2.0.0
2023/01/08 17:46:09 [INFO] checking pact-broker within range &gt;= 1.22.3
=== RUN   TestProviderIndex_Local/Pact_between__and__
=== RUN   TestProviderIndex_Local/has_status_code_200
    pact.go:638: Verifying a pact between Consumer and BookSwap Given BookSwap is up GET / request with GET / returns a response which has status code 200
=== RUN   TestProviderIndex_Local/has_a_matching_body
    pact.go:638: Verifying a pact between Consumer and BookSwap Given BookSwap is up GET / request with GET / returns a response which has a matching body
--- PASS: TestProviderIndex_Local (1.52s)
    --- PASS: TestProviderIndex_Local/has_status_code_200 (0.00s)
    --- PASS: TestProviderIndex_Local/has_a_matching_body (0.00s)
    --- PASS: TestProviderIndex_Local/Pact_between__and__ (0.00s)
PASS
ok      command-line-arguments  1.682s</span></pre>
<p><span class="koboSpan" id="kobo.760.1">The provider verification passes because the returned response from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">BookSwap</span></strong><span class="koboSpan" id="kobo.762.1"> application is as we </span><a id="_idIndexMarker693"/><span class="koboSpan" id="kobo.763.1">have specified on the consumer side. </span><span class="koboSpan" id="kobo.763.2">We have </span><a id="_idIndexMarker694"/><span class="koboSpan" id="kobo.764.1">now successfully written and run our first contract test with Pact! </span><span class="koboSpan" id="kobo.764.2">All of the interaction with the contract testing library has been through a simple Go library, which has also allowed us to write contract tests in the same way as unit tests. </span></p>
<p><span class="koboSpan" id="kobo.765.1">As we have seen, the power of Pact is that it allows developers to easily implement code-first contract tests, so it is definitely a framework that you should consider adding to your projects alongside the practice of </span><span class="No-Break"><span class="koboSpan" id="kobo.766.1">contract testing.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.767.1">The role of the Pact Broker</span></p>
<p class="callout"><span class="koboSpan" id="kobo.768.1">In the example we have explored, the contract tests were running locally, so they had shared access to the </span><a id="_idIndexMarker695"/><span class="koboSpan" id="kobo.769.1">same contract file. </span><span class="koboSpan" id="kobo.769.2">However, this is not possible in microservice </span><a id="_idIndexMarker696"/><span class="koboSpan" id="kobo.770.1">architectures or consumer-facing services. </span><span class="koboSpan" id="kobo.770.2">Teams run a dedicated Pact Broker service that can serve as the URL to the contracts that they wish to write and verify. </span><span class="koboSpan" id="kobo.770.3">The Pact Broker can be easily run with Docker using its image available on Docker </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">hub (</span></span><a href="https://hub.docker.com/r/pactfoundation/pact-broker/"><span class="No-Break"><span class="koboSpan" id="kobo.772.1">https://hub.docker.com/r/pactfoundation/pact-broker/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.773.1">).</span></span></p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.774.1">Breaking up the BookSwap monolith</span></h1>
<p><span class="koboSpan" id="kobo.775.1">The discussion in </span><a id="_idIndexMarker697"/><span class="koboSpan" id="kobo.776.1">this chapter has been centered around discussing microservice architectures, as distributed systems have become the standard and you will most likely have to work on this kind of system in the near future. </span><span class="koboSpan" id="kobo.776.2">However, the BookSwap application is still a </span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">monolithic application.</span></span></p>
<p><span class="koboSpan" id="kobo.778.1">Based on some of the practices we discussed in </span><a href="B18371_07.xhtml#_idTextAnchor162"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.779.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.780.1">, </span><em class="italic"><span class="koboSpan" id="kobo.781.1">Refactoring in Go</span></em><span class="koboSpan" id="kobo.782.1">, we can discuss how we might go splitting up the BookSwap monolith. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.783.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.784.1">.7</span></em><span class="koboSpan" id="kobo.785.1"> depicts some of the microservices that we </span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">could create:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer074">
<span class="koboSpan" id="kobo.787.1"><img alt="Figure 8.7 – The distributed BookSwap system " src="image/Figure_8.07_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.788.1">Figure 8.7 – The distributed BookSwap system</span></p>
<p><span class="koboSpan" id="kobo.789.1">The distributed </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">BookSwap</span></strong><span class="koboSpan" id="kobo.791.1"> system has microservices with </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">well-defined responsibilities:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">SwapService</span></strong><span class="koboSpan" id="kobo.794.1"> is the entry point to the system and is responsible for handling and routing all the incoming user requests of the system. </span><span class="koboSpan" id="kobo.794.2">It has direct dependencies on </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">BookService</span></strong><span class="koboSpan" id="kobo.796.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">UserService</span></strong><span class="koboSpan" id="kobo.798.1">, which own the data that </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">SwapService</span></strong><span class="koboSpan" id="kobo.800.1"> relies on. </span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">UserService</span></strong><span class="koboSpan" id="kobo.802.1"> is responsible for all the operations pertaining to user management. </span><span class="koboSpan" id="kobo.802.2">The service has persistent storage, </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">UsersDB</span></strong><span class="koboSpan" id="kobo.804.1">, which it has full control of inside the system. </span><span class="koboSpan" id="kobo.804.2">This storage can take any form, but the service must be able to </span><a id="_idIndexMarker698"/><span class="koboSpan" id="kobo.805.1">support the access patterns required by </span><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">SwapService</span></strong><span class="koboSpan" id="kobo.807.1">. </span><span class="koboSpan" id="kobo.807.2">This service has a direct dependency </span><span class="No-Break"><span class="koboSpan" id="kobo.808.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">BookService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.811.1">BookService</span></strong><span class="koboSpan" id="kobo.812.1"> is responsible for all the operations pertaining to book management. </span><span class="koboSpan" id="kobo.812.2">This service has its own dedicated persistent storage, </span><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">BooksDB</span></strong><span class="koboSpan" id="kobo.814.1">, which it has full control of inside the system. </span><span class="koboSpan" id="kobo.814.2">This service has a direct dependency on </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">PostingService</span></strong><span class="koboSpan" id="kobo.816.1">, which is an external service to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">BookSwap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.818.1"> system.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.819.1">Avoiding a shared database</span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">BookService</span></strong><span class="koboSpan" id="kobo.821.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">UserService</span></strong><span class="koboSpan" id="kobo.823.1"> have been designed to have their own dedicated databases, instead of sharing one single persistent storage. </span><span class="koboSpan" id="kobo.823.2">This allows us to enforce data separation between the two microservices, as well as ensure that a database outage does not cause an outage on both of </span><span class="No-Break"><span class="koboSpan" id="kobo.824.1">the services.</span></span></p>
<p><span class="koboSpan" id="kobo.825.1">This simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">BookSwap</span></strong><span class="koboSpan" id="kobo.827.1"> system from </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.828.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.829.1">.7</span></em><span class="koboSpan" id="kobo.830.1"> is the starting point of how we might go about splitting up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">BookSwap</span></strong><span class="koboSpan" id="kobo.832.1"> monolith. </span><span class="koboSpan" id="kobo.832.2">As we can see, the services have dependencies, so they must support the access patterns required by their consumers. </span><span class="koboSpan" id="kobo.832.3">The next step in the monolith splitting process is to design the APIs of the </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">different services.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.834.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.835.1">.8</span></em><span class="koboSpan" id="kobo.836.1"> depicts which API calls the services </span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">might expose:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer075">
<span class="koboSpan" id="kobo.838.1"><img alt="Figure 8.8 – The endpoints of the BookSwap microservices " src="image/Figure_8.08_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.839.1">Figure 8.8 – The endpoints of the BookSwap microservices</span></p>
<p><span class="koboSpan" id="kobo.840.1">As previously discussed, </span><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">SwapService</span></strong><span class="koboSpan" id="kobo.842.1"> is the only user-facing service, with the other services being </span><a id="_idIndexMarker699"/><span class="koboSpan" id="kobo.843.1">direct dependencies to it. </span><span class="koboSpan" id="kobo.843.2">We can see the following access patterns for the different domains in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">BookSwap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.845.1"> services:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.846.1">Books are accessed by their primary ID and by their owner user ID. </span><span class="koboSpan" id="kobo.846.2">This access pattern by two indices must be implemented to satisfy the requirements </span><span class="No-Break"><span class="koboSpan" id="kobo.847.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">SwapService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.849.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.850.1">There is a </span><strong class="bold"><span class="koboSpan" id="kobo.851.1">one-to-many relationship</span></strong><span class="koboSpan" id="kobo.852.1"> between users and books. </span><span class="koboSpan" id="kobo.852.2">If we use a SQL database, then </span><a id="_idIndexMarker700"/><span class="koboSpan" id="kobo.853.1">the user ID is a foreign key on the books table. </span><span class="koboSpan" id="kobo.853.2">This type of dependency can also be implemented in NoSQL tables, even though it feels like a natural fit for </span><span class="No-Break"><span class="koboSpan" id="kobo.854.1">SQL databases.</span></span></li>
<li><span class="koboSpan" id="kobo.855.1">Users are created and updated using the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">POST</span></strong><span class="koboSpan" id="kobo.857.1"> request on the corresponding endpoint. </span><span class="koboSpan" id="kobo.857.2">This conforms to RESTful design practices, but this merged operation should be handled lower down on the </span><span class="No-Break"><span class="koboSpan" id="kobo.858.1">service level.</span></span></li>
<li><span class="koboSpan" id="kobo.859.1">Books are created using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">POST</span></strong><span class="koboSpan" id="kobo.861.1"> request but are updated using their ID as the URL parameter. </span><span class="koboSpan" id="kobo.861.2">The second update is the implementation of the </span><span class="No-Break"><span class="koboSpan" id="kobo.862.1">swap endpoint.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.863.1">These simple access patterns can be easily implemented with either a SQL or NoSQL persistent storage solution. </span><span class="koboSpan" id="kobo.863.2">It is highly recommended that REST endpoints use JSON as content type, especially as JSON marshaling and unmarshaling are natively supported in Go with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">encoding/json</span></strong><span class="koboSpan" id="kobo.865.1"> library. </span><span class="koboSpan" id="kobo.865.2">We have previously explored persistent storage with PostgreSQL, but most major NoSQL data stores have </span><span class="No-Break"><span class="koboSpan" id="kobo.866.1">Go drivers.</span></span></p>
<p><span class="koboSpan" id="kobo.867.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">BookSwap</span></strong><span class="koboSpan" id="kobo.869.1"> monolithic application would have lived in one single code base up until now, giving developers full visibility of all the changes that are being made to the application. </span><span class="koboSpan" id="kobo.869.2">However, in the </span><a id="_idIndexMarker701"/><span class="koboSpan" id="kobo.870.1">microservices world, each service has its own code repository and </span><span class="No-Break"><span class="koboSpan" id="kobo.871.1">team ownership.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.872.1">Figure 8</span></em></span><em class="italic"><span class="koboSpan" id="kobo.873.1">.9</span></em><span class="koboSpan" id="kobo.874.1"> depicts the five service integrations exposed by the new </span><span class="No-Break"><span class="koboSpan" id="kobo.875.1">microservice architecture:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer076">
<span class="koboSpan" id="kobo.876.1"><img alt="Figure 8.9 – Five service integrations exposed by the new microservice architecture " src="image/Figure_8.09_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.877.1">Figure 8.9 – Five service integrations exposed by the new microservice architecture</span></p>
<p><span class="koboSpan" id="kobo.878.1">The microservices </span><a id="_idIndexMarker702"/><span class="koboSpan" id="kobo.879.1">assume the role of consumer and provider according to the flow of data and the request flow between the </span><span class="No-Break"><span class="koboSpan" id="kobo.880.1">two services:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.881.1">The client code is the consumer that issues the request to </span><strong class="source-inline"><span class="koboSpan" id="kobo.882.1">SwapService</span></strong><span class="koboSpan" id="kobo.883.1">, which handles it by relying on the other services of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.884.1">BookSwap</span></strong><span class="koboSpan" id="kobo.885.1"> application. </span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">SwapService</span></strong><span class="koboSpan" id="kobo.887.1"> is the consumer as it issues requests to </span><strong class="source-inline"><span class="koboSpan" id="kobo.888.1">BookService</span></strong><span class="koboSpan" id="kobo.889.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.890.1">UserService</span></strong><span class="koboSpan" id="kobo.891.1"> in order to process creation and update their </span><span class="No-Break"><span class="koboSpan" id="kobo.892.1">corresponding model.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">UserService</span></strong><span class="koboSpan" id="kobo.894.1"> is the consumer and </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">BookService</span></strong><span class="koboSpan" id="kobo.896.1"> is the provider as it fetches the list of books belonging to </span><span class="No-Break"><span class="koboSpan" id="kobo.897.1">the user.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">BookService</span></strong><span class="koboSpan" id="kobo.899.1"> is the consumer and the external </span><strong class="source-inline"><span class="koboSpan" id="kobo.900.1">PostingService</span></strong><span class="koboSpan" id="kobo.901.1"> is the provider, as </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">PostingService</span></strong><span class="koboSpan" id="kobo.903.1"> handles the side effects of all book swaps, which is a critically important detail because these side effects are what deliver the business value of the system in the </span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">real world.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.905.1">Contract testing the integration between </span><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">BookService</span></strong><span class="koboSpan" id="kobo.907.1"> and the external </span><strong class="source-inline"><span class="koboSpan" id="kobo.908.1">PostingService</span></strong><span class="koboSpan" id="kobo.909.1"> can help us to validate version upgrades, ensuring that external APIs continue to integrate well with our systems. </span><span class="koboSpan" id="kobo.909.2">This is a great way to ensure the continued successful operation of our system and all </span><span class="No-Break"><span class="koboSpan" id="kobo.910.1">its dependencies.</span></span></p>
<p><span class="koboSpan" id="kobo.911.1">As we have seen from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">BookSwap</span></strong><span class="koboSpan" id="kobo.913.1"> application in this section, monolithic applications can be </span><a id="_idIndexMarker703"/><span class="koboSpan" id="kobo.914.1">converted in to a microservice architecture once the domain and team have the maturity to undertake this journey. </span><span class="koboSpan" id="kobo.914.2">In turn, this adds different kinds of complexity to the development, testing, and release processes. </span><span class="koboSpan" id="kobo.914.3">That complexity then enables onward scaling of the solution and team. </span><span class="koboSpan" id="kobo.914.4">A solid testing strategy, which includes contract testing, can help validate that the microservice architecture is stable, as well </span><span class="No-Break"><span class="koboSpan" id="kobo.915.1">as scalable.</span></span></p>
<h1 id="_idParaDest-168"><a id="_idTextAnchor189"/><span class="koboSpan" id="kobo.916.1">Production best practices</span></h1>
<p><span class="koboSpan" id="kobo.917.1">The final aspect of the microservice architectures that we will look at is some best practices when it comes to deployment and release. </span><span class="koboSpan" id="kobo.917.2">As we previously mentioned, the release pipelines should be automated to make it feasible for teams to release service multiple times a day. </span><span class="koboSpan" id="kobo.917.3">In this section, we will briefly explore some common patterns and solutions to consider when migrating to </span><span class="No-Break"><span class="koboSpan" id="kobo.918.1">microservice architectures.</span></span></p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor190"/><span class="koboSpan" id="kobo.919.1">Monitoring and observability</span></h2>
<p><span class="koboSpan" id="kobo.920.1">In the microservices </span><a id="_idIndexMarker704"/><span class="koboSpan" id="kobo.921.1">world, it can be difficult to have an understanding of how data travels through </span><a id="_idIndexMarker705"/><span class="koboSpan" id="kobo.922.1">the system and how healthy our system is. </span><span class="koboSpan" id="kobo.922.2">This is alleviated by monitoring and observability solutions, which give us the required visibility. </span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.923.1">Observability versus monitoring</span></p>
<p class="callout"><span class="koboSpan" id="kobo.924.1">Observability and monitoring are often used interchangeably, but they have two different intended </span><a id="_idIndexMarker706"/><span class="koboSpan" id="kobo.925.1">purposes: observability aims to give teams access to </span><a id="_idIndexMarker707"/><span class="koboSpan" id="kobo.926.1">data they need to debug problems, while monitoring aims to track performance and identify service anomalies. </span><span class="koboSpan" id="kobo.926.2">This means that monitoring is contained within observability. </span><span class="koboSpan" id="kobo.926.3">Observations need to be viewed in terms of meaningful value to the business in order to deliver reliable monitoring of properties, such as availability, performance, </span><span class="No-Break"><span class="koboSpan" id="kobo.927.1">and capacity.</span></span></p>
<p><span class="koboSpan" id="kobo.928.1">We covered some important metrics for performance earlier in this chapter, in the </span><em class="italic"><span class="koboSpan" id="kobo.929.1">Performance testing in Go</span></em><span class="koboSpan" id="kobo.930.1"> section. </span><span class="koboSpan" id="kobo.930.2">Alongside these important metrics, </span><strong class="bold"><span class="koboSpan" id="kobo.931.1">structured logging</span></strong><span class="koboSpan" id="kobo.932.1"> is often </span><a id="_idIndexMarker708"/><span class="koboSpan" id="kobo.933.1">added to track application logs. </span><span class="koboSpan" id="kobo.933.2">This type of logging can be analyzed to get </span><a id="_idIndexMarker709"/><span class="koboSpan" id="kobo.934.1">an idea of the </span><a id="_idIndexMarker710"/><span class="koboSpan" id="kobo.935.1">events that have occurred </span><a id="_idIndexMarker711"/><span class="koboSpan" id="kobo.936.1">in our microservice architecture. </span><span class="koboSpan" id="kobo.936.2">Some popular open source </span><a id="_idIndexMarker712"/><span class="koboSpan" id="kobo.937.1">structured logging </span><a id="_idIndexMarker713"/><span class="koboSpan" id="kobo.938.1">libraries are </span><strong class="source-inline"><span class="koboSpan" id="kobo.939.1">zap</span></strong><span class="koboSpan" id="kobo.940.1"> (</span><a href="https://pkg.go.dev/go.uber.org/zap"><span class="koboSpan" id="kobo.941.1">https://pkg.go.dev/go.uber.org/zap</span></a><span class="koboSpan" id="kobo.942.1">), </span><strong class="source-inline"><span class="koboSpan" id="kobo.943.1">logrus</span></strong><span class="koboSpan" id="kobo.944.1"> (</span><a href="https://github.com/sirupsen/logrus"><span class="koboSpan" id="kobo.945.1">https://github.com/sirupsen/logrus</span></a><span class="koboSpan" id="kobo.946.1">), and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">apex/log</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.948.1"> (</span></span><a href="https://github.com/apex/log"><span class="No-Break"><span class="koboSpan" id="kobo.949.1">https://github.com/apex/log</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.950.1">).</span></span></p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor191"/><span class="koboSpan" id="kobo.951.1">Deployment patterns</span></h2>
<p><span class="koboSpan" id="kobo.952.1">While a solid </span><a id="_idIndexMarker714"/><span class="koboSpan" id="kobo.953.1">test strategy verifies the system for errors and performance issues, no code change or testing </span><a id="_idIndexMarker715"/><span class="koboSpan" id="kobo.954.1">strategy is perfect. </span><span class="koboSpan" id="kobo.954.2">Deployment patterns will allow us to gradually release changes, making it easier to prevent outages. </span><span class="koboSpan" id="kobo.954.3">Two common patterns are </span><span class="No-Break"><span class="koboSpan" id="kobo.955.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.956.1">Canary deployments</span></strong><span class="koboSpan" id="kobo.957.1"> involve releasing the change to a small percentage of traffic. </span><span class="koboSpan" id="kobo.957.2">If the </span><a id="_idIndexMarker716"/><span class="koboSpan" id="kobo.958.1">canary is functioning </span><a id="_idIndexMarker717"/><span class="koboSpan" id="kobo.959.1">correctly, then we roll out the change to larger percentages of traffic. </span><span class="koboSpan" id="kobo.959.2">However, if the metrics recorded in the canary deployment are not positive, we can roll back traffic to the old version of the application, which is still up and running. </span><span class="koboSpan" id="kobo.959.3">This minimizes the amount of work that must be done to handle the repercussions of a </span><span class="No-Break"><span class="koboSpan" id="kobo.960.1">negative change.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.961.1">Blue-green deployments</span></strong><span class="koboSpan" id="kobo.962.1"> involve maintaining two versions of the microservice </span><a id="_idIndexMarker718"/><span class="koboSpan" id="kobo.963.1">to be changed. </span><span class="koboSpan" id="kobo.963.2">The blue </span><a id="_idIndexMarker719"/><span class="koboSpan" id="kobo.964.1">version is running the current version of the service, while the green version is running the updated version. </span><span class="koboSpan" id="kobo.964.2">Once the green version has passed testing, user traffic is routed to the green environment. </span><span class="koboSpan" id="kobo.964.3">In the case of errors, traffic can be routed back to the blue version. </span><span class="koboSpan" id="kobo.964.4">Once the team is confident that the green version is functioning correctly, the blue version can be removed from the running environment or can be used for the </span><span class="No-Break"><span class="koboSpan" id="kobo.965.1">next iteration.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.966.1">These two </span><a id="_idIndexMarker720"/><span class="koboSpan" id="kobo.967.1">popular deployment strategies will make it easier to avoid outages when rolling out new versions </span><a id="_idIndexMarker721"/><span class="koboSpan" id="kobo.968.1">of a microservice, allowing us to quickly roll back to the previous version in the case of increased error rates. </span><span class="koboSpan" id="kobo.968.2">Such strategies are well supported by tools such as Kubernetes and </span><span class="No-Break"><span class="koboSpan" id="kobo.969.1">service meshes.</span></span></p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor192"/><span class="koboSpan" id="kobo.970.1">The circuit breaker pattern</span></h2>
<p><span class="koboSpan" id="kobo.971.1">The circuit breaker pattern is a development pattern that allows us to avoid </span><strong class="bold"><span class="koboSpan" id="kobo.972.1">cascading failures</span></strong><span class="koboSpan" id="kobo.973.1">, which is the process </span><a id="_idIndexMarker722"/><span class="koboSpan" id="kobo.974.1">of one service increasing the probability </span><a id="_idIndexMarker723"/><span class="koboSpan" id="kobo.975.1">that other services will fail. </span><span class="koboSpan" id="kobo.975.2">Circuit breakers typically wrap remote calls to other microservices. </span><span class="koboSpan" id="kobo.975.3">Once the </span><a id="_idIndexMarker724"/><span class="koboSpan" id="kobo.976.1">error rate for calls to the remote services reaches an established threshold, the circuit breaker will immediately fail other requests, allowing the other service space to attempt to recover, and giving users a clear and timely response to explain the situation rather than keeping many requests in flight. </span><span class="koboSpan" id="kobo.976.2">An open circuit breaker then retries after a delay, becoming closed and able to pass further requests if the remote services are available, or becoming open again if the </span><span class="No-Break"><span class="koboSpan" id="kobo.977.1">problems continue.</span></span></p>
<p><span class="koboSpan" id="kobo.978.1">A popular open source circuit breaker implementation is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.979.1">hystrix-go</span></strong><span class="koboSpan" id="kobo.980.1"> (</span><a href="https://github.com/afex/hystrix-go"><span class="koboSpan" id="kobo.981.1">https://github.com/afex/hystrix-go</span></a><span class="koboSpan" id="kobo.982.1">) library, which implements error monitoring and retries. </span><span class="koboSpan" id="kobo.982.2">This pattern is </span><a id="_idIndexMarker725"/><span class="koboSpan" id="kobo.983.1">simple and also requires us to consider default values and fallback behavior for all of our remote calls. </span><span class="koboSpan" id="kobo.983.2">The explicit implementation of the error cases for dependency outages brings further resilience to our </span><span class="No-Break"><span class="koboSpan" id="kobo.984.1">microservice architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.985.1">This brings us to the end of our exploration of microservice architecture implementation and testing. </span><span class="koboSpan" id="kobo.985.2">As we </span><a id="_idIndexMarker726"/><span class="koboSpan" id="kobo.986.1">have seen in this chapter, a comprehensive testing strategy will allow us to take full advantage of </span><a id="_idIndexMarker727"/><span class="koboSpan" id="kobo.987.1">the power of microservices, but we must be aware of the difference in the development process in order to be able to efficiently work with </span><span class="No-Break"><span class="koboSpan" id="kobo.988.1">microservice architectures.</span></span></p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor193"/><span class="koboSpan" id="kobo.989.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.990.1">In this chapter, we discussed how to test microservice architectures. </span><span class="koboSpan" id="kobo.990.2">Having focused on functional testing in previous chapters, we started by exploring non-functional testing. </span><span class="koboSpan" id="kobo.990.3">Then, we took a closer look at performance testing, one particularly important type of non-functional testing. </span><span class="koboSpan" id="kobo.990.4">Then, we explored the complexities that microservice architectures bring to the development process and learned how contract testing can help with the verification of </span><span class="No-Break"><span class="koboSpan" id="kobo.991.1">API integrations.</span></span></p>
<p><span class="koboSpan" id="kobo.992.1">We learned how to use the Pact tools to write contract tests using the same techniques and processes that developers use for unit testing. </span><span class="koboSpan" id="kobo.992.2">Finally, we explored how we might split up the monolithic </span><strong class="source-inline"><span class="koboSpan" id="kobo.993.1">BookSwap</span></strong><span class="koboSpan" id="kobo.994.1"> application, including which services, endpoints, and contract tests we </span><span class="No-Break"><span class="koboSpan" id="kobo.995.1">would write.</span></span></p>
<p><span class="koboSpan" id="kobo.996.1">In </span><a href="B18371_09.xhtml#_idTextAnchor197"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.997.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.998.1">, </span><em class="italic"><span class="koboSpan" id="kobo.999.1">Challenges of Testing Concurrent Code</span></em><span class="koboSpan" id="kobo.1000.1">, we will tackle the complex topic of concurrency in Go. </span><span class="koboSpan" id="kobo.1000.2">We will learn the fundamentals of concurrency in Go and then explore the testing challenges that </span><span class="No-Break"><span class="koboSpan" id="kobo.1001.1">concurrency introduces.</span></span></p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor194"/><span class="koboSpan" id="kobo.1002.1">Questions</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1003.1">What is the difference between functional and non-functional testing? </span></li>
<li><span class="koboSpan" id="kobo.1004.1">What are some key metrics that performance testing should measure? </span></li>
<li><span class="koboSpan" id="kobo.1005.1">How does performance testing ensure that the system is scalable? </span></li>
<li><span class="koboSpan" id="kobo.1006.1">What are some of the benefits of microservice architectures? </span><span class="koboSpan" id="kobo.1006.2">What types of complexity are introduced by </span><span class="No-Break"><span class="koboSpan" id="kobo.1007.1">microservice architectures?</span></span></li>
<li><span class="koboSpan" id="kobo.1008.1">What is </span><span class="No-Break"><span class="koboSpan" id="kobo.1009.1">contract testing?</span></span></li>
</ol>
<h1 id="_idParaDest-174"><a id="_idTextAnchor195"/><span class="koboSpan" id="kobo.1010.1">Further reading</span></h1>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.1011.1">Web Application Security: Exploitation and Countermeasures for Modern Web Applications</span></em><span class="koboSpan" id="kobo.1012.1">, Andrew Hoffman, published </span><span class="No-Break"><span class="koboSpan" id="kobo.1013.1">by O’Reilly</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1014.1">Production-Ready Microservices: Building Standardized Systems Across an Engineering Organization</span></em><span class="koboSpan" id="kobo.1015.1">, Susan J. </span><span class="koboSpan" id="kobo.1015.2">Fowler, published </span><span class="No-Break"><span class="koboSpan" id="kobo.1016.1">by O’Reilly</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1017.1">Building Microservices: Designing Fine-Grained Systems</span></em><span class="koboSpan" id="kobo.1018.1">, Sam Newman, published </span><span class="No-Break"><span class="koboSpan" id="kobo.1019.1">by O’Reilly</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1020.1">Monolith to Microservices: Evolutionary Patterns to Transform Your Monolith</span></em><span class="koboSpan" id="kobo.1021.1">, Sam Newman, published </span><span class="No-Break"><span class="koboSpan" id="kobo.1022.1">by O’Reilly</span></span></li>
</ul>
</div>


<div class="Content" id="_idContainer078">
<h1 id="_idParaDest-175"><a id="_idTextAnchor196"/><span class="koboSpan" id="kobo.1.1">Part 3: Advanced Testing Techniques</span></h1>
<p><span class="koboSpan" id="kobo.2.1">The final part is dedicated to discussing the more challenging aspects of testing complex Go code, as all the tools and techniques required for testing applications are provided by the previous two sections. </span><span class="koboSpan" id="kobo.2.2">We begin our exploration by learning about Go concurrency mechanisms and what the concurrency untestable conditions are, including how to use Go’s race detector. </span><span class="koboSpan" id="kobo.2.3">Then, we revisit and expand our testing of edge cases by making use of fuzz tests and property-based testing, allowing us to test our code with a large amount of input to ensure that it is robust. </span><span class="koboSpan" id="kobo.2.4">Finally, we explore how to leverage Go’s recently introduced generics capability to write code that can work with different types, learn how to change table-driven tests to verify generic code, and leverage generics to create custom test utilities. </span></p>
<p><span class="koboSpan" id="kobo.3.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">following chapters:</span></span></p>
<ul>
<li><a href="B18371_09.xhtml#_idTextAnchor197"><em class="italic"><span class="koboSpan" id="kobo.5.1">Chapter 9</span></em></a><em class="italic"><span class="koboSpan" id="kobo.6.1">, Challenges of Testing Concurrent Code</span></em></li>
<li><a href="B18371_10.xhtml#_idTextAnchor218"><em class="italic"><span class="koboSpan" id="kobo.7.1">Chapter 10</span></em></a><em class="italic"><span class="koboSpan" id="kobo.8.1">, Testing Edge Cases</span></em></li>
<li><a href="B18371_11.xhtml#_idTextAnchor231"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 11</span></em></a><em class="italic"><span class="koboSpan" id="kobo.10.1">, Working with Generics</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer079">
</div>
</div>
</body></html>