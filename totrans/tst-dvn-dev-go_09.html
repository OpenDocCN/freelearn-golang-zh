<html><head></head><body>
<div id="_idContainer089">
<h1 class="chapter-number" id="_idParaDest-176"><a id="_idTextAnchor197"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-177"><a id="_idTextAnchor198"/><span class="koboSpan" id="kobo.2.1">Challenges of Testing Concurrent Code</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapters, we covered all of the essentials knowledge that TDD practitioners will need to test their applications. </span><span class="koboSpan" id="kobo.3.2">We learned how to unit test our code in the development phase, how to integration test our larger components, and how to end-to-end test our entire services. </span><span class="koboSpan" id="kobo.3.3">These are essential building blocks for building and running any software project. </span><span class="koboSpan" id="kobo.3.4">The test suite allows us to verify that our application is functioning according to the </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">client’s requirements.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">As the system grows and matures, developers then must inevitably consider how to change and evolve their code, ensuring that their system remains performant and scalable. </span><span class="koboSpan" id="kobo.5.2">As discussed in </span><a href="B18371_07.xhtml#_idTextAnchor162"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Refactoring in Go</span></em><span class="koboSpan" id="kobo.9.1">, there are some common refactoring techniques that we can use to make the code change process easier. </span><span class="koboSpan" id="kobo.9.2">One common system refactoring technique is breaking up monolithic applications and replacing them with microservice architectures. </span><span class="koboSpan" id="kobo.9.3">In </span><a href="B18371_08.xhtml#_idTextAnchor179"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.10.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.11.1">, </span><em class="italic"><span class="koboSpan" id="kobo.12.1">Testing Microservice Architectures</span></em><span class="koboSpan" id="kobo.13.1">, we learned how to split up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.14.1">BookSwap</span></strong><span class="koboSpan" id="kobo.15.1"> application and test the integrations between microservices with the newly introduced technique of </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">contract testing.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">As we step into the world of microservice architectures, testing gets more difficult due to two crucial aspects: services are changed by teams within the organization without any central oversight and the operation order can no longer be guaranteed. </span><span class="koboSpan" id="kobo.17.2">We covered the integration testing aspects in previous chapters, but we are yet to explore the difficulties brought on by the variations in operation order. </span><span class="koboSpan" id="kobo.17.3">Most importantly, we need to explore how to handle the different states that varying operation orders can put an application in. </span></p>
<p><span class="koboSpan" id="kobo.18.1">This chapter will explore the implementation and testing of concurrent code. </span><span class="koboSpan" id="kobo.18.2">We will begin by discussing Go’s concurrency mechanisms, which are one of the main advantages of the Go programming language. </span><span class="koboSpan" id="kobo.18.3">Then, we will explore some common concurrency examples. </span><span class="koboSpan" id="kobo.18.4">We will learn how to make use of Go’s race detector, which is part of the Go toolchain. </span><span class="koboSpan" id="kobo.18.5">Finally, we will discuss what concurrency conditions cannot be tested and see how we can detect concurrency issues in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.19.1">BookSwap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.20.1"> application.</span></span></p>
<p><span class="koboSpan" id="kobo.21.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.23.1">Go’s concurrency mechanisms – goroutines, channels, and </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">synchronization primitives</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Applied concurrency examples and patterns, including creating thread-safe </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">data structures</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">Untestable conditions of concurrent code – race conditions, deadlocks, </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">and starvation</span></span></li>
<li><span class="koboSpan" id="kobo.29.1">The usage and limitations of the Go </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">race detector</span></span></li>
<li><span class="koboSpan" id="kobo.31.1">Detecting and fixing concurrency issues in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.32.1">BookSwap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.33.1"> application</span></span></li>
</ul>
<h1 id="_idParaDest-178"><a id="_idTextAnchor199"/><span class="koboSpan" id="kobo.34.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.35.1">You will need to have </span><strong class="bold"><span class="koboSpan" id="kobo.36.1">Go version 1.19</span></strong><span class="koboSpan" id="kobo.37.1"> or later installed to run the code samples in this chapter. </span><span class="koboSpan" id="kobo.37.2">The installation process is described on the official Go documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">at </span></span><a href="https://go.dev/doc/install"><span class="No-Break"><span class="koboSpan" id="kobo.39.1">https://go.dev/doc/install</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.40.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">The code examples included in this book are publicly available </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">at </span></span><a href="https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter09"><span class="No-Break"><span class="koboSpan" id="kobo.43.1">https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter09</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.44.1">.</span></span></p>
<h1 id="_idParaDest-179"><a id="_idTextAnchor200"/><span class="koboSpan" id="kobo.45.1">Concurrency mechanisms in Go</span></h1>
<p><span class="koboSpan" id="kobo.46.1">Go’s in-built concurrency mechanisms</span><a id="_idIndexMarker728"/><span class="koboSpan" id="kobo.47.1"> are one of its biggest strengths and are often one of the main reasons developers choose to use Go</span><a id="_idIndexMarker729"/><span class="koboSpan" id="kobo.48.1"> for their services. </span><span class="koboSpan" id="kobo.48.2">Implementing</span><a id="_idIndexMarker730"/><span class="koboSpan" id="kobo.49.1"> concurrency in Go is easy (and painless!) due to its </span><strong class="bold"><span class="koboSpan" id="kobo.50.1">goroutines</span></strong><span class="koboSpan" id="kobo.51.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.52.1">channels</span></strong><span class="koboSpan" id="kobo.53.1">. </span><span class="koboSpan" id="kobo.53.2">In this section, we will explore each mechanism and review its behavior so that we can better understand how to use and </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">test them.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.55.1">Concurrency</span></strong><span class="koboSpan" id="kobo.56.1"> is a program’s ability to process</span><a id="_idIndexMarker731"/><span class="koboSpan" id="kobo.57.1"> multiple tasks at the same time. </span><span class="koboSpan" id="kobo.57.2">This crucial ability allows us to get the most out of the CPU processing power, allowing us to make optimal use of our resources. </span><span class="koboSpan" id="kobo.57.3">This is important in all systems in order to be able to process as many requests as possible, without disrupting other flows in the program and keep computing </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">costs low.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.59.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.60.1">.1</span></em><span class="koboSpan" id="kobo.61.1"> depicts two concurrent tasks: </span></p>
<div>
<div class="IMG---Figure" id="_idContainer080">
<span class="koboSpan" id="kobo.62.1"><img alt="Figure 9.1 – Concurrent execution flow of two tasks " src="image/Figure_9.1_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.63.1">Figure 9.1 – Concurrent execution flow of two tasks</span></p>
<p><span class="koboSpan" id="kobo.64.1">The tasks are divided into functions</span><a id="_idIndexMarker732"/><span class="koboSpan" id="kobo.65.1"> that form a </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">call stack:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.67.1">In this example, each task is divided into three functions that make up the call stack. </span><span class="koboSpan" id="kobo.67.2">The task begins when it receives its input and finishes when it has computed its result or output. </span><strong class="bold"><span class="koboSpan" id="kobo.68.1">Task A</span></strong><span class="koboSpan" id="kobo.69.1"> is divided into three functions: </span><strong class="bold"><span class="koboSpan" id="kobo.70.1">Function A1</span></strong><span class="koboSpan" id="kobo.71.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.72.1">Function A2</span></strong><span class="koboSpan" id="kobo.73.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.74.1">Function A3</span></strong><span class="koboSpan" id="kobo.75.1">. </span><span class="koboSpan" id="kobo.75.2">This separation is the same in </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.76.1">Task B</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.78.1">The two tasks, </span><strong class="bold"><span class="koboSpan" id="kobo.79.1">Task A</span></strong><span class="koboSpan" id="kobo.80.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.81.1">Task B</span></strong><span class="koboSpan" id="kobo.82.1">, are independent of each other. </span><span class="koboSpan" id="kobo.82.2">Each task receives its own input and calculates its own result. </span><span class="koboSpan" id="kobo.82.3">As the tasks are not connected, they can be</span><a id="_idIndexMarker733"/><span class="koboSpan" id="kobo.83.1"> computed in any order. </span><span class="koboSpan" id="kobo.83.2">This makes them suitable for executing as part of a </span><strong class="bold"><span class="koboSpan" id="kobo.84.1">concurrent </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.85.1">execution flow</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.87.1">When executing the tasks concurrently, subtasks are </span><strong class="bold"><span class="koboSpan" id="kobo.88.1">scheduled</span></strong><span class="koboSpan" id="kobo.89.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.90.1">interrupted</span></strong><span class="koboSpan" id="kobo.91.1"> for the most efficient execution. </span><span class="koboSpan" id="kobo.91.2">The ability to interrupt the functions in the call stack is a key requirement for the concurrent execution of these two tasks. </span><span class="koboSpan" id="kobo.91.3">We will learn how to prevent these interruptions in the following sections. </span></li>
<li><span class="koboSpan" id="kobo.92.1">Each task begins when its input is received. </span><span class="koboSpan" id="kobo.92.2">In this example, </span><strong class="bold"><span class="koboSpan" id="kobo.93.1">Input A</span></strong><span class="koboSpan" id="kobo.94.1"> is received before </span><strong class="bold"><span class="koboSpan" id="kobo.95.1">Input B</span></strong><span class="koboSpan" id="kobo.96.1"> and its corresponding </span><strong class="bold"><span class="koboSpan" id="kobo.97.1">Task A</span></strong><span class="koboSpan" id="kobo.98.1"> starts </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">execution first.</span></span></li>
<li><span class="koboSpan" id="kobo.100.1">The subtasks, or functions, are executed in an interleaving way, with the CPU executing functions from </span><strong class="bold"><span class="koboSpan" id="kobo.101.1">Task A</span></strong><span class="koboSpan" id="kobo.102.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.103.1">Task B</span></strong><span class="koboSpan" id="kobo.104.1"> in a combined way. </span><span class="koboSpan" id="kobo.104.2">We notice that the subtasks are executed in order within the task. </span><span class="koboSpan" id="kobo.104.3">This means that </span><strong class="bold"><span class="koboSpan" id="kobo.105.1">Function A1</span></strong><span class="koboSpan" id="kobo.106.1"> is executed before </span><strong class="bold"><span class="koboSpan" id="kobo.107.1">Function A2</span></strong><span class="koboSpan" id="kobo.108.1">, but there are </span><strong class="bold"><span class="koboSpan" id="kobo.109.1">no order guarantees</span></strong><span class="koboSpan" id="kobo.110.1"> with regard to timing when it comes to the subtasks of </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.111.1">Task B</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.113.1">Once the task is completed successfully, the output is returned and the CPU is free to execute other tasks. </span><span class="koboSpan" id="kobo.113.2">We notice that even though </span><strong class="bold"><span class="koboSpan" id="kobo.114.1">Input B</span></strong><span class="koboSpan" id="kobo.115.1"> arrives second and </span><strong class="bold"><span class="koboSpan" id="kobo.116.1">Task B</span></strong><span class="koboSpan" id="kobo.117.1"> starts second, it completes first and </span><strong class="bold"><span class="koboSpan" id="kobo.118.1">Result B</span></strong><span class="koboSpan" id="kobo.119.1"> is returned first. </span><span class="koboSpan" id="kobo.119.2">The scheduling of the functions depends on the availability of resources and other factors. </span><span class="koboSpan" id="kobo.119.3">We will explore how scheduling works in Go in </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">later sections.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.121.1">Since there are no order guarantees</span><a id="_idIndexMarker734"/><span class="koboSpan" id="kobo.122.1"> between concurrently running tasks, we should be careful that the tasks we allow to run concurrently are independent and do not rely on each other. </span><span class="koboSpan" id="kobo.122.2">Otherwise, the concurrent execution of the tasks could lead to slow-running tasks or bugs. </span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.123.1">Avoid ordering assumptions</span></p>
<p class="callout"><span class="koboSpan" id="kobo.124.1">Concurrency</span><a id="_idIndexMarker735"/><span class="koboSpan" id="kobo.125.1"> can be used under the hood in libraries, and it might not always be straightforward to see where it is used. </span><span class="koboSpan" id="kobo.125.2">Therefore, we should avoid making assumptions about ordering or execution time. </span><span class="koboSpan" id="kobo.125.3">We will learn how to make use of synchronization mechanisms and checks to ensure that conditions are met before execution </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">is started.</span></span></p>
<p><span class="koboSpan" id="kobo.127.1">Parallelism is often confused</span><a id="_idIndexMarker736"/><span class="koboSpan" id="kobo.128.1"> with concurrency, but it is a program’s ability to execute tasks simultaneously. </span><span class="koboSpan" id="kobo.128.2">Unlike concurrency, which does not guarantee task ordering, we know that the task execution in this pattern will be happening in parallel. </span><span class="koboSpan" id="kobo.128.3">Tasks should also be independent of each other, as they cannot wait for each other. </span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.129.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.130.1">.2</span></em><span class="koboSpan" id="kobo.131.1"> depicts two </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">parallel tasks:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer081">
<span class="koboSpan" id="kobo.133.1"><img alt="Figure 9.2 – Parallel execution flow of two tasks " src="image/Figure_9.2_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.134.1">Figure 9.2 – Parallel execution flow of two tasks</span></p>
<p><span class="koboSpan" id="kobo.135.1">The parallel execution flow of two tasks </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">happens simultaneously:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.137.1">The tasks begin executing once </span><strong class="bold"><span class="koboSpan" id="kobo.138.1">Input A</span></strong><span class="koboSpan" id="kobo.139.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.140.1">Input B</span></strong><span class="koboSpan" id="kobo.141.1"> are received. </span></li>
<li><span class="koboSpan" id="kobo.142.1">The tasks are executed simultaneously and independently, without interruption </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">or interleaving.</span></span></li>
<li><span class="koboSpan" id="kobo.144.1">The tasks are completed at the same time, within a margin of error. </span><span class="koboSpan" id="kobo.144.2">There will always be deviations in resource usage and performance regardless of how much we attempt to specify them to </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">be identical.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.146.1">In order to achieve</span><a id="_idIndexMarker737"/><span class="koboSpan" id="kobo.147.1"> true parallelism, separate computing resources are required. </span><span class="koboSpan" id="kobo.147.2">This increases the cost of our system infrastructure, which is undesirable, if not a dealbreaker, for some engineering teams. </span><span class="koboSpan" id="kobo.147.3">Therefore, concurrency is often the preferred way to achieve multitasking in programs. </span><span class="koboSpan" id="kobo.147.4">As the system becomes successful, properly implemented concurrency can facilitate a smooth transition to parallelism when the system can handle such </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">increased costs.</span></span></p>
<p><span class="koboSpan" id="kobo.149.1">In Go, the concurrent</span><a id="_idIndexMarker738"/><span class="koboSpan" id="kobo.150.1"> processing of functions or subtasks is executed using </span><strong class="bold"><span class="koboSpan" id="kobo.151.1">goroutines</span></strong><span class="koboSpan" id="kobo.152.1">. </span><span class="koboSpan" id="kobo.152.2">We will look at what they are, how they are scheduled, and how to synchronize them in the </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">following sections.</span></span></p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor201"/><span class="koboSpan" id="kobo.154.1">Goroutines</span></h2>
<p><span class="koboSpan" id="kobo.155.1">Now that we understand</span><a id="_idIndexMarker739"/><span class="koboSpan" id="kobo.156.1"> the difference between concurrency and parallelism, we will focus our attention on the implementation of concurrency in Go for the remainder of </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">this chapter.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.158.1">Goroutines</span></strong><span class="koboSpan" id="kobo.159.1"> are functions or methods that can run concurrently</span><a id="_idIndexMarker740"/><span class="koboSpan" id="kobo.160.1"> with other functions or methods. </span><span class="koboSpan" id="kobo.160.2">They are often referred to as </span><strong class="bold"><span class="koboSpan" id="kobo.161.1">lightweight threads</span></strong><span class="koboSpan" id="kobo.162.1">, as they have a small memory allocation and run over a much smaller number of OS threads. </span></p>
<p><span class="koboSpan" id="kobo.163.1">It is easy to instruct the Go runtime to run a function in its own goroutine by using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">go</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.165.1"> keyword:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.166.1">func greet(gr string) </span></strong><span class="koboSpan" id="kobo.167.1">{
  fmt.Println("Hello, friend!")
}
 
func main() {
</span><strong class="bold"><span class="koboSpan" id="kobo.168.1">  go greet()</span></strong><span class="koboSpan" id="kobo.169.1">
  fmt.Println("Goodbye, friend!")
}</span></pre>
<p><span class="koboSpan" id="kobo.170.1">This code snippet creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">main</span></strong><span class="koboSpan" id="kobo.172.1"> function and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">greet</span></strong><span class="koboSpan" id="kobo.174.1"> function, which takes a string as a parameter and then prints it to the terminal. </span><span class="koboSpan" id="kobo.174.2">We instruct the runtime to run the function in its own goroutine by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">go</span></strong><span class="koboSpan" id="kobo.176.1"> keyword in front of its invocation. </span><span class="koboSpan" id="kobo.176.2">At the end, we print the “Goodbye, friend!” </span><span class="koboSpan" id="kobo.176.3">line to signal that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">main</span></strong><span class="koboSpan" id="kobo.178.1"> function has </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">been completed.</span></span></p>
<p><span class="koboSpan" id="kobo.180.1">We run this little program using the usual command: </span></p>
<pre class="console"><span class="koboSpan" id="kobo.181.1">
$ go run chapter09/concurrency/goroutines/main.go 
Goodbye, friend!</span></pre>
<p><span class="koboSpan" id="kobo.182.1">The program does not print the greeting; instead, it only prints the goodbye line. </span><span class="koboSpan" id="kobo.182.2">This is due to the behavior of programs</span><a id="_idIndexMarker741"/><span class="koboSpan" id="kobo.183.1"> and goroutines. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.184.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.185.1">.3</span></em><span class="koboSpan" id="kobo.186.1"> presents a visualization of </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">these properties:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer082">
<span class="koboSpan" id="kobo.188.1"><img alt="Figure 9.3 – Goroutine execution of the greeting program " src="image/Figure_9.3_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.189.1">Figure 9.3 – Goroutine execution of the greeting program</span></p>
<p><span class="koboSpan" id="kobo.190.1">The program</span><a id="_idIndexMarker742"/><span class="koboSpan" id="kobo.191.1"> does not print the greeting to the terminal because of the intended </span><strong class="bold"><span class="koboSpan" id="kobo.192.1">non-blocking behavior</span></strong><span class="koboSpan" id="kobo.193.1"> of goroutine creation: </span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.194.1">The main function starts when we run our program. </span><span class="koboSpan" id="kobo.194.2">This function</span><a id="_idIndexMarker743"/><span class="koboSpan" id="kobo.195.1"> runs in its own goroutine, which we will refer to as the </span><strong class="bold"><span class="koboSpan" id="kobo.196.1">main goroutine</span></strong><span class="koboSpan" id="kobo.197.1">. </span><span class="koboSpan" id="kobo.197.2">The main function has its own </span><strong class="bold"><span class="koboSpan" id="kobo.198.1">execution time</span></strong><span class="koboSpan" id="kobo.199.1"> based on the statements</span><a id="_idIndexMarker744"/><span class="koboSpan" id="kobo.200.1"> contained inside the body of the </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">main function.</span></span></li>
<li><span class="koboSpan" id="kobo.202.1">During main function execution, the main goroutine instructs the Go runtime to </span><strong class="bold"><span class="koboSpan" id="kobo.203.1">create a goroutine</span></strong><span class="koboSpan" id="kobo.204.1"> and run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">greet</span></strong><span class="koboSpan" id="kobo.206.1"> function in this goroutine. </span><span class="koboSpan" id="kobo.206.2">This main goroutine has a </span><strong class="bold"><span class="koboSpan" id="kobo.207.1">parent-child relationship</span></strong><span class="koboSpan" id="kobo.208.1"> with the main goroutine. </span><span class="koboSpan" id="kobo.208.2">We will refer</span><a id="_idIndexMarker745"/><span class="koboSpan" id="kobo.209.1"> to this child goroutine as the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.210.1">greet goroutine</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.212.1">The creation of the child</span><a id="_idIndexMarker746"/><span class="koboSpan" id="kobo.213.1"> goroutine, which will run our </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">greet</span></strong><span class="koboSpan" id="kobo.215.1"> function, is a </span><strong class="bold"><span class="koboSpan" id="kobo.216.1">non-blocking operation</span></strong><span class="koboSpan" id="kobo.217.1">. </span><span class="koboSpan" id="kobo.217.2">This allows us to achieve the multitasking aspect of concurrency that we </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">previously discussed.</span></span></li>
<li><span class="koboSpan" id="kobo.219.1">As the main goroutine is not blocked, it finishes its own work and completes its execution time. </span><span class="koboSpan" id="kobo.219.2">Once the main goroutine has completed, the Go runtime cleans up all of its resources. </span><span class="koboSpan" id="kobo.219.3">As the main goroutine has a parent-child relationship with the greet goroutine, the runtime </span><strong class="bold"><span class="koboSpan" id="kobo.220.1">kills the </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.221.1">greet goroutine</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.223.1">The greet goroutine immediately stops execution and </span><strong class="bold"><span class="koboSpan" id="kobo.224.1">shuts down</span></strong><span class="koboSpan" id="kobo.225.1">. </span><span class="koboSpan" id="kobo.225.2">Depending on how much execution time it has received from the CPU, the greet goroutine may be able to execute its print to the terminal </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">or not.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.227.1">Due to these properties, the program</span><a id="_idIndexMarker747"/><span class="koboSpan" id="kobo.228.1"> does not manage to reliably print the greeting to the terminal. </span><span class="koboSpan" id="kobo.228.2">We need to stop the main goroutine from shutting down in order to give time for the child goroutine to finish its execution. </span></p>
<p><span class="koboSpan" id="kobo.229.1">One solution is to block the main goroutine from terminating by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">time.Sleep</span></strong><span class="koboSpan" id="kobo.231.1"> function for a predetermined amount of time, such as 1 second. </span><span class="koboSpan" id="kobo.231.2">Another, more interesting, solution is to signal that the greet goroutine has completed its work by writing a value to a shared variable: </span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.232.1">var finished bool</span></strong><span class="koboSpan" id="kobo.233.1">
func greet() {
  fmt.Println("Hello, friend!")
  </span><strong class="bold"><span class="koboSpan" id="kobo.234.1">finished = true</span></strong><span class="koboSpan" id="kobo.235.1">
}
 
func main() {
  go greet()
  </span><strong class="bold"><span class="koboSpan" id="kobo.236.1">for !finished {</span></strong><span class="koboSpan" id="kobo.237.1">
    fmt.Println("Child goroutine not finished.")
    </span><strong class="bold"><span class="koboSpan" id="kobo.238.1">time.Sleep(10 * time.Millisecond)</span></strong><span class="koboSpan" id="kobo.239.1">
  }
  fmt.Println("Child goroutine finished.")
  fmt.Println("Goodbye, friend!")
}</span></pre>
<p><span class="koboSpan" id="kobo.240.1">The two functions</span><a id="_idIndexMarker748"/><span class="koboSpan" id="kobo.241.1"> share memory space, so it is possible for them to write and read to shared variables. </span><span class="koboSpan" id="kobo.241.2">The code snippet demonstrates this: </span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.242.1">We create a variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">bool</span></strong><span class="koboSpan" id="kobo.244.1"> type at the top, named </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">finished</span></strong><span class="koboSpan" id="kobo.246.1">. </span><span class="koboSpan" id="kobo.246.2">The purpose of this variable is to provide a signal to the main function that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">greet</span></strong><span class="koboSpan" id="kobo.248.1"> function has completed. </span></li>
<li><span class="koboSpan" id="kobo.249.1">Once the greet function writes its greeting to the terminal, it sets the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">finished</span></strong><span class="koboSpan" id="kobo.251.1"> variable </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">true</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.255.1">Inside the body of the main function, we create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">for</span></strong><span class="koboSpan" id="kobo.257.1"> loop, which will execute until the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">finished</span></strong><span class="koboSpan" id="kobo.259.1"> variable is </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">true</span></strong><span class="koboSpan" id="kobo.261.1">. </span><span class="koboSpan" id="kobo.261.2">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">time.Sleep</span></strong><span class="koboSpan" id="kobo.263.1"> function, we poll the value of the variable every </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">10 milliseconds.</span></span></li>
<li><span class="koboSpan" id="kobo.265.1">Once the </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">for</span></strong><span class="koboSpan" id="kobo.267.1"> loop completes, the main goroutine completes its execution and all of the resources of both goroutines are </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">cleaned up.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.269.1">Running this program will print </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.271.1">
$ go run chapter09/concurrency/goroutines/main.go
</span><strong class="bold"><span class="koboSpan" id="kobo.272.1">Child goroutine not finished.</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.273.1">Hello, friend!</span></strong><span class="koboSpan" id="kobo.274.1">
Child goroutine finished.
</span><span class="koboSpan" id="kobo.274.2">Goodbye, friend!</span></pre>
<p><span class="koboSpan" id="kobo.275.1">Finally, using this simple approach of writing to a shared variable, we have managed to block the main goroutine until its child goroutine finishes. </span><span class="koboSpan" id="kobo.275.2">We are finally able to see the greeting printed in the terminal and the program is executing correctly. </span></p>
<p><span class="koboSpan" id="kobo.276.1">This way of sharing</span><a id="_idIndexMarker749"/><span class="koboSpan" id="kobo.277.1"> information between goroutines is known as </span><strong class="bold"><span class="koboSpan" id="kobo.278.1">communicating by sharing memory</span></strong><span class="koboSpan" id="kobo.279.1"> and it is the traditional way to deal with concurrency in other programming languages. </span><span class="koboSpan" id="kobo.279.2">This approach</span><a id="_idIndexMarker750"/><span class="koboSpan" id="kobo.280.1"> is not without drawbacks. </span><span class="koboSpan" id="kobo.280.2">However, Go has another approach, which we will explore in the next section. </span></p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor202"/><span class="koboSpan" id="kobo.281.1">Channels</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.282.1">Channels</span></strong><span class="koboSpan" id="kobo.283.1"> provide another way for goroutines</span><a id="_idIndexMarker751"/><span class="koboSpan" id="kobo.284.1"> to communicate with one another. </span><span class="koboSpan" id="kobo.284.2">We can think of the in-built channel type as a pipe through which we can safely send information between goroutines, without having to use</span><a id="_idIndexMarker752"/><span class="koboSpan" id="kobo.285.1"> shared variables or memory. </span><span class="koboSpan" id="kobo.285.2">In Go, this principle is known as </span><strong class="bold"><span class="koboSpan" id="kobo.286.1">sharing memory </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.287.1">by communicating</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.289.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.290.1">.4</span></em><span class="koboSpan" id="kobo.291.1"> depicts the main operations and syntax </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">of channels:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer083">
<span class="koboSpan" id="kobo.293.1"><img alt="Figure 9.4 – Operations and syntax of Go channels " src="image/Figure_9.4_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.294.1">Figure 9.4 – Operations and syntax of Go channels</span></p>
<p><span class="koboSpan" id="kobo.295.1">The interaction with the channel demonstrates the syntax of its two </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">main operations:</span></span></p>
<ol>
<li value="1"><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">ch chan bool</span></strong><span class="koboSpan" id="kobo.298.1">: The channel is a built-in type in Go, so it does not require us to import any libraries. </span><span class="koboSpan" id="kobo.298.2">A channel is declared using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">chan</span></strong><span class="koboSpan" id="kobo.300.1"> keyword followed by a data type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">bool</span></strong><span class="koboSpan" id="kobo.302.1">, which the channel will be able to transport. </span><span class="koboSpan" id="kobo.302.2">Only this type of variable can be transported through it. </span><span class="koboSpan" id="kobo.302.3">This is compiler enforced.  </span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">ch &lt;- true</span></strong><span class="koboSpan" id="kobo.304.1">: The first operation</span><a id="_idIndexMarker753"/><span class="koboSpan" id="kobo.305.1"> that channels support is the </span><strong class="bold"><span class="koboSpan" id="kobo.306.1">send operation</span></strong><span class="koboSpan" id="kobo.307.1">. </span><span class="koboSpan" id="kobo.307.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.308.1">channel operator</span></strong><span class="koboSpan" id="kobo.309.1"> looks like an arrow, </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">&lt;-</span></strong><span class="koboSpan" id="kobo.311.1">, and indicates the way</span><a id="_idIndexMarker754"/><span class="koboSpan" id="kobo.312.1"> that the data is flowing through the channel. </span><span class="koboSpan" id="kobo.312.2">In this case, the arrow points toward the channel where we send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">true</span></strong><span class="koboSpan" id="kobo.314.1"> value </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">to it.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">f :=  &lt;-ch</span></strong><span class="koboSpan" id="kobo.317.1">: The  counterpart to the send operation is the receive operation. </span><span class="koboSpan" id="kobo.317.2">This operation is performed by pointing the channel operator away from the channel and allocating the receive to a local variable named </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">f</span></strong><span class="koboSpan" id="kobo.319.1">. </span></li>
</ol>
<p><span class="koboSpan" id="kobo.320.1">This is the basic usage</span><a id="_idIndexMarker755"/><span class="koboSpan" id="kobo.321.1"> of channels, although we will explore some further subtleties in later sections. </span><span class="koboSpan" id="kobo.321.2">The send and receive operations are </span><strong class="bold"><span class="koboSpan" id="kobo.322.1">blocking and synchronous</span></strong><span class="koboSpan" id="kobo.323.1">, so both parties of the transaction need to be available for the operations to complete. </span></p>
<p><span class="koboSpan" id="kobo.324.1">Channels are a great </span><strong class="bold"><span class="koboSpan" id="kobo.325.1">synchronization and communication mechanism</span></strong><span class="koboSpan" id="kobo.326.1">. </span><span class="koboSpan" id="kobo.326.2">We can make use of them to synchronize</span><a id="_idIndexMarker756"/><span class="koboSpan" id="kobo.327.1"> our main and greeter goroutines using more concise code: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.328.1">
func </span><strong class="bold"><span class="koboSpan" id="kobo.329.1">greet(ch chan bool)</span></strong><span class="koboSpan" id="kobo.330.1"> {
  fmt.Println("Hello, friend!")
</span><strong class="bold"><span class="koboSpan" id="kobo.331.1">  ch &lt;- true</span></strong><span class="koboSpan" id="kobo.332.1">
}
func main() {
</span><strong class="bold"><span class="koboSpan" id="kobo.333.1">  ch := make(chan bool)</span></strong><span class="koboSpan" id="kobo.334.1">
  go greet(ch)
</span><strong class="bold"><span class="koboSpan" id="kobo.335.1">  &lt;-ch</span></strong><span class="koboSpan" id="kobo.336.1">
  fmt.Println("Child goroutine finished.")
  fmt.Println("Goodbye, friend!")
}</span></pre>
<p><span class="koboSpan" id="kobo.337.1">This simplified version of the solution makes use of a channel to synchronize the </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">two goroutines:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.339.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">greet</span></strong><span class="koboSpan" id="kobo.341.1"> function is changed to take in a channel parameter. </span><span class="koboSpan" id="kobo.341.2">Similarly, for maps and slices, the channel type has a built-in pointer reference, so we do not need to explicitly pass it by pointer using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">&amp;</span></strong><span class="koboSpan" id="kobo.343.1"> operator. </span></li>
<li><span class="koboSpan" id="kobo.344.1">Once the greeting is printed, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">greet</span></strong><span class="koboSpan" id="kobo.346.1"> function sends the </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">true</span></strong><span class="koboSpan" id="kobo.348.1"> value to the channel. </span><span class="koboSpan" id="kobo.348.2">This will signal to the main goroutine that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">greet</span></strong><span class="koboSpan" id="kobo.350.1"> function has </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">successfully completed.</span></span></li>
<li><span class="koboSpan" id="kobo.352.1">Inside the main function, we initialize a channel using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">make</span></strong><span class="koboSpan" id="kobo.354.1"> function. </span><span class="koboSpan" id="kobo.354.2">The zero value of the channel type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">nil</span></strong><span class="koboSpan" id="kobo.356.1">, so we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">make</span></strong><span class="koboSpan" id="kobo.358.1"> function to create a channel that is ready to use. </span><span class="koboSpan" id="kobo.358.2">Under the hood, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">make</span></strong><span class="koboSpan" id="kobo.360.1"> function will allocate all the resources required. </span></li>
<li><span class="koboSpan" id="kobo.361.1"> Once the </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">greet</span></strong><span class="koboSpan" id="kobo.363.1"> function has been started in its own goroutine, the main function invokes the receive operation on the channel. </span><span class="koboSpan" id="kobo.363.2">Since the send and receive operations on channels are blocking, this will block the main goroutine until the </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">greet</span></strong><span class="koboSpan" id="kobo.365.1"> goroutine has completed and has been able to send the value through the channel. </span></li>
</ol>
<p><span class="koboSpan" id="kobo.366.1">The use of channels has simplified</span><a id="_idIndexMarker757"/><span class="koboSpan" id="kobo.367.1"> the implementation by removing the need to poll for the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">finished</span></strong><span class="koboSpan" id="kobo.369.1"> variable. </span><span class="koboSpan" id="kobo.369.2">We also notice that the channel variable, </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">ch</span></strong><span class="koboSpan" id="kobo.371.1">, has been initialized inside the main function and been passed as a parameter. </span><span class="koboSpan" id="kobo.371.2">Since there is now no global variable, we have removed the need to communicate by sharing memory between the two goroutines. </span></p>
<p><span class="koboSpan" id="kobo.372.1">Channels support one final operation, the close operation. </span><span class="koboSpan" id="kobo.372.2">Unlike sends and receives, closing a channel changes the state of the channel and indicates the completion of work to the channel’s receivers. </span><span class="koboSpan" id="kobo.372.3">It is an operation that can be used for the purpose of synchronization, as opposed to supporting information exchange and communication between goroutines. </span><span class="koboSpan" id="kobo.372.4">A closed channel will immediately return the zero value of the channel type to all receive operations and cause a panic on all send operations that are attempted on the channel in the future. </span></p>
<p><span class="koboSpan" id="kobo.373.1">Since the purpose of our channel is to synchronize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">greet</span></strong><span class="koboSpan" id="kobo.375.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">main</span></strong><span class="koboSpan" id="kobo.377.1"> goroutines, we can make use of the close operation to further simplify </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">our code:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.379.1">func greet(ch chan struct{})</span></strong><span class="koboSpan" id="kobo.380.1"> {
  fmt.Println("Hello, friend!")
</span><strong class="bold"><span class="koboSpan" id="kobo.381.1">  close(ch)</span></strong><span class="koboSpan" id="kobo.382.1">
}
 
func main() {
</span><strong class="bold"><span class="koboSpan" id="kobo.383.1">  ch := make(chan struct{})</span></strong><span class="koboSpan" id="kobo.384.1">
  go greet(ch)
  &lt;-ch
  fmt.Println("Child goroutine finished.")
  fmt.Println("Goodbye, friend!")
}</span></pre>
<p><span class="koboSpan" id="kobo.385.1">There are a few tweaks we have made</span><a id="_idIndexMarker758"/><span class="koboSpan" id="kobo.386.1"> to our solution. </span><span class="koboSpan" id="kobo.386.2">The data type of the channel is now the empty </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">struct{}</span></strong><span class="koboSpan" id="kobo.388.1">, which reduces the memory footprint of the channel. </span><span class="koboSpan" id="kobo.388.2">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">greet</span></strong><span class="koboSpan" id="kobo.390.1"> function, we close the channel immediately after the function prints its greeting. </span><span class="koboSpan" id="kobo.390.2">While these changes do not seem significant, this solution will work for signaling to multiple receivers that work has completed, as opposed to having to write multiple values on the channel. </span><span class="koboSpan" id="kobo.390.3">This is a powerful mechanism that we can make use of to solve a variety </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">of problems.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.392.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.393.1">.5</span></em><span class="koboSpan" id="kobo.394.1"> summarizes the behavior</span><a id="_idIndexMarker759"/><span class="koboSpan" id="kobo.395.1"> of the channels we have studied </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">so far:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer084">
<span class="koboSpan" id="kobo.397.1"><img alt="Figure 9.5 – Summary of channel operations and states " src="image/Figure_9.5_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.398.1">Figure 9.5 – Summary of channel operations and states</span></p>
<p><span class="koboSpan" id="kobo.399.1">This figure is a useful reference for understanding</span><a id="_idIndexMarker760"/><span class="koboSpan" id="kobo.400.1"> how channels will behave in our code: </span></p>
<ol>
<li value="1"><strong class="bold"><span class="koboSpan" id="kobo.401.1">Nil channels</span></strong><span class="koboSpan" id="kobo.402.1"> are channels that have not been correctly initialized using</span><a id="_idIndexMarker761"/><span class="koboSpan" id="kobo.403.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">make</span></strong><span class="koboSpan" id="kobo.405.1"> function. </span><span class="koboSpan" id="kobo.405.2">They cannot be used to send information but are useful for passing to goroutines when those goroutines are started. </span><span class="koboSpan" id="kobo.405.3">The nil channel will be initialized for use at a </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">future time</span></span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">:</span></span><ol><li><span class="koboSpan" id="kobo.408.1">Send operations will block until the channel is initialized, after which the rules for initialized </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">channels apply.</span></span></li><li><span class="koboSpan" id="kobo.410.1">Receive operations behave identically to </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">send operations.</span></span></li><li><span class="koboSpan" id="kobo.412.1">Close operations panic on nil channels. </span><span class="koboSpan" id="kobo.412.2">As nil channels are not ready to send information through, it would not make sense to close them. </span><span class="koboSpan" id="kobo.412.3">It is therefore considered a fatal error if we attempt to close </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">nil channels.</span></span></li></ol></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.414.1">Initialized channels</span></strong><span class="koboSpan" id="kobo.415.1"> are created using the make function</span><a id="_idIndexMarker762"/><span class="koboSpan" id="kobo.416.1"> and are ready to be used. </span><span class="koboSpan" id="kobo.416.2">They are ready for sending </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">information through:</span></span><ol><li><span class="koboSpan" id="kobo.418.1">Send operations will block until a receiver arrives. </span><span class="koboSpan" id="kobo.418.2">The sending goroutine will not be able to execute past this point until the operation completes. </span></li><li><span class="koboSpan" id="kobo.419.1">Receive operations will block until a value arrives from the sender. </span><span class="koboSpan" id="kobo.419.2">As sends and receives are synchronous operations, both goroutines must be ready to complete the operation for the two parts of the transaction to be completed. </span><span class="koboSpan" id="kobo.419.3">So, if the sender starts up but the receiver is not yet ready, this will mean the sender halts until the receiver is ready, which can be a </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">helpful property.</span></span></li><li><span class="koboSpan" id="kobo.421.1">Close operations complete immediately. </span><span class="koboSpan" id="kobo.421.2">Once the first operation completes, the channel will move into the </span><strong class="bold"><span class="koboSpan" id="kobo.422.1">Closed Channel</span></strong><span class="koboSpan" id="kobo.423.1"> state. </span></li></ol></li>
<li><span class="koboSpan" id="kobo.424.1">Closed channels are initialized channels</span><a id="_idIndexMarker763"/><span class="koboSpan" id="kobo.425.1"> that have been successfully closed. </span><span class="koboSpan" id="kobo.425.2">Channels in this state signal that they will no longer be able to </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">transport information:</span></span><ol><li><span class="koboSpan" id="kobo.427.1">Send operations will panic. </span><span class="koboSpan" id="kobo.427.2">There is no easy way to know whether a channel is closed, so the panic lets senders know that they should stop sending values to it, but you should code carefully in order to avoid encountering </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">a panic.</span></span></li><li><span class="koboSpan" id="kobo.429.1">Receive operations will immediately complete with the zero value of the channel’s data type. </span><span class="koboSpan" id="kobo.429.2">As we have seen in our greeter example, we can use the receive operation on closed channels as a synchronization mechanism. </span></li><li><span class="koboSpan" id="kobo.430.1">Close operations will panic, as channels can only move into the closed state once. </span><span class="koboSpan" id="kobo.430.2">Again, defensive coding (for example, the single responsibility principle where only one part of your code</span><a id="_idIndexMarker764"/><span class="koboSpan" id="kobo.431.1"> is responsible for closing the channel) can help to </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">control this.</span></span></li></ol></li>
</ol>
<p><span class="koboSpan" id="kobo.433.1">One final aspect to note</span><a id="_idIndexMarker765"/><span class="koboSpan" id="kobo.434.1"> is that once a channel is closed, it cannot be opened again. </span><span class="koboSpan" id="kobo.434.2">This can create some complications when using them when solving more complicated problems. </span><span class="koboSpan" id="kobo.434.3">Now that we understand the fundamental behavior of goroutines and channels, we can explore some commonly applied concurrency examples in the next section. </span></p>
<h1 id="_idParaDest-182"><a id="_idTextAnchor203"/><span class="koboSpan" id="kobo.435.1">Applied concurrency examples</span></h1>
<p><span class="koboSpan" id="kobo.436.1">So far, we have learned</span><a id="_idIndexMarker766"/><span class="koboSpan" id="kobo.437.1"> about the main operations and behavior of goroutines and channels. </span><span class="koboSpan" id="kobo.437.2">These two concurrency mechanisms are important to understand, as they are pivotal to how Go implements concurrency. </span><span class="koboSpan" id="kobo.437.3">However, the Go standard library also includes concurrency primitives in its </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">sync</span></strong><span class="koboSpan" id="kobo.439.1"> package. </span><span class="koboSpan" id="kobo.439.2">It contains synchronization primitives with a broad variety of uses: </span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">sync.Map</span></strong><span class="koboSpan" id="kobo.441.1"> is a map implementation that is safe</span><a id="_idIndexMarker767"/><span class="koboSpan" id="kobo.442.1"> for concurrent use. </span><span class="koboSpan" id="kobo.442.2">We will explore how to create other thread-safe data structures in the next section. </span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">sync.Mutex</span></strong><span class="koboSpan" id="kobo.444.1"> is an exclusion lock. </span><span class="koboSpan" id="kobo.444.2">It allows us to gatekeep</span><a id="_idIndexMarker768"/><span class="koboSpan" id="kobo.445.1"> resources for usage by one goroutine at a time. </span><span class="koboSpan" id="kobo.445.2">It is also possible to take a read-only or a read-write mutex depending on the problem </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">being solved.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">sync.Once</span></strong><span class="koboSpan" id="kobo.448.1"> is a specialized lock that can only be acquired</span><a id="_idIndexMarker769"/><span class="koboSpan" id="kobo.449.1"> once. </span><span class="koboSpan" id="kobo.449.2">This is useful for wrapping around statements, such as cleanup code, which should only </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">run once.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">sync.Pool</span></strong><span class="koboSpan" id="kobo.452.1"> is a temporary set of objects that are individually</span><a id="_idIndexMarker770"/><span class="koboSpan" id="kobo.453.1"> saved and retrieved. </span><span class="koboSpan" id="kobo.453.2">It can be seen as a cache of objects, making it easy to create thread-safe lists. </span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">sync.WaitGroup</span></strong><span class="koboSpan" id="kobo.455.1"> waits for a collection of goroutines to</span><a id="_idIndexMarker771"/><span class="koboSpan" id="kobo.456.1"> finish. </span><span class="koboSpan" id="kobo.456.2">This primitive has a counter and a lock under the hood, allowing it to keep track of how many goroutines it will need to wait for before completing. </span><span class="koboSpan" id="kobo.456.3">This can greatly simplify a </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">main goroutine.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.458.1">You can read the full documentation</span><a id="_idIndexMarker772"/><span class="koboSpan" id="kobo.459.1"> of the synchronization primitives of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">sync</span></strong><span class="koboSpan" id="kobo.461.1"> package in the</span><a id="_idIndexMarker773"/><span class="koboSpan" id="kobo.462.1"> official Golang documentation (</span><a href="https://pkg.go.dev/sync"><span class="koboSpan" id="kobo.463.1">https://pkg.go.dev/sync</span></a><span class="koboSpan" id="kobo.464.1">). </span><span class="koboSpan" id="kobo.464.2">These well-designed synchronization primitives give us the tools to solve many types of problems. </span><span class="koboSpan" id="kobo.464.3">Let us have a look at some of them in action in the next sections. </span></p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor204"/><span class="koboSpan" id="kobo.465.1">Closing once</span></h2>
<p><span class="koboSpan" id="kobo.466.1">As we saw in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.467.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.468.1">.5</span></em><span class="koboSpan" id="kobo.469.1">, channels panic</span><a id="_idIndexMarker774"/><span class="koboSpan" id="kobo.470.1"> if we attempt to close a channel multiple times. </span><span class="koboSpan" id="kobo.470.2">This is a great candidate for using </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">sync.Once</span></strong><span class="koboSpan" id="kobo.472.1">, although we can imagine</span><a id="_idIndexMarker775"/><span class="koboSpan" id="kobo.473.1"> other great uses of this mechanism, such as implementing the </span><strong class="bold"><span class="koboSpan" id="kobo.474.1">Singleton pattern</span></strong><span class="koboSpan" id="kobo.475.1"> or executing clean-up functions. </span></p>
<p><span class="koboSpan" id="kobo.476.1">This specialized lock is easy to use to ensure that a channel is only closed once: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.477.1">
func safelyClose(</span><strong class="bold"><span class="koboSpan" id="kobo.478.1">once *sync.Once</span></strong><span class="koboSpan" id="kobo.479.1">, ch chan struct{}) {
  fmt.Println("Hello, friend!")
  </span><strong class="bold"><span class="koboSpan" id="kobo.480.1">once.Do(func() {</span></strong><span class="koboSpan" id="kobo.481.1">
    fmt.Println("Channel closed.")
</span><strong class="bold"><span class="koboSpan" id="kobo.482.1">    </span></strong><strong class="bold"><span class="koboSpan" id="kobo.483.1">close(ch)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.484.1">  })</span></strong><span class="koboSpan" id="kobo.485.1">
}
func main() {
  </span><strong class="bold"><span class="koboSpan" id="kobo.486.1">var once sync.Once</span></strong><span class="koboSpan" id="kobo.487.1">
  ch := make(chan struct{})
  for i := 0; i&lt;3; i++ {
</span><strong class="bold"><span class="koboSpan" id="kobo.488.1">    go safelyClose(&amp;once, ch)</span></strong><span class="koboSpan" id="kobo.489.1">
  }
</span><strong class="bold"><span class="koboSpan" id="kobo.490.1">  &lt;-ch</span></strong><span class="koboSpan" id="kobo.491.1">
  fmt.Println("Goodbye, friend!")
}</span></pre>
<p><span class="koboSpan" id="kobo.492.1">We implement the safe closing</span><a id="_idIndexMarker776"/><span class="koboSpan" id="kobo.493.1"> of a channel by wrapping it around the close operation: </span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.494.1">We create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">safelyClose</span></strong><span class="koboSpan" id="kobo.496.1"> function, which takes in a pointer to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">sync.Once</span></strong><span class="koboSpan" id="kobo.498.1"> type and the channel created by the main function. </span><span class="koboSpan" id="kobo.498.2">Note that unlike the channel type, we need to pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">Once</span></strong><span class="koboSpan" id="kobo.500.1"> type using explicit parameter </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">pointer types.</span></span></li>
<li><span class="koboSpan" id="kobo.502.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">safelyClose</span></strong><span class="koboSpan" id="kobo.504.1"> function, we call the close operation on the channel inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">once.Do</span></strong><span class="koboSpan" id="kobo.506.1"> method. </span><span class="koboSpan" id="kobo.506.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">Do</span></strong><span class="koboSpan" id="kobo.508.1"> method takes a function as a parameter, so we wrap our statement inside an </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">anonymous function.</span></span></li>
<li><span class="koboSpan" id="kobo.510.1">Inside the main function, we create a zero-value </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">sync.Once</span></strong><span class="koboSpan" id="kobo.512.1"> instance. </span><span class="koboSpan" id="kobo.512.2">There is no special initialization we need to undertake with synchronization primitives, so the zero value is ready </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">for use.</span></span></li>
<li><span class="koboSpan" id="kobo.514.1">We create multiple goroutines that execute the </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">safelyClose</span></strong><span class="koboSpan" id="kobo.516.1"> function using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">for</span></strong><span class="koboSpan" id="kobo.518.1"> loop. </span><span class="koboSpan" id="kobo.518.2">These goroutines all share the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">once</span></strong><span class="koboSpan" id="kobo.520.1"> and channel instances. </span></li>
<li><span class="koboSpan" id="kobo.521.1">Finally, we block the main goroutine with a receive operation from the channel. </span><span class="koboSpan" id="kobo.521.2">This operation will complete as soon as the first goroutine closes the channel. </span></li>
</ol>
<p><span class="koboSpan" id="kobo.522.1">Running the example program shows that multiple goroutines are started, but the channel is closed only once: </span></p>
<pre class="console"><span class="koboSpan" id="kobo.523.1">
$ go run chapter09/concurrency/once/main.go
</span><strong class="bold"><span class="koboSpan" id="kobo.524.1">Hello, friend!</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.525.1">Channel closed.</span></strong><span class="koboSpan" id="kobo.526.1">
Hello, friend!
</span><span class="koboSpan" id="kobo.526.2">Goodbye, friend!
</span><span class="koboSpan" id="kobo.526.3">Hello, friend! </span></pre>
<p><span class="koboSpan" id="kobo.527.1">As we can see from the output, multiple goroutines are started, but the channel is only closed once. </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">sync.Once</span></strong><span class="koboSpan" id="kobo.529.1"> is simple to use, but it can help</span><a id="_idIndexMarker777"/><span class="koboSpan" id="kobo.530.1"> us build safety around operations that should only be executed once, such as closing </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">a channel.</span></span></p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor205"/><span class="koboSpan" id="kobo.532.1">Thread-safe data structures</span></h2>
<p><span class="koboSpan" id="kobo.533.1">Another frequent</span><a id="_idIndexMarker778"/><span class="koboSpan" id="kobo.534.1"> problem that engineers solve is building </span><strong class="bold"><span class="koboSpan" id="kobo.535.1">thread-safe data structures</span></strong><span class="koboSpan" id="kobo.536.1">. </span><span class="koboSpan" id="kobo.536.2">These types of structures are safe for reading and writing by multiple goroutines. </span><span class="koboSpan" id="kobo.536.3">By default, Go’s slices and maps are not safe for concurrent use, so we will need to be mindful of multiple goroutines accessing shared data structures and resources. </span><span class="koboSpan" id="kobo.536.4">This is one of the reasons why communicating using channels, which are thread safe, is preferred to communicating via shared memory, represented by data structures </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">or variables.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">sync.Map</span></strong><span class="koboSpan" id="kobo.539.1"> (</span><a href="https://pkg.go.dev/sync#Map"><span class="koboSpan" id="kobo.540.1">https://pkg.go.dev/sync#Map</span></a><span class="koboSpan" id="kobo.541.1">) is an implementation of a map</span><a id="_idIndexMarker779"/><span class="koboSpan" id="kobo.542.1"> that is thread safe. </span><span class="koboSpan" id="kobo.542.2">This map</span><a id="_idIndexMarker780"/><span class="koboSpan" id="kobo.543.1"> uses locks under the hood, so it will not be as performant as the built-in map type. </span><span class="koboSpan" id="kobo.543.2">The synchronized map exposes methods providing reading and </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">writing functionality:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.545.1">const workerCount = 3</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.546.1">func greet(id int, smap *sync.Map, done chan struct{}) </span></strong><span class="koboSpan" id="kobo.547.1">{
  g := fmt.Sprintf("Hello, friend! </span><span class="koboSpan" id="kobo.547.2">I'm Goroutine %d.", id)
</span><strong class="bold"><span class="koboSpan" id="kobo.548.1">  </span></strong><strong class="bold"><span class="koboSpan" id="kobo.549.1">smap.Store(id, g)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.550.1">  done &lt;- struct{}{}</span></strong><span class="koboSpan" id="kobo.551.1">
}
func main() {
</span><strong class="bold"><span class="koboSpan" id="kobo.552.1">  var smap sync.Map</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.553.1">  done := make(chan struct{})</span></strong><span class="koboSpan" id="kobo.554.1">
  for i := 0; i &lt; workerCount; i++ {
</span><strong class="bold"><span class="koboSpan" id="kobo.555.1">    go greet(i, &amp;smap, done)</span></strong><span class="koboSpan" id="kobo.556.1">
  }
  for i := 0; i &lt; workerCount; i++ {
</span><strong class="bold"><span class="koboSpan" id="kobo.557.1">    &lt;-done</span></strong><span class="koboSpan" id="kobo.558.1">
  }
  </span><strong class="bold"><span class="koboSpan" id="kobo.559.1">smap.Range(func(key, value any) bool </span></strong><span class="koboSpan" id="kobo.560.1">{
    fmt.Println(value)
    return true
  })
  fmt.Println("Goodbye, friend!")
}</span></pre>
<p><span class="koboSpan" id="kobo.561.1">We interact with the synchronized</span><a id="_idIndexMarker781"/><span class="koboSpan" id="kobo.562.1"> map through </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">wrapper methods:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.564.1">We declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">workerCount</span></strong><span class="koboSpan" id="kobo.566.1"> constant at the top of the program, which will denote the number of goroutines we will be starting. </span></li>
<li><span class="koboSpan" id="kobo.567.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">greet</span></strong><span class="koboSpan" id="kobo.569.1"> function takes in three</span><a id="_idIndexMarker782"/><span class="koboSpan" id="kobo.570.1"> parameters: an ID, a pointer to </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">sync.Map</span></strong><span class="koboSpan" id="kobo.572.1">, and a channel for us to signal that the goroutine has finished its work. </span><span class="koboSpan" id="kobo.572.2">We format a greeting string, which makes use of the ID that was passed in. </span><span class="koboSpan" id="kobo.572.3">Then, we save it in the map using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">Store</span></strong><span class="koboSpan" id="kobo.574.1"> method and write a value to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">done</span></strong><span class="koboSpan" id="kobo.576.1"> channel to signal to the main goroutine that this worker goroutine has finished. </span></li>
<li><span class="koboSpan" id="kobo.577.1">Inside the main function, we initialize the map. </span><span class="koboSpan" id="kobo.577.2">The zero value of this map is ready for usage, just as we saw with </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">sync.Once</span></strong><span class="koboSpan" id="kobo.579.1"> earlier. </span><span class="koboSpan" id="kobo.579.2">We also initialize a channel, which we will use to signal to the main goroutine that the worker goroutines have completed. </span></li>
<li><span class="koboSpan" id="kobo.580.1">Then, we run through two </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">for</span></strong><span class="koboSpan" id="kobo.582.1"> loops. </span><span class="koboSpan" id="kobo.582.2">The first loop starts the </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">greet</span></strong><span class="koboSpan" id="kobo.584.1"> function in its own goroutine, while the second waits until values are received on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">done</span></strong><span class="koboSpan" id="kobo.586.1"> channel. </span><span class="koboSpan" id="kobo.586.2">This allows us to wait for all goroutines to complete before continuing. </span></li>
<li><span class="koboSpan" id="kobo.587.1">Finally, we read all the values contained in the map using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">Range</span></strong><span class="koboSpan" id="kobo.589.1"> method, which takes an anonymous function as a parameter. </span><span class="koboSpan" id="kobo.589.2">We print the entries and return </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">true</span></strong><span class="koboSpan" id="kobo.591.1">, which will allow the </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">Range</span></strong><span class="koboSpan" id="kobo.593.1"> method to </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">continue looping.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.595.1">The output of this program</span><a id="_idIndexMarker783"/><span class="koboSpan" id="kobo.596.1"> shows that the greetings can be saved and </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">retrieved concurrently:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.598.1">
$ go run chapter09/concurrency/syncmap/main.go 
Hello, friend! </span><span class="koboSpan" id="kobo.598.2">I'm Goroutine 2.
</span><span class="koboSpan" id="kobo.598.3">Hello, friend! </span><span class="koboSpan" id="kobo.598.4">I'm Goroutine 0.
</span><span class="koboSpan" id="kobo.598.5">Hello, friend! </span><span class="koboSpan" id="kobo.598.6">I'm Goroutine 1.
</span><span class="koboSpan" id="kobo.598.7">Goodbye, friend!</span></pre>
<p><span class="koboSpan" id="kobo.599.1">The built-in map type will panic when written to by multiple goroutines, so you should make sure to use the synchronized map in </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">this case.</span></span></p>
<p><span class="koboSpan" id="kobo.601.1">Similar to the approach of </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">sync.Map</span></strong><span class="koboSpan" id="kobo.603.1">, we can create our own</span><a id="_idIndexMarker784"/><span class="koboSpan" id="kobo.604.1"> thread-safe custom</span><a id="_idIndexMarker785"/><span class="koboSpan" id="kobo.605.1"> data structures by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">sync.Mutex</span></strong><span class="koboSpan" id="kobo.607.1"> lock to limit access to the underlying</span><a id="_idIndexMarker786"/><span class="koboSpan" id="kobo.608.1"> data structure. </span><span class="koboSpan" id="kobo.608.2">For example, we can create a thread-safe </span><strong class="bold"><span class="koboSpan" id="kobo.609.1">Last In First Out</span></strong><span class="koboSpan" id="kobo.610.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.611.1">LIFO</span></strong><span class="koboSpan" id="kobo.612.1">) stack by following </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">this approach:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.614.1">
// Thread safe LIFO Stack implementation
type Stack struct {
</span><strong class="bold"><span class="koboSpan" id="kobo.615.1">  lock sync.Mutex</span></strong><span class="koboSpan" id="kobo.616.1">
  data []string
}
// Push adds the given element to the end of the list
func (s *Stack) Push(el string) {
</span><strong class="bold"><span class="koboSpan" id="kobo.617.1">  defer s.lock.Unlock()</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.618.1">  s.lock.Lock()</span></strong><span class="koboSpan" id="kobo.619.1">
  s.data = append(s.data, el)
}
// Pop removes and returns the last element from the list,
// or an error if the list is empty.
</span><span class="koboSpan" id="kobo.619.2">func (s *Stack) Pop() (*string, error) {
</span><strong class="bold"><span class="koboSpan" id="kobo.620.1">  </span></strong><strong class="bold"><span class="koboSpan" id="kobo.621.1">defer s.lock.Unlock()</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.622.1">  s.lock.Lock()</span></strong><span class="koboSpan" id="kobo.623.1">
  if len(s.data) == 0 {
    return nil, fmt.Errorf("stack is empty")
  }
  last := s.data[len(s.data)-1]
  s.data = s.data[0 : len(s.data)-1]
  return &amp;last, nil
}</span></pre>
<p><span class="koboSpan" id="kobo.624.1">The stack</span><a id="_idIndexMarker787"/><span class="koboSpan" id="kobo.625.1"> implementation makes</span><a id="_idIndexMarker788"/><span class="koboSpan" id="kobo.626.1"> use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">sync.Mutex</span></strong><span class="koboSpan" id="kobo.628.1">, which exposes two methods, </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">Lock</span></strong><span class="koboSpan" id="kobo.630.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">Unlock</span></strong><span class="koboSpan" id="kobo.632.1">, to limit access to the underlying data slice: </span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.633.1">The custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">Stack</span></strong><span class="koboSpan" id="kobo.635.1"> struct has two fields, a lock and a data slice. </span><span class="koboSpan" id="kobo.635.2">These are unexported fields, as they should only be managed by the stack data </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">structure itself.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">Stack</span></strong><span class="koboSpan" id="kobo.638.1"> has two methods. </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">Push</span></strong><span class="koboSpan" id="kobo.640.1"> adds the element to the end of the data slice, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">Pop</span></strong><span class="koboSpan" id="kobo.642.1"> removes the last element from the data slice and returns it. </span><span class="koboSpan" id="kobo.642.2">If the slice is empty, then the </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">Pop</span></strong><span class="koboSpan" id="kobo.644.1"> method will return an error. </span></li>
<li><span class="koboSpan" id="kobo.645.1">Both functions make use of the lock that is of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">sync.Mutex</span></strong><span class="koboSpan" id="kobo.647.1"> type to ensure that both methods are called by one goroutine at a time. </span><span class="koboSpan" id="kobo.647.2">We make use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">defer</span></strong><span class="koboSpan" id="kobo.649.1"> keyword to ensure that the lock is released regardless of which execution path the method </span><span class="No-Break"><span class="koboSpan" id="kobo.650.1">goes through.</span></span></li>
</ol>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">sync.Mutex</span></strong><span class="koboSpan" id="kobo.652.1"> is a versatile locking</span><a id="_idIndexMarker789"/><span class="koboSpan" id="kobo.653.1"> mechanism that can be used to block access to any code segment that accesses shared resources</span><a id="_idIndexMarker790"/><span class="koboSpan" id="kobo.654.1"> or requires unique control of a resource. </span><span class="koboSpan" id="kobo.654.2">This is known as a </span><strong class="bold"><span class="koboSpan" id="kobo.655.1">critical </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.656.1">code section</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.658.1">Similarly, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">sync</span></strong><span class="koboSpan" id="kobo.660.1"> package also provides </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">sync.RWMutex</span></strong><span class="koboSpan" id="kobo.662.1">, which provides control of locking reads</span><a id="_idIndexMarker791"/><span class="koboSpan" id="kobo.663.1"> and writes separately. </span><span class="koboSpan" id="kobo.663.2">This level of control may be useful for creating thread-safe data structures that are used by many goroutines. </span></p>
<h2 id="_idParaDest-185"><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.664.1">Waiting for completion</span></h2>
<p><span class="koboSpan" id="kobo.665.1">The final synchronization</span><a id="_idIndexMarker792"/><span class="koboSpan" id="kobo.666.1"> primitive that we will explore in this section is </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">sync.WaitGroup</span></strong><span class="koboSpan" id="kobo.668.1">. </span><span class="koboSpan" id="kobo.668.2">Under the hood, </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">WaitGroup</span></strong><span class="koboSpan" id="kobo.670.1"> manages an inner counter that maintains how many resources are left to complete. </span><span class="koboSpan" id="kobo.670.2">This specialized lock allows us to wait for multiple goroutines to complete, allowing us to simplify our synchronized map example from the previous section: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.671.1">
const workerCount = 3
func greet(id int, smap *sync.Map, </span><strong class="bold"><span class="koboSpan" id="kobo.672.1">wg *sync.WaitGroup</span></strong><span class="koboSpan" id="kobo.673.1">) {
</span><strong class="bold"><span class="koboSpan" id="kobo.674.1">  defer wg.Done()</span></strong><span class="koboSpan" id="kobo.675.1">  
  g := fmt.Sprintf("Hello, friend! </span><span class="koboSpan" id="kobo.675.2">I'm Goroutine %d.", id)
  smap.Store(id, g)
}
func main() {
  var smap sync.Map
</span><strong class="bold"><span class="koboSpan" id="kobo.676.1">  var wg sync.WaitGroup</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.677.1">  wg.Add(workerCount)</span></strong><span class="koboSpan" id="kobo.678.1">
  for i := 0; i &lt; workerCount; i++ {
    go greet(i, &amp;smap, &amp;wg)
  }
</span><strong class="bold"><span class="koboSpan" id="kobo.679.1">  wg.Wait()</span></strong><span class="koboSpan" id="kobo.680.1">
  smap.Range(func(key, value any) bool {
    fmt.Println(value)
    return true
  })
  fmt.Println("Goodbye, friend!")
}</span></pre>
<p><span class="koboSpan" id="kobo.681.1">We have made a few key changes that greatly simplify our solution: </span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.682.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">greet</span></strong><span class="koboSpan" id="kobo.684.1"> function takes in a pointer to </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">sync.WaitGroup</span></strong><span class="koboSpan" id="kobo.686.1"> instead of the done channel. </span><span class="koboSpan" id="kobo.686.2">At the top of the function, we defer the </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">Done</span></strong><span class="koboSpan" id="kobo.688.1"> method on </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">WaitGroup</span></strong><span class="koboSpan" id="kobo.690.1">, which decreases its inner counter by 1, signaling that this goroutine has completed. </span></li>
<li><span class="koboSpan" id="kobo.691.1">Inside the main function, we initialize </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">sync.WaitGroup</span></strong><span class="koboSpan" id="kobo.693.1">, which is ready for use. </span><span class="koboSpan" id="kobo.693.2">We add </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">workerCount</span></strong><span class="koboSpan" id="kobo.695.1"> to the inner counter, signaling to it how many goroutines we will start. </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">WaitGroup</span></strong><span class="koboSpan" id="kobo.697.1"> will block until this inner counter reaches zero, which will happen as each child goroutine calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">Done</span></strong><span class="koboSpan" id="kobo.699.1"> method once as it finishes. </span></li>
<li><span class="koboSpan" id="kobo.700.1">Finally, we invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">Wait</span></strong><span class="koboSpan" id="kobo.702.1"> method further down in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">main</span></strong><span class="koboSpan" id="kobo.704.1"> function. </span><span class="koboSpan" id="kobo.704.2">This method will block until the inner counter of </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">WaitGroup</span></strong><span class="koboSpan" id="kobo.706.1"> reaches 0. </span><span class="koboSpan" id="kobo.706.2">This removes the need to read messages from our channel for each completed goroutine inside a </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">for</span></strong><span class="koboSpan" id="kobo.708.1"> loop. </span></li>
</ol>
<p><span class="koboSpan" id="kobo.709.1">This brings us to the end of our exploration of Go concurrency fundamentals and applications. </span><span class="koboSpan" id="kobo.709.2">As we have seen, Go concurrency</span><a id="_idIndexMarker793"/><span class="koboSpan" id="kobo.710.1"> makes use of goroutines, channels, and synchronization primitives. </span><span class="koboSpan" id="kobo.710.2">We can easily use locks to create thread-safe data structures and ensure that critical code sections are only accessed one goroutine at a time. </span><span class="koboSpan" id="kobo.710.3">In the next section, we will learn what problems the newly introduced aspect of concurrency brings to </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">our programs.</span></span></p>
<h1 id="_idParaDest-186"><a id="_idTextAnchor207"/><span class="koboSpan" id="kobo.712.1">Issues with concurrency</span></h1>
<p><span class="koboSpan" id="kobo.713.1">Writing concurrent code</span><a id="_idIndexMarker794"/><span class="koboSpan" id="kobo.714.1"> in Go is elegant and simple. </span><span class="koboSpan" id="kobo.714.2">However, it does make our code more complex. </span><span class="koboSpan" id="kobo.714.3">Developers need to be familiar with the behavior of concurrency mechanisms to understand the code they are reading. </span><span class="koboSpan" id="kobo.714.4">Furthermore, as timing plays a crucial part in how goroutines behave, we might have a hard time reproducing potential bugs. </span><span class="koboSpan" id="kobo.714.5">In this section, we look at three common concurrency issues. </span><span class="koboSpan" id="kobo.714.6">As we deep dive into each example, we will also have the opportunity to understand the behavior of Go’s concurrency mechanisms. </span></p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor208"/><span class="koboSpan" id="kobo.715.1">Data races</span></h2>
<p><span class="koboSpan" id="kobo.716.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.717.1">data race</span></strong><span class="koboSpan" id="kobo.718.1"> is the m</span><a id="_idTextAnchor209"/><span class="koboSpan" id="kobo.719.1">ost common concurrency issue. </span><span class="koboSpan" id="kobo.719.2">This issue</span><a id="_idIndexMarker795"/><span class="koboSpan" id="kobo.720.1"> occurs when multiple</span><a id="_idIndexMarker796"/><span class="koboSpan" id="kobo.721.1"> goroutines access and modify the same shared resource concurrently. </span><span class="koboSpan" id="kobo.721.2">This is one of the reasons why we should avoid sharing the state between goroutines, preferring to share information between goroutines using channels. </span></p>
<p><span class="koboSpan" id="kobo.722.1">We modify our previous greeting example by saving the formatted greetings into a slice, instead of immediately printing the greeting to </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">the terminal:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.724.1">const workerCount = 3</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.725.1">var greetings []string</span></strong><span class="koboSpan" id="kobo.726.1">
func greet(id int, wg *sync.WaitGroup) {
  defer wg.Done()
  g := fmt.Sprintf("Hello, friend! </span><span class="koboSpan" id="kobo.726.2">I'm Goroutine %d.", id)
</span><strong class="bold"><span class="koboSpan" id="kobo.727.1">  greetings = append(greetings, g)</span></strong><span class="koboSpan" id="kobo.728.1">
}
func main() {
  var wg sync.WaitGroup
  wg.Add(workerCount)
  for i := 0; i &lt; workerCount; i++ {
    go greet(i, &amp;wg)
  }
  wg.Wait()
</span><strong class="bold"><span class="koboSpan" id="kobo.729.1">  for _, g := range greetings {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.730.1">    fmt.Println(g)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.731.1">  }</span></strong><span class="koboSpan" id="kobo.732.1">
  fmt.Println("Goodbye, friend!")
}</span></pre>
<p><span class="koboSpan" id="kobo.733.1">At first glance, the code</span><a id="_idIndexMarker797"/><span class="koboSpan" id="kobo.734.1"> example hasn’t been modified</span><a id="_idIndexMarker798"/><span class="koboSpan" id="kobo.735.1"> very much: </span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.736.1">At the top of the program, we declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">greetings</span></strong><span class="koboSpan" id="kobo.738.1"> string slice that we will be saving the greetings into. </span><span class="koboSpan" id="kobo.738.2">We also declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">workerCount</span></strong><span class="koboSpan" id="kobo.740.1"> constant as </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">3</span></strong><span class="koboSpan" id="kobo.742.1">, which is how many goroutines we will be running. </span></li>
<li><span class="koboSpan" id="kobo.743.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">greet</span></strong><span class="koboSpan" id="kobo.745.1"> function takes in two parameters, the goroutine ID and a pointer to </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">sync.WaitGroup</span></strong><span class="koboSpan" id="kobo.747.1">. </span><span class="koboSpan" id="kobo.747.2">At the end of the function, we append the formatted greeting, </span><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">g</span></strong><span class="koboSpan" id="kobo.749.1">, to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">greetings</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.751.1"> slice.</span></span></li>
<li><span class="koboSpan" id="kobo.752.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">main</span></strong><span class="koboSpan" id="kobo.754.1"> function, we create </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">sync.WaitGroup</span></strong><span class="koboSpan" id="kobo.756.1"> and run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">greet</span></strong><span class="koboSpan" id="kobo.758.1"> function in multiple goroutines. </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">WaitGroup</span></strong><span class="koboSpan" id="kobo.760.1"> is used to ensure that the main goroutine waits for all of its worker goroutines to complete. </span><span class="koboSpan" id="kobo.760.2">At the end of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">main</span></strong><span class="koboSpan" id="kobo.762.1"> function, once all the </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">greet</span></strong><span class="koboSpan" id="kobo.764.1"> goroutines have completed, we loop over the </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">greetings</span></strong><span class="koboSpan" id="kobo.766.1"> slice and print each entry to </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">the terminal.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.768.1">As the </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">main</span></strong><span class="koboSpan" id="kobo.770.1"> function waits for all the goroutines to complete, we expect that all goroutines will have their greeting saved correctly. </span><span class="koboSpan" id="kobo.770.2">As </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">workerCount</span></strong><span class="koboSpan" id="kobo.772.1"> is equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">3</span></strong><span class="koboSpan" id="kobo.774.1">, we expect three lines to be printed to the terminal. </span><span class="koboSpan" id="kobo.774.2">Let us run this program in the usual way and see </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">its output:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.776.1">
$ go run chapter09/concurrency/data-races/main.go 
Hello, friend! </span><span class="koboSpan" id="kobo.776.2">I'm Goroutine 2.
</span><span class="koboSpan" id="kobo.776.3">Hello, friend! </span><span class="koboSpan" id="kobo.776.4">I'm Goroutine 1.
</span><span class="koboSpan" id="kobo.776.5">Goodbye, friend!</span></pre>
<p><span class="koboSpan" id="kobo.777.1">Looking at the output, we see</span><a id="_idIndexMarker799"/><span class="koboSpan" id="kobo.778.1"> only two goroutines have had their results recorded. </span><span class="koboSpan" id="kobo.778.2">We can </span><a id="_idIndexMarker800"/><span class="koboSpan" id="kobo.779.1">see that something has gone wrong with the code changes we have made. </span></p>
<p><span class="koboSpan" id="kobo.780.1">This code example suffers from a data race. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.781.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.782.1">.6</span></em><span class="koboSpan" id="kobo.783.1"> depicts the sequence of events happening in this example: </span></p>
<div>
<div class="IMG---Figure" id="_idContainer085">
<span class="koboSpan" id="kobo.784.1"><img alt="Figure 9.6 – The data race events " src="image/Figure_9.6_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.785.1">Figure 9.6 – The data race events</span></p>
<p><span class="koboSpan" id="kobo.786.1">As multiple goroutines attempt to append their results to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">greetings</span></strong><span class="koboSpan" id="kobo.788.1"> slice, they actually perform a few operations under </span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">the hood:</span></span></p>
<ol>
<li value="1"><strong class="bold"><span class="koboSpan" id="kobo.790.1">(1) Read </span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">greetings</span></strong><strong class="bold"><span class="koboSpan" id="kobo.792.1"> reference</span></strong><span class="koboSpan" id="kobo.793.1">: </span><strong class="bold"><span class="koboSpan" id="kobo.794.1">Goroutine 1</span></strong><span class="koboSpan" id="kobo.795.1"> begins its execution by reading the reference to the greetings slice. </span><span class="koboSpan" id="kobo.795.2">It will complete its operations based on </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">this value.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.797.1">(2) Read </span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">greetings</span></strong><strong class="bold"><span class="koboSpan" id="kobo.799.1"> reference</span></strong><span class="koboSpan" id="kobo.800.1">: At a later time, </span><strong class="bold"><span class="koboSpan" id="kobo.801.1">Goroutine 2</span></strong><span class="koboSpan" id="kobo.802.1"> begins its execution by reading the reference to the greetings slice. </span><span class="koboSpan" id="kobo.802.2">This may or may not be the same value that </span><strong class="bold"><span class="koboSpan" id="kobo.803.1">Goroutine 1</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.804.1">has read.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.805.1">(3) Write changed version</span></strong><span class="koboSpan" id="kobo.806.1">: During its execution, </span><strong class="bold"><span class="koboSpan" id="kobo.807.1">Goroutine 1</span></strong><span class="koboSpan" id="kobo.808.1"> is ready to write its changes and complete its execution. </span><span class="koboSpan" id="kobo.808.2">If there is space in the underlying array, the element is appended to it. </span><span class="koboSpan" id="kobo.808.3">Otherwise, a new, larger array is created and the elements are copied to it. </span><span class="koboSpan" id="kobo.808.4">A new slice is created with a reference to the updated underlying array. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.809.1">(4) Write changed version</span></strong><span class="koboSpan" id="kobo.810.1">: Finally, </span><strong class="bold"><span class="koboSpan" id="kobo.811.1">Goroutine 2</span></strong><span class="koboSpan" id="kobo.812.1"> is ready to write its changes as well. </span><span class="koboSpan" id="kobo.812.2">However, it is unaware of any changes that </span><strong class="bold"><span class="koboSpan" id="kobo.813.1">Goroutine 1</span></strong><span class="koboSpan" id="kobo.814.1"> has made up to this point. </span><span class="koboSpan" id="kobo.814.2">It is still working based on the reference that it has read at point </span><strong class="bold"><span class="koboSpan" id="kobo.815.1">2</span></strong><span class="koboSpan" id="kobo.816.1">. </span><strong class="bold"><span class="koboSpan" id="kobo.817.1">Goroutine 2</span></strong><span class="koboSpan" id="kobo.818.1"> writes its changes, overwriting all the work that </span><strong class="bold"><span class="koboSpan" id="kobo.819.1">Goroutine 1</span></strong><span class="koboSpan" id="kobo.820.1"> will have saved at point </span><strong class="bold"><span class="koboSpan" id="kobo.821.1">3</span></strong><span class="koboSpan" id="kobo.822.1">. </span></li>
</ol>
<p><span class="koboSpan" id="kobo.823.1">As the </span><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">greetings</span></strong><span class="koboSpan" id="kobo.825.1"> slice is not protected</span><a id="_idIndexMarker801"/><span class="koboSpan" id="kobo.826.1"> by locks, goroutines can be interrupted </span><a id="_idIndexMarker802"/><span class="koboSpan" id="kobo.827.1">at any point in this process. </span><span class="koboSpan" id="kobo.827.2">As these changes interleave, the goroutines can end up overwriting each other’s changes, leading to an inconsistent result. </span><span class="koboSpan" id="kobo.827.3">Depending on timing, your output may well look different from the preceding result. </span><span class="koboSpan" id="kobo.827.4">Also depending on the timing, we might see all of the greetings printed to the terminal and assume the program is functioning correctly, or we might see the inconsistent behavior we saw during our test run. </span><span class="koboSpan" id="kobo.827.5">Data races are commonly occurring issues in the world of concurrency and they can be hard to find </span><span class="No-Break"><span class="koboSpan" id="kobo.828.1">and replicate.</span></span></p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor210"/><span class="koboSpan" id="kobo.829.1">Deadlocks</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.830.1">Deadlocks</span></strong><span class="koboSpan" id="kobo.831.1"> are another common concurrency issue. </span><span class="koboSpan" id="kobo.831.2">This issue</span><a id="_idIndexMarker803"/><span class="koboSpan" id="kobo.832.1"> occurs when goroutines</span><a id="_idIndexMarker804"/><span class="koboSpan" id="kobo.833.1"> are blocked waiting for a resource that never becomes available. </span><span class="koboSpan" id="kobo.833.2">The goroutines will never be able to proceed. </span><span class="koboSpan" id="kobo.833.3">The Go runtime will detect when your program becomes blocked and trigger a panic, shutting down and cleaning </span><span class="No-Break"><span class="koboSpan" id="kobo.834.1">up resources.</span></span></p>
<p><span class="koboSpan" id="kobo.835.1">To fix our data race from the previous section, we’ll modify the code to make use of a channel to allow only one goroutine at a time to append to the </span><span class="No-Break"><span class="koboSpan" id="kobo.836.1">greetings slice:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.837.1">
var greetings []string
const workerCount = 3
func greet(id int, </span><strong class="bold"><span class="koboSpan" id="kobo.838.1">ch chan struct{}</span></strong><span class="koboSpan" id="kobo.839.1">, wg *sync.WaitGroup) {
  defer wg.Done()
  g := fmt.Sprintf("Hello, friend! </span><span class="koboSpan" id="kobo.839.2">I'm Goroutine %d.", id)
</span><strong class="bold"><span class="koboSpan" id="kobo.840.1">  &lt;-ch</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.841.1">  greetings = append(greetings, g)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.842.1">  ch &lt;- struct{}{}</span></strong><span class="koboSpan" id="kobo.843.1">
}
func main() {
  </span><strong class="bold"><span class="koboSpan" id="kobo.844.1">ch := make(chan struct{})</span></strong><span class="koboSpan" id="kobo.845.1">
  var wg sync.WaitGroup
  wg.Add(workerCount)
</span><strong class="bold"><span class="koboSpan" id="kobo.846.1">  for i := 0; i &lt; workerCount; i++ {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.847.1">    go greet(i, ch, &amp;wg)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.848.1">  }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.849.1">  ch &lt;- struct{}{}</span></strong><span class="koboSpan" id="kobo.850.1">
  wg.Wait()
  for _, g := range greetings {
    fmt.Println(g)
  }
  fmt.Println("Goodbye, friend!")
}</span></pre>
<p><span class="koboSpan" id="kobo.851.1">At first</span><a id="_idIndexMarker805"/><span class="koboSpan" id="kobo.852.1"> glance, the example</span><a id="_idIndexMarker806"/><span class="koboSpan" id="kobo.853.1"> seems reasonable: </span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.854.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.855.1">greet</span></strong><span class="koboSpan" id="kobo.856.1"> function takes in three parameters: an ID, a channel, and a pointer to </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">WaitGroup</span></strong><span class="koboSpan" id="kobo.858.1">. </span><span class="koboSpan" id="kobo.858.2">Inside the function, we read from the channel, append our greeting to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">greetings</span></strong><span class="koboSpan" id="kobo.860.1"> slice, then write to </span><span class="No-Break"><span class="koboSpan" id="kobo.861.1">the channel.</span></span></li>
<li><span class="koboSpan" id="kobo.862.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">main</span></strong><span class="koboSpan" id="kobo.864.1"> function, we initialize the channel and </span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">WaitGroup</span></strong><span class="koboSpan" id="kobo.866.1">. </span><span class="koboSpan" id="kobo.866.2">These are the synchronization mechanisms that our goroutines will use. </span></li>
<li><span class="koboSpan" id="kobo.867.1">We then write a </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">for</span></strong><span class="koboSpan" id="kobo.869.1"> loop, which will start as many goroutines running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">greet</span></strong><span class="koboSpan" id="kobo.871.1"> function as </span><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">workerCount</span></strong><span class="koboSpan" id="kobo.873.1">, which is three. </span></li>
<li><span class="koboSpan" id="kobo.874.1">After the loop, we send a value to the channel to get the first goroutine started. </span><span class="koboSpan" id="kobo.874.2">It also signals to the worker goroutines that the main goroutine is ready to process </span><span class="No-Break"><span class="koboSpan" id="kobo.875.1">their results.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.876.1">This seems like a reasonable</span><a id="_idIndexMarker807"/><span class="koboSpan" id="kobo.877.1"> technical solution that could ensure our data races</span><a id="_idIndexMarker808"/><span class="koboSpan" id="kobo.878.1"> are fixed. </span><span class="koboSpan" id="kobo.878.2">Let us run this program in the usual way and see its output: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.879.1">
$ go run chapter09/concurrency/deadlock/main.go
</span><strong class="bold"><span class="koboSpan" id="kobo.880.1">fatal error: all goroutines are asleep - deadlock!</span></strong><span class="koboSpan" id="kobo.881.1">
goroutine 1 [semacquire]:
</span><strong class="bold"><span class="koboSpan" id="kobo.882.1">sync.(*WaitGroup).Wait(0x0?)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.883.1">        /usr/local/go/src/sync/waitgroup.go:139 +0x52</span></strong><span class="koboSpan" id="kobo.884.1">
main.main()
        .../chapter09/deadlock/main.go:28 +0xd5
goroutine 19 [chan send]:
</span><strong class="bold"><span class="koboSpan" id="kobo.885.1">main.greet(0x0?, 0x0?, 0x0?)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.886.1">        .../chapter09/deadlock/main.go:17 +0x165</span></strong><span class="koboSpan" id="kobo.887.1">
created by main.main
        .../chapter09/deadlock/main.go:25 +0x4f
exit status 2</span></pre>
<p><span class="koboSpan" id="kobo.888.1">This program suffers from a deadlock, which is detected by the Go runtime. </span><span class="koboSpan" id="kobo.888.2">The stack trace indicates that two goroutines are blocked: </span></p>
<ul>
<li><span class="koboSpan" id="kobo.889.1">The main goroutine cannot complete the </span><strong class="source-inline"><span class="koboSpan" id="kobo.890.1">Wait</span></strong><span class="koboSpan" id="kobo.891.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.892.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">WaitGroup</span></strong></span></li>
<li><span class="koboSpan" id="kobo.894.1">One of the worker goroutines cannot complete its channel </span><span class="No-Break"><span class="koboSpan" id="kobo.895.1">send operation</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.896.1">This deadlock is caused by the synchronous nature of channel operations. </span><span class="koboSpan" id="kobo.896.2">The last worker goroutine tries to send to the channel and signal that its work has completed, but there is no remaining receiver on the channel. </span><span class="koboSpan" id="kobo.896.3">Due to this, the worker remains blocked, </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">WaitGroup</span></strong><span class="koboSpan" id="kobo.898.1"> never unblocks, and the whole program freezes. </span></p>
<p><span class="koboSpan" id="kobo.899.1">Common causes</span><a id="_idIndexMarker809"/><span class="koboSpan" id="kobo.900.1"> for goroutines becoming blocked are waiting to complete</span><a id="_idIndexMarker810"/><span class="koboSpan" id="kobo.901.1"> channel operations or waiting for one of the locks in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">sync</span></strong><span class="koboSpan" id="kobo.903.1"> package to become available. </span><span class="koboSpan" id="kobo.903.2">Understanding the behavior of the concurrency mechanisms we are using is the best tool for avoiding issues and bugs. </span></p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor211"/><span class="koboSpan" id="kobo.904.1">Buffered channels</span></h2>
<p><span class="koboSpan" id="kobo.905.1">By default, channels are </span><strong class="bold"><span class="koboSpan" id="kobo.906.1">unbuffered</span></strong><span class="koboSpan" id="kobo.907.1">, meaning that they have </span><a id="_idIndexMarker811"/><span class="koboSpan" id="kobo.908.1">no capacity</span><a id="_idIndexMarker812"/><span class="koboSpan" id="kobo.909.1"> to store or buffer</span><a id="_idIndexMarker813"/><span class="koboSpan" id="kobo.910.1"> values. </span><span class="koboSpan" id="kobo.910.2">This is why all the channel operations that we have seen so far have been </span><strong class="bold"><span class="koboSpan" id="kobo.911.1">synchronous</span></strong><span class="koboSpan" id="kobo.912.1">. </span><span class="koboSpan" id="kobo.912.2">However, this can be limiting for senders</span><a id="_idIndexMarker814"/><span class="koboSpan" id="kobo.913.1"> and receivers that operate at different speeds. </span><span class="koboSpan" id="kobo.913.2">A special kind of channel addresses this limitation. </span></p>
<p><span class="koboSpan" id="kobo.914.1">Buffered channels have the capacity to accept a predefined, limited number of values without</span><a id="_idIndexMarker815"/><span class="koboSpan" id="kobo.915.1"> a receiver. </span><span class="koboSpan" id="kobo.915.2">This allows us to process a limited number of </span><strong class="bold"><span class="koboSpan" id="kobo.916.1">asynchronous</span></strong><span class="koboSpan" id="kobo.917.1"> operations. </span><span class="koboSpan" id="kobo.917.2">The capacity of a channel is predefined, at initialization, with an optional parameter to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.918.1">make</span></strong><span class="koboSpan" id="kobo.919.1"> function: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.920.1">
ch := make(chan Type, capacity)</span></pre>
<p><span class="koboSpan" id="kobo.921.1">The capacity is an integer, which has a default value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">0</span></strong><span class="koboSpan" id="kobo.923.1"> for unbuffered channels. </span><span class="koboSpan" id="kobo.923.2">This parameter defines the size of the backing array that will save the </span><span class="No-Break"><span class="koboSpan" id="kobo.924.1">channel’s values.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.925.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.926.1">.7</span></em><span class="koboSpan" id="kobo.927.1"> depicts the send and receive operations on the two types </span><span class="No-Break"><span class="koboSpan" id="kobo.928.1">of channels:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer086">
<span class="koboSpan" id="kobo.929.1"><img alt="Figure 9.7 – Send and receive operations on channels " src="image/Figure_9.7_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.930.1">Figure 9.7 – Send and receive operations on channels</span></p>
<p><span class="koboSpan" id="kobo.931.1">The timing of operations</span><a id="_idIndexMarker816"/><span class="koboSpan" id="kobo.932.1"> is the key difference between the channels: </span></p>
<ul>
<li><span class="koboSpan" id="kobo.933.1">On </span><strong class="bold"><span class="koboSpan" id="kobo.934.1">unbuffered channels</span></strong><span class="koboSpan" id="kobo.935.1">, both the send and receive operations</span><a id="_idIndexMarker817"/><span class="koboSpan" id="kobo.936.1"> happen at the same time. </span><span class="koboSpan" id="kobo.936.2">The channel does not store any values and can only complete the operation once both the sender and receiver are available. </span></li>
<li><span class="koboSpan" id="kobo.937.1">On </span><strong class="bold"><span class="koboSpan" id="kobo.938.1">buffered channels</span></strong><span class="koboSpan" id="kobo.939.1">, the channel has a limited capacity</span><a id="_idIndexMarker818"/><span class="koboSpan" id="kobo.940.1"> buffer that can save values, if it has the capacity to do so. </span><span class="koboSpan" id="kobo.940.2">The send and receive operations complete at different times, as the channel saves the sender’s value in its buffer. </span><span class="koboSpan" id="kobo.940.3">Once the receiver is ready, it can read the available value from its buffer</span><a id="_idIndexMarker819"/><span class="koboSpan" id="kobo.941.1"> and pass it on to the receiver. </span></li>
<li><span class="koboSpan" id="kobo.942.1">When the buffer is at capacity, buffered channels will block send operations, behaving like an unbuffered channel until the buffer starts to be emptied by </span><span class="No-Break"><span class="koboSpan" id="kobo.943.1">the receiver.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.944.1">We can make use of buffered</span><a id="_idIndexMarker820"/><span class="koboSpan" id="kobo.945.1"> channels to allow the </span><strong class="source-inline"><span class="koboSpan" id="kobo.946.1">greet</span></strong><span class="koboSpan" id="kobo.947.1"> workers to complete</span><a id="_idIndexMarker821"/><span class="koboSpan" id="kobo.948.1"> as soon as they write their value, instead of waiting for the main goroutine to be available to receive </span><span class="No-Break"><span class="koboSpan" id="kobo.949.1">their values:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.950.1">
const workerCount = 3
func greet(id int, </span><strong class="bold"><span class="koboSpan" id="kobo.951.1">ch chan string</span></strong><span class="koboSpan" id="kobo.952.1">) {
</span><strong class="bold"><span class="koboSpan" id="kobo.953.1">  g := fmt.Sprintf("Hello, friend! </span><span class="koboSpan" id="kobo.953.2">I'm Goroutine %d.", id)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.954.1">  ch &lt;- g</span></strong><span class="koboSpan" id="kobo.955.1">
  fmt.Printf("Goroutine %d completed.\n", id)
}
func main() {
</span><strong class="bold"><span class="koboSpan" id="kobo.956.1">  ch := make(chan string, workerCount)</span></strong><span class="koboSpan" id="kobo.957.1">
  for i := 0; i &lt; workerCount; i++ {
</span><strong class="bold"><span class="koboSpan" id="kobo.958.1">    go greet(i, ch)</span></strong><span class="koboSpan" id="kobo.959.1">
  }
</span><strong class="bold"><span class="koboSpan" id="kobo.960.1">  fmt.Println(&lt;-ch)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.961.1">  fmt.Println(&lt;-ch)</span></strong><span class="koboSpan" id="kobo.962.1">
  fmt.Println("Goodbye, friend!")
}</span></pre>
<p><span class="koboSpan" id="kobo.963.1">This simple example demonstrates the usage of buffered channels: </span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.964.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.965.1">greet</span></strong><span class="koboSpan" id="kobo.966.1"> function takes in two parameters again: an ID and channel with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.967.1">string</span></strong><span class="koboSpan" id="kobo.968.1"> data type. </span><span class="koboSpan" id="kobo.968.2">The buffered channel has the same type as the unbuffered channel, so the </span><strong class="source-inline"><span class="koboSpan" id="kobo.969.1">greet</span></strong><span class="koboSpan" id="kobo.970.1"> function cannot detect whether it is using a buffered or unbuffered channel. </span></li>
<li><span class="koboSpan" id="kobo.971.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.972.1">greet</span></strong><span class="koboSpan" id="kobo.973.1"> function, we format the greeting and send it to the channel. </span></li>
<li><span class="koboSpan" id="kobo.974.1">At the top of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">main</span></strong><span class="koboSpan" id="kobo.976.1"> function, we initialize the buffered channel by passing </span><strong class="source-inline"><span class="koboSpan" id="kobo.977.1">workerCount</span></strong><span class="koboSpan" id="kobo.978.1"> as the capacity of the channel. </span><span class="koboSpan" id="kobo.978.2">Then, we start the greet function in its own goroutine inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.979.1">for</span></strong><span class="koboSpan" id="kobo.980.1"> loop, passing the index and the channel as the parameters of the function. </span></li>
<li><span class="koboSpan" id="kobo.981.1">Finally, we print and receive two values from the channel and terminate the program. </span></li>
</ol>
<p><span class="koboSpan" id="kobo.982.1">We run the program</span><a id="_idIndexMarker822"/><span class="koboSpan" id="kobo.983.1"> in the usual way</span><a id="_idIndexMarker823"/><span class="koboSpan" id="kobo.984.1"> to see how it behaves: </span></p>
<pre class="console"><span class="koboSpan" id="kobo.985.1">
$ go run chapter09/concurrency/buffered-channels/main.go 
Goroutine 1 completed.
</span><span class="koboSpan" id="kobo.985.2">Goroutine 2 completed.
</span><span class="koboSpan" id="kobo.985.3">Goroutine 0 completed.
</span><strong class="bold"><span class="koboSpan" id="kobo.986.1">Hello, friend! </span><span class="koboSpan" id="kobo.986.2">I'm Goroutine 2.</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.987.1">Hello, friend! </span><span class="koboSpan" id="kobo.987.2">I'm Goroutine 1.</span></strong><span class="koboSpan" id="kobo.988.1">
Goodbye, friend!</span></pre>
<p><span class="koboSpan" id="kobo.989.1">The program functions as intended: the worker goroutines complete immediately and the main goroutine prints two messages to the terminal, then completes successfully. </span><span class="koboSpan" id="kobo.989.2">However, this program does have an issue. </span><span class="koboSpan" id="kobo.989.3">The third greeting of the greeter goroutine is successfully sent to the channel but is never received. </span><span class="koboSpan" id="kobo.989.4">From the point of view of the greeter, its result was correctly sent and processed, when in fact the main goroutine never processed it. </span></p>
<p><span class="koboSpan" id="kobo.990.1">Since the receiver</span><a id="_idIndexMarker824"/><span class="koboSpan" id="kobo.991.1"> is only ready twice, our program has a </span><strong class="bold"><span class="koboSpan" id="kobo.992.1">leaked resource</span></strong><span class="koboSpan" id="kobo.993.1">, which is a resource that has not been released correctly. </span><span class="koboSpan" id="kobo.993.2">While the Go garbage collector will collect unused memory, we should avoid writing this kind of code, as it can cause issues and bugs if these operations are performed at scale. </span></p>
<p><span class="koboSpan" id="kobo.994.1">Buffered channels have a limited capacity to ensure that these types of resource leaks are avoided. </span><span class="koboSpan" id="kobo.994.2">They are often used to implement the </span><strong class="bold"><span class="koboSpan" id="kobo.995.1">worker pool concurrency pattern</span></strong><span class="koboSpan" id="kobo.996.1">, which is the implementation of a collection of goroutines</span><a id="_idIndexMarker825"/><span class="koboSpan" id="kobo.997.1"> waiting to repeatedly process jobs.  </span></p>
<p><span class="koboSpan" id="kobo.998.1">So far, we have discussed the behavior</span><a id="_idIndexMarker826"/><span class="koboSpan" id="kobo.999.1"> and issues of concurrency mechanisms by studying code examples</span><a id="_idIndexMarker827"/><span class="koboSpan" id="kobo.1000.1"> and reasoning around the problems that we are able to reproduce. </span><span class="koboSpan" id="kobo.1000.2">In the next section, we will discuss how to make use of the Go tools to detect concurrency issues in our programs. </span></p>
<h1 id="_idParaDest-190"><a id="_idTextAnchor212"/><span class="koboSpan" id="kobo.1001.1">The Go race detector</span></h1>
<p><span class="koboSpan" id="kobo.1002.1">In </span><a href="B18371_08.xhtml#_idTextAnchor179"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1003.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.1004.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1005.1">Testing Microservice Architectures</span></em><span class="koboSpan" id="kobo.1006.1">, we explored how</span><a id="_idIndexMarker828"/><span class="koboSpan" id="kobo.1007.1"> to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1008.1">pprof</span></strong><span class="koboSpan" id="kobo.1009.1"> tool to profile the CPU and memory usage of Go applications. </span><span class="koboSpan" id="kobo.1009.2">One of the essential tools that can help us find issues with concurrency is the Go race detector. </span><span class="koboSpan" id="kobo.1009.3">It is a powerful tool that analyzes our code to find concurrency problems when an application is running. </span></p>
<p><span class="koboSpan" id="kobo.1010.1">Go’s race detector was added to the toolchain in Go 1.1, released in 2012. </span><span class="koboSpan" id="kobo.1010.2">This tool was designed to help developers find race conditions in their code. </span><span class="koboSpan" id="kobo.1010.3">As we have seen in the previous examples, writing concurrent code in Go is easy, but bugs can appear in even the most readable and </span><span class="No-Break"><span class="koboSpan" id="kobo.1011.1">well-designed code.</span></span></p>
<p><span class="koboSpan" id="kobo.1012.1">The race detector is enabled using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1013.1">–race</span></strong><span class="koboSpan" id="kobo.1014.1"> command-line flag, alongside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1015.1">go</span></strong><span class="koboSpan" id="kobo.1016.1"> command. </span><span class="koboSpan" id="kobo.1016.2">For example, we can instruct it to run alongside </span><span class="No-Break"><span class="koboSpan" id="kobo.1017.1">our program:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1018.1">
$ go run </span><strong class="bold"><span class="koboSpan" id="kobo.1019.1">–race</span></strong><span class="koboSpan" id="kobo.1020.1"> main.go</span></pre>
<p><span class="koboSpan" id="kobo.1021.1">The race detector can be used with other commands as well, including the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1022.1">build</span></strong><span class="koboSpan" id="kobo.1023.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">test</span></strong><span class="koboSpan" id="kobo.1025.1"> commands. </span><span class="koboSpan" id="kobo.1025.2">This makes it easy to use the detector to find data races in your application at any stage in the development process. </span></p>
<p><span class="koboSpan" id="kobo.1026.1">Once the detector is enabled, the compiler records memory access and the Go runtime analyzes these records for data races. </span><span class="koboSpan" id="kobo.1026.2">As we know, data races are typically caused by multiple goroutines accessing and modifying one shared resource without making use of </span><span class="No-Break"><span class="koboSpan" id="kobo.1027.1">synchronization mechanisms.</span></span></p>
<p><span class="koboSpan" id="kobo.1028.1">When a data race occurs, the detector will print a report with details of the problem, pinpointing the problem and guiding an observant developer toward the fix for the detected issue. </span><span class="koboSpan" id="kobo.1028.2">Let us try it out with our data race</span><a id="_idIndexMarker829"/><span class="koboSpan" id="kobo.1029.1"> example from the </span><span class="No-Break"><span class="koboSpan" id="kobo.1030.1">previous section:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1031.1">
$ go run -race chapter09/concurrency/data-race/main.go 
==================
WARNING: DATA RACE
</span><strong class="bold"><span class="koboSpan" id="kobo.1032.1">Read</span></strong><span class="koboSpan" id="kobo.1033.1"> at 0x0000011e6d70 by </span><strong class="bold"><span class="koboSpan" id="kobo.1034.1">goroutine 8</span></strong><span class="koboSpan" id="kobo.1035.1">:
  </span><strong class="bold"><span class="koboSpan" id="kobo.1036.1">main.greet()</span></strong><span class="koboSpan" id="kobo.1037.1">
      .../chapter09/data-races/</span><strong class="bold"><span class="koboSpan" id="kobo.1038.1">main.go:15</span></strong><span class="koboSpan" id="kobo.1039.1"> +0xf5 
</span><strong class="bold"><span class="koboSpan" id="kobo.1040.1">Previous write</span></strong><span class="koboSpan" id="kobo.1041.1"> at 0x0000011e6d70 by </span><strong class="bold"><span class="koboSpan" id="kobo.1042.1">goroutine 7</span></strong><span class="koboSpan" id="kobo.1043.1">:
  main.greet()
      ../chapter09/data-races/</span><strong class="bold"><span class="koboSpan" id="kobo.1044.1">main.go:15</span></strong><span class="koboSpan" id="kobo.1045.1"> +0x1b3
==================
==================
WARNING: DATA RACE
</span><strong class="bold"><span class="koboSpan" id="kobo.1046.1">Read</span></strong><span class="koboSpan" id="kobo.1047.1"> at 0x00c00009e000 by </span><strong class="bold"><span class="koboSpan" id="kobo.1048.1">goroutine 9</span></strong><span class="koboSpan" id="kobo.1049.1">:
  </span><strong class="bold"><span class="koboSpan" id="kobo.1050.1">runtime.growslice()</span></strong><span class="koboSpan" id="kobo.1051.1">
      /usr/local/go/src/runtime/slice.go:178 +0x0
  main.greet()
      .../chapter09/data-races/</span><strong class="bold"><span class="koboSpan" id="kobo.1052.1">main.go:15</span></strong><span class="koboSpan" id="kobo.1053.1"> +0x12f 
</span><strong class="bold"><span class="koboSpan" id="kobo.1054.1">Previous write</span></strong><span class="koboSpan" id="kobo.1055.1"> at 0x00c00009e000 by </span><strong class="bold"><span class="koboSpan" id="kobo.1056.1">goroutine 7</span></strong><span class="koboSpan" id="kobo.1057.1">:
  main.greet()
      .../chapter09/data-races/main.go:15 +0x164
==================
Hello, friend! </span><span class="koboSpan" id="kobo.1057.2">I'm Goroutine 0.
</span><span class="koboSpan" id="kobo.1057.3">Hello, friend! </span><span class="koboSpan" id="kobo.1057.4">I'm Goroutine 2.
</span><span class="koboSpan" id="kobo.1057.5">Goodbye, friend!
</span><strong class="bold"><span class="koboSpan" id="kobo.1058.1">Found 2 data race(s)</span></strong><span class="koboSpan" id="kobo.1059.1">
exit status 66</span></pre>
<p><span class="koboSpan" id="kobo.1060.1">As expected, the race detector</span><a id="_idIndexMarker830"/><span class="koboSpan" id="kobo.1061.1"> finds some issues with our data race example. </span><span class="koboSpan" id="kobo.1061.2">The output points out the problem: </span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1062.1">The first data race is detected in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1063.1">greet</span></strong><span class="koboSpan" id="kobo.1064.1"> function at </span><strong class="source-inline"><span class="koboSpan" id="kobo.1065.1">main.go:15</span></strong><span class="koboSpan" id="kobo.1066.1">. </span><span class="koboSpan" id="kobo.1066.2">One goroutine reads a variable, while another goroutine writes </span><span class="No-Break"><span class="koboSpan" id="kobo.1067.1">to it.</span></span></li>
<li><span class="koboSpan" id="kobo.1068.1">The second data race is happening as the slice grows during append, which is indicated by the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1069.1">runtime.growslice()</span></strong><span class="koboSpan" id="kobo.1070.1">. </span><span class="koboSpan" id="kobo.1070.2">This function copies the slice and handles the allocation of a larger backing array, if it is required. </span><span class="koboSpan" id="kobo.1070.3">The modifications to this slice are also happening in an interleaving manner, with reads and writes happening in </span><span class="No-Break"><span class="koboSpan" id="kobo.1071.1">different goroutines.</span></span></li>
<li><span class="koboSpan" id="kobo.1072.1">Finally, the output of the program is printed and the race detector summarizes that two data races have been found. </span></li>
</ol>
<p><span class="koboSpan" id="kobo.1073.1">As we already suspected, the concurrent changes made to the shared slice without synchronization mechanisms have caused a data race. </span><span class="koboSpan" id="kobo.1073.2">The code block identified by the race detector is as follows: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1074.1">
func greet(id int, wg *sync.WaitGroup) {
  defer wg.Done()
  g := fmt.Sprintf("Hello, friend! </span><span class="koboSpan" id="kobo.1074.2">I'm Goroutine %d.", id)
</span><strong class="bold"><span class="koboSpan" id="kobo.1075.1">  greetings = append(greetings, g)</span></strong><span class="koboSpan" id="kobo.1076.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.1077.1">The line highlighted by the detector is the read and write to the greetings slice during the append function. </span><span class="koboSpan" id="kobo.1077.2">As we discussed in previous sections, the append function consists of multiple operations, which can cause data races if they are interleaving across </span><span class="No-Break"><span class="koboSpan" id="kobo.1078.1">multiple goroutines.</span></span></p>
<p><span class="koboSpan" id="kobo.1079.1">Due to the instrumentation that the race detector requires, it is only able to find data races as they are triggered. </span><span class="koboSpan" id="kobo.1079.2">Therefore, our application should be subjected to realistic workloads and user journeys in order to detect issues.  </span></p>
<p><span class="koboSpan" id="kobo.1080.1">According to the official Go documentation (</span><a href="https://go.dev/blog/race-detector"><span class="koboSpan" id="kobo.1081.1">https://go.dev/blog/race-detector</span></a><span class="koboSpan" id="kobo.1082.1">), race-enabled applications</span><a id="_idIndexMarker831"/><span class="koboSpan" id="kobo.1083.1"> use 10 times the CPU and memory, so we should avoid running them in production. </span><span class="koboSpan" id="kobo.1083.2">Instead, we should run our load tests and integration tests with the race detector enabled, since these tests </span><a id="_idIndexMarker832"/><span class="koboSpan" id="kobo.1084.1">usually exercise the most important parts of the program. </span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1085.1">Limitations of the race detector</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1086.1">While the race detector</span><a id="_idIndexMarker833"/><span class="koboSpan" id="kobo.1087.1"> is a very useful tool, we should remember that it can only check for race conditions. </span><span class="koboSpan" id="kobo.1087.2">While it does not flag any false positives, the code can contain other concurrency issues. </span><span class="koboSpan" id="kobo.1087.3">We should bear in mind that the race detector is simply an indicator. </span></p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor213"/><span class="koboSpan" id="kobo.1088.1">Untestable conditions</span></h2>
<p><span class="koboSpan" id="kobo.1089.1">While the Go race detector </span><a id="_idIndexMarker834"/><span class="koboSpan" id="kobo.1090.1">is a useful tool, concurrency testing is difficult to perform and prove to be correct. </span><span class="koboSpan" id="kobo.1090.2">The race detector only focuses on finding data races, but we have already seen that there are other concurrency issues in the previous section, </span><em class="italic"><span class="koboSpan" id="kobo.1091.1">Issues with concurrency</span></em><span class="koboSpan" id="kobo.1092.1">, where we explored deadlocks and leaked resources. </span></p>
<p><span class="koboSpan" id="kobo.1093.1">Due to the dependency on timing, there are four essentially untestable </span><span class="No-Break"><span class="koboSpan" id="kobo.1094.1">concurrency problems:</span></span></p>
<ol>
<li value="1"><strong class="bold"><span class="koboSpan" id="kobo.1095.1">Race conditions</span></strong><span class="koboSpan" id="kobo.1096.1">: Unstable or inconsistent behavior</span><a id="_idIndexMarker835"/><span class="koboSpan" id="kobo.1097.1"> due to multiple goroutines that read and modify a shared resource without the correct usage of synchronization mechanisms. </span><span class="koboSpan" id="kobo.1097.2">For example, goroutines reading and incrementing a common counter. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1098.1">Deadlocks</span></strong><span class="koboSpan" id="kobo.1099.1">: Goroutines becoming blocked waiting</span><a id="_idIndexMarker836"/><span class="koboSpan" id="kobo.1100.1"> for resources that never become available, either because they never reach the required state or because another goroutine has locked the resources and never released them. </span><span class="koboSpan" id="kobo.1100.2">For example, a goroutine is waiting to receive from</span><a id="_idIndexMarker837"/><span class="koboSpan" id="kobo.1101.1"> a nil channel, which never becomes initialized. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1102.1">Livelocks</span></strong><span class="koboSpan" id="kobo.1103.1">: Similar to deadlocks, goroutines become livelocked</span><a id="_idIndexMarker838"/><span class="koboSpan" id="kobo.1104.1"> when they continue to attempt to acquire resources that never become available, either because they never reach the required state or because another resource has locked the resources and never released them. </span><span class="koboSpan" id="kobo.1104.2">In this case, goroutines will waste CPU continuing to retry impossible operations. </span><span class="koboSpan" id="kobo.1104.3">For example, a goroutine periodically polls to write to a variable that has been locked by another goroutine, which is waiting for a resource that the first goroutine has locked and </span><span class="No-Break"><span class="koboSpan" id="kobo.1105.1">never received.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1106.1">Starvation</span></strong><span class="koboSpan" id="kobo.1107.1">: Similar to livelocks, goroutines cannot get all the resources</span><a id="_idIndexMarker839"/><span class="koboSpan" id="kobo.1108.1"> needed to continue processing. </span><span class="koboSpan" id="kobo.1108.2">One or more goroutines are prevented from doing meaningful work by greedy goroutines that do not release resources. </span><span class="koboSpan" id="kobo.1108.3">For example, a goroutine locks a resource and then proceeds to execute a very long-running operation, preventing other goroutines from gaining access to the resource in the meantime. </span></li>
</ol>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1109.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1110.1">.8</span></em><span class="koboSpan" id="kobo.1111.1"> depicts a common scenario of where deadlocks </span><span class="No-Break"><span class="koboSpan" id="kobo.1112.1">commonly occur:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer087">
<span class="koboSpan" id="kobo.1113.1"><img alt="Figure 9.8 – A common deadlock problem " src="image/Figure_9.8_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1114.1">Figure 9.8 – A common deadlock problem</span></p>
<p><span class="koboSpan" id="kobo.1115.1">In this scenario, both goroutines</span><a id="_idIndexMarker840"/><span class="koboSpan" id="kobo.1116.1"> need two resources to complete their work. </span><span class="koboSpan" id="kobo.1116.2">Each of the goroutines is holding onto a resource while it is waiting for the second resource. </span><span class="koboSpan" id="kobo.1116.3">Neither goroutine can complete its work and a deadlock occurs. </span><span class="koboSpan" id="kobo.1116.4">This same scenario can also lead to a livelock, if each goroutine is polling to check the state of a resource or another goroutine. </span><span class="koboSpan" id="kobo.1116.5">In this case, each goroutine is using CPU cycles but never </span><span class="No-Break"><span class="koboSpan" id="kobo.1117.1">finishes executing.</span></span></p>
<p><span class="koboSpan" id="kobo.1118.1">These four untestable conditions are actually a result of </span><strong class="bold"><span class="koboSpan" id="kobo.1119.1">poorly designed code</span></strong><span class="koboSpan" id="kobo.1120.1"> or a </span><strong class="bold"><span class="koboSpan" id="kobo.1121.1">faulty understanding of the behavior of concurrency mechanisms</span></strong><span class="koboSpan" id="kobo.1122.1">. </span><span class="koboSpan" id="kobo.1122.2">This is the main reason that we have started this chapter by thoroughly discussing and exploring the fundamentals and behavior of Go’s concurrency mechanisms. </span><span class="koboSpan" id="kobo.1122.3">These conditions can be detected by using good linters and a code review, but the best defense is to be aware of the problems when you are writing </span><span class="No-Break"><span class="koboSpan" id="kobo.1123.1">your code.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1124.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1125.1">.9</span></em><span class="koboSpan" id="kobo.1126.1"> presents a summary of three rules of thumb when it comes to </span><span class="No-Break"><span class="koboSpan" id="kobo.1127.1">using concurrency:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer088">
<span class="koboSpan" id="kobo.1128.1"><img alt="Figure 9.9 – Concurrency rules of thumb " src="image/Figure_9.9_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1129.1">Figure 9.9 – Concurrency rules of thumb</span></p>
<p><span class="koboSpan" id="kobo.1130.1">These three rules of thumb</span><a id="_idIndexMarker841"/><span class="koboSpan" id="kobo.1131.1"> will help you minimize the difficult-to-detect concurrency issues we have discussed so far: </span></p>
<ol>
<li value="1"><strong class="bold"><span class="koboSpan" id="kobo.1132.1">Share values with channels</span></strong><span class="koboSpan" id="kobo.1133.1">: As discussed previously, we should avoid sharing results using variables and pointers. </span><span class="koboSpan" id="kobo.1133.2">Even when correctly protected by locks, channels are much more efficient and can simplify your code. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1134.1">Defer lock releases</span></strong><span class="koboSpan" id="kobo.1135.1">: When using locks, you should get in the habit of immediately invoking the lock unlock/release with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1136.1">defer</span></strong><span class="koboSpan" id="kobo.1137.1"> keyword as soon as you acquire it. </span><span class="koboSpan" id="kobo.1137.2">This will ensure that your function releases the lock, regardless of the completion logic branch or any potential errors. </span><span class="koboSpan" id="kobo.1137.3">You should also consider whether you need a read-write lock, or whether you can avoid starvation by acquiring  read mutexes, </span><span class="No-Break"><span class="koboSpan" id="kobo.1138.1">where possible.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1139.1">Wait for all children to complete</span></strong><span class="koboSpan" id="kobo.1140.1">: As we have discussed, goroutines have a parent-child relationship with the goroutines they create. </span><span class="koboSpan" id="kobo.1140.2">You should make use of synchronization mechanisms to ensure that the parent goroutine waits for all the goroutines it has created before shutting down to ensure that operations are completed correctly and resources are cleaned up correctly. </span></li>
</ol>
<p><span class="koboSpan" id="kobo.1141.1">Testing alone </span><strong class="bold"><span class="koboSpan" id="kobo.1142.1">cannot prove the absence</span></strong><span class="koboSpan" id="kobo.1143.1"> of the four untestable conditions, but it can give us statistical confidence that these errors will not occur in production, for the scenarios that are important to our systems. </span><span class="koboSpan" id="kobo.1143.2">Therefore, writing tests that cover the concurrent parts of our code is an important part of our </span><span class="No-Break"><span class="koboSpan" id="kobo.1144.1">testing strategy.</span></span></p>
<p><span class="koboSpan" id="kobo.1145.1">In the next section, we will look at how we can make use of the race detector to test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1146.1">BookSwap</span></strong><span class="koboSpan" id="kobo.1147.1"> application under </span><span class="No-Break"><span class="koboSpan" id="kobo.1148.1">concurrent conditions.</span></span></p>
<h1 id="_idParaDest-192"><a id="_idTextAnchor214"/><span class="koboSpan" id="kobo.1149.1">Use case – testing concurrency in the BookSwap application</span></h1>
<p><span class="koboSpan" id="kobo.1150.1">The last section of this chapter</span><a id="_idIndexMarker842"/><span class="koboSpan" id="kobo.1151.1"> is dedicated to the detection of concurrency</span><a id="_idIndexMarker843"/><span class="koboSpan" id="kobo.1152.1"> issues in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1153.1">BookSwap</span></strong><span class="koboSpan" id="kobo.1154.1"> web application. </span><span class="koboSpan" id="kobo.1154.2">We will make use of Go’s race detector, alongside the testing strategies we have learned so far, to see what issues we can discover in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1155.1">BookSwap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1156.1"> application.</span></span></p>
<p><span class="koboSpan" id="kobo.1157.1">You might be wondering why we would worry about the concurrency aspects of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1158.1">BookSwap</span></strong><span class="koboSpan" id="kobo.1159.1"> application, since we have not used any locks, channels, or goroutines in the code base we have seen so far. </span><span class="koboSpan" id="kobo.1159.2">Go’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1160.1">net/http</span></strong><span class="koboSpan" id="kobo.1161.1"> library uses goroutines under the hood to serve HTTP requests, so the application can still have concurrency issues, even though it does not explicitly create its own goroutines and channels. </span><span class="koboSpan" id="kobo.1161.2">This effect will be further amplified once the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1162.1">BookSwap</span></strong><span class="koboSpan" id="kobo.1163.1"> application gets converted from a monolithic application to running in the microservice architecture we discussed in </span><a href="B18371_08.xhtml#_idTextAnchor179"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1164.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.1165.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1166.1">Testing </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1167.1">Microservice Architectures</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1168.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1169.1">We already have all the tools available for writing tests that can simulate and verify the concurrent behavior of our application. </span><span class="koboSpan" id="kobo.1169.2">We will write a test that creates </span><strong class="source-inline"><span class="koboSpan" id="kobo.1170.1">BookSwap</span></strong><span class="koboSpan" id="kobo.1171.1"> users concurrently: </span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1172.1">func TestUpsertUser_Load(t *testing.T) {</span></strong><span class="koboSpan" id="kobo.1173.1">
if os.Getenv("LONG") == "" {
    t.Skip("Skipping TestUpsertUser_Load in short mode.")
  }
  userEndpoint := getTestEndpoint(t)
  requestBody, err := json.Marshal(map[string]string{
    "name":      "Concurrent Test User",
    "address":   "1 London Road",
    "post_code": "N1",
    "country":   "United Kingdom",
  })
  require.Nil(t, err)
  require.NotNil(t, requestBody)
</span><strong class="bold"><span class="koboSpan" id="kobo.1174.1">  for i := 0; i &lt; LOAD_AMOUNT; i++ {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1175.1">    t.Run("concurrent upsert", func(t *testing.T) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1176.1">      t.Parallel()</span></strong><span class="koboSpan" id="kobo.1177.1">
      req := bytes.NewBuffer(requestBody)
</span><strong class="bold"><span class="koboSpan" id="kobo.1178.1">      r, err := http.Post(userEndpoint, "application/json", </span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1179.1">                          req)</span></strong><span class="koboSpan" id="kobo.1180.1">
      assert.Nil(t, err)
      body, err := io.ReadAll(r.Body)
      </span><strong class="bold"><span class="koboSpan" id="kobo.1181.1">r.Body.Close()</span></strong><span class="koboSpan" id="kobo.1182.1">
      require.Nil(t, err)
      var resp handlers.Response
      err = json.Unmarshal(body, &amp;resp)
      require.Nil(t, err)
      assert.Equal(t, http.StatusOK, r.StatusCode)
      assert.Nil(t, err)
      assert.NotNil(t, resp)
      assert.NotEmpty(t, resp.User.ID)
    })
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.1183.1">This benchmark</span><a id="_idIndexMarker844"/><span class="koboSpan" id="kobo.1184.1"> test sends requests concurrently</span><a id="_idIndexMarker845"/><span class="koboSpan" id="kobo.1185.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1186.1">POST /users</span></strong><span class="koboSpan" id="kobo.1187.1"> endpoint of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1188.1">BookSwap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1189.1"> application:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1190.1">We declare a new test with the usual signature, which takes in a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.1191.1">*testing.T</span></strong><span class="koboSpan" id="kobo.1192.1"> parameter.This test will run only when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1193.1">LONG</span></strong><span class="koboSpan" id="kobo.1194.1"> argument is passed to the test runner, as it required the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1195.1">BookSwap</span></strong><span class="koboSpan" id="kobo.1196.1"> application to be up. </span><span class="koboSpan" id="kobo.1196.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1197.1">userEndpoint</span></strong><span class="koboSpan" id="kobo.1198.1"> is returned by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1199.1">getTestEndpoint</span></strong><span class="koboSpan" id="kobo.1200.1"> helper function based on environment variables. </span><span class="koboSpan" id="kobo.1200.2">For brevity, we have not included the implementation of this </span><span class="No-Break"><span class="koboSpan" id="kobo.1201.1">function here.</span></span></li>
<li><span class="koboSpan" id="kobo.1202.1">In the setup of the test, we marshal a map with the string key and value type, which contains all the JSON fields that we require to create a new user. </span><span class="koboSpan" id="kobo.1202.2">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1203.1">json.Marshal</span></strong><span class="koboSpan" id="kobo.1204.1"> function in the standard library to do this. </span><span class="koboSpan" id="kobo.1204.2">This function will return a slice of bytes, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1205.1">[]byte</span></strong><span class="koboSpan" id="kobo.1206.1">,  which we will use as the request body for our HTTP POST calls. </span></li>
<li><span class="koboSpan" id="kobo.1207.1">We repeat the same test in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1208.1">for</span></strong><span class="koboSpan" id="kobo.1209.1"> loop up to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1210.1">LOAD_AMOUNT</span></strong><span class="koboSpan" id="kobo.1211.1"> constant. </span><span class="koboSpan" id="kobo.1211.2">The test runner will run the test in parallel according to the configuration that it has available. </span><span class="koboSpan" id="kobo.1211.3">It’s important to include this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1212.1">for</span></strong><span class="koboSpan" id="kobo.1213.1"> loop; otherwise, our goroutine will only make a </span><span class="No-Break"><span class="koboSpan" id="kobo.1214.1">single call.</span></span></li>
<li><span class="koboSpan" id="kobo.1215.1">We set up the test to run in parallel using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1216.1">t.Parallel</span></strong><span class="koboSpan" id="kobo.1217.1"> method. </span><span class="koboSpan" id="kobo.1217.2">Under the hood, this creates</span><a id="_idIndexMarker846"/><span class="koboSpan" id="kobo.1218.1"> multiple goroutines and distributes</span><a id="_idIndexMarker847"/><span class="koboSpan" id="kobo.1219.1"> the test iterations across them. </span><span class="koboSpan" id="kobo.1219.2">This method takes in a function as a parameter, which will set up any local state and be run in each of the goroutines of the test. </span></li>
<li><span class="koboSpan" id="kobo.1220.1">In the loop, we convert the JSON byte slice into a buffer, which is required for the invocation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1221.1">http.Post</span></strong><span class="koboSpan" id="kobo.1222.1"> function. </span><span class="koboSpan" id="kobo.1222.2">This function takes in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1223.1">usersEndpoint</span></strong><span class="koboSpan" id="kobo.1224.1">, which will contain the URL to </span><span class="No-Break"><span class="koboSpan" id="kobo.1225.1">test against.</span></span></li>
<li><span class="koboSpan" id="kobo.1226.1">Once the HTTP request completes, it will return a response, against which we can make our assertions. </span><span class="koboSpan" id="kobo.1226.2">We ensure that we close the body of the response in order to allow the same connection to be reused by </span><span class="No-Break"><span class="koboSpan" id="kobo.1227.1">another goroutine.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1228.1">The simple configuration of the test will allow us to test our endpoint using a fixed number of concurrent requests. </span><span class="koboSpan" id="kobo.1228.2">As we have seen in previous chapters, this function constructs the URL based on the environment variables specified for the application. </span><span class="koboSpan" id="kobo.1228.3">If you want to run with the default values, set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1229.1">BOOKSWAP_BASE_URL</span></strong><span class="koboSpan" id="kobo.1230.1"> environment variable to http://localhost and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1231.1">BOOKSWAP_PORT</span></strong><span class="koboSpan" id="kobo.1232.1"> environment variable to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1233.1">3000</span></strong><span class="koboSpan" id="kobo.1234.1"> to your </span><span class="No-Break"><span class="koboSpan" id="kobo.1235.1">terminal session.</span></span></p>
<p><span class="koboSpan" id="kobo.1236.1">By default, the number of goroutines that will be used by the benchmark is equal to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1237.1">GOMAXPROCS</span></strong><span class="koboSpan" id="kobo.1238.1"> variable. </span><span class="koboSpan" id="kobo.1238.2">This variable will be equal to the number of CPUs on the machine it is running. </span><span class="koboSpan" id="kobo.1238.3">Your OS decides what counts as a CPU, so for a four-core machine with hyperthreading, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1239.1">GOMAXPROCS</span></strong><span class="koboSpan" id="kobo.1240.1"> will be </span><strong class="source-inline"><span class="koboSpan" id="kobo.1241.1">8</span></strong><span class="koboSpan" id="kobo.1242.1">. </span><span class="koboSpan" id="kobo.1242.2">If you would like to adjust the number of goroutines, you can easily configure this by changing this environment variable. </span><span class="koboSpan" id="kobo.1242.3">Just as we have done with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1243.1">pprof</span></strong><span class="koboSpan" id="kobo.1244.1"> tool in </span><a href="B18371_08.xhtml#_idTextAnchor179"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1245.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.1246.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1247.1">Testing Microservice Architectures</span></em><span class="koboSpan" id="kobo.1248.1">, we run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1249.1">BookSwap</span></strong><span class="koboSpan" id="kobo.1250.1"> application with the race </span><span class="No-Break"><span class="koboSpan" id="kobo.1251.1">detector enabled:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1252.1">
$ go run -race cmd/main.go</span></pre>
<p><span class="koboSpan" id="kobo.1253.1">The modification of resources and goroutines is happening in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1254.1">BookSwap</span></strong><span class="koboSpan" id="kobo.1255.1"> application itself, not the test code, so this is why we instrument the application and not the test code. </span><span class="koboSpan" id="kobo.1255.2">Remember that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1256.1">BookSwap</span></strong><span class="koboSpan" id="kobo.1257.1"> application relies on a database now, we need to have PostgreSQL running and set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1258.1">BOOKSWAP_DB_URL</span></strong><span class="koboSpan" id="kobo.1259.1"> environment variable to the PostgreSQL </span><span class="No-Break"><span class="koboSpan" id="kobo.1260.1">connection string.</span></span></p>
<p><span class="koboSpan" id="kobo.1261.1">In a separate terminal window, we run the benchmark in the usual way, as running the benchmark in parallel is not visible outside the test configuration: </span></p>
<pre class="console"><span class="koboSpan" id="kobo.1262.1">
$ LONG=true go test  chapter09/user_create_test.go -v</span></pre>
<p><span class="koboSpan" id="kobo.1263.1">We can then issue a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1264.1">SIGINT</span></strong><span class="koboSpan" id="kobo.1265.1"> with </span><em class="italic"><span class="koboSpan" id="kobo.1266.1">Ctrl</span></em><span class="koboSpan" id="kobo.1267.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.1268.1">C</span></em><span class="koboSpan" id="kobo.1269.1"> in the first console window in order to halt the race detector. </span><span class="koboSpan" id="kobo.1269.2">If any data races are detected, they will be printed to the terminal, alongside the logs of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1270.1">BookSwap</span></strong><span class="koboSpan" id="kobo.1271.1">. </span><span class="koboSpan" id="kobo.1271.2">Since the race detector is running separately from the test code, we cannot fail the test when data races are detected. </span><span class="koboSpan" id="kobo.1271.3">We must therefore monitor the logs to see whether data races have </span><span class="No-Break"><span class="koboSpan" id="kobo.1272.1">been detected.</span></span></p>
<p><span class="koboSpan" id="kobo.1273.1">This simple technique</span><a id="_idIndexMarker848"/><span class="koboSpan" id="kobo.1274.1"> can be used for end-to-end testing and integration</span><a id="_idIndexMarker849"/><span class="koboSpan" id="kobo.1275.1"> testing of our application. </span><span class="koboSpan" id="kobo.1275.2">You can use it to implement any user journey or sequence of requests. </span><span class="koboSpan" id="kobo.1275.3">However, we should always bear in mind that the race detector is a limited tool and that no amount of testing can definitively and conclusively prove the absence of untestable concurrency issues. </span></p>
<h1 id="_idParaDest-193"><a id="_idTextAnchor215"/><span class="koboSpan" id="kobo.1276.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1277.1">In this chapter, we discussed the important and uniquely challenging topic of concurrency. </span><span class="koboSpan" id="kobo.1277.2">As a good understanding of concurrency mechanisms is important to avoid issues, we started by learning the fundamentals of two of Go’s most central concurrency mechanisms, goroutines and channels. </span><span class="koboSpan" id="kobo.1277.3">Then, we looked at three applied concurrency examples, which helped us further explore </span><span class="No-Break"><span class="koboSpan" id="kobo.1278.1">their behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.1279.1">Once we were familiar with how concurrency works, we started looking at some commonly occurring issues with concurrency. </span><span class="koboSpan" id="kobo.1279.2">The Go race detector is a tool that can help us detect data races and provide pinpoint guidance to engineers to help them to resolve the issue. </span><span class="koboSpan" id="kobo.1279.3">However, due to the importance of timing, it is not possible to conclusively prove the absence of concurrency issues, so careful design is always the first defense. </span><span class="koboSpan" id="kobo.1279.4">Finally, we looked at an applied example of how to use benchmarks to make concurrent calls to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1280.1">BookSwap</span></strong><span class="koboSpan" id="kobo.1281.1"> application and detect issues with Go’s race detector. </span></p>
<p><span class="koboSpan" id="kobo.1282.1">In </span><a href="B18371_10.xhtml#_idTextAnchor218"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1283.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.1284.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1285.1">Testing Edge Cases</span></em><span class="koboSpan" id="kobo.1286.1">, we will explore how to extend tests and ensure that our code is robust with Go’s </span><span class="No-Break"><span class="koboSpan" id="kobo.1287.1">fuzzing capability.</span></span></p>
<h1 id="_idParaDest-194"><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.1288.1">Questions</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1289.1">What is the difference between concurrency and parallelism? </span></li>
<li><span class="koboSpan" id="kobo.1290.1">What operations do unbuffered channels support and how do they behave? </span></li>
<li><span class="koboSpan" id="kobo.1291.1">What is the difference between </span><strong class="source-inline"><span class="koboSpan" id="kobo.1292.1">sync.Mutex</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1293.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1294.1">sync.WaitGroup</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1295.1">?</span></span></li>
<li><span class="koboSpan" id="kobo.1296.1">What is a data race? </span><span class="koboSpan" id="kobo.1296.2">What is a deadlock? </span></li>
<li><span class="koboSpan" id="kobo.1297.1">How do you use Go’s race detector? </span></li>
</ol>
<h1 id="_idParaDest-195"><a id="_idTextAnchor217"/><span class="koboSpan" id="kobo.1298.1">Further reading</span></h1>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.1299.1">Concurrency in Go: Tools and Techniques for Developers</span></em><span class="koboSpan" id="kobo.1300.1">, by Katherine Cox-Buday, published </span><span class="No-Break"><span class="koboSpan" id="kobo.1301.1">by O’Reilly</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1302.1">Network Programming with Go: Learn to Code Secure and Reliable Network Services from Scratch</span></em><span class="koboSpan" id="kobo.1303.1">, by Adam Woodbeck, published by No </span><span class="No-Break"><span class="koboSpan" id="kobo.1304.1">Starch Press</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1305.1">Introduction to Concurrency in Programming Languages</span></em><span class="koboSpan" id="kobo.1306.1">, by Matthew J. </span><span class="koboSpan" id="kobo.1306.2">Sottile et al., published by Chapman &amp; </span><span class="No-Break"><span class="koboSpan" id="kobo.1307.1">Hall</span></span></li>
</ul>
</div>
</body></html>