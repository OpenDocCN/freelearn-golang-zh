["```go\nfunc greet(gr string) {\n  fmt.Println(\"Hello, friend!\")\n}\n\nfunc main() {\n  go greet()\n  fmt.Println(\"Goodbye, friend!\")\n}\n```", "```go\n$ go run chapter09/concurrency/goroutines/main.go \nGoodbye, friend!\n```", "```go\nvar finished bool\nfunc greet() {\n  fmt.Println(\"Hello, friend!\")\n  finished = true\n}\n\nfunc main() {\n  go greet()\n  for !finished {\n    fmt.Println(\"Child goroutine not finished.\")\n    time.Sleep(10 * time.Millisecond)\n  }\n  fmt.Println(\"Child goroutine finished.\")\n  fmt.Println(\"Goodbye, friend!\")\n}\n```", "```go\n$ go run chapter09/concurrency/goroutines/main.go\nChild goroutine not finished.\nHello, friend!\nChild goroutine finished.\nGoodbye, friend!\n```", "```go\nfunc greet(ch chan bool) {\n  fmt.Println(\"Hello, friend!\")\n  ch <- true\n}\nfunc main() {\n  ch := make(chan bool)\n  go greet(ch)\n  <-ch\n  fmt.Println(\"Child goroutine finished.\")\n  fmt.Println(\"Goodbye, friend!\")\n}\n```", "```go\nfunc greet(ch chan struct{}) {\n  fmt.Println(\"Hello, friend!\")\n  close(ch)\n}\n\nfunc main() {\n  ch := make(chan struct{})\n  go greet(ch)\n  <-ch\n  fmt.Println(\"Child goroutine finished.\")\n  fmt.Println(\"Goodbye, friend!\")\n}\n```", "```go\nfunc safelyClose(once *sync.Once, ch chan struct{}) {\n  fmt.Println(\"Hello, friend!\")\n  once.Do(func() {\n    fmt.Println(\"Channel closed.\")\nclose(ch)\n  })\n}\nfunc main() {\n  var once sync.Once\n  ch := make(chan struct{})\n  for i := 0; i<3; i++ {\n    go safelyClose(&once, ch)\n  }\n  <-ch\n  fmt.Println(\"Goodbye, friend!\")\n}\n```", "```go\n$ go run chapter09/concurrency/once/main.go\nHello, friend!\nChannel closed.\nHello, friend!\nGoodbye, friend!\nHello, friend! \n```", "```go\nconst workerCount = 3\nfunc greet(id int, smap *sync.Map, done chan struct{}) {\n  g := fmt.Sprintf(\"Hello, friend! I'm Goroutine %d.\", id)\nsmap.Store(id, g)\n  done <- struct{}{}\n}\nfunc main() {\n  var smap sync.Map\n  done := make(chan struct{})\n  for i := 0; i < workerCount; i++ {\n    go greet(i, &smap, done)\n  }\n  for i := 0; i < workerCount; i++ {\n    <-done\n  }\n  smap.Range(func(key, value any) bool {\n    fmt.Println(value)\n    return true\n  })\n  fmt.Println(\"Goodbye, friend!\")\n}\n```", "```go\n$ go run chapter09/concurrency/syncmap/main.go \nHello, friend! I'm Goroutine 2.\nHello, friend! I'm Goroutine 0.\nHello, friend! I'm Goroutine 1.\nGoodbye, friend!\n```", "```go\n// Thread safe LIFO Stack implementation\ntype Stack struct {\n  lock sync.Mutex\n  data []string\n}\n// Push adds the given element to the end of the list\nfunc (s *Stack) Push(el string) {\n  defer s.lock.Unlock()\n  s.lock.Lock()\n  s.data = append(s.data, el)\n}\n// Pop removes and returns the last element from the list,\n// or an error if the list is empty.\nfunc (s *Stack) Pop() (*string, error) {\ndefer s.lock.Unlock()\n  s.lock.Lock()\n  if len(s.data) == 0 {\n    return nil, fmt.Errorf(\"stack is empty\")\n  }\n  last := s.data[len(s.data)-1]\n  s.data = s.data[0 : len(s.data)-1]\n  return &last, nil\n}\n```", "```go\nconst workerCount = 3\nfunc greet(id int, smap *sync.Map, wg *sync.WaitGroup) {\n  defer wg.Done()  \n  g := fmt.Sprintf(\"Hello, friend! I'm Goroutine %d.\", id)\n  smap.Store(id, g)\n}\nfunc main() {\n  var smap sync.Map\n  var wg sync.WaitGroup\n  wg.Add(workerCount)\n  for i := 0; i < workerCount; i++ {\n    go greet(i, &smap, &wg)\n  }\n  wg.Wait()\n  smap.Range(func(key, value any) bool {\n    fmt.Println(value)\n    return true\n  })\n  fmt.Println(\"Goodbye, friend!\")\n}\n```", "```go\nconst workerCount = 3\nvar greetings []string\nfunc greet(id int, wg *sync.WaitGroup) {\n  defer wg.Done()\n  g := fmt.Sprintf(\"Hello, friend! I'm Goroutine %d.\", id)\n  greetings = append(greetings, g)\n}\nfunc main() {\n  var wg sync.WaitGroup\n  wg.Add(workerCount)\n  for i := 0; i < workerCount; i++ {\n    go greet(i, &wg)\n  }\n  wg.Wait()\n  for _, g := range greetings {\n    fmt.Println(g)\n  }\n  fmt.Println(\"Goodbye, friend!\")\n}\n```", "```go\n$ go run chapter09/concurrency/data-races/main.go \nHello, friend! I'm Goroutine 2.\nHello, friend! I'm Goroutine 1.\nGoodbye, friend!\n```", "```go\nvar greetings []string\nconst workerCount = 3\nfunc greet(id int, ch chan struct{}, wg *sync.WaitGroup) {\n  defer wg.Done()\n  g := fmt.Sprintf(\"Hello, friend! I'm Goroutine %d.\", id)\n  <-ch\n  greetings = append(greetings, g)\n  ch <- struct{}{}\n}\nfunc main() {\n  ch := make(chan struct{})\n  var wg sync.WaitGroup\n  wg.Add(workerCount)\n  for i := 0; i < workerCount; i++ {\n    go greet(i, ch, &wg)\n  }\n  ch <- struct{}{}\n  wg.Wait()\n  for _, g := range greetings {\n    fmt.Println(g)\n  }\n  fmt.Println(\"Goodbye, friend!\")\n}\n```", "```go\n$ go run chapter09/concurrency/deadlock/main.go\nfatal error: all goroutines are asleep - deadlock!\ngoroutine 1 [semacquire]:\nsync.(*WaitGroup).Wait(0x0?)\n        /usr/local/go/src/sync/waitgroup.go:139 +0x52\nmain.main()\n        .../chapter09/deadlock/main.go:28 +0xd5\ngoroutine 19 [chan send]:\nmain.greet(0x0?, 0x0?, 0x0?)\n        .../chapter09/deadlock/main.go:17 +0x165\ncreated by main.main\n        .../chapter09/deadlock/main.go:25 +0x4f\nexit status 2\n```", "```go\nch := make(chan Type, capacity)\n```", "```go\nconst workerCount = 3\nfunc greet(id int, ch chan string) {\n  g := fmt.Sprintf(\"Hello, friend! I'm Goroutine %d.\", id)\n  ch <- g\n  fmt.Printf(\"Goroutine %d completed.\\n\", id)\n}\nfunc main() {\n  ch := make(chan string, workerCount)\n  for i := 0; i < workerCount; i++ {\n    go greet(i, ch)\n  }\n  fmt.Println(<-ch)\n  fmt.Println(<-ch)\n  fmt.Println(\"Goodbye, friend!\")\n}\n```", "```go\n$ go run chapter09/concurrency/buffered-channels/main.go \nGoroutine 1 completed.\nGoroutine 2 completed.\nGoroutine 0 completed.\nHello, friend! I'm Goroutine 2.\nHello, friend! I'm Goroutine 1.\nGoodbye, friend!\n```", "```go\n$ go run –race main.go\n```", "```go\n$ go run -race chapter09/concurrency/data-race/main.go \n==================\nWARNING: DATA RACE\nRead at 0x0000011e6d70 by goroutine 8:\n  main.greet()\n      .../chapter09/data-races/main.go:15 +0xf5 \nPrevious write at 0x0000011e6d70 by goroutine 7:\n  main.greet()\n      ../chapter09/data-races/main.go:15 +0x1b3\n==================\n==================\nWARNING: DATA RACE\nRead at 0x00c00009e000 by goroutine 9:\n  runtime.growslice()\n      /usr/local/go/src/runtime/slice.go:178 +0x0\n  main.greet()\n      .../chapter09/data-races/main.go:15 +0x12f \nPrevious write at 0x00c00009e000 by goroutine 7:\n  main.greet()\n      .../chapter09/data-races/main.go:15 +0x164\n==================\nHello, friend! I'm Goroutine 0.\nHello, friend! I'm Goroutine 2.\nGoodbye, friend!\nFound 2 data race(s)\nexit status 66\n```", "```go\nfunc greet(id int, wg *sync.WaitGroup) {\n  defer wg.Done()\n  g := fmt.Sprintf(\"Hello, friend! I'm Goroutine %d.\", id)\n  greetings = append(greetings, g)\n}\n```", "```go\nfunc TestUpsertUser_Load(t *testing.T) {\nif os.Getenv(\"LONG\") == \"\" {\n    t.Skip(\"Skipping TestUpsertUser_Load in short mode.\")\n  }\n  userEndpoint := getTestEndpoint(t)\n  requestBody, err := json.Marshal(map[string]string{\n    \"name\":      \"Concurrent Test User\",\n    \"address\":   \"1 London Road\",\n    \"post_code\": \"N1\",\n    \"country\":   \"United Kingdom\",\n  })\n  require.Nil(t, err)\n  require.NotNil(t, requestBody)\n  for i := 0; i < LOAD_AMOUNT; i++ {\n    t.Run(\"concurrent upsert\", func(t *testing.T) {\n      t.Parallel()\n      req := bytes.NewBuffer(requestBody)\nr, err := http.Post(userEndpoint, \"application/json\", \n                          req)\n      assert.Nil(t, err)\n      body, err := io.ReadAll(r.Body)\n      r.Body.Close()\n      require.Nil(t, err)\n      var resp handlers.Response\n      err = json.Unmarshal(body, &resp)\n      require.Nil(t, err)\n      assert.Equal(t, http.StatusOK, r.StatusCode)\n      assert.Nil(t, err)\n      assert.NotNil(t, resp)\n      assert.NotEmpty(t, resp.User.ID)\n    })\n  }\n}\n```", "```go\n$ go run -race cmd/main.go\n```", "```go\n$ LONG=true go test  chapter09/user_create_test.go -v\n```"]