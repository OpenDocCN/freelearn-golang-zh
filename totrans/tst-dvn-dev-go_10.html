<html><head></head><body>
<div id="_idContainer094">
<h1 class="chapter-number" id="_idParaDest-196"><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-197"><a id="_idTextAnchor219"/><span class="koboSpan" id="kobo.2.1">Testing Edge Cases</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapters, we discussed the implementation and testing of web applications. </span><span class="koboSpan" id="kobo.3.2">We made use of a variety of functional and non-functional tests to ensure that the individual services within our microservice architectures remained performant and delivered the correct functionality. </span></p>
<p><span class="koboSpan" id="kobo.4.1">In </span><a href="B18371_04.xhtml#_idTextAnchor085"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.5.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.6.1">, </span><em class="italic"><span class="koboSpan" id="kobo.7.1">Building Efficient Test Suites</span></em><span class="koboSpan" id="kobo.8.1">, we discussed the definitions of edge and corner cases, as well as learning how to implement them using table-driven testing. </span><span class="koboSpan" id="kobo.8.2">For production systems, it would be nearly impossible to fully test complex systems, no matter how dedicated we might be to implementing tests across a variety of scenarios. </span><span class="koboSpan" id="kobo.8.3">Therefore, testing strategies should be designed with system requirements and user journeys </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">in mind.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">However, no matter how carefully we design and implement them, testing strategies also have their limitations. </span><span class="koboSpan" id="kobo.10.2">As discussed in </span><a href="B18371_09.xhtml#_idTextAnchor197"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.11.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.12.1">, </span><em class="italic"><span class="koboSpan" id="kobo.13.1">Challenges of Testing Concurrent Code</span></em><span class="koboSpan" id="kobo.14.1">, testing cannot prove the absence of concurrency bugs but does give us statistical confidence that these errors will not happen under the scenarios covered by our testing strategy. </span><span class="koboSpan" id="kobo.14.2">We also discussed how concurrency issues are not implementation bugs and are in fact system design faults, so a thorough understanding of Go’s concurrency mechanisms is important in order to avoid </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">such errors.</span></span></p>
<p><span class="koboSpan" id="kobo.16.1">This chapter will explore the previously discussed topic of edge cases through a new lens. </span><span class="koboSpan" id="kobo.16.2">We will begin with an introduction to the concept of code robustness, which will allow us to write implementation code that is stable for a wide variety of inputs. </span><span class="koboSpan" id="kobo.16.3">Then, we will learn how to use Go’s newly introduced fuzz testing capability to write tests that cover a wide variety of inputs. </span><span class="koboSpan" id="kobo.16.4">Finally, we will explore property-based testing, which allows us to write assertions for the output properties that really matter to us, as opposed to exact value matches. </span><span class="koboSpan" id="kobo.16.5">This is a different approach to test writing than we have seen so far and can make writing tests for edge cases </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">much simpler.</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.20.1">Definition and best practices for achieving </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">code robustness</span></span></li>
<li><span class="koboSpan" id="kobo.22.1">Go’s newly introduced </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">fuzzing capability</span></span></li>
<li><span class="koboSpan" id="kobo.24.1">The concept of property-based testing and how we can implement it </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">in Go</span></span></li>
<li><span class="koboSpan" id="kobo.26.1">How to use fuzzing and property-based testing in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.27.1">BookSwap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.28.1"> application</span></span></li>
</ul>
<h1 id="_idParaDest-198"><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.29.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.30.1">You will need to have </span><strong class="bold"><span class="koboSpan" id="kobo.31.1">Go version 1.19</span></strong><span class="koboSpan" id="kobo.32.1"> or later installed to run the code samples in this chapter. </span><span class="koboSpan" id="kobo.32.2">The installation process is described in the official Go documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">at </span></span><a href="https://go.dev/doc/install"><span class="No-Break"><span class="koboSpan" id="kobo.34.1">https://go.dev/doc/install</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.35.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">The code examples included in this book are publicly available </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">at </span></span><a href="https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter10"><span class="No-Break"><span class="koboSpan" id="kobo.38.1">https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter10</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.39.1">.</span></span></p>
<h1 id="_idParaDest-199"><a id="_idTextAnchor221"/><span class="koboSpan" id="kobo.40.1">Code robustness</span></h1>
<p><span class="koboSpan" id="kobo.41.1">In </span><a href="B18371_04.xhtml#_idTextAnchor085"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.42.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.43.1">, </span><em class="italic"><span class="koboSpan" id="kobo.44.1">Building Efficient Test Suites</span></em><span class="koboSpan" id="kobo.45.1">, we discussed the types of variable values that our testing strategies should cover. </span><span class="koboSpan" id="kobo.45.2">Among these values, we identified three types of test cases covering our parameters: </span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.46.1">Base cases</span></span></li>
<li><span class="koboSpan" id="kobo.47.1">Edge cases </span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.48.1">Boundary cases</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.49.1">We further identified corner cases that occur when multiple input variables are supplied with edge case values. </span><span class="koboSpan" id="kobo.49.2">We should write test cases that cover a broad range of values for the inputs supplied to </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">our functions.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">In the world of microservice architectures, we often don’t have control over which values are supplied to our services and functions, so the code we write should be stable under a variety of scenarios. </span><span class="koboSpan" id="kobo.51.2">In order to achieve this stability, we should implement a well-designed, well-tested robust </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">code base.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.53.1">Code robustness</span></strong><span class="koboSpan" id="kobo.54.1"> is an often </span><a id="_idIndexMarker850"/><span class="koboSpan" id="kobo.55.1">overlooked quality that can help us achieve code that will remain stable even as it changes and goes through refactoring cycles. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.56.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.57.1">.1</span></em><span class="koboSpan" id="kobo.58.1"> presents the main characteristics of </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">robust code:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer090">
<span class="koboSpan" id="kobo.60.1"><img alt="Figure 10.1 – Characteristics of robust code " src="image/Figure_10.1_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.61.1">Figure 10.1 – Characteristics of robust code</span></p>
<p><span class="koboSpan" id="kobo.62.1">In a nutshell, robust code is </span><a id="_idIndexMarker851"/><span class="koboSpan" id="kobo.63.1">easy for developers to work on due to the </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">following characteristics:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.65.1">Easy to change</span></strong><span class="koboSpan" id="kobo.66.1">: Robust code is able to handle a wide variety of external factors, making it easier to refactor and change its dependencies. </span><span class="koboSpan" id="kobo.66.2">We will see that the other characteristics will contribute to making robust code easy </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">to change.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.68.1">Minimal assumptions</span></strong><span class="koboSpan" id="kobo.69.1">: Robust code makes minimal assumptions for the values of input parameters and resources that it has available. </span><span class="koboSpan" id="kobo.69.2">It should check any value that it does not generate internally to ensure that it is </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">as expected.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.71.1">Good error handling</span></strong><span class="koboSpan" id="kobo.72.1">: Robust code implements good error handling by checking for errors from external functions, gracefully ending current operations in the case of an error, and providing meaningful error messages to be returned to callers. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.73.1">Provides a clear API</span></strong><span class="koboSpan" id="kobo.74.1">: Robust code provides an easy-to-read and comprehensible API for external callers. </span><span class="koboSpan" id="kobo.74.2">It should make it clear what parameter types it expects and what possible errors it can return. </span><span class="koboSpan" id="kobo.74.3">While documentation is a useful supplement, we should not rely on it. </span><span class="koboSpan" id="kobo.74.4">Robust code should use custom types and interfaces to leverage compiler checks and type safety as much </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">as possible.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.76.1">Easy to test</span></strong><span class="koboSpan" id="kobo.77.1">: Due to the characteristics we have already explored, robust code is easy to test. </span><span class="koboSpan" id="kobo.77.2">A clear API makes it easy for us to design our test cases, mock any dependencies required, or formulate any contracts for the implementation of contract testing. </span><span class="koboSpan" id="kobo.77.3">Good error handling, which returns well-formulated errors, allows us to write concise assertions that verify returned </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">error messages.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.79.1">Consistent style</span></strong><span class="koboSpan" id="kobo.80.1">: Robust code is written using a consistent set of practices, which includes naming </span><a id="_idIndexMarker852"/><span class="koboSpan" id="kobo.81.1">standards and function structure. </span><span class="koboSpan" id="kobo.81.2">This can be achieved at code review as well as using Go’s formatting and linting capabilities. </span><span class="koboSpan" id="kobo.81.3">You can read more about how to achieve this when </span><a id="_idIndexMarker853"/><span class="koboSpan" id="kobo.82.1">using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">go vet</span></strong><span class="koboSpan" id="kobo.84.1"> command in the official documentation – </span><a href="https://pkg.go.dev/cmd/vet"><span class="No-Break"><span class="koboSpan" id="kobo.85.1">https://pkg.go.dev/cmd/vet</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.86.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.87.1">Easy to read</span></strong><span class="koboSpan" id="kobo.88.1">: Robust code that uses a consistent style, handles errors, and provides good APIs reduces the cognitive load that developers will require to understand its behavior. </span><span class="koboSpan" id="kobo.88.2">This makes it easier to read and </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">search through.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.90.1">Good naming/comments</span></strong><span class="koboSpan" id="kobo.91.1">: Documentation is another important but often overlooked aspect of writing code. </span><span class="koboSpan" id="kobo.91.2">Variable naming should be short, but representative of the functionality it provides. </span><span class="koboSpan" id="kobo.91.3">Functions and types should have accompanying documentation that clearly states their expected behavior and the functionality it provides. </span><span class="koboSpan" id="kobo.91.4">You can read more about how to write Go comments on the official blog – </span><a href="https://tip.golang.org/doc/comment"><span class="No-Break"><span class="koboSpan" id="kobo.92.1">https://tip.golang.org/doc/comment</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.93.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.94.1">Designing code </span><a id="_idIndexMarker854"/><span class="koboSpan" id="kobo.95.1">with robustness in mind will help us create stable systems and microservice architectures. </span><span class="koboSpan" id="kobo.95.2">One of the common ways that developers implement systems is by emulating </span><a id="_idIndexMarker855"/><span class="koboSpan" id="kobo.96.1">the principles of the </span><strong class="bold"><span class="koboSpan" id="kobo.97.1">Unix philosophy</span></strong><span class="koboSpan" id="kobo.98.1">, which has been established by its creators and the community. </span><span class="koboSpan" id="kobo.98.2">It states that robustness results from transparency and simplicity, which are principles that relate well to Go software development. </span><span class="koboSpan" id="kobo.98.3">Looking at these principles, we can see that they are reflected in the characteristics we have examined in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.99.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.100.1">.1</span></em><span class="koboSpan" id="kobo.101.1">: </span></p>
<ul>
<li><span class="koboSpan" id="kobo.102.1">Transparent code is easy to read and understand. </span><span class="koboSpan" id="kobo.102.2">Readability is aided by consistent styling, good naming/comments, and clear </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">API definitions.</span></span></li>
<li><span class="koboSpan" id="kobo.104.1">Simple code is also easy to understand, but it is also uncomplicated and provides well-defined functionality that can be easily reused. </span><span class="koboSpan" id="kobo.104.2">This provides our systems with modularity, which allows us to reuse them to solve a wide variety of problems and situations. </span><span class="koboSpan" id="kobo.104.3">However, it should also be able to gracefully handle error cases or situations that it was not designed </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">to accommodate.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.106.1">Just like Linux, open source software and libraries are generally seen as more robust than their proprietary counterparts, as they have a wider audience that can find and correct errors. </span><span class="koboSpan" id="kobo.106.2">This is one of the reasons that we have only explored open source libraries and tools throughout our entire exploration of TDD. </span></p>
<p><span class="koboSpan" id="kobo.107.1">The opposite of </span><a id="_idIndexMarker856"/><span class="koboSpan" id="kobo.108.1">robust code is fragile and error-prone code. </span><span class="koboSpan" id="kobo.108.2">This type of code is complicated to understand and can be difficult to refactor, even when using the strategies we explored in </span><a href="B18371_07.xhtml#_idTextAnchor162"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.109.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.110.1">, </span><em class="italic"><span class="koboSpan" id="kobo.111.1">Refactoring in Go</span></em><span class="koboSpan" id="kobo.112.1">.  </span><span class="koboSpan" id="kobo.112.2">Often, code refactoring involves making code changes to add robustness to code using some of the best practices we will explore in the next section. </span></p>
<h2 id="_idParaDest-200"><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.113.1">Best practices</span></h2>
<p><span class="koboSpan" id="kobo.114.1">Now that we have </span><a id="_idIndexMarker857"/><span class="koboSpan" id="kobo.115.1">a good grasp of the characteristics of robust code, we can begin to look at some best practices for implementing it in Go. </span><span class="koboSpan" id="kobo.115.2">We can begin our exploration by looking at a simple example of a fragile piece of code and exploring what we can do to make it </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">more robust.</span></span></p>
<p><span class="koboSpan" id="kobo.117.1">We will write a function that returns the values contained inside a Go map in key-sorted order. </span><span class="koboSpan" id="kobo.117.2">To achieve this, our function will do </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">the following:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.119.1">Extract the keys contained inside </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">the map.</span></span></li>
<li><span class="koboSpan" id="kobo.121.1">Sort the keys according to a given </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">order parameter.</span></span></li>
<li><span class="koboSpan" id="kobo.123.1">Extract the values corresponding to their keys and return them as </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">a slice.</span></span></li>
</ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.125.1">Map refresher</span></p>
<p class="callout"><span class="koboSpan" id="kobo.126.1">Go maps are dynamic, unordered collections of key-value pairs. </span><span class="koboSpan" id="kobo.126.2">Values can be accessed and modified using a unique key. </span><span class="koboSpan" id="kobo.126.3">They are represented using the built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">map</span></strong><span class="koboSpan" id="kobo.128.1"> type. </span><span class="koboSpan" id="kobo.128.2">The zero value of a map is nil, so it is initialized using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">make</span></strong><span class="koboSpan" id="kobo.130.1"> function. </span><span class="koboSpan" id="kobo.130.2">Since Go 1.12, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">fmt</span></strong><span class="koboSpan" id="kobo.132.1"> package will print maps in key-sorted order, but it is important to remember that the collection </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">is unordered.</span></span></p>
<p><span class="koboSpan" id="kobo.134.1">Based on this knowledge, we </span><a id="_idIndexMarker858"/><span class="koboSpan" id="kobo.135.1">can write a simple function to return the sorted values from </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">a map:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.137.1">var input map[int]string</span></strong><span class="koboSpan" id="kobo.138.1">
func </span><strong class="bold"><span class="koboSpan" id="kobo.139.1">GetValues(dir string) []string </span></strong><span class="koboSpan" id="kobo.140.1">{
  var keys []int
</span><strong class="bold"><span class="koboSpan" id="kobo.141.1">  for k := range input {</span></strong><span class="koboSpan" id="kobo.142.1">
    keys = append(keys, k)
  }
  if </span><strong class="bold"><span class="koboSpan" id="kobo.143.1">dir == "asc"</span></strong><span class="koboSpan" id="kobo.144.1"> {
    sort.Ints(keys)
  }
  if </span><strong class="bold"><span class="koboSpan" id="kobo.145.1">dir == "desc"</span></strong><span class="koboSpan" id="kobo.146.1"> {
    </span><strong class="bold"><span class="koboSpan" id="kobo.147.1">sort.Slice(keys, func(i, j int) bool {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.148.1">      return keys[i] &gt; keys[j]</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.149.1">    })</span></strong><span class="koboSpan" id="kobo.150.1">
  }
</span><strong class="bold"><span class="koboSpan" id="kobo.151.1">  var vals []string</span></strong><span class="koboSpan" id="kobo.152.1">
  for _, k := range keys {
    vals = append(vals, input[k])
  }
  return vals
}</span></pre>
<p><span class="koboSpan" id="kobo.153.1">This example function does work, returning sorted values, but it does have some areas for improvement to make it </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">less fragile:</span></span></p>
<ol>
<li value="1"><strong class="bold"><span class="koboSpan" id="kobo.155.1">Global variables</span></strong><span class="koboSpan" id="kobo.156.1">: The input map is a global variable, defined outside the scope of the function. </span><span class="koboSpan" id="kobo.156.2">The dependency between the function and the map is unclear from looking at the signature. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.157.1">Function name and signature</span></strong><span class="koboSpan" id="kobo.158.1">: The function name, </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">GetValues</span></strong><span class="koboSpan" id="kobo.160.1">, does not give any indication of the sorting functionality. </span><span class="koboSpan" id="kobo.160.2">It is also unclear what the </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">dir</span></strong><span class="koboSpan" id="kobo.162.1"> parameter is used for and what its allowed </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">values are.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.164.1">Nil input behavior</span></strong><span class="koboSpan" id="kobo.165.1">: As previously mentioned, the zero value of a map is nil. </span><span class="koboSpan" id="kobo.165.2">The function immediately uses the input map, without checking for nil. </span><span class="koboSpan" id="kobo.165.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">range</span></strong><span class="koboSpan" id="kobo.167.1"> operator is able to handle a nil map passed to it without panic, but it is unclear what the expected behavior of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">GetValues</span></strong><span class="koboSpan" id="kobo.169.1"> function is in </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">this case.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.171.1">Input validation</span></strong><span class="koboSpan" id="kobo.172.1">: The function allows two values for sorting the keys in ascending or descending order, as specified by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">dir</span></strong><span class="koboSpan" id="kobo.174.1"> parameter. </span><span class="koboSpan" id="kobo.174.2">The function handles the value of the </span><a id="_idIndexMarker859"/><span class="koboSpan" id="kobo.175.1">parameter and performs the corresponding sorting, but the values will simply remain unsorted in the case of another value. </span><span class="koboSpan" id="kobo.175.2">Instead, it would be better if the caller of the function received some indication that the function was not able to perform its </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">intended work.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.177.1">Hardcoded strings</span></strong><span class="koboSpan" id="kobo.178.1">: Another issue with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">dir</span></strong><span class="koboSpan" id="kobo.180.1"> parameter is that it is validated against hardcoded values defined inside the function. </span><span class="koboSpan" id="kobo.180.2">Unless the value of the sorting direction is the same, including the letter case, the function will not match it. </span><span class="koboSpan" id="kobo.180.3">Furthermore, the caller has no idea what the accepted values are unless the implementation code </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">is inspected.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.182.1">Inconsistent style</span></strong><span class="koboSpan" id="kobo.183.1">: The function uses the built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">sort</span></strong><span class="koboSpan" id="kobo.185.1"> package to sort the keys in the correct order. </span><span class="koboSpan" id="kobo.185.2">This is a lot better than implementing a sorting algorithm from scratch, but the two sorting cases are implemented using different </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">sort</span></strong><span class="koboSpan" id="kobo.187.1"> package functions. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.188.1">Memory allocation</span></strong><span class="koboSpan" id="kobo.189.1">: The slices used for the keys and sorted values are declared as their zero values, even though we already know how many keys are values we will be sorting. </span><span class="koboSpan" id="kobo.189.2">Under the hood, the Go runtime will have to expand the underlying arrays and copy the data as the number of </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">values grows.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.191.1">We can add robustness to this function by addressing the issues we’ve found with the original implementation. </span><span class="koboSpan" id="kobo.191.2">This code refactoring is relatively straightforward, as this function is currently </span><a id="_idIndexMarker860"/><span class="koboSpan" id="kobo.192.1">operating in isolation from any other code. </span><span class="koboSpan" id="kobo.192.2">A revised version is </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.194.1">
type SortDirection int
const (
</span><strong class="bold"><span class="koboSpan" id="kobo.195.1">  ASC SortDirection = iota</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.196.1">  DESC</span></strong><span class="koboSpan" id="kobo.197.1">
) 
// GetSortedValues returns the key-sorted values of a given map.
</span><span class="koboSpan" id="kobo.197.2">func </span><strong class="bold"><span class="koboSpan" id="kobo.198.1">GetSortedValues(input map[int]string, dir SortDirection) ([]string, error)</span></strong><span class="koboSpan" id="kobo.199.1"> {
  if input == nil {
</span><strong class="bold"><span class="koboSpan" id="kobo.200.1">      return nil, fmt.Errorf("cannot sort nil input map")</span></strong><span class="koboSpan" id="kobo.201.1">
  }
</span><strong class="bold"><span class="koboSpan" id="kobo.202.1">  keys := make([]int, 0, len(input))</span></strong><span class="koboSpan" id="kobo.203.1">
  for k := range input {
    keys = append(keys, k)
  }
  switch dir {
</span><strong class="bold"><span class="koboSpan" id="kobo.204.1">    case ASC:</span></strong><span class="koboSpan" id="kobo.205.1">
      sort.Slice(keys, func(i, j int) bool {
        return keys[i] &lt; keys[j]
      })
</span><strong class="bold"><span class="koboSpan" id="kobo.206.1">    case DESC:</span></strong><span class="koboSpan" id="kobo.207.1">
      sort.Slice(keys, func(i, j int) bool {
return keys[i] &gt; keys[j]
})
    </span><strong class="bold"><span class="koboSpan" id="kobo.208.1">default:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.209.1">      return nil, fmt.Errorf("sort direction not recognized")</span></strong><span class="koboSpan" id="kobo.210.1">
    }
</span><strong class="bold"><span class="koboSpan" id="kobo.211.1">    vals := make([]string, 0, len(input))</span></strong><span class="koboSpan" id="kobo.212.1">
    for _, k := range keys {
      vals = append(vals, input[k])
    }
    return vals, nil
}</span></pre>
<p><span class="koboSpan" id="kobo.213.1">The changes we have made to this simple function have addressed a lot of the issues that we </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">previously identified:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.215.1">We introduce a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">SortDirection</span></strong><span class="koboSpan" id="kobo.217.1"> type to replace the string value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">dir</span></strong><span class="koboSpan" id="kobo.219.1"> parameter. </span><span class="koboSpan" id="kobo.219.2">This type is used to create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">enum</span></strong><span class="koboSpan" id="kobo.221.1"> with the acceptable sort </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">direction values.</span></span></li>
<li><span class="koboSpan" id="kobo.223.1">The signature of the </span><a id="_idIndexMarker861"/><span class="koboSpan" id="kobo.224.1">function has been changed to take the input map as a parameter, removing its dependency from the input map global variable. </span><span class="koboSpan" id="kobo.224.2">The function also returns a second error value in the case that it cannot complete its operation. </span></li>
<li><span class="koboSpan" id="kobo.225.1">Alternatively, we could have allowed the </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">GetSortedValues</span></strong><span class="koboSpan" id="kobo.227.1"> function to take a sorting function as a parameter, allowing the caller to implement their custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">sort</span></strong><span class="koboSpan" id="kobo.229.1"> functions. </span><span class="koboSpan" id="kobo.229.2">This would allow us to move the entire sorting logic outside the function, but would also give calling code a lot </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">more flexibility.</span></span></li>
<li><span class="koboSpan" id="kobo.231.1">In the case that the input map is nil, the function returns an error and stops being executed. </span><span class="koboSpan" id="kobo.231.2">This is the behavior we have decided to implement for the function, making it clear to the user that an uninitialized map is considered an </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">error case.</span></span></li>
<li><span class="koboSpan" id="kobo.233.1">Slices used for saving keys and values are initialized with the same capacity as the length of the input map. </span><span class="koboSpan" id="kobo.233.2">Appending values to these slices will not cause data reallocations and copying under the hood. </span><span class="koboSpan" id="kobo.233.3">As this is a small sample function, we will assume that the size of the map is enough to load in memory, but this might not be the case when processing very </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">large datasets.</span></span></li>
<li><span class="koboSpan" id="kobo.235.1">We make use of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">switch</span></strong><span class="koboSpan" id="kobo.237.1"> statement to check the values of the newly implemented </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">SortDirection</span></strong><span class="koboSpan" id="kobo.239.1">. </span><span class="koboSpan" id="kobo.239.2">The function has two acceptable cases for ascending and descending sort orders and returns an error in the case that another </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">enum</span></strong><span class="koboSpan" id="kobo.241.1"> value is introduced without the correct implementation. </span><span class="koboSpan" id="kobo.241.2">Both cases implement sorting using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">sort.Slice</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.243.1"> function.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.244.1">These changes have added robustness to our simple function, making it easier and more intuitive to use. </span><span class="koboSpan" id="kobo.244.2">We </span><a id="_idIndexMarker862"/><span class="koboSpan" id="kobo.245.1">have also seen that adding code robustness is all about small changes, which add up to big improvements in our code stability and readability. </span></p>
<p><span class="koboSpan" id="kobo.246.1">Once we get into the habit of writing code with robustness and stability in mind, it becomes a habit to build it into our solutions, removing the need to return and refactor it later. </span><span class="koboSpan" id="kobo.246.2">As we have stated multiple times, test code is just as important as implementation code. </span><span class="koboSpan" id="kobo.246.3">Therefore, it should also be designed with robustness in mind. </span><span class="koboSpan" id="kobo.246.4">In the next sections, we will explore two strategies for writing robust test code that verifies </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">edge cases.</span></span></p>
<h1 id="_idParaDest-201"><a id="_idTextAnchor223"/><span class="koboSpan" id="kobo.248.1">Usages of fuzzing</span></h1>
<p><span class="koboSpan" id="kobo.249.1">As discussed previously, it is very difficult to write tests that cover all possible user scenarios and parameter value ranges. </span><span class="koboSpan" id="kobo.249.2">The number of test cases to write and maintain can become even more time-consuming than project work. </span><span class="koboSpan" id="kobo.249.3">In this section, we will explore Go’s fuzz testing capability, which can help us write tests that cover a wide variety </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">of inputs.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.251.1">Fuzz testing</span></strong><span class="koboSpan" id="kobo.252.1"> is a powerful </span><a id="_idIndexMarker863"/><span class="koboSpan" id="kobo.253.1">technique that has been used to find bugs in a wide variety of software systems, including the Go standard library itself. </span><span class="koboSpan" id="kobo.253.2">It involves generating a wide variety of values and using them as input to the UUT. </span><span class="koboSpan" id="kobo.253.3">The generated values stress-test the UUT and help uncover bugs or unexpected behavior such as panics, memory leaks, or </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">incorrect outputs.</span></span></p>
<p><span class="koboSpan" id="kobo.255.1">Fuzz tests are automated, black-box tests that can be used to detect any potential functional or security issues in our system. </span><span class="koboSpan" id="kobo.255.2">They are usually run using a </span><strong class="bold"><span class="koboSpan" id="kobo.256.1">fuzz tool</span></strong><span class="koboSpan" id="kobo.257.1">, which takes care of value generation, test </span><a id="_idIndexMarker864"/><span class="koboSpan" id="kobo.258.1">execution, and error detection. </span><span class="koboSpan" id="kobo.258.2">In this section, we will focus on using fuzzing to detect </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">functional errors.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.260.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.261.1">.2</span></em><span class="koboSpan" id="kobo.262.1"> presents an overview of the steps involved in </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">fuzz testing:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer091">
<span class="koboSpan" id="kobo.264.1"><img alt="Figure 10.2 – The main steps of fuzz testing " src="image/Figure_10.2_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.265.1">Figure 10.2 – The main steps of fuzz testing</span></p>
<p><span class="koboSpan" id="kobo.266.1">Writing fuzz tests is not very different from regular </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">unit tests:</span></span></p>
<ol>
<li value="1"><strong class="bold"><span class="koboSpan" id="kobo.268.1">Identify the fuzz target</span></strong><span class="koboSpan" id="kobo.269.1">: Just like </span><a id="_idIndexMarker865"/><span class="koboSpan" id="kobo.270.1">with normal tests, we begin by identifying the UUT. </span><span class="koboSpan" id="kobo.270.2">The fuzz target will be the function that we will cover in </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">our tests.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.272.1">Identify fuzz arguments</span></strong><span class="koboSpan" id="kobo.273.1">: The fuzz target is only suitable for fuzz testing if it takes in at least one parameter. </span><span class="koboSpan" id="kobo.273.2">These are the parameters that will be generated by the fuzz tool and used as input for the previously identified </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">fuzz target.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.275.1">Generate fuzzed values</span></strong><span class="koboSpan" id="kobo.276.1">: Once the test is specified, the fuzz tool will begin to generate the random values for our </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">fuzz arguments.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.278.1">Run tests with fuzzed values</span></strong><span class="koboSpan" id="kobo.279.1">: The tests are executed with the generated fuzzed values. </span><span class="koboSpan" id="kobo.279.2">Typically, fuzz tests are fast-running unit tests, as they will be run with a large amount of generated fuzzed values. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.280.1">Report and log failures</span></strong><span class="koboSpan" id="kobo.281.1">: The test </span><a id="_idIndexMarker866"/><span class="koboSpan" id="kobo.282.1">runner will execute the tests, logging and reporting failures. </span><span class="koboSpan" id="kobo.282.2">Just like unit tests, fuzz tests can include assertions and verifications. </span></li>
</ol>
<p><span class="koboSpan" id="kobo.283.1">Fuzz testing can be used to </span><a id="_idIndexMarker867"/><span class="koboSpan" id="kobo.284.1">validate any input values that the UUT or fuzz target has not generated. </span><span class="koboSpan" id="kobo.284.2">These can be values coming from other services in the system or from outside sources. </span><span class="koboSpan" id="kobo.284.3">It can be applied to files, policies, applications, and libraries. </span></p>
<h2 id="_idParaDest-202"><a id="_idTextAnchor224"/><span class="koboSpan" id="kobo.285.1">Fuzz testing in Go</span></h2>
<p><span class="koboSpan" id="kobo.286.1">The ability to fuzz-test is an important </span><a id="_idIndexMarker868"/><span class="koboSpan" id="kobo.287.1">component of a well-rounded testing strategy. </span><span class="koboSpan" id="kobo.287.2">Fuzzing was added to the standard Go testing library in Go version 1.18. </span><span class="koboSpan" id="kobo.287.3">This feature was highly anticipated by the Go community, making writing fuzzed tests as easy as writing </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">unit tests.</span></span></p>
<p><span class="koboSpan" id="kobo.289.1">Just like tests and benchmarks, fuzzed tests must follow a </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">few rules:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.291.1">Tests must begin with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">Fuzz</span></strong><span class="koboSpan" id="kobo.293.1"> prefix. </span><span class="koboSpan" id="kobo.293.2">We notice that tests are exported functions, defined by starting with a capital letter. </span><span class="koboSpan" id="kobo.293.3">For example, a fuzz test for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">GetSortedValues</span></strong><span class="koboSpan" id="kobo.295.1"> function would be </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">FuzzGetSortedValues</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.299.1">Tests must be defined in test files named with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">_test.go</span></strong><span class="koboSpan" id="kobo.301.1"> postfix. </span><span class="koboSpan" id="kobo.301.2">As with other test files, we should use the name of the source file to name our test file. </span><span class="koboSpan" id="kobo.301.3">For example, if our sorting function was defined in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">sort.go</span></strong><span class="koboSpan" id="kobo.303.1"> file, then its corresponding test file could be </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">sort_test.go</span></strong><span class="koboSpan" id="kobo.305.1">. </span></li>
<li><span class="koboSpan" id="kobo.306.1">Tests must accept a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">*testing.F</span></strong><span class="koboSpan" id="kobo.308.1"> parameter and have no return values. </span><span class="koboSpan" id="kobo.308.2">This is the way fuzzed tests interact with the test runner and </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">fuzzing tool.</span></span></li>
<li><span class="koboSpan" id="kobo.310.1">The fuzz target is defined by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">Fuzz</span></strong><span class="koboSpan" id="kobo.312.1"> function on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">*testing.F</span></strong><span class="koboSpan" id="kobo.314.1"> parameter. </span><span class="koboSpan" id="kobo.314.2">This function takes in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">*testing.T</span></strong><span class="koboSpan" id="kobo.316.1"> parameter, followed by the fuzzing arguments. </span><span class="koboSpan" id="kobo.316.2">There can only be one fuzz target per test and the calls on the UUT will happen inside the fuzz target. </span></li>
<li><span class="koboSpan" id="kobo.317.1">Fuzz arguments are added to the fuzzing tool using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">Add</span></strong><span class="koboSpan" id="kobo.319.1"> function on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">*testing.F</span></strong><span class="koboSpan" id="kobo.321.1"> parameter. </span><span class="koboSpan" id="kobo.321.2">This will instruct the tool to generate values to be used in the </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">fuzz target.</span></span></li>
<li><span class="koboSpan" id="kobo.323.1">Fuzzing arguments can be of the </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">following types:</span></span><ol><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">string</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">[]byte</span></strong></span></li><li><span class="koboSpan" id="kobo.328.1">All </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">int</span></strong><span class="koboSpan" id="kobo.330.1"> types, </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">including </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">rune</span></strong></span></li><li><span class="koboSpan" id="kobo.333.1">All </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">uint</span></strong><span class="koboSpan" id="kobo.335.1"> types, </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">including </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">byte</span></strong></span></li><li><span class="koboSpan" id="kobo.338.1">All </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">float</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.340.1"> types</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">bool</span></strong> </li></ol></li>
<li><span class="koboSpan" id="kobo.342.1">Due to a large number of test runs, fuzz tests will be run in parallel. </span><span class="koboSpan" id="kobo.342.2">They should therefore </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">be deterministic.</span></span></li>
<li><span class="koboSpan" id="kobo.344.1">Fuzz tests are run alongside your other unit tests using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">go test</span></strong><span class="koboSpan" id="kobo.346.1"> command or with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">-fuzz</span></strong><span class="koboSpan" id="kobo.348.1"> flag followed by a test name or package. </span><span class="koboSpan" id="kobo.348.2">Again, this is similar to how we run </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">benchmark tests.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.350.1">The fuzzing tool monitors </span><a id="_idIndexMarker869"/><span class="koboSpan" id="kobo.351.1">the test runs and reports errors that have occurred. </span><span class="koboSpan" id="kobo.351.2">Fuzz tests can fail for a few reasons: panics, test failures, non-recoverable errors, or timeouts. </span><span class="koboSpan" id="kobo.351.3">By default, the timeout for a fuzz target is 1 second, so your tests should be fast. </span></p>
<p><span class="koboSpan" id="kobo.352.1">Fuzzed tests will continue to run until a failing input is found or until the user cancels the test run manually. </span><span class="koboSpan" id="kobo.352.2">Alternatively, we can supply a maximum execution time or the maximum number of iterations using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">–fuzztime</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.354.1">command-line parameter.</span></span></p>
<h3><span class="koboSpan" id="kobo.355.1">A simple fuzz test</span></h3>
<p><span class="koboSpan" id="kobo.356.1">We can write a </span><a id="_idIndexMarker870"/><span class="koboSpan" id="kobo.357.1">simple fuzz test for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">GetSortedValues</span></strong><span class="koboSpan" id="kobo.359.1"> function we wrote in the previous section:  </span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.360.1">func FuzzGetSortedValues_ASC(f *testing.F) </span></strong><span class="koboSpan" id="kobo.361.1">{
  input := map[int]string{
    99: "B",
    0:  "A",
  }
</span><strong class="bold"><span class="koboSpan" id="kobo.362.1">  f.Add(3, "W")</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.363.1">  f.Fuzz(func(t *testing.T, k int, v string) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.364.1">    input[k] = v</span></strong><span class="koboSpan" id="kobo.365.1">
    keys := make([]int, 0, len(input))
    for k := range input {
      keys = append(keys, k)
    }
    sort.Ints(keys)
</span><strong class="bold"><span class="koboSpan" id="kobo.366.1">    sortedValues, err := GetSortedValues(input, ASC)</span></strong><span class="koboSpan" id="kobo.367.1">
    require.Nil(t, err)
    require.NotNil(t, sortedValues)
    for index, v := range sortedValues {
      key := keys[index]
</span><strong class="bold"><span class="koboSpan" id="kobo.368.1">      assert.Equal(t, input[key], v)</span></strong><span class="koboSpan" id="kobo.369.1">
    }
  })
}</span></pre>
<p><span class="koboSpan" id="kobo.370.1">We have written </span><a id="_idIndexMarker871"/><span class="koboSpan" id="kobo.371.1">the fuzzed test according to the rules we have discussed and with the same techniques we use for unit tests: </span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.372.1">We declare a fuzz test using the required signature. </span><span class="koboSpan" id="kobo.372.2">The test starts with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">Fuzz</span></strong><span class="koboSpan" id="kobo.374.1"> prefix and takes in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">*</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">testing.F</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.377.1"> parameter.</span></span></li>
<li><span class="koboSpan" id="kobo.378.1">We add two fuzz testing arguments to the fuzz testing tool using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">f.Add</span></strong><span class="koboSpan" id="kobo.380.1"> method, one for the map key of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">int</span></strong><span class="koboSpan" id="kobo.382.1"> type and one of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">string</span></strong><span class="koboSpan" id="kobo.384.1"> type for the map value. </span><span class="koboSpan" id="kobo.384.2">These values will be generated by the fuzzing tool. </span><span class="koboSpan" id="kobo.384.3">Both of these types are accepted for </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">fuzzing arguments.</span></span></li>
<li><span class="koboSpan" id="kobo.386.1">We define the fuzz target using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">f.Fuzz</span></strong><span class="koboSpan" id="kobo.388.1"> method. </span><span class="koboSpan" id="kobo.388.2">This method takes a function as a parameter, which itself takes the fuzzing arguments as parameters. </span><span class="koboSpan" id="kobo.388.3">The function also takes in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">*testing.T</span></strong><span class="koboSpan" id="kobo.390.1"> parameter, which makes it possible for us to write test assertions inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">fuzz target.</span></span></li>
<li><span class="koboSpan" id="kobo.392.1">Inside the fuzz target, we write the testing code. </span><span class="koboSpan" id="kobo.392.2">We add the fuzzing arguments to the map, using the generated values to test our functionality. </span><span class="koboSpan" id="kobo.392.3">Then, we extract the keys from the map and sort them in </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">ascending order.</span></span></li>
<li><span class="koboSpan" id="kobo.394.1">We invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">GetSortedValues</span></strong><span class="koboSpan" id="kobo.396.1"> function, which is our UUT for this test, passing it the input map that now contains the fuzzing arguments. </span></li>
<li><span class="koboSpan" id="kobo.397.1">At the end of the test, we use the previously sorted slice of keys to assert that the values returned are </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">sorted correctly.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.399.1">We have successfully </span><a id="_idIndexMarker872"/><span class="koboSpan" id="kobo.400.1">written our first fuzzed test. </span><span class="koboSpan" id="kobo.400.2">We can run it using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">go test</span></strong><span class="koboSpan" id="kobo.402.1"> command with two </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">configuration flags:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.404.1">
$ go test </span><strong class="bold"><span class="koboSpan" id="kobo.405.1">-fuzz FuzzGetSortedValues_ASC -fuzztime 5s ./chapter10/fragile-revised -v</span></strong><span class="koboSpan" id="kobo.406.1">
=== FUZZ  FuzzGetSortedValues_ASC
fuzz: elapsed: 0s, gathering baseline coverage: 0/711 completed
fuzz: elapsed: 1s, </span><strong class="bold"><span class="koboSpan" id="kobo.407.1">gathering baseline coverage: 711/711 completed, now fuzzing with 8 workers</span></strong><span class="koboSpan" id="kobo.408.1">
fuzz: elapsed: 3s, execs: 10707 (3569/sec), </span><strong class="bold"><span class="koboSpan" id="kobo.409.1">new interesting: 54</span></strong><span class="koboSpan" id="kobo.410.1"> (total: 765)
fuzz: elapsed: 5s, execs: 17519 (3262/sec), new interesting: 67 (total: 778)
--- PASS: FuzzGetSortedValues_ASC (5.14s)
PASS
ok      github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter10/fragile-revised      5.303s</span></pre>
<p><span class="koboSpan" id="kobo.411.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">–fuzz</span></strong><span class="koboSpan" id="kobo.413.1"> flag instructs the test runner to execute the fuzzed test specified by name, while the </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">–fuzztime</span></strong><span class="koboSpan" id="kobo.415.1"> flag specifies that the test should run for a maximum of 5 seconds. </span><span class="koboSpan" id="kobo.415.2">The output of our test run highlights some key metrics of the </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">test run:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">elapsed</span></strong><span class="koboSpan" id="kobo.418.1"> indicates the amount of </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">processing time</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">baseline coverage</span></strong><span class="koboSpan" id="kobo.421.1"> indicates the number of scenarios that are applied to measure the coverage provided by </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">the tests</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">execs</span></strong><span class="koboSpan" id="kobo.424.1"> indicates the </span><a id="_idIndexMarker873"/><span class="koboSpan" id="kobo.425.1">number of test cases that have been run with the </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">fuzz target</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">new interesting</span></strong><span class="koboSpan" id="kobo.428.1"> is the number of new inputs that are identified that expand the coverage of the </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">fuzzed test</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.430.1">Now that we understand how to write and run fuzzed tests, we are ready to add them to our own testing strategies. </span><span class="koboSpan" id="kobo.430.2">However, it does have some drawbacks. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.431.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.432.1">.3</span></em><span class="koboSpan" id="kobo.433.1"> presents some of the advantages and disadvantages of </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">fuzz testing:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer092">
<span class="koboSpan" id="kobo.435.1"><img alt="Figure 10.3 – Advantages and disadvantages of fuzz testing " src="image/Figure_10.3_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.436.1">Figure 10.3 – Advantages and disadvantages of fuzz testing</span></p>
<p><span class="koboSpan" id="kobo.437.1">The advantages of </span><a id="_idIndexMarker874"/><span class="koboSpan" id="kobo.438.1">fuzz testing are as follows: </span></p>
<ol>
<li value="1"><strong class="bold"><span class="koboSpan" id="kobo.439.1">Easy to use and implement</span></strong><span class="koboSpan" id="kobo.440.1">: As fuzzing integrates with Go’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">testing</span></strong><span class="koboSpan" id="kobo.442.1"> package, we can easily write fuzzed tests for anything in Go. </span><span class="koboSpan" id="kobo.442.2">However, it’s important to keep the scope of the tests small so that they can be executed quickly </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">and efficiently.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.444.1">Can be used early in the development life cycle</span></strong><span class="koboSpan" id="kobo.445.1">: As we have seen in our simple example, fuzzed tests can be written for functions or even small units of code. </span><span class="koboSpan" id="kobo.445.2">This makes it easy to leverage them at any stage of the development </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">life cycle.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.447.1">Detects a wide variety of bugs</span></strong><span class="koboSpan" id="kobo.448.1">: Fuzzed testing generates values that cover edge cases and run over many executions. </span><span class="koboSpan" id="kobo.448.2">This makes it a great tool for detecting bugs that would otherwise not have been possible to find. </span></li>
</ol>
<p><span class="koboSpan" id="kobo.449.1">The disadvantages </span><a id="_idIndexMarker875"/><span class="koboSpan" id="kobo.450.1">of fuzz testing are </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">as follows:</span></span></p>
<ol>
<li value="1"><strong class="bold"><span class="koboSpan" id="kobo.452.1">Does not replace traditional testing</span></strong><span class="koboSpan" id="kobo.453.1">: Fuzzing complements rather than substitutes the types of tests that we have explored throughout this book. </span><span class="koboSpan" id="kobo.453.2">Therefore, it can take additional engineering effort to write these tests. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.454.1">Does not provide guarantees</span></strong><span class="koboSpan" id="kobo.455.1">: Fuzzed tests only provide an indication of the stability of the UUT, not a guarantee. </span><span class="koboSpan" id="kobo.455.2">As it generates random values, it can only indicate to developers the presence of bugs for the inputs it does cover. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.456.1">Memory- &amp; CPU-intensive</span></strong><span class="koboSpan" id="kobo.457.1">: As we have seen from our example output, fuzzed tests are run in parallel over a large number of scenarios. </span><span class="koboSpan" id="kobo.457.2">This makes them more memory- and CPU-intensive than unit tests. </span></li>
</ol>
<p><span class="koboSpan" id="kobo.458.1">Despite its drawbacks, fuzz testing is a useful and powerful testing technique that complements all the traditional testing methods we have explored so far. </span><span class="koboSpan" id="kobo.458.2">As it is able to generate a wide variety </span><a id="_idIndexMarker876"/><span class="koboSpan" id="kobo.459.1">of inputs, fuzz testing is also an important tool that can help uncover security vulnerabilities. </span><span class="koboSpan" id="kobo.459.2">In security fuzz testing, we input malicious data to a program, while in functional fuzz testing, we input invalid data. </span><span class="koboSpan" id="kobo.459.3">We will not focus on security testing in this book, but it is another great use for fuzzing. </span><span class="koboSpan" id="kobo.459.4">It is especially useful for ensuring our systems remain stable in edge cases or when processing </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">user inputs.</span></span></p>
<h1 id="_idParaDest-203"><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.461.1">Property-based testing</span></h1>
<p><span class="koboSpan" id="kobo.462.1">Fuzz testing is a great step forward when testing edge cases in our application. </span><span class="koboSpan" id="kobo.462.2">We can think of it as analogous to </span><a id="_idIndexMarker877"/><span class="koboSpan" id="kobo.463.1">chaos testing, where we test a huge variety of edge cases in the hope of detecting an error. </span><span class="koboSpan" id="kobo.463.2">However, we do not have any control over the random inputs. </span><span class="koboSpan" id="kobo.463.3">This leads to </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">two problems:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.465.1">We test a large number of irrelevant scenarios that are unlikely to happen in </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">our system.</span></span></li>
<li><span class="koboSpan" id="kobo.467.1">We don’t know whether the scenarios that really matter have been covered by our fuzzed tests. </span><span class="koboSpan" id="kobo.467.2">Instead, it would be great if we had a more structured approach available </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">to us.</span></span></li>
</ul>
<p><strong class="bold"><span class="koboSpan" id="kobo.469.1">Property-based testing</span></strong><span class="koboSpan" id="kobo.470.1"> is a testing technique that involves testing a program against a set of properties or</span><a id="_idIndexMarker878"/><span class="koboSpan" id="kobo.471.1"> specifications that are important to our user journeys and system behavior. </span><span class="koboSpan" id="kobo.471.2">This allows engineers to follow a systemic approach to testing, as opposed to focusing on </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">verifying inputs.</span></span></p>
<p><span class="koboSpan" id="kobo.473.1">In property-based testing, we generate random inputs that satisfy the set of constraints or properties that we have identified. </span><span class="koboSpan" id="kobo.473.2">The generation aspect ensures that we test against a larger space of edge cases than would have been possible with traditional, manually written tests. </span><span class="koboSpan" id="kobo.473.3">The focus on properties ensures that we cover the edge cases that matter to our applications. </span><span class="koboSpan" id="kobo.473.4">Again, this does not guarantee the absence of bugs, but it does ensure that we spend our time testing the things </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">that matter.</span></span></p>
<p><span class="koboSpan" id="kobo.475.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">testing/quick</span></strong><span class="koboSpan" id="kobo.477.1"> package offers testing helper functionality that we can leverage to implement </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">property-based tests:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.479.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">quick.Check</span></strong><span class="koboSpan" id="kobo.481.1"> function t</span><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.482.1">akes in a function with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">bool</span></strong><span class="koboSpan" id="kobo.484.1"> return value and searches for arbitrary values that make the input function </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">return </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.488.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">quick.CheckEqual</span></strong><span class="koboSpan" id="kobo.490.1"> function takes in two functions and looks for an input for which the functions return </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">different results.</span></span></li>
<li><span class="koboSpan" id="kobo.492.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">quick.Generator</span></strong><span class="koboSpan" id="kobo.494.1"> interface defines a Generate method that custom types can implement. </span><span class="koboSpan" id="kobo.494.2">Once they satisfy this interface, we can generate random values for our custom types using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">quick.Value</span></strong><span class="koboSpan" id="kobo.496.1"> function. </span><span class="koboSpan" id="kobo.496.2">This gives us the flexibility to generate values for any exported type. </span></li>
</ul>
<p><span class="koboSpan" id="kobo.497.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">Check</span></strong><span class="koboSpan" id="kobo.499.1"> functions of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">quick</span></strong><span class="koboSpan" id="kobo.501.1"> package also take in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">*quick.Config</span></strong><span class="koboSpan" id="kobo.503.1"> parameter that allows us to configure our test run with the maximum number of iterations or another </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">random generator.</span></span></p>
<p><span class="koboSpan" id="kobo.505.1">This type of testing is intuitive and easy to achieve. </span><span class="koboSpan" id="kobo.505.2">Looking back at the fuzzing example we implemented, the verifications in the fuzz target only asserted the order of the elements, not the values </span><a id="_idIndexMarker879"/><span class="koboSpan" id="kobo.506.1">themselves. </span><span class="koboSpan" id="kobo.506.2">In fact, without realizing it, we wrote our first property-based test. </span><span class="koboSpan" id="kobo.506.3">The real value of property-based testing, however, lies in its search for failing function inputs, as opposed to generating fully random values. </span></p>
<p><span class="koboSpan" id="kobo.507.1">We can re-implement our previously implemented fuzz test with property-based testing </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">in mind:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.509.1">func TestGetSortedValues_ASC(t *testing.T)</span></strong><span class="koboSpan" id="kobo.510.1"> {
  input := map[int]string{
    99: "B",
    0:  "A",
  }
</span><strong class="bold"><span class="koboSpan" id="kobo.511.1">  isSorted := func(k int, val string) bool</span></strong><span class="koboSpan" id="kobo.512.1"> {
</span><strong class="bold"><span class="koboSpan" id="kobo.513.1">    input[k] = val</span></strong><span class="koboSpan" id="kobo.514.1">
    keys := make([]int, 0, len(input))
    for k := range input {
      keys = append(keys, k)
    }
    sort.Ints(keys)
</span><strong class="bold"><span class="koboSpan" id="kobo.515.1">    sortedValues, err := fr.GetSortedValues(input, fr.ASC)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.516.1">    if err != nil || sortedValues == nil {</span></strong><span class="koboSpan" id="kobo.517.1">
      return false
    }
    for index, v := range sortedValues {
      key := keys[index]
</span><strong class="bold"><span class="koboSpan" id="kobo.518.1">      if input[key] != v {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.519.1">        return false</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.520.1">      }</span></strong><span class="koboSpan" id="kobo.521.1">
    }
    return true
  }
</span><strong class="bold"><span class="koboSpan" id="kobo.522.1">  if err := quick.Check(isSorted, nil); err != nil {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.523.1">    t.Error(err)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.524.1">  }</span></strong><span class="koboSpan" id="kobo.525.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.526.1">The structure of the test is different, but it uses the same verifications as in the </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">fuzzing test:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.528.1">The test uses the regular unit test signature, starting with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">Test</span></strong><span class="koboSpan" id="kobo.530.1"> prefix and taking in a single parameter of </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">*testing.T</span></strong><span class="koboSpan" id="kobo.532.1">. </span></li>
<li><span class="koboSpan" id="kobo.533.1">Inside the test, we declare an </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">isSorted</span></strong><span class="koboSpan" id="kobo.535.1"> helper function, which takes in the two arguments we </span><a id="_idIndexMarker880"/><span class="koboSpan" id="kobo.536.1">will generate, one for the key and one for the value of our new map entry. </span><span class="koboSpan" id="kobo.536.2">It also returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">bool</span></strong><span class="koboSpan" id="kobo.538.1"> value, making it suitable to be used with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">quick.Check</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.540.1"> function.</span></span></li>
<li><span class="koboSpan" id="kobo.541.1">Inside the function, we add the generated values to the input map. </span><span class="koboSpan" id="kobo.541.2">Then, we copy the keys and sort them. </span><span class="koboSpan" id="kobo.541.3">We call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">GetSortedValues</span></strong><span class="koboSpan" id="kobo.543.1"> function and our UUT and get the actual values </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">to verify.</span></span></li>
<li><span class="koboSpan" id="kobo.545.1">In the case of an error or a nil slice, we return </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">false</span></strong><span class="koboSpan" id="kobo.547.1">, stopping the test. </span><span class="koboSpan" id="kobo.547.2">We also return </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">false</span></strong><span class="koboSpan" id="kobo.549.1"> if the sorted values are not as expected. </span><span class="koboSpan" id="kobo.549.2">This will signal to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">quick.Check</span></strong><span class="koboSpan" id="kobo.551.1"> function that an error has occurred. </span></li>
<li><span class="koboSpan" id="kobo.552.1">Inside the test, we pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">isSorted</span></strong><span class="koboSpan" id="kobo.554.1"> helper function to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">quick.Check</span></strong><span class="koboSpan" id="kobo.556.1"> function and fail the test if it returns an error. </span></li>
</ol>
<p><span class="koboSpan" id="kobo.557.1">In the case of error, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">quick.Check</span></strong><span class="koboSpan" id="kobo.559.1"> function will report the values that have caused the failure. </span><span class="koboSpan" id="kobo.559.2">Forcing the </span><a id="_idIndexMarker881"/><span class="koboSpan" id="kobo.560.1">test to fail, we will receive an output with information about the inputs that caused the failure: </span></p>
<pre class="console"><span class="koboSpan" id="kobo.561.1">
$ go test -run TestGetSortedValues_ASC ./chapter10/fragile-revised -v
=== RUN   TestGetSortedValues_ASC
</span><strong class="bold"><span class="koboSpan" id="kobo.562.1">  sort_test.go:62: #1: failed on input 73546389, "\U000773b8"</span></strong><span class="koboSpan" id="kobo.563.1">
--- FAIL: TestGetSortedValues_ASC (0.00s)
FAIL
exit status 1
FAIL    github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter10/fragile-revised      0.154s</span></pre>
<p><span class="koboSpan" id="kobo.564.1">The input values causing the failure can be used by engineers to debug the application and fix the cause of </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">the failure.</span></span></p>
<p><span class="koboSpan" id="kobo.566.1">The two testing techniques we have covered in this chapter, fuzz testing and property-based testing, allow us to take advantage of value generation and test a wide variety of edge cases for our system inputs. </span><span class="koboSpan" id="kobo.566.2">These testing techniques are complementary to the robust code best practices discussed at the beginning of the chapter and allow us to ensure the stability and reliability of </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">our services.</span></span></p>
<h1 id="_idParaDest-204"><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.568.1">Use case – edge cases of the BookSwap application</span></h1>
<p><span class="koboSpan" id="kobo.569.1">This chapter has taught us two new testing techniques: fuzzed testing and property-based testing. </span><span class="koboSpan" id="kobo.569.2">We have learned how to apply these to a simple function that provided the functionality of returning the key-sorted values contained inside an input map. </span><span class="koboSpan" id="kobo.569.3">In this section, we </span><a id="_idIndexMarker882"/><span class="koboSpan" id="kobo.570.1">will end our exploration with a discussion of how these techniques can be applied to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">BookSwap</span></strong><span class="koboSpan" id="kobo.572.1"> application we have built so far. </span></p>
<p><span class="koboSpan" id="kobo.573.1">As previously discussed, robust code should test any variables that it does not generate itself. </span><span class="koboSpan" id="kobo.573.2">We named these inputs as being from untrusted sources. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.574.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.575.1">.4</span></em><span class="koboSpan" id="kobo.576.1"> presents all the inputs that can be considered untrusted from the viewpoint of the </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">processing service:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer093">
<span class="koboSpan" id="kobo.578.1"><img alt="Figure 10.4 – Untrusted input in the BookSwap application " src="image/Figure_10.4_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.579.1">Figure 10.4 – Untrusted input in the BookSwap application</span></p>
<p><span class="koboSpan" id="kobo.580.1">We identify two sources of untrusted input </span><a id="_idIndexMarker883"/><span class="koboSpan" id="kobo.581.1">within the services </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">BookSwap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">UserService</span></strong><span class="koboSpan" id="kobo.586.1"> receives input from the user. </span><span class="koboSpan" id="kobo.586.2">As we have no control over what the user submits, this interaction is a source of untrusted input. </span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">UserService</span></strong><span class="koboSpan" id="kobo.588.1"> receives information from </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">BookService</span></strong><span class="koboSpan" id="kobo.590.1">. </span><span class="koboSpan" id="kobo.590.2">As you may remember from our discussion in </span><a href="B18371_08.xhtml#_idTextAnchor179"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.591.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.592.1">, </span><em class="italic"><span class="koboSpan" id="kobo.593.1">Testing Microservice Architectures</span></em><span class="koboSpan" id="kobo.594.1">, microservices change without any central oversight. </span><span class="koboSpan" id="kobo.594.2">Therefore, as </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">UserService</span></strong><span class="koboSpan" id="kobo.596.1"> does not have any control over the functionality provided by this external service, this interaction is a source of </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">untrusted input.</span></span></li>
<li><span class="koboSpan" id="kobo.598.1">The same applies to </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">BookService</span></strong><span class="koboSpan" id="kobo.600.1">, which receives requests from </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">UserService</span></strong><span class="koboSpan" id="kobo.602.1">. </span><span class="koboSpan" id="kobo.602.2">While this </span><a id="_idIndexMarker884"/><span class="koboSpan" id="kobo.603.1">interaction does not actively send input to </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">BookService</span></strong><span class="koboSpan" id="kobo.605.1">, the request still contains </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">untrusted information.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.607.1">Based on these insights, we can identify the need to implement fuzz testing for the HTTP handlers exposed by </span><a id="_idIndexMarker885"/><span class="koboSpan" id="kobo.608.1">our web application. </span><span class="koboSpan" id="kobo.608.2">We will test the user creation operation that we have also tested in previous chapters. </span><span class="koboSpan" id="kobo.608.3">Fuzz testing of HTTP endpoints can easily achieve this using Go’s </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">fuzzing capability:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.610.1">
func FuzzTestUserCreation(f *testing.F) {
  // other initialization
</span><strong class="bold"><span class="koboSpan" id="kobo.611.1">  f.Add("test user", "1 London Road", "N1", "UK")</span></strong><span class="koboSpan" id="kobo.612.1">
 </span><strong class="bold"><span class="koboSpan" id="kobo.613.1"> f.Fuzz(func(t *testing.T, name string, address string,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.614.1">    postCode string, country string)</span></strong><span class="koboSpan" id="kobo.615.1"> {
    requestBody, err := json.Marshal(map[string]string{
      "name":      name,
      "address":   address,
      "post_code": postCode,
      "country":   country,
    })
    require.Nil(t, err)
    req := bytes.NewBuffer(requestBody)
</span><strong class="bold"><span class="koboSpan" id="kobo.616.1">    resp, err := http.Post(userEndpoint, "application/json", req)</span></strong><span class="koboSpan" id="kobo.617.1">
    assert.Nil(t, err)
    defer resp.Body.Close()
    assert.Equal(t, http.StatusOK, resp.StatusCode)
    assert.Nil(t, err)
    assert.NotNil(t, resp)
  })
}</span></pre>
<p><span class="koboSpan" id="kobo.618.1">Other than the interaction with the fuzz testing tool for setting up the fuzzing target and arguments, the body of this test is identical to the HTTP testing we are already familiar with. </span><span class="koboSpan" id="kobo.618.2">We add four fuzzing arguments for the fields that the user creation request needs. </span><span class="koboSpan" id="kobo.618.3">Inside the fuzzing </span><a id="_idIndexMarker886"/><span class="koboSpan" id="kobo.619.1">target, we create and marshal the request to JSON format. </span><span class="koboSpan" id="kobo.619.2">Finally, we send the request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">/users</span></strong><span class="koboSpan" id="kobo.621.1"> endpoint using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">http.Post</span></strong><span class="koboSpan" id="kobo.623.1"> function. </span><span class="koboSpan" id="kobo.623.2">Just as the previous fuzz testing example we have seen in this chapter, we run this test using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">LONG=true go test -fuzz FuzzTestUserCreation -fuzztime=5s ./chapter10 -v</span></strong><span class="koboSpan" id="kobo.625.1"> command. </span><span class="koboSpan" id="kobo.625.2">It requires the BookSwap application to be up and running, which we can easily do with the Docker command we've seen so far </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">docker compose -f docker-compose.book-swap.chapter10.yml up --build</span></strong><span class="koboSpan" id="kobo.627.1">. </span><span class="koboSpan" id="kobo.627.2">The test also relies on environment variables to construct the URL under test. </span><span class="koboSpan" id="kobo.627.3">If you want to run with the default values, set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">BOOKSWAP_BASE_URL</span></strong><span class="koboSpan" id="kobo.629.1"> environment variable to http://localhost and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">BOOKSWAP_PORT</span></strong><span class="koboSpan" id="kobo.631.1"> environment variable to </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">3000</span></strong><span class="koboSpan" id="kobo.633.1"> to your </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">terminal session.</span></span></p>
<p><span class="koboSpan" id="kobo.635.1">This brings us to the end of our exploration of fuzz testing and property-based testing, which are two related techniques that allow us to easily write testing strategies that cover a wide variety of edge cases. </span><span class="koboSpan" id="kobo.635.2">Both of these techniques integrate well with Go’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">testing</span></strong><span class="koboSpan" id="kobo.637.1"> package and can be easily implemented at any level of our application testing. </span></p>
<h1 id="_idParaDest-205"><a id="_idTextAnchor228"/><span class="koboSpan" id="kobo.638.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.639.1">In this chapter, we revisited our understanding and approach to covering edge cases of input variables. </span><span class="koboSpan" id="kobo.639.2">We began our discussion with the concept of code robustness, focusing on writing code that can handle unexpected inputs and errors. </span><span class="koboSpan" id="kobo.639.3">Once code robustness becomes part of our mindset, we start to understand the edge cases of our code. </span><span class="koboSpan" id="kobo.639.4">However, it can be very difficult to manually implement tests to cover all </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">these values.</span></span></p>
<p><span class="koboSpan" id="kobo.641.1">Two testing techniques leverage input generation to make this task easier: fuzz testing and property-based testing. </span><span class="koboSpan" id="kobo.641.2">Both of these techniques can be implemented with Go’s testing library, allowing us to easily leverage the benefits of these techniques to verify a broad range of edge cases to our components at any level. </span><span class="koboSpan" id="kobo.641.3">Finally, we looked at an applied example of how to use fuzz testing together with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">BookSwap</span></strong><span class="koboSpan" id="kobo.643.1"> application’s user creation flow, ensuring that it is stable for </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">generated values.</span></span></p>
<p><span class="koboSpan" id="kobo.645.1">In </span><a href="B18371_11.xhtml#_idTextAnchor231"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.646.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.647.1">, </span><em class="italic"><span class="koboSpan" id="kobo.648.1">Working with Generics</span></em><span class="koboSpan" id="kobo.649.1">, we will explore another newly introduced Go feature, namely generics. </span><span class="koboSpan" id="kobo.649.2">We will see how it can make our implementation and testing code simpler and easier to use. </span></p>
<h1 id="_idParaDest-206"><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.650.1">Questions</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.651.1">What are some of the characteristics of </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">robust code?</span></span></li>
<li><span class="koboSpan" id="kobo.653.1">What is fuzz testing? </span></li>
<li><span class="koboSpan" id="kobo.654.1">What is the signature of a fuzzed test </span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">in Go?</span></span></li>
<li><span class="koboSpan" id="kobo.656.1">What is </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">property-based testing?</span></span></li>
<li><span class="koboSpan" id="kobo.658.1">What are the untrusted inputs of the UUT? </span></li>
</ol>
<h1 id="_idParaDest-207"><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.659.1">Further reading</span></h1>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.660.1">The Art of Clean Code: Best Practices to Eliminate Complexity and Simplify Your Life</span></em><span class="koboSpan" id="kobo.661.1">, Christian Mayer, published by No </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">Starch Press</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.663.1">How to Break Software: A Practical Guide to Testing</span></em><span class="koboSpan" id="kobo.664.1">, James Whittaker, published </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">by Pearson</span></span></li>
</ul>
</div>
</body></html>