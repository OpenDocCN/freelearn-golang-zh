["```go\nvar input map[int]string\nfunc GetValues(dir string) []string {\n  var keys []int\n  for k := range input {\n    keys = append(keys, k)\n  }\n  if dir == \"asc\" {\n    sort.Ints(keys)\n  }\n  if dir == \"desc\" {\n    sort.Slice(keys, func(i, j int) bool {\n      return keys[i] > keys[j]\n    })\n  }\n  var vals []string\n  for _, k := range keys {\n    vals = append(vals, input[k])\n  }\n  return vals\n}\n```", "```go\ntype SortDirection int\nconst (\n  ASC SortDirection = iota\n  DESC\n) \n// GetSortedValues returns the key-sorted values of a given map.\nfunc GetSortedValues(input map[int]string, dir SortDirection) ([]string, error) {\n  if input == nil {\n      return nil, fmt.Errorf(\"cannot sort nil input map\")\n  }\n  keys := make([]int, 0, len(input))\n  for k := range input {\n    keys = append(keys, k)\n  }\n  switch dir {\n    case ASC:\n      sort.Slice(keys, func(i, j int) bool {\n        return keys[i] < keys[j]\n      })\n    case DESC:\n      sort.Slice(keys, func(i, j int) bool {\nreturn keys[i] > keys[j]\n})\n    default:\n      return nil, fmt.Errorf(\"sort direction not recognized\")\n    }\n    vals := make([]string, 0, len(input))\n    for _, k := range keys {\n      vals = append(vals, input[k])\n    }\n    return vals, nil\n}\n```", "```go\nfunc FuzzGetSortedValues_ASC(f *testing.F) {\n  input := map[int]string{\n    99: \"B\",\n    0:  \"A\",\n  }\n  f.Add(3, \"W\")\n  f.Fuzz(func(t *testing.T, k int, v string) {\n    input[k] = v\n    keys := make([]int, 0, len(input))\n    for k := range input {\n      keys = append(keys, k)\n    }\n    sort.Ints(keys)\n    sortedValues, err := GetSortedValues(input, ASC)\n    require.Nil(t, err)\n    require.NotNil(t, sortedValues)\n    for index, v := range sortedValues {\n      key := keys[index]\n      assert.Equal(t, input[key], v)\n    }\n  })\n}\n```", "```go\n$ go test -fuzz FuzzGetSortedValues_ASC -fuzztime 5s ./chapter10/fragile-revised -v\n=== FUZZ  FuzzGetSortedValues_ASC\nfuzz: elapsed: 0s, gathering baseline coverage: 0/711 completed\nfuzz: elapsed: 1s, gathering baseline coverage: 711/711 completed, now fuzzing with 8 workers\nfuzz: elapsed: 3s, execs: 10707 (3569/sec), new interesting: 54 (total: 765)\nfuzz: elapsed: 5s, execs: 17519 (3262/sec), new interesting: 67 (total: 778)\n--- PASS: FuzzGetSortedValues_ASC (5.14s)\nPASS\nok      github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter10/fragile-revised      5.303s\n```", "```go\nfunc TestGetSortedValues_ASC(t *testing.T) {\n  input := map[int]string{\n    99: \"B\",\n    0:  \"A\",\n  }\n  isSorted := func(k int, val string) bool {\n    input[k] = val\n    keys := make([]int, 0, len(input))\n    for k := range input {\n      keys = append(keys, k)\n    }\n    sort.Ints(keys)\n    sortedValues, err := fr.GetSortedValues(input, fr.ASC)\n    if err != nil || sortedValues == nil {\n      return false\n    }\n    for index, v := range sortedValues {\n      key := keys[index]\n      if input[key] != v {\n        return false\n      }\n    }\n    return true\n  }\n  if err := quick.Check(isSorted, nil); err != nil {\n    t.Error(err)\n  }\n}\n```", "```go\n$ go test -run TestGetSortedValues_ASC ./chapter10/fragile-revised -v\n=== RUN   TestGetSortedValues_ASC\n  sort_test.go:62: #1: failed on input 73546389, \"\\U000773b8\"\n--- FAIL: TestGetSortedValues_ASC (0.00s)\nFAIL\nexit status 1\nFAIL    github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter10/fragile-revised      0.154s\n```", "```go\nfunc FuzzTestUserCreation(f *testing.F) {\n  // other initialization\n  f.Add(\"test user\", \"1 London Road\", \"N1\", \"UK\")\n  f.Fuzz(func(t *testing.T, name string, address string,\n    postCode string, country string) {\n    requestBody, err := json.Marshal(map[string]string{\n      \"name\":      name,\n      \"address\":   address,\n      \"post_code\": postCode,\n      \"country\":   country,\n    })\n    require.Nil(t, err)\n    req := bytes.NewBuffer(requestBody)\n    resp, err := http.Post(userEndpoint, \"application/json\", req)\n    assert.Nil(t, err)\n    defer resp.Body.Close()\n    assert.Equal(t, http.StatusOK, resp.StatusCode)\n    assert.Nil(t, err)\n    assert.NotNil(t, resp)\n  })\n}\n```"]