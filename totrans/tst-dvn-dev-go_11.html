<html><head></head><body>
<div id="_idContainer099">
<h1 class="chapter-number" id="_idParaDest-208"><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.1.1">11</span></h1>
<h1 id="_idParaDest-209"><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.2.1">Working with Generics</span></h1>
<p><span class="koboSpan" id="kobo.3.1">The previous chapters have covered all the aspects of testing and code design, gradually increasing in complexity. </span><span class="koboSpan" id="kobo.3.2">These tests will allow us to verify the behavior of a wide variety of applications, including microservices architectures and services that persist data to a database service. </span><span class="koboSpan" id="kobo.3.3">We have all the knowledge to perform the functional and non-functional testing of a variety of systems. </span></p>
<p><span class="koboSpan" id="kobo.4.1">We have also discussed how systems need to change and evolve, as engineering organizations grow and new functionality is added. </span><span class="koboSpan" id="kobo.4.2">In </span><a href="B18371_09.xhtml#_idTextAnchor197"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.5.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.6.1">, </span><em class="italic"><span class="koboSpan" id="kobo.7.1">Challenges of Testing Concurrent Code</span></em><span class="koboSpan" id="kobo.8.1">, we discussed how to make the most of computing resources by making use of Go’s concurrency mechanisms, enabling us to serve production traffic. </span><span class="koboSpan" id="kobo.8.2">In </span><a href="B18371_10.xhtml#_idTextAnchor218"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Testing Edge Cases</span></em><span class="koboSpan" id="kobo.12.1">, we explored two testing techniques to cover system edge cases, including Go’s fuzz testing capabilities. </span></p>
<p><span class="koboSpan" id="kobo.13.1">Go’s </span><strong class="bold"><span class="koboSpan" id="kobo.14.1">1.18</span></strong><span class="koboSpan" id="kobo.15.1"> release introduced support for generics, alongside adding fuzz testing to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.16.1">go test</span></strong><span class="koboSpan" id="kobo.17.1"> toolset. </span><span class="koboSpan" id="kobo.17.2">Generics was a major, much-anticipated feature by the Go community. </span><span class="koboSpan" id="kobo.17.3">It allows us to write functions, types, and data structures that can work with any type, rather than being limited to one type when we declare them. </span><span class="koboSpan" id="kobo.17.4">A newly released language feature is another reason why we might change our code, alongside the maintenance and feature development processes we </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">have discussed.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">This chapter will explore the implementation and testing of generic code. </span><span class="koboSpan" id="kobo.19.2">We will begin by exploring how to write generic code, exploring both use cases and syntax. </span><span class="koboSpan" id="kobo.19.3">Then, we will explore how to test generic code, including where generics can be used to streamline our test code. </span><span class="koboSpan" id="kobo.19.4">Finally, we will reflect on all we have learned and summarize some of the testing best practices that we have explored throughout this book. </span></p>
<p><span class="koboSpan" id="kobo.20.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.22.1">The basics of writing generic code </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">in Go</span></span></li>
<li><span class="koboSpan" id="kobo.24.1">Testing </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">generic code</span></span></li>
<li><span class="koboSpan" id="kobo.26.1">Leveraging generics for </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">test utilities</span></span></li>
<li><span class="koboSpan" id="kobo.28.1">A summary of the testing best practices we have covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">this book</span></span></li>
</ul>
<h1 id="_idParaDest-210"><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.30.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.31.1">You will need to have </span><strong class="bold"><span class="koboSpan" id="kobo.32.1">Go version 1.19</span></strong><span class="koboSpan" id="kobo.33.1"> or later installed to run the code samples in this chapter. </span><span class="koboSpan" id="kobo.33.2">The installation process is described in the official Go documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">at </span></span><a href="https://go.dev/doc/install"><span class="No-Break"><span class="koboSpan" id="kobo.35.1">https://go.dev/doc/install</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.36.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">The code examples included in this book are publicly available </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">at </span></span><a href="https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter11"><span class="No-Break"><span class="koboSpan" id="kobo.39.1">https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter11</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.40.1">.</span></span></p>
<h1 id="_idParaDest-211"><a id="_idTextAnchor234"/><span class="koboSpan" id="kobo.41.1">Writing generic code in Go</span></h1>
<p><span class="koboSpan" id="kobo.42.1">The introduction of </span><a id="_idIndexMarker887"/><span class="koboSpan" id="kobo.43.1">generics in Go was a highly debated and anticipated feature. </span><span class="koboSpan" id="kobo.43.2">Some developers felt that introducing it would contradict Go’s core principles of simplicity, while others felt like it was a sign of maturity and would allow them to write better production code. </span><span class="koboSpan" id="kobo.43.3">As with every technical solution or design decision, there is a trade-off between the advantages </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">and disadvantages.</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">As previously mentioned, </span><strong class="bold"><span class="koboSpan" id="kobo.46.1">generics</span></strong><span class="koboSpan" id="kobo.47.1"> refers to the ability to write code that works with different data types </span><a id="_idIndexMarker888"/><span class="koboSpan" id="kobo.48.1">without being limited to a specific type. </span><span class="koboSpan" id="kobo.48.2">In the absence of generics, we have used Go interfaces to implement generic behavior in Go. </span><span class="koboSpan" id="kobo.48.3">In </span><a href="B18371_03.xhtml#_idTextAnchor061"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.49.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.50.1">, </span><em class="italic"><span class="koboSpan" id="kobo.51.1">Mocking and Assertion Frameworks</span></em><span class="koboSpan" id="kobo.52.1">, we explored the power of interfaces and have seen how they can be used for wrapping and replacing dependencies. </span><span class="koboSpan" id="kobo.52.2">While interfaces are not the same as generics, they provide a way to achieve similar goals of </span><strong class="bold"><span class="koboSpan" id="kobo.53.1">flexibility</span></strong><span class="koboSpan" id="kobo.54.1"> and </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.55.1">code reuse</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.57.1">Figure 11</span></em></span><em class="italic"><span class="koboSpan" id="kobo.58.1">.1</span></em><span class="koboSpan" id="kobo.59.1"> provides a comparison of generics </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">and interfaces:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer095">
<span class="koboSpan" id="kobo.61.1"><img alt="Figure 11.1 – Comparison of generics and interfaces " src="image/Figure_11.1_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.62.1">Figure 11.1 – Comparison of generics and interfaces</span></p>
<p><span class="koboSpan" id="kobo.63.1">While both generics </span><a id="_idIndexMarker889"/><span class="koboSpan" id="kobo.64.1">and interfaces provide code flexibility and polymorphism </span><a id="_idIndexMarker890"/><span class="koboSpan" id="kobo.65.1">to our code, they have the following </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">main differences:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.67.1">Generics are a way to specify the type, while interfaces specify behavior. </span><span class="koboSpan" id="kobo.67.2">As we have seen, interfaces are collections of methods that must be defined by structs in order to satisfy them. </span><span class="koboSpan" id="kobo.67.3">On the other hand, generics give us the ability to specify the types of parameters that can be used. </span></li>
<li><span class="koboSpan" id="kobo.68.1">Generics are built into the language, while interfaces are defined by the application. </span><span class="koboSpan" id="kobo.68.2">Interfaces are defined by engineers as part of their code bases, which makes it easier to define them to include any behavior required by the application. </span><span class="koboSpan" id="kobo.68.3">The specifications of generics are built into the language and can be shared across </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">code bases.</span></span></li>
<li><span class="koboSpan" id="kobo.70.1">Generics have limited scope, while interfaces have a wide scope. </span><span class="koboSpan" id="kobo.70.2">As they are built into the language, they are simple enough to implement solutions to a wide variety of problems. </span><span class="koboSpan" id="kobo.70.3">On the other hand, interfaces are expressive and can define complex behavior. </span></li>
</ol>
<p><span class="koboSpan" id="kobo.71.1">Both generics and interfaces are implemented by the Go compiler, so they are both statically type-checked. </span><span class="koboSpan" id="kobo.71.2">However, interfaces ensure that specific methods are available for a parameter, while generics do not provide </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">these guarantees.</span></span></p>
<h2 id="_idParaDest-212"><a id="_idTextAnchor235"/><span class="koboSpan" id="kobo.73.1">Generics in Go</span></h2>
<p><span class="koboSpan" id="kobo.74.1">The ability to write generic code is a core part of other strongly typed programming languages such as Java, C#, and C++. </span><span class="koboSpan" id="kobo.74.2">Its addition to Go gives us the ability to write more flexible and reusable code. </span><span class="koboSpan" id="kobo.74.3">Let us look at some examples of how we can leverage this new ability. </span></p>
<p><span class="koboSpan" id="kobo.75.1">There are three main components for specifying </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">generic code:</span></span></p>
<ol>
<li value="1"><strong class="bold"><span class="koboSpan" id="kobo.77.1">Type parameters</span></strong><span class="koboSpan" id="kobo.78.1"> are the </span><a id="_idIndexMarker891"/><span class="koboSpan" id="kobo.79.1">placeholder type </span><a id="_idIndexMarker892"/><span class="koboSpan" id="kobo.80.1">specifications that will be used with generic code. </span><span class="koboSpan" id="kobo.80.2">They are typically denoted with one single letter, for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">T</span></strong><span class="koboSpan" id="kobo.82.1">, and allow us to reference the placeholder type in our implementation. </span><span class="koboSpan" id="kobo.82.2">A generic function or type is defined by this placeholder as part of its specification. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.83.1">Type constraints</span></strong><span class="koboSpan" id="kobo.84.1"> help us </span><a id="_idIndexMarker893"/><span class="koboSpan" id="kobo.85.1">define rules or </span><a id="_idIndexMarker894"/><span class="koboSpan" id="kobo.86.1">subtypes for the type parameters. </span><span class="koboSpan" id="kobo.86.2">Constraints are not full specifications like interfaces, but they allow us to restrict type parameters to </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">certain properties.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.88.1">Type arguments</span></strong><span class="koboSpan" id="kobo.89.1"> are the </span><a id="_idIndexMarker895"/><span class="koboSpan" id="kobo.90.1">type that is passed </span><a id="_idIndexMarker896"/><span class="koboSpan" id="kobo.91.1">to the generic function or type upon invocation, which specifies the type of data we will be using. </span><span class="koboSpan" id="kobo.91.2">Type arguments are used in place of the type parameter placeholders declared by the function or type signature. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.92.1">Type inference</span></strong><span class="koboSpan" id="kobo.93.1"> is the process </span><a id="_idIndexMarker897"/><span class="koboSpan" id="kobo.94.1">that takes place under </span><a id="_idIndexMarker898"/><span class="koboSpan" id="kobo.95.1">the hood to determine the type of a variable, without its explicit type specification. </span><span class="koboSpan" id="kobo.95.2">This also allows us to write less verbose </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">generic code.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.97.1">These four components work together to make it easy for us to write generic code. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.98.1">Figure 11</span></em></span><em class="italic"><span class="koboSpan" id="kobo.99.1">.2</span></em><span class="koboSpan" id="kobo.100.1"> demonstrates each component with a simple example of a </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">generic function:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer096">
<span class="koboSpan" id="kobo.102.1"><img alt="Figure 11.2 – Generics example on a simple function " src="image/Figure_11.2_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.103.1">Figure 11.2 – Generics example on a simple function</span></p>
<p><span class="koboSpan" id="kobo.104.1">The example defines </span><a id="_idIndexMarker899"/><span class="koboSpan" id="kobo.105.1">a generic </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">sum</span></strong><span class="koboSpan" id="kobo.107.1"> function that takes in two parameters. </span><span class="koboSpan" id="kobo.107.2">It defines a type parameter, </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">T</span></strong><span class="koboSpan" id="kobo.109.1">, which must satisfy the specified type constraints. </span><span class="koboSpan" id="kobo.109.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">main</span></strong><span class="koboSpan" id="kobo.111.1"> function, we invoke the function with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">int64</span></strong><span class="koboSpan" id="kobo.113.1"> type argument and two parameters. </span><span class="koboSpan" id="kobo.113.2">The compiler uses type inference to ensure that the passed parameters comply with the type constraint and replace the type parameter with the type argument supplied in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">main</span></strong><span class="koboSpan" id="kobo.115.1"> function. </span><span class="koboSpan" id="kobo.115.2">We will explore how to write and test generic Go code in the </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">next sections.</span></span></p>
<h2 id="_idParaDest-213"><a id="_idTextAnchor236"/><span class="koboSpan" id="kobo.117.1">Exploring type constraints</span></h2>
<p><span class="koboSpan" id="kobo.118.1">Type constraints </span><a id="_idIndexMarker900"/><span class="koboSpan" id="kobo.119.1">are a central component </span><a id="_idIndexMarker901"/><span class="koboSpan" id="kobo.120.1">of generics, as they allow us to limit the data types that our generic code can be used with. </span><span class="koboSpan" id="kobo.120.2">This makes it easier for us to write safe and simple code that operates on types that meet </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">specified conditions.</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">Type parameters are declared inside square brackets (</span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">[]</span></strong><span class="koboSpan" id="kobo.124.1">) in Go. </span><span class="koboSpan" id="kobo.124.2">The type parameter defines a name and possible constraints for a type. </span><span class="koboSpan" id="kobo.124.3">We can declare constraints in a </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">few ways:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.126.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">any</span></strong><span class="koboSpan" id="kobo.128.1"> interface is an alias for the empty interface, </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">interface{}</span></strong><span class="koboSpan" id="kobo.130.1">, and allows all types to be used. </span><span class="koboSpan" id="kobo.130.2">This allows us to build functions and types without constraints. </span><span class="koboSpan" id="kobo.130.3">For example, we can make the </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">sum</span></strong><span class="koboSpan" id="kobo.132.1"> function accept any parameter type by using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">any</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.134.1"> interface:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.135.1">
func </span><strong class="bold"><span class="koboSpan" id="kobo.136.1">sum[T any]</span></strong><span class="koboSpan" id="kobo.137.1">(x, y T) T {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.138.1">
  // implementation</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.139.1">
} </span></pre></li>
<li><span class="koboSpan" id="kobo.140.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">comparable</span></strong><span class="koboSpan" id="kobo.142.1"> interface is a pre-declared type constraint that denotes types that can be </span><a id="_idIndexMarker902"/><span class="koboSpan" id="kobo.143.1">compared using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">==</span></strong><span class="koboSpan" id="kobo.145.1"> operator. </span><span class="koboSpan" id="kobo.145.2">These types are </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">string</span></strong><span class="koboSpan" id="kobo.147.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">bool</span></strong><span class="koboSpan" id="kobo.149.1">, all numbers, and composite types </span><a id="_idIndexMarker903"/><span class="koboSpan" id="kobo.150.1">containing comparable fields. </span><span class="koboSpan" id="kobo.150.2">For example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">sum</span></strong><span class="koboSpan" id="kobo.152.1"> function will now allow these types as parameters, but we will need to implement the sum logic accordingly, as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">+</span></strong><span class="koboSpan" id="kobo.154.1"> operator will no longer be implemented by all </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">these types:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.156.1">
func </span><strong class="bold"><span class="koboSpan" id="kobo.157.1">sum[T comparable]</span></strong><span class="koboSpan" id="kobo.158.1">(x, y T) T {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.159.1">
  // implementation</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.160.1">
} </span></pre></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.161.1">Type sets</span></strong><span class="koboSpan" id="kobo.162.1"> can be created using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">|</span></strong><span class="koboSpan" id="kobo.164.1"> operator. </span><span class="koboSpan" id="kobo.164.2">This allows us to create constraints that contain multiple types without having to wrap them in a custom interface. </span><span class="koboSpan" id="kobo.164.3">This is the example we have seen in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.165.1">Figure 11</span></em></span><em class="italic"><span class="koboSpan" id="kobo.166.1">.2</span></em><span class="koboSpan" id="kobo.167.1">, where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">sum</span></strong><span class="koboSpan" id="kobo.169.1"> function allows the </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">int64</span></strong><span class="koboSpan" id="kobo.171.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">float64</span></strong><span class="koboSpan" id="kobo.173.1"> types, which already support the </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">+</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.175.1">operator:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.176.1">
func </span><strong class="bold"><span class="koboSpan" id="kobo.177.1">sum[T int64 | float64]</span></strong><span class="koboSpan" id="kobo.178.1">(x, y T) T {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.179.1">
  // implementation</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.180.1">
}</span></pre></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.181.1">Custom type constraints</span></strong><span class="koboSpan" id="kobo.182.1"> can also be created as an interface and reused in our code. </span><span class="koboSpan" id="kobo.182.2">These are also declared using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">|</span></strong><span class="koboSpan" id="kobo.184.1"> operator. </span><span class="koboSpan" id="kobo.184.2">For example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">Number</span></strong><span class="koboSpan" id="kobo.186.1"> interface allows the </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">int64</span></strong><span class="koboSpan" id="kobo.188.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">float64</span></strong><span class="koboSpan" id="kobo.190.1"> types, which we can then use in the specification of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">sum</span></strong><span class="koboSpan" id="kobo.192.1"> function, resulting in the same specification as the previous </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">type sets:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.194.1">
type Number interface {</span></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.195.1">  int64 | float64</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.196.1">
}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.197.1">
func </span><strong class="bold"><span class="koboSpan" id="kobo.198.1">sum[T Number]</span></strong><span class="koboSpan" id="kobo.199.1">(x, y T) T {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.200.1">
  // implementation</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.201.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.202.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">~</span></strong><span class="koboSpan" id="kobo.204.1"> keyword can be used to restrict all custom types that have the same underlying type. </span><span class="koboSpan" id="kobo.204.2">This allows us to encompass custom types into our constraints. </span><span class="koboSpan" id="kobo.204.3">For example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">Number</span></strong><span class="koboSpan" id="kobo.206.1"> interface will now allow any </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">int</span></strong><span class="koboSpan" id="kobo.208.1">- and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">float64</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">-based types:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.211.1">
type Number interface {</span></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.212.1">  ~int64 | ~float64</span></strong></pre><pre class="source-code"><span class="koboSpan" id="kobo.213.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.214.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">constraints</span></strong><span class="koboSpan" id="kobo.216.1"> package defines some useful constraints that can be used together with </span><a id="_idIndexMarker904"/><span class="koboSpan" id="kobo.217.1">your generic code. </span><span class="koboSpan" id="kobo.217.2">This </span><a id="_idIndexMarker905"/><span class="koboSpan" id="kobo.218.1">package contains numerical and ordered constraints that you might find useful. </span><span class="koboSpan" id="kobo.218.2">For example, we can modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">sum</span></strong><span class="koboSpan" id="kobo.220.1"> function to accept all signed integers by using </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">this package:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.222.1">
func </span><strong class="bold"><span class="koboSpan" id="kobo.223.1">sum[T constraints.Signed]</span></strong><span class="koboSpan" id="kobo.224.1">(x, y T) T {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.225.1">
  // implementation </span></pre><pre class="source-code"><span class="koboSpan" id="kobo.226.1">
}</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.227.1">Generics can be applied to functions and structs, allowing us to create generic data structures and reusable behaviors. </span><span class="koboSpan" id="kobo.227.2">This can streamline our code and remove the need to define code multiple times in order to accommodate different types of underlying data. </span><span class="koboSpan" id="kobo.227.3">In </span><a href="B18371_10.xhtml#_idTextAnchor218"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.228.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.229.1">, </span><em class="italic"><span class="koboSpan" id="kobo.230.1">Testing Edge Cases</span></em><span class="koboSpan" id="kobo.231.1">, we implemented a function that sorts map values based on key values: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.232.1">
// GetSortedValues returns the key-sorted values of a given map.
</span><span class="koboSpan" id="kobo.232.2">func GetSortedValues(input map[int]string, dir SortDirection) ([]string, error) {
  // implementation
} </span></pre>
<p><span class="koboSpan" id="kobo.233.1">This very useful function has a major limitation in that it only works for a single type of map with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">int</span></strong><span class="koboSpan" id="kobo.235.1"> key and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">string</span></strong><span class="koboSpan" id="kobo.237.1"> value – </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">map[int]string</span></strong><span class="koboSpan" id="kobo.239.1">. </span><span class="koboSpan" id="kobo.239.2">This limitation makes it difficult to reuse this code for other map types. </span></p>
<p><span class="koboSpan" id="kobo.240.1">In the days before Go generics, we would have to create a function for each type of map: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.241.1">
 // GetSortedFloatValues returns the key-sorted values of a given map with int key and float64 values. 
</span><span class="koboSpan" id="kobo.241.2">func </span><strong class="bold"><span class="koboSpan" id="kobo.242.1">GetSortedFloatValues</span></strong><span class="koboSpan" id="kobo.243.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.244.1">input map[int]float64</span></strong><span class="koboSpan" id="kobo.245.1">, dir SortDirection) ([]string, error) { 
  // implementation 
}</span></pre>
<p><span class="koboSpan" id="kobo.246.1">Since Go does not </span><a id="_idIndexMarker906"/><span class="koboSpan" id="kobo.247.1">allow function overriding, we </span><a id="_idIndexMarker907"/><span class="koboSpan" id="kobo.248.1">also need to use different names for the function taking different parameters. </span><span class="koboSpan" id="kobo.248.2">This can make it difficult to create libraries, even if we extract helper functions to help us reuse the implementation code inside the function. </span></p>
<p><span class="koboSpan" id="kobo.249.1">This is much simplified by generics, which allow us to parameterize the key and value types of the sort function: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.250.1">
// GetSortedValues returns the key-sorted values of a given map.
</span><span class="koboSpan" id="kobo.250.2">func </span><strong class="bold"><span class="koboSpan" id="kobo.251.1">GetSortedValues[K ~int, V comparable]</span></strong><span class="koboSpan" id="kobo.252.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.253.1">input map[K]V</span></strong><span class="koboSpan" id="kobo.254.1">, dir SortDirection) (</span><strong class="bold"><span class="koboSpan" id="kobo.255.1">[]V</span></strong><span class="koboSpan" id="kobo.256.1">, error) {
  // implementation
}</span></pre>
<p><span class="koboSpan" id="kobo.257.1">The signature of the function has been changed to leverage the power of generics to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">reusable function:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.259.1">The function has two type parameters, one for the key type and one for the value type. </span><span class="koboSpan" id="kobo.259.2">The key value is restricted to any </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">int</span></strong><span class="koboSpan" id="kobo.261.1"> type using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">~</span></strong><span class="koboSpan" id="kobo.263.1"> keyword, while the value is opened to any type that complies using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">comparable</span></strong><span class="koboSpan" id="kobo.265.1"> interface. </span></li>
<li><span class="koboSpan" id="kobo.266.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">map</span></strong><span class="koboSpan" id="kobo.268.1"> parameter is declared using the key and value placeholder types, </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">map[K]V</span></strong><span class="koboSpan" id="kobo.270.1">. </span><span class="koboSpan" id="kobo.270.2">Only parameters that comply with the type constraints will be accepted by the function. </span></li>
<li><span class="koboSpan" id="kobo.271.1">The return value </span><a id="_idIndexMarker908"/><span class="koboSpan" id="kobo.272.1">of the function is </span><a id="_idIndexMarker909"/><span class="koboSpan" id="kobo.273.1">adjusted to return a slice of value types, </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">[]V</span></strong><span class="koboSpan" id="kobo.275.1">. </span><span class="koboSpan" id="kobo.275.2">This ensures that values returned are of the type as passed in by the </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">input map.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.277.1">Once we open up our functions to receive generic types, it is also important to apply meaningful constraints to ensure that our code continues to provide useful functionality. </span><span class="koboSpan" id="kobo.277.2">The function signature also serves as a user manual for callers, so we should continue to guide them, even though we are adding flexibility to </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">our code.</span></span></p>
<h1 id="_idParaDest-214"><a id="_idTextAnchor237"/><span class="koboSpan" id="kobo.279.1">Table-driven testing revisited</span></h1>
<p><span class="koboSpan" id="kobo.280.1">Now that we understand the basics of implementing generic code, we can turn our attention to testing it. </span><span class="koboSpan" id="kobo.280.2">The adoption of generics throughout the Go community is still in its beginning stages. </span><span class="koboSpan" id="kobo.280.3">We have already established that generic code is statically enforced by the compiler, but does this increase in flexibility lead to more complex </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">test code?</span></span></p>
<p><span class="koboSpan" id="kobo.282.1">We can continue our exploration using the generic </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">GetSortedValues</span></strong><span class="koboSpan" id="kobo.284.1"> function that we have implemented. </span><span class="koboSpan" id="kobo.284.2">Tests should now be written to assert the behavior of the function for a variety of input types and values. </span><span class="koboSpan" id="kobo.284.3">We can achieve this by using the table-driven testing technique that we explored in </span><a href="B18371_04.xhtml#_idTextAnchor085"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.285.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.286.1">, </span><em class="italic"><span class="koboSpan" id="kobo.287.1">Building Efficient Test Suites</span></em><span class="koboSpan" id="kobo.288.1">. </span><span class="koboSpan" id="kobo.288.2">The implementation of generic table-driven testing follows a series </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">of steps.</span></span></p>
<h2 id="_idParaDest-215"><a id="_idTextAnchor238"/><span class="koboSpan" id="kobo.290.1">Step 1 – defining generic test cases</span></h2>
<p><span class="koboSpan" id="kobo.291.1">We begin by creating </span><a id="_idIndexMarker910"/><span class="koboSpan" id="kobo.292.1">a generic test case </span><a id="_idIndexMarker911"/><span class="koboSpan" id="kobo.293.1">type to save our input map </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">and values:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.295.1">
type </span><strong class="bold"><span class="koboSpan" id="kobo.296.1">testCase[K ~int, V comparable]</span></strong><span class="koboSpan" id="kobo.297.1"> struct {
</span><strong class="bold"><span class="koboSpan" id="kobo.298.1">  input  map[K]V</span></strong><span class="koboSpan" id="kobo.299.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.300.1">A generic test </span><a id="_idIndexMarker912"/><span class="koboSpan" id="kobo.301.1">case allows us to construct an input map with the correct key and value type constraints, which </span><a id="_idIndexMarker913"/><span class="koboSpan" id="kobo.302.1">are the same as we have used for the generic </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">GetSortedValues</span></strong><span class="koboSpan" id="kobo.304.1"> function. </span><span class="koboSpan" id="kobo.304.2">We will use the input map as a parameter for </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">the UUT.</span></span></p>
<h2 id="_idParaDest-216"><a id="_idTextAnchor239"/><span class="koboSpan" id="kobo.306.1">Step 2 – creating test cases</span></h2>
<p><span class="koboSpan" id="kobo.307.1">As we remember </span><a id="_idIndexMarker914"/><span class="koboSpan" id="kobo.308.1">from our introduction </span><a id="_idIndexMarker915"/><span class="koboSpan" id="kobo.309.1">to table-driven testing, we typically construct a map of test cases with the scenarios that we will be running our tests over. </span><span class="koboSpan" id="kobo.309.2">Due to the differences in type, we construct multiple test case maps: </span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.310.1">type CustomI int</span></strong><span class="koboSpan" id="kobo.311.1">
testStrings := map[string]testCase[int, string]{
  "unordered":       {input: map[int]string{99: "A", 50:"X"}},
  "empty map":       {input: map[int]string{}},
  "negative values": {input: map[int]string{-99: "A", -1:"X"}},
}
testFloats := map[string]testCase[CustomI, float64]{
  "unordered":     {input: map[CustomI]float64{99: 1.2, 0: 4.6}},
  "empty map":     {input: map[CustomI]float64{}},
  "negative keys": {input: map[CustomI]float64{-99: 1.2, 0: 4.6}},
}</span></pre>
<p><span class="koboSpan" id="kobo.312.1">In this example, we create two maps with three scenarios each. </span><span class="koboSpan" id="kobo.312.2">The first </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">testCase</span></strong><span class="koboSpan" id="kobo.314.1"> map has an </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">int</span></strong><span class="koboSpan" id="kobo.316.1"> key type and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">string</span></strong><span class="koboSpan" id="kobo.318.1"> value type. </span><span class="koboSpan" id="kobo.318.2">The second </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">testCase</span></strong><span class="koboSpan" id="kobo.320.1"> map has an </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">int</span></strong><span class="koboSpan" id="kobo.322.1">-based custom </span><a id="_idIndexMarker916"/><span class="koboSpan" id="kobo.323.1">type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">CustomI</span></strong><span class="koboSpan" id="kobo.325.1">. </span><span class="koboSpan" id="kobo.325.2">These are two possible combinations of key and value types. </span><span class="koboSpan" id="kobo.325.3">We can extend these types and scenario combinations as much as </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">we want.</span></span></p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor240"/><span class="koboSpan" id="kobo.327.1">Step 3 – implementing a generic test run function</span></h2>
<p><span class="koboSpan" id="kobo.328.1">The next step </span><a id="_idIndexMarker917"/><span class="koboSpan" id="kobo.329.1">required is to write a test helper function that contains all the logic for looping over the </span><a id="_idIndexMarker918"/><span class="koboSpan" id="kobo.330.1">map of test cases and asserting the functionality of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">GetSortedValues</span></strong><span class="koboSpan" id="kobo.332.1"> function. </span><span class="koboSpan" id="kobo.332.2">Usually, this functionality is contained inside the test body, but we will extract a function, as we have multiple input maps that we need </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">to process:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.334.1">func runTests[K ~int, V comparable](t *testing.T, tests map[string]testCase[K, V])</span></strong><span class="koboSpan" id="kobo.335.1"> {
</span><strong class="bold"><span class="koboSpan" id="kobo.336.1">  t.Helper()</span></strong><span class="koboSpan" id="kobo.337.1">
  for name, rtc := range tests {
    tc := rtc
</span><strong class="bold"><span class="koboSpan" id="kobo.338.1">    t.Run(name, func(t *testing.T) {</span></strong><span class="koboSpan" id="kobo.339.1">
      keys := make([]K, 0, len(tc.input))
      for k := range tc.input {
        keys = append(keys, k)
      }
      sort.Slice(keys, func(i, j int) bool {
        return keys[i] &lt; keys[j]
      })
</span><strong class="bold"><span class="koboSpan" id="kobo.340.1">      sortedValues, err := gs.GetSortedValues(tc.input, gs.ASC)</span></strong><span class="koboSpan" id="kobo.341.1">
      require.Nil(t, err)
      require.NotNil(t, sortedValues)
      for index, v := range sortedValues {
        key := keys[index]
</span><strong class="bold"><span class="koboSpan" id="kobo.342.1">        assert.Equal(t, tc.input[key], v)</span></strong><span class="koboSpan" id="kobo.343.1">
      }
    })
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.344.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">runTests</span></strong><span class="koboSpan" id="kobo.346.1"> function has the </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">following implementation:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.348.1">The function signature takes two type parameters for the key and value types. </span><span class="koboSpan" id="kobo.348.2">They have the same type constraints as the test case type we have declared. </span><span class="koboSpan" id="kobo.348.3">It takes in two parameters: the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">*testing.T</span></strong><span class="koboSpan" id="kobo.350.1"> runner and the map of test cases, with the same key and value </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">type parameters.</span></span></li>
<li><span class="koboSpan" id="kobo.352.1">This function is </span><a id="_idIndexMarker919"/><span class="koboSpan" id="kobo.353.1">marked as a helper using </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">t.Helper</span></strong><span class="koboSpan" id="kobo.355.1"> so that it does not </span><a id="_idIndexMarker920"/><span class="koboSpan" id="kobo.356.1">pollute </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">test output.</span></span></li>
<li><span class="koboSpan" id="kobo.358.1">We loop over the map of test cases and run each in its own subtest using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">t.Run</span></strong><span class="koboSpan" id="kobo.360.1"> function. </span></li>
<li><span class="koboSpan" id="kobo.361.1">The rest of the function body is the same as any test implementation. </span><span class="koboSpan" id="kobo.361.2">We invoke the function under test and assert the order of the elements. </span></li>
</ol>
<h2 id="_idParaDest-218"><a id="_idTextAnchor241"/><span class="koboSpan" id="kobo.362.1">Step 4 – putting everything together</span></h2>
<p><span class="koboSpan" id="kobo.363.1">With all our building blocks </span><a id="_idIndexMarker921"/><span class="koboSpan" id="kobo.364.1">in place, we can write our first generic test for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">GetSortedValues</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.366.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.367.1">
func TestGetSortedValues(t *testing.T) {
</span><strong class="bold"><span class="koboSpan" id="kobo.368.1">  t.Run("[int]string", func(t *testing.T) {</span></strong><span class="koboSpan" id="kobo.369.1">
    testStrings := map[string]testCase[int, string]{
      // values declaration 
    }
</span><strong class="bold"><span class="koboSpan" id="kobo.370.1">    runTests(t, testStrings)</span></strong><span class="koboSpan" id="kobo.371.1">
  })
  t.Run("[CustomI]float64", func(t *testing.T) {
    testFloats := map[string]testCase[CustomI, float64]{
      // values declaration
    }
    runTests(t, testFloats)
  })
}</span></pre>
<p><span class="koboSpan" id="kobo.372.1">The test contains a subtest for </span><a id="_idIndexMarker922"/><span class="koboSpan" id="kobo.373.1">each combination of key and value types. </span><span class="koboSpan" id="kobo.373.2">Inside the subtest, we create the map of test cases and invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">runTests</span></strong><span class="koboSpan" id="kobo.375.1"> function with the </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">correct parameters.</span></span></p>
<h2 id="_idParaDest-219"><a id="_idTextAnchor242"/><span class="koboSpan" id="kobo.377.1">Step 5 – running the test</span></h2>
<p><span class="koboSpan" id="kobo.378.1">The last step is </span><a id="_idIndexMarker923"/><span class="koboSpan" id="kobo.379.1">to run the test to see our generic code in action: </span></p>
<pre class="console"><span class="koboSpan" id="kobo.380.1">
$ go test -run TestGetSortedValues ./chapter11/generics/sort -v
=== RUN   TestGetSortedValues
--- PASS: TestGetSortedValues
  --- PASS: TestGetSortedValues/[int]string
    --- PASS: TestGetSortedValues/[int]string/unordered
    --- PASS: TestGetSortedValues/[int]string/empty_map
    --- PASS: TestGetSortedValues/[int]string/negative_values
  --- PASS: TestGetSortedValues/[CustomI]float64
    --- PASS: TestGetSortedValues/[CustomI]float64/unordered
    --- PASS: TestGetSortedValues/[CustomI]float64/empty_map 
    --- PASS: TestGetSortedValues/[CustomI]float64/negative_keys PASS
ok  github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter11/generics/sort        0.201s</span></pre>
<p><span class="koboSpan" id="kobo.381.1">The usage of subtests </span><a id="_idIndexMarker924"/><span class="koboSpan" id="kobo.382.1">gives us structured output for our test run. </span><span class="koboSpan" id="kobo.382.2">We have also easily adapted table-driven testing to use generics to be able to test our </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">GetSortedValues</span></strong><span class="koboSpan" id="kobo.384.1"> function with different types of input values. </span></p>
<p><span class="koboSpan" id="kobo.385.1">As we have seen from this simple example, the power of generics extends to test code. </span><span class="koboSpan" id="kobo.385.2">Another interesting use of generics is for creating test utilities. </span><span class="koboSpan" id="kobo.385.3">We will look at an example of this in the next section. </span></p>
<h2 id="_idParaDest-220"><a id="_idTextAnchor243"/><span class="koboSpan" id="kobo.386.1">Test utilities</span></h2>
<p><span class="koboSpan" id="kobo.387.1">The test assertion libraries we have been using so far, </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">testify</span></strong><span class="koboSpan" id="kobo.389.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">ginkgo</span></strong><span class="koboSpan" id="kobo.391.1">, were written before the </span><a id="_idIndexMarker925"/><span class="koboSpan" id="kobo.392.1">introduction of Go generics. </span><span class="koboSpan" id="kobo.392.2">They use reflection to implement comparisons and assertions </span><a id="_idIndexMarker926"/><span class="koboSpan" id="kobo.393.1">on variables. </span><span class="koboSpan" id="kobo.393.2">While this is a powerful tool, it can be difficult to use to write our own assertions and test utilities. </span><span class="koboSpan" id="kobo.393.3">The introduction of generics has made this process much easier, so we can easily create our own test utilities to reuse them in </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">our tests.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.395.1">Reflection in a nutshell</span></p>
<p class="callout"><span class="koboSpan" id="kobo.396.1">Reflection is the ability </span><a id="_idIndexMarker927"/><span class="koboSpan" id="kobo.397.1">of a program to analyze and manipulate program elements at runtime. </span><span class="koboSpan" id="kobo.397.2">This gives us the ability to inspect types, modify behavior, and test code. </span><span class="koboSpan" id="kobo.397.3">The Go standard library provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">reflect</span></strong><span class="koboSpan" id="kobo.399.1"> package, which provides functionality for implementing reflection. </span></p>
<p><span class="koboSpan" id="kobo.400.1">Continuing our example from </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">TestGetSortedValues</span></strong><span class="koboSpan" id="kobo.402.1"> we wrote previously, we can streamline our </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">runTests</span></strong><span class="koboSpan" id="kobo.404.1"> helper by extracting a test utility that we can use in other tests. </span><span class="koboSpan" id="kobo.404.2">We can easily create our own generic test helper for asserting that the order of our keys and values is </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">as expected:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.406.1">func AssertMapOrderedByKeys[K ~int, V comparable](t *testing.T, input map[K]V, want []V) {</span></strong><span class="koboSpan" id="kobo.407.1">
  t.Helper()
  keys := make([]K, 0, len(input))
  for k := range input {
    keys = append(keys, k)
  }
  sort.Slice(keys, func(i, j int) bool {
    return keys[i] &lt; keys[j]
  })
  for index, v := range want {
    key := keys[index]
    assert.Equal(t, input[key], v)
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.408.1">We extract the code and use two type parameters for the key and value type. </span><span class="koboSpan" id="kobo.408.2">We use the same technique as writing our </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">runTests</span></strong><span class="koboSpan" id="kobo.410.1"> helper, but extract only the code that asserts on map value ordering. </span><span class="koboSpan" id="kobo.410.2">This test helper still takes the test runner </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">*testing.T</span></strong><span class="koboSpan" id="kobo.412.1"> as a parameter, allowing it to fail tests in the case that the assertions inside </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">it fail.</span></span></p>
<p><span class="koboSpan" id="kobo.414.1">In the absence of </span><a id="_idIndexMarker928"/><span class="koboSpan" id="kobo.415.1">generics, we would </span><a id="_idIndexMarker929"/><span class="koboSpan" id="kobo.416.1">have to use the empty interface, </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">interface{}</span></strong><span class="koboSpan" id="kobo.418.1">, to allow our test to take in a variety of parameters. </span><span class="koboSpan" id="kobo.418.2">This does not allow us to write type-safe code, so writing helpers is more difficult and error-prone. </span></p>
<p><span class="koboSpan" id="kobo.419.1">Generics can help us streamline our application and test code. </span><span class="koboSpan" id="kobo.419.2">As we have seen in this section, we can use it to extend the technique of table-driven testing to allow us to write tests that cover a variety of input types and scenarios. </span><span class="koboSpan" id="kobo.419.3">We have also seen how generics can be used to create our own test utilities. </span></p>
<h1 id="_idParaDest-221"><a id="_idTextAnchor244"/><span class="koboSpan" id="kobo.420.1">Extending the BookSwap application with generics</span></h1>
<p><span class="koboSpan" id="kobo.421.1">So far, we have </span><a id="_idIndexMarker930"/><span class="koboSpan" id="kobo.422.1">seen how to write a generic </span><a id="_idIndexMarker931"/><span class="koboSpan" id="kobo.423.1">function and use generics to write easier test utilities. </span><span class="koboSpan" id="kobo.423.2">This has already proven to be a very powerful mechanism, providing us with both flexibility and type safety, something which cannot be achieved by an empty interface. </span><span class="koboSpan" id="kobo.423.3">In this section, we will learn how to make use of generics in our example REST API, the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">BookSwap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.425.1"> application.</span></span></p>
<p><span class="koboSpan" id="kobo.426.1">Let us suppose that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">BookSwap</span></strong><span class="koboSpan" id="kobo.428.1"> application wants to extend its business model and begin swapping magazines, alongside its regular books business model. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.429.1">Figure 11</span></em></span><em class="italic"><span class="koboSpan" id="kobo.430.1">.3</span></em><span class="koboSpan" id="kobo.431.1"> presents the new system diagram for </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">the application:</span></span></p>
<p class="IMG---Figure"> </p>
<div>
<div class="IMG---Figure" id="_idContainer097">
<span class="koboSpan" id="kobo.433.1"><img alt="Figure 11.3 – The extended BookSwap application " src="image/Figure_11.3_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.434.1">Figure 11.3 – The extended BookSwap application</span></p>
<p><span class="koboSpan" id="kobo.435.1">The preceding example considers the </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">BookSwap</span></strong><span class="koboSpan" id="kobo.437.1"> application’s monolithic architecture, but the same kind of considerations would apply to microservices architectures as well. </span><span class="koboSpan" id="kobo.437.2">Changes would have to be made throughout the application to support a new model, starting from the </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">database level:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.439.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">Magazines</span></strong><span class="koboSpan" id="kobo.441.1"> database table will be created. </span><span class="koboSpan" id="kobo.441.2">Just like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">Books</span></strong><span class="koboSpan" id="kobo.443.1"> table, it will have a foreign key dependency on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">Users</span></strong><span class="koboSpan" id="kobo.445.1"> primary </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">key, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">id</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">MagazineService</span></strong><span class="koboSpan" id="kobo.450.1"> will be created to interact with the database queries. </span><span class="koboSpan" id="kobo.450.2">Just like </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">BookService</span></strong><span class="koboSpan" id="kobo.452.1">, it will support upsert, list, and swap operations. </span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">UserService</span></strong><span class="koboSpan" id="kobo.454.1"> will have a dependency on </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">MagazineService</span></strong><span class="koboSpan" id="kobo.456.1">, allowing it to perform operations on this service and send information onward to the user. </span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">PostingService</span></strong><span class="koboSpan" id="kobo.458.1"> will need to handle both </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">Magazine</span></strong><span class="koboSpan" id="kobo.460.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">Book</span></strong><span class="koboSpan" id="kobo.462.1"> when they are successfully swapped. </span><span class="koboSpan" id="kobo.462.2">Since this service is external, we can assume that this information will be transferred through an HTTP request. </span></li>
</ul>
<p><span class="koboSpan" id="kobo.463.1">Some of these changes </span><a id="_idIndexMarker932"/><span class="koboSpan" id="kobo.464.1">do require dedicated </span><a id="_idIndexMarker933"/><span class="koboSpan" id="kobo.465.1">code since we wouldn’t want to make magazines and books too tightly coupled. </span><span class="koboSpan" id="kobo.465.2">One example of where we might leverage generics is during the construction of the HTTP response. </span><span class="koboSpan" id="kobo.465.3">So far, </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">Response</span></strong><span class="koboSpan" id="kobo.467.1"> has consisted of only the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">Books</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.469.1"> items:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.470.1">
type Response struct {
  Message string    `json:"message,omitempty"`
  Error   string    `json:"error,omitempty"`
</span><strong class="bold"><span class="koboSpan" id="kobo.471.1">  Books   []db.Book `json:"books,omitempty"`</span></strong><span class="koboSpan" id="kobo.472.1">
  User    *db.User  `json:"user,omitempty"`
}</span></pre>
<p><span class="koboSpan" id="kobo.473.1">We populate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">Books</span></strong><span class="koboSpan" id="kobo.475.1"> slice with the books returned from </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">BookService</span></strong><span class="koboSpan" id="kobo.477.1">. </span><span class="koboSpan" id="kobo.477.2">We now need to extend the </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">Response</span></strong><span class="koboSpan" id="kobo.479.1"> struct to be able to handle </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">Magazines</span></strong><span class="koboSpan" id="kobo.481.1"> as well. </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">Response</span></strong><span class="koboSpan" id="kobo.483.1"> is a widely used type, so it would be a good candidate for a generic implementation. </span></p>
<p><span class="koboSpan" id="kobo.484.1">We create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">ResponseItemType</span></strong><span class="koboSpan" id="kobo.486.1"> custom constraint, which contains a set of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">db.Book</span></strong><span class="koboSpan" id="kobo.488.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">db.Magazine</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.490.1"> types:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.491.1">
type ResponseItemType interface {
  </span><strong class="bold"><span class="koboSpan" id="kobo.492.1">db.Book | db.Magazine</span></strong><span class="koboSpan" id="kobo.493.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.494.1">If more types are added, then we can add them to this custom type constraint and use them throughout the application. </span></p>
<p><span class="koboSpan" id="kobo.495.1">Next, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">ResponseItemType</span></strong><span class="koboSpan" id="kobo.497.1"> as the type parameter of </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">Response</span></strong><span class="koboSpan" id="kobo.499.1">: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.500.1">
type Response[</span><strong class="bold"><span class="koboSpan" id="kobo.501.1">T ResponseItemType</span></strong><span class="koboSpan" id="kobo.502.1">] struct {
  Message string   `json:"message,omitempty"`
  Error   string   `json:"error,omitempty"`
  </span><strong class="bold"><span class="koboSpan" id="kobo.503.1">Items   []T      `json:"items,omitempty"`</span></strong><span class="koboSpan" id="kobo.504.1">
  User    *db.User `json:"user,omitempty"`
}</span></pre>
<p><span class="koboSpan" id="kobo.505.1">We use the </span><a id="_idIndexMarker934"/><span class="koboSpan" id="kobo.506.1">placeholder, </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">T</span></strong><span class="koboSpan" id="kobo.508.1">, as the type of the </span><a id="_idIndexMarker935"/><span class="koboSpan" id="kobo.509.1">response, which is then used as the type of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">Items</span></strong><span class="koboSpan" id="kobo.511.1"> slice. </span><span class="koboSpan" id="kobo.511.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">Items</span></strong><span class="koboSpan" id="kobo.513.1"> slice is now able to contain both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">db.Book</span></strong><span class="koboSpan" id="kobo.515.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">db.Magazine</span></strong><span class="koboSpan" id="kobo.517.1"> types. </span><span class="koboSpan" id="kobo.517.2">All other functions that interact with </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">Response</span></strong><span class="koboSpan" id="kobo.519.1"> will now also need to handle the generic </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">Response</span></strong><span class="koboSpan" id="kobo.521.1">. </span></p>
<p><span class="koboSpan" id="kobo.522.1">We add the same type parameter to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">writeResponse</span></strong><span class="koboSpan" id="kobo.524.1"> function, which is responsible for populating data in </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">Response</span></strong><span class="koboSpan" id="kobo.526.1">: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.527.1">
func writeResponse</span><strong class="bold"><span class="koboSpan" id="kobo.528.1">[T ResponseItemType]</span></strong><span class="koboSpan" id="kobo.529.1">(w http.ResponseWriter, status int, </span><strong class="bold"><span class="koboSpan" id="kobo.530.1">resp *Response[T]</span></strong><span class="koboSpan" id="kobo.531.1">) { 
  // implementation
}</span></pre>
<p><span class="koboSpan" id="kobo.532.1">The generic function simply passes the type to the response and no other changes are required for the implementation logic. </span><span class="koboSpan" id="kobo.532.2">The type either needs to be supplied or sent through as </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">a placeholder.</span></span></p>
<p><span class="koboSpan" id="kobo.534.1">On the calling side, we also need to handle the generic aspects. </span><span class="koboSpan" id="kobo.534.2">Each handler makes use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">writeResponse</span></strong><span class="koboSpan" id="kobo.536.1"> function to populate data on </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">Response</span></strong><span class="koboSpan" id="kobo.538.1"> and return it to the client. </span><span class="koboSpan" id="kobo.538.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">ListBooks</span></strong><span class="koboSpan" id="kobo.540.1"> handler demonstrates how to handle this on the </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">calling side:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.542.1">
// ListBooks is invoked by HTTP GET /books.
</span><span class="koboSpan" id="kobo.542.2">func (h *Handler) ListBooks(w http.ResponseWriter, r *http.Request){
  books, err := h.bs.List()
  if err != nil {
</span><strong class="bold"><span class="koboSpan" id="kobo.543.1">    writeResponse(w, http.StatusInternalServerError, &amp;Response[db.Book]{</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.544.1">      Error: err.Error(),</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.545.1">    })</span></strong><span class="koboSpan" id="kobo.546.1">
    return
 }
  // Send an HTTP status &amp; the list of books
</span><strong class="bold"><span class="koboSpan" id="kobo.547.1">  writeResponse(w, http.StatusOK, &amp;Response[db.Book]{</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.548.1">    Items: books,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.549.1">  })</span></strong><span class="koboSpan" id="kobo.550.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.551.1">The handlers responsible for books will handle response writing in a similar way. </span><span class="koboSpan" id="kobo.551.2">We pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">db.Book</span></strong><span class="koboSpan" id="kobo.553.1"> type to </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">Response</span></strong><span class="koboSpan" id="kobo.555.1"> and invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">writeResponse</span></strong><span class="koboSpan" id="kobo.557.1"> function. </span><span class="koboSpan" id="kobo.557.2">We do not need to pass a type argument to this function, as the type can be inferred from the invocation on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">Response</span></strong><span class="koboSpan" id="kobo.559.1"> parameter. </span><span class="koboSpan" id="kobo.559.2">In the case of an error, we write the error to </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">Response</span></strong><span class="koboSpan" id="kobo.561.1"> and return it, stopping execution. </span><span class="koboSpan" id="kobo.561.2">In the happy path case, we write the books to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">Items</span></strong><span class="koboSpan" id="kobo.563.1"> slice. </span></p>
<p><span class="koboSpan" id="kobo.564.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">Magazine</span></strong><span class="koboSpan" id="kobo.566.1"> handlers will be implemented in the same way using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">db.Magazine</span></strong><span class="koboSpan" id="kobo.568.1"> type instead. </span><span class="koboSpan" id="kobo.568.2">We can use the same table-testing technique we have explored in previous sections for testing our </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">response logic.</span></span></p>
<p><span class="koboSpan" id="kobo.570.1">This brings us to the </span><a id="_idIndexMarker936"/><span class="koboSpan" id="kobo.571.1">end of our exploration with generic </span><a id="_idIndexMarker937"/><span class="koboSpan" id="kobo.572.1">code in Go. </span><span class="koboSpan" id="kobo.572.2">This powerful tool allows us to write flexible code, which can be used with different data types. </span><span class="koboSpan" id="kobo.572.3">When it comes to generic code, we should always keep in mind that it needs to be tested against different types of input parameters, not just different values. </span><span class="koboSpan" id="kobo.572.4">This can make testing more complicated, but we can still easily modify the popular technique of table-driven testing to test generic code. </span></p>
<h1 id="_idParaDest-222"><a id="_idTextAnchor245"/><span class="koboSpan" id="kobo.573.1">Testing best practices</span></h1>
<p><span class="koboSpan" id="kobo.574.1">This brings us to the end of this chapter and the end of our exploration of Go with TDD. </span><span class="koboSpan" id="kobo.574.2">We have had an amazing journey, having studied many libraries and techniques and applied them to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">BookSwap</span></strong><span class="koboSpan" id="kobo.576.1"> application, as well as smaller examples. </span><span class="koboSpan" id="kobo.576.2">In this final section, we will recap the lessons learned and formulate some testing </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">best practices.</span></span></p>
<p><span class="koboSpan" id="kobo.578.1">Achieving a comprehensive testing strategy requires constant effort and a cultural shift within an organization to embrace quality and prioritize testing. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.579.1">Figure 11</span></em></span><em class="italic"><span class="koboSpan" id="kobo.580.1">.4</span></em><span class="koboSpan" id="kobo.581.1"> presents a summary of some of the best practices we have explored divided into three </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">different categories:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer098">
<span class="koboSpan" id="kobo.583.1"><img alt="Figure 11.4 – Development, testing, and culture best practices " src="image/Figure_11.4_B18371.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.584.1">Figure 11.4 – Development, testing, and culture best practices</span></p>
<p><span class="koboSpan" id="kobo.585.1">We have discussed 14 best practices throughout this book, which have been divided into 3 categories – development, testing, </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">and culture.</span></span></p>
<h2 id="_idParaDest-223"><a id="_idTextAnchor246"/><span class="koboSpan" id="kobo.587.1">Development best practices</span></h2>
<p><span class="koboSpan" id="kobo.588.1">Here are </span><a id="_idIndexMarker938"/><span class="koboSpan" id="kobo.589.1">some best practices for development (as seen in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.590.1">Figure 11</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.591.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">):</span></span></p>
<ol>
<li value="1"><strong class="bold"><span class="koboSpan" id="kobo.593.1">Use TDD to write tests during the development process</span></strong><span class="koboSpan" id="kobo.594.1">: The best way to ensure that the code we write is tested is to include it in the development process. </span><span class="koboSpan" id="kobo.594.2">Code is never delivered untested and developers write testable, well-designed code. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.595.1">Use interfaces to wrap dependencies</span></strong><span class="koboSpan" id="kobo.596.1">: Our code will often have dependencies on other components. </span><span class="koboSpan" id="kobo.596.2">It is a good practice to have dependencies external to our package wrapped by interfaces so that they can be easily replaced, either by test code or with another dependency. </span><span class="koboSpan" id="kobo.596.3">We have explored dependencies and interfaces in </span><a href="B18371_03.xhtml#_idTextAnchor061"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.597.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.598.1">, </span><em class="italic"><span class="koboSpan" id="kobo.599.1">Mocking and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.600.1">Assertion Frameworks</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.602.1">Refactor code to tackle technical debt</span></strong><span class="koboSpan" id="kobo.603.1">: Code should be refactored alongside new </span><a id="_idIndexMarker939"/><span class="koboSpan" id="kobo.604.1">feature development to ensure that it stays performant, readable, and easy to maintain. </span><span class="koboSpan" id="kobo.604.2">We explored some refactoring techniques in </span><a href="B18371_07.xhtml#_idTextAnchor162"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.605.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.606.1">, </span><em class="italic"><span class="koboSpan" id="kobo.607.1">Refactoring in Go</span></em><span class="koboSpan" id="kobo.608.1">. </span><span class="koboSpan" id="kobo.608.2">Tests will ensure that no functionality is broken by the refactoring process. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.609.1">Write robust code that is able to handle a variety of inputs</span></strong><span class="koboSpan" id="kobo.610.1">: We discussed what code robustness is in </span><a href="B18371_10.xhtml#_idTextAnchor218"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.611.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.612.1">, </span><em class="italic"><span class="koboSpan" id="kobo.613.1">Testing Edge Cases</span></em><span class="koboSpan" id="kobo.614.1">. </span><span class="koboSpan" id="kobo.614.2">It should be able to handle a wide variety of inputs and respond with </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">well-formulated errors.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.616.1">Adopt generics for easier code reuse</span></strong><span class="koboSpan" id="kobo.617.1">: As we have seen in this chapter, generics allow us to write code that is able to handle different data inputs. </span><span class="koboSpan" id="kobo.617.2">This allows us to use reusable code, which works for a variety of </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">type parameters.</span></span></li>
</ol>
<h2 id="_idParaDest-224"><a id="_idTextAnchor247"/><span class="koboSpan" id="kobo.619.1">Testing best practices</span></h2>
<p><span class="koboSpan" id="kobo.620.1">Here are </span><a id="_idIndexMarker940"/><span class="koboSpan" id="kobo.621.1">some best practices for testing (as seen in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.622.1">Figure 11</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.623.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">):</span></span></p>
<ol>
<li value="1"><strong class="bold"><span class="koboSpan" id="kobo.625.1">Write simple, isolated tests</span></strong><span class="koboSpan" id="kobo.626.1">: Tests should be simple and isolated from their dependencies. </span><span class="koboSpan" id="kobo.626.2">This allows us to avoid setting up a large number of services, which can be cumbersome and are likely to change. </span><span class="koboSpan" id="kobo.626.3">Instead, we should write focused tests that make use of mocks to test the UUT in isolation. </span><span class="koboSpan" id="kobo.626.4">We explored mocks and dependencies in </span><a href="B18371_03.xhtml#_idTextAnchor061"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.627.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.628.1">, </span><em class="italic"><span class="koboSpan" id="kobo.629.1">Mocking and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.630.1">Assertion Frameworks</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.632.1">Use table-driven tests to cover a variety of scenarios</span></strong><span class="koboSpan" id="kobo.633.1">: The popular technique of writing table-driven testing is to easily create a list of test cases and run through them. </span><span class="koboSpan" id="kobo.633.2">Test cases should be run in their own subtests to create a well-structured test output. </span><span class="koboSpan" id="kobo.633.3">We explored this technique in </span><a href="B18371_04.xhtml#_idTextAnchor085"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.634.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.635.1">, </span><em class="italic"><span class="koboSpan" id="kobo.636.1">Building Efficient Test Suites</span></em><span class="koboSpan" id="kobo.637.1">, as well as </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">this chapter.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.639.1">Write tests at every level of the application</span></strong><span class="koboSpan" id="kobo.640.1">: Unit tests are fast, but they only assert that the functionality of a given package is correct, not that it is able to function correctly with other units. </span><span class="koboSpan" id="kobo.640.2">As depicted by the testing pyramid presented in </span><a href="B18371_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.641.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.642.1">, </span><em class="italic"><span class="koboSpan" id="kobo.643.1">Getting to Grips with Test-Driven Development</span></em><span class="koboSpan" id="kobo.644.1">, we should write automated tests that assert that the individual units of the application integrate and function correctly together. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.645.1">Use Go’s testing package</span></strong><span class="koboSpan" id="kobo.646.1">: While it might appear overly simple at first, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">testing</span></strong><span class="koboSpan" id="kobo.648.1"> package offers a wide variety of functionality that allows us to write functional and non-functional tests. </span><span class="koboSpan" id="kobo.648.2">We have explored the capabilities of this package throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">this book.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.650.1">Use third-party testing libraries</span></strong><span class="koboSpan" id="kobo.651.1">: We explored multiple third-party testing libraries (</span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">testify</span></strong><span class="koboSpan" id="kobo.653.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">ginkgo</span></strong><span class="koboSpan" id="kobo.655.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">godog</span></strong><span class="koboSpan" id="kobo.657.1">) that complement the standard </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">testing</span></strong><span class="koboSpan" id="kobo.659.1"> package and </span><a id="_idIndexMarker941"/><span class="koboSpan" id="kobo.660.1">make it easier for us to write test assertions and </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">create mocks.</span></span></li>
</ol>
<h2 id="_idParaDest-225"><a id="_idTextAnchor248"/><span class="koboSpan" id="kobo.662.1">Culture best practices</span></h2>
<p><span class="koboSpan" id="kobo.663.1">Here are some </span><a id="_idIndexMarker942"/><span class="koboSpan" id="kobo.664.1">best practices for culture (as seen in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.665.1">Figure 11</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.666.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">):</span></span></p>
<ol>
<li value="1"><strong class="bold"><span class="koboSpan" id="kobo.668.1">Document customer requirements</span></strong><span class="koboSpan" id="kobo.669.1">: User journeys and customer requirements should be at the heart of all the tests we write. </span><span class="koboSpan" id="kobo.669.2">As it is nearly impossible to write tests that cover every single code path and interaction, engineers should ensure that the things that matter to customers are prioritized and covered </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">by tests.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.671.1">Mitigate for errors and unexpected outages</span></strong><span class="koboSpan" id="kobo.672.1">: In microservices architectures, it is nearly impossible to ensure that there are zero outages. </span><span class="koboSpan" id="kobo.672.2">We should contract-test our services, as well as design our microservices architectures according to the best practices described in </span><a href="B18371_08.xhtml#_idTextAnchor179"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.673.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.674.1">, </span><em class="italic"><span class="koboSpan" id="kobo.675.1">Testing Microservice Architectures</span></em><span class="koboSpan" id="kobo.676.1">. </span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.677.1">Value and prioritize code quality</span></strong><span class="koboSpan" id="kobo.678.1">: As an organization, you should value and prioritize code quality, allowing the engineering teams time to refactor their services to ensure they can be easily extended and maintained for the future needs of </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">the business.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.680.1">Document non-functional requirements</span></strong><span class="koboSpan" id="kobo.681.1">: While one important use of tests is to ensure that our system is able to satisfy functional requirements, another important aspect </span><a id="_idIndexMarker943"/><span class="koboSpan" id="kobo.682.1">is to verify the performance of our system according to the needs of the customers. </span><span class="koboSpan" id="kobo.682.2">We explored how to test the performance of our code using benchmarks in </span><a href="B18371_02.xhtml#_idTextAnchor035"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.683.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.684.1">, </span><em class="italic"><span class="koboSpan" id="kobo.685.1">Unit Testing Essentials</span></em><span class="koboSpan" id="kobo.686.1">. </span></li>
</ol>
<p><span class="koboSpan" id="kobo.687.1">The final aspect to remember is that no testing strategy is perfect, as it cannot cover every single code path and edge case. </span><span class="koboSpan" id="kobo.687.2">The tools and techniques we have explored throughout this book should help you plan and implement the efficient testing of your system. </span><span class="koboSpan" id="kobo.687.3">There is no “one-size-fits-all” approach to a testing strategy, so make sure that you work with your product manager and other key business stakeholders to ensure that your testing efforts are made efficiently. </span></p>
<h1 id="_idParaDest-226"><a id="_idTextAnchor249"/><span class="koboSpan" id="kobo.688.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.689.1">In this chapter, we spent time exploring Go’s newly introduced generics support. </span><span class="koboSpan" id="kobo.689.2">We learned the basic syntax for implementing generic code, including how to specify type constraints. </span><span class="koboSpan" id="kobo.689.3">We also looked at a quick comparison of generic code versus writing code </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">using interfaces.</span></span></p>
<p><span class="koboSpan" id="kobo.691.1">Then, we revisited the previously introduced technique of table-driven testing and learned how to modify it to support generic code, allowing us to write test cases that support different input types and values. </span><span class="koboSpan" id="kobo.691.2">We also learned how to make use of generics to easily write our own test utilities, promoting code reuse in test code as well as </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">implementation code.</span></span></p>
<p><span class="koboSpan" id="kobo.693.1">Finally, we summarized all of the tools and techniques we have explored throughout this book with 14 best practices divided into 3 categories: development, testing, and culture. </span><span class="koboSpan" id="kobo.693.2">Implementing and maintaining a comprehensive testing strategy requires effort throughout the entire product and </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">engineering organization.</span></span></p>
<h1 id="_idParaDest-227"><a id="_idTextAnchor250"/><span class="koboSpan" id="kobo.695.1">Questions</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.696.1">What </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">is generics?</span></span></li>
<li><span class="koboSpan" id="kobo.698.1">What are the main components of </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">Go generics?</span></span></li>
<li><span class="koboSpan" id="kobo.700.1">Describe the steps involved in writing generic table-driven testing. </span></li>
</ol>
<h1 id="_idParaDest-228"><a id="_idTextAnchor251"/><span class="koboSpan" id="kobo.701.1">Further reading</span></h1>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.702.1">Generic Data Structures and Algorithms in Go: An Applied Approach Using Concurrency, Genericity and Heuristics</span></em><span class="koboSpan" id="kobo.703.1">, by Richard Wiener, published </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">by Apress</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.705.1">Cloud Native Go: Building Reliable Services in Unreliable Environments</span></em><span class="koboSpan" id="kobo.706.1">, by Matthew Titmus, published </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">by O’Reilly</span></span></li>
</ul>
</div>


<div id="_idContainer100">
<h1 id="_idParaDest-229"><a id="_idTextAnchor252"/><span class="koboSpan" id="kobo.1.1">Assessments</span></h1>
<h1 id="_idParaDest-230"><a id="_idTextAnchor253"/><span class="koboSpan" id="kobo.2.1">Chapter 1, Getting to Grips with Test-Driven Development</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.3.1">The testing pyramid specifies how automated test suites should be structured. </span><span class="koboSpan" id="kobo.3.2">At the bottom of the pyramid are unit tests, which test a single isolated component. </span><span class="koboSpan" id="kobo.3.3">Next up in the middle of the pyramid are integration tests, which test that multiple components are able to work together as specified. </span><span class="koboSpan" id="kobo.3.4">Finally, at the top of the test pyramid are end-to-end tests that test the behavior of the </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">entire application.</span></span></li>
<li><span class="koboSpan" id="kobo.5.1">Functional tests cover the correctness of a system, while non-functional tests cover the usability and performance of a system. </span><span class="koboSpan" id="kobo.5.2">Both types of tests are required to ensure that the system satisfies the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">customers’ needs.</span></span></li>
<li><span class="koboSpan" id="kobo.7.1">The red, green, and refactor TDD approach refers to the three phases of the process. </span><span class="koboSpan" id="kobo.7.2">The red phase involves writing a new failing test for the functionality we intend to implement. </span><span class="koboSpan" id="kobo.7.3">The green phase involves writing enough implementation code to make all tests pass. </span><span class="koboSpan" id="kobo.7.4">Finally, the refactor phase involves optimizing both implementation and testing code to remove duplication and come up with </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">better solutions.</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Acceptance test-driven development. </span><span class="koboSpan" id="kobo.9.2">Just like TDD, ATDD puts tests first. </span><span class="koboSpan" id="kobo.9.3">ATDD is related to TDD, but it involves writing a suite of acceptance tests before the implementation begins. </span><span class="koboSpan" id="kobo.9.4">It involves multiple stakeholders to ensure that the acceptance test captures the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">customer’s requirements.</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Code coverage is the percentage of your lines of code that are exercised by your unit test. </span><span class="koboSpan" id="kobo.11.2">This is calculated by considering the function statements, parameter values, and execution paths of your code. </span><span class="koboSpan" id="kobo.11.3">The Go test runner outputs the calculated code coverage. </span><span class="koboSpan" id="kobo.11.4">We should aim for a good value, but optimizing for 100% is normally </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">not appropriate.</span></span></li>
</ol>
<h1 id="_idParaDest-231"><a id="_idTextAnchor254"/><span class="koboSpan" id="kobo.13.1">Chapter 2, Unit Testing Essentials</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.14.1">In Go, a module is a collection of packages that should be built and released together. </span><span class="koboSpan" id="kobo.14.2">A package is a collection of Go files that must be built together. </span><span class="koboSpan" id="kobo.14.3">A module is specified by a </span><strong class="source-inline"><span class="koboSpan" id="kobo.15.1">go.mod</span></strong><span class="koboSpan" id="kobo.16.1"> file, while a package is specified by the package declaration at the top of the </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">source file.</span></span></li>
<li><span class="koboSpan" id="kobo.18.1">The additional test package is a package that matches the name of the source package with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.19.1">_test</span></strong><span class="koboSpan" id="kobo.20.1"> suffix added. </span><span class="koboSpan" id="kobo.20.2">The additional test package provides isolation between test code and source code, preventing brittle tests and allowing developers to see the integrations with </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">their packages.</span></span></li>
<li><span class="koboSpan" id="kobo.22.1">Test signatures have only a </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">few requirements:</span></span><ol><li><span class="koboSpan" id="kobo.24.1">The test name must begin with the </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">word </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.26.1">Test</span></strong></span></li><li><span class="koboSpan" id="kobo.27.1">Any other name that follows the </span><strong class="source-inline"><span class="koboSpan" id="kobo.28.1">Test</span></strong><span class="koboSpan" id="kobo.29.1"> must also </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">be capitalized</span></span></li><li><span class="koboSpan" id="kobo.31.1">There must only be one parameter of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.32.1">*testing.T</span></strong><span class="koboSpan" id="kobo.33.1"> type and no </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">return type</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.35.1">Subtests are tests that run within an enclosing test. </span><span class="koboSpan" id="kobo.35.2">They are created by passing a name and corresponding function to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">t.Run</span></strong><span class="koboSpan" id="kobo.37.1"> method on the enclosing test. </span><span class="koboSpan" id="kobo.37.2">A failure in a subtest will cause the failure of the enclosing test </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">as well.</span></span></li>
<li><span class="koboSpan" id="kobo.39.1">Benchmarks are a way to measure the performance of our code. </span><span class="koboSpan" id="kobo.39.2">Go’s test runner will repeatedly run the instrumented function until it finds stable measurements for the performance of the </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">benchmarked function.</span></span></li>
</ol>
<h1 id="_idParaDest-232"><a id="_idTextAnchor255"/><span class="koboSpan" id="kobo.41.1">Chapter 3, Mocking and Assertion Frameworks</span></h1>
<p><span class="koboSpan" id="kobo.42.1">The code examples included in this book are publicly available at </span><a href="https://github.com/PacktPublishing/Test-Driven-Development-in-Go"><span class="koboSpan" id="kobo.43.1">https://github.com/PacktPublishing/Test-Driven-Development-in-Go</span></a><span class="koboSpan" id="kobo.44.1">. </span><span class="koboSpan" id="kobo.44.2">You can find </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">the implemented</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">solution from the Question section in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">chapter03-solution</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.48.1"> directory.</span></span></p>
<h1 id="_idParaDest-233"><a id="_idTextAnchor256"/><span class="koboSpan" id="kobo.49.1">Chapter 4, Building Efficient Test Suites</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.50.1">An edge case is a test case that occurs at extreme values of an operating parameter. </span><span class="koboSpan" id="kobo.50.2">A corner case occurs at the extreme values of multiple operating parameters. </span><span class="koboSpan" id="kobo.50.3">As corner cases occur when multiple edge cases occur, they are much less likely to occur than </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">edge cases.</span></span></li>
<li><span class="koboSpan" id="kobo.52.1">An idempotent operation is an operation that can be repeated multiple times without changing the initial result. </span><span class="koboSpan" id="kobo.52.2">These operations are predominant in API design, which can often involve retries and resending requests due to </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">network conditions.</span></span></li>
<li><span class="koboSpan" id="kobo.54.1">In Go, error handling is done using the built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">error</span></strong><span class="koboSpan" id="kobo.56.1"> type. </span><span class="koboSpan" id="kobo.56.2">Errors are handled as part of regular code flow, where errors are handled just like any other return value, most often alongside other values using multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">return values.</span></span></li>
<li><span class="koboSpan" id="kobo.58.1">Table-driven testing is a popular technique that allows us to test multiple scenarios in a unified way, which reduces code duplication. </span><span class="koboSpan" id="kobo.58.2">Custom types are created, which represent the inputs and expected outputs of the particular test scenario. </span><span class="koboSpan" id="kobo.58.3">These are then saved in a test collection. </span><span class="koboSpan" id="kobo.58.4">The test collection is run over, with each case being </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">identically executed.</span></span></li>
<li><span class="koboSpan" id="kobo.60.1">By default, Go tests in different packages are run in parallel. </span><span class="koboSpan" id="kobo.60.2">Test cases within a package can be marked to be run in parallel using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">t.Parallel()</span></strong><span class="koboSpan" id="kobo.62.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">*testing.T</span></strong><span class="koboSpan" id="kobo.64.1"> instance. </span><span class="koboSpan" id="kobo.64.2">This allows tests that are marked accordingly to be run </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">in parallel.</span></span></li>
</ol>
<h1 id="_idParaDest-234"><a id="_idTextAnchor257"/><span class="koboSpan" id="kobo.66.1">Chapter 5, Performing Integration Testing</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.67.1">Integration tests cover multiple units of the system, ensuring that they work well together. </span><span class="koboSpan" id="kobo.67.2">End-to-end tests replicate user behavior on the system as </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">a whole.</span></span></li>
<li><span class="koboSpan" id="kobo.69.1">BDD is a branch of TDD that focuses on writing human-readable tests and involve a variety of stakeholders from across the business. </span><span class="koboSpan" id="kobo.69.2">The most important part of BDD is establishing a common vocabulary that is shared across </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">the business.</span></span></li>
<li><span class="koboSpan" id="kobo.71.1">No, it is considered an anti-pattern to mock databases. </span><span class="koboSpan" id="kobo.71.2">They are complex systems that are difficult to mock and replicate. </span><span class="koboSpan" id="kobo.71.3">In general, tests should use the same database as </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">in production.</span></span></li>
<li><span class="koboSpan" id="kobo.73.1">A container is a unit of software and all its dependencies, specified by a container image. </span><span class="koboSpan" id="kobo.73.2">Docker Engine starts up and manages containers on top of the </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">operating system.</span></span></li>
</ol>
<h1 id="_idParaDest-235"><a id="_idTextAnchor258"/><span class="koboSpan" id="kobo.75.1">Chapter 6, End-to-End Testing the BookSwap Web Application</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.76.1">A user journey is a path that a user may take to achieve their goal while using a given application. </span><span class="koboSpan" id="kobo.76.2">Identifying user journeys allows us to write E2E tests that correctly replicate and verify the user experience on </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">our platform.</span></span></li>
<li><span class="koboSpan" id="kobo.78.1">ORM stands for object-relational mapping and is a technique that allows us to bridge the gap between object-oriented languages and relational databases. </span><span class="koboSpan" id="kobo.78.2">It allows developers to interact with the database types as just any other </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">custom type.</span></span></li>
<li><span class="koboSpan" id="kobo.80.1">Docker Compose allows us to easily define and network multi-container applications. </span><span class="koboSpan" id="kobo.80.2">Dockerfiles define the steps to building a single container image, while Docker Compose allows us to define services with a single configuration </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">and command.</span></span></li>
<li><span class="koboSpan" id="kobo.82.1">Database seeding involves adding initial data to a database. </span><span class="koboSpan" id="kobo.82.2">Often, this dummy data is generated and changes between </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">test runs.</span></span></li>
</ol>
<h1 id="_idParaDest-236"><a id="_idTextAnchor259"/><span class="koboSpan" id="kobo.84.1">Chapter 7, Refactoring in Go</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.85.1">Code redesign involves changing the functionality of an existing service, while code refactoring involves changing the internal structure of an existing service, without changing its existing functionality. </span><span class="koboSpan" id="kobo.85.2">Code redesign changes the </span><em class="italic"><span class="koboSpan" id="kobo.86.1">what</span></em><span class="koboSpan" id="kobo.87.1">, while code refactoring changes the </span><em class="italic"><span class="koboSpan" id="kobo.88.1">how</span></em><span class="koboSpan" id="kobo.89.1">. </span><span class="koboSpan" id="kobo.89.2">If done correctly, code refactoring will not be visible outside the refactored </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">code scope.</span></span></li>
<li><span class="koboSpan" id="kobo.91.1">The developer starts by identifying the change they wish to make. </span><span class="koboSpan" id="kobo.91.2">Then, they modify their implementation or test code. </span><span class="koboSpan" id="kobo.91.3">Once this is done and the code compiles, they then run their test suite. </span><span class="koboSpan" id="kobo.91.4">If the suite is passing, the code refactor has been successful. </span><span class="koboSpan" id="kobo.91.5">However, if the suite is not passing, the developer revisits their code change, adjusting it together with the test code until the test suite is passing. </span><span class="koboSpan" id="kobo.91.6">No change is released until the test suite successfully verifies </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">the change.</span></span></li>
<li><span class="koboSpan" id="kobo.93.1">Technical debt is the term used to refer to code that has not been written to the technical team’s typical high standards of quality. </span><span class="koboSpan" id="kobo.93.2">It typically occurs when the team prioritizes speedy delivery over taking the time to design a </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">high-quality solution.</span></span></li>
<li><span class="koboSpan" id="kobo.95.1">A monolithic application is a single application that is built and released as a single unit. </span><span class="koboSpan" id="kobo.95.2">A microservice architecture is a system design pattern that involves building independently built and released units. </span><span class="koboSpan" id="kobo.95.3">Organizations typically start with monolithic applications and then move to microservice architectures </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">as needed.</span></span></li>
</ol>
<h1 id="_idParaDest-237"><a id="_idTextAnchor260"/><span class="koboSpan" id="kobo.97.1">Chapter 8, Testing Microservice Architectures</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.98.1">Functional testing ensures that the features of the system work correctly. </span><span class="koboSpan" id="kobo.98.2">Non-functional testing verifies that other aspects of the system behave as expected. </span><span class="koboSpan" id="kobo.98.3">The two main types of non-functional testing are performance tests and </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">usability tests.</span></span></li>
<li><span class="koboSpan" id="kobo.100.1">Performance testing relies on key metrics to quantify and compare the performance of the application. </span><span class="koboSpan" id="kobo.100.2">Important key metrics to monitor are response time, error rate, concurrent users, data throughput, and </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">CPU/memory usage.</span></span></li>
<li><span class="koboSpan" id="kobo.102.1">Performance testing ensures that the system is scalable by measuring the performance of the individual parts of the system, allowing us to identify bottlenecks and improvements required. </span><span class="koboSpan" id="kobo.102.2">Furthermore, testing at higher loads of the system allows us to estimate the limits of what the system can handle, and helps us understand what the growth runway of the current system </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">configuration is.</span></span></li>
<li><span class="koboSpan" id="kobo.104.1">Microservice architectures provide scalability benefits because they allow the different parts of our system to be scaled independently. </span><span class="koboSpan" id="kobo.104.2">They also allow easier maintenance and provide increased delivery speed, as engineering teams can own and change their services without any central oversight. </span><span class="koboSpan" id="kobo.104.3">On the other hand, they introduce complexity in every part of the software </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">life cycle</span></span><ol><li><span class="koboSpan" id="kobo.106.1">Development complexity as engineers need to structure multiple code bases, then implement and test features across </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">multiple services.</span></span></li><li><span class="koboSpan" id="kobo.108.1">Deployment complexity as each service has its own infrastructure to be maintained. </span><span class="koboSpan" id="kobo.108.2">Automation of the release pipelines becomes essential in order to make it easy for engineers to release </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">multiple services.</span></span></li><li><span class="koboSpan" id="kobo.110.1">Organizational complexity as engineers must handle increased ownership of multiple services. </span><span class="koboSpan" id="kobo.110.2">While teams are able to deliver features on multiple services without any central oversight, they must also communicate to establish common technical standards, suitable for a variety </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">of microservices.</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.112.1">Contract testing is a testing technique that allows us to reliably test the interaction between two services. </span><span class="koboSpan" id="kobo.112.2">The consumer initiates the exchange and sends the request, while the provider processes the request and sends back the response. </span><span class="koboSpan" id="kobo.112.3">The exchange is recorded in a contract on the consumer side. </span><span class="koboSpan" id="kobo.112.4">Then, the contract is verified on the provider side against the real implementation. </span><span class="koboSpan" id="kobo.112.5">One of the key advantages of contract testing is that it allows us to verify the integration between two services without having to run and maintain the test against real implementations of both the consumer </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">and provider.</span></span></li>
</ol>
<h1 id="_idParaDest-238"><a id="_idTextAnchor261"/><span class="koboSpan" id="kobo.114.1">Chapter 9, Challenges of Testing Concurrent Code</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.115.1">Concurrency refers to a program’s ability to execute more than one task, with interruptions and without any ordering guarantees. </span><span class="koboSpan" id="kobo.115.2">Parallelism refers to a program’s ability to execute more than one task, simultaneously and without interruptions. </span><span class="koboSpan" id="kobo.115.3">The OS (or even in silico implementations such as hyperthreading) may give the illusion of parallelism through pre-emptive multitasking. </span><span class="koboSpan" id="kobo.115.4">However, in order for parallelism to be truly simultaneous, multiple computational resources </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">are required.</span></span></li>
<li><span class="koboSpan" id="kobo.117.1">Channels support three operations. </span><span class="koboSpan" id="kobo.117.2">The send operation writes information to the channel, while the receive operation reads information from the channel. </span><span class="koboSpan" id="kobo.117.3">The close operation signals to all receivers that no more values will be sent through it. </span><span class="koboSpan" id="kobo.117.4">Once closed, channels can never be reopened. </span><span class="koboSpan" id="kobo.117.5">For unbuffered channels, send and receive operations are synchronous and will only complete once both sender and receiver are available. </span><span class="koboSpan" id="kobo.117.6">On closed channels, sends will panic, while receives will immediately complete with the zero value of the channel’s </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">data type.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">sync.Mutex</span></strong><span class="koboSpan" id="kobo.120.1"> is a lock that exposes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">Lock</span></strong><span class="koboSpan" id="kobo.122.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">Unlock</span></strong><span class="koboSpan" id="kobo.124.1"> methods. </span><span class="koboSpan" id="kobo.124.2">Goroutines will block until they can acquire the lock successfully. </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">sync.WaitGroup</span></strong><span class="koboSpan" id="kobo.126.1"> is a specialized lock that maintains an inner counter that will block until the inner counter of </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">WaitGroup</span></strong><span class="koboSpan" id="kobo.128.1"> reaches 0 by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">Done</span></strong><span class="koboSpan" id="kobo.130.1"> on </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">WaitGroup</span></strong><span class="koboSpan" id="kobo.132.1"> the appropriate number of times. </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">sync.WaitGroup</span></strong><span class="koboSpan" id="kobo.134.1"> allows us to wait for multiple goroutines to complete, in a simpler and more compact way than reading from channels or </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">shared memory.</span></span></li>
<li><span class="koboSpan" id="kobo.136.1">A data race occurs when multiple goroutines access and modify a shared resource. </span><span class="koboSpan" id="kobo.136.2">This can lead to inconsistent values and hard-to-detect bugs. </span><span class="koboSpan" id="kobo.136.3">A deadlock occurs when goroutines are blocked, waiting for a resource that never becomes available. </span><span class="koboSpan" id="kobo.136.4">If the whole program becomes blocked, the Go runtime will detect the deadlock and shut down </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">the program.</span></span></li>
<li><span class="koboSpan" id="kobo.138.1">Go’s race detector is integrated into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">go</span></strong><span class="koboSpan" id="kobo.140.1"> tool chain and is enabled with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">–race</span></strong><span class="koboSpan" id="kobo.142.1"> command-line flag. </span><span class="koboSpan" id="kobo.142.2">It instruments memory access and reports when data races are detected. </span><span class="koboSpan" id="kobo.142.3">As it significantly increases the CPU and memory usage of the applications it instruments, the race detector should not be used </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">in production.</span></span></li>
</ol>
<h1 id="_idParaDest-239"><a id="_idTextAnchor262"/><span class="koboSpan" id="kobo.144.1">Chapter 10, Testing Edge Cases</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.145.1">A robust system is one that continues to function correctly, even when supplied with unexpected or exceptional inputs. </span><span class="koboSpan" id="kobo.145.2">When errors or unexpected inputs occur, the system is able to handle them gracefully without panics and return meaningful errors. </span><span class="koboSpan" id="kobo.145.3">Robust code is readable, maintainable, and easy </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">to test.</span></span></li>
<li><span class="koboSpan" id="kobo.147.1">Fuzz testing is a software testing technique that involves generating a large amount of random data, which is then passed to the fuzz target in an attempt to verify its behavior against a wide range of parameters. </span><span class="koboSpan" id="kobo.147.2">Fuzz testing makes it easier to uncover bugs by reducing the number of tests we need to write manually to cover edge cases of </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">input variables.</span></span></li>
<li><span class="koboSpan" id="kobo.149.1">A fuzzed test begins with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">Fuzz</span></strong><span class="koboSpan" id="kobo.151.1"> prefix, takes in a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">*testing.F</span></strong><span class="koboSpan" id="kobo.153.1"> parameter, and returns no values. </span><span class="koboSpan" id="kobo.153.2">Just like other tests, they must be defined inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">_test.go</span></strong><span class="koboSpan" id="kobo.155.1"> files. </span><span class="koboSpan" id="kobo.155.2">They are run using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">go </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">test</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.158.1"> command.</span></span></li>
<li><span class="koboSpan" id="kobo.159.1">Property-based testing is a technique that involves the generation and verification of input values that satisfy a set of system properties or specifications. </span><span class="koboSpan" id="kobo.159.2">This allows us to test a wide variety of edge cases that are relevant to our system without the need to manually write and maintain a large number </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">of tests.</span></span></li>
<li><span class="koboSpan" id="kobo.161.1">From the viewpoint of the UUT, untrusted inputs are any values that the UUT receives or that it uses that it has not generated. </span><span class="koboSpan" id="kobo.161.2">These inputs can be good candidates for </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">fuzzing arguments.</span></span></li>
</ol>
<h1 id="_idParaDest-240"><a id="_idTextAnchor263"/><span class="koboSpan" id="kobo.163.1">Chapter 11, Working with Generics</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.164.1">Generics is the ability to write code that is able to be used with different data types without being limited to a single type. </span><span class="koboSpan" id="kobo.164.2">It is a powerful mechanism, supported by most programming languages, and allows us to write flexible, </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">reusable code.</span></span></li>
<li><span class="koboSpan" id="kobo.166.1">The main components of Go generics are type parameters, type constraints, type arguments, and </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">type inferences:</span></span><ol><li><span class="koboSpan" id="kobo.168.1">Type parameters are the placeholder types that will be used in our generic code, typically denoted by a </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">single letter.</span></span></li><li><span class="koboSpan" id="kobo.170.1">Type constraints restrict the types that can be used with our generic function </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">or type.</span></span></li><li><span class="koboSpan" id="kobo.172.1">Type arguments are the types that are passed to the function upon invocation. </span><span class="koboSpan" id="kobo.172.2">They replace the type parameters and satisfy the </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">type constraints.</span></span></li><li><span class="koboSpan" id="kobo.174.1">Type inference is the process that takes place under the hood to determine the type of a variable, without us needing to explicitly declare it. </span><span class="koboSpan" id="kobo.174.2">This makes generic code </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">less verbose.</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.176.1">Testing generic code with table-driven tests will often involve writing test cases with different type parameters. </span><span class="koboSpan" id="kobo.176.2">To support this, we define generic test case types that can contain different input types. </span><span class="koboSpan" id="kobo.176.3">Then, a generic test run function that is able to run over the generic test cases and interact with the input types should be created. </span><span class="koboSpan" id="kobo.176.4">Test cases should be run in subtests, ensuring that test runs have a </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">structured output.</span></span></li>
</ol>
</div>
</body></html>