["```go\n    func sum[T any](x, y T) T {\n    ```", "```go\n      // implementation\n    ```", "```go\n    } \n    ```", "```go\n    func sum[T comparable](x, y T) T {\n    ```", "```go\n      // implementation\n    ```", "```go\n    } \n    ```", "```go\n    func sum[T int64 | float64](x, y T) T {\n    ```", "```go\n      // implementation\n    ```", "```go\n    }\n    ```", "```go\n    type Number interface {\n    ```", "```go\n      int64 | float64\n    ```", "```go\n    }\n    ```", "```go\n    func sum[T Number](x, y T) T {\n    ```", "```go\n      // implementation\n    ```", "```go\n    }\n    ```", "```go\n    type Number interface {\n    ```", "```go\n      ~int64 | ~float64\n    ```", "```go\n    }\n    ```", "```go\n    func sum[T constraints.Signed](x, y T) T {\n    ```", "```go\n      // implementation \n    ```", "```go\n    }\n    ```", "```go\n// GetSortedValues returns the key-sorted values of a given map.\nfunc GetSortedValues(input map[int]string, dir SortDirection) ([]string, error) {\n  // implementation\n} \n```", "```go\n // GetSortedFloatValues returns the key-sorted values of a given map with int key and float64 values. \nfunc GetSortedFloatValues(input map[int]float64, dir SortDirection) ([]string, error) { \n  // implementation \n}\n```", "```go\n// GetSortedValues returns the key-sorted values of a given map.\nfunc GetSortedValues[K ~int, V comparable](input map[K]V, dir SortDirection) ([]V, error) {\n  // implementation\n}\n```", "```go\ntype testCase[K ~int, V comparable] struct {\n  input  map[K]V\n}\n```", "```go\ntype CustomI int\ntestStrings := map[string]testCase[int, string]{\n  \"unordered\":       {input: map[int]string{99: \"A\", 50:\"X\"}},\n  \"empty map\":       {input: map[int]string{}},\n  \"negative values\": {input: map[int]string{-99: \"A\", -1:\"X\"}},\n}\ntestFloats := map[string]testCase[CustomI, float64]{\n  \"unordered\":     {input: map[CustomI]float64{99: 1.2, 0: 4.6}},\n  \"empty map\":     {input: map[CustomI]float64{}},\n  \"negative keys\": {input: map[CustomI]float64{-99: 1.2, 0: 4.6}},\n}\n```", "```go\nfunc runTests[K ~int, V comparable](t *testing.T, tests map[string]testCase[K, V]) {\n  t.Helper()\n  for name, rtc := range tests {\n    tc := rtc\n    t.Run(name, func(t *testing.T) {\n      keys := make([]K, 0, len(tc.input))\n      for k := range tc.input {\n        keys = append(keys, k)\n      }\n      sort.Slice(keys, func(i, j int) bool {\n        return keys[i] < keys[j]\n      })\n      sortedValues, err := gs.GetSortedValues(tc.input, gs.ASC)\n      require.Nil(t, err)\n      require.NotNil(t, sortedValues)\n      for index, v := range sortedValues {\n        key := keys[index]\n        assert.Equal(t, tc.input[key], v)\n      }\n    })\n  }\n}\n```", "```go\nfunc TestGetSortedValues(t *testing.T) {\n  t.Run(\"[int]string\", func(t *testing.T) {\n    testStrings := map[string]testCase[int, string]{\n      // values declaration \n    }\n    runTests(t, testStrings)\n  })\n  t.Run(\"[CustomI]float64\", func(t *testing.T) {\n    testFloats := map[string]testCase[CustomI, float64]{\n      // values declaration\n    }\n    runTests(t, testFloats)\n  })\n}\n```", "```go\n$ go test -run TestGetSortedValues ./chapter11/generics/sort -v\n=== RUN   TestGetSortedValues\n--- PASS: TestGetSortedValues\n  --- PASS: TestGetSortedValues/[int]string\n    --- PASS: TestGetSortedValues/[int]string/unordered\n    --- PASS: TestGetSortedValues/[int]string/empty_map\n    --- PASS: TestGetSortedValues/[int]string/negative_values\n  --- PASS: TestGetSortedValues/[CustomI]float64\n    --- PASS: TestGetSortedValues/[CustomI]float64/unordered\n    --- PASS: TestGetSortedValues/[CustomI]float64/empty_map \n    --- PASS: TestGetSortedValues/[CustomI]float64/negative_keys PASS\nok  github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter11/generics/sort        0.201s\n```", "```go\nfunc AssertMapOrderedByKeys[K ~int, V comparable](t *testing.T, input map[K]V, want []V) {\n  t.Helper()\n  keys := make([]K, 0, len(input))\n  for k := range input {\n    keys = append(keys, k)\n  }\n  sort.Slice(keys, func(i, j int) bool {\n    return keys[i] < keys[j]\n  })\n  for index, v := range want {\n    key := keys[index]\n    assert.Equal(t, input[key], v)\n  }\n}\n```", "```go\ntype Response struct {\n  Message string    `json:\"message,omitempty\"`\n  Error   string    `json:\"error,omitempty\"`\n  Books   []db.Book `json:\"books,omitempty\"`\n  User    *db.User  `json:\"user,omitempty\"`\n}\n```", "```go\ntype ResponseItemType interface {\n  db.Book | db.Magazine\n}\n```", "```go\ntype Response[T ResponseItemType] struct {\n  Message string   `json:\"message,omitempty\"`\n  Error   string   `json:\"error,omitempty\"`\n  Items   []T      `json:\"items,omitempty\"`\n  User    *db.User `json:\"user,omitempty\"`\n}\n```", "```go\nfunc writeResponse[T ResponseItemType](w http.ResponseWriter, status int, resp *Response[T]) { \n  // implementation\n}\n```", "```go\n// ListBooks is invoked by HTTP GET /books.\nfunc (h *Handler) ListBooks(w http.ResponseWriter, r *http.Request){\n  books, err := h.bs.List()\n  if err != nil {\n    writeResponse(w, http.StatusInternalServerError, &Response[db.Book]{\n      Error: err.Error(),\n    })\n    return\n }\n  // Send an HTTP status & the list of books\n  writeResponse(w, http.StatusOK, &Response[db.Book]{\n    Items: books,\n  })\n}\n```"]