- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Working with Generics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用泛型
- en: The previous chapters have covered all the aspects of testing and code design,
    gradually increasing in complexity. These tests will allow us to verify the behavior
    of a wide variety of applications, including microservices architectures and services
    that persist data to a database service. We have all the knowledge to perform
    the functional and non-functional testing of a variety of systems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章已经涵盖了测试和代码设计的各个方面，复杂性逐渐增加。这些测试将使我们能够验证各种应用程序的行为，包括微服务架构和将数据持久化到数据库服务的服务。我们拥有执行各种系统功能性和非功能性测试所需的所有知识。
- en: We have also discussed how systems need to change and evolve, as engineering
    organizations grow and new functionality is added. In [*Chapter 9*](B18371_09.xhtml#_idTextAnchor197),
    *Challenges of Testing Concurrent Code*, we discussed how to make the most of
    computing resources by making use of Go’s concurrency mechanisms, enabling us
    to serve production traffic. In [*Chapter 10*](B18371_10.xhtml#_idTextAnchor218),
    *Testing Edge Cases*, we explored two testing techniques to cover system edge
    cases, including Go’s fuzz testing capabilities.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了随着工程组织的成长和新功能的添加，系统需要如何改变和演进。在第[*9章*](B18371_09.xhtml#_idTextAnchor197)中，*并发代码的测试挑战*，我们讨论了如何通过利用Go的并发机制来最大限度地利用计算资源，从而能够处理生产流量。在第[*10章*](B18371_10.xhtml#_idTextAnchor218)中，*测试边缘情况*，我们探索了两种测试技术来覆盖系统边缘情况，包括Go的模糊测试功能。
- en: Go’s `go test` toolset. Generics was a major, much-anticipated feature by the
    Go community. It allows us to write functions, types, and data structures that
    can work with any type, rather than being limited to one type when we declare
    them. A newly released language feature is another reason why we might change
    our code, alongside the maintenance and feature development processes we have
    discussed.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Go的`go test`工具集。泛型是Go社区期待已久的重大功能之一。它允许我们编写可以与任何类型一起工作的函数、类型和数据结构，而不是在声明时局限于一种类型。新发布的语言功能是我们可能改变代码的另一个原因，与我们所讨论的维护和功能开发过程并列。
- en: This chapter will explore the implementation and testing of generic code. We
    will begin by exploring how to write generic code, exploring both use cases and
    syntax. Then, we will explore how to test generic code, including where generics
    can be used to streamline our test code. Finally, we will reflect on all we have
    learned and summarize some of the testing best practices that we have explored
    throughout this book.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨泛型代码的实现和测试。我们将从探索如何编写泛型代码开始，探讨用例和语法。然后，我们将探讨如何测试泛型代码，包括泛型如何帮助我们简化测试代码。最后，我们将回顾我们所学的所有内容，并总结一些我们在本书中探索的测试最佳实践。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The basics of writing generic code in Go
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Go中编写泛型代码的基础
- en: Testing generic code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试泛型代码
- en: Leveraging generics for test utilities
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用泛型为测试工具提供支持
- en: A summary of the testing best practices we have covered in this book
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书涵盖的测试最佳实践的总结
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need to have **Go version 1.19** or later installed to run the code
    samples in this chapter. The installation process is described in the official
    Go documentation at [https://go.dev/doc/install](https://go.dev/doc/install).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装**Go版本1.19**或更高版本才能运行本章中的代码示例。安装过程在官方Go文档中有描述，请参阅[https://go.dev/doc/install](https://go.dev/doc/install)。
- en: The code examples included in this book are publicly available at [https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter11](https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter11).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本书包含的代码示例在[https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter11](https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter11)上公开提供。
- en: Writing generic code in Go
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中编写泛型代码
- en: The introduction of generics in Go was a highly debated and anticipated feature.
    Some developers felt that introducing it would contradict Go’s core principles
    of simplicity, while others felt like it was a sign of maturity and would allow
    them to write better production code. As with every technical solution or design
    decision, there is a trade-off between the advantages and disadvantages.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Go中泛型的引入是一个备受争议和期待的功能。一些开发者认为引入泛型会与Go的核心原则——简洁性相矛盾，而另一些开发者则认为这是一个成熟的标志，将使他们能够编写更好的生产代码。与每个技术解决方案或设计决策一样，优势和劣势之间存在着权衡。
- en: As previously mentioned, **generics** refers to the ability to write code that
    works with different data types without being limited to a specific type. In the
    absence of generics, we have used Go interfaces to implement generic behavior
    in Go. In [*Chapter 3*](B18371_03.xhtml#_idTextAnchor061), *Mocking and Assertion
    Frameworks*, we explored the power of interfaces and have seen how they can be
    used for wrapping and replacing dependencies. While interfaces are not the same
    as generics, they provide a way to achieve similar goals of **flexibility** and
    **code reuse**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，**泛型**指的是编写与不同数据类型一起工作的代码的能力，而无需限制为特定类型。在没有泛型的情况下，我们使用了 Go 接口在 Go 中实现泛型行为。在
    [*第 3 章*](B18371_03.xhtml#_idTextAnchor061)，*Mocking 和 Assertion Frameworks* 中，我们探讨了接口的力量，并看到了它们如何被用于封装和替换依赖项。虽然接口与泛型不同，但它们提供了一种实现类似目标
    **灵活性** 和 **代码重用** 的方法。
- en: '*Figure 11**.1* provides a comparison of generics and interfaces:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11**.1* 展示了泛型和接口的比较：'
- en: '![Figure 11.1 – Comparison of generics and interfaces ](img/Figure_11.1_B18371.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – 泛型和接口的比较](img/Figure_11.1_B18371.jpg)'
- en: Figure 11.1 – Comparison of generics and interfaces
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 泛型和接口的比较
- en: 'While both generics and interfaces provide code flexibility and polymorphism
    to our code, they have the following main differences:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然泛型和接口都为我们提供了代码灵活性和多态性，但它们有以下主要区别：
- en: Generics are a way to specify the type, while interfaces specify behavior. As
    we have seen, interfaces are collections of methods that must be defined by structs
    in order to satisfy them. On the other hand, generics give us the ability to specify
    the types of parameters that can be used.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 泛型是一种指定类型的方式，而接口指定行为。正如我们所见，接口是一组必须由结构体定义的方法，以满足它们。另一方面，泛型使我们能够指定可以使用的参数类型。
- en: Generics are built into the language, while interfaces are defined by the application.
    Interfaces are defined by engineers as part of their code bases, which makes it
    easier to define them to include any behavior required by the application. The
    specifications of generics are built into the language and can be shared across
    code bases.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 泛型是语言内置的，而接口是由应用程序定义的。接口由工程师作为其代码库的一部分来定义，这使得定义它们以包含应用程序所需的行为变得更加容易。泛型的规范是内置到语言中的，并且可以在代码库之间共享。
- en: Generics have limited scope, while interfaces have a wide scope. As they are
    built into the language, they are simple enough to implement solutions to a wide
    variety of problems. On the other hand, interfaces are expressive and can define
    complex behavior.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 泛型的范围有限，而接口的范围广泛。由于它们是内置到语言中的，因此它们足够简单，可以解决各种各样的问题。另一方面，接口具有表达性，可以定义复杂的行为。
- en: Both generics and interfaces are implemented by the Go compiler, so they are
    both statically type-checked. However, interfaces ensure that specific methods
    are available for a parameter, while generics do not provide these guarantees.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型和接口都是由 Go 编译器实现的，因此它们都进行静态类型检查。然而，接口确保参数有特定的方法可用，而泛型则不提供这些保证。
- en: Generics in Go
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go 中的泛型
- en: The ability to write generic code is a core part of other strongly typed programming
    languages such as Java, C#, and C++. Its addition to Go gives us the ability to
    write more flexible and reusable code. Let us look at some examples of how we
    can leverage this new ability.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 编写泛型代码的能力是其他强类型编程语言（如 Java、C# 和 C++）的核心部分。将其添加到 Go 中，使我们能够编写更灵活和可重用的代码。让我们看看一些如何利用这种新能力的例子。
- en: 'There are three main components for specifying generic code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 指定泛型代码有三个主要组件：
- en: '`T`, and allow us to reference the placeholder type in our implementation.
    A generic function or type is defined by this placeholder as part of its specification.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`T`，并允许我们在实现中引用占位符类型。泛型函数或类型由这个占位符作为其规范的一部分来定义。'
- en: '**Type constraints** help us define rules or subtypes for the type parameters.
    Constraints are not full specifications like interfaces, but they allow us to
    restrict type parameters to certain properties.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**类型约束**帮助我们为类型参数定义规则或子类型。约束不是像接口那样的完整规范，但它们允许我们将类型参数限制为某些属性。'
- en: '**Type arguments** are the type that is passed to the generic function or type
    upon invocation, which specifies the type of data we will be using. Type arguments
    are used in place of the type parameter placeholders declared by the function
    or type signature.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**类型参数**是在调用通用函数或类型时传递的类型，它指定了我们将使用的数据类型。类型参数用于替换函数或类型签名中声明的类型参数占位符。'
- en: '**Type inference** is the process that takes place under the hood to determine
    the type of a variable, without its explicit type specification. This also allows
    us to write less verbose generic code.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**类型推断**是在幕后进行的确定变量类型的过程，而不需要显式指定其类型。这也允许我们编写更简洁的泛型代码。'
- en: 'These four components work together to make it easy for us to write generic
    code. *Figure 11**.2* demonstrates each component with a simple example of a generic
    function:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个组件共同作用，使我们能够轻松编写通用代码。*图11.2*通过一个通用函数的简单示例演示了每个组件：
- en: '![Figure 11.2 – Generics example on a simple function ](img/Figure_11.2_B18371.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 – 简单函数的泛型示例](img/Figure_11.2_B18371.jpg)'
- en: Figure 11.2 – Generics example on a simple function
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 简单函数的泛型示例
- en: The example defines a generic `sum` function that takes in two parameters. It
    defines a type parameter, `T`, which must satisfy the specified type constraints.
    In the `main` function, we invoke the function with an `int64` type argument and
    two parameters. The compiler uses type inference to ensure that the passed parameters
    comply with the type constraint and replace the type parameter with the type argument
    supplied in the `main` function. We will explore how to write and test generic
    Go code in the next sections.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例定义了一个通用`sum`函数，它接受两个参数。它定义了一个类型参数`T`，该参数必须满足指定的类型约束。在`main`函数中，我们使用`int64`类型参数和两个参数调用该函数。编译器使用类型推断来确保传递的参数符合类型约束，并用`main`函数中提供的类型参数替换类型参数。我们将在下一节中探讨如何编写和测试通用Go代码。
- en: Exploring type constraints
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索类型约束
- en: Type constraints are a central component of generics, as they allow us to limit
    the data types that our generic code can be used with. This makes it easier for
    us to write safe and simple code that operates on types that meet specified conditions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 类型约束是泛型的一个核心组件，因为它们允许我们限制我们的泛型代码可以与之一起使用的数据类型。这使得我们能够编写更安全、更简单的代码，这些代码在满足指定条件的数据类型上操作。
- en: 'Type parameters are declared inside square brackets (`[]`) in Go. The type
    parameter defines a name and possible constraints for a type. We can declare constraints
    in a few ways:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，类型参数是在方括号`[]`内声明的。类型参数定义了一个类型名称和可能的约束。我们可以以几种方式声明约束：
- en: 'The `any` interface is an alias for the empty interface, `interface{}`, and
    allows all types to be used. This allows us to build functions and types without
    constraints. For example, we can make the `sum` function accept any parameter
    type by using the `any` interface:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`any`接口是空接口`interface{}`的别名，允许使用所有类型。这使我们能够构建无约束的函数和类型。例如，我们可以通过使用`any`接口使`sum`函数接受任何参数类型：'
- en: '[PRE0]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `comparable` interface is a pre-declared type constraint that denotes types
    that can be compared using the `==` operator. These types are `string`, `bool`,
    all numbers, and composite types containing comparable fields. For example, the
    `sum` function will now allow these types as parameters, but we will need to implement
    the sum logic accordingly, as the `+` operator will no longer be implemented by
    all these types:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`comparable`接口是一个预声明的类型约束，表示可以使用`==`运算符进行比较的类型。这些类型是`string`、`bool`、所有数字以及包含可比较字段的复合类型。例如，`sum`函数现在将允许这些类型作为参数，但我们需要相应地实现求和逻辑，因为`+`运算符将不再由所有这些类型实现：'
- en: '[PRE3]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`|` operator. This allows us to create constraints that contain multiple types
    without having to wrap them in a custom interface. This is the example we have
    seen in *Figure 11**.2*, where the `sum` function allows the `int64` and `float64`
    types, which already support the `+` operator:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`|`运算符。这允许我们创建包含多个类型的约束，而无需将它们包装在自定义接口中。这正是我们在*图11.2*中看到的例子，其中`sum`函数允许`int64`和`float64`类型，这些类型已经支持`+`运算符：'
- en: '[PRE6]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`|` operator. For example, the `Number` interface allows the `int64` and `float64`
    types, which we can then use in the specification of the `sum` function, resulting
    in the same specification as the previous type sets:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`|`运算符。例如，`Number`接口允许`int64`和`float64`类型，然后我们可以将这些类型用于`sum`函数的指定中，从而得到与之前类型集相同的指定：'
- en: '[PRE9]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `~` keyword can be used to restrict all custom types that have the same
    underlying type. This allows us to encompass custom types into our constraints.
    For example, the `Number` interface will now allow any `int`- and `float64`-based
    types:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`~`关键字来限制所有具有相同底层类型的自定义类型。这允许我们将自定义类型纳入我们的约束之中。例如，`Number`接口现在将允许任何基于`int`和`float64`的类型：
- en: '[PRE15]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `constraints` package defines some useful constraints that can be used
    together with your generic code. This package contains numerical and ordered constraints
    that you might find useful. For example, we can modify the `sum` function to accept
    all signed integers by using this package:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constraints`包定义了一些有用的约束，可以与您的泛型代码一起使用。此包包含数值和有序约束，您可能会发现它们很有用。例如，我们可以通过使用此包修改`sum`函数以接受所有有符号整数：'
- en: '[PRE18]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Generics can be applied to functions and structs, allowing us to create generic
    data structures and reusable behaviors. This can streamline our code and remove
    the need to define code multiple times in order to accommodate different types
    of underlying data. In [*Chapter 10*](B18371_10.xhtml#_idTextAnchor218), *Testing
    Edge Cases*, we implemented a function that sorts map values based on key values:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型可以应用于函数和结构体，允许我们创建泛型数据结构和可重用的行为。这可以简化我们的代码，并消除为了适应不同类型的数据而多次定义代码的需要。在[*第10章*](B18371_10.xhtml#_idTextAnchor218)，*测试边缘情况*中，我们实现了一个根据键值对映射值进行排序的函数：
- en: '[PRE21]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This very useful function has a major limitation in that it only works for a
    single type of map with an `int` key and a `string` value – `map[int]string`.
    This limitation makes it difficult to reuse this code for other map types.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个非常有用的函数有一个主要限制，即它只适用于具有`int`键和`string`值的单一类型的映射`map[int]string`。这种限制使得很难将此代码用于其他映射类型。
- en: 'In the days before Go generics, we would have to create a function for each
    type of map:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go泛型出现之前的日子里，我们不得不为每种映射类型创建一个函数：
- en: '[PRE22]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since Go does not allow function overriding, we also need to use different names
    for the function taking different parameters. This can make it difficult to create
    libraries, even if we extract helper functions to help us reuse the implementation
    code inside the function.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Go不允许函数重写，我们还需要为接受不同参数的函数使用不同的名称。这可能会使创建库变得困难，即使我们提取辅助函数以帮助我们重用函数内部的实现代码。
- en: 'This is much simplified by generics, which allow us to parameterize the key
    and value types of the sort function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过泛型，我们可以简化这一点，泛型允许我们参数化排序函数的键和值类型：
- en: '[PRE23]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The signature of the function has been changed to leverage the power of generics
    to create a reusable function:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的签名已经更改，以利用泛型的力量创建可重用的函数：
- en: The function has two type parameters, one for the key type and one for the value
    type. The key value is restricted to any `int` type using the `~` keyword, while
    the value is opened to any type that complies using the `comparable` interface.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数有两个类型参数，一个用于键类型，一个用于值类型。键值被限制为任何`int`类型，使用`~`关键字，而值类型则通过`comparable`接口对任何符合的类型开放。
- en: The `map` parameter is declared using the key and value placeholder types, `map[K]V`.
    Only parameters that comply with the type constraints will be accepted by the
    function.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用键和值占位符类型`map[K]V`声明`map`参数。只有符合类型约束的参数才会被函数接受。
- en: The return value of the function is adjusted to return a slice of value types,
    `[]V`. This ensures that values returned are of the type as passed in by the input
    map.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的返回值调整为返回值类型的切片`[]V`，这确保返回的值与输入映射中传递的类型相同。
- en: Once we open up our functions to receive generic types, it is also important
    to apply meaningful constraints to ensure that our code continues to provide useful
    functionality. The function signature also serves as a user manual for callers,
    so we should continue to guide them, even though we are adding flexibility to
    our code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将函数开放以接收通用类型，同样重要的是应用有意义的约束以确保我们的代码继续提供有用的功能。函数签名也充当调用者的用户手册，因此我们应该继续引导他们，即使我们在代码中增加了灵活性。
- en: Table-driven testing revisited
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视基于表的测试
- en: Now that we understand the basics of implementing generic code, we can turn
    our attention to testing it. The adoption of generics throughout the Go community
    is still in its beginning stages. We have already established that generic code
    is statically enforced by the compiler, but does this increase in flexibility
    lead to more complex test code?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了实现泛型代码的基础，我们可以将注意力转向测试它。泛型在 Go 社区中的采用仍处于起步阶段。我们已经确定泛型代码是由编译器静态强制的，但这种灵活性增加是否会导致测试代码更加复杂？
- en: We can continue our exploration using the generic `GetSortedValues` function
    that we have implemented. Tests should now be written to assert the behavior of
    the function for a variety of input types and values. We can achieve this by using
    the table-driven testing technique that we explored in [*Chapter 4*](B18371_04.xhtml#_idTextAnchor085),
    *Building Efficient Test Suites*. The implementation of generic table-driven testing
    follows a series of steps.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们已实现的泛型 `GetSortedValues` 函数继续探索。现在应该编写测试用例来断言函数对各种输入类型和值的操作行为。我们可以通过使用我们在
    [*第4章*](B18371_04.xhtml#_idTextAnchor085) 中探索的表驱动测试技术来实现这一点，即 *构建高效的测试套件*。泛型表驱动测试的实现遵循一系列步骤。
- en: Step 1 – defining generic test cases
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1步 – 定义泛型测试用例
- en: 'We begin by creating a generic test case type to save our input map and values:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个泛型测试用例类型来保存我们的输入映射和值：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A generic test case allows us to construct an input map with the correct key
    and value type constraints, which are the same as we have used for the generic
    `GetSortedValues` function. We will use the input map as a parameter for the UUT.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型测试用例允许我们构建具有正确键和值类型约束的输入映射，这些约束与泛型 `GetSortedValues` 函数中使用的相同。我们将使用输入映射作为
    UUT 的参数。
- en: Step 2 – creating test cases
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2步 – 创建测试用例
- en: 'As we remember from our introduction to table-driven testing, we typically
    construct a map of test cases with the scenarios that we will be running our tests
    over. Due to the differences in type, we construct multiple test case maps:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从表驱动测试的介绍中记得，我们通常构建一个测试用例映射，其中包含我们将运行测试的场景。由于类型差异，我们构建多个测试用例映射：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, we create two maps with three scenarios each. The first `testCase`
    map has an `int` key type and a `string` value type. The second `testCase` map
    has an `int`-based custom type, `CustomI`. These are two possible combinations
    of key and value types. We can extend these types and scenario combinations as
    much as we want.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们创建了两个具有三个场景的映射。第一个 `testCase` 映射具有 `int` 键类型和 `string` 值类型。第二个 `testCase`
    映射具有基于 `int` 的自定义类型 `CustomI`。这是键和值类型的两种可能的组合。我们可以根据需要扩展这些类型和场景组合。
- en: Step 3 – implementing a generic test run function
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3步 – 实现泛型测试运行函数
- en: 'The next step required is to write a test helper function that contains all
    the logic for looping over the map of test cases and asserting the functionality
    of the `GetSortedValues` function. Usually, this functionality is contained inside
    the test body, but we will extract a function, as we have multiple input maps
    that we need to process:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步需要编写一个测试辅助函数，该函数包含遍历测试用例映射并断言 `GetSortedValues` 函数功能性的所有逻辑。通常，这种功能包含在测试体中，但我们将提取一个函数，因为我们需要处理多个输入映射：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `runTests` function has the following implementation:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`runTests` 函数具有以下实现：'
- en: 'The function signature takes two type parameters for the key and value types.
    They have the same type constraints as the test case type we have declared. It
    takes in two parameters: the `*testing.T` runner and the map of test cases, with
    the same key and value type parameters.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数签名接受两个类型参数，用于键和值类型。它们的类型约束与我们所声明的测试用例类型相同。它接受两个参数：`*testing.T` 运行器和测试用例的映射，具有相同的键和值类型参数。
- en: This function is marked as a helper using `t.Helper` so that it does not pollute
    test output.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此函数使用 `t.Helper` 标记为辅助函数，以便它不会污染测试输出。
- en: We loop over the map of test cases and run each in its own subtest using the
    `t.Run` function.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们遍历测试用例映射，并使用 `t.Run` 函数在各自的子测试中运行每个测试用例。
- en: The rest of the function body is the same as any test implementation. We invoke
    the function under test and assert the order of the elements.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数体的其余部分与任何测试实现相同。我们调用被测试的函数并断言元素的顺序。
- en: Step 4 – putting everything together
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4步 – 整合所有内容
- en: 'With all our building blocks in place, we can write our first generic test
    for the `GetSortedValues` function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有构建块就绪后，我们可以为 `GetSortedValues` 函数编写第一个泛型测试：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The test contains a subtest for each combination of key and value types. Inside
    the subtest, we create the map of test cases and invoke the `runTests` function
    with the correct parameters.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 测试包含针对键和值类型每个组合的子测试。在子测试内部，我们创建测试用例的映射，并使用正确的参数调用`runTests`函数。
- en: Step 5 – running the test
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5步 - 运行测试
- en: 'The last step is to run the test to see our generic code in action:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是运行测试以查看我们的泛型代码的实际效果：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The usage of subtests gives us structured output for our test run. We have also
    easily adapted table-driven testing to use generics to be able to test our `GetSortedValues`
    function with different types of input values.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 子测试的使用为我们提供了测试运行的有序输出。我们还轻松地将表驱动测试与泛型结合使用，以便能够使用不同类型的输入值测试我们的`GetSortedValues`函数。
- en: As we have seen from this simple example, the power of generics extends to test
    code. Another interesting use of generics is for creating test utilities. We will
    look at an example of this in the next section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从这个简单的例子中看到的，泛型的力量扩展到了测试代码。泛型另一个有趣的应用是创建测试工具。我们将在下一节中查看这个例子。
- en: Test utilities
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试工具
- en: The test assertion libraries we have been using so far, `testify` and `ginkgo`,
    were written before the introduction of Go generics. They use reflection to implement
    comparisons and assertions on variables. While this is a powerful tool, it can
    be difficult to use to write our own assertions and test utilities. The introduction
    of generics has made this process much easier, so we can easily create our own
    test utilities to reuse them in our tests.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止一直在使用的测试断言库`testify`和`ginkgo`是在Go泛型引入之前编写的。它们使用反射来实现变量上的比较和断言。虽然这是一个强大的工具，但可能很难用于编写我们自己的断言和测试工具。泛型的引入使这个过程变得容易得多，因此我们可以轻松创建自己的测试工具以在测试中重用它们。
- en: Reflection in a nutshell
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 反射概述
- en: Reflection is the ability of a program to analyze and manipulate program elements
    at runtime. This gives us the ability to inspect types, modify behavior, and test
    code. The Go standard library provides the `reflect` package, which provides functionality
    for implementing reflection.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 反射是程序在运行时分析和操作程序元素的能力。这使我们能够检查类型、修改行为和测试代码。Go标准库提供了`reflect`包，它提供了实现反射的功能。
- en: 'Continuing our example from `TestGetSortedValues` we wrote previously, we can
    streamline our `runTests` helper by extracting a test utility that we can use
    in other tests. We can easily create our own generic test helper for asserting
    that the order of our keys and values is as expected:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们之前编写的`TestGetSortedValues`示例，我们可以通过提取一个可以在其他测试中使用的测试工具来简化我们的`runTests`辅助函数。我们可以轻松创建自己的泛型测试辅助函数，以断言我们的键和值的顺序符合预期：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We extract the code and use two type parameters for the key and value type.
    We use the same technique as writing our `runTests` helper, but extract only the
    code that asserts on map value ordering. This test helper still takes the test
    runner `*testing.T` as a parameter, allowing it to fail tests in the case that
    the assertions inside it fail.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提取代码，并为键和值类型使用两个类型参数。我们使用与编写我们的`runTests`辅助函数相同的技巧，但只提取断言映射值排序的代码。这个测试辅助函数仍然将测试运行器`*testing.T`作为参数，允许它在内部断言失败时使测试失败。
- en: In the absence of generics, we would have to use the empty interface, `interface{}`,
    to allow our test to take in a variety of parameters. This does not allow us to
    write type-safe code, so writing helpers is more difficult and error-prone.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有泛型的情况下，我们必须使用空接口`interface{}`来允许我们的测试接受各种参数。这不允许我们编写类型安全的代码，因此编写辅助函数更困难且容易出错。
- en: Generics can help us streamline our application and test code. As we have seen
    in this section, we can use it to extend the technique of table-driven testing
    to allow us to write tests that cover a variety of input types and scenarios.
    We have also seen how generics can be used to create our own test utilities.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型可以帮助我们简化应用程序和测试代码。如本节所示，我们可以使用它来扩展表驱动测试技术，以便我们可以编写覆盖各种输入类型和场景的测试。我们还看到了泛型如何用于创建我们自己的测试工具。
- en: Extending the BookSwap application with generics
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用泛型扩展BookSwap应用程序
- en: So far, we have seen how to write a generic function and use generics to write
    easier test utilities. This has already proven to be a very powerful mechanism,
    providing us with both flexibility and type safety, something which cannot be
    achieved by an empty interface. In this section, we will learn how to make use
    of generics in our example REST API, the `BookSwap` application.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何编写泛型函数以及如何使用泛型编写更简单的测试工具。这已经证明是一个非常强大的机制，为我们提供了灵活性和类型安全，这是空接口无法实现的。在本节中，我们将学习如何在我们的示例
    REST API，即 `BookSwap` 应用程序中，使用泛型。
- en: 'Let us suppose that the `BookSwap` application wants to extend its business
    model and begin swapping magazines, alongside its regular books business model.
    *Figure 11**.3* presents the new system diagram for the application:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `BookSwap` 应用程序想要扩展其商业模式，并开始交换杂志，同时保持其常规的书籍业务模型。*图 11.3* 展示了应用程序的新系统图：
- en: '![Figure 11.3 – The extended BookSwap application ](img/Figure_11.3_B18371.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – 扩展的 BookSwap 应用程序](img/Figure_11.3_B18371.jpg)'
- en: Figure 11.3 – The extended BookSwap application
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 扩展的 BookSwap 应用程序
- en: 'The preceding example considers the `BookSwap` application’s monolithic architecture,
    but the same kind of considerations would apply to microservices architectures
    as well. Changes would have to be made throughout the application to support a
    new model, starting from the database level:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例考虑了 `BookSwap` 应用程序的单一架构，但类似的考虑也适用于微服务架构。为了支持新的模型，需要对应用程序进行全面的更改，从数据库级别开始：
- en: A `Magazines` database table will be created. Just like the `Books` table, it
    will have a foreign key dependency on the `Users` primary key, `id`.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将创建一个 `Magazines` 数据库表。就像 `Books` 表一样，它将依赖于 `Users` 主键 `id` 的外键。
- en: '`MagazineService` will be created to interact with the database queries. Just
    like `BookService`, it will support upsert, list, and swap operations.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将创建 `MagazineService` 以与数据库查询交互。就像 `BookService` 一样，它将支持插入、列表和交换操作。
- en: '`UserService` will have a dependency on `MagazineService`, allowing it to perform
    operations on this service and send information onward to the user.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserService` 将依赖于 `MagazineService`，允许它执行对该服务的操作并将信息发送给用户。'
- en: '`PostingService` will need to handle both `Magazine` and `Book` when they are
    successfully swapped. Since this service is external, we can assume that this
    information will be transferred through an HTTP request.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PostingService` 需要处理在成功交换后出现的 `Magazine` 和 `Book`。由于这个服务是外部的，我们可以假设这些信息将通过
    HTTP 请求进行传输。'
- en: 'Some of these changes do require dedicated code since we wouldn’t want to make
    magazines and books too tightly coupled. One example of where we might leverage
    generics is during the construction of the HTTP response. So far, `Response` has
    consisted of only the `Books` items:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些更改确实需要专门的代码，因为我们不希望杂志和书籍过于紧密地耦合。一个可能利用泛型的例子是在构建 HTTP 响应的过程中。到目前为止，`Response`
    只包含 `Books` 项目：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We populate the `Books` slice with the books returned from `BookService`. We
    now need to extend the `Response` struct to be able to handle `Magazines` as well.
    `Response` is a widely used type, so it would be a good candidate for a generic
    implementation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用从 `BookService` 返回的书籍填充 `Books` 切片。现在我们需要扩展 `Response` 结构体，以便能够处理 `Magazines`。`Response`
    是一个广泛使用的类型，因此它是一个很好的泛型实现候选。
- en: 'We create a `ResponseItemType` custom constraint, which contains a set of the
    `db.Book` and `db.Magazine` types:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个 `ResponseItemType` 自定义约束，其中包含了一组 `db.Book` 和 `db.Magazine` 类型：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If more types are added, then we can add them to this custom type constraint
    and use them throughout the application.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果添加更多类型，则可以将它们添加到这个自定义类型约束中，并在整个应用程序中使用它们。
- en: 'Next, we use `ResponseItemType` as the type parameter of `Response`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `ResponseItemType` 作为 `Response` 的类型参数：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We use the placeholder, `T`, as the type of the response, which is then used
    as the type of the `Items` slice. The `Items` slice is now able to contain both
    the `db.Book` and `db.Magazine` types. All other functions that interact with
    `Response` will now also need to handle the generic `Response`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用占位符 `T` 作为响应的类型，然后将其用作 `Items` 切片的类型。现在 `Items` 切片能够包含 `db.Book` 和 `db.Magazine`
    类型。现在所有与 `Response` 交互的其他函数也需要处理泛型 `Response`。
- en: 'We add the same type parameter to the `writeResponse` function, which is responsible
    for populating data in `Response`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将相同的类型参数添加到 `writeResponse` 函数中，该函数负责在 `Response` 中填充数据：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The generic function simply passes the type to the response and no other changes
    are required for the implementation logic. The type either needs to be supplied
    or sent through as a placeholder.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型函数只是将类型传递给响应，实现逻辑不需要进行其他更改。类型要么需要提供，要么作为占位符发送。
- en: 'On the calling side, we also need to handle the generic aspects. Each handler
    makes use of the `writeResponse` function to populate data on `Response` and return
    it to the client. The `ListBooks` handler demonstrates how to handle this on the
    calling side:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用端，我们还需要处理泛型方面。每个处理程序都使用`writeResponse`函数在`Response`上填充数据，并将其返回给客户端。`ListBooks`处理程序演示了如何在调用端处理这种情况：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The handlers responsible for books will handle response writing in a similar
    way. We pass the `db.Book` type to `Response` and invoke the `writeResponse` function.
    We do not need to pass a type argument to this function, as the type can be inferred
    from the invocation on the `Response` parameter. In the case of an error, we write
    the error to `Response` and return it, stopping execution. In the happy path case,
    we write the books to the `Items` slice.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 负责书籍的处理程序将以类似的方式处理响应编写。我们将`db.Book`类型传递给`Response`并调用`writeResponse`函数。我们不需要向此函数传递类型参数，因为类型可以从对`Response`参数的调用中推断出来。在出错的情况下，我们将错误写入`Response`并返回它，停止执行。在愉快的路径情况下，我们将书籍写入`Items`切片。
- en: The `Magazine` handlers will be implemented in the same way using the `db.Magazine`
    type instead. We can use the same table-testing technique we have explored in
    previous sections for testing our response logic.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Magazine`处理程序将以相同的方式实现，使用`db.Magazine`类型代替。我们可以使用我们在前面章节中探索的相同表格测试技术来测试我们的响应逻辑。'
- en: This brings us to the end of our exploration with generic code in Go. This powerful
    tool allows us to write flexible code, which can be used with different data types.
    When it comes to generic code, we should always keep in mind that it needs to
    be tested against different types of input parameters, not just different values.
    This can make testing more complicated, but we can still easily modify the popular
    technique of table-driven testing to test generic code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们结束了对Go中泛型代码的探索。这个强大的工具允许我们编写灵活的代码，可以用于不同的数据类型。当涉及到泛型代码时，我们应始终牢记，它需要针对不同类型的输入参数进行测试，而不仅仅是不同的值。这可能会使测试更加复杂，但我们仍然可以轻松地修改流行的表格驱动测试技术来测试泛型代码。
- en: Testing best practices
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试最佳实践
- en: This brings us to the end of this chapter and the end of our exploration of
    Go with TDD. We have had an amazing journey, having studied many libraries and
    techniques and applied them to our `BookSwap` application, as well as smaller
    examples. In this final section, we will recap the lessons learned and formulate
    some testing best practices.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们到达了本章的结尾，也是我们使用TDD探索Go语言的终点。我们经历了一段精彩的旅程，研究了众多库和技术，并将它们应用于我们的`BookSwap`应用程序以及一些小示例。在本节的最后，我们将回顾所学到的课程，并制定一些测试最佳实践。
- en: 'Achieving a comprehensive testing strategy requires constant effort and a cultural
    shift within an organization to embrace quality and prioritize testing. *Figure
    11**.4* presents a summary of some of the best practices we have explored divided
    into three different categories:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 实现全面的测试策略需要持续的努力，以及组织内部的文化转变，以拥抱质量和优先考虑测试。*图11.4*展示了我们探索的一些最佳实践的总结，分为三个不同的类别：
- en: '![Figure 11.4 – Development, testing, and culture best practices ](img/Figure_11.4_B18371.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图11.4 – 开发、测试和文化最佳实践](img/Figure_11.4_B18371.jpg)'
- en: Figure 11.4 – Development, testing, and culture best practices
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 – 开发、测试和文化最佳实践
- en: We have discussed 14 best practices throughout this book, which have been divided
    into 3 categories – development, testing, and culture.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们讨论了14项最佳实践，这些实践被分为3个类别——开发、测试和文化。
- en: Development best practices
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发最佳实践
- en: 'Here are some best practices for development (as seen in *Figure 11**.4*):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些开发最佳实践（如图*11.4*所示）：
- en: '**Use TDD to write tests during the development process**: The best way to
    ensure that the code we write is tested is to include it in the development process.
    Code is never delivered untested and developers write testable, well-designed
    code.'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用TDD在开发过程中编写测试**：确保我们编写的代码经过测试的最佳方式是将测试纳入开发过程。代码永远不会在没有测试的情况下交付，开发者编写可测试且设计良好的代码。'
- en: '**Use interfaces to wrap dependencies**: Our code will often have dependencies
    on other components. It is a good practice to have dependencies external to our
    package wrapped by interfaces so that they can be easily replaced, either by test
    code or with another dependency. We have explored dependencies and interfaces
    in [*Chapter 3*](B18371_03.xhtml#_idTextAnchor061), *Mocking and* *Assertion Frameworks*.'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用接口封装依赖项**：我们的代码通常会依赖于其他组件。将依赖项封装在接口中是一种良好的实践，这样它们就可以很容易地被替换，无论是通过测试代码还是通过另一个依赖项。我们在[*第3章*](B18371_03.xhtml#_idTextAnchor061)，*模拟和断言框架*中探讨了依赖项和接口。'
- en: '**Refactor code to tackle technical debt**: Code should be refactored alongside
    new feature development to ensure that it stays performant, readable, and easy
    to maintain. We explored some refactoring techniques in [*Chapter 7*](B18371_07.xhtml#_idTextAnchor162),
    *Refactoring in Go*. Tests will ensure that no functionality is broken by the
    refactoring process.'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重构代码以解决技术债务**：代码应该与新功能开发同时重构，以确保其保持性能、可读性和易于维护。我们在[*第7章*](B18371_07.xhtml#_idTextAnchor162)，*Go中的重构*中探讨了某些重构技术。测试将确保重构过程没有破坏任何功能。'
- en: '**Write robust code that is able to handle a variety of inputs**: We discussed
    what code robustness is in [*Chapter 10*](B18371_10.xhtml#_idTextAnchor218), *Testing
    Edge Cases*. It should be able to handle a wide variety of inputs and respond
    with well-formulated errors.'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编写能够处理各种输入的健壮代码**：我们在[*第10章*](B18371_10.xhtml#_idTextAnchor218)，*测试边缘情况*中讨论了代码健壮性的概念。它应该能够处理各种输入并返回精心设计的错误。'
- en: '**Adopt generics for easier code reuse**: As we have seen in this chapter,
    generics allow us to write code that is able to handle different data inputs.
    This allows us to use reusable code, which works for a variety of type parameters.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**采用泛型以实现代码重用**：正如我们在本章中看到的，泛型允许我们编写能够处理不同数据输入的代码。这使我们能够使用适用于各种类型参数的可重用代码。'
- en: Testing best practices
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试最佳实践
- en: 'Here are some best practices for testing (as seen in *Figure 11**.4*):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是测试的一些最佳实践（如图*图11*.4所示）：
- en: '**Write simple, isolated tests**: Tests should be simple and isolated from
    their dependencies. This allows us to avoid setting up a large number of services,
    which can be cumbersome and are likely to change. Instead, we should write focused
    tests that make use of mocks to test the UUT in isolation. We explored mocks and
    dependencies in [*Chapter 3*](B18371_03.xhtml#_idTextAnchor061), *Mocking and*
    *Assertion Frameworks*.'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编写简单、独立的测试**：测试应该是简单且与它们的依赖项隔离的。这使我们能够避免设置大量服务，这些服务可能很繁琐并且可能发生变化。相反，我们应该编写专注于使用模拟来独立测试UUT的测试。我们在[*第3章*](B18371_03.xhtml#_idTextAnchor061)，*模拟和断言框架*中探讨了模拟和依赖项。'
- en: '**Use table-driven tests to cover a variety of scenarios**: The popular technique
    of writing table-driven testing is to easily create a list of test cases and run
    through them. Test cases should be run in their own subtests to create a well-structured
    test output. We explored this technique in [*Chapter 4*](B18371_04.xhtml#_idTextAnchor085),
    *Building Efficient Test Suites*, as well as this chapter.'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用表驱动测试覆盖各种场景**：编写表驱动测试的流行技术是轻松创建测试用例列表并运行它们。测试用例应在自己的子测试中运行，以创建结构良好的测试输出。我们在[*第4章*](B18371_04.xhtml#_idTextAnchor085)，*构建高效的测试套件*以及本章中探讨了这种技术。'
- en: '**Write tests at every level of the application**: Unit tests are fast, but
    they only assert that the functionality of a given package is correct, not that
    it is able to function correctly with other units. As depicted by the testing
    pyramid presented in [*Chapter 1*](B18371_01.xhtml#_idTextAnchor015), *Getting
    to Grips with Test-Driven Development*, we should write automated tests that assert
    that the individual units of the application integrate and function correctly
    together.'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在应用程序的每个级别编写测试**：单元测试速度快，但它们只能断言给定包的功能是正确的，而不能断言它能够与其他单元正确地一起工作。正如[*第1章*](B18371_01.xhtml#_idTextAnchor015)，*掌握测试驱动开发*中展示的测试金字塔所示，我们应该编写断言应用程序各个单元能够集成并正确一起工作的自动化测试。'
- en: '`testing` package offers a wide variety of functionality that allows us to
    write functional and non-functional tests. We have explored the capabilities of
    this package throughout this book.'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`testing`包提供了广泛的功能，使我们能够编写功能性和非功能性测试。我们在这本书中探讨了该包的整个功能。'
- en: '`testify`, `ginkgo`, and `godog`) that complement the standard `testing` package
    and make it easier for us to write test assertions and create mocks.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`testify`、`ginkgo`和`godog`等工具与标准`testing`包相辅相成，使我们能够更容易地编写测试断言和创建模拟。'
- en: Culture best practices
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文化最佳实践
- en: 'Here are some best practices for culture (as seen in *Figure 11**.4*):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于文化的最佳实践（如图11.4所示）：
- en: '**Document customer requirements**: User journeys and customer requirements
    should be at the heart of all the tests we write. As it is nearly impossible to
    write tests that cover every single code path and interaction, engineers should
    ensure that the things that matter to customers are prioritized and covered by
    tests.'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**记录客户需求**：用户旅程和客户需求应该是我们编写的所有测试的核心。由于几乎不可能编写覆盖每个单独代码路径和交互的测试，工程师应确保客户关心的事项被优先考虑并由测试覆盖。'
- en: '**Mitigate for errors and unexpected outages**: In microservices architectures,
    it is nearly impossible to ensure that there are zero outages. We should contract-test
    our services, as well as design our microservices architectures according to the
    best practices described in [*Chapter 8*](B18371_08.xhtml#_idTextAnchor179), *Testing
    Microservice Architectures*.'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**减轻错误和意外中断的影响**：在微服务架构中，几乎不可能确保零中断。我们应该对服务进行合同测试，并根据第8章中描述的最佳实践设计我们的微服务架构，该章节为*测试微服务架构*。'
- en: '**Value and prioritize code quality**: As an organization, you should value
    and prioritize code quality, allowing the engineering teams time to refactor their
    services to ensure they can be easily extended and maintained for the future needs
    of the business.'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重视并优先考虑代码质量**：作为一个组织，您应该重视并优先考虑代码质量，让工程团队能够有时间重构他们的服务，以确保它们可以轻松扩展和维护以满足未来的业务需求。'
- en: '**Document non-functional requirements**: While one important use of tests
    is to ensure that our system is able to satisfy functional requirements, another
    important aspect is to verify the performance of our system according to the needs
    of the customers. We explored how to test the performance of our code using benchmarks
    in [*Chapter 2*](B18371_02.xhtml#_idTextAnchor035), *Unit Testing Essentials*.'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**记录非功能性需求**：虽然测试的一个重要用途是确保我们的系统能够满足功能性需求，但另一个重要方面是根据客户的需求验证系统的性能。我们在第2章中探讨了如何使用基准测试来测试代码的性能，该章节为*单元测试基础*。'
- en: The final aspect to remember is that no testing strategy is perfect, as it cannot
    cover every single code path and edge case. The tools and techniques we have explored
    throughout this book should help you plan and implement the efficient testing
    of your system. There is no “one-size-fits-all” approach to a testing strategy,
    so make sure that you work with your product manager and other key business stakeholders
    to ensure that your testing efforts are made efficiently.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的最后一个方面是，没有测试策略是完美的，因为它无法覆盖每个单独的代码路径和边缘情况。本书中探讨的工具和技术应有助于您计划和实施系统的高效测试。没有“一刀切”的测试策略，因此请确保您与产品经理和其他关键业务利益相关者合作，以确保您的测试工作高效完成。
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we spent time exploring Go’s newly introduced generics support.
    We learned the basic syntax for implementing generic code, including how to specify
    type constraints. We also looked at a quick comparison of generic code versus
    writing code using interfaces.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们花费时间探索了Go语言新引入的泛型支持。我们学习了实现泛型代码的基本语法，包括如何指定类型约束。我们还比较了泛型代码与使用接口编写代码的快速对比。
- en: Then, we revisited the previously introduced technique of table-driven testing
    and learned how to modify it to support generic code, allowing us to write test
    cases that support different input types and values. We also learned how to make
    use of generics to easily write our own test utilities, promoting code reuse in
    test code as well as implementation code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们回顾了之前介绍的技术——表格驱动测试，并学习了如何修改它以支持泛型代码，使我们能够编写支持不同输入类型和值的测试用例。我们还学习了如何利用泛型轻松编写我们自己的测试工具，促进测试代码以及实现代码中的代码重用。
- en: 'Finally, we summarized all of the tools and techniques we have explored throughout
    this book with 14 best practices divided into 3 categories: development, testing,
    and culture. Implementing and maintaining a comprehensive testing strategy requires
    effort throughout the entire product and engineering organization.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们总结了本书中探索的所有工具和技术，通过14项最佳实践分为3个类别：开发、测试和文化。实施和维护全面的测试策略需要整个产品和工程组织在整个过程中的努力。
- en: Questions
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is generics?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是泛型？
- en: What are the main components of Go generics?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Go泛型的主要组件是什么？
- en: Describe the steps involved in writing generic table-driven testing.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述编写泛型表驱动测试的步骤。
- en: Further reading
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Generic Data Structures and Algorithms in Go: An Applied Approach Using Concurrency,
    Genericity and Heuristics*, by Richard Wiener, published by Apress'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Go中的泛型数据结构和算法：使用并发、泛型和启发式方法的应用方法》*，作者理查德·维纳，由Apress出版'
- en: '*Cloud Native Go: Building Reliable Services in Unreliable Environments*, by
    Matthew Titmus, published by O’Reilly'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《云原生Go：在不可靠环境中构建可靠服务》*，作者马修·蒂特姆斯，由O''Reilly出版'
- en: Assessments
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Chapter 1, Getting to Grips with Test-Driven Development
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章，掌握测试驱动开发
- en: The testing pyramid specifies how automated test suites should be structured.
    At the bottom of the pyramid are unit tests, which test a single isolated component.
    Next up in the middle of the pyramid are integration tests, which test that multiple
    components are able to work together as specified. Finally, at the top of the
    test pyramid are end-to-end tests that test the behavior of the entire application.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试金字塔指定了自动化测试套件的构建方式。金字塔的底部是单元测试，它测试单个隔离的组件。接下来在金字塔的中间是集成测试，它测试多个组件能否按照指定的方式一起工作。最后，在测试金字塔的顶部是端到端测试，它测试整个应用程序的行为。
- en: Functional tests cover the correctness of a system, while non-functional tests
    cover the usability and performance of a system. Both types of tests are required
    to ensure that the system satisfies the customers’ needs.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 功能测试覆盖了系统的正确性，而非功能测试覆盖了系统的可用性和性能。这两种类型的测试都是必需的，以确保系统能满足客户的需求。
- en: The red, green, and refactor TDD approach refers to the three phases of the
    process. The red phase involves writing a new failing test for the functionality
    we intend to implement. The green phase involves writing enough implementation
    code to make all tests pass. Finally, the refactor phase involves optimizing both
    implementation and testing code to remove duplication and come up with better
    solutions.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 红色、绿色和重构TDD方法指的是过程的三个阶段。红色阶段涉及为我们要实现的功能编写一个新的失败的测试。绿色阶段涉及编写足够的实现代码，使所有测试通过。最后，重构阶段涉及优化实现和测试代码，以消除重复并找到更好的解决方案。
- en: Acceptance test-driven development. Just like TDD, ATDD puts tests first. ATDD
    is related to TDD, but it involves writing a suite of acceptance tests before
    the implementation begins. It involves multiple stakeholders to ensure that the
    acceptance test captures the customer’s requirements.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受测试驱动开发。就像TDD一样，ATDD将测试放在首位。ATDD与TDD相关，但在实施开始之前，它涉及编写一系列接受测试。它涉及多个利益相关者，以确保接受测试能够捕捉到客户的需求。
- en: Code coverage is the percentage of your lines of code that are exercised by
    your unit test. This is calculated by considering the function statements, parameter
    values, and execution paths of your code. The Go test runner outputs the calculated
    code coverage. We should aim for a good value, but optimizing for 100% is normally
    not appropriate.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码覆盖率是您的单元测试执行的代码行数的百分比。这是通过考虑您的代码的功能语句、参数值和执行路径来计算的。Go测试运行器输出计算出的代码覆盖率。我们应该追求一个好的值，但优化到100%通常是不合适的。
- en: Chapter 2, Unit Testing Essentials
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章，单元测试基础
- en: In Go, a module is a collection of packages that should be built and released
    together. A package is a collection of Go files that must be built together. A
    module is specified by a `go.mod` file, while a package is specified by the package
    declaration at the top of the source file.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Go中，一个模块是一组应该一起构建和发布的包。一个包是一组必须一起构建的Go文件。模块由`go.mod`文件指定，而包由源文件顶部的包声明指定。
- en: The additional test package is a package that matches the name of the source
    package with the `_test` suffix added. The additional test package provides isolation
    between test code and source code, preventing brittle tests and allowing developers
    to see the integrations with their packages.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 额外的测试包是与源包名称匹配并添加了 `_test` 后缀的包。额外的测试包在测试代码和源代码之间提供隔离，防止脆弱的测试，并允许开发者查看他们包的集成情况。
- en: 'Test signatures have only a few requirements:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试签名只有几个要求：
- en: The test name must begin with the word `Test`
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试名称必须以单词 `Test` 开头
- en: Any other name that follows the `Test` must also be capitalized
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何跟随 `Test` 的其他名称也必须首字母大写
- en: There must only be one parameter of the `*testing.T` type and no return type
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须只有一个 `*testing.T` 类型的参数，并且没有返回类型
- en: Subtests are tests that run within an enclosing test. They are created by passing
    a name and corresponding function to the `t.Run` method on the enclosing test.
    A failure in a subtest will cause the failure of the enclosing test as well.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子测试是在封装测试中运行的测试。它们通过将名称和相应的函数传递给封装测试上的 `t.Run` 方法来创建。子测试中的失败将导致封装测试的失败。
- en: Benchmarks are a way to measure the performance of our code. Go’s test runner
    will repeatedly run the instrumented function until it finds stable measurements
    for the performance of the benchmarked function.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基准测试是衡量我们代码性能的一种方法。Go 的测试运行器会重复运行被测函数，直到找到基准函数性能的稳定测量值。
- en: Chapter 3, Mocking and Assertion Frameworks
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章，模拟和断言框架
- en: The code examples included in this book are publicly available at [https://github.com/PacktPublishing/Test-Driven-Development-in-Go](https://github.com/PacktPublishing/Test-Driven-Development-in-Go).
    You can find the implemented
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 本书包含的代码示例在 [https://github.com/PacktPublishing/Test-Driven-Development-in-Go](https://github.com/PacktPublishing/Test-Driven-Development-in-Go)
    上公开可用。您可以找到已实现的
- en: solution from the Question section in the `chapter03-solution` directory.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 `chapter03-solution` 目录中问题部分的解决方案。
- en: Chapter 4, Building Efficient Test Suites
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章，构建高效的测试套件
- en: An edge case is a test case that occurs at extreme values of an operating parameter.
    A corner case occurs at the extreme values of multiple operating parameters. As
    corner cases occur when multiple edge cases occur, they are much less likely to
    occur than edge cases.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 边界情况是在操作参数的极端值处发生的测试案例。角落情况发生在多个操作参数的极端值处。由于角落情况发生在多个边界情况发生时，它们的发生概率比边界情况要低得多。
- en: An idempotent operation is an operation that can be repeated multiple times
    without changing the initial result. These operations are predominant in API design,
    which can often involve retries and resending requests due to network conditions.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 幂等操作是可以重复多次而不改变初始结果的操作。这些操作在 API 设计中很普遍，由于网络条件，它们经常涉及重试和重新发送请求。
- en: In Go, error handling is done using the built-in `error` type. Errors are handled
    as part of regular code flow, where errors are handled just like any other return
    value, most often alongside other values using multiple return values.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Go 语言中，错误处理是通过内置的 `error` 类型来完成的。错误被当作常规代码流程的一部分来处理，就像处理任何其他返回值一样，通常与其他值一起使用多个返回值来处理。
- en: Table-driven testing is a popular technique that allows us to test multiple
    scenarios in a unified way, which reduces code duplication. Custom types are created,
    which represent the inputs and expected outputs of the particular test scenario.
    These are then saved in a test collection. The test collection is run over, with
    each case being identically executed.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表驱动测试是一种流行的技术，它允许我们以统一的方式测试多个场景，从而减少代码重复。创建自定义类型来表示特定测试场景的输入和预期输出。然后，它们被保存在测试集合中。测试集合会被运行，每个案例都会被相同地执行。
- en: By default, Go tests in different packages are run in parallel. Test cases within
    a package can be marked to be run in parallel using the `t.Parallel()` method
    of the `*testing.T` instance. This allows tests that are marked accordingly to
    be run in parallel.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，不同包中的 Go 测试是并行运行的。可以使用 `*testing.T` 实例的 `t.Parallel()` 方法标记包内的测试案例以并行运行。这允许相应标记的测试并行运行。
- en: Chapter 5, Performing Integration Testing
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章，执行集成测试
- en: Integration tests cover multiple units of the system, ensuring that they work
    well together. End-to-end tests replicate user behavior on the system as a whole.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集成测试覆盖了系统的多个单元，确保它们能够良好地协同工作。端到端测试则在整个系统上复制用户行为。
- en: BDD is a branch of TDD that focuses on writing human-readable tests and involve
    a variety of stakeholders from across the business. The most important part of
    BDD is establishing a common vocabulary that is shared across the business.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BDD是TDD的一个分支，它侧重于编写人类可读的测试，并涉及来自整个业务的各种利益相关者。BDD最重要的部分是建立一个在业务中共享的通用词汇。
- en: No, it is considered an anti-pattern to mock databases. They are complex systems
    that are difficult to mock and replicate. In general, tests should use the same
    database as in production.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不，模拟数据库被认为是一种反模式。它们是复杂系统，难以模拟和复制。一般来说，测试应该使用与生产环境中相同的数据库。
- en: A container is a unit of software and all its dependencies, specified by a container
    image. Docker Engine starts up and manages containers on top of the operating
    system.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器是软件及其依赖项的单元，由容器镜像指定。Docker Engine在操作系统之上启动和管理容器。
- en: Chapter 6, End-to-End Testing the BookSwap Web Application
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章，BookSwap Web应用程序的端到端测试
- en: A user journey is a path that a user may take to achieve their goal while using
    a given application. Identifying user journeys allows us to write E2E tests that
    correctly replicate and verify the user experience on our platform.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户旅程是在使用给定应用程序时用户可能采取以实现其目标的一条路径。识别用户旅程允许我们编写端到端测试，以正确复制和验证我们平台上的用户体验。
- en: ORM stands for object-relational mapping and is a technique that allows us to
    bridge the gap between object-oriented languages and relational databases. It
    allows developers to interact with the database types as just any other custom
    type.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ORM代表对象关系映射，是一种允许我们弥合面向对象语言和关系数据库之间差距的技术。它允许开发者像与其他任何自定义类型一样与数据库类型交互。
- en: Docker Compose allows us to easily define and network multi-container applications.
    Dockerfiles define the steps to building a single container image, while Docker
    Compose allows us to define services with a single configuration and command.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker Compose允许我们轻松定义和配置多容器应用的网络。Dockerfile定义了构建单个容器镜像的步骤，而Docker Compose允许我们使用单个配置和命令定义服务。
- en: Database seeding involves adding initial data to a database. Often, this dummy
    data is generated and changes between test runs.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库初始化涉及向数据库添加初始数据。通常，这些虚拟数据在测试运行之间生成和更改。
- en: Chapter 7, Refactoring in Go
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章，Go语言中的重构
- en: Code redesign involves changing the functionality of an existing service, while
    code refactoring involves changing the internal structure of an existing service,
    without changing its existing functionality. Code redesign changes the *what*,
    while code refactoring changes the *how*. If done correctly, code refactoring
    will not be visible outside the refactored code scope.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码重构涉及改变现有服务的功能，而代码重构则涉及改变现有服务的内部结构，而不改变其现有功能。代码重构改变的是*什么*，而代码重构改变的是*如何*。如果做得正确，代码重构将不会在重构代码范围之外可见。
- en: The developer starts by identifying the change they wish to make. Then, they
    modify their implementation or test code. Once this is done and the code compiles,
    they then run their test suite. If the suite is passing, the code refactor has
    been successful. However, if the suite is not passing, the developer revisits
    their code change, adjusting it together with the test code until the test suite
    is passing. No change is released until the test suite successfully verifies the
    change.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发者首先确定他们希望做出的更改。然后，他们修改他们的实现或测试代码。一旦完成并编译代码，他们就会运行他们的测试套件。如果套件通过，则代码重构已成功。然而，如果套件未通过，开发者将重新审视他们的代码更改，并调整它与测试代码一起，直到测试套件通过。除非测试套件成功验证更改，否则不会发布任何更改。
- en: Technical debt is the term used to refer to code that has not been written to
    the technical team’s typical high standards of quality. It typically occurs when
    the team prioritizes speedy delivery over taking the time to design a high-quality
    solution.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 技术债务是指未按照技术团队典型的高质量标准编写的代码。它通常发生在团队优先考虑快速交付而不是花时间设计高质量解决方案时。
- en: A monolithic application is a single application that is built and released
    as a single unit. A microservice architecture is a system design pattern that
    involves building independently built and released units. Organizations typically
    start with monolithic applications and then move to microservice architectures
    as needed.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单体应用是一个构建和发布为一个单一单元的单个应用。微服务架构是一种系统设计模式，涉及构建独立构建和发布的单元。组织通常从单体应用开始，然后根据需要转向微服务架构。
- en: Chapter 8, Testing Microservice Architectures
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章，测试微服务架构
- en: Functional testing ensures that the features of the system work correctly. Non-functional
    testing verifies that other aspects of the system behave as expected. The two
    main types of non-functional testing are performance tests and usability tests.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 功能测试确保系统的功能正确工作。非功能测试验证系统的其他方面是否按预期行为。两种主要类型的非功能测试是性能测试和可用性测试。
- en: Performance testing relies on key metrics to quantify and compare the performance
    of the application. Important key metrics to monitor are response time, error
    rate, concurrent users, data throughput, and CPU/memory usage.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 性能测试依赖于关键指标来量化并比较应用程序的性能。需要监控的重要关键指标包括响应时间、错误率、并发用户、数据吞吐量和CPU/内存使用率。
- en: Performance testing ensures that the system is scalable by measuring the performance
    of the individual parts of the system, allowing us to identify bottlenecks and
    improvements required. Furthermore, testing at higher loads of the system allows
    us to estimate the limits of what the system can handle, and helps us understand
    what the growth runway of the current system configuration is.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 性能测试通过测量系统的各个部分性能，确保系统可扩展性，从而帮助我们识别瓶颈和所需改进。此外，在系统更高负载下进行测试，可以让我们估计系统可以处理的最大极限，并帮助我们了解当前系统配置的增长空间。
- en: Microservice architectures provide scalability benefits because they allow the
    different parts of our system to be scaled independently. They also allow easier
    maintenance and provide increased delivery speed, as engineering teams can own
    and change their services without any central oversight. On the other hand, they
    introduce complexity in every part of the software life cycle
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微服务架构提供了可扩展性优势，因为它们允许我们独立扩展系统的不同部分。它们还允许更轻松的维护，并提高了交付速度，因为工程团队能够拥有并更改他们的服务，而无需任何中央监督。另一方面，它们在软件生命周期的每个部分都引入了复杂性。
- en: Development complexity as engineers need to structure multiple code bases, then
    implement and test features across multiple services.
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为工程师，需要结构化多个代码库，然后在多个服务中实现和测试功能，这使得开发复杂性增加。
- en: Deployment complexity as each service has its own infrastructure to be maintained.
    Automation of the release pipelines becomes essential in order to make it easy
    for engineers to release multiple services.
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署复杂性在于每个服务都有自己的基础设施需要维护。自动化发布管道变得至关重要，以便让工程师能够轻松地发布多个服务。
- en: Organizational complexity as engineers must handle increased ownership of multiple
    services. While teams are able to deliver features on multiple services without
    any central oversight, they must also communicate to establish common technical
    standards, suitable for a variety of microservices.
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组织复杂性在于工程师必须处理多个服务的增加所有权。虽然团队能够在没有中央监督的情况下在多个服务上交付功能，但他们也必须进行沟通，以建立适用于各种微服务的共同技术标准。
- en: Contract testing is a testing technique that allows us to reliably test the
    interaction between two services. The consumer initiates the exchange and sends
    the request, while the provider processes the request and sends back the response.
    The exchange is recorded in a contract on the consumer side. Then, the contract
    is verified on the provider side against the real implementation. One of the key
    advantages of contract testing is that it allows us to verify the integration
    between two services without having to run and maintain the test against real
    implementations of both the consumer and provider.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合同测试是一种测试技术，允许我们可靠地测试两个服务之间的交互。消费者启动交换并发送请求，而提供者处理请求并发送响应。交换在消费者端记录在合同中。然后，在提供者端，合同与实际实现进行验证。合同测试的一个关键优势是，它允许我们在不需要运行和维护消费者和提供者的实际实现测试的情况下，验证两个服务之间的集成。
- en: Chapter 9, Challenges of Testing Concurrent Code
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章，测试并发代码的挑战
- en: Concurrency refers to a program’s ability to execute more than one task, with
    interruptions and without any ordering guarantees. Parallelism refers to a program’s
    ability to execute more than one task, simultaneously and without interruptions.
    The OS (or even in silico implementations such as hyperthreading) may give the
    illusion of parallelism through pre-emptive multitasking. However, in order for
    parallelism to be truly simultaneous, multiple computational resources are required.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并发是指程序执行多个任务的能力，带有中断，并且没有任何顺序保证。并行性是指程序执行多个任务的能力，同时执行，并且没有中断。操作系统（甚至是在硅基实现中，如超线程）可能通过抢占式多任务处理来提供并行性的错觉。然而，为了使并行性真正同时发生，需要多个计算资源。
- en: Channels support three operations. The send operation writes information to
    the channel, while the receive operation reads information from the channel. The
    close operation signals to all receivers that no more values will be sent through
    it. Once closed, channels can never be reopened. For unbuffered channels, send
    and receive operations are synchronous and will only complete once both sender
    and receiver are available. On closed channels, sends will panic, while receives
    will immediately complete with the zero value of the channel’s data type.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Channels 支持三种操作。发送操作将信息写入通道，而接收操作从通道读取信息。关闭操作向所有接收者发出信号，表明不会通过它发送更多值。一旦关闭，通道将永远无法重新打开。对于无缓冲通道，发送和接收操作是同步的，并且只有在发送者和接收者都可用时才会完成。在关闭的通道上，发送将引发恐慌，而接收将立即以通道数据类型的零值完成。
- en: '`sync.Mutex` is a lock that exposes the `Lock` and `Unlock` methods. Goroutines
    will block until they can acquire the lock successfully. `sync.WaitGroup` is a
    specialized lock that maintains an inner counter that will block until the inner
    counter of `WaitGroup` reaches 0 by calling `Done` on `WaitGroup` the appropriate
    number of times. `sync.WaitGroup` allows us to wait for multiple goroutines to
    complete, in a simpler and more compact way than reading from channels or shared
    memory.'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sync.Mutex` 是一个暴露 `Lock` 和 `Unlock` 方法的锁。Goroutines 将会阻塞，直到它们成功获取锁。`sync.WaitGroup`
    是一种特殊的锁，它维护一个内部计数器，该计数器会阻塞，直到通过在 `WaitGroup` 上调用适当次数的 `Done` 方法，使内部计数器达到 0。`sync.WaitGroup`
    允许我们以比从通道或共享内存读取更简单、更紧凑的方式等待多个 goroutines 完成。'
- en: A data race occurs when multiple goroutines access and modify a shared resource.
    This can lead to inconsistent values and hard-to-detect bugs. A deadlock occurs
    when goroutines are blocked, waiting for a resource that never becomes available.
    If the whole program becomes blocked, the Go runtime will detect the deadlock
    and shut down the program.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当多个 goroutines 访问并修改共享资源时，会发生数据竞态。这可能导致不一致的值和难以检测的 bug。当 goroutines 被阻塞，等待永远不会变得可用的资源时，会发生死锁。如果整个程序被阻塞，Go
    运行时将检测到死锁并关闭程序。
- en: Go’s race detector is integrated into the `go` tool chain and is enabled with
    the `–race` command-line flag. It instruments memory access and reports when data
    races are detected. As it significantly increases the CPU and memory usage of
    the applications it instruments, the race detector should not be used in production.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Go 的竞态检测器集成到 `go` 工具链中，并通过 `–race` 命令行标志启用。它会对内存访问进行检测，并在检测到数据竞态时报告。由于它显著增加了它所检测的应用程序的
    CPU 和内存使用量，因此竞态检测器不应在生产环境中使用。
- en: Chapter 10, Testing Edge Cases
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章，测试边缘情况
- en: A robust system is one that continues to function correctly, even when supplied
    with unexpected or exceptional inputs. When errors or unexpected inputs occur,
    the system is able to handle them gracefully without panics and return meaningful
    errors. Robust code is readable, maintainable, and easy to test.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个健壮的系统是指即使在提供意外或异常输入的情况下也能继续正确运行的系统。当出现错误或意外输入时，系统能够优雅地处理它们，而不会引发恐慌，并返回有意义的错误。健壮的代码是可读的、可维护的，并且易于测试。
- en: Fuzz testing is a software testing technique that involves generating a large
    amount of random data, which is then passed to the fuzz target in an attempt to
    verify its behavior against a wide range of parameters. Fuzz testing makes it
    easier to uncover bugs by reducing the number of tests we need to write manually
    to cover edge cases of input variables.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模糊测试是一种软件测试技术，涉及生成大量随机数据，然后将这些数据传递给模糊目标，以验证其行为是否与广泛的参数相匹配。模糊测试通过减少我们需要手动编写的测试数量来覆盖输入变量的边缘情况，从而更容易地发现
    bug。
- en: A fuzzed test begins with the `Fuzz` prefix, takes in a single `*testing.F`
    parameter, and returns no values. Just like other tests, they must be defined
    inside `_test.go` files. They are run using the `go` `test` command.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模糊测试以`Fuzz`前缀开始，接受一个单独的`*testing.F`参数，并返回无值。就像其他测试一样，它们必须在`_test.go`文件中定义。它们使用`go
    test`命令运行。
- en: Property-based testing is a technique that involves the generation and verification
    of input values that satisfy a set of system properties or specifications. This
    allows us to test a wide variety of edge cases that are relevant to our system
    without the need to manually write and maintain a large number of tests.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于属性的测试是一种技术，它涉及生成和验证满足一组系统属性或规范的输入值。这使得我们能够在不手动编写和维护大量测试的情况下，测试与我们系统相关的各种边缘情况。
- en: From the viewpoint of the UUT, untrusted inputs are any values that the UUT
    receives or that it uses that it has not generated. These inputs can be good candidates
    for fuzzing arguments.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从被测单元（UUT）的角度来看，不受信任的输入是被测单元接收或使用但未生成的任何值。这些输入可以是模糊测试参数的良好候选者。
- en: Chapter 11, Working with Generics
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章，使用泛型
- en: Generics is the ability to write code that is able to be used with different
    data types without being limited to a single type. It is a powerful mechanism,
    supported by most programming languages, and allows us to write flexible, reusable
    code.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 泛型是编写能够与不同数据类型一起使用而无需限制为单一类型的代码的能力。这是一个强大的机制，被大多数编程语言所支持，并允许我们编写灵活、可重用的代码。
- en: 'The main components of Go generics are type parameters, type constraints, type
    arguments, and type inferences:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Go泛型的主要组件是类型参数、类型约束、类型参数和类型推断：
- en: Type parameters are the placeholder types that will be used in our generic code,
    typically denoted by a single letter.
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型参数是在我们的泛型代码中将使用的占位符类型，通常用一个字母表示。
- en: Type constraints restrict the types that can be used with our generic function
    or type.
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型约束限制了可以与我们的泛型函数或类型一起使用的类型。
- en: Type arguments are the types that are passed to the function upon invocation.
    They replace the type parameters and satisfy the type constraints.
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型参数是在调用函数时传递给函数的类型。它们替换了类型参数并满足类型约束。
- en: Type inference is the process that takes place under the hood to determine the
    type of a variable, without us needing to explicitly declare it. This makes generic
    code less verbose.
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型推断是在幕后进行的，用于确定变量的类型，而无需我们显式声明它。这使得泛型代码更加简洁。
- en: Testing generic code with table-driven tests will often involve writing test
    cases with different type parameters. To support this, we define generic test
    case types that can contain different input types. Then, a generic test run function
    that is able to run over the generic test cases and interact with the input types
    should be created. Test cases should be run in subtests, ensuring that test runs
    have a structured output.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用表格驱动测试测试泛型代码通常涉及编写具有不同类型参数的测试用例。为了支持这一点，我们定义了可以包含不同输入类型的泛型测试用例类型。然后，创建一个能够运行泛型测试用例并与输入类型交互的泛型测试运行函数。测试用例应在子测试中运行，以确保测试运行有结构化的输出。
