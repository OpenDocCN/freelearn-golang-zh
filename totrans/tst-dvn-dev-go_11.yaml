- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapters have covered all the aspects of testing and code design,
    gradually increasing in complexity. These tests will allow us to verify the behavior
    of a wide variety of applications, including microservices architectures and services
    that persist data to a database service. We have all the knowledge to perform
    the functional and non-functional testing of a variety of systems.
  prefs: []
  type: TYPE_NORMAL
- en: We have also discussed how systems need to change and evolve, as engineering
    organizations grow and new functionality is added. In [*Chapter 9*](B18371_09.xhtml#_idTextAnchor197),
    *Challenges of Testing Concurrent Code*, we discussed how to make the most of
    computing resources by making use of Go’s concurrency mechanisms, enabling us
    to serve production traffic. In [*Chapter 10*](B18371_10.xhtml#_idTextAnchor218),
    *Testing Edge Cases*, we explored two testing techniques to cover system edge
    cases, including Go’s fuzz testing capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Go’s `go test` toolset. Generics was a major, much-anticipated feature by the
    Go community. It allows us to write functions, types, and data structures that
    can work with any type, rather than being limited to one type when we declare
    them. A newly released language feature is another reason why we might change
    our code, alongside the maintenance and feature development processes we have
    discussed.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will explore the implementation and testing of generic code. We
    will begin by exploring how to write generic code, exploring both use cases and
    syntax. Then, we will explore how to test generic code, including where generics
    can be used to streamline our test code. Finally, we will reflect on all we have
    learned and summarize some of the testing best practices that we have explored
    throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of writing generic code in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing generic code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging generics for test utilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A summary of the testing best practices we have covered in this book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need to have **Go version 1.19** or later installed to run the code
    samples in this chapter. The installation process is described in the official
    Go documentation at [https://go.dev/doc/install](https://go.dev/doc/install).
  prefs: []
  type: TYPE_NORMAL
- en: The code examples included in this book are publicly available at [https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter11](https://github.com/PacktPublishing/Test-Driven-Development-in-Go/chapter11).
  prefs: []
  type: TYPE_NORMAL
- en: Writing generic code in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The introduction of generics in Go was a highly debated and anticipated feature.
    Some developers felt that introducing it would contradict Go’s core principles
    of simplicity, while others felt like it was a sign of maturity and would allow
    them to write better production code. As with every technical solution or design
    decision, there is a trade-off between the advantages and disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: As previously mentioned, **generics** refers to the ability to write code that
    works with different data types without being limited to a specific type. In the
    absence of generics, we have used Go interfaces to implement generic behavior
    in Go. In [*Chapter 3*](B18371_03.xhtml#_idTextAnchor061), *Mocking and Assertion
    Frameworks*, we explored the power of interfaces and have seen how they can be
    used for wrapping and replacing dependencies. While interfaces are not the same
    as generics, they provide a way to achieve similar goals of **flexibility** and
    **code reuse**.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11**.1* provides a comparison of generics and interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Comparison of generics and interfaces ](img/Figure_11.1_B18371.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Comparison of generics and interfaces
  prefs: []
  type: TYPE_NORMAL
- en: 'While both generics and interfaces provide code flexibility and polymorphism
    to our code, they have the following main differences:'
  prefs: []
  type: TYPE_NORMAL
- en: Generics are a way to specify the type, while interfaces specify behavior. As
    we have seen, interfaces are collections of methods that must be defined by structs
    in order to satisfy them. On the other hand, generics give us the ability to specify
    the types of parameters that can be used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generics are built into the language, while interfaces are defined by the application.
    Interfaces are defined by engineers as part of their code bases, which makes it
    easier to define them to include any behavior required by the application. The
    specifications of generics are built into the language and can be shared across
    code bases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generics have limited scope, while interfaces have a wide scope. As they are
    built into the language, they are simple enough to implement solutions to a wide
    variety of problems. On the other hand, interfaces are expressive and can define
    complex behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both generics and interfaces are implemented by the Go compiler, so they are
    both statically type-checked. However, interfaces ensure that specific methods
    are available for a parameter, while generics do not provide these guarantees.
  prefs: []
  type: TYPE_NORMAL
- en: Generics in Go
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ability to write generic code is a core part of other strongly typed programming
    languages such as Java, C#, and C++. Its addition to Go gives us the ability to
    write more flexible and reusable code. Let us look at some examples of how we
    can leverage this new ability.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main components for specifying generic code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`T`, and allow us to reference the placeholder type in our implementation.
    A generic function or type is defined by this placeholder as part of its specification.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Type constraints** help us define rules or subtypes for the type parameters.
    Constraints are not full specifications like interfaces, but they allow us to
    restrict type parameters to certain properties.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Type arguments** are the type that is passed to the generic function or type
    upon invocation, which specifies the type of data we will be using. Type arguments
    are used in place of the type parameter placeholders declared by the function
    or type signature.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Type inference** is the process that takes place under the hood to determine
    the type of a variable, without its explicit type specification. This also allows
    us to write less verbose generic code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These four components work together to make it easy for us to write generic
    code. *Figure 11**.2* demonstrates each component with a simple example of a generic
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Generics example on a simple function ](img/Figure_11.2_B18371.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Generics example on a simple function
  prefs: []
  type: TYPE_NORMAL
- en: The example defines a generic `sum` function that takes in two parameters. It
    defines a type parameter, `T`, which must satisfy the specified type constraints.
    In the `main` function, we invoke the function with an `int64` type argument and
    two parameters. The compiler uses type inference to ensure that the passed parameters
    comply with the type constraint and replace the type parameter with the type argument
    supplied in the `main` function. We will explore how to write and test generic
    Go code in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring type constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Type constraints are a central component of generics, as they allow us to limit
    the data types that our generic code can be used with. This makes it easier for
    us to write safe and simple code that operates on types that meet specified conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type parameters are declared inside square brackets (`[]`) in Go. The type
    parameter defines a name and possible constraints for a type. We can declare constraints
    in a few ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `any` interface is an alias for the empty interface, `interface{}`, and
    allows all types to be used. This allows us to build functions and types without
    constraints. For example, we can make the `sum` function accept any parameter
    type by using the `any` interface:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `comparable` interface is a pre-declared type constraint that denotes types
    that can be compared using the `==` operator. These types are `string`, `bool`,
    all numbers, and composite types containing comparable fields. For example, the
    `sum` function will now allow these types as parameters, but we will need to implement
    the sum logic accordingly, as the `+` operator will no longer be implemented by
    all these types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`|` operator. This allows us to create constraints that contain multiple types
    without having to wrap them in a custom interface. This is the example we have
    seen in *Figure 11**.2*, where the `sum` function allows the `int64` and `float64`
    types, which already support the `+` operator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`|` operator. For example, the `Number` interface allows the `int64` and `float64`
    types, which we can then use in the specification of the `sum` function, resulting
    in the same specification as the previous type sets:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `~` keyword can be used to restrict all custom types that have the same
    underlying type. This allows us to encompass custom types into our constraints.
    For example, the `Number` interface will now allow any `int`- and `float64`-based
    types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `constraints` package defines some useful constraints that can be used
    together with your generic code. This package contains numerical and ordered constraints
    that you might find useful. For example, we can modify the `sum` function to accept
    all signed integers by using this package:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Generics can be applied to functions and structs, allowing us to create generic
    data structures and reusable behaviors. This can streamline our code and remove
    the need to define code multiple times in order to accommodate different types
    of underlying data. In [*Chapter 10*](B18371_10.xhtml#_idTextAnchor218), *Testing
    Edge Cases*, we implemented a function that sorts map values based on key values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This very useful function has a major limitation in that it only works for a
    single type of map with an `int` key and a `string` value – `map[int]string`.
    This limitation makes it difficult to reuse this code for other map types.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the days before Go generics, we would have to create a function for each
    type of map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Since Go does not allow function overriding, we also need to use different names
    for the function taking different parameters. This can make it difficult to create
    libraries, even if we extract helper functions to help us reuse the implementation
    code inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is much simplified by generics, which allow us to parameterize the key
    and value types of the sort function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The signature of the function has been changed to leverage the power of generics
    to create a reusable function:'
  prefs: []
  type: TYPE_NORMAL
- en: The function has two type parameters, one for the key type and one for the value
    type. The key value is restricted to any `int` type using the `~` keyword, while
    the value is opened to any type that complies using the `comparable` interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `map` parameter is declared using the key and value placeholder types, `map[K]V`.
    Only parameters that comply with the type constraints will be accepted by the
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return value of the function is adjusted to return a slice of value types,
    `[]V`. This ensures that values returned are of the type as passed in by the input
    map.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we open up our functions to receive generic types, it is also important
    to apply meaningful constraints to ensure that our code continues to provide useful
    functionality. The function signature also serves as a user manual for callers,
    so we should continue to guide them, even though we are adding flexibility to
    our code.
  prefs: []
  type: TYPE_NORMAL
- en: Table-driven testing revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand the basics of implementing generic code, we can turn
    our attention to testing it. The adoption of generics throughout the Go community
    is still in its beginning stages. We have already established that generic code
    is statically enforced by the compiler, but does this increase in flexibility
    lead to more complex test code?
  prefs: []
  type: TYPE_NORMAL
- en: We can continue our exploration using the generic `GetSortedValues` function
    that we have implemented. Tests should now be written to assert the behavior of
    the function for a variety of input types and values. We can achieve this by using
    the table-driven testing technique that we explored in [*Chapter 4*](B18371_04.xhtml#_idTextAnchor085),
    *Building Efficient Test Suites*. The implementation of generic table-driven testing
    follows a series of steps.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – defining generic test cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We begin by creating a generic test case type to save our input map and values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: A generic test case allows us to construct an input map with the correct key
    and value type constraints, which are the same as we have used for the generic
    `GetSortedValues` function. We will use the input map as a parameter for the UUT.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – creating test cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we remember from our introduction to table-driven testing, we typically
    construct a map of test cases with the scenarios that we will be running our tests
    over. Due to the differences in type, we construct multiple test case maps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create two maps with three scenarios each. The first `testCase`
    map has an `int` key type and a `string` value type. The second `testCase` map
    has an `int`-based custom type, `CustomI`. These are two possible combinations
    of key and value types. We can extend these types and scenario combinations as
    much as we want.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – implementing a generic test run function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step required is to write a test helper function that contains all
    the logic for looping over the map of test cases and asserting the functionality
    of the `GetSortedValues` function. Usually, this functionality is contained inside
    the test body, but we will extract a function, as we have multiple input maps
    that we need to process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `runTests` function has the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function signature takes two type parameters for the key and value types.
    They have the same type constraints as the test case type we have declared. It
    takes in two parameters: the `*testing.T` runner and the map of test cases, with
    the same key and value type parameters.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This function is marked as a helper using `t.Helper` so that it does not pollute
    test output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We loop over the map of test cases and run each in its own subtest using the
    `t.Run` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The rest of the function body is the same as any test implementation. We invoke
    the function under test and assert the order of the elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Step 4 – putting everything together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With all our building blocks in place, we can write our first generic test
    for the `GetSortedValues` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The test contains a subtest for each combination of key and value types. Inside
    the subtest, we create the map of test cases and invoke the `runTests` function
    with the correct parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Step 5 – running the test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last step is to run the test to see our generic code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The usage of subtests gives us structured output for our test run. We have also
    easily adapted table-driven testing to use generics to be able to test our `GetSortedValues`
    function with different types of input values.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen from this simple example, the power of generics extends to test
    code. Another interesting use of generics is for creating test utilities. We will
    look at an example of this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Test utilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The test assertion libraries we have been using so far, `testify` and `ginkgo`,
    were written before the introduction of Go generics. They use reflection to implement
    comparisons and assertions on variables. While this is a powerful tool, it can
    be difficult to use to write our own assertions and test utilities. The introduction
    of generics has made this process much easier, so we can easily create our own
    test utilities to reuse them in our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Reflection in a nutshell
  prefs: []
  type: TYPE_NORMAL
- en: Reflection is the ability of a program to analyze and manipulate program elements
    at runtime. This gives us the ability to inspect types, modify behavior, and test
    code. The Go standard library provides the `reflect` package, which provides functionality
    for implementing reflection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing our example from `TestGetSortedValues` we wrote previously, we can
    streamline our `runTests` helper by extracting a test utility that we can use
    in other tests. We can easily create our own generic test helper for asserting
    that the order of our keys and values is as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We extract the code and use two type parameters for the key and value type.
    We use the same technique as writing our `runTests` helper, but extract only the
    code that asserts on map value ordering. This test helper still takes the test
    runner `*testing.T` as a parameter, allowing it to fail tests in the case that
    the assertions inside it fail.
  prefs: []
  type: TYPE_NORMAL
- en: In the absence of generics, we would have to use the empty interface, `interface{}`,
    to allow our test to take in a variety of parameters. This does not allow us to
    write type-safe code, so writing helpers is more difficult and error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: Generics can help us streamline our application and test code. As we have seen
    in this section, we can use it to extend the technique of table-driven testing
    to allow us to write tests that cover a variety of input types and scenarios.
    We have also seen how generics can be used to create our own test utilities.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the BookSwap application with generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen how to write a generic function and use generics to write
    easier test utilities. This has already proven to be a very powerful mechanism,
    providing us with both flexibility and type safety, something which cannot be
    achieved by an empty interface. In this section, we will learn how to make use
    of generics in our example REST API, the `BookSwap` application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us suppose that the `BookSwap` application wants to extend its business
    model and begin swapping magazines, alongside its regular books business model.
    *Figure 11**.3* presents the new system diagram for the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – The extended BookSwap application ](img/Figure_11.3_B18371.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – The extended BookSwap application
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example considers the `BookSwap` application’s monolithic architecture,
    but the same kind of considerations would apply to microservices architectures
    as well. Changes would have to be made throughout the application to support a
    new model, starting from the database level:'
  prefs: []
  type: TYPE_NORMAL
- en: A `Magazines` database table will be created. Just like the `Books` table, it
    will have a foreign key dependency on the `Users` primary key, `id`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MagazineService` will be created to interact with the database queries. Just
    like `BookService`, it will support upsert, list, and swap operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UserService` will have a dependency on `MagazineService`, allowing it to perform
    operations on this service and send information onward to the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PostingService` will need to handle both `Magazine` and `Book` when they are
    successfully swapped. Since this service is external, we can assume that this
    information will be transferred through an HTTP request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of these changes do require dedicated code since we wouldn’t want to make
    magazines and books too tightly coupled. One example of where we might leverage
    generics is during the construction of the HTTP response. So far, `Response` has
    consisted of only the `Books` items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We populate the `Books` slice with the books returned from `BookService`. We
    now need to extend the `Response` struct to be able to handle `Magazines` as well.
    `Response` is a widely used type, so it would be a good candidate for a generic
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a `ResponseItemType` custom constraint, which contains a set of the
    `db.Book` and `db.Magazine` types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If more types are added, then we can add them to this custom type constraint
    and use them throughout the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we use `ResponseItemType` as the type parameter of `Response`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We use the placeholder, `T`, as the type of the response, which is then used
    as the type of the `Items` slice. The `Items` slice is now able to contain both
    the `db.Book` and `db.Magazine` types. All other functions that interact with
    `Response` will now also need to handle the generic `Response`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add the same type parameter to the `writeResponse` function, which is responsible
    for populating data in `Response`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The generic function simply passes the type to the response and no other changes
    are required for the implementation logic. The type either needs to be supplied
    or sent through as a placeholder.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the calling side, we also need to handle the generic aspects. Each handler
    makes use of the `writeResponse` function to populate data on `Response` and return
    it to the client. The `ListBooks` handler demonstrates how to handle this on the
    calling side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The handlers responsible for books will handle response writing in a similar
    way. We pass the `db.Book` type to `Response` and invoke the `writeResponse` function.
    We do not need to pass a type argument to this function, as the type can be inferred
    from the invocation on the `Response` parameter. In the case of an error, we write
    the error to `Response` and return it, stopping execution. In the happy path case,
    we write the books to the `Items` slice.
  prefs: []
  type: TYPE_NORMAL
- en: The `Magazine` handlers will be implemented in the same way using the `db.Magazine`
    type instead. We can use the same table-testing technique we have explored in
    previous sections for testing our response logic.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the end of our exploration with generic code in Go. This powerful
    tool allows us to write flexible code, which can be used with different data types.
    When it comes to generic code, we should always keep in mind that it needs to
    be tested against different types of input parameters, not just different values.
    This can make testing more complicated, but we can still easily modify the popular
    technique of table-driven testing to test generic code.
  prefs: []
  type: TYPE_NORMAL
- en: Testing best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This brings us to the end of this chapter and the end of our exploration of
    Go with TDD. We have had an amazing journey, having studied many libraries and
    techniques and applied them to our `BookSwap` application, as well as smaller
    examples. In this final section, we will recap the lessons learned and formulate
    some testing best practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Achieving a comprehensive testing strategy requires constant effort and a cultural
    shift within an organization to embrace quality and prioritize testing. *Figure
    11**.4* presents a summary of some of the best practices we have explored divided
    into three different categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Development, testing, and culture best practices ](img/Figure_11.4_B18371.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Development, testing, and culture best practices
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed 14 best practices throughout this book, which have been divided
    into 3 categories – development, testing, and culture.
  prefs: []
  type: TYPE_NORMAL
- en: Development best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some best practices for development (as seen in *Figure 11**.4*):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use TDD to write tests during the development process**: The best way to
    ensure that the code we write is tested is to include it in the development process.
    Code is never delivered untested and developers write testable, well-designed
    code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Use interfaces to wrap dependencies**: Our code will often have dependencies
    on other components. It is a good practice to have dependencies external to our
    package wrapped by interfaces so that they can be easily replaced, either by test
    code or with another dependency. We have explored dependencies and interfaces
    in [*Chapter 3*](B18371_03.xhtml#_idTextAnchor061), *Mocking and* *Assertion Frameworks*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Refactor code to tackle technical debt**: Code should be refactored alongside
    new feature development to ensure that it stays performant, readable, and easy
    to maintain. We explored some refactoring techniques in [*Chapter 7*](B18371_07.xhtml#_idTextAnchor162),
    *Refactoring in Go*. Tests will ensure that no functionality is broken by the
    refactoring process.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Write robust code that is able to handle a variety of inputs**: We discussed
    what code robustness is in [*Chapter 10*](B18371_10.xhtml#_idTextAnchor218), *Testing
    Edge Cases*. It should be able to handle a wide variety of inputs and respond
    with well-formulated errors.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Adopt generics for easier code reuse**: As we have seen in this chapter,
    generics allow us to write code that is able to handle different data inputs.
    This allows us to use reusable code, which works for a variety of type parameters.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Testing best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some best practices for testing (as seen in *Figure 11**.4*):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Write simple, isolated tests**: Tests should be simple and isolated from
    their dependencies. This allows us to avoid setting up a large number of services,
    which can be cumbersome and are likely to change. Instead, we should write focused
    tests that make use of mocks to test the UUT in isolation. We explored mocks and
    dependencies in [*Chapter 3*](B18371_03.xhtml#_idTextAnchor061), *Mocking and*
    *Assertion Frameworks*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Use table-driven tests to cover a variety of scenarios**: The popular technique
    of writing table-driven testing is to easily create a list of test cases and run
    through them. Test cases should be run in their own subtests to create a well-structured
    test output. We explored this technique in [*Chapter 4*](B18371_04.xhtml#_idTextAnchor085),
    *Building Efficient Test Suites*, as well as this chapter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Write tests at every level of the application**: Unit tests are fast, but
    they only assert that the functionality of a given package is correct, not that
    it is able to function correctly with other units. As depicted by the testing
    pyramid presented in [*Chapter 1*](B18371_01.xhtml#_idTextAnchor015), *Getting
    to Grips with Test-Driven Development*, we should write automated tests that assert
    that the individual units of the application integrate and function correctly
    together.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`testing` package offers a wide variety of functionality that allows us to
    write functional and non-functional tests. We have explored the capabilities of
    this package throughout this book.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`testify`, `ginkgo`, and `godog`) that complement the standard `testing` package
    and make it easier for us to write test assertions and create mocks.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Culture best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some best practices for culture (as seen in *Figure 11**.4*):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Document customer requirements**: User journeys and customer requirements
    should be at the heart of all the tests we write. As it is nearly impossible to
    write tests that cover every single code path and interaction, engineers should
    ensure that the things that matter to customers are prioritized and covered by
    tests.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Mitigate for errors and unexpected outages**: In microservices architectures,
    it is nearly impossible to ensure that there are zero outages. We should contract-test
    our services, as well as design our microservices architectures according to the
    best practices described in [*Chapter 8*](B18371_08.xhtml#_idTextAnchor179), *Testing
    Microservice Architectures*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Value and prioritize code quality**: As an organization, you should value
    and prioritize code quality, allowing the engineering teams time to refactor their
    services to ensure they can be easily extended and maintained for the future needs
    of the business.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Document non-functional requirements**: While one important use of tests
    is to ensure that our system is able to satisfy functional requirements, another
    important aspect is to verify the performance of our system according to the needs
    of the customers. We explored how to test the performance of our code using benchmarks
    in [*Chapter 2*](B18371_02.xhtml#_idTextAnchor035), *Unit Testing Essentials*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final aspect to remember is that no testing strategy is perfect, as it cannot
    cover every single code path and edge case. The tools and techniques we have explored
    throughout this book should help you plan and implement the efficient testing
    of your system. There is no “one-size-fits-all” approach to a testing strategy,
    so make sure that you work with your product manager and other key business stakeholders
    to ensure that your testing efforts are made efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we spent time exploring Go’s newly introduced generics support.
    We learned the basic syntax for implementing generic code, including how to specify
    type constraints. We also looked at a quick comparison of generic code versus
    writing code using interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we revisited the previously introduced technique of table-driven testing
    and learned how to modify it to support generic code, allowing us to write test
    cases that support different input types and values. We also learned how to make
    use of generics to easily write our own test utilities, promoting code reuse in
    test code as well as implementation code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we summarized all of the tools and techniques we have explored throughout
    this book with 14 best practices divided into 3 categories: development, testing,
    and culture. Implementing and maintaining a comprehensive testing strategy requires
    effort throughout the entire product and engineering organization.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is generics?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the main components of Go generics?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe the steps involved in writing generic table-driven testing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Generic Data Structures and Algorithms in Go: An Applied Approach Using Concurrency,
    Genericity and Heuristics*, by Richard Wiener, published by Apress'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Cloud Native Go: Building Reliable Services in Unreliable Environments*, by
    Matthew Titmus, published by O’Reilly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 1, Getting to Grips with Test-Driven Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The testing pyramid specifies how automated test suites should be structured.
    At the bottom of the pyramid are unit tests, which test a single isolated component.
    Next up in the middle of the pyramid are integration tests, which test that multiple
    components are able to work together as specified. Finally, at the top of the
    test pyramid are end-to-end tests that test the behavior of the entire application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Functional tests cover the correctness of a system, while non-functional tests
    cover the usability and performance of a system. Both types of tests are required
    to ensure that the system satisfies the customers’ needs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The red, green, and refactor TDD approach refers to the three phases of the
    process. The red phase involves writing a new failing test for the functionality
    we intend to implement. The green phase involves writing enough implementation
    code to make all tests pass. Finally, the refactor phase involves optimizing both
    implementation and testing code to remove duplication and come up with better
    solutions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Acceptance test-driven development. Just like TDD, ATDD puts tests first. ATDD
    is related to TDD, but it involves writing a suite of acceptance tests before
    the implementation begins. It involves multiple stakeholders to ensure that the
    acceptance test captures the customer’s requirements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code coverage is the percentage of your lines of code that are exercised by
    your unit test. This is calculated by considering the function statements, parameter
    values, and execution paths of your code. The Go test runner outputs the calculated
    code coverage. We should aim for a good value, but optimizing for 100% is normally
    not appropriate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 2, Unit Testing Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Go, a module is a collection of packages that should be built and released
    together. A package is a collection of Go files that must be built together. A
    module is specified by a `go.mod` file, while a package is specified by the package
    declaration at the top of the source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The additional test package is a package that matches the name of the source
    package with the `_test` suffix added. The additional test package provides isolation
    between test code and source code, preventing brittle tests and allowing developers
    to see the integrations with their packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Test signatures have only a few requirements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The test name must begin with the word `Test`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Any other name that follows the `Test` must also be capitalized
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: There must only be one parameter of the `*testing.T` type and no return type
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Subtests are tests that run within an enclosing test. They are created by passing
    a name and corresponding function to the `t.Run` method on the enclosing test.
    A failure in a subtest will cause the failure of the enclosing test as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Benchmarks are a way to measure the performance of our code. Go’s test runner
    will repeatedly run the instrumented function until it finds stable measurements
    for the performance of the benchmarked function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 3, Mocking and Assertion Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code examples included in this book are publicly available at [https://github.com/PacktPublishing/Test-Driven-Development-in-Go](https://github.com/PacktPublishing/Test-Driven-Development-in-Go).
    You can find the implemented
  prefs: []
  type: TYPE_NORMAL
- en: solution from the Question section in the `chapter03-solution` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4, Building Efficient Test Suites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An edge case is a test case that occurs at extreme values of an operating parameter.
    A corner case occurs at the extreme values of multiple operating parameters. As
    corner cases occur when multiple edge cases occur, they are much less likely to
    occur than edge cases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An idempotent operation is an operation that can be repeated multiple times
    without changing the initial result. These operations are predominant in API design,
    which can often involve retries and resending requests due to network conditions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Go, error handling is done using the built-in `error` type. Errors are handled
    as part of regular code flow, where errors are handled just like any other return
    value, most often alongside other values using multiple return values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Table-driven testing is a popular technique that allows us to test multiple
    scenarios in a unified way, which reduces code duplication. Custom types are created,
    which represent the inputs and expected outputs of the particular test scenario.
    These are then saved in a test collection. The test collection is run over, with
    each case being identically executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, Go tests in different packages are run in parallel. Test cases within
    a package can be marked to be run in parallel using the `t.Parallel()` method
    of the `*testing.T` instance. This allows tests that are marked accordingly to
    be run in parallel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 5, Performing Integration Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integration tests cover multiple units of the system, ensuring that they work
    well together. End-to-end tests replicate user behavior on the system as a whole.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: BDD is a branch of TDD that focuses on writing human-readable tests and involve
    a variety of stakeholders from across the business. The most important part of
    BDD is establishing a common vocabulary that is shared across the business.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, it is considered an anti-pattern to mock databases. They are complex systems
    that are difficult to mock and replicate. In general, tests should use the same
    database as in production.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A container is a unit of software and all its dependencies, specified by a container
    image. Docker Engine starts up and manages containers on top of the operating
    system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 6, End-to-End Testing the BookSwap Web Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A user journey is a path that a user may take to achieve their goal while using
    a given application. Identifying user journeys allows us to write E2E tests that
    correctly replicate and verify the user experience on our platform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ORM stands for object-relational mapping and is a technique that allows us to
    bridge the gap between object-oriented languages and relational databases. It
    allows developers to interact with the database types as just any other custom
    type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Docker Compose allows us to easily define and network multi-container applications.
    Dockerfiles define the steps to building a single container image, while Docker
    Compose allows us to define services with a single configuration and command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Database seeding involves adding initial data to a database. Often, this dummy
    data is generated and changes between test runs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 7, Refactoring in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code redesign involves changing the functionality of an existing service, while
    code refactoring involves changing the internal structure of an existing service,
    without changing its existing functionality. Code redesign changes the *what*,
    while code refactoring changes the *how*. If done correctly, code refactoring
    will not be visible outside the refactored code scope.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The developer starts by identifying the change they wish to make. Then, they
    modify their implementation or test code. Once this is done and the code compiles,
    they then run their test suite. If the suite is passing, the code refactor has
    been successful. However, if the suite is not passing, the developer revisits
    their code change, adjusting it together with the test code until the test suite
    is passing. No change is released until the test suite successfully verifies the
    change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Technical debt is the term used to refer to code that has not been written to
    the technical team’s typical high standards of quality. It typically occurs when
    the team prioritizes speedy delivery over taking the time to design a high-quality
    solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A monolithic application is a single application that is built and released
    as a single unit. A microservice architecture is a system design pattern that
    involves building independently built and released units. Organizations typically
    start with monolithic applications and then move to microservice architectures
    as needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 8, Testing Microservice Architectures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional testing ensures that the features of the system work correctly. Non-functional
    testing verifies that other aspects of the system behave as expected. The two
    main types of non-functional testing are performance tests and usability tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Performance testing relies on key metrics to quantify and compare the performance
    of the application. Important key metrics to monitor are response time, error
    rate, concurrent users, data throughput, and CPU/memory usage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Performance testing ensures that the system is scalable by measuring the performance
    of the individual parts of the system, allowing us to identify bottlenecks and
    improvements required. Furthermore, testing at higher loads of the system allows
    us to estimate the limits of what the system can handle, and helps us understand
    what the growth runway of the current system configuration is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Microservice architectures provide scalability benefits because they allow the
    different parts of our system to be scaled independently. They also allow easier
    maintenance and provide increased delivery speed, as engineering teams can own
    and change their services without any central oversight. On the other hand, they
    introduce complexity in every part of the software life cycle
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Development complexity as engineers need to structure multiple code bases, then
    implement and test features across multiple services.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Deployment complexity as each service has its own infrastructure to be maintained.
    Automation of the release pipelines becomes essential in order to make it easy
    for engineers to release multiple services.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Organizational complexity as engineers must handle increased ownership of multiple
    services. While teams are able to deliver features on multiple services without
    any central oversight, they must also communicate to establish common technical
    standards, suitable for a variety of microservices.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Contract testing is a testing technique that allows us to reliably test the
    interaction between two services. The consumer initiates the exchange and sends
    the request, while the provider processes the request and sends back the response.
    The exchange is recorded in a contract on the consumer side. Then, the contract
    is verified on the provider side against the real implementation. One of the key
    advantages of contract testing is that it allows us to verify the integration
    between two services without having to run and maintain the test against real
    implementations of both the consumer and provider.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 9, Challenges of Testing Concurrent Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concurrency refers to a program’s ability to execute more than one task, with
    interruptions and without any ordering guarantees. Parallelism refers to a program’s
    ability to execute more than one task, simultaneously and without interruptions.
    The OS (or even in silico implementations such as hyperthreading) may give the
    illusion of parallelism through pre-emptive multitasking. However, in order for
    parallelism to be truly simultaneous, multiple computational resources are required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Channels support three operations. The send operation writes information to
    the channel, while the receive operation reads information from the channel. The
    close operation signals to all receivers that no more values will be sent through
    it. Once closed, channels can never be reopened. For unbuffered channels, send
    and receive operations are synchronous and will only complete once both sender
    and receiver are available. On closed channels, sends will panic, while receives
    will immediately complete with the zero value of the channel’s data type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sync.Mutex` is a lock that exposes the `Lock` and `Unlock` methods. Goroutines
    will block until they can acquire the lock successfully. `sync.WaitGroup` is a
    specialized lock that maintains an inner counter that will block until the inner
    counter of `WaitGroup` reaches 0 by calling `Done` on `WaitGroup` the appropriate
    number of times. `sync.WaitGroup` allows us to wait for multiple goroutines to
    complete, in a simpler and more compact way than reading from channels or shared
    memory.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A data race occurs when multiple goroutines access and modify a shared resource.
    This can lead to inconsistent values and hard-to-detect bugs. A deadlock occurs
    when goroutines are blocked, waiting for a resource that never becomes available.
    If the whole program becomes blocked, the Go runtime will detect the deadlock
    and shut down the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go’s race detector is integrated into the `go` tool chain and is enabled with
    the `–race` command-line flag. It instruments memory access and reports when data
    races are detected. As it significantly increases the CPU and memory usage of
    the applications it instruments, the race detector should not be used in production.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 10, Testing Edge Cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A robust system is one that continues to function correctly, even when supplied
    with unexpected or exceptional inputs. When errors or unexpected inputs occur,
    the system is able to handle them gracefully without panics and return meaningful
    errors. Robust code is readable, maintainable, and easy to test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fuzz testing is a software testing technique that involves generating a large
    amount of random data, which is then passed to the fuzz target in an attempt to
    verify its behavior against a wide range of parameters. Fuzz testing makes it
    easier to uncover bugs by reducing the number of tests we need to write manually
    to cover edge cases of input variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A fuzzed test begins with the `Fuzz` prefix, takes in a single `*testing.F`
    parameter, and returns no values. Just like other tests, they must be defined
    inside `_test.go` files. They are run using the `go` `test` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Property-based testing is a technique that involves the generation and verification
    of input values that satisfy a set of system properties or specifications. This
    allows us to test a wide variety of edge cases that are relevant to our system
    without the need to manually write and maintain a large number of tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the viewpoint of the UUT, untrusted inputs are any values that the UUT
    receives or that it uses that it has not generated. These inputs can be good candidates
    for fuzzing arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 11, Working with Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generics is the ability to write code that is able to be used with different
    data types without being limited to a single type. It is a powerful mechanism,
    supported by most programming languages, and allows us to write flexible, reusable
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The main components of Go generics are type parameters, type constraints, type
    arguments, and type inferences:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type parameters are the placeholder types that will be used in our generic code,
    typically denoted by a single letter.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Type constraints restrict the types that can be used with our generic function
    or type.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Type arguments are the types that are passed to the function upon invocation.
    They replace the type parameters and satisfy the type constraints.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Type inference is the process that takes place under the hood to determine the
    type of a variable, without us needing to explicitly declare it. This makes generic
    code less verbose.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Testing generic code with table-driven tests will often involve writing test
    cases with different type parameters. To support this, we define generic test
    case types that can contain different input types. Then, a generic test run function
    that is able to run over the generic test cases and interact with the input types
    should be created. Test cases should be run in subtests, ensuring that test runs
    have a structured output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
